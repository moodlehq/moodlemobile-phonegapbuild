webpackJsonp([39],{

/***/ 1001:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MoodleMobileApp; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_status_bar__ = __webpack_require__(588);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_splash_screen__ = __webpack_require__(589);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_app__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_events__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_login_providers_helper__ = __webpack_require__(41);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








var MoodleMobileApp = /** @class */ (function () {
    function MoodleMobileApp(platform, statusBar, splashScreen, logger, eventsProvider, loginHelper, appProvider) {
        this.platform = platform;
        this.eventsProvider = eventsProvider;
        this.loginHelper = loginHelper;
        this.appProvider = appProvider;
        // Use page name (string) because the page is lazy loaded (Ionic feature). That way we can load pages without importing them.
        // The downside is that each page needs to implement a ngModule.
        this.rootPage = 'CoreLoginInitPage';
        this.lastUrls = {};
        this.logger = logger.getInstance('AppComponent');
        platform.ready().then(function () {
            // Okay, so the platform is ready and our plugins are available.
            // Here you can do any higher level native things you might need.
            statusBar.styleDefault();
            splashScreen.hide();
        });
    }
    /**
     * Component being initialized.
     */
    MoodleMobileApp.prototype.ngOnInit = function () {
        var _this = this;
        // Go to sites page when user is logged out.
        this.eventsProvider.on(__WEBPACK_IMPORTED_MODULE_5__providers_events__["a" /* CoreEventsProvider */].LOGOUT, function () {
            _this.appProvider.getRootNavController().setRoot('CoreLoginSitesPage');
        });
        // Listen for session expired events.
        this.eventsProvider.on(__WEBPACK_IMPORTED_MODULE_5__providers_events__["a" /* CoreEventsProvider */].SESSION_EXPIRED, function (data) {
            _this.loginHelper.sessionExpired(data);
        });
        // Listen for passwordchange and usernotfullysetup events to open InAppBrowser.
        this.eventsProvider.on(__WEBPACK_IMPORTED_MODULE_5__providers_events__["a" /* CoreEventsProvider */].PASSWORD_CHANGE_FORCED, function (data) {
            _this.loginHelper.openInAppForEdit(data.siteId, '/login/change_password.php', 'core.forcepasswordchangenotice', true);
        });
        this.eventsProvider.on(__WEBPACK_IMPORTED_MODULE_5__providers_events__["a" /* CoreEventsProvider */].USER_NOT_FULLY_SETUP, function (data) {
            _this.loginHelper.openInAppForEdit(data.siteId, '/user/edit.php', 'core.usernotfullysetup');
        });
        // Listen for sitepolicynotagreed event to accept the site policy.
        this.eventsProvider.on(__WEBPACK_IMPORTED_MODULE_5__providers_events__["a" /* CoreEventsProvider */].SITE_POLICY_NOT_AGREED, function (data) {
            _this.loginHelper.sitePolicyNotAgreed(data.siteId);
        });
        // Check URLs loaded in any InAppBrowser.
        this.eventsProvider.on(__WEBPACK_IMPORTED_MODULE_5__providers_events__["a" /* CoreEventsProvider */].IAB_LOAD_START, function (event) {
            _this.loginHelper.inAppBrowserLoadStart(event.url);
        });
        // Check InAppBrowser closed.
        this.eventsProvider.on(__WEBPACK_IMPORTED_MODULE_5__providers_events__["a" /* CoreEventsProvider */].IAB_EXIT, function () {
            _this.loginHelper.waitingForBrowser = false;
            _this.loginHelper.lastInAppUrl = '';
            _this.loginHelper.checkLogout();
        });
        this.platform.resume.subscribe(function () {
            // Wait a second before setting it to false since in iOS there could be some frozen WS calls.
            setTimeout(function () {
                _this.loginHelper.waitingForBrowser = false;
                _this.loginHelper.checkLogout();
            }, 1000);
        });
        // Handle app launched with a certain URL (custom URL scheme).
        window.handleOpenURL = function (url) {
            // First check that the URL hasn't been treated a few seconds ago. Sometimes this function is called more than once.
            if (_this.lastUrls[url] && Date.now() - _this.lastUrls[url] < 3000) {
                // Function called more than once, stop.
                return;
            }
            _this.logger.debug('App launched by URL ', url);
            _this.lastUrls[url] = Date.now();
            _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_5__providers_events__["a" /* CoreEventsProvider */].APP_LAUNCHED_URL, url);
        };
        // Listen for app launched URLs. If we receive one, check if it's a SSO authentication.
        this.eventsProvider.on(__WEBPACK_IMPORTED_MODULE_5__providers_events__["a" /* CoreEventsProvider */].APP_LAUNCHED_URL, function (url) {
            _this.loginHelper.appLaunchedByURL(url);
        });
    };
    MoodleMobileApp = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/app/app.html"*/'<ion-nav [root]="rootPage"></ion-nav>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/app/app.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */], __WEBPACK_IMPORTED_MODULE_2__ionic_native_status_bar__["a" /* StatusBar */], __WEBPACK_IMPORTED_MODULE_3__ionic_native_splash_screen__["a" /* SplashScreen */], __WEBPACK_IMPORTED_MODULE_6__providers_logger__["a" /* CoreLoggerProvider */],
            __WEBPACK_IMPORTED_MODULE_5__providers_events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_7__core_login_providers_helper__["a" /* CoreLoginHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_app__["a" /* CoreAppProvider */]])
    ], MoodleMobileApp);
    return MoodleMobileApp;
}());

//# sourceMappingURL=app.component.js.map

/***/ }),

/***/ 1002:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCronDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_network__ = __webpack_require__(102);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__app__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__config__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_constants__ = __webpack_require__(26);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};







/*
 * Service to handle cron processes. The registered processes will be executed every certain time.
*/
var CoreCronDelegate = /** @class */ (function () {
    function CoreCronDelegate(logger, appProvider, configProvider, utils, network) {
        var _this = this;
        this.appProvider = appProvider;
        this.configProvider = configProvider;
        this.utils = utils;
        // Variables for database.
        this.CRON_TABLE = 'cron';
        this.tableSchema = {
            name: this.CRON_TABLE,
            columns: [
                {
                    name: 'id',
                    type: 'TEXT',
                    primaryKey: true
                },
                {
                    name: 'value',
                    type: 'INTEGER'
                }
            ]
        };
        this.handlers = {};
        this.queuePromise = Promise.resolve();
        this.logger = logger.getInstance('CoreCronDelegate');
        this.appDB = this.appProvider.getDB();
        this.appDB.createTableFromSchema(this.tableSchema);
        // When the app is re-connected, start network handlers that were stopped.
        network.onConnect().subscribe(function () {
            _this.startNetworkHandlers();
        });
    }
    CoreCronDelegate_1 = CoreCronDelegate;
    /**
     * Try to execute a handler. It will schedule the next execution once done.
     * If the handler cannot be executed or it fails, it will be re-executed after mmCoreCronMinInterval.
     *
     * @param {string} name Name of the handler.
     * @param {boolean} [force] Wether the execution is forced (manual sync).
     * @param {string}  [siteId] Site ID. If not defined, all sites.
     * @return {Promise<any>} Promise resolved if handler is executed successfully, rejected otherwise.
     */
    CoreCronDelegate.prototype.checkAndExecuteHandler = function (name, force, siteId) {
        var _this = this;
        if (!this.handlers[name] || !this.handlers[name].execute) {
            // Invalid handler.
            this.logger.debug('Cannot execute handler because is invalid: ' + name);
            return Promise.reject(null);
        }
        var usesNetwork = this.handlerUsesNetwork(name), isSync = !force && this.isHandlerSync(name);
        var promise;
        if (usesNetwork && !this.appProvider.isOnline()) {
            // Offline, stop executing.
            this.logger.debug('Cannot execute handler because device is offline: ' + name);
            this.stopHandler(name);
            return Promise.reject(null);
        }
        if (isSync) {
            // Check network connection.
            promise = this.configProvider.get(__WEBPACK_IMPORTED_MODULE_6__core_constants__["a" /* CoreConstants */].SETTINGS_SYNC_ONLY_ON_WIFI, false).then(function (syncOnlyOnWifi) {
                return !syncOnlyOnWifi || !_this.appProvider.isNetworkAccessLimited();
            });
        }
        else {
            promise = Promise.resolve(true);
        }
        return promise.then(function (execute) {
            if (!execute) {
                // Cannot execute in this network connection, retry soon.
                _this.logger.debug('Cannot execute handler because device is using limited connection: ' + name);
                _this.scheduleNextExecution(name, CoreCronDelegate_1.MIN_INTERVAL);
                return Promise.reject(null);
            }
            // Add the execution to the queue.
            _this.queuePromise = _this.queuePromise.catch(function () {
                // Ignore errors in previous handlers.
            }).then(function () {
                return _this.executeHandler(name, siteId).then(function () {
                    _this.logger.debug("Execution of handler '" + name + "' was a success.");
                    return _this.setHandlerLastExecutionTime(name, Date.now()).then(function () {
                        _this.scheduleNextExecution(name);
                    });
                }, function () {
                    // Handler call failed. Retry soon.
                    _this.logger.debug("Execution of handler '" + name + "' failed.");
                    _this.scheduleNextExecution(name, CoreCronDelegate_1.MIN_INTERVAL);
                    return Promise.reject(null);
                });
            });
            return _this.queuePromise;
        });
    };
    /**
     * Run a handler, cancelling the execution if it takes more than MAX_TIME_PROCESS.
     *
     * @param {string} name Name of the handler.
     * @param {string} [siteId] Site ID. If not defined, all sites.
     * @return {Promise<any>} Promise resolved when the handler finishes or reaches max time, rejected if it fails.
     */
    CoreCronDelegate.prototype.executeHandler = function (name, siteId) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var cancelTimeout;
            _this.logger.debug('Executing handler: ' + name);
            // Wrap the call in Promise.resolve to make sure it's a promise.
            Promise.resolve(_this.handlers[name].execute(siteId)).then(resolve).catch(reject).finally(function () {
                clearTimeout(cancelTimeout);
            });
            cancelTimeout = setTimeout(function () {
                // The handler took too long. Resolve because we don't want to retry soon.
                _this.logger.debug("Resolving execution of handler '" + name + "' because it took too long.");
                resolve();
            }, CoreCronDelegate_1.MAX_TIME_PROCESS);
        });
    };
    /**
     * Force execution of synchronization cron tasks without waiting for the scheduled time.
     * Please notice that some tasks may not be executed depending on the network connection and sync settings.
     *
     * @param {string} [siteId] Site ID. If not defined, all sites.
     * @return {Promise<any>} Promise resolved if all handlers are executed successfully, rejected otherwise.
     */
    CoreCronDelegate.prototype.forceSyncExecution = function (siteId) {
        var promises = [];
        for (var name_1 in this.handlers) {
            var handler = this.handlers[name_1];
            if (this.isHandlerManualSync(name_1)) {
                // Mark the handler as running (it might be running already).
                handler.running = true;
                // Cancel pending timeout.
                clearTimeout(handler.timeout);
                delete handler.timeout;
                // Now force the execution of the handler.
                promises.push(this.checkAndExecuteHandler(name_1, true, siteId));
            }
        }
        return this.utils.allPromises(promises);
    };
    /**
     * Get a handler's interval.
     *
     * @param {string} name Handler's name.
     * @return {number} Handler's interval.
     */
    CoreCronDelegate.prototype.getHandlerInterval = function (name) {
        if (!this.handlers[name] || !this.handlers[name].getInterval) {
            // Invalid, return default.
            return CoreCronDelegate_1.DEFAULT_INTERVAL;
        }
        // Don't allow intervals lower than the minimum.
        var minInterval = this.appProvider.isDesktop() ? CoreCronDelegate_1.DESKTOP_MIN_INTERVAL : CoreCronDelegate_1.MIN_INTERVAL, handlerInterval = this.handlers[name].getInterval();
        if (!handlerInterval) {
            return CoreCronDelegate_1.DEFAULT_INTERVAL;
        }
        else {
            return Math.max(minInterval, handlerInterval);
        }
    };
    /**
     * Get a handler's last execution ID.
     *
     * @param {string} name Handler's name.
     * @return {string} Handler's last execution ID.
     */
    CoreCronDelegate.prototype.getHandlerLastExecutionId = function (name) {
        return 'last_execution_' + name;
    };
    /**
     * Get a handler's last execution time. If not defined, return 0.
     *
     * @param {string} name Handler's name.
     * @return {Promise<number>} Promise resolved with the handler's last execution time.
     */
    CoreCronDelegate.prototype.getHandlerLastExecutionTime = function (name) {
        var id = this.getHandlerLastExecutionId(name);
        return this.appDB.getRecord(this.CRON_TABLE, { id: id }).then(function (entry) {
            var time = parseInt(entry.value, 10);
            return isNaN(time) ? 0 : time;
        }).catch(function () {
            return 0; // Not set, return 0.
        });
    };
    /**
     * Check if a handler uses network. Defaults to true.
     *
     * @param {string} name Handler's name.
     * @return {boolean} True if handler uses network or not defined, false otherwise.
     */
    CoreCronDelegate.prototype.handlerUsesNetwork = function (name) {
        if (!this.handlers[name] || !this.handlers[name].usesNetwork) {
            // Invalid, return default.
            return true;
        }
        return this.handlers[name].usesNetwork();
    };
    /**
     * Check if there is any manual sync handler registered.
     *
     * @return {boolean} Whether it has at least 1 manual sync handler.
     */
    CoreCronDelegate.prototype.hasManualSyncHandlers = function () {
        for (var name_2 in this.handlers) {
            if (this.isHandlerManualSync(name_2)) {
                return true;
            }
        }
        return false;
    };
    /**
     * Check if there is any sync handler registered.
     *
     * @return {boolean} Whether it has at least 1 sync handler.
     */
    CoreCronDelegate.prototype.hasSyncHandlers = function () {
        for (var name_3 in this.handlers) {
            if (this.isHandlerSync(name_3)) {
                return true;
            }
        }
        return false;
    };
    /**
     * Check if a handler can be manually synced. Defaults will use isSync instead.
     *
     * @param {string} name Handler's name.
     * @return {boolean} True if handler is a sync process and can be manually executed or not defined, false otherwise.
     */
    CoreCronDelegate.prototype.isHandlerManualSync = function (name) {
        if (!this.handlers[name] || !this.handlers[name].canManualSync) {
            // Invalid, return default.
            return this.isHandlerSync(name);
        }
        return this.handlers[name].canManualSync();
    };
    /**
     * Check if a handler is a sync process. Defaults to true.
     *
     * @param {string} name Handler's name.
     * @return {boolean} True if handler is a sync process or not defined, false otherwise.
     */
    CoreCronDelegate.prototype.isHandlerSync = function (name) {
        if (!this.handlers[name] || !this.handlers[name].isSync) {
            // Invalid, return default.
            return true;
        }
        return this.handlers[name].isSync();
    };
    /**
     * Register a handler to be executed every certain time.
     *
     * @param {CoreCronHandler} handler The handler to register.
     */
    CoreCronDelegate.prototype.register = function (handler) {
        if (!handler || !handler.name) {
            // Invalid handler.
            return;
        }
        if (typeof this.handlers[handler.name] != 'undefined') {
            this.logger.debug("The cron handler '" + name + "' is already registered.");
            return;
        }
        this.logger.debug.debug("Register handler '" + name + "' in cron.");
        handler.running = false;
        this.handlers[handler.name] = handler;
        // Start the handler.
        this.startHandler(name);
    };
    /**
     * Schedule a next execution for a handler.
     *
     * @param {string} name Name of the handler.
     * @param {number} [time] Time to the next execution. If not supplied it will be calculated using the last execution and
     *                        the handler's interval. This param should be used only if it's really necessary.
     */
    CoreCronDelegate.prototype.scheduleNextExecution = function (name, time) {
        var _this = this;
        if (!this.handlers[name]) {
            // Invalid handler.
            return;
        }
        if (this.handlers[name].timeout) {
            // There's already a pending timeout.
            return;
        }
        var promise;
        if (time) {
            promise = Promise.resolve(time);
        }
        else {
            // Get last execution time to check when do we need to execute it.
            promise = this.getHandlerLastExecutionTime(name).then(function (lastExecution) {
                var interval = _this.getHandlerInterval(name), nextExecution = lastExecution + interval;
                return nextExecution - Date.now();
            });
        }
        promise.then(function (nextExecution) {
            _this.logger.debug("Scheduling next execution of handler '" + name + "' in '" + nextExecution + "' ms");
            if (nextExecution < 0) {
                nextExecution = 0; // Big negative numbers aren't executed immediately.
            }
            _this.handlers[name].timeout = setTimeout(function () {
                delete _this.handlers[name].timeout;
                _this.checkAndExecuteHandler(name);
            }, nextExecution);
        });
    };
    /**
     * Set a handler's last execution time.
     *
     * @param {string} name Handler's name.
     * @param {number} time Time to set.
     * @return {Promise}    Promise resolved when the execution time is saved.
     */
    CoreCronDelegate.prototype.setHandlerLastExecutionTime = function (name, time) {
        var id = this.getHandlerLastExecutionId(name), entry = {
            id: id,
            value: time
        };
        return this.appDB.insertOrUpdateRecord(this.CRON_TABLE, entry, { id: id });
    };
    /**
     * Start running a handler periodically.
     *
     * @param {string} name Name of the handler.
     */
    CoreCronDelegate.prototype.startHandler = function (name) {
        if (!this.handlers[name]) {
            // Invalid handler.
            this.logger.debug("Cannot start handler '" + name + "', is invalid.");
            return;
        }
        if (this.handlers[name].running) {
            this.logger.debug("Handler '" + name + "', is already running.");
            return;
        }
        this.handlers[name].running = true;
        this.scheduleNextExecution(name);
    };
    /**
     * Start running periodically the handlers that use network.
     */
    CoreCronDelegate.prototype.startNetworkHandlers = function () {
        for (var name_4 in this.handlers) {
            if (this.handlerUsesNetwork(name_4)) {
                this.startHandler(name_4);
            }
        }
    };
    /**
     * Stop running a handler periodically.
     *
     * @param {string} name Name of the handler.
     */
    CoreCronDelegate.prototype.stopHandler = function (name) {
        if (!this.handlers[name]) {
            // Invalid handler.
            this.logger.debug("Cannot stop handler '" + name + "', is invalid.");
            return;
        }
        if (!this.handlers[name].running) {
            this.logger.debug("Cannot stop handler '" + name + "', it's not running.");
            return;
        }
        this.handlers[name].running = false;
        clearTimeout(this.handlers[name].timeout);
        delete this.handlers[name].timeout;
    };
    // Constants.
    CoreCronDelegate.DEFAULT_INTERVAL = 3600000; // Default interval is 1 hour.
    CoreCronDelegate.MIN_INTERVAL = 300000; // Minimum interval is 5 minutes.
    CoreCronDelegate.DESKTOP_MIN_INTERVAL = 60000; // Minimum interval in desktop is 1 minute.
    CoreCronDelegate.MAX_TIME_PROCESS = 120000; // Max time a process can block the queue. Defaults to 2 minutes.
    CoreCronDelegate = CoreCronDelegate_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_3__config__["a" /* CoreConfigProvider */],
            __WEBPACK_IMPORTED_MODULE_5__utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_1__ionic_native_network__["a" /* Network */]])
    ], CoreCronDelegate);
    return CoreCronDelegate;
    var CoreCronDelegate_1;
}());

//# sourceMappingURL=cron.js.map

/***/ }),

/***/ 1003:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFileSessionProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__sites__ = __webpack_require__(8);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Helper to store some temporary data for file submission.
 *
 * It uses siteId and component name to index the files.
 * Every component can provide a File area identifier to indentify every file list on the session.
 * This value can be the activity id or a mix of name and numbers.
 */
var CoreFileSessionProvider = /** @class */ (function () {
    function CoreFileSessionProvider(sitesProvider) {
        this.sitesProvider = sitesProvider;
        this.files = {};
    }
    /**
     * Add a file to the session.
     *
     * @param {string} component Component Name.
     * @param {string|number} id File area identifier.
     * @param {any} file File to add.
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    CoreFileSessionProvider.prototype.addFile = function (component, id, file, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        this.initFileArea(component, id, siteId);
        this.files[siteId][component][id].push(file);
    };
    /**
     * Clear files stored in session.
     *
     * @param {string} component Component Name.
     * @param {string|number} id File area identifier.
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    CoreFileSessionProvider.prototype.clearFiles = function (component, id, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (this.files[siteId] && this.files[siteId][component] && this.files[siteId][component][id]) {
            this.files[siteId][component][id] = [];
        }
    };
    /**
     * Get files stored in session.
     *
     * @param {string} component Component Name.
     * @param {string|number} id File area identifier.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {any[]} Array of files in session.
     */
    CoreFileSessionProvider.prototype.getFiles = function (component, id, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (this.files[siteId] && this.files[siteId][component] && this.files[siteId][component][id]) {
            return this.files[siteId][component][id];
        }
        return [];
    };
    /**
     * Initializes the filearea to store the file.
     *
     * @param {string} component Component Name.
     * @param {string|number} id File area identifier.
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    CoreFileSessionProvider.prototype.initFileArea = function (component, id, siteId) {
        if (!this.files[siteId]) {
            this.files[siteId] = {};
        }
        if (!this.files[siteId][component]) {
            this.files[siteId][component] = {};
        }
        if (!this.files[siteId][component][id]) {
            this.files[siteId][component][id] = [];
        }
    };
    /**
     * Remove a file stored in session.
     *
     * @param {string} component Component Name.
     * @param {string|number} id File area identifier.
     * @param {any} file File to remove. The instance should be exactly the same as the one stored in session.
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    CoreFileSessionProvider.prototype.removeFile = function (component, id, file, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (this.files[siteId] && this.files[siteId][component] && this.files[siteId][component][id]) {
            var position = this.files[siteId][component][id].indexOf(file);
            if (position != -1) {
                this.files[siteId][component][id].splice(position, 1);
            }
        }
    };
    /**
     * Remove a file stored in session.
     *
     * @param {string} component Component Name.
     * @param {string|number} id File area identifier.
     * @param {number} index Position of the file to remove.
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    CoreFileSessionProvider.prototype.removeFileByIndex = function (component, id, index, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (this.files[siteId] && this.files[siteId][component] && this.files[siteId][component][id] && index >= 0 &&
            index < this.files[siteId][component][id].length) {
            this.files[siteId][component][id].splice(index, 1);
        }
    };
    /**
     * Set a group of files in the session.
     *
     * @param {string} component Component Name.
     * @param {string|number} id File area identifier.
     * @param {any[]} newFiles Files to set.
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    CoreFileSessionProvider.prototype.setFiles = function (component, id, newFiles, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        this.initFileArea(component, id, siteId);
        this.files[siteId][component][id] = newFiles;
    };
    CoreFileSessionProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__sites__["a" /* CoreSitesProvider */]])
    ], CoreFileSessionProvider);
    return CoreFileSessionProvider;
}());

//# sourceMappingURL=file-session.js.map

/***/ }),

/***/ 1004:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreUpdateManagerProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__config__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__filepool__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__init__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__local_notifications__ = __webpack_require__(113);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__sites__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__configconstants__ = __webpack_require__(46);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








/**
 * Factory to handle app updates. This factory shouldn't be used outside of core.
 *
 * This service handles processes that need to be run when updating the app, like migrate Ionic 1 database data to Ionic 3.
 */
var CoreUpdateManagerProvider = /** @class */ (function () {
    function CoreUpdateManagerProvider(logger, configProvider, sitesProvider, filepoolProvider, notifProvider) {
        this.configProvider = configProvider;
        this.sitesProvider = sitesProvider;
        this.filepoolProvider = filepoolProvider;
        this.notifProvider = notifProvider;
        // Data for init delegate.
        this.name = 'CoreUpdateManager';
        this.priority = __WEBPACK_IMPORTED_MODULE_3__init__["a" /* CoreInitDelegate */].MAX_RECOMMENDED_PRIORITY + 300;
        this.blocking = true;
        this.VERSION_APPLIED = 'version_applied';
        this.logger = logger.getInstance('CoreUpdateManagerProvider');
    }
    /**
     * Check if the app has been updated and performs the needed processes.
     * This function shouldn't be used outside of core.
     *
     * @return {Promise<any>} Promise resolved when the update process finishes.
     */
    CoreUpdateManagerProvider.prototype.load = function () {
        var _this = this;
        var promises = [], versionCode = __WEBPACK_IMPORTED_MODULE_7__configconstants__["a" /* CoreConfigConstants */].versioncode;
        return this.configProvider.get(this.VERSION_APPLIED, 0).then(function (versionApplied) {
            // @todo: Migrate all data from ydn-db to SQLite if there is no versionApplied.
            if (versionCode >= 2013 && versionApplied < 2013) {
                promises.push(_this.migrateFileExtensions());
            }
            if (versionCode >= 2017 && versionApplied < 2017) {
                promises.push(_this.setCalendarDefaultNotifTime());
                promises.push(_this.setSitesConfig());
            }
            if (versionCode >= 2018 && versionApplied < 2018) {
                promises.push(_this.adaptForumOfflineStores());
            }
            return Promise.all(promises).then(function () {
                return _this.configProvider.set(_this.VERSION_APPLIED, versionCode);
            }).catch(function (error) {
                _this.logger.error("Error applying update from " + versionApplied + " to " + versionCode, error);
            });
        });
    };
    /**
     * Migrates files filling extensions.
     *
     * @return {Promise<any>} Promise resolved when the site migration is finished.
     */
    CoreUpdateManagerProvider.prototype.migrateFileExtensions = function () {
        var _this = this;
        return this.sitesProvider.getSitesIds().then(function (sites) {
            var promises = [];
            sites.forEach(function (siteId) {
                promises.push(_this.filepoolProvider.fillMissingExtensionInFiles(siteId));
            });
            promises.push(_this.filepoolProvider.treatExtensionInQueue());
            return Promise.all(promises);
        });
    };
    /**
     * Calendar default notification time is configurable from version 3.2.1, and a new option "Default" is added.
     * All events that were configured to use the fixed default time should now be configured to use "Default" option.
     *
     * @return {Promise<any>} Promise resolved when the events are configured.
     */
    CoreUpdateManagerProvider.prototype.setCalendarDefaultNotifTime = function () {
        if (!this.notifProvider.isAvailable()) {
            // Local notifications not available, nothing to do.
            return Promise.resolve();
        }
        // @todo: Implement it once Calendar addon is implemented.
        return Promise.resolve();
    };
    /**
     * In version 3.2.1 we want the site config to be stored in each site if available.
     * Since it can be slow, we'll only block retrieving the config of current site, the rest will be in background.
     *
     * @return {Promise<any>} Promise resolved when the config is loaded for the current site (if any).
     */
    CoreUpdateManagerProvider.prototype.setSitesConfig = function () {
        var _this = this;
        return this.sitesProvider.getSitesIds().then(function (siteIds) {
            return _this.sitesProvider.getStoredCurrentSiteId().catch(function () {
                // Error getting current site.
            }).then(function (currentSiteId) {
                var promise;
                // Load the config of current site first.
                if (currentSiteId) {
                    promise = _this.setSiteConfig(currentSiteId);
                }
                else {
                    promise = Promise.resolve();
                }
                // Load the config of rest of sites in background.
                siteIds.forEach(function (siteId) {
                    if (siteId != currentSiteId) {
                        _this.setSiteConfig(siteId);
                    }
                });
                return promise;
            });
        });
    };
    /**
     * Store the config of a site.
     *
     * @param {String} siteId Site ID.
     * @return {Promise<any>} Promise resolved when the config is loaded for the site.
     */
    CoreUpdateManagerProvider.prototype.setSiteConfig = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            if (site.getStoredConfig() || !site.wsAvailable('tool_mobile_get_config')) {
                // Site already has the config or it cannot be retrieved. Stop.
                return;
            }
            // Get the site config.
            return site.getConfig().then(function (config) {
                return _this.sitesProvider.addSite(site.getId(), site.getURL(), site.getToken(), site.getInfo(), site.getPrivateToken(), config);
            }).catch(function () {
                // Ignore errors.
            });
        });
    };
    /**
     * The data stored for offline discussions and posts changed its format. Adapt the entries already stored.
     * Since it can be slow, we'll only block migrating the db of current site, the rest will be in background.
     *
     * @return {Promise<any>} Promise resolved when the db is migrated.
     */
    CoreUpdateManagerProvider.prototype.adaptForumOfflineStores = function () {
        // @todo: Implement it once Forum addon is implemented.
        return Promise.resolve();
    };
    CoreUpdateManagerProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_1__config__["a" /* CoreConfigProvider */], __WEBPACK_IMPORTED_MODULE_6__sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_2__filepool__["a" /* CoreFilepoolProvider */], __WEBPACK_IMPORTED_MODULE_4__local_notifications__["a" /* CoreLocalNotificationsProvider */]])
    ], CoreUpdateManagerProvider);
    return CoreUpdateManagerProvider;
}());

//# sourceMappingURL=update-manager.js.map

/***/ }),

/***/ 1005:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSyncProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__events__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__sites__ = __webpack_require__(8);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/*
 * Service that provides some features regarding synchronization.
*/
var CoreSyncProvider = /** @class */ (function () {
    function CoreSyncProvider(eventsProvider, sitesProvider) {
        var _this = this;
        this.sitesProvider = sitesProvider;
        this.tableSchema = {
            name: CoreSyncProvider_1.SYNC_TABLE,
            columns: [
                {
                    name: 'component',
                    type: 'TEXT',
                    notNull: true
                },
                {
                    name: 'id',
                    type: 'INTEGER',
                    notNull: true
                },
                {
                    name: 'time',
                    type: 'INTEGER'
                },
                {
                    name: 'warnings',
                    type: 'TEXT'
                }
            ],
            primaryKeys: ['component', 'id']
        };
        // Store blocked sync objects.
        this.blockedItems = {};
        this.sitesProvider.createTableFromSchema(this.tableSchema);
        // Unblock all blocks on logout.
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_1__events__["a" /* CoreEventsProvider */].LOGOUT, function (data) {
            _this.clearAllBlocks(data.siteId);
        });
    }
    CoreSyncProvider_1 = CoreSyncProvider;
    /**
     * Block a component and ID so it cannot be synchronized.
     *
     * @param {string} component Component name.
     * @param {number} id Unique ID per component.
     * @param {string} [operation] Operation name. If not defined, a default text is used.
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    CoreSyncProvider.prototype.blockOperation = function (component, id, operation, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var uniqueId = this.getUniqueSyncBlockId(component, id);
        if (!this.blockedItems[siteId]) {
            this.blockedItems[siteId] = {};
        }
        if (!this.blockedItems[siteId][uniqueId]) {
            this.blockedItems[siteId][uniqueId] = {};
        }
        operation = operation || '-';
        this.blockedItems[siteId][uniqueId][operation] = true;
    };
    /**
     * Clear all blocks for a site or all sites.
     *
     * @param {string} [siteId] If set, clear the blocked objects only for this site. Otherwise clear them for all sites.
     */
    CoreSyncProvider.prototype.clearAllBlocks = function (siteId) {
        if (siteId) {
            delete this.blockedItems[siteId];
        }
        else {
            this.blockedItems = {};
        }
    };
    /**
     * Clear all blocks for a certain component.
     *
     * @param {string} component Component name.
     * @param {number} id Unique ID per component.
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    CoreSyncProvider.prototype.clearBlocks = function (component, id, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var uniqueId = this.getUniqueSyncBlockId(component, id);
        if (this.blockedItems[siteId]) {
            delete this.blockedItems[siteId][uniqueId];
        }
    };
    /**
     * Convenience function to create unique identifiers for a component and id.
     *
     * @param {string} component Component name.
     * @param {number} id Unique ID per component.
     * @return {string} Unique sync id.
     */
    CoreSyncProvider.prototype.getUniqueSyncBlockId = function (component, id) {
        return component + '#' + id;
    };
    /**
     * Check if a component is blocked.
     * One block can have different operations. Here we check how many operations are being blocking the object.
     *
     * @param {string} component Component name.
     * @param {number} id Unique ID per component.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {boolean} Whether it's blocked.
     */
    CoreSyncProvider.prototype.isBlocked = function (component, id, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (!this.blockedItems[siteId]) {
            return false;
        }
        var uniqueId = this.getUniqueSyncBlockId(component, id);
        if (!this.blockedItems[siteId][uniqueId]) {
            return false;
        }
        return Object.keys(this.blockedItems[siteId][uniqueId]).length > 0;
    };
    /**
     * Unblock an operation on a component and ID.
     *
     * @param {string} component Component name.
     * @param {number} id Unique ID per component.
     * @param {string} [operation] Operation name. If not defined, a default text is used.
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    CoreSyncProvider.prototype.unblockOperation = function (component, id, operation, siteId) {
        operation = operation || '-';
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var uniqueId = this.getUniqueSyncBlockId(component, id);
        if (this.blockedItems[siteId] && this.blockedItems[siteId][uniqueId]) {
            delete this.blockedItems[siteId][uniqueId][operation];
        }
    };
    // Variables for the database.
    CoreSyncProvider.SYNC_TABLE = 'sync';
    CoreSyncProvider = CoreSyncProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_2__sites__["a" /* CoreSitesProvider */]])
    ], CoreSyncProvider);
    return CoreSyncProvider;
    var CoreSyncProvider_1;
}());

//# sourceMappingURL=sync.js.map

/***/ }),

/***/ 1006:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreEmulatorModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_camera__ = __webpack_require__(216);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_clipboard__ = __webpack_require__(202);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ionic_native_file__ = __webpack_require__(106);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ionic_native_file_transfer__ = __webpack_require__(214);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ionic_native_globalization__ = __webpack_require__(198);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ionic_native_in_app_browser__ = __webpack_require__(130);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__ionic_native_keyboard__ = __webpack_require__(200);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__ionic_native_local_notifications__ = __webpack_require__(138);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__ionic_native_media_capture__ = __webpack_require__(215);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__ionic_native_network__ = __webpack_require__(102);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__ionic_native_splash_screen__ = __webpack_require__(589);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__ionic_native_status_bar__ = __webpack_require__(588);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__ionic_native_sqlite__ = __webpack_require__(450);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__ionic_native_zip__ = __webpack_require__(213);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_camera__ = __webpack_require__(1007);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_clipboard__ = __webpack_require__(1008);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__providers_file__ = __webpack_require__(1009);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__providers_file_transfer__ = __webpack_require__(590);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__providers_globalization__ = __webpack_require__(1013);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__providers_inappbrowser__ = __webpack_require__(1014);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__providers_local_notifications__ = __webpack_require__(1016);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__providers_media_capture__ = __webpack_require__(1034);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__providers_network__ = __webpack_require__(1035);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__providers_zip__ = __webpack_require__(1036);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__providers_helper__ = __webpack_require__(1085);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__providers_capture_helper__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__providers_app__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__providers_file__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__providers_utils_text__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__providers_utils_mimetype__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__providers_utils_url__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_33__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_34__providers_init__ = __webpack_require__(51);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


// Ionic Native services.














// Services that Mock Ionic Native in browser an desktop.



















/**
 * This module handles the emulation of Cordova plugins in browser and desktop.
 *
 * It includes the "mock" of all the Ionic Native services that should be supported in browser and desktop,
 * otherwise those features would only work in a Cordova environment.
 *
 * This module also determines if the app should use the original service or the mock. In each of the "useFactory"
 * functions we check if the app is running in mobile or not, and then provide the right service to use.
 */
var CoreEmulatorModule = /** @class */ (function () {
    function CoreEmulatorModule(appProvider, initDelegate, helper) {
        var win = window; // Convert the "window" to "any" type to be able to use non-standard properties.
        // Emulate Custom URL Scheme plugin in desktop apps.
        if (appProvider.isDesktop()) {
            __webpack_require__(1086).ipcRenderer.on('mmAppLaunched', function (event, url) {
                if (typeof win.handleOpenURL != 'undefined') {
                    win.handleOpenURL(url);
                }
            });
        }
        if (!appProvider.isMobile()) {
            // Register an init process to load the Mocks that need it.
            initDelegate.registerProcess(helper);
        }
    }
    CoreEmulatorModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [],
            providers: [
                __WEBPACK_IMPORTED_MODULE_26__providers_helper__["a" /* CoreEmulatorHelperProvider */],
                __WEBPACK_IMPORTED_MODULE_27__providers_capture_helper__["a" /* CoreEmulatorCaptureHelperProvider */],
                {
                    provide: __WEBPACK_IMPORTED_MODULE_2__ionic_native_camera__["a" /* Camera */],
                    deps: [__WEBPACK_IMPORTED_MODULE_28__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_27__providers_capture_helper__["a" /* CoreEmulatorCaptureHelperProvider */]],
                    useFactory: function (appProvider, captureHelper) {
                        return appProvider.isMobile() ? new __WEBPACK_IMPORTED_MODULE_2__ionic_native_camera__["a" /* Camera */]() : new __WEBPACK_IMPORTED_MODULE_16__providers_camera__["a" /* CameraMock */](captureHelper);
                    }
                },
                {
                    provide: __WEBPACK_IMPORTED_MODULE_3__ionic_native_clipboard__["a" /* Clipboard */],
                    deps: [__WEBPACK_IMPORTED_MODULE_28__providers_app__["a" /* CoreAppProvider */]],
                    useFactory: function (appProvider) {
                        return appProvider.isMobile() ? new __WEBPACK_IMPORTED_MODULE_3__ionic_native_clipboard__["a" /* Clipboard */]() : new __WEBPACK_IMPORTED_MODULE_17__providers_clipboard__["a" /* ClipboardMock */](appProvider);
                    }
                },
                {
                    provide: __WEBPACK_IMPORTED_MODULE_4__ionic_native_file__["a" /* File */],
                    deps: [__WEBPACK_IMPORTED_MODULE_28__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_30__providers_utils_text__["a" /* CoreTextUtilsProvider */]],
                    useFactory: function (appProvider, textUtils) {
                        // Use platform instead of CoreAppProvider to prevent circular dependencies.
                        return appProvider.isMobile() ? new __WEBPACK_IMPORTED_MODULE_4__ionic_native_file__["a" /* File */]() : new __WEBPACK_IMPORTED_MODULE_18__providers_file__["a" /* FileMock */](appProvider, textUtils);
                    }
                },
                {
                    provide: __WEBPACK_IMPORTED_MODULE_5__ionic_native_file_transfer__["a" /* FileTransfer */],
                    deps: [__WEBPACK_IMPORTED_MODULE_28__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_29__providers_file__["a" /* CoreFileProvider */]],
                    useFactory: function (appProvider, fileProvider) {
                        // Use platform instead of CoreAppProvider to prevent circular dependencies.
                        return appProvider.isMobile() ? new __WEBPACK_IMPORTED_MODULE_5__ionic_native_file_transfer__["a" /* FileTransfer */]() : new __WEBPACK_IMPORTED_MODULE_19__providers_file_transfer__["b" /* FileTransferMock */](appProvider, fileProvider);
                    }
                },
                {
                    provide: __WEBPACK_IMPORTED_MODULE_6__ionic_native_globalization__["a" /* Globalization */],
                    deps: [__WEBPACK_IMPORTED_MODULE_28__providers_app__["a" /* CoreAppProvider */]],
                    useFactory: function (appProvider) {
                        return appProvider.isMobile() ? new __WEBPACK_IMPORTED_MODULE_6__ionic_native_globalization__["a" /* Globalization */]() : new __WEBPACK_IMPORTED_MODULE_20__providers_globalization__["a" /* GlobalizationMock */](appProvider);
                    }
                },
                {
                    provide: __WEBPACK_IMPORTED_MODULE_7__ionic_native_in_app_browser__["a" /* InAppBrowser */],
                    deps: [__WEBPACK_IMPORTED_MODULE_28__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_29__providers_file__["a" /* CoreFileProvider */], __WEBPACK_IMPORTED_MODULE_32__providers_utils_url__["a" /* CoreUrlUtilsProvider */]],
                    useFactory: function (appProvider, fileProvider, urlUtils) {
                        return !appProvider.isDesktop() ? new __WEBPACK_IMPORTED_MODULE_7__ionic_native_in_app_browser__["a" /* InAppBrowser */]() : new __WEBPACK_IMPORTED_MODULE_21__providers_inappbrowser__["a" /* InAppBrowserMock */](appProvider, fileProvider, urlUtils);
                    }
                },
                __WEBPACK_IMPORTED_MODULE_8__ionic_native_keyboard__["a" /* Keyboard */],
                {
                    provide: __WEBPACK_IMPORTED_MODULE_9__ionic_native_local_notifications__["a" /* LocalNotifications */],
                    deps: [__WEBPACK_IMPORTED_MODULE_28__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_33__providers_utils_utils__["a" /* CoreUtilsProvider */]],
                    useFactory: function (appProvider, utils) {
                        // Use platform instead of CoreAppProvider to prevent circular dependencies.
                        return appProvider.isMobile() ? new __WEBPACK_IMPORTED_MODULE_9__ionic_native_local_notifications__["a" /* LocalNotifications */]() : new __WEBPACK_IMPORTED_MODULE_22__providers_local_notifications__["a" /* LocalNotificationsMock */](appProvider, utils);
                    }
                },
                {
                    provide: __WEBPACK_IMPORTED_MODULE_10__ionic_native_media_capture__["a" /* MediaCapture */],
                    deps: [__WEBPACK_IMPORTED_MODULE_28__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_27__providers_capture_helper__["a" /* CoreEmulatorCaptureHelperProvider */]],
                    useFactory: function (appProvider, captureHelper) {
                        return appProvider.isMobile() ? new __WEBPACK_IMPORTED_MODULE_10__ionic_native_media_capture__["a" /* MediaCapture */]() : new __WEBPACK_IMPORTED_MODULE_23__providers_media_capture__["a" /* MediaCaptureMock */](captureHelper);
                    }
                },
                {
                    provide: __WEBPACK_IMPORTED_MODULE_11__ionic_native_network__["a" /* Network */],
                    deps: [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */]],
                    useFactory: function (platform) {
                        // Use platform instead of CoreAppProvider to prevent circular dependencies.
                        return platform.is('cordova') ? new __WEBPACK_IMPORTED_MODULE_11__ionic_native_network__["a" /* Network */]() : new __WEBPACK_IMPORTED_MODULE_24__providers_network__["a" /* NetworkMock */]();
                    }
                },
                __WEBPACK_IMPORTED_MODULE_12__ionic_native_splash_screen__["a" /* SplashScreen */],
                __WEBPACK_IMPORTED_MODULE_13__ionic_native_status_bar__["a" /* StatusBar */],
                __WEBPACK_IMPORTED_MODULE_14__ionic_native_sqlite__["a" /* SQLite */],
                {
                    provide: __WEBPACK_IMPORTED_MODULE_15__ionic_native_zip__["a" /* Zip */],
                    deps: [__WEBPACK_IMPORTED_MODULE_28__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_4__ionic_native_file__["a" /* File */], __WEBPACK_IMPORTED_MODULE_31__providers_utils_mimetype__["a" /* CoreMimetypeUtilsProvider */], __WEBPACK_IMPORTED_MODULE_30__providers_utils_text__["a" /* CoreTextUtilsProvider */]],
                    useFactory: function (appProvider, file, mimeUtils) {
                        // Use platform instead of CoreAppProvider to prevent circular dependencies.
                        return appProvider.isMobile() ? new __WEBPACK_IMPORTED_MODULE_15__ionic_native_zip__["a" /* Zip */]() : new __WEBPACK_IMPORTED_MODULE_25__providers_zip__["a" /* ZipMock */](file, mimeUtils);
                    }
                },
            ]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_28__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_34__providers_init__["a" /* CoreInitDelegate */], __WEBPACK_IMPORTED_MODULE_26__providers_helper__["a" /* CoreEmulatorHelperProvider */]])
    ], CoreEmulatorModule);
    return CoreEmulatorModule;
}());

//# sourceMappingURL=emulator.module.js.map

/***/ }),

/***/ 1007:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CameraMock; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_camera__ = __webpack_require__(216);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__capture_helper__ = __webpack_require__(145);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Emulates the Cordova Camera plugin in desktop apps and in browser.
 */
var CameraMock = /** @class */ (function (_super) {
    __extends(CameraMock, _super);
    function CameraMock(captureHelper) {
        var _this = _super.call(this) || this;
        _this.captureHelper = captureHelper;
        return _this;
    }
    /**
     * Remove intermediate image files that are kept in temporary storage after calling camera.getPicture.
     *
     * @return {Promise<any>} Promise resolved when done.
     */
    CameraMock.prototype.cleanup = function () {
        // This function is iOS only, nothing to do.
        return Promise.resolve();
    };
    /**
     * Take a picture.
     *
     * @param {CameraOptions} options Options that you want to pass to the camera.
     * @return {Promise<any>} Promise resolved when captured.
     */
    CameraMock.prototype.getPicture = function (options) {
        return this.captureHelper.captureMedia('image', options);
    };
    CameraMock = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__capture_helper__["a" /* CoreEmulatorCaptureHelperProvider */]])
    ], CameraMock);
    return CameraMock;
}(__WEBPACK_IMPORTED_MODULE_1__ionic_native_camera__["a" /* Camera */]));

//# sourceMappingURL=camera.js.map

/***/ }),

/***/ 1008:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ClipboardMock; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_clipboard__ = __webpack_require__(202);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(14);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Emulates the Cordova Clipboard plugin in desktop apps and in browser.
 */
var ClipboardMock = /** @class */ (function (_super) {
    __extends(ClipboardMock, _super);
    function ClipboardMock(appProvider) {
        var _this = _super.call(this) || this;
        _this.isDesktop = appProvider.isDesktop();
        if (_this.isDesktop) {
            _this.clipboard = __webpack_require__(146).clipboard;
        }
        else {
            // In browser the text must be selected in order to copy it. Create a hidden textarea to put the text in it.
            _this.copyTextarea = document.createElement('textarea');
            _this.copyTextarea.className = 'core-browser-copy-area';
            _this.copyTextarea.setAttribute('aria-hidden', 'true');
            document.body.appendChild(_this.copyTextarea);
        }
        return _this;
    }
    /**
     * Copy some text to the clipboard.
     *
     * @param {string} text The text to copy.
     * @return {Promise<any>} Promise resolved when copied.
     */
    ClipboardMock.prototype.copy = function (text) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (_this.isDesktop) {
                _this.clipboard.writeText(text);
                resolve();
            }
            else {
                // Put the text in the hidden textarea and select it.
                _this.copyTextarea.innerHTML = text;
                _this.copyTextarea.select();
                try {
                    if (document.execCommand('copy')) {
                        resolve();
                    }
                    else {
                        reject();
                    }
                }
                catch (err) {
                    reject();
                }
                _this.copyTextarea.innerHTML = '';
            }
        });
    };
    /*
     * Get the text stored in the clipboard.
     *
     * @return {Promise<any>} Promise resolved with the text.
     */
    ClipboardMock.prototype.paste = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (_this.isDesktop) {
                resolve(_this.clipboard.readText());
            }
            else {
                // Paste the text in the hidden textarea and get it.
                _this.copyTextarea.innerHTML = '';
                _this.copyTextarea.select();
                try {
                    if (document.execCommand('paste')) {
                        resolve(_this.copyTextarea.innerHTML);
                    }
                    else {
                        reject();
                    }
                }
                catch (err) {
                    reject();
                }
                _this.copyTextarea.innerHTML = '';
            }
        });
    };
    ClipboardMock = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */]])
    ], ClipboardMock);
    return ClipboardMock;
}(__WEBPACK_IMPORTED_MODULE_1__ionic_native_clipboard__["a" /* Clipboard */]));

//# sourceMappingURL=clipboard.js.map

/***/ }),

/***/ 1009:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FileMock; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_file__ = __webpack_require__(106);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_text__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__configconstants__ = __webpack_require__(46);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Emulates the Cordova File plugin in desktop apps and in browser.
 * Most of the code is extracted from the File class of Ionic Native.
 */
var FileMock = /** @class */ (function (_super) {
    __extends(FileMock, _super);
    function FileMock(appProvider, textUtils) {
        var _this = _super.call(this) || this;
        _this.appProvider = appProvider;
        _this.textUtils = textUtils;
        return _this;
    }
    /**
     * Check if a directory exists in a certain path, directory.
     *
     * @param {string} path Base FileSystem.
     * @param {string} dir Name of directory to check
     * @returns {Promise<boolean>} Returns a Promise that resolves to true if the directory exists or rejects with an error.
     */
    FileMock.prototype.checkDir = function (path, dir) {
        var fullPath = this.textUtils.concatenatePaths(path, dir);
        return this.resolveDirectoryUrl(fullPath).then(function () {
            return true;
        });
    };
    /**
     * Check if a file exists in a certain path, directory.
     *
     * @param {string} path Base FileSystem.
     * @param {string} file Name of file to check.
     * @returns {Promise<boolean>} Returns a Promise that resolves with a boolean or rejects with an error.
     */
    FileMock.prototype.checkFile = function (path, file) {
        return this.resolveLocalFilesystemUrl(this.textUtils.concatenatePaths(path, file)).then(function (fse) {
            if (fse.isFile) {
                return true;
            }
            else {
                var err = new __WEBPACK_IMPORTED_MODULE_1__ionic_native_file__["FileError"](13);
                err.message = 'input is not a file';
                return Promise.reject(err);
            }
        });
    };
    /**
     * Copy a file or directory.
     *
     * @param {Entry} srce The Entry to copy.
     * @param {DirectoryEntry} destDir The directory where to put the copy.
     * @param {string} newName New name of the file/dir.
     * @returns {Promise<Entry>} Returns a Promise that resolves to the new Entry object or rejects with an error.
     */
    FileMock.prototype.copyMock = function (srce, destDir, newName) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            srce.copyTo(destDir, newName, function (deste) {
                resolve(deste);
            }, function (err) {
                _this.fillErrorMessageMock(err);
                reject(err);
            });
        });
    };
    /**
     * Copy a directory in various methods. If destination directory exists, will fail to copy.
     *
     * @param {string} path Base FileSystem. Please refer to the iOS and Android filesystems above.
     * @param {string} dirName Name of directory to copy.
     * @param {string} newPath Base FileSystem of new location.
     * @param {string} newDirName New name of directory to copy to (leave blank to remain the same).
     * @returns {Promise<Entry>} Returns a Promise that resolves to the new Entry object or rejects with an error.
     */
    FileMock.prototype.copyDir = function (path, dirName, newPath, newDirName) {
        var _this = this;
        return this.resolveDirectoryUrl(path).then(function (fse) {
            return _this.getDirectory(fse, dirName, { create: false });
        }).then(function (srcde) {
            return _this.resolveDirectoryUrl(newPath).then(function (deste) {
                return _this.copyMock(srcde, deste, newDirName);
            });
        });
    };
    /**
     * Copy a file in various methods. If file exists, will fail to copy.
     *
     * @param {string} path Base FileSystem. Please refer to the iOS and Android filesystems above
     * @param {string} fileName Name of file to copy
     * @param {string} newPath Base FileSystem of new location
     * @param {string} newFileName New name of file to copy to (leave blank to remain the same)
     * @returns {Promise<Entry>} Returns a Promise that resolves to an Entry or rejects with an error.
     */
    FileMock.prototype.copyFile = function (path, fileName, newPath, newFileName) {
        var _this = this;
        newFileName = newFileName || fileName;
        return this.resolveDirectoryUrl(path).then(function (fse) {
            return _this.getFile(fse, fileName, { create: false });
        }).then(function (srcfe) {
            return _this.resolveDirectoryUrl(newPath).then(function (deste) {
                return _this.copyMock(srcfe, deste, newFileName);
            });
        });
    };
    /**
     * Creates a new directory in the specific path.
     * The replace boolean value determines whether to replace an existing directory with the same name.
     * If an existing directory exists and the replace value is false, the promise will fail and return an error.
     *
     * @param {string} path Base FileSystem.
     * @param {string} dirName Name of directory to create
     * @param {boolean} replace If true, replaces file with same name. If false returns error
     * @returns {Promise<DirectoryEntry>} Returns a Promise that resolves with a DirectoryEntry or rejects with an error.
     */
    FileMock.prototype.createDir = function (path, dirName, replace) {
        var _this = this;
        var options = {
            create: true
        };
        if (!replace) {
            options.exclusive = true;
        }
        return this.resolveDirectoryUrl(path).then(function (fse) {
            return _this.getDirectory(fse, dirName, options);
        });
    };
    /**
     * Creates a new file in the specific path.
     * The replace boolean value determines whether to replace an existing file with the same name.
     * If an existing file exists and the replace value is false, the promise will fail and return an error.
     *
     * @param {string} path  Base FileSystem.
     * @param {string} fileName Name of file to create.
     * @param {boolean} replace If true, replaces file with same name. If false returns error.
     * @returns {Promise<FileEntry>} Returns a Promise that resolves to a FileEntry or rejects with an error.
     */
    FileMock.prototype.createFile = function (path, fileName, replace) {
        var _this = this;
        var options = {
            create: true
        };
        if (!replace) {
            options.exclusive = true;
        }
        return this.resolveDirectoryUrl(path).then(function (fse) {
            return _this.getFile(fse, fileName, options);
        });
    };
    /**
     * Create a file writer for a certain file.
     *
     * @param {FileEntry} fe File entry object.
     * @returns {Promise<FileWriter>} Promise resolved with the FileWriter.
     */
    FileMock.prototype.createWriterMock = function (fe) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            fe.createWriter(function (writer) {
                resolve(writer);
            }, function (err) {
                _this.fillErrorMessageMock(err);
                reject(err);
            });
        });
    };
    /**
     * Fill the message for an error.
     *
     * @param {any} err Error.
     */
    FileMock.prototype.fillErrorMessageMock = function (err) {
        try {
            err.message = this.cordovaFileError[err.code];
        }
        catch (e) {
            // Ignore errors.
        }
    };
    /**
     * Get a directory.
     *
     * @param directoryEntry {DirectoryEntry} Directory entry, obtained by resolveDirectoryUrl method
     * @param directoryName {string} Directory name
     * @param flags {Flags} Options
     * @returns {Promise<DirectoryEntry>}
     */
    FileMock.prototype.getDirectory = function (directoryEntry, directoryName, flags) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            try {
                directoryEntry.getDirectory(directoryName, flags, function (de) {
                    resolve(de);
                }, function (err) {
                    _this.fillErrorMessageMock(err);
                    reject(err);
                });
            }
            catch (xc) {
                _this.fillErrorMessageMock(xc);
                reject(xc);
            }
        });
    };
    /**
     * Get a file
     * @param directoryEntry {DirectoryEntry} Directory entry, obtained by resolveDirectoryUrl method
     * @param fileName {string} File name
     * @param flags {Flags} Options
     * @returns {Promise<FileEntry>}
     */
    FileMock.prototype.getFile = function (directoryEntry, fileName, flags) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            try {
                directoryEntry.getFile(fileName, flags, resolve, function (err) {
                    _this.fillErrorMessageMock(err);
                    reject(err);
                });
            }
            catch (xc) {
                _this.fillErrorMessageMock(xc);
                reject(xc);
            }
        });
    };
    /**
     * Get free disk space.
     *
     * @return {Promise<number>} Promise resolved with the free space.
     */
    FileMock.prototype.getFreeDiskSpace = function () {
        // FRequest a file system instance with a minimum size until we get an error.
        if (window.requestFileSystem) {
            return new Promise(function (resolve, reject) {
                var iterations = 0, maxIterations = 50;
                var calculateByRequest = function (size, ratio) {
                    return new Promise(function (resolve, reject) {
                        window.requestFileSystem(LocalFileSystem.PERSISTENT, size, function () {
                            iterations++;
                            if (iterations > maxIterations) {
                                resolve(size);
                                return;
                            }
                            calculateByRequest(size * ratio, ratio).then(resolve);
                        }, function () {
                            resolve(size / ratio);
                        });
                    });
                };
                // General calculation, base 1MB and increasing factor 1.3.
                calculateByRequest(1048576, 1.3).then(function (size) {
                    iterations = 0;
                    maxIterations = 10;
                    // More accurate. Factor is 1.1.
                    calculateByRequest(size, 1.1).then(function (size) {
                        return size / 1024; // Return size in KB.
                    });
                });
            });
        }
        else {
            return Promise.reject(null);
        }
    };
    /**
     * List files and directory from a given path.
     *
     * @param {string} path Base FileSystem. Please refer to the iOS and Android filesystems above
     * @param {string} dirName Name of directory
     * @returns {Promise<Entry[]>} Returns a Promise that resolves to an array of Entry objects or rejects with an error.
     */
    FileMock.prototype.listDir = function (path, dirName) {
        var _this = this;
        return this.resolveDirectoryUrl(path).then(function (fse) {
            return _this.getDirectory(fse, dirName, { create: false, exclusive: false });
        }).then(function (de) {
            var reader = de.createReader();
            return _this.readEntriesMock(reader);
        });
    };
    /**
     * Loads an initialize the API for browser and desktop.
     *
     * @return {Promise<any>} Promise resolved when loaded.
     */
    FileMock.prototype.load = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var win = window; // Convert to <any> to be able to use non-standard properties.
            var basePath;
            if (typeof win.requestFileSystem == 'undefined') {
                win.requestFileSystem = win.webkitRequestFileSystem;
            }
            if (typeof win.resolveLocalFileSystemURL == 'undefined') {
                win.resolveLocalFileSystemURL = win.webkitResolveLocalFileSystemURL;
            }
            win.LocalFileSystem = {
                PERSISTENT: 1
            };
            if (_this.appProvider.isDesktop()) {
                var fs = __webpack_require__(1010), app = __webpack_require__(146).remote.app;
                // @todo emulateCordovaFileForDesktop(fs);
                // Initialize File System. Get the path to use.
                basePath = app.getPath('documents') || app.getPath('home');
                if (!basePath) {
                    reject('Cannot calculate base path for file system.');
                    return;
                }
                basePath = _this.textUtils.concatenatePaths(basePath.replace(/\\/g, '/'), __WEBPACK_IMPORTED_MODULE_4__configconstants__["a" /* CoreConfigConstants */].app_id) + '/';
                // Create the folder if needed.
                fs.mkdir(basePath, function (e) {
                    if (!e || (e && e.code === 'EEXIST')) {
                        // Create successful or it already exists. Resolve.
                        // @todo this.fileProvider.setHTMLBasePath(basePath);
                        resolve(basePath);
                    }
                    else {
                        reject('Error creating base path.');
                    }
                });
            }
            else {
                // It's browser, request a quota to use. Request 500MB.
                navigator.webkitPersistentStorage.requestQuota(500 * 1024 * 1024, function (granted) {
                    window.requestFileSystem(LocalFileSystem.PERSISTENT, granted, function (entry) {
                        basePath = entry.root.toURL();
                        resolve(basePath);
                    }, reject);
                }, reject);
            }
        });
    };
    /**
     * Move a file or directory.
     *
     * @param {Entry} srce The Entry to copy.
     * @param {DirectoryEntry} destDir The directory where to move the file/dir.
     * @param {string} newName New name of the file/dir.
     * @returns {Promise<Entry>} Returns a Promise that resolves to the new Entry object or rejects with an error.
     */
    FileMock.prototype.moveMock = function (srce, destDir, newName) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            srce.moveTo(destDir, newName, function (deste) {
                resolve(deste);
            }, function (err) {
                _this.fillErrorMessageMock(err);
                reject(err);
            });
        });
    };
    /**
     * Move a directory to a given path.
     *
     * @param {string} path The source path to the directory.
     * @param {string} dirName The source directory name.
     * @param {string} newPath The destionation path to the directory.
     * @param {string} newDirName The destination directory name.
     * @returns {Promise<DirectoryEntry|Entry>} Returns a Promise that resolves to the new DirectoryEntry object or rejects with
     *                                          an error.
     */
    FileMock.prototype.moveDir = function (path, dirName, newPath, newDirName) {
        var _this = this;
        return this.resolveDirectoryUrl(path).then(function (fse) {
            return _this.getDirectory(fse, dirName, { create: false });
        }).then(function (srcde) {
            return _this.resolveDirectoryUrl(newPath).then(function (deste) {
                return _this.moveMock(srcde, deste, newDirName);
            });
        });
    };
    /**
     * Move a file to a given path.
     *
     * @param {string} path Base FileSystem. Please refer to the iOS and Android filesystems above
     * @param {string} fileName Name of file to move
     * @param {string} newPath Base FileSystem of new location
     * @param {string} newFileName New name of file to move to (leave blank to remain the same)
     * @returns {Promise<Entry>} Returns a Promise that resolves to the new Entry or rejects with an error.
     */
    FileMock.prototype.moveFile = function (path, fileName, newPath, newFileName) {
        var _this = this;
        newFileName = newFileName || fileName;
        return this.resolveDirectoryUrl(path).then(function (fse) {
            return _this.getFile(fse, fileName, { create: false });
        }).then(function (srcfe) {
            return _this.resolveDirectoryUrl(newPath).then(function (deste) {
                return _this.moveMock(srcfe, deste, newFileName);
            });
        });
    };
    /**
     * Read file and return data as an ArrayBuffer.
     * @param {string} path Base FileSystem.
     * @param {string} file Name of file, relative to path.
     * @returns {Promise<ArrayBuffer>} Returns a Promise that resolves with the contents of the file as ArrayBuffer or rejects
     *                                 with an error.
     */
    FileMock.prototype.readAsArrayBuffer = function (path, file) {
        return this.readFileMock(path, file, 'ArrayBuffer');
    };
    /**
     * Read file and return data as a binary data.
     * @param {string} path Base FileSystem.
     * @param {string} file Name of file, relative to path.
     * @returns {Promise<string>} Returns a Promise that resolves with the contents of the file as string rejects with an error.
     */
    FileMock.prototype.readAsBinaryString = function (path, file) {
        return this.readFileMock(path, file, 'BinaryString');
    };
    /**
     * Read file and return data as a base64 encoded data url.
     * A data url is of the form:
     *      data: [<mediatype>][;base64],<data>
     * @param {string} path Base FileSystem.
     * @param {string} file Name of file, relative to path.
     * @returns {Promise<string>} Returns a Promise that resolves with the contents of the file as data URL or rejects
     *                            with an error.
     */
    FileMock.prototype.readAsDataURL = function (path, file) {
        return this.readFileMock(path, file, 'DataURL');
    };
    /**
     * Read the contents of a file as text.
     *
     * @param {string} path Base FileSystem.
     * @param {string} file Name of file, relative to path.
     * @returns {Promise<string>} Returns a Promise that resolves with the contents of the file as string or rejects with an error.
     */
    FileMock.prototype.readAsText = function (path, file) {
        return this.readFileMock(path, file, 'Text');
    };
    /**
     * Read all the files and directories inside a directory.
     *
     * @param {DirectoryReader} dr The directory reader.
     * @return {Promise<Entry[]>} Promise resolved with the list of files/dirs.
     */
    FileMock.prototype.readEntriesMock = function (dr) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            dr.readEntries(function (entries) {
                resolve(entries);
            }, function (err) {
                _this.fillErrorMessageMock(err);
                reject(err);
            });
        });
    };
    /**
     * Read the contents of a file.
     *
     * @param {string} path Base FileSystem.
     * @param {string} file Name of file, relative to path.
     * @param {string} readAs Format to read as.
     * @returns {Promise<string>} Returns a Promise that resolves with the contents of the file or rejects with an error.
     */
    FileMock.prototype.readFileMock = function (path, file, readAs) {
        var _this = this;
        return this.resolveDirectoryUrl(path).then(function (directoryEntry) {
            return _this.getFile(directoryEntry, file, { create: false });
        }).then(function (fileEntry) {
            var reader = new FileReader();
            return new Promise(function (resolve, reject) {
                reader.onloadend = function () {
                    if (reader.result !== undefined || reader.result !== null) {
                        resolve(reader.result);
                    }
                    else if (reader.error !== undefined || reader.error !== null) {
                        reject(reader.error);
                    }
                    else {
                        reject({ code: null, message: 'READER_ONLOADEND_ERR' });
                    }
                };
                fileEntry.file(function (file) {
                    reader["readAs" + readAs].call(reader, file);
                }, function (error) {
                    reject(error);
                });
            });
        });
    };
    /**
     * Delete a file.
     *
     * @param {Entry} fe The file to remove.
     * @return {Promise<any>} Promise resolved when done.
     */
    FileMock.prototype.removeMock = function (fe) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            fe.remove(function () {
                resolve({ success: true, fileRemoved: fe });
            }, function (err) {
                _this.fillErrorMessageMock(err);
                reject(err);
            });
        });
    };
    /**
     * Remove a directory at a given path.
     *
     * @param {string} path The path to the directory.
     * @param {string} dirName The directory name.
     * @returns {Promise<RemoveResult>} Returns a Promise that resolves to a RemoveResult or rejects with an error.
     */
    FileMock.prototype.removeDir = function (path, dirName) {
        var _this = this;
        return this.resolveDirectoryUrl(path).then(function (fse) {
            return _this.getDirectory(fse, dirName, { create: false });
        }).then(function (de) {
            return _this.removeMock(de);
        });
    };
    /**
     * Removes a file from a desired location.
     *
     * @param {string} path  Base FileSystem.
     * @param {string} fileName Name of file to remove.
     * @returns {Promise<RemoveResult>} Returns a Promise that resolves to a RemoveResult or rejects with an error.
     */
    FileMock.prototype.removeFile = function (path, fileName) {
        var _this = this;
        return this.resolveDirectoryUrl(path).then(function (fse) {
            return _this.getFile(fse, fileName, { create: false });
        }).then(function (fe) {
            return _this.removeMock(fe);
        });
    };
    /**
     * Removes all files and the directory from a desired location.
     *
     * @param {string} path Base FileSystem. Please refer to the iOS and Android filesystems above
     * @param {string} dirName Name of directory
     * @returns {Promise<RemoveResult>} Returns a Promise that resolves with a RemoveResult or rejects with an error.
     */
    FileMock.prototype.removeRecursively = function (path, dirName) {
        var _this = this;
        return this.resolveDirectoryUrl(path).then(function (fse) {
            return _this.getDirectory(fse, dirName, { create: false });
        }).then(function (de) {
            return _this.rimrafMock(de);
        });
    };
    /**
     * Resolves a local directory url
     * @param directoryUrl {string} directory system url
     * @returns {Promise<DirectoryEntry>}
     */
    FileMock.prototype.resolveDirectoryUrl = function (directoryUrl) {
        return this.resolveLocalFilesystemUrl(directoryUrl).then(function (de) {
            if (de.isDirectory) {
                return de;
            }
            else {
                var err = new __WEBPACK_IMPORTED_MODULE_1__ionic_native_file__["FileError"](13);
                err.message = 'input is not a directory';
                return Promise.reject(err);
            }
        });
    };
    /**
     * Resolves a local file system URL
     * @param fileUrl {string} file system url
     * @returns {Promise<Entry>}
     */
    FileMock.prototype.resolveLocalFilesystemUrl = function (fileUrl) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            try {
                window.resolveLocalFileSystemURL(fileUrl, function (entry) {
                    resolve(entry);
                }, function (err) {
                    _this.fillErrorMessageMock(err);
                    reject(err);
                });
            }
            catch (xc) {
                _this.fillErrorMessageMock(xc);
                reject(xc);
            }
        });
    };
    /**
     * Remove a directory and all its contents.
     *
     * @param {DirectoryEntry} de Directory to remove.
     * @return {Promise<any>} Promise resolved when done.
     */
    FileMock.prototype.rimrafMock = function (de) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            de.removeRecursively(function () {
                resolve({ success: true, fileRemoved: de });
            }, function (err) {
                _this.fillErrorMessageMock(err);
                reject(err);
            });
        });
    };
    /**
     * Write some data in a file.
     *
     * @param {FileWriter} writer File writer.
     * @param {any} data The data to write.
     * @return {Promise<any>} Promise resolved when done.
     */
    FileMock.prototype.writeMock = function (writer, data) {
        if (data instanceof Blob) {
            return this.writeFileInChunksMock(writer, data);
        }
        return new Promise(function (resolve, reject) {
            writer.onwriteend = function (evt) {
                if (writer.error) {
                    reject(writer.error);
                }
                else {
                    resolve(evt);
                }
            };
            writer.write(data);
        });
    };
    /**
     * Write to an existing file.
     *
     * @param {string} path Base FileSystem.
     * @param {string} fileName path relative to base path.
     * @param {string | Blob} text content or blob to write.
     * @returns {Promise<void>} Returns a Promise that resolves or rejects with an error.
     */
    FileMock.prototype.writeExistingFile = function (path, fileName, text) {
        return this.writeFile(path, fileName, text, { replace: true });
    };
    /**
     * Write a new file to the desired location.
     *
     * @param {string} path Base FileSystem. Please refer to the iOS and Android filesystems above
     * @param {string} fileName path relative to base path
     * @param {string | Blob} text content or blob to write
     * @param {any} options replace file if set to true. See WriteOptions for more information.
     * @returns {Promise<any>} Returns a Promise that resolves to updated file entry or rejects with an error.
     */
    FileMock.prototype.writeFile = function (path, fileName, text, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var getFileOpts = {
            create: !options.append,
            exclusive: !options.replace
        };
        return this.resolveDirectoryUrl(path).then(function (directoryEntry) {
            return _this.getFile(directoryEntry, fileName, getFileOpts);
        }).then(function (fileEntry) {
            return _this.writeFileEntryMock(fileEntry, text, options);
        });
    };
    /**
     * Write content to FileEntry.
     *
     * @param {FileEntry} fe File entry object.
     * @param {string | Blob} text Content or blob to write.
     * @param {IWriteOptions} options replace file if set to true. See WriteOptions for more information.
     * @returns {Promise<FileEntry>} Returns a Promise that resolves to updated file entry or rejects with an error.
     */
    FileMock.prototype.writeFileEntryMock = function (fe, text, options) {
        var _this = this;
        return this.createWriterMock(fe).then(function (writer) {
            if (options.append) {
                writer.seek(writer.length);
            }
            if (options.truncate) {
                writer.truncate(options.truncate);
            }
            return _this.writeMock(writer, text);
        }).then(function () { return fe; });
    };
    /**
     * Write a file in chunks.
     *
     * @param {FileWriter} writer File writer.
     * @param {Blob} data Data to write.
     * @return {Promise<any>} Promise resolved when done.
     */
    FileMock.prototype.writeFileInChunksMock = function (writer, data) {
        var writtenSize = 0;
        var BLOCK_SIZE = 1024 * 1024, writeNextChunk = function () {
            var size = Math.min(BLOCK_SIZE, data.size - writtenSize);
            var chunk = data.slice(writtenSize, writtenSize + size);
            writtenSize += size;
            writer.write(chunk);
        };
        return new Promise(function (resolve, reject) {
            writer.onerror = reject;
            writer.onwrite = function () {
                if (writtenSize < data.size) {
                    writeNextChunk();
                }
                else {
                    resolve();
                }
            };
            writeNextChunk();
        });
    };
    FileMock = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_text__["a" /* CoreTextUtilsProvider */]])
    ], FileMock);
    return FileMock;
}(__WEBPACK_IMPORTED_MODULE_1__ionic_native_file__["a" /* File */]));

//# sourceMappingURL=file.js.map

/***/ }),

/***/ 101:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreLangProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_moment__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_globalization__ = __webpack_require__(198);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__config__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__configconstants__ = __webpack_require__(46);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};







/*
 * Service to handle language features, like changing the current language.
*/
var CoreLangProvider = /** @class */ (function () {
    function CoreLangProvider(translate, configProvider, platform, globalization) {
        var _this = this;
        this.translate = translate;
        this.configProvider = configProvider;
        this.globalization = globalization;
        this.fallbackLanguage = __WEBPACK_IMPORTED_MODULE_6__configconstants__["a" /* CoreConfigConstants */].default_lang || 'en';
        this.customStrings = {};
        // Set fallback language and language to use until the app determines the right language to use.
        translate.setDefaultLang(this.fallbackLanguage);
        translate.use(this.fallbackLanguage);
        platform.ready().then(function () {
            _this.getCurrentLanguage().then(function (language) {
                translate.use(language);
                __WEBPACK_IMPORTED_MODULE_2_moment__["locale"](language);
            });
        });
        this.decorateTranslate();
    }
    /**
     * Change current language.
     *
     * @param {string} language New language to use.
     * @return {Promise<any>} Promise resolved when the change is finished.
     */
    CoreLangProvider.prototype.changeCurrentLanguage = function (language) {
        var promises = [];
        promises.push(this.translate.use(language));
        promises.push(this.configProvider.set('current_language', language));
        __WEBPACK_IMPORTED_MODULE_2_moment__["locale"](language);
        this.currentLanguage = language;
        return Promise.all(promises);
    };
    /**
     * Clear current custom strings.
     */
    CoreLangProvider.prototype.clearCustomStrings = function () {
        this.customStrings = {};
        this.customStringsRaw = '';
    };
    /**
     * Function to "decorate" the TranslateService.
     * Basically, it extends the translate functions to use the custom lang strings.
     */
    CoreLangProvider.prototype.decorateTranslate = function () {
        var _this = this;
        var originalGet = this.translate.get, originalInstant = this.translate.instant;
        // Redefine translate.get.
        this.translate.get = function (key, interpolateParams) {
            // Always call the original get function to avoid having to create our own Observables.
            if (typeof key == 'string') {
                var value = _this.getCustomString(key);
                if (typeof value != 'undefined') {
                    key = value;
                }
            }
            else {
                key = _this.getCustomStrings(key).translations;
            }
            return originalGet.apply(_this.translate, [key, interpolateParams]);
        };
        // Redefine translate.instant.
        this.translate.instant = function (key, interpolateParams) {
            if (typeof key == 'string') {
                var value = _this.getCustomString(key);
                if (typeof value != 'undefined') {
                    return value;
                }
                return originalInstant.apply(_this.translate, [key, interpolateParams]);
            }
            else {
                var result = _this.getCustomStrings(key);
                if (result.allFound) {
                    return result.translations;
                }
                return originalInstant.apply(_this.translate, [result.translations]);
            }
        };
    };
    /**
     * Get all current custom strings.
     *
     * @return {any} Custom strings.
     */
    CoreLangProvider.prototype.getAllCustomStrings = function () {
        return this.customStrings;
    };
    /**
     * Get current language.
     *
     * @return {Promise<string>} Promise resolved with the current language.
     */
    CoreLangProvider.prototype.getCurrentLanguage = function () {
        var _this = this;
        if (typeof this.currentLanguage != 'undefined') {
            return Promise.resolve(this.currentLanguage);
        }
        // Get current language from config (user might have changed it).
        return this.configProvider.get('current_language').then(function (language) {
            return language;
        }).catch(function () {
            // User hasn't defined a language. If default language is forced, use it.
            if (__WEBPACK_IMPORTED_MODULE_6__configconstants__["a" /* CoreConfigConstants */].forcedefaultlanguage && !__WEBPACK_IMPORTED_MODULE_6__configconstants__["a" /* CoreConfigConstants */].forcedefaultlanguage) {
                return __WEBPACK_IMPORTED_MODULE_6__configconstants__["a" /* CoreConfigConstants */].default_lang;
            }
            try {
                // No forced language, try to get current language from cordova globalization.
                return _this.globalization.getPreferredLanguage().then(function (result) {
                    var language = result.value.toLowerCase();
                    if (language.indexOf('-') > -1) {
                        // Language code defined by locale has a dash, like en-US or es-ES. Check if it's supported.
                        if (__WEBPACK_IMPORTED_MODULE_6__configconstants__["a" /* CoreConfigConstants */].languages && typeof __WEBPACK_IMPORTED_MODULE_6__configconstants__["a" /* CoreConfigConstants */].languages[language] == 'undefined') {
                            // Code is NOT supported. Fallback to language without dash. E.g. 'en-US' would fallback to 'en'.
                            language = language.substr(0, language.indexOf('-'));
                        }
                    }
                    return language;
                }).catch(function () {
                    // Error getting locale. Use default language.
                    return _this.fallbackLanguage;
                });
            }
            catch (err) {
                // Error getting locale. Use default language.
                return Promise.resolve(_this.fallbackLanguage);
            }
        }).then(function (language) {
            _this.currentLanguage = language; // Save it for later.
            return language;
        });
    };
    /**
     * Get a custom string for a certain key.
     *
     * @param {string} key The key of the translation to get.
     * @return {string} Translation, undefined if not found.
     */
    CoreLangProvider.prototype.getCustomString = function (key) {
        var customStrings = this.getCustomStringsForLanguage();
        if (customStrings && typeof customStrings[key] != 'undefined') {
            return customStrings[key];
        }
    };
    /**
     * Get custom strings for several keys.
     *
     * @param {string[]} keys The keys of the translations to get.
     * @return {any} Object with translations and a boolean indicating if all translations were found in custom strings.
     */
    CoreLangProvider.prototype.getCustomStrings = function (keys) {
        var customStrings = this.getCustomStringsForLanguage(), translations = [];
        var allFound = true;
        keys.forEach(function (key) {
            if (customStrings && typeof customStrings[key] != 'undefined') {
                translations.push(customStrings[key]);
            }
            else {
                allFound = false;
                translations.push(key);
            }
        });
        return {
            allFound: allFound,
            translations: translations
        };
    };
    /**
     * Get custom strings for a certain language.
     *
     * @param {string} [lang] The language to get. If not defined, return current language.
     * @return {any} Custom strings.
     */
    CoreLangProvider.prototype.getCustomStringsForLanguage = function (lang) {
        lang = lang || this.currentLanguage;
        return this.customStrings[lang];
    };
    /**
     * Load certain custom strings.
     *
     * @param {string} strings Custom strings to load (tool_mobile_customlangstrings).
     */
    CoreLangProvider.prototype.loadCustomStrings = function (strings) {
        var _this = this;
        if (strings == this.customStringsRaw) {
            // Strings haven't changed, stop.
            return;
        }
        // Reset current values.
        this.clearCustomStrings();
        if (!strings) {
            return;
        }
        var list = strings.split(/(?:\r\n|\r|\n)/);
        list.forEach(function (entry) {
            var values = entry.split('|');
            var lang;
            if (values.length < 3) {
                // Not enough data, ignore the entry.
                return;
            }
            lang = values[2];
            if (!_this.customStrings[lang]) {
                _this.customStrings[lang] = {};
            }
            _this.customStrings[lang][values[0]] = values[1];
        });
    };
    CoreLangProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_5__config__["a" /* CoreConfigProvider */], __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["n" /* Platform */],
            __WEBPACK_IMPORTED_MODULE_3__ionic_native_globalization__["a" /* Globalization */]])
    ], CoreLangProvider);
    return CoreLangProvider;
}());

//# sourceMappingURL=lang.js.map

/***/ }),

/***/ 1013:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GlobalizationMock; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_globalization__ = __webpack_require__(198);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(14);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Emulates the Cordova Globalization plugin in desktop apps and in browser.
 */
var GlobalizationMock = /** @class */ (function (_super) {
    __extends(GlobalizationMock, _super);
    function GlobalizationMock(appProvider) {
        var _this = _super.call(this) || this;
        _this.appProvider = appProvider;
        return _this;
    }
    /**
     * Get the current locale.
     *
     * @return {string} Locale name.
     */
    GlobalizationMock.prototype.getCurrentlocale = function () {
        // Get browser language.
        var navLang = navigator.userLanguage || navigator.language;
        try {
            if (this.appProvider.isDesktop()) {
                return __webpack_require__(146).remote.app.getLocale() || navLang;
            }
            else {
                return navLang;
            }
        }
        catch (ex) {
            // Something went wrong, return browser language.
            return navLang;
        }
    };
    /**
     * Get the current locale name.
     *
     * @return {Promise<{value: string}>} Promise resolved with an object with the language string.
     */
    GlobalizationMock.prototype.getLocaleName = function () {
        var locale = this.getCurrentlocale();
        if (locale) {
            return Promise.resolve({ value: locale });
        }
        else {
            var error = { code: GlobalizationError.UNKNOWN_ERROR, message: 'Cannot get language' };
            return Promise.reject(error);
        }
    };
    /*
     * Get the current preferred language.
     *
     * @return {Promise<{value: string}>} Promise resolved with an object with the language string.
     */
    GlobalizationMock.prototype.getPreferredLanguage = function () {
        return this.getLocaleName();
    };
    GlobalizationMock = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */]])
    ], GlobalizationMock);
    return GlobalizationMock;
}(__WEBPACK_IMPORTED_MODULE_1__ionic_native_globalization__["a" /* Globalization */]));

//# sourceMappingURL=globalization.js.map

/***/ }),

/***/ 1014:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return InAppBrowserMock; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_in_app_browser__ = __webpack_require__(130);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_file__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_url__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__classes_inappbrowserobject__ = __webpack_require__(1015);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






/**
 * Emulates the Cordova InAppBrowser plugin in desktop apps.
 */
var InAppBrowserMock = /** @class */ (function (_super) {
    __extends(InAppBrowserMock, _super);
    function InAppBrowserMock(appProvider, fileProvider, urlUtils) {
        var _this = _super.call(this) || this;
        _this.appProvider = appProvider;
        _this.fileProvider = fileProvider;
        _this.urlUtils = urlUtils;
        return _this;
    }
    /**
     * Opens a URL in a new InAppBrowser instance, the current browser instance, or the system browser.
     *
     * @param {string} url The URL to load.
     * @param {string} [target] The target in which to load the URL, an optional parameter that defaults to _self.
     * @param {string} [options] Options for the InAppBrowser.
     * @return {InAppBrowserObject} The new instance.
     */
    InAppBrowserMock.prototype.create = function (url, target, options) {
        if (options === void 0) { options = ''; }
        if (!this.appProvider.isDesktop()) {
            return _super.prototype.create.call(this, url, target, options);
        }
        return new __WEBPACK_IMPORTED_MODULE_5__classes_inappbrowserobject__["a" /* InAppBrowserObjectMock */](this.appProvider, this.fileProvider, this.urlUtils, url, target, options);
    };
    InAppBrowserMock = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_file__["a" /* CoreFileProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_utils_url__["a" /* CoreUrlUtilsProvider */]])
    ], InAppBrowserMock);
    return InAppBrowserMock;
}(__WEBPACK_IMPORTED_MODULE_1__ionic_native_in_app_browser__["a" /* InAppBrowser */]));

//# sourceMappingURL=inappbrowser.js.map

/***/ }),

/***/ 1015:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return InAppBrowserObjectMock; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_in_app_browser__ = __webpack_require__(130);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


/**
 * Emulates the Cordova InAppBrowserObject in desktop apps.
 */
var InAppBrowserObjectMock = /** @class */ (function (_super) {
    __extends(InAppBrowserObjectMock, _super);
    function InAppBrowserObjectMock(appProvider, fileProvider, urlUtils, url, target, options) {
        if (options === void 0) { options = ''; }
        var _this = _super.call(this, url, target, options) || this;
        _this.fileProvider = fileProvider;
        _this.urlUtils = urlUtils;
        _this.url = url;
        if (!appProvider.isDesktop()) {
            return _this;
        }
        _this.browserWindow = __webpack_require__(592).remote.BrowserWindow;
        _this.screen = __webpack_require__(592).screen;
        _this.isSSO = !!(url && url.match(/\/launch\.php\?service=.+&passport=/));
        _this.isLinux = appProvider.isLinux();
        var width = 800, height = 600, display;
        var bwOptions = {};
        if (screen) {
            display = _this.screen.getPrimaryDisplay();
            if (display && display.workArea) {
                width = display.workArea.width || width;
                height = display.workArea.height || height;
            }
        }
        // Create the BrowserWindow options based on the received options.
        bwOptions.width = width;
        bwOptions.height = height;
        if (options.indexOf('hidden=yes') != -1) {
            bwOptions.show = false;
        }
        if (options.indexOf('location=no') != -1) {
            bwOptions.frame = false;
        }
        if (options.indexOf('fullscreen=yes') != -1) {
            bwOptions.fullscreen = true;
        }
        _this.window = new _this.browserWindow(bwOptions);
        _this.window.loadURL(url);
        if (_this.isLinux && _this.isSSO) {
            // SSO in Linux. Simulate it's an iOS device so we can retrieve the launch URL.
            // This is needed because custom URL scheme is not supported in Linux.
            var userAgent = 'Mozilla/5.0 (iPad) AppleWebKit/603.3.8 (KHTML, like Gecko) Mobile/14G60';
            _this.window.webContents.setUserAgent(userAgent);
        }
        return _this;
    }
    /**
     * Close the window.
     */
    InAppBrowserObjectMock.prototype.close = function () {
        this.window.close();
    };
    /**
     * Execute a JS script.
     *
     * @param {any} details Details of the script to run, specifying either a file or code key.
     * @return {Promise<any>} Promise resolved when done.
     */
    InAppBrowserObjectMock.prototype.executeScript = function (details) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (details.code) {
                _this.window.webContents.executeJavaScript(details.code, false, resolve);
            }
            else if (details.file) {
                _this.fileProvider.readFile(details.file).then(function (code) {
                    _this.window.webContents.executeJavaScript(code, false, resolve);
                }).catch(reject);
            }
            else {
                reject('executeScript requires exactly one of code or file to be specified');
            }
        });
    };
    /**
     * Recursive function to get the launch URL from the contents of a BrowserWindow.
     *
     * @param {number} [retry=0] Retry number.
     * @return {Promise<string>} Promise resolved with the launch URL.
     */
    InAppBrowserObjectMock.prototype.getLaunchUrl = function (retry) {
        var _this = this;
        if (retry === void 0) { retry = 0; }
        return new Promise(function (resolve, reject) {
            // Execute Javascript to retrieve the launch link.
            var jsCode = 'var el = document.querySelector("#launchapp"); el && el.href;';
            var found = false;
            _this.window.webContents.executeJavaScript(jsCode).then(function (launchUrl) {
                found = true;
                resolve(launchUrl);
            });
            setTimeout(function () {
                if (found) {
                    // URL found, stop.
                }
                else if (retry > 5) {
                    // Waited enough, stop.
                    reject();
                }
                else {
                    _this.getLaunchUrl(retry + 1).then(resolve, reject);
                }
            }, 300);
        });
    };
    /**
     * Hide the window.
     */
    InAppBrowserObjectMock.prototype.hide = function () {
        this.window.hide();
    };
    /**
     * Insert CSS.
     *
     * @param {any} details Details of the CSS to insert, specifying either a file or code key.
     * @return {Promise<any>} Promise resolved when done.
     */
    InAppBrowserObjectMock.prototype.insertCSS = function (details) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (details.code) {
                _this.window.webContents.insertCSS(details.code);
                resolve();
            }
            else if (details.file) {
                _this.fileProvider.readFile(details.file).then(function (code) {
                    _this.window.webContents.insertCSS(code);
                    resolve();
                }).catch(reject);
            }
            else {
                reject('insertCSS requires exactly one of code or file to be specified');
            }
        });
    };
    /**
     * Listen to events happening.
     *
     * @param {string} name Name of the event.
     * @return {Observable<InAppBrowserEvent>} Observable that will listen to the event on subscribe, and will stop listening
     *                                         to the event on unsubscribe.
     */
    InAppBrowserObjectMock.prototype.on = function (name) {
        var _this = this;
        // Create the observable.
        return new __WEBPACK_IMPORTED_MODULE_0_rxjs__["Observable"](function (observer) {
            // Helper functions to handle events.
            var received = function (event, url) {
                try {
                    event.url = url || _this.window.getURL();
                    event.type = name;
                    observer.next(event);
                }
                catch (ex) {
                    // Ignore errors.
                }
            }, finishLoad = function (event) {
                // Check if user is back to launch page.
                if (_this.urlUtils.removeUrlParams(_this.url) == _this.urlUtils.removeUrlParams(_this.window.getURL())) {
                    // The launch page was loaded. Search for the launch link.
                    _this.getLaunchUrl().then(function (launchUrl) {
                        if (launchUrl) {
                            // Launch URL retrieved, send it and stop listening.
                            received(event, launchUrl);
                        }
                    });
                }
            };
            switch (name) {
                case 'loadstart':
                    _this.window.webContents.on('did-start-loading', received);
                    if (_this.isLinux && _this.isSSO) {
                        // Linux doesn't support custom URL Schemes. Check if launch page is loaded.
                        _this.window.webContents.on('did-finish-load', finishLoad);
                    }
                    break;
                case 'loadstop':
                    _this.window.webContents.on('did-finish-load', received);
                    break;
                case 'loaderror':
                    _this.window.webContents.on('did-fail-load', received);
                    break;
                case 'exit':
                    _this.window.on('close', received);
                    break;
                default:
            }
            return function () {
                // Unsubscribing. We need to remove the listeners.
                switch (name) {
                    case 'loadstart':
                        _this.window.webContents.removeListener('did-start-loading', received);
                        _this.window.webContents.removeListener('did-finish-load', finishLoad);
                        break;
                    case 'loadstop':
                        _this.window.webContents.removeListener('did-finish-load', received);
                        break;
                    case 'loaderror':
                        _this.window.webContents.removeListener('did-fail-load', received);
                        break;
                    case 'exit':
                        _this.window.removeListener('close', received);
                        break;
                    default:
                }
            };
        });
    };
    /**
     * Show the window.
     */
    InAppBrowserObjectMock.prototype.show = function () {
        this.window.show();
    };
    return InAppBrowserObjectMock;
}(__WEBPACK_IMPORTED_MODULE_1__ionic_native_in_app_browser__["b" /* InAppBrowserObject */]));

//# sourceMappingURL=inappbrowserobject.js.map

/***/ }),

/***/ 1016:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LocalNotificationsMock; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_local_notifications__ = __webpack_require__(138);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__constants__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__configconstants__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_moment__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_moment__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};







/**
 * Emulates the Cordova Globalization plugin in desktop apps and in browser.
 */
var LocalNotificationsMock = /** @class */ (function (_super) {
    __extends(LocalNotificationsMock, _super);
    function LocalNotificationsMock(appProvider, utils) {
        var _this = _super.call(this) || this;
        _this.appProvider = appProvider;
        _this.utils = utils;
        // Templates for Windows ToastNotifications and TileNotifications.
        _this.toastTemplate = '<toast><visual><binding template="ToastText02"><text id="1" hint-wrap="true">%s</text>' +
            '<text id="2" hint-wrap="true">%s</text></binding></visual></toast>';
        _this.tileBindingTemplate = '<text hint-style="base" hint-wrap="true">%s</text>' +
            '<text hint-style="captionSubtle" hint-wrap="true">%s</text>';
        _this.tileTemplate = '<tile><visual branding="nameAndLogo">' +
            '<binding template="TileMedium">' + _this.tileBindingTemplate + '</binding>' +
            '<binding template="TileWide">' + _this.tileBindingTemplate + '</binding>' +
            '<binding template="TileLarge">' + _this.tileBindingTemplate + '</binding>' +
            '</visual></tile>';
        // Variables for database.
        _this.DESKTOP_NOTIFS_TABLE = 'desktop_local_notifications';
        _this.tableSchema = {
            name: _this.DESKTOP_NOTIFS_TABLE,
            columns: [
                {
                    name: 'id',
                    type: 'INTEGER',
                    primaryKey: true
                },
                {
                    name: 'triggered',
                    type: 'INTEGER'
                }
            ]
        };
        _this.scheduled = {};
        _this.triggered = {};
        _this.defaults = {
            text: '',
            title: '',
            sound: '',
            badge: 0,
            id: 0,
            data: undefined,
            every: undefined,
            at: undefined
        };
        _this.appDB = appProvider.getDB();
        _this.appDB.createTableFromSchema(_this.tableSchema);
        // Initialize observers.
        _this.observers = {
            schedule: [],
            trigger: [],
            click: [],
            update: [],
            clear: [],
            clearall: [],
            cancel: [],
            cancelall: []
        };
        return _this;
    }
    /**
     * Cancels single or multiple notifications
     * @param notificationId {any} A single notification id, or an array of notification ids.
     * @returns {Promise<any>} Returns a promise when the notification is canceled
     */
    LocalNotificationsMock.prototype.cancel = function (notificationId) {
        var _this = this;
        var promises = [];
        notificationId = Array.isArray(notificationId) ? notificationId : [notificationId];
        notificationId = this.convertIds(notificationId);
        // Cancel the notifications.
        notificationId.forEach(function (id) {
            if (_this.scheduled[id]) {
                promises.push(_this.cancelNotification(id, false, 'cancel'));
            }
        });
        return Promise.all(promises);
    };
    /**
     * Cancels all notifications.
     *
     * @returns {Promise<any>} Returns a promise when all notifications are canceled.
     */
    LocalNotificationsMock.prototype.cancelAll = function () {
        var _this = this;
        return this.cancel(Object.keys(this.scheduled)).then(function () {
            _this.triggerEvent('cancelall', 'foreground');
        });
    };
    /**
     * Cancel a local notification.
     *
     * @param {number} id Notification ID.
     * @param {boolean} omitEvent If true, the clear/cancel event won't be triggered.
     * @param {string} eventName Name of the event to trigger.
     * @return {Void}
     */
    LocalNotificationsMock.prototype.cancelNotification = function (id, omitEvent, eventName) {
        var notification = this.scheduled[id].notification;
        clearTimeout(this.scheduled[id].timeout);
        clearInterval(this.scheduled[id].interval);
        delete this.scheduled[id];
        delete this.triggered[id];
        this.removeNotification(id);
        if (!omitEvent) {
            this.triggerEvent(eventName, notification, 'foreground');
        }
    };
    /**
     * Clears single or multiple notifications.
     *
     * @param {any} notificationId A single notification id, or an array of notification ids.
     * @returns {Promise<any>} Returns a promise when the notification had been cleared.
     */
    LocalNotificationsMock.prototype.clear = function (notificationId) {
        var _this = this;
        var promises = [];
        notificationId = Array.isArray(notificationId) ? notificationId : [notificationId];
        notificationId = this.convertIds(notificationId);
        // Clear the notifications.
        notificationId.forEach(function (id) {
            // Cancel only the notifications that aren't repeating.
            if (_this.scheduled[id] && _this.scheduled[id].notification && !_this.scheduled[id].notification.every) {
                promises.push(_this.cancelNotification(id, false, 'clear'));
            }
        });
        return Promise.all(promises);
    };
    /**
     * Clears all notifications.
     *
     * @returns {Promise<any>} Returns a promise when all notifications have cleared
     */
    LocalNotificationsMock.prototype.clearAll = function () {
        var _this = this;
        return this.clear(Object.keys(this.scheduled)).then(function () {
            _this.triggerEvent('clearall', 'foreground');
        });
    };
    /**
     * Convert a list of IDs to numbers.
     * Code extracted from the Cordova plugin.
     *
     * @param {any[]} ids List of IDs.
     * @return {number[]} List of IDs as numbers.
     */
    LocalNotificationsMock.prototype.convertIds = function (ids) {
        var convertedIds = [];
        for (var i = 0; i < ids.length; i++) {
            convertedIds.push(Number(ids[i]));
        }
        return convertedIds;
    };
    /**
     * Convert the notification options to their required type.
     * Code extracted from the Cordova plugin.
     *
     * @param {ILocalNotification} notification Notification.
     * @return {ILocalNotification} Converted notification.
     */
    LocalNotificationsMock.prototype.convertProperties = function (notification) {
        if (notification.id) {
            if (isNaN(notification.id)) {
                notification.id = this.defaults.id;
            }
            else {
                notification.id = Number(notification.id);
            }
        }
        if (notification.title) {
            notification.title = notification.title.toString();
        }
        if (notification.text) {
            notification.text = notification.text.toString();
        }
        if (notification.badge) {
            if (isNaN(notification.badge)) {
                notification.badge = this.defaults.badge;
            }
            else {
                notification.badge = Number(notification.badge);
            }
        }
        if (notification.at) {
            if (typeof notification.at == 'object') {
                notification.at = notification.at.getTime();
            }
            notification.at = Math.round(notification.at / 1000);
        }
        if (typeof notification.data == 'object') {
            notification.data = JSON.stringify(notification.data);
        }
        return notification;
    };
    /**
     * Get a notification object.
     *
     * @param {any} notificationId The id of the notification to get.
     * @returns {Promise<ILocalNotification>}
     */
    LocalNotificationsMock.prototype.get = function (notificationId) {
        return Promise.resolve(this.getNotifications([Number(notificationId)], true, true)[0]);
    };
    /**
     * Get all notification objects.
     *
     * @returns {Promise<Array<ILocalNotification>>}
     */
    LocalNotificationsMock.prototype.getAll = function () {
        return Promise.resolve(this.getNotifications(undefined, true, true));
    };
    /**
     * Get all the notification ids.
     *
     * @returns {Promise<Array<number>>}
     */
    LocalNotificationsMock.prototype.getAllIds = function () {
        var ids = this.utils.mergeArraysWithoutDuplicates(Object.keys(this.scheduled), Object.keys(this.triggered));
        ids = ids.map(function (id) {
            return Number(id);
        });
        return Promise.resolve(ids);
    };
    /**
     * Get all the notification stored in local DB.
     *
     * @return {Promise<any>} Promise resolved with the notifications.
     */
    LocalNotificationsMock.prototype.getAllNotifications = function () {
        return this.appDB.getAllRecords(this.DESKTOP_NOTIFS_TABLE);
    };
    /**
     * Get all scheduled notification objects.
     *
     * @returns {Promise<Array<ILocalNotification>>}
     */
    LocalNotificationsMock.prototype.getAllScheduled = function () {
        return Promise.resolve(this.getNotifications(undefined, true, false));
    };
    /**
     * Get all triggered notification objects.
     *
     * @returns {Promise<Array<ILocalNotification>>}
     */
    LocalNotificationsMock.prototype.getAllTriggered = function () {
        return Promise.resolve(this.getNotifications(undefined, false, true));
    };
    /**
     * Get a set of notifications. If ids isn't specified, return all the notifications.
     *
     * @param {Number[]} [ids] Ids of notifications to get. If not specified, get all notifications.
     * @param {boolean} [getScheduled] Get scheduled notifications.
     * @param {boolean} [getTriggered] Get triggered notifications.
     * @return {ILocalNotification[]} List of notifications.
     */
    LocalNotificationsMock.prototype.getNotifications = function (ids, getScheduled, getTriggered) {
        var notifications = [];
        if (getScheduled) {
            for (var id in this.scheduled) {
                if (!ids || ids.indexOf(Number(id)) != -1) {
                    notifications.push(this.scheduled[id].notification);
                }
            }
        }
        if (getTriggered) {
            for (var id in this.triggered) {
                if ((!getScheduled || !this.scheduled[id]) && (!ids || ids.indexOf(Number(id)) != -1)) {
                    notifications.push(this.triggered[id].notification);
                }
            }
        }
        return notifications;
    };
    /**
     * Get a scheduled notification object.
     *
     * @param {any} notificationId The id of the notification to ge.
     * @returns {Promise<ILocalNotification>}
     */
    LocalNotificationsMock.prototype.getScheduled = function (notificationId) {
        return Promise.resolve(this.getNotifications([Number(notificationId)], true, false)[0]);
    };
    /**
     * Get the ids of scheduled notifications.
     *
     * @returns {Promise<Array<number>>} Returns a promise
     */
    LocalNotificationsMock.prototype.getScheduledIds = function () {
        var ids = Object.keys(this.scheduled).map(function (id) {
            return Number(id);
        });
        return Promise.resolve(ids);
    };
    /**
     * Get a triggered notification object.
     *
     * @param {any} notificationId The id of the notification to get.
     * @returns {Promise<ILocalNotification>}
     */
    LocalNotificationsMock.prototype.getTriggered = function (notificationId) {
        return Promise.resolve(this.getNotifications([Number(notificationId)], false, true)[0]);
    };
    /**
     * Get the ids of triggered notifications.
     *
     * @returns {Promise<Array<number>>}
     */
    LocalNotificationsMock.prototype.getTriggeredIds = function () {
        var ids = Object.keys(this.triggered).map(function (id) {
            return Number(id);
        });
        return Promise.resolve(ids);
    };
    /**
     * Given an object of options and a list of properties, return the first property that exists.
     * Code extracted from the Cordova plugin.
     *
     * @param {ILocalNotification} notification Notification.
     * @param {any} ...args List of keys to check.
     * @return {any} First value found.
     */
    LocalNotificationsMock.prototype.getValueFor = function (notification) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        for (var i in args) {
            var key = args[i];
            if (notification.hasOwnProperty(key)) {
                return notification[key];
            }
        }
    };
    /**
     * Informs if the app has the permission to show notifications.
     *
     * @returns {Promise<boolean>}
     */
    LocalNotificationsMock.prototype.hasPermission = function () {
        return Promise.resolve(true);
    };
    /**
     * Checks presence of a notification.
     *
     * @param {number} notificationId Notification ID.
     * @returns {Promise<boolean>}
     */
    LocalNotificationsMock.prototype.isPresent = function (notificationId) {
        return Promise.resolve(!!this.scheduled[notificationId] || !!this.triggered[notificationId]);
    };
    /**
     * Checks is a notification is scheduled.
     *
     * @param {number} notificationId Notification ID.
     * @returns {Promise<boolean>}
     */
    LocalNotificationsMock.prototype.isScheduled = function (notificationId) {
        return Promise.resolve(!!this.scheduled[notificationId]);
    };
    /**
     * Checks if a notification is triggered.
     *
     * @param {number} notificationId Notification ID.
     * @returns {Promise<boolean>}
     */
    LocalNotificationsMock.prototype.isTriggered = function (notificationId) {
        return Promise.resolve(!!this.triggered[notificationId]);
    };
    /**
     * Loads an initialize the API for desktop.
     *
     * @return {Promise<any>} Promise resolved when done.
     */
    LocalNotificationsMock.prototype.load = function () {
        var _this = this;
        if (!this.appProvider.isDesktop()) {
            return Promise.resolve();
        }
        if (this.appProvider.isWindows()) {
            try {
                this.winNotif = __webpack_require__(1017);
            }
            catch (ex) {
                // Ignore errors.
            }
        }
        // App is being loaded, re-schedule all the notifications that were scheduled before.
        return this.getAllNotifications().catch(function () {
            return [];
        }).then(function (notifications) {
            notifications.forEach(function (notification) {
                if (notification.triggered) {
                    // Notification was triggered already, store it in memory but don't schedule it again.
                    delete notification.triggered;
                    _this.scheduled[notification.id] = {
                        notification: notification
                    };
                    _this.triggered[notification.id] = notification;
                }
                else {
                    // Schedule the notification again unless it should have been triggered more than an hour ago.
                    delete notification.triggered;
                    notification.at = notification.at * 1000;
                    if (notification.at - Date.now() > -__WEBPACK_IMPORTED_MODULE_4__constants__["a" /* CoreConstants */].SECONDS_HOUR * 1000) {
                        _this.schedule(notification);
                    }
                }
            });
        });
    };
    /**
     * Merge notification options with default values.
     * Code extracted from the Cordova plugin.
     *
     * @param {ILocalNotification} notification Notification.
     * @return {ILocalNotification} Treated notification.
     */
    LocalNotificationsMock.prototype.mergeWithDefaults = function (notification) {
        notification.at = this.getValueFor(notification, 'at', 'firstAt', 'date');
        notification.text = this.getValueFor(notification, 'text', 'message');
        notification.data = this.getValueFor(notification, 'data', 'json');
        if (notification.at === undefined || notification.at === null) {
            notification.at = new Date();
        }
        for (var key in this.defaults) {
            if (notification[key] === null || notification[key] === undefined) {
                if (notification.hasOwnProperty(key) && ['data', 'sound'].indexOf(key) > -1) {
                    notification[key] = undefined;
                }
                else {
                    notification[key] = this.defaults[key];
                }
            }
        }
        for (var key in notification) {
            if (!this.defaults.hasOwnProperty(key)) {
                delete notification[key];
            }
        }
        return notification;
    };
    /**
     * Function called when a notification is clicked.
     *
     * @param {ILocalNotification} notification Clicked notification.
     */
    LocalNotificationsMock.prototype.notificationClicked = function (notification) {
        this.triggerEvent('click', notification, 'foreground');
        // Focus the app.
        __webpack_require__(146).ipcRenderer.send('focusApp');
    };
    /**
     * Sets a callback for a specific event.
     *
     * @param {string} eventName Name of the event. Events: schedule, trigger, click, update, clear, clearall, cancel, cancelall
     * @param {any} callback Call back function.
     */
    LocalNotificationsMock.prototype.on = function (eventName, callback) {
        if (!this.observers[eventName] || typeof callback != 'function') {
            // Event not supported, stop.
            return;
        }
        this.observers[eventName].push(callback);
    };
    /**
     * Parse a interval and convert it to a number of milliseconds (0 if not valid).
     * Code extracted from the Cordova plugin.
     *
     * @param {string} every Interval to convert.
     * @return {number} Number of milliseconds of the interval-
     */
    LocalNotificationsMock.prototype.parseInterval = function (every) {
        var interval;
        every = String(every).toLowerCase();
        if (!every || every == 'undefined') {
            interval = 0;
        }
        else if (every == 'second') {
            interval = 1000;
        }
        else if (every == 'minute') {
            interval = __WEBPACK_IMPORTED_MODULE_4__constants__["a" /* CoreConstants */].SECONDS_MINUTE * 1000;
        }
        else if (every == 'hour') {
            interval = __WEBPACK_IMPORTED_MODULE_4__constants__["a" /* CoreConstants */].SECONDS_HOUR * 1000;
        }
        else if (every == 'day') {
            interval = __WEBPACK_IMPORTED_MODULE_4__constants__["a" /* CoreConstants */].SECONDS_DAY * 1000;
        }
        else if (every == 'week') {
            interval = __WEBPACK_IMPORTED_MODULE_4__constants__["a" /* CoreConstants */].SECONDS_DAY * 7 * 1000;
        }
        else if (every == 'month') {
            interval = __WEBPACK_IMPORTED_MODULE_4__constants__["a" /* CoreConstants */].SECONDS_DAY * 31 * 1000;
        }
        else if (every == 'quarter') {
            interval = __WEBPACK_IMPORTED_MODULE_4__constants__["a" /* CoreConstants */].SECONDS_HOUR * 2190 * 1000;
        }
        else if (every == 'year') {
            interval = __WEBPACK_IMPORTED_MODULE_4__constants__["a" /* CoreConstants */].SECONDS_YEAR * 1000;
        }
        else {
            interval = parseInt(every, 10);
            if (isNaN(interval)) {
                interval = 0;
            }
            else {
                interval *= 60000;
            }
        }
        return interval;
    };
    /**
     * Register permission to show notifications if not already granted.
     *
     * @returns {Promise<boolean>}
     */
    LocalNotificationsMock.prototype.registerPermission = function () {
        return Promise.resolve(true);
    };
    /**
     * Remove a notification from local DB.
     *
     * @param {number} id ID of the notification.
     * @return {Promise<any>} Promise resolved when done.
     */
    LocalNotificationsMock.prototype.removeNotification = function (id) {
        return this.appDB.deleteRecords(this.DESKTOP_NOTIFS_TABLE, { id: id });
    };
    /**
     * Schedules a single or multiple notifications.
     *
     * @param {ILocalNotification | Array<ILocalNotification>} [options] Notification or notifications.
     */
    LocalNotificationsMock.prototype.schedule = function (options) {
        this.scheduleOrUpdate(options);
    };
    /**
     * Schedules or updates a single or multiple notifications.
     *
     * @param {ILocalNotification | Array<ILocalNotification>} [options] Notification or notifications.
     * @param {string} [eventName] Name of the event: schedule or update.
     */
    LocalNotificationsMock.prototype.scheduleOrUpdate = function (options, eventName) {
        var _this = this;
        if (eventName === void 0) { eventName = 'schedule'; }
        options = Array.isArray(options) ? options : [options];
        options.forEach(function (notification) {
            _this.mergeWithDefaults(notification);
            _this.convertProperties(notification);
            // Cancel current notification if exists.
            _this.cancelNotification(notification.id, true, 'cancel');
            // Store the notification in the scheduled list and in the DB.
            _this.scheduled[notification.id] = {
                notification: notification
            };
            _this.storeNotification(notification, false);
            if (Math.abs(__WEBPACK_IMPORTED_MODULE_6_moment__().diff(notification.at * 1000, 'days')) > 15) {
                // Notification should trigger more than 15 days from now, don't schedule it.
                return;
            }
            // Schedule the notification.
            var toTriggerTime = notification.at * 1000 - Date.now(), trigger = function () {
                // Trigger the notification.
                _this.triggerNotification(notification);
                // Store the notification as triggered. Don't remove it from scheduled, it's how the plugin works.
                _this.triggered[notification.id] = notification;
                _this.storeNotification(notification, true);
                // Launch the trigger event.
                _this.triggerEvent('trigger', notification, 'foreground');
                if (notification.every && _this.scheduled[notification.id] && !_this.scheduled[notification.id].interval) {
                    var interval = _this.parseInterval(notification.every);
                    if (interval > 0) {
                        _this.scheduled[notification.id].interval = setInterval(trigger, interval);
                    }
                }
            };
            _this.scheduled[notification.id].timeout = setTimeout(trigger, toTriggerTime);
            // Launch the scheduled/update event.
            _this.triggerEvent(eventName, notification, 'foreground');
        });
    };
    /**
     * Store a notification in local DB.
     *
     * @param {any} notification Notification to store.
     * @param {boolean} triggered Whether the notification has been triggered.
     * @return {Promise<any>} Promise resolved when stored.
     */
    LocalNotificationsMock.prototype.storeNotification = function (notification, triggered) {
        notification = Object.assign({}, notification); // Clone the object.
        notification.triggered = !!triggered;
        return this.appDB.insertOrUpdateRecord(this.DESKTOP_NOTIFS_TABLE, notification, { id: notification.id });
    };
    /**
     * Trigger an event.
     *
     * @param {string} eventName Event name.
     * @param {any[]} ...args List of parameters to pass.
     */
    LocalNotificationsMock.prototype.triggerEvent = function (eventName) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (this.observers[eventName]) {
            this.observers[eventName].forEach(function (callback) {
                callback.apply(null, args);
            });
        }
    };
    /**
     * Trigger a notification, using the best method depending on the OS.
     *
     * @param {ILocalNotification} notification Notification to trigger.
     */
    LocalNotificationsMock.prototype.triggerNotification = function (notification) {
        var _this = this;
        if (this.winNotif) {
            // Use Windows notifications.
            var notifInstance = new this.winNotif.ToastNotification({
                appId: __WEBPACK_IMPORTED_MODULE_5__configconstants__["a" /* CoreConfigConstants */].app_id,
                template: this.toastTemplate,
                strings: [notification.title, notification.text]
            });
            // Listen for click events.
            notifInstance.on('activated', function () {
                _this.notificationClicked(notification);
            });
            notifInstance.show();
            try {
                // Show it in Tile too.
                var tileNotif = new this.winNotif.TileNotification({
                    tag: notification.id + '',
                    template: this.tileTemplate,
                    strings: [notification.title, notification.text, notification.title, notification.text, notification.title,
                        notification.text],
                    expirationTime: new Date(Date.now() + __WEBPACK_IMPORTED_MODULE_4__constants__["a" /* CoreConstants */].SECONDS_HOUR * 1000) // Expire in 1 hour.
                });
                tileNotif.show();
            }
            catch (ex) {
                // tslint:disable-next-line
                console.warn('Error showing TileNotification. Please notice they only work with the app installed.', ex);
            }
        }
        else {
            // Use Electron default notifications.
            var notifInstance = new Notification(notification.title, {
                body: notification.text
            });
            // Listen for click events.
            notifInstance.onclick = function () {
                _this.notificationClicked(notification);
            };
        }
    };
    /**
     * Removes a callback of a specific event.
     *
     * @param {string} eventName Name of the event. Events: schedule, trigger, click, update, clear, clearall, cancel, cancelall
     * @param {any} callback Call back function.
     */
    LocalNotificationsMock.prototype.un = function (eventName, callback) {
        if (this.observers[eventName] && this.observers[eventName].length) {
            for (var i = 0; i < this.observers[eventName].length; i++) {
                if (this.observers[eventName][i] == callback) {
                    this.observers[eventName].splice(i, 1);
                    break;
                }
            }
        }
    };
    /**
     * Updates a previously scheduled notification. Must include the id in the options parameter.
     *
     * @param {ILocalNotification} [options] Notification.
     */
    LocalNotificationsMock.prototype.update = function (options) {
        return this.scheduleOrUpdate(options, 'update');
    };
    LocalNotificationsMock = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], LocalNotificationsMock);
    return LocalNotificationsMock;
}(__WEBPACK_IMPORTED_MODULE_1__ionic_native_local_notifications__["a" /* LocalNotifications */]));

//# sourceMappingURL=local-notifications.js.map

/***/ }),

/***/ 1034:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MediaCaptureMock; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_media_capture__ = __webpack_require__(215);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__capture_helper__ = __webpack_require__(145);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Emulates the Cordova MediaCapture plugin in desktop apps and in browser.
 */
var MediaCaptureMock = /** @class */ (function (_super) {
    __extends(MediaCaptureMock, _super);
    function MediaCaptureMock(captureHelper) {
        var _this = _super.call(this) || this;
        _this.captureHelper = captureHelper;
        return _this;
    }
    /**
     * Start the audio recorder application and return information about captured audio clip files.
     *
     * @param {CaptureAudioOptions} options Options.
     * @return {Promise<any>} Promise resolved when captured.
     */
    MediaCaptureMock.prototype.captureAudio = function (options) {
        return this.captureHelper.captureMedia('audio', options);
    };
    /**
     * Start the camera application and return information about captured image files.
     *
     * @param {CaptureImageOptions} options Options.
     * @return {Promise<any>} Promise resolved when captured.
     */
    MediaCaptureMock.prototype.captureImage = function (options) {
        return this.captureHelper.captureMedia('captureimage', options);
    };
    /**
     * Start the video recorder application and return information about captured video clip files.
     *
     * @param {CaptureVideoOptions} options Options.
     * @return {Promise<any>} Promise resolved when captured.
     */
    MediaCaptureMock.prototype.captureVideo = function (options) {
        return this.captureHelper.captureMedia('video', options);
    };
    MediaCaptureMock = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__capture_helper__["a" /* CoreEmulatorCaptureHelperProvider */]])
    ], MediaCaptureMock);
    return MediaCaptureMock;
}(__WEBPACK_IMPORTED_MODULE_1__ionic_native_media_capture__["a" /* MediaCapture */]));

//# sourceMappingURL=media-capture.js.map

/***/ }),

/***/ 1035:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return NetworkMock; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_network__ = __webpack_require__(102);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_rxjs__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Emulates the Cordova Globalization plugin in desktop apps and in browser.
 */
var NetworkMock = /** @class */ (function (_super) {
    __extends(NetworkMock, _super);
    function NetworkMock() {
        var _this = _super.call(this) || this;
        window.Connection = {
            UNKNOWN: 'unknown',
            ETHERNET: 'ethernet',
            WIFI: 'wifi',
            CELL_2G: '2g',
            CELL_3G: '3g',
            CELL_4G: '4g',
            CELL: 'cellular',
            NONE: 'none'
        };
        return _this;
    }
    /**
     * Returns an observable to watch connection changes.
     *
     * @return {Observable<any>} Observable.
     */
    NetworkMock.prototype.onchange = function () {
        return __WEBPACK_IMPORTED_MODULE_2_rxjs__["Observable"].merge(this.onConnect(), this.onDisconnect());
    };
    /**
     * Returns an observable to notify when the app is connected.
     *
     * @return {Observable<any>} Observable.
     */
    NetworkMock.prototype.onConnect = function () {
        var observable = new __WEBPACK_IMPORTED_MODULE_2_rxjs__["Subject"]();
        window.addEventListener('online', function (ev) {
            observable.next(ev);
        }, false);
        return observable;
    };
    /**
     * Returns an observable to notify when the app is disconnected.
     *
     * @return {Observable<any>} Observable.
     */
    NetworkMock.prototype.onDisconnect = function () {
        var observable = new __WEBPACK_IMPORTED_MODULE_2_rxjs__["Subject"]();
        window.addEventListener('offline', function (ev) {
            observable.next(ev);
        }, false);
        return observable;
    };
    NetworkMock = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [])
    ], NetworkMock);
    return NetworkMock;
}(__WEBPACK_IMPORTED_MODULE_1__ionic_native_network__["a" /* Network */]));

//# sourceMappingURL=network.js.map

/***/ }),

/***/ 1036:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ZipMock; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_zip__ = __webpack_require__(213);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_jszip__ = __webpack_require__(1037);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_jszip___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_jszip__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_file__ = __webpack_require__(106);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_mimetype__ = __webpack_require__(38);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Emulates the Cordova Zip plugin in desktop apps and in browser.
 */
var ZipMock = /** @class */ (function (_super) {
    __extends(ZipMock, _super);
    function ZipMock(file, mimeUtils) {
        var _this = _super.call(this) || this;
        _this.file = file;
        _this.mimeUtils = mimeUtils;
        return _this;
    }
    /**
     * Extracts files from a ZIP archive.
     *
     * @param {string} source Path to the source ZIP file.
     * @param {string} destination Destination folder.
     * @param {Function} [onProgress] Optional callback to be called on progress update
     * @return {Promise<number>} Promise that resolves with a number. 0 is success, -1 is error.
     */
    ZipMock.prototype.unzip = function (source, destination, onProgress) {
        var _this = this;
        // Replace all %20 with spaces.
        source = source.replace(/%20/g, ' ');
        destination = destination.replace(/%20/g, ' ');
        var sourceDir = source.substring(0, source.lastIndexOf('/')), sourceName = source.substr(source.lastIndexOf('/') + 1);
        return this.file.readAsArrayBuffer(sourceDir, sourceName).then(function (data) {
            var zip = new __WEBPACK_IMPORTED_MODULE_2_jszip__["JSZip"](data), promises = [], total = Object.keys(zip.files).length;
            var loaded = 0;
            if (!zip.files || !zip.files.length) {
                // Nothing to extract.
                return 0;
            }
            zip.files.forEach(function (file, name) {
                var type, promise;
                if (!file.dir) {
                    // It's a file. Get the mimetype and write the file.
                    type = _this.mimeUtils.getMimeType(_this.mimeUtils.getFileExtension(name));
                    promise = _this.file.writeFile(destination, name, new Blob([file.asArrayBuffer()], { type: type }));
                }
                else {
                    // It's a folder, create it if it doesn't exist.
                    promise = _this.file.createDir(destination, name, false);
                }
                promises.push(promise.then(function () {
                    // File unzipped, call the progress.
                    loaded++;
                    onProgress && onProgress({ loaded: loaded, total: total });
                }));
            });
            return Promise.all(promises).then(function () {
                return 0;
            });
        }).catch(function () {
            // Error.
            return -1;
        });
    };
    ZipMock = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__ionic_native_file__["a" /* File */], __WEBPACK_IMPORTED_MODULE_4__providers_utils_mimetype__["a" /* CoreMimetypeUtilsProvider */]])
    ], ZipMock);
    return ZipMock;
}(__WEBPACK_IMPORTED_MODULE_1__ionic_native_zip__["a" /* Zip */]));

//# sourceMappingURL=zip.js.map

/***/ }),

/***/ 1040:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 1085:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreEmulatorHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_file__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_file__ = __webpack_require__(106);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ionic_native_local_notifications__ = __webpack_require__(138);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_init__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__file_transfer__ = __webpack_require__(590);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__capture_helper__ = __webpack_require__(145);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








/**
 * Helper service for the emulator feature. It also acts as an init handler.
 */
var CoreEmulatorHelperProvider = /** @class */ (function () {
    function CoreEmulatorHelperProvider(file, fileProvider, utils, initDelegate, localNotif, captureHelper) {
        this.file = file;
        this.fileProvider = fileProvider;
        this.utils = utils;
        this.localNotif = localNotif;
        this.captureHelper = captureHelper;
        this.name = 'CoreEmulator';
        this.priority = __WEBPACK_IMPORTED_MODULE_5__providers_init__["a" /* CoreInitDelegate */].MAX_RECOMMENDED_PRIORITY + 500;
        this.blocking = true;
    }
    /**
     * Load the Mocks that need it.
     *
     * @return {Promise<void>} Promise resolved when loaded.
     */
    CoreEmulatorHelperProvider.prototype.load = function () {
        var _this = this;
        var promises = [];
        promises.push(this.file.load().then(function (basePath) {
            _this.fileProvider.setHTMLBasePath(basePath);
        }));
        promises.push(this.localNotif.load());
        promises.push(this.captureHelper.load());
        window.FileTransferError = __WEBPACK_IMPORTED_MODULE_6__file_transfer__["a" /* FileTransferErrorMock */];
        return this.utils.allPromises(promises);
    };
    CoreEmulatorHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__ionic_native_file__["a" /* File */], __WEBPACK_IMPORTED_MODULE_1__providers_file__["a" /* CoreFileProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_5__providers_init__["a" /* CoreInitDelegate */], __WEBPACK_IMPORTED_MODULE_4__ionic_native_local_notifications__["a" /* LocalNotifications */],
            __WEBPACK_IMPORTED_MODULE_7__capture_helper__["a" /* CoreEmulatorCaptureHelperProvider */]])
    ], CoreEmulatorHelperProvider);
    return CoreEmulatorHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),

/***/ 1086:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 1087:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreLoginModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_helper__ = __webpack_require__(41);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


var CoreLoginModule = /** @class */ (function () {
    function CoreLoginModule() {
    }
    CoreLoginModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [],
            providers: [
                __WEBPACK_IMPORTED_MODULE_1__providers_helper__["a" /* CoreLoginHelperProvider */]
            ]
        })
    ], CoreLoginModule);
    return CoreLoginModule;
}());

//# sourceMappingURL=login.module.js.map

/***/ }),

/***/ 1088:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreMainMenuModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_delegate__ = __webpack_require__(88);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_mainmenu__ = __webpack_require__(643);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};



var CoreMainMenuModule = /** @class */ (function () {
    function CoreMainMenuModule() {
    }
    CoreMainMenuModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [],
            providers: [
                __WEBPACK_IMPORTED_MODULE_1__providers_delegate__["a" /* CoreMainMenuDelegate */],
                __WEBPACK_IMPORTED_MODULE_2__providers_mainmenu__["a" /* CoreMainMenuProvider */]
            ]
        })
    ], CoreMainMenuModule);
    return CoreMainMenuModule;
}());

//# sourceMappingURL=mainmenu.module.js.map

/***/ }),

/***/ 1089:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCoursesModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_courses__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_mainmenu_handler__ = __webpack_require__(1090);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_my_overview__ = __webpack_require__(156);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_course_link_handler__ = __webpack_require__(1091);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_courses_index_link_handler__ = __webpack_require__(1092);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_my_overview_link_handler__ = __webpack_require__(1093);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__mainmenu_providers_delegate__ = __webpack_require__(88);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__contentlinks_providers_delegate__ = __webpack_require__(87);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};









var CoreCoursesModule = /** @class */ (function () {
    function CoreCoursesModule(mainMenuDelegate, contentLinksDelegate, mainMenuHandler, courseLinkHandler, indexLinkHandler, myOverviewLinkHandler) {
        mainMenuDelegate.registerHandler(mainMenuHandler);
        contentLinksDelegate.registerHandler(courseLinkHandler);
        contentLinksDelegate.registerHandler(indexLinkHandler);
        contentLinksDelegate.registerHandler(myOverviewLinkHandler);
    }
    CoreCoursesModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [],
            providers: [
                __WEBPACK_IMPORTED_MODULE_1__providers_courses__["a" /* CoreCoursesProvider */],
                __WEBPACK_IMPORTED_MODULE_2__providers_mainmenu_handler__["a" /* CoreCoursesMainMenuHandler */],
                __WEBPACK_IMPORTED_MODULE_3__providers_my_overview__["a" /* CoreCoursesMyOverviewProvider */],
                __WEBPACK_IMPORTED_MODULE_4__providers_course_link_handler__["a" /* CoreCoursesCourseLinkHandler */],
                __WEBPACK_IMPORTED_MODULE_5__providers_courses_index_link_handler__["a" /* CoreCoursesIndexLinkHandler */],
                __WEBPACK_IMPORTED_MODULE_6__providers_my_overview_link_handler__["a" /* CoreCoursesMyOverviewLinkHandler */]
            ],
            exports: []
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_7__mainmenu_providers_delegate__["a" /* CoreMainMenuDelegate */], __WEBPACK_IMPORTED_MODULE_8__contentlinks_providers_delegate__["a" /* CoreContentLinksDelegate */],
            __WEBPACK_IMPORTED_MODULE_2__providers_mainmenu_handler__["a" /* CoreCoursesMainMenuHandler */], __WEBPACK_IMPORTED_MODULE_4__providers_course_link_handler__["a" /* CoreCoursesCourseLinkHandler */],
            __WEBPACK_IMPORTED_MODULE_5__providers_courses_index_link_handler__["a" /* CoreCoursesIndexLinkHandler */], __WEBPACK_IMPORTED_MODULE_6__providers_my_overview_link_handler__["a" /* CoreCoursesMyOverviewLinkHandler */]])
    ], CoreCoursesModule);
    return CoreCoursesModule;
}());

//# sourceMappingURL=courses.module.js.map

/***/ }),

/***/ 1090:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCoursesMainMenuHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__courses__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_my_overview__ = __webpack_require__(156);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Handler to add My Courses or My Overview into main menu.
 */
var CoreCoursesMainMenuHandler = /** @class */ (function () {
    function CoreCoursesMainMenuHandler(coursesProvider, myOverviewProvider) {
        this.coursesProvider = coursesProvider;
        this.myOverviewProvider = myOverviewProvider;
        this.name = 'CoreCourses';
        this.priority = 1100;
    }
    /**
     * Check if the handler is enabled on a site level.
     *
     * @return {boolean | Promise<boolean>} Whether or not the handler is enabled on a site level.
     */
    CoreCoursesMainMenuHandler.prototype.isEnabled = function () {
        var _this = this;
        // Check if my overview is enabled.
        return this.myOverviewProvider.isEnabled().then(function (enabled) {
            _this.isOverviewEnabled = enabled;
            if (enabled) {
                return true;
            }
            // My overview not enabled, check if my courses is enabled.
            return !_this.coursesProvider.isMyCoursesDisabledInSite();
        });
    };
    /**
     * Returns the data needed to render the handler.
     *
     * @return {CoreMainMenuHandlerData} Data needed to render the handler.
     */
    CoreCoursesMainMenuHandler.prototype.getDisplayData = function () {
        if (this.isOverviewEnabled) {
            return {
                icon: 'ionic',
                title: 'core.courses.courseoverview',
                page: 'CoreCoursesMyOverviewPage',
                class: 'core-courseoverview-handler'
            };
        }
        else {
            return {
                icon: 'ionic',
                title: 'core.courses.mycourses',
                page: 'CoreCoursesMyCoursesPage',
                class: 'core-mycourses-handler'
            };
        }
    };
    CoreCoursesMainMenuHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__courses__["a" /* CoreCoursesProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_my_overview__["a" /* CoreCoursesMyOverviewProvider */]])
    ], CoreCoursesMainMenuHandler);
    return CoreCoursesMainMenuHandler;
}());

//# sourceMappingURL=mainmenu-handler.js.map

/***/ }),

/***/ 1091:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCoursesCourseLinkHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__contentlinks_classes_base_handler__ = __webpack_require__(84);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__login_providers_helper__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__course_providers_course__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__courses__ = __webpack_require__(57);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








/**
 * Handler to treat links to course view or enrol (except site home).
 */
var CoreCoursesCourseLinkHandler = /** @class */ (function (_super) {
    __extends(CoreCoursesCourseLinkHandler, _super);
    function CoreCoursesCourseLinkHandler(sitesProvider, coursesProvider, loginHelper, domUtils, translate, courseProvider) {
        var _this = _super.call(this) || this;
        _this.sitesProvider = sitesProvider;
        _this.coursesProvider = coursesProvider;
        _this.loginHelper = loginHelper;
        _this.domUtils = domUtils;
        _this.translate = translate;
        _this.courseProvider = courseProvider;
        _this.name = 'CoreCoursesCourseLinkHandler';
        _this.pattern = /((\/enrol\/index\.php)|(\/course\/enrol\.php)|(\/course\/view\.php)).*([\?\&]id=\d+)/;
        _this.waitStart = 0;
        return _this;
    }
    /**
     * Get the list of actions for a link (url).
     *
     * @param {string[]} siteIds List of sites the URL belongs to.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {CoreContentLinksAction[]|Promise<CoreContentLinksAction[]>} List of (or promise resolved with list of) actions.
     */
    CoreCoursesCourseLinkHandler.prototype.getActions = function (siteIds, url, params, courseId) {
        var _this = this;
        courseId = parseInt(params.id, 10);
        var sectionId = params.sectionid ? parseInt(params.sectionid, 10) : null, sectionNumber = typeof params.section != 'undefined' ? parseInt(params.section, 10) : NaN, pageParams = {
            course: { id: courseId },
            sectionId: sectionId || null
        };
        if (!isNaN(sectionNumber)) {
            pageParams.sectionNumber = sectionNumber;
        }
        return [{
                action: function (siteId, navCtrl) {
                    siteId = siteId || _this.sitesProvider.getCurrentSiteId();
                    if (siteId == _this.sitesProvider.getCurrentSiteId()) {
                        _this.actionEnrol(courseId, url, pageParams).catch(function () {
                            // Ignore errors.
                        });
                    }
                    else {
                        // Use redirect to make the course the new history root (to avoid "loops" in history).
                        _this.loginHelper.redirect('CoreCourseSectionPage', pageParams, siteId);
                    }
                }
            }];
    };
    /**
     * Check if the handler is enabled for a certain site (site + user) and a URL.
     * If not defined, defaults to true.
     *
     * @param {string} siteId The site ID.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {boolean|Promise<boolean>} Whether the handler is enabled for the URL and site.
     */
    CoreCoursesCourseLinkHandler.prototype.isEnabled = function (siteId, url, params, courseId) {
        courseId = parseInt(params.id, 10);
        if (!courseId) {
            return false;
        }
        // Get the course id of Site Home.
        return this.sitesProvider.getSiteHomeId(siteId).then(function (siteHomeId) {
            return courseId != siteHomeId;
        });
    };
    /**
     * Action to perform when an enrol link is clicked.
     *
     * @param {number} courseId Course ID.
     * @param {string} url Treated URL.
     * @param {any} pageParams Params to send to the new page.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCoursesCourseLinkHandler.prototype.actionEnrol = function (courseId, url, pageParams) {
        var _this = this;
        var modal = this.domUtils.showModalLoading(), isEnrolUrl = !!url.match(/(\/enrol\/index\.php)|(\/course\/enrol\.php)/);
        // Check if user is enrolled in the course.
        return this.coursesProvider.getUserCourse(courseId).catch(function () {
            // User is not enrolled in the course. Check if can self enrol.
            return _this.canSelfEnrol(courseId).then(function () {
                modal.dismiss();
                // The user can self enrol. If it's not a enrolment URL we'll ask for confirmation.
                var promise = isEnrolUrl ? Promise.resolve() :
                    _this.domUtils.showConfirm(_this.translate.instant('core.courses.confirmselfenrol'));
                return promise.then(function () {
                    // Enrol URL or user confirmed.
                    return _this.selfEnrol(courseId).catch(function (error) {
                        if (error) {
                            _this.domUtils.showErrorModal(error);
                        }
                        return Promise.reject(null);
                    });
                }, function () {
                    // User cancelled. Check if the user can view the course contents (guest access or similar).
                    return _this.courseProvider.getSections(courseId, false, true);
                });
            }, function (error) {
                // Can't self enrol. Check if the user can view the course contents (guest access or similar).
                return _this.courseProvider.getSections(courseId, false, true).catch(function () {
                    // Error. Show error message and allow the user to open the link in browser.
                    modal.dismiss();
                    if (error) {
                        error = error.message || error.error || error.content || error.body || error;
                    }
                    if (!error) {
                        error = _this.translate.instant('core.courses.notenroled');
                    }
                    var body = _this.translate.instant('core.twoparagraphs', { p1: error, p2: _this.translate.instant('core.confirmopeninbrowser') });
                    _this.domUtils.showConfirm(body).then(function () {
                        _this.sitesProvider.getCurrentSite().openInBrowserWithAutoLogin(url);
                    }).catch(function () {
                        // User cancelled.
                    });
                    return Promise.reject(null);
                });
            });
        }).then(function () {
            modal.dismiss();
            // Use redirect to make the course the new history root (to avoid "loops" in history).
            _this.loginHelper.redirect('CoreCourseSectionPage', pageParams, _this.sitesProvider.getCurrentSiteId());
        });
    };
    /**
     * Check if a user can be "automatically" self enrolled in a course.
     *
     * @param {number} courseId Course ID.
     * @return {Promise<any>} Promise resolved if user can be enrolled in a course, rejected otherwise.
     */
    CoreCoursesCourseLinkHandler.prototype.canSelfEnrol = function (courseId) {
        // Check that the course has self enrolment enabled.
        return this.coursesProvider.getCourseEnrolmentMethods(courseId).then(function (methods) {
            var isSelfEnrolEnabled = false, instances = 0;
            methods.forEach(function (method) {
                if (method.type == 'self' && method.status) {
                    isSelfEnrolEnabled = true;
                    instances++;
                }
            });
            if (!isSelfEnrolEnabled || instances != 1) {
                // Self enrol not enabled or more than one instance.
                return Promise.reject(null);
            }
        });
    };
    /**
     * Try to self enrol a user in a course.
     *
     * @param {number} courseId Course ID.
     * @param {string} [password] Password.
     * @return {Promise<any>} Promise resolved when the user is enrolled, rejected otherwise.
     */
    CoreCoursesCourseLinkHandler.prototype.selfEnrol = function (courseId, password) {
        var _this = this;
        var modal = this.domUtils.showModalLoading();
        return this.coursesProvider.selfEnrol(courseId, password).then(function () {
            // Success self enrolling the user, invalidate the courses list.
            return _this.coursesProvider.invalidateUserCourses().catch(function () {
                // Ignore errors.
            }).then(function () {
                // Sometimes the list of enrolled courses takes a while to be updated. Wait for it.
                return _this.waitForEnrolled(courseId, true).finally(function () {
                    modal.dismiss();
                });
            });
        }).catch(function (error) {
            modal.dismiss();
            if (error && error.code === __WEBPACK_IMPORTED_MODULE_7__courses__["a" /* CoreCoursesProvider */].ENROL_INVALID_KEY) {
                // Invalid password. Allow the user to input password.
                var title = _this.translate.instant('core.courses.selfenrolment'), body = ' ', // Empty message.
                placeholder = _this.translate.instant('core.courses.password');
                if (typeof password != 'undefined') {
                    // The user attempted a password. Show an error message.
                    _this.domUtils.showErrorModal(error.message);
                }
                return _this.domUtils.showPrompt(body, title, placeholder).then(function (password) {
                    return _this.selfEnrol(courseId, password);
                });
            }
            else {
                return Promise.reject(error);
            }
        });
    };
    /**
     * Wait for the user to be enrolled in a course.
     *
     * @param {number} courseId The course ID.
     * @param {boolean} first If it's the first call (true) or it's a recursive call (false).
     * @return {Promise<any>} Promise resolved when enrolled or timeout.
     */
    CoreCoursesCourseLinkHandler.prototype.waitForEnrolled = function (courseId, first) {
        var _this = this;
        if (first) {
            this.waitStart = Date.now();
        }
        // Check if user is enrolled in the course.
        return this.coursesProvider.invalidateUserCourses().catch(function () {
            // Ignore errors.
        }).then(function () {
            return _this.coursesProvider.getUserCourse(courseId);
        }).catch(function () {
            // Not enrolled, wait a bit and try again.
            if (Date.now() - _this.waitStart > 60000) {
                // Max time reached, stop.
                return;
            }
            return new Promise(function (resolve, reject) {
                setTimeout(function () {
                    _this.waitForEnrolled(courseId).then(resolve);
                }, 5000);
            });
        });
    };
    CoreCoursesCourseLinkHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_7__courses__["a" /* CoreCoursesProvider */],
            __WEBPACK_IMPORTED_MODULE_5__login_providers_helper__["a" /* CoreLoginHelperProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_6__course_providers_course__["a" /* CoreCourseProvider */]])
    ], CoreCoursesCourseLinkHandler);
    return CoreCoursesCourseLinkHandler;
}(__WEBPACK_IMPORTED_MODULE_4__contentlinks_classes_base_handler__["a" /* CoreContentLinksHandlerBase */]));

//# sourceMappingURL=course-link-handler.js.map

/***/ }),

/***/ 1092:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCoursesIndexLinkHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__contentlinks_classes_base_handler__ = __webpack_require__(84);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__login_providers_helper__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__courses__ = __webpack_require__(57);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Handler to treat links to course index (list of courses).
 */
var CoreCoursesIndexLinkHandler = /** @class */ (function (_super) {
    __extends(CoreCoursesIndexLinkHandler, _super);
    function CoreCoursesIndexLinkHandler(coursesProvider, loginHelper) {
        var _this = _super.call(this) || this;
        _this.coursesProvider = coursesProvider;
        _this.loginHelper = loginHelper;
        _this.name = 'CoreCoursesIndexLinkHandler';
        _this.featureName = '$mmSideMenuDelegate_mmCourses';
        _this.pattern = /\/course\/?(index\.php.*)?$/;
        return _this;
    }
    /**
     * Get the list of actions for a link (url).
     *
     * @param {string[]} siteIds List of sites the URL belongs to.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {CoreContentLinksAction[] | Promise<CoreContentLinksAction[]>} List of (or promise resolved with list of) actions.
     */
    CoreCoursesIndexLinkHandler.prototype.getActions = function (siteIds, url, params, courseId) {
        var _this = this;
        return [{
                action: function (siteId, navCtrl) {
                    var page = 'CoreCoursesMyCoursesPage'; // By default, go to My Courses.
                    var pageParams = {};
                    if (_this.coursesProvider.isGetCoursesByFieldAvailable()) {
                        if (params.categoryid) {
                            page = 'CoreCoursesCategoriesPage';
                            pageParams.categoryId = parseInt(params.categoryid, 10);
                        }
                        else {
                            page = 'CoreCoursesAvailableCoursesPage';
                        }
                    }
                    // Always use redirect to make it the new history root (to avoid "loops" in history).
                    _this.loginHelper.redirect(page, pageParams, siteId);
                }
            }];
    };
    CoreCoursesIndexLinkHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__courses__["a" /* CoreCoursesProvider */], __WEBPACK_IMPORTED_MODULE_2__login_providers_helper__["a" /* CoreLoginHelperProvider */]])
    ], CoreCoursesIndexLinkHandler);
    return CoreCoursesIndexLinkHandler;
}(__WEBPACK_IMPORTED_MODULE_1__contentlinks_classes_base_handler__["a" /* CoreContentLinksHandlerBase */]));

//# sourceMappingURL=courses-index-link-handler.js.map

/***/ }),

/***/ 1093:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCoursesMyOverviewLinkHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__contentlinks_classes_base_handler__ = __webpack_require__(84);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__login_providers_helper__ = __webpack_require__(41);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Handler to treat links to my overview.
 */
var CoreCoursesMyOverviewLinkHandler = /** @class */ (function (_super) {
    __extends(CoreCoursesMyOverviewLinkHandler, _super);
    function CoreCoursesMyOverviewLinkHandler(loginHelper) {
        var _this = _super.call(this) || this;
        _this.loginHelper = loginHelper;
        _this.name = 'CoreCoursesMyOverviewLinkHandler';
        _this.featureName = '$mmSideMenuDelegate_mmCourses';
        _this.pattern = /\/my\/?$/;
        return _this;
    }
    /**
     * Get the list of actions for a link (url).
     *
     * @param {string[]} siteIds List of sites the URL belongs to.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {CoreContentLinksAction[]|Promise<CoreContentLinksAction[]>} List of (or promise resolved with list of) actions.
     */
    CoreCoursesMyOverviewLinkHandler.prototype.getActions = function (siteIds, url, params, courseId) {
        var _this = this;
        return [{
                action: function (siteId, navCtrl) {
                    // Always use redirect to make it the new history root (to avoid "loops" in history).
                    _this.loginHelper.redirect('CoreCoursesMyOverviewPage', undefined, siteId);
                }
            }];
    };
    CoreCoursesMyOverviewLinkHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__login_providers_helper__["a" /* CoreLoginHelperProvider */]])
    ], CoreCoursesMyOverviewLinkHandler);
    return CoreCoursesMyOverviewLinkHandler;
}(__WEBPACK_IMPORTED_MODULE_1__contentlinks_classes_base_handler__["a" /* CoreContentLinksHandlerBase */]));

//# sourceMappingURL=my-overview-link-handler.js.map

/***/ }),

/***/ 1094:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFileUploaderModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_fileuploader__ = __webpack_require__(139);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_helper__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_delegate__ = __webpack_require__(217);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_album_handler__ = __webpack_require__(1095);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_audio_handler__ = __webpack_require__(1096);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_camera_handler__ = __webpack_require__(1097);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_file_handler__ = __webpack_require__(1098);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_video_handler__ = __webpack_require__(1099);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};









var CoreFileUploaderModule = /** @class */ (function () {
    function CoreFileUploaderModule(delegate, albumHandler, audioHandler, cameraHandler, videoHandler, fileHandler) {
        delegate.registerHandler(albumHandler);
        delegate.registerHandler(audioHandler);
        delegate.registerHandler(cameraHandler);
        delegate.registerHandler(fileHandler);
        delegate.registerHandler(videoHandler);
    }
    CoreFileUploaderModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [],
            providers: [
                __WEBPACK_IMPORTED_MODULE_1__providers_fileuploader__["a" /* CoreFileUploaderProvider */],
                __WEBPACK_IMPORTED_MODULE_2__providers_helper__["a" /* CoreFileUploaderHelperProvider */],
                __WEBPACK_IMPORTED_MODULE_3__providers_delegate__["a" /* CoreFileUploaderDelegate */],
                __WEBPACK_IMPORTED_MODULE_4__providers_album_handler__["a" /* CoreFileUploaderAlbumHandler */],
                __WEBPACK_IMPORTED_MODULE_5__providers_audio_handler__["a" /* CoreFileUploaderAudioHandler */],
                __WEBPACK_IMPORTED_MODULE_6__providers_camera_handler__["a" /* CoreFileUploaderCameraHandler */],
                __WEBPACK_IMPORTED_MODULE_7__providers_file_handler__["a" /* CoreFileUploaderFileHandler */],
                __WEBPACK_IMPORTED_MODULE_8__providers_video_handler__["a" /* CoreFileUploaderVideoHandler */]
            ]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_delegate__["a" /* CoreFileUploaderDelegate */], __WEBPACK_IMPORTED_MODULE_4__providers_album_handler__["a" /* CoreFileUploaderAlbumHandler */],
            __WEBPACK_IMPORTED_MODULE_5__providers_audio_handler__["a" /* CoreFileUploaderAudioHandler */], __WEBPACK_IMPORTED_MODULE_6__providers_camera_handler__["a" /* CoreFileUploaderCameraHandler */],
            __WEBPACK_IMPORTED_MODULE_8__providers_video_handler__["a" /* CoreFileUploaderVideoHandler */], __WEBPACK_IMPORTED_MODULE_7__providers_file_handler__["a" /* CoreFileUploaderFileHandler */]])
    ], CoreFileUploaderModule);
    return CoreFileUploaderModule;
}());

//# sourceMappingURL=fileuploader.module.js.map

/***/ }),

/***/ 1095:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFileUploaderAlbumHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_app__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__helper__ = __webpack_require__(70);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Handler to upload files from the album.
 */
var CoreFileUploaderAlbumHandler = /** @class */ (function () {
    function CoreFileUploaderAlbumHandler(appProvider, utils, uploaderHelper) {
        this.appProvider = appProvider;
        this.utils = utils;
        this.uploaderHelper = uploaderHelper;
        this.name = 'CoreFileUploaderAlbum';
        this.priority = 2000;
    }
    /**
     * Whether or not the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} True or promise resolved with true if enabled.
     */
    CoreFileUploaderAlbumHandler.prototype.isEnabled = function () {
        return this.appProvider.isMobile();
    };
    /**
     * Given a list of mimetypes, return the ones that are supported by the handler.
     *
     * @param {string[]} [mimetypes] List of mimetypes.
     * @return {string[]} Supported mimetypes.
     */
    CoreFileUploaderAlbumHandler.prototype.getSupportedMimetypes = function (mimetypes) {
        // Album allows picking images and videos.
        return this.utils.filterByRegexp(mimetypes, /^(image|video)\//);
    };
    /**
     * Get the data to display the handler.
     *
     * @return {CoreFileUploaderHandlerData} Data.
     */
    CoreFileUploaderAlbumHandler.prototype.getData = function () {
        var _this = this;
        return {
            title: 'core.fileuploader.photoalbums',
            class: 'core-fileuploader-album-handler',
            icon: 'images',
            action: function (maxSize, upload, allowOffline, mimetypes) {
                return _this.uploaderHelper.uploadImage(true, maxSize, upload, mimetypes).then(function (result) {
                    return {
                        treated: true,
                        result: result
                    };
                });
            }
        };
    };
    CoreFileUploaderAlbumHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_3__helper__["a" /* CoreFileUploaderHelperProvider */]])
    ], CoreFileUploaderAlbumHandler);
    return CoreFileUploaderAlbumHandler;
}());

//# sourceMappingURL=album-handler.js.map

/***/ }),

/***/ 1096:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFileUploaderAudioHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__helper__ = __webpack_require__(70);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Handler to record an audio to upload it.
 */
var CoreFileUploaderAudioHandler = /** @class */ (function () {
    function CoreFileUploaderAudioHandler(appProvider, utils, platform, uploaderHelper) {
        this.appProvider = appProvider;
        this.utils = utils;
        this.platform = platform;
        this.uploaderHelper = uploaderHelper;
        this.name = 'CoreFileUploaderAudio';
        this.priority = 1600;
    }
    /**
     * Whether or not the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} True or promise resolved with true if enabled.
     */
    CoreFileUploaderAudioHandler.prototype.isEnabled = function () {
        return this.appProvider.isMobile() || (this.appProvider.canGetUserMedia() && this.appProvider.canRecordMedia());
    };
    /**
     * Given a list of mimetypes, return the ones that are supported by the handler.
     *
     * @param {string[]} [mimetypes] List of mimetypes.
     * @return {string[]} Supported mimetypes.
     */
    CoreFileUploaderAudioHandler.prototype.getSupportedMimetypes = function (mimetypes) {
        if (this.platform.is('ios')) {
            // In iOS it's recorded as WAV.
            return this.utils.filterByRegexp(mimetypes, /^audio\/wav$/);
        }
        else if (this.platform.is('android')) {
            // In Android we don't know the format the audio will be recorded, so accept any audio mimetype.
            return this.utils.filterByRegexp(mimetypes, /^audio\//);
        }
        else {
            // In desktop, support audio formats that are supported by MediaRecorder.
            var mediaRecorder_1 = window.MediaRecorder;
            if (mediaRecorder_1) {
                return mimetypes.filter(function (type) {
                    var matches = type.match(/^audio\//);
                    return matches && matches.length && mediaRecorder_1.isTypeSupported(type);
                });
            }
        }
        return [];
    };
    /**
     * Get the data to display the handler.
     *
     * @return {CoreFileUploaderHandlerData} Data.
     */
    CoreFileUploaderAudioHandler.prototype.getData = function () {
        var _this = this;
        return {
            title: 'core.fileuploader.audio',
            class: 'core-fileuploader-audio-handler',
            icon: 'microphone',
            action: function (maxSize, upload, allowOffline, mimetypes) {
                return _this.uploaderHelper.uploadAudioOrVideo(true, maxSize, upload, mimetypes).then(function (result) {
                    return {
                        treated: true,
                        result: result
                    };
                });
            }
        };
    };
    CoreFileUploaderAudioHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */],
            __WEBPACK_IMPORTED_MODULE_4__helper__["a" /* CoreFileUploaderHelperProvider */]])
    ], CoreFileUploaderAudioHandler);
    return CoreFileUploaderAudioHandler;
}());

//# sourceMappingURL=audio-handler.js.map

/***/ }),

/***/ 1097:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFileUploaderCameraHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_app__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__helper__ = __webpack_require__(70);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Handler to take a picture to upload it.
 */
var CoreFileUploaderCameraHandler = /** @class */ (function () {
    function CoreFileUploaderCameraHandler(appProvider, utils, uploaderHelper) {
        this.appProvider = appProvider;
        this.utils = utils;
        this.uploaderHelper = uploaderHelper;
        this.name = 'CoreFileUploaderCamera';
        this.priority = 1800;
    }
    /**
     * Whether or not the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} True or promise resolved with true if enabled.
     */
    CoreFileUploaderCameraHandler.prototype.isEnabled = function () {
        return this.appProvider.isMobile() || this.appProvider.canGetUserMedia();
    };
    /**
     * Given a list of mimetypes, return the ones that are supported by the handler.
     *
     * @param {string[]} [mimetypes] List of mimetypes.
     * @return {string[]} Supported mimetypes.
     */
    CoreFileUploaderCameraHandler.prototype.getSupportedMimetypes = function (mimetypes) {
        // Camera only supports JPEG and PNG.
        return this.utils.filterByRegexp(mimetypes, /^image\/(jpeg|png)$/);
    };
    /**
     * Get the data to display the handler.
     *
     * @return {CoreFileUploaderHandlerData} Data.
     */
    CoreFileUploaderCameraHandler.prototype.getData = function () {
        var _this = this;
        return {
            title: 'core.fileuploader.camera',
            class: 'core-fileuploader-camera-handler',
            icon: 'camera',
            action: function (maxSize, upload, allowOffline, mimetypes) {
                return _this.uploaderHelper.uploadImage(false, maxSize, upload, mimetypes).then(function (result) {
                    return {
                        treated: true,
                        result: result
                    };
                });
            }
        };
    };
    CoreFileUploaderCameraHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_3__helper__["a" /* CoreFileUploaderHelperProvider */]])
    ], CoreFileUploaderCameraHandler);
    return CoreFileUploaderCameraHandler;
}());

//# sourceMappingURL=camera-handler.js.map

/***/ }),

/***/ 1098:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFileUploaderFileHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_time__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__helper__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__fileuploader__ = __webpack_require__(139);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};







/**
 * Handler to upload any type of file.
 */
var CoreFileUploaderFileHandler = /** @class */ (function () {
    function CoreFileUploaderFileHandler(appProvider, platform, timeUtils, uploaderHelper, uploaderProvider, domUtils) {
        this.appProvider = appProvider;
        this.platform = platform;
        this.timeUtils = timeUtils;
        this.uploaderHelper = uploaderHelper;
        this.uploaderProvider = uploaderProvider;
        this.domUtils = domUtils;
        this.name = 'CoreFileUploaderFile';
        this.priority = 1200;
    }
    /**
     * Whether or not the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} True or promise resolved with true if enabled.
     */
    CoreFileUploaderFileHandler.prototype.isEnabled = function () {
        return this.platform.is('android') || !this.appProvider.isMobile() ||
            (this.platform.is('ios') && this.platform.version().major >= 9);
    };
    /**
     * Given a list of mimetypes, return the ones that are supported by the handler.
     *
     * @param {string[]} [mimetypes] List of mimetypes.
     * @return {string[]} Supported mimetypes.
     */
    CoreFileUploaderFileHandler.prototype.getSupportedMimetypes = function (mimetypes) {
        return mimetypes;
    };
    /**
     * Get the data to display the handler.
     *
     * @return {CoreFileUploaderHandlerData} Data.
     */
    CoreFileUploaderFileHandler.prototype.getData = function () {
        var _this = this;
        var isIOS = this.platform.is('ios');
        return {
            title: isIOS ? 'core.fileuploader.more' : 'core.fileuploader.file',
            class: 'core-fileuploader-file-handler',
            icon: isIOS ? 'more' : 'folder',
            afterRender: function (maxSize, upload, allowOffline, mimetypes) {
                // Add an invisible file input in the file handler.
                // It needs to be done like this because the action sheet items don't accept inputs.
                var element = document.querySelector('.core-fileuploader-file-handler');
                if (element) {
                    var input_1 = document.createElement('input');
                    input_1.setAttribute('type', 'file');
                    if (mimetypes && mimetypes.length && (!_this.platform.is('android') || mimetypes.length == 1)) {
                        // Don't use accept attribute in Android with several mimetypes, it's not supported.
                        input_1.setAttribute('accept', mimetypes.join(', '));
                    }
                    input_1.addEventListener('change', function (evt) {
                        var file = input_1.files[0];
                        var fileName;
                        input_1.value = ''; // Unset input.
                        if (!file) {
                            return;
                        }
                        // Verify that the mimetype of the file is supported, in case the accept attribute isn't supported.
                        var error = _this.uploaderProvider.isInvalidMimetype(mimetypes, file.name, file.type);
                        if (error) {
                            _this.domUtils.showErrorModal(error);
                            return;
                        }
                        fileName = file.name;
                        if (isIOS) {
                            // Check the name of the file and add a timestamp if needed (take picture).
                            var matches = fileName.match(/image\.(jpe?g|png)/);
                            if (matches) {
                                fileName = 'image_' + _this.timeUtils.readableTimestamp() + '.' + matches[1];
                            }
                        }
                        // Upload the picked file.
                        _this.uploaderHelper.uploadFileObject(file, maxSize, upload, allowOffline, fileName).then(function (result) {
                            _this.uploaderHelper.fileUploaded(result);
                        }).catch(function (error) {
                            if (error) {
                                _this.domUtils.showErrorModal(error);
                            }
                        });
                    });
                    element.appendChild(input_1);
                }
            }
        };
    };
    CoreFileUploaderFileHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */], __WEBPACK_IMPORTED_MODULE_4__providers_utils_time__["a" /* CoreTimeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_5__helper__["a" /* CoreFileUploaderHelperProvider */], __WEBPACK_IMPORTED_MODULE_6__fileuploader__["a" /* CoreFileUploaderProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__["a" /* CoreDomUtilsProvider */]])
    ], CoreFileUploaderFileHandler);
    return CoreFileUploaderFileHandler;
}());

//# sourceMappingURL=file-handler.js.map

/***/ }),

/***/ 1099:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFileUploaderVideoHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__helper__ = __webpack_require__(70);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Handler to record a video to upload it.
 */
var CoreFileUploaderVideoHandler = /** @class */ (function () {
    function CoreFileUploaderVideoHandler(appProvider, utils, platform, uploaderHelper) {
        this.appProvider = appProvider;
        this.utils = utils;
        this.platform = platform;
        this.uploaderHelper = uploaderHelper;
        this.name = 'CoreFileUploaderVideo';
        this.priority = 1400;
    }
    /**
     * Whether or not the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} True or promise resolved with true if enabled.
     */
    CoreFileUploaderVideoHandler.prototype.isEnabled = function () {
        return this.appProvider.isMobile() || (this.appProvider.canGetUserMedia() && this.appProvider.canRecordMedia());
    };
    /**
     * Given a list of mimetypes, return the ones that are supported by the handler.
     *
     * @param {string[]} [mimetypes] List of mimetypes.
     * @return {string[]} Supported mimetypes.
     */
    CoreFileUploaderVideoHandler.prototype.getSupportedMimetypes = function (mimetypes) {
        if (this.platform.is('ios')) {
            // In iOS it's recorded as MOV.
            return this.utils.filterByRegexp(mimetypes, /^video\/quicktime$/);
        }
        else if (this.platform.is('android')) {
            // In Android we don't know the format the video will be recorded, so accept any video mimetype.
            return this.utils.filterByRegexp(mimetypes, /^video\//);
        }
        else {
            // In desktop, support video formats that are supported by MediaRecorder.
            var mediaRecorder_1 = window.MediaRecorder;
            if (mediaRecorder_1) {
                return mimetypes.filter(function (type) {
                    var matches = type.match(/^video\//);
                    return matches && matches.length && mediaRecorder_1.isTypeSupported(type);
                });
            }
        }
        return [];
    };
    /**
     * Get the data to display the handler.
     *
     * @return {CoreFileUploaderHandlerData} Data.
     */
    CoreFileUploaderVideoHandler.prototype.getData = function () {
        var _this = this;
        return {
            title: 'core.fileuploader.video',
            class: 'core-fileuploader-video-handler',
            icon: 'videocam',
            action: function (maxSize, upload, allowOffline, mimetypes) {
                return _this.uploaderHelper.uploadAudioOrVideo(false, maxSize, upload, mimetypes).then(function (result) {
                    return {
                        treated: true,
                        result: result
                    };
                });
            }
        };
    };
    CoreFileUploaderVideoHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */],
            __WEBPACK_IMPORTED_MODULE_4__helper__["a" /* CoreFileUploaderHelperProvider */]])
    ], CoreFileUploaderVideoHandler);
    return CoreFileUploaderVideoHandler;
}());

//# sourceMappingURL=video-handler.js.map

/***/ }),

/***/ 1100:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSharedFilesModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sharedfiles__ = __webpack_require__(255);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_helper__ = __webpack_require__(254);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_upload_handler__ = __webpack_require__(1101);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__fileuploader_providers_delegate__ = __webpack_require__(217);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






var CoreSharedFilesModule = /** @class */ (function () {
    function CoreSharedFilesModule(platform, delegate, handler, helper) {
        // Register the handler.
        delegate.registerHandler(handler);
        if (platform.is('ios')) {
            // Check if there are new files at app start and when the app is resumed.
            helper.searchIOSNewSharedFiles();
            platform.resume.subscribe(function () {
                helper.searchIOSNewSharedFiles();
            });
        }
    }
    CoreSharedFilesModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [],
            providers: [
                __WEBPACK_IMPORTED_MODULE_2__providers_sharedfiles__["a" /* CoreSharedFilesProvider */],
                __WEBPACK_IMPORTED_MODULE_3__providers_helper__["a" /* CoreSharedFilesHelperProvider */],
                __WEBPACK_IMPORTED_MODULE_4__providers_upload_handler__["a" /* CoreSharedFilesUploadHandler */]
            ]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */], __WEBPACK_IMPORTED_MODULE_5__fileuploader_providers_delegate__["a" /* CoreFileUploaderDelegate */], __WEBPACK_IMPORTED_MODULE_4__providers_upload_handler__["a" /* CoreSharedFilesUploadHandler */],
            __WEBPACK_IMPORTED_MODULE_3__providers_helper__["a" /* CoreSharedFilesHelperProvider */]])
    ], CoreSharedFilesModule);
    return CoreSharedFilesModule;
}());

//# sourceMappingURL=sharedfiles.module.js.map

/***/ }),

/***/ 1101:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSharedFilesUploadHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__helper__ = __webpack_require__(254);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Handler to upload files from the album.
 */
var CoreSharedFilesUploadHandler = /** @class */ (function () {
    function CoreSharedFilesUploadHandler(sharedFilesHelper, platform) {
        this.sharedFilesHelper = sharedFilesHelper;
        this.platform = platform;
        this.name = 'CoreSharedFilesUpload';
        this.priority = 1300;
    }
    /**
     * Whether or not the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} True or promise resolved with true if enabled.
     */
    CoreSharedFilesUploadHandler.prototype.isEnabled = function () {
        return this.platform.is('ios');
    };
    /**
     * Given a list of mimetypes, return the ones that are supported by the handler.
     *
     * @param {string[]} [mimetypes] List of mimetypes.
     * @return {string[]} Supported mimetypes.
     */
    CoreSharedFilesUploadHandler.prototype.getSupportedMimetypes = function (mimetypes) {
        return mimetypes;
    };
    /**
     * Get the data to display the handler.
     *
     * @return {CoreFileUploaderHandlerData} Data.
     */
    CoreSharedFilesUploadHandler.prototype.getData = function () {
        var _this = this;
        return {
            title: 'core.sharedfiles.sharedfiles',
            class: 'core-sharedfiles-fileuploader-handler',
            icon: 'folder',
            action: function (maxSize, upload, allowOffline, mimetypes) {
                // Don't use the params because the file won't be uploaded, it is returned to the fileuploader.
                return _this.sharedFilesHelper.pickSharedFile(mimetypes);
            }
        };
    };
    CoreSharedFilesUploadHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__helper__["a" /* CoreSharedFilesHelperProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */]])
    ], CoreSharedFilesUploadHandler);
    return CoreSharedFilesUploadHandler;
}());

//# sourceMappingURL=upload-handler.js.map

/***/ }),

/***/ 1102:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_course__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_helper__ = __webpack_require__(639);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_format_delegate__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_module_delegate__ = __webpack_require__(140);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_module_prefetch_delegate__ = __webpack_require__(250);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_options_delegate__ = __webpack_require__(154);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_default_format__ = __webpack_require__(547);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__formats_singleactivity_singleactivity_module__ = __webpack_require__(1103);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__formats_social_social_module__ = __webpack_require__(1104);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__formats_topics_topics_module__ = __webpack_require__(1106);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__formats_weeks_weeks_module__ = __webpack_require__(1108);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};












var CoreCourseModule = /** @class */ (function () {
    function CoreCourseModule() {
    }
    CoreCourseModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [
                __WEBPACK_IMPORTED_MODULE_8__formats_singleactivity_singleactivity_module__["a" /* CoreCourseFormatSingleActivityModule */],
                __WEBPACK_IMPORTED_MODULE_10__formats_topics_topics_module__["a" /* CoreCourseFormatTopicsModule */],
                __WEBPACK_IMPORTED_MODULE_11__formats_weeks_weeks_module__["a" /* CoreCourseFormatWeeksModule */],
                __WEBPACK_IMPORTED_MODULE_9__formats_social_social_module__["a" /* CoreCourseFormatSocialModule */]
            ],
            providers: [
                __WEBPACK_IMPORTED_MODULE_1__providers_course__["a" /* CoreCourseProvider */],
                __WEBPACK_IMPORTED_MODULE_2__providers_helper__["a" /* CoreCourseHelperProvider */],
                __WEBPACK_IMPORTED_MODULE_3__providers_format_delegate__["a" /* CoreCourseFormatDelegate */],
                __WEBPACK_IMPORTED_MODULE_4__providers_module_delegate__["a" /* CoreCourseModuleDelegate */],
                __WEBPACK_IMPORTED_MODULE_5__providers_module_prefetch_delegate__["a" /* CoreCourseModulePrefetchDelegate */],
                __WEBPACK_IMPORTED_MODULE_6__providers_options_delegate__["a" /* CoreCourseOptionsDelegate */],
                __WEBPACK_IMPORTED_MODULE_7__providers_default_format__["a" /* CoreCourseFormatDefaultHandler */]
            ],
            exports: []
        })
    ], CoreCourseModule);
    return CoreCourseModule;
}());

//# sourceMappingURL=course.module.js.map

/***/ }),

/***/ 1103:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseFormatSingleActivityModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_singleactivity__ = __webpack_require__(623);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_handler__ = __webpack_require__(624);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_format_delegate__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__components_components_module__ = __webpack_require__(56);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





var CoreCourseFormatSingleActivityModule = /** @class */ (function () {
    function CoreCourseFormatSingleActivityModule(formatDelegate, handler) {
        formatDelegate.registerHandler(handler);
    }
    CoreCourseFormatSingleActivityModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_1__components_singleactivity__["a" /* CoreCourseFormatSingleActivityComponent */]
            ],
            imports: [
                __WEBPACK_IMPORTED_MODULE_4__components_components_module__["a" /* CoreComponentsModule */]
            ],
            providers: [
                __WEBPACK_IMPORTED_MODULE_2__providers_handler__["a" /* CoreCourseFormatSingleActivityHandler */]
            ],
            exports: [
                __WEBPACK_IMPORTED_MODULE_1__components_singleactivity__["a" /* CoreCourseFormatSingleActivityComponent */]
            ],
            entryComponents: [
                __WEBPACK_IMPORTED_MODULE_1__components_singleactivity__["a" /* CoreCourseFormatSingleActivityComponent */]
            ]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_format_delegate__["a" /* CoreCourseFormatDelegate */], __WEBPACK_IMPORTED_MODULE_2__providers_handler__["a" /* CoreCourseFormatSingleActivityHandler */]])
    ], CoreCourseFormatSingleActivityModule);
    return CoreCourseFormatSingleActivityModule;
}());

//# sourceMappingURL=singleactivity.module.js.map

/***/ }),

/***/ 1104:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseFormatSocialModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_handler__ = __webpack_require__(1105);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_format_delegate__ = __webpack_require__(86);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



var CoreCourseFormatSocialModule = /** @class */ (function () {
    function CoreCourseFormatSocialModule(formatDelegate, handler) {
        formatDelegate.registerHandler(handler);
    }
    CoreCourseFormatSocialModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [],
            providers: [
                __WEBPACK_IMPORTED_MODULE_1__providers_handler__["a" /* CoreCourseFormatSocialHandler */]
            ],
            exports: []
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_format_delegate__["a" /* CoreCourseFormatDelegate */], __WEBPACK_IMPORTED_MODULE_1__providers_handler__["a" /* CoreCourseFormatSocialHandler */]])
    ], CoreCourseFormatSocialModule);
    return CoreCourseFormatSocialModule;
}());

//# sourceMappingURL=social.module.js.map

/***/ }),

/***/ 1105:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseFormatSocialHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__singleactivity_providers_handler__ = __webpack_require__(624);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


/**
 * Handler to support social course format.
 * This format is like singleactivity in the mobile app, so we'll use the same implementation for both.
 */
var CoreCourseFormatSocialHandler = /** @class */ (function (_super) {
    __extends(CoreCourseFormatSocialHandler, _super);
    function CoreCourseFormatSocialHandler() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.name = 'social';
        return _this;
    }
    CoreCourseFormatSocialHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])()
    ], CoreCourseFormatSocialHandler);
    return CoreCourseFormatSocialHandler;
}(__WEBPACK_IMPORTED_MODULE_1__singleactivity_providers_handler__["a" /* CoreCourseFormatSingleActivityHandler */]));

//# sourceMappingURL=handler.js.map

/***/ }),

/***/ 1106:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseFormatTopicsModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_handler__ = __webpack_require__(1107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_format_delegate__ = __webpack_require__(86);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



var CoreCourseFormatTopicsModule = /** @class */ (function () {
    function CoreCourseFormatTopicsModule(formatDelegate, handler) {
        formatDelegate.registerHandler(handler);
    }
    CoreCourseFormatTopicsModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [],
            providers: [
                __WEBPACK_IMPORTED_MODULE_1__providers_handler__["a" /* CoreCourseFormatTopicsHandler */]
            ],
            exports: []
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_format_delegate__["a" /* CoreCourseFormatDelegate */], __WEBPACK_IMPORTED_MODULE_1__providers_handler__["a" /* CoreCourseFormatTopicsHandler */]])
    ], CoreCourseFormatTopicsModule);
    return CoreCourseFormatTopicsModule;
}());

//# sourceMappingURL=topics.module.js.map

/***/ }),

/***/ 1107:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseFormatTopicsHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

/**
 * Handler to support topics course format.
 */
var CoreCourseFormatTopicsHandler = /** @class */ (function () {
    function CoreCourseFormatTopicsHandler() {
        this.name = 'topics';
        // Nothing to do.
    }
    /**
     * Whether or not the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} True or promise resolved with true if enabled.
     */
    CoreCourseFormatTopicsHandler.prototype.isEnabled = function () {
        return true;
    };
    CoreCourseFormatTopicsHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [])
    ], CoreCourseFormatTopicsHandler);
    return CoreCourseFormatTopicsHandler;
}());

//# sourceMappingURL=handler.js.map

/***/ }),

/***/ 1108:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseFormatWeeksModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_handler__ = __webpack_require__(1109);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_format_delegate__ = __webpack_require__(86);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



var CoreCourseFormatWeeksModule = /** @class */ (function () {
    function CoreCourseFormatWeeksModule(formatDelegate, handler) {
        formatDelegate.registerHandler(handler);
    }
    CoreCourseFormatWeeksModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [],
            providers: [
                __WEBPACK_IMPORTED_MODULE_1__providers_handler__["a" /* CoreCourseFormatWeeksHandler */]
            ],
            exports: []
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_format_delegate__["a" /* CoreCourseFormatDelegate */], __WEBPACK_IMPORTED_MODULE_1__providers_handler__["a" /* CoreCourseFormatWeeksHandler */]])
    ], CoreCourseFormatWeeksModule);
    return CoreCourseFormatWeeksModule;
}());

//# sourceMappingURL=weeks.module.js.map

/***/ }),

/***/ 1109:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseFormatWeeksHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_utils_time__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constants__ = __webpack_require__(26);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Handler to support weeks course format.
 */
var CoreCourseFormatWeeksHandler = /** @class */ (function () {
    function CoreCourseFormatWeeksHandler(timeUtils) {
        this.timeUtils = timeUtils;
        this.name = 'weeks';
    }
    /**
     * Whether or not the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} True or promise resolved with true if enabled.
     */
    CoreCourseFormatWeeksHandler.prototype.isEnabled = function () {
        return true;
    };
    /**
     * Given a list of sections, get the "current" section that should be displayed first.
     *
     * @param {any} course The course to get the title.
     * @param {any[]} sections List of sections.
     * @return {any|Promise<any>} Current section (or promise resolved with current section).
     */
    CoreCourseFormatWeeksHandler.prototype.getCurrentSection = function (course, sections) {
        var now = this.timeUtils.timestamp();
        if (now < course.startdate || (course.enddate && now > course.enddate)) {
            // Course hasn't started yet or it has ended already. Return the first section.
            return sections[1];
        }
        for (var i = 0; i < sections.length; i++) {
            var section = sections[i];
            if (typeof section.section == 'undefined' || section.section < 1) {
                continue;
            }
            var dates = this.getSectionDates(section, course.startdate);
            if ((now >= dates.start) && (now < dates.end)) {
                return section;
            }
        }
        // The section wasn't found, return the first section.
        return sections[1];
    };
    /**
     * Return the start and end date of a section.
     *
     * @param {any} section The section to treat.
     * @param {number} startDate The course start date (in seconds).
     * @return {{start: number, end: number}} An object with the start and end date of the section.
     */
    CoreCourseFormatWeeksHandler.prototype.getSectionDates = function (section, startDate) {
        // Hack alert. We add 2 hours to avoid possible DST problems. (e.g. we go into daylight savings and the date changes).
        startDate = startDate + 7200;
        var dates = {
            start: startDate + (__WEBPACK_IMPORTED_MODULE_2__constants__["a" /* CoreConstants */].SECONDS_WEEK * (section.section - 1)),
            end: 0
        };
        dates.end = dates.start + __WEBPACK_IMPORTED_MODULE_2__constants__["a" /* CoreConstants */].SECONDS_WEEK;
        return dates;
    };
    CoreCourseFormatWeeksHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_utils_time__["a" /* CoreTimeUtilsProvider */]])
    ], CoreCourseFormatWeeksHandler);
    return CoreCourseFormatWeeksHandler;
}());

//# sourceMappingURL=handler.js.map

/***/ }),

/***/ 111:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreContentLinksHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_events__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_init__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_sites__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_dom__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_url__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__login_providers_helper__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__delegate__ = __webpack_require__(87);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__constants__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__configconstants__ = __webpack_require__(46);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};













/**
 * Service that provides some features regarding content links.
 */
var CoreContentLinksHelperProvider = /** @class */ (function () {
    function CoreContentLinksHelperProvider(logger, sitesProvider, loginHelper, contentLinksDelegate, appProvider, domUtils, urlUtils, translate, initDelegate, eventsProvider) {
        this.sitesProvider = sitesProvider;
        this.loginHelper = loginHelper;
        this.contentLinksDelegate = contentLinksDelegate;
        this.appProvider = appProvider;
        this.domUtils = domUtils;
        this.urlUtils = urlUtils;
        this.translate = translate;
        this.initDelegate = initDelegate;
        this.logger = logger.getInstance('CoreContentLinksHelperProvider');
        // Listen for app launched URLs. If we receive one, check if it's a content link.
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_3__providers_events__["a" /* CoreEventsProvider */].APP_LAUNCHED_URL, this.handleCustomUrl.bind(this));
    }
    /**
     * Get the first valid action in a list of actions.
     *
     * @param {CoreContentLinksAction[]} actions List of actions.
     * @return {CoreContentLinksAction} First valid action. Returns undefined if no valid action found.
     */
    CoreContentLinksHelperProvider.prototype.getFirstValidAction = function (actions) {
        if (actions) {
            for (var i = 0; i < actions.length; i++) {
                var action = actions[i];
                if (action && action.sites && action.sites.length) {
                    return action;
                }
            }
        }
    };
    /**
     * Goes to a certain page in a certain site. If the site is current site it will perform a regular navigation,
     * otherwise it will 'redirect' to the other site.
     *
     * @param {NavController} navCtrl The NavController instance to use.
     * @param {string} pageName Name of the page to go.
     * @param {any} [pageParams] Params to send to the page.
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    CoreContentLinksHelperProvider.prototype.goInSite = function (navCtrl, pageName, pageParams, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (navCtrl && siteId == this.sitesProvider.getCurrentSiteId()) {
            navCtrl.push(pageName, pageParams);
        }
        else {
            this.loginHelper.redirect(pageName, pageParams, siteId);
        }
    };
    /**
     * Go to the page to choose a site.
     *
     * @param {string} url URL to treat.
     */
    CoreContentLinksHelperProvider.prototype.goToChooseSite = function (url) {
        this.appProvider.getRootNavController().setRoot('CoreContentLinksChooseSitePage', { url: url });
    };
    /**
     * Handle a URL received by Custom URL Scheme.
     *
     * @param {string} url URL to handle.
     * @return {boolean} True if the URL should be handled by this component, false otherwise.
     */
    CoreContentLinksHelperProvider.prototype.handleCustomUrl = function (url) {
        var _this = this;
        var contentLinksScheme = __WEBPACK_IMPORTED_MODULE_12__configconstants__["a" /* CoreConfigConstants */].customurlscheme + '://link';
        if (url.indexOf(contentLinksScheme) == -1) {
            return false;
        }
        var modal = this.domUtils.showModalLoading();
        var username;
        url = decodeURIComponent(url);
        // App opened using custom URL scheme.
        this.logger.debug('Treating custom URL scheme: ' + url);
        // Delete the scheme from the URL.
        url = url.replace(contentLinksScheme + '=', '');
        // Detect if there's a user specified.
        username = this.urlUtils.getUsernameFromUrl(url);
        if (username) {
            url = url.replace(username + '@', ''); // Remove the username from the URL.
        }
        // Wait for the app to be ready.
        this.initDelegate.ready().then(function () {
            // Check if the site is stored.
            return _this.sitesProvider.getSiteIdsFromUrl(url, false, username);
        }).then(function (siteIds) {
            if (siteIds.length) {
                modal.dismiss(); // Dismiss modal so it doesn't collide with confirms.
                return _this.handleLink(url, username).then(function (treated) {
                    if (!treated) {
                        _this.domUtils.showErrorModal('core.contentlinks.errornoactions', true);
                    }
                });
            }
            else {
                // Get the site URL.
                var siteUrl = _this.contentLinksDelegate.getSiteUrl(url);
                if (!siteUrl) {
                    _this.domUtils.showErrorModal('core.login.invalidsite', true);
                    return;
                }
                // Check that site exists.
                return _this.sitesProvider.checkSite(siteUrl).then(function (result) {
                    // Site exists. We'll allow to add it.
                    var ssoNeeded = _this.loginHelper.isSSOLoginNeeded(result.code), hasRemoteAddonsLoaded = false, pageName = 'CoreLoginCredentialsPage', pageParams = {
                        siteUrl: result.siteUrl,
                        username: username,
                        urlToOpen: url,
                        siteConfig: result.config
                    };
                    var promise;
                    modal.dismiss(); // Dismiss modal so it doesn't collide with confirms.
                    if (!_this.sitesProvider.isLoggedIn()) {
                        // Not logged in, no need to confirm. If SSO the confirm will be shown later.
                        promise = Promise.resolve();
                    }
                    else {
                        // Ask the user before changing site.
                        var confirmMsg = _this.translate.instant('core.contentlinks.confirmurlothersite');
                        promise = _this.domUtils.showConfirm(confirmMsg).then(function () {
                            if (!ssoNeeded) {
                                // @todo hasRemoteAddonsLoaded = $mmAddonManager.hasRemoteAddonsLoaded(); @todo
                                if (hasRemoteAddonsLoaded) {
                                    // Store the redirect since logout will restart the app.
                                    _this.appProvider.storeRedirect(__WEBPACK_IMPORTED_MODULE_11__constants__["a" /* CoreConstants */].NO_SITE_ID, pageName, pageParams);
                                }
                                return _this.sitesProvider.logout().catch(function () {
                                    // Ignore errors (shouldn't happen).
                                });
                            }
                        });
                    }
                    return promise.then(function () {
                        if (ssoNeeded) {
                            _this.loginHelper.confirmAndOpenBrowserForSSOLogin(result.siteUrl, result.code, result.service, result.config && result.config.launchurl);
                        }
                        else if (!hasRemoteAddonsLoaded) {
                            _this.appProvider.getRootNavController().setRoot(pageName, pageParams);
                        }
                    });
                }).catch(function (error) {
                    if (error) {
                        _this.domUtils.showErrorModal(error);
                    }
                });
            }
        }).finally(function () {
            modal.dismiss();
        });
        return true;
    };
    /**
     * Handle a link.
     *
     * @param {string} url URL to handle.
     * @param {string} [username] Username related with the URL. E.g. in 'http://myuser@m.com', url would be 'http://m.com' and
     *                            the username 'myuser'. Don't use it if you don't want to filter by username.
     * @param {NavController} [navCtrl] Nav Controller to use to navigate.
     * @return {Promise<boolean>} Promise resolved with a boolean: true if URL was treated, false otherwise.
     */
    CoreContentLinksHelperProvider.prototype.handleLink = function (url, username, navCtrl) {
        var _this = this;
        // Check if the link should be treated by some component/addon.
        return this.contentLinksDelegate.getActionsFor(url, undefined, username).then(function (actions) {
            var action = _this.getFirstValidAction(actions);
            if (action) {
                if (!_this.sitesProvider.isLoggedIn()) {
                    // No current site. Perform the action if only 1 site found, choose the site otherwise.
                    if (action.sites.length == 1) {
                        action.action(action.sites[0], navCtrl);
                    }
                    else {
                        _this.goToChooseSite(url);
                    }
                }
                else if (action.sites.length == 1 && action.sites[0] == _this.sitesProvider.getCurrentSiteId()) {
                    // Current site.
                    action.action(action.sites[0], navCtrl);
                }
                else {
                    // Not current site or more than one site. Ask for confirmation.
                    _this.domUtils.showConfirm(_this.translate.instant('core.contentlinks.confirmurlothersite')).then(function () {
                        if (action.sites.length == 1) {
                            action.action(action.sites[0], navCtrl);
                        }
                        else {
                            _this.goToChooseSite(url);
                        }
                    });
                }
                return true;
            }
            return false;
        }).catch(function () {
            return false;
        });
    };
    CoreContentLinksHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_9__login_providers_helper__["a" /* CoreLoginHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_10__delegate__["a" /* CoreContentLinksDelegate */], __WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_7__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_8__providers_utils_url__["a" /* CoreUrlUtilsProvider */], __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_4__providers_init__["a" /* CoreInitDelegate */], __WEBPACK_IMPORTED_MODULE_3__providers_events__["a" /* CoreEventsProvider */]])
    ], CoreContentLinksHelperProvider);
    return CoreContentLinksHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),

/***/ 1110:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSiteHomeModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_sitehome__ = __webpack_require__(115);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_mainmenu_handler__ = __webpack_require__(1111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_index_link_handler__ = __webpack_require__(1112);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__mainmenu_providers_delegate__ = __webpack_require__(88);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__contentlinks_providers_delegate__ = __webpack_require__(87);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






var CoreSiteHomeModule = /** @class */ (function () {
    function CoreSiteHomeModule(mainMenuDelegate, contentLinksDelegate, mainMenuHandler, indexLinkHandler) {
        mainMenuDelegate.registerHandler(mainMenuHandler);
        contentLinksDelegate.registerHandler(indexLinkHandler);
    }
    CoreSiteHomeModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [],
            providers: [
                __WEBPACK_IMPORTED_MODULE_1__providers_sitehome__["a" /* CoreSiteHomeProvider */],
                __WEBPACK_IMPORTED_MODULE_2__providers_mainmenu_handler__["a" /* CoreSiteHomeMainMenuHandler */],
                __WEBPACK_IMPORTED_MODULE_3__providers_index_link_handler__["a" /* CoreSiteHomeIndexLinkHandler */]
            ],
            exports: []
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__mainmenu_providers_delegate__["a" /* CoreMainMenuDelegate */], __WEBPACK_IMPORTED_MODULE_5__contentlinks_providers_delegate__["a" /* CoreContentLinksDelegate */],
            __WEBPACK_IMPORTED_MODULE_2__providers_mainmenu_handler__["a" /* CoreSiteHomeMainMenuHandler */], __WEBPACK_IMPORTED_MODULE_3__providers_index_link_handler__["a" /* CoreSiteHomeIndexLinkHandler */]])
    ], CoreSiteHomeModule);
    return CoreSiteHomeModule;
}());

//# sourceMappingURL=sitehome.module.js.map

/***/ }),

/***/ 1111:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSiteHomeMainMenuHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__sitehome__ = __webpack_require__(115);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__courses_providers_my_overview__ = __webpack_require__(156);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Handler to add Site Home into main menu.
 */
var CoreSiteHomeMainMenuHandler = /** @class */ (function () {
    function CoreSiteHomeMainMenuHandler(siteHomeProvider, myOverviewProvider) {
        this.siteHomeProvider = siteHomeProvider;
        this.myOverviewProvider = myOverviewProvider;
        this.name = 'CoreSiteHome';
        this.priority = 1000;
    }
    /**
     * Check if the handler is enabled on a site level.
     *
     * @return {boolean} Whether or not the handler is enabled on a site level.
     */
    CoreSiteHomeMainMenuHandler.prototype.isEnabled = function () {
        var _this = this;
        // Check if my overview is enabled.
        return this.myOverviewProvider.isEnabled().then(function (enabled) {
            if (enabled) {
                // My overview is enabled, Site Home will be inside the overview page.
                return false;
            }
            // My overview not enabled, check if site home is enabled.
            return _this.siteHomeProvider.isAvailable();
        });
    };
    /**
     * Returns the data needed to render the handler.
     *
     * @return {CoreMainMenuHandlerData} Data needed to render the handler.
     */
    CoreSiteHomeMainMenuHandler.prototype.getDisplayData = function () {
        return {
            icon: 'home',
            title: 'core.sitehome.sitehome',
            page: 'CoreSiteHomeIndexPage',
            class: 'core-sitehome-handler'
        };
    };
    CoreSiteHomeMainMenuHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__sitehome__["a" /* CoreSiteHomeProvider */], __WEBPACK_IMPORTED_MODULE_2__courses_providers_my_overview__["a" /* CoreCoursesMyOverviewProvider */]])
    ], CoreSiteHomeMainMenuHandler);
    return CoreSiteHomeMainMenuHandler;
}());

//# sourceMappingURL=mainmenu-handler.js.map

/***/ }),

/***/ 1112:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSiteHomeIndexLinkHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_sites__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__contentlinks_classes_base_handler__ = __webpack_require__(84);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__login_providers_helper__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__sitehome__ = __webpack_require__(115);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Handler to treat links to site home index.
 */
var CoreSiteHomeIndexLinkHandler = /** @class */ (function (_super) {
    __extends(CoreSiteHomeIndexLinkHandler, _super);
    function CoreSiteHomeIndexLinkHandler(sitesProvider, siteHomeProvider, loginHelper) {
        var _this = _super.call(this) || this;
        _this.sitesProvider = sitesProvider;
        _this.siteHomeProvider = siteHomeProvider;
        _this.loginHelper = loginHelper;
        _this.name = 'CoreSiteHomeIndexLinkHandler';
        _this.featureName = '$mmSideMenuDelegate_mmaFrontpage';
        _this.pattern = /\/course\/view\.php.*([\?\&]id=\d+)/;
        return _this;
    }
    /**
     * Get the list of actions for a link (url).
     *
     * @param {string[]} siteIds List of sites the URL belongs to.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {CoreContentLinksAction[]|Promise<CoreContentLinksAction[]>} List of (or promise resolved with list of) actions.
     */
    CoreSiteHomeIndexLinkHandler.prototype.getActions = function (siteIds, url, params, courseId) {
        var _this = this;
        return [{
                action: function (siteId, navCtrl) {
                    // Always use redirect to make it the new history root (to avoid "loops" in history).
                    _this.loginHelper.redirect('CoreSiteHomeIndexPage', undefined, siteId);
                }
            }];
    };
    /**
     * Check if the handler is enabled for a certain site (site + user) and a URL.
     * If not defined, defaults to true.
     *
     * @param {string} siteId The site ID.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {boolean|Promise<boolean>} Whether the handler is enabled for the URL and site.
     */
    CoreSiteHomeIndexLinkHandler.prototype.isEnabled = function (siteId, url, params, courseId) {
        var _this = this;
        courseId = parseInt(params.id, 10);
        if (!courseId) {
            return false;
        }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            if (courseId != site.getSiteHomeId()) {
                // The course is not site home.
                return false;
            }
            return _this.siteHomeProvider.isAvailable(siteId).then(function () {
                return true;
            }).catch(function () {
                return false;
            });
        });
    };
    CoreSiteHomeIndexLinkHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_4__sitehome__["a" /* CoreSiteHomeProvider */],
            __WEBPACK_IMPORTED_MODULE_3__login_providers_helper__["a" /* CoreLoginHelperProvider */]])
    ], CoreSiteHomeIndexLinkHandler);
    return CoreSiteHomeIndexLinkHandler;
}(__WEBPACK_IMPORTED_MODULE_2__contentlinks_classes_base_handler__["a" /* CoreContentLinksHandlerBase */]));

//# sourceMappingURL=index-link-handler.js.map

/***/ }),

/***/ 1113:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreContentLinksModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_delegate__ = __webpack_require__(87);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_helper__ = __webpack_require__(111);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};



var CoreContentLinksModule = /** @class */ (function () {
    function CoreContentLinksModule() {
    }
    CoreContentLinksModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [],
            providers: [
                __WEBPACK_IMPORTED_MODULE_1__providers_delegate__["a" /* CoreContentLinksDelegate */],
                __WEBPACK_IMPORTED_MODULE_2__providers_helper__["a" /* CoreContentLinksHelperProvider */]
            ],
            exports: []
        })
    ], CoreContentLinksModule);
    return CoreContentLinksModule;
}());

//# sourceMappingURL=contentlinks.module.js.map

/***/ }),

/***/ 1114:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreUserModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_user_delegate__ = __webpack_require__(116);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_user_profile_field_delegate__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_user__ = __webpack_require__(112);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_helper__ = __webpack_require__(644);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_user_handler__ = __webpack_require__(1115);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_events__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_sites__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__contentlinks_providers_delegate__ = __webpack_require__(87);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_user_link_handler__ = __webpack_require__(1116);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_course_option_handler__ = __webpack_require__(1117);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_participants_link_handler__ = __webpack_require__(1118);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__course_providers_options_delegate__ = __webpack_require__(154);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__components_components_module__ = __webpack_require__(641);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};














var CoreUserModule = /** @class */ (function () {
    function CoreUserModule(userDelegate, userProfileMailHandler, eventsProvider, sitesProvider, userProvider, contentLinksDelegate, userLinkHandler, courseOptionHandler, linkHandler, courseOptionsDelegate) {
        userDelegate.registerHandler(userProfileMailHandler);
        courseOptionsDelegate.registerHandler(courseOptionHandler);
        contentLinksDelegate.registerHandler(userLinkHandler);
        contentLinksDelegate.registerHandler(linkHandler);
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_6__providers_events__["a" /* CoreEventsProvider */].USER_DELETED, function (data) {
            // Search for userid in params.
            var params = data.params;
            var userId = 0;
            if (params.userid) {
                userId = params.userid;
            }
            else if (params.userids) {
                userId = params.userids[0];
            }
            else if (params.field === 'id' && params.values && params.values.length) {
                userId = params.values[0];
            }
            else if (params.userlist && params.userlist.length) {
                userId = params.userlist[0].userid;
            }
            if (userId > 0) {
                userProvider.deleteStoredUser(userId, data.siteId);
            }
        }, sitesProvider.getCurrentSiteId());
    }
    CoreUserModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [
                __WEBPACK_IMPORTED_MODULE_13__components_components_module__["a" /* CoreUserComponentsModule */]
            ],
            providers: [
                __WEBPACK_IMPORTED_MODULE_1__providers_user_delegate__["a" /* CoreUserDelegate */],
                __WEBPACK_IMPORTED_MODULE_2__providers_user_profile_field_delegate__["a" /* CoreUserProfileFieldDelegate */],
                __WEBPACK_IMPORTED_MODULE_5__providers_user_handler__["a" /* CoreUserProfileMailHandler */],
                __WEBPACK_IMPORTED_MODULE_3__providers_user__["a" /* CoreUserProvider */],
                __WEBPACK_IMPORTED_MODULE_4__providers_helper__["a" /* CoreUserHelperProvider */],
                __WEBPACK_IMPORTED_MODULE_9__providers_user_link_handler__["a" /* CoreUserProfileLinkHandler */],
                __WEBPACK_IMPORTED_MODULE_10__providers_course_option_handler__["a" /* CoreUserParticipantsCourseOptionHandler */],
                __WEBPACK_IMPORTED_MODULE_11__providers_participants_link_handler__["a" /* CoreUserParticipantsLinkHandler */]
            ]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_user_delegate__["a" /* CoreUserDelegate */], __WEBPACK_IMPORTED_MODULE_5__providers_user_handler__["a" /* CoreUserProfileMailHandler */],
            __WEBPACK_IMPORTED_MODULE_6__providers_events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_7__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_user__["a" /* CoreUserProvider */],
            __WEBPACK_IMPORTED_MODULE_8__contentlinks_providers_delegate__["a" /* CoreContentLinksDelegate */], __WEBPACK_IMPORTED_MODULE_9__providers_user_link_handler__["a" /* CoreUserProfileLinkHandler */],
            __WEBPACK_IMPORTED_MODULE_10__providers_course_option_handler__["a" /* CoreUserParticipantsCourseOptionHandler */], __WEBPACK_IMPORTED_MODULE_11__providers_participants_link_handler__["a" /* CoreUserParticipantsLinkHandler */],
            __WEBPACK_IMPORTED_MODULE_12__course_providers_options_delegate__["a" /* CoreCourseOptionsDelegate */]])
    ], CoreUserModule);
    return CoreUserModule;
}());

//# sourceMappingURL=user.module.js.map

/***/ }),

/***/ 1115:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreUserProfileMailHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__user_delegate__ = __webpack_require__(116);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(8);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Profile links email handler.
 */
var CoreUserProfileMailHandler = /** @class */ (function () {
    function CoreUserProfileMailHandler(sitesProvider) {
        this.sitesProvider = sitesProvider;
        this.name = 'mmUser';
        this.priority = 700;
        this.type = __WEBPACK_IMPORTED_MODULE_1__user_delegate__["a" /* CoreUserDelegate */].TYPE_COMMUNICATION;
    }
    /**
     * Check if handler is enabled.
     *
     * @return {boolean} Always enabled.
     */
    CoreUserProfileMailHandler.prototype.isEnabled = function () {
        return true;
    };
    /**
     * Check if handler is enabled for this user in this context.
     *
     * @param {any} user     User to check.
     * @param {number} courseId Course ID.
     * @param  {any} [navOptions] Course navigation options for current user. See $mmCourses#getUserNavigationOptions.
     * @param  {any} [admOptions] Course admin options for current user. See $mmCourses#getUserAdministrationOptions.
     * @return  {boolean|Promise<boolean>}   Promise resolved with true if enabled, resolved with false otherwise.
     */
    CoreUserProfileMailHandler.prototype.isEnabledForUser = function (user, courseId, navOptions, admOptions) {
        // Not current user required.
        return user.id != this.sitesProvider.getCurrentSite().getUserId() && user.email;
    };
    /**
     * Returns the data needed to render the handler.
     *
     * @return {CoreUserProfileHandlerData} Data needed to render the handler.
     */
    CoreUserProfileMailHandler.prototype.getDisplayData = function (user, courseId) {
        return {
            icon: 'mail',
            title: 'core.user.sendemail',
            class: 'core-user-profile-mail',
            action: function (event, navCtrl, user, courseId) {
                event.preventDefault();
                event.stopPropagation();
                window.open('mailto:' + user.email, '_blank');
            }
        };
    };
    CoreUserProfileMailHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */]])
    ], CoreUserProfileMailHandler);
    return CoreUserProfileMailHandler;
}());

//# sourceMappingURL=user-handler.js.map

/***/ }),

/***/ 1116:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreUserProfileLinkHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__contentlinks_classes_base_handler__ = __webpack_require__(84);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__contentlinks_providers_helper__ = __webpack_require__(111);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Handler to treat links to user profiles.
 */
var CoreUserProfileLinkHandler = /** @class */ (function (_super) {
    __extends(CoreUserProfileLinkHandler, _super);
    function CoreUserProfileLinkHandler(linkHelper) {
        var _this = _super.call(this) || this;
        _this.linkHelper = linkHelper;
        _this.name = 'CoreUserProfileLinkHandler';
        // Match user/view.php and user/profile.php but NOT grade/report/user/.
        _this.pattern = /((\/user\/view\.php)|(\/user\/profile\.php)).*([\?\&]id=\d+)/;
        return _this;
    }
    /**
     * Get the list of actions for a link (url).
     *
     * @param {string[]} siteIds List of sites the URL belongs to.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {CoreContentLinksAction[]|Promise<CoreContentLinksAction[]>} List of (or promise resolved with list of) actions.
     */
    CoreUserProfileLinkHandler.prototype.getActions = function (siteIds, url, params, courseId) {
        var _this = this;
        return [{
                action: function (siteId, navCtrl) {
                    var pageParams = {
                        courseId: params.course,
                        userId: parseInt(params.id, 10)
                    };
                    // Always use redirect to make it the new history root (to avoid "loops" in history).
                    _this.linkHelper.goInSite(navCtrl, 'CoreUserProfilePage', pageParams, siteId);
                }
            }];
    };
    /**
     * Check if the handler is enabled for a certain site (site + user) and a URL.
     * If not defined, defaults to true.
     *
     * @param {string} siteId The site ID.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {boolean|Promise<boolean>} Whether the handler is enabled for the URL and site.
     */
    CoreUserProfileLinkHandler.prototype.isEnabled = function (siteId, url, params, courseId) {
        return url.indexOf('/grade/report/') == -1;
    };
    CoreUserProfileLinkHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__contentlinks_providers_helper__["a" /* CoreContentLinksHelperProvider */]])
    ], CoreUserProfileLinkHandler);
    return CoreUserProfileLinkHandler;
}(__WEBPACK_IMPORTED_MODULE_1__contentlinks_classes_base_handler__["a" /* CoreContentLinksHandlerBase */]));

//# sourceMappingURL=user-link-handler.js.map

/***/ }),

/***/ 1117:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreUserParticipantsCourseOptionHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__course_providers_course__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__user__ = __webpack_require__(112);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__login_providers_helper__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__components_participants_participants__ = __webpack_require__(548);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Course nav handler.
 */
var CoreUserParticipantsCourseOptionHandler = /** @class */ (function () {
    function CoreUserParticipantsCourseOptionHandler(userProvider, loginHelper) {
        this.userProvider = userProvider;
        this.loginHelper = loginHelper;
        this.name = 'AddonParticipants';
        this.priority = 600;
    }
    /**
     * Should invalidate the data to determine if the handler is enabled for a certain course.
     *
     * @param {number} courseId The course ID.
     * @param {any} [navOptions] Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.
     * @param {any} [admOptions] Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreUserParticipantsCourseOptionHandler.prototype.invalidateEnabledForCourse = function (courseId, navOptions, admOptions) {
        if (navOptions && typeof navOptions.participants != 'undefined') {
            // No need to invalidate anything.
            return Promise.resolve();
        }
        return this.userProvider.invalidateParticipantsList(courseId);
    };
    /**
     * Check if the handler is enabled on a site level.
     *
     * @return {boolean} Whether or not the handler is enabled on a site level.
     */
    CoreUserParticipantsCourseOptionHandler.prototype.isEnabled = function () {
        return true;
    };
    /**
     * Whether or not the handler is enabled for a certain course.
     *
     * @param {number} courseId The course ID.
     * @param {any} accessData Access type and data. Default, guest, ...
     * @param {any} [navOptions] Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.
     * @param {any} [admOptions] Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.
     * @return {boolean|Promise<boolean>} True or promise resolved with true if enabled.
     */
    CoreUserParticipantsCourseOptionHandler.prototype.isEnabledForCourse = function (courseId, accessData, navOptions, admOptions) {
        if (accessData && accessData.type == __WEBPACK_IMPORTED_MODULE_1__course_providers_course__["a" /* CoreCourseProvider */].ACCESS_GUEST) {
            return false; // Not enabled for guests.
        }
        if (navOptions && typeof navOptions.participants != 'undefined') {
            return navOptions.participants;
        }
        return this.userProvider.isPluginEnabledForCourse(courseId);
    };
    /**
     * Returns the data needed to render the handler.
     *
     * @return {CoreMainMenuHandlerData} Data needed to render the handler.
     */
    CoreUserParticipantsCourseOptionHandler.prototype.getDisplayData = function () {
        return {
            title: 'core.user.participants',
            class: 'core-user-participants-handler',
            component: __WEBPACK_IMPORTED_MODULE_4__components_participants_participants__["a" /* CoreUserParticipantsComponent */]
        };
    };
    CoreUserParticipantsCourseOptionHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__user__["a" /* CoreUserProvider */], __WEBPACK_IMPORTED_MODULE_3__login_providers_helper__["a" /* CoreLoginHelperProvider */]])
    ], CoreUserParticipantsCourseOptionHandler);
    return CoreUserParticipantsCourseOptionHandler;
}());

//# sourceMappingURL=course-option-handler.js.map

/***/ }),

/***/ 1118:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreUserParticipantsLinkHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_contentlinks_classes_base_handler__ = __webpack_require__(84);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_login_providers_helper__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__user__ = __webpack_require__(112);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Handler to treat links to user participants page.
 */
var CoreUserParticipantsLinkHandler = /** @class */ (function (_super) {
    __extends(CoreUserParticipantsLinkHandler, _super);
    function CoreUserParticipantsLinkHandler(userProvider, loginHelper) {
        var _this = _super.call(this) || this;
        _this.userProvider = userProvider;
        _this.loginHelper = loginHelper;
        _this.name = 'AddonParticipants';
        _this.featureName = '$mmCoursesDelegate_mmaParticipants';
        _this.pattern = /\/user\/index\.php/;
        return _this;
    }
    /**
     * Get the list of actions for a link (url).
     *
     * @param {string[]} siteIds List of sites the URL belongs to.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {CoreContentLinksAction[]|Promise<CoreContentLinksAction[]>} List of (or promise resolved with list of) actions.
     */
    CoreUserParticipantsLinkHandler.prototype.getActions = function (siteIds, url, params, courseId) {
        var _this = this;
        courseId = parseInt(params.id, 10) || courseId;
        return [{
                action: function (siteId, navCtrl) {
                    // Always use redirect to make it the new history root (to avoid "loops" in history).
                    _this.loginHelper.redirect('AddonParticipantsListPage', { courseId: courseId }, siteId);
                }
            }];
    };
    /**
     * Check if the handler is enabled for a certain site (site + user) and a URL.
     * If not defined, defaults to true.
     *
     * @param {string} siteId The site ID.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {boolean|Promise<boolean>} Whether the handler is enabled for the URL and site.
     */
    CoreUserParticipantsLinkHandler.prototype.isEnabled = function (siteId, url, params, courseId) {
        courseId = parseInt(params.id, 10) || courseId;
        if (!courseId || url.indexOf('/grade/report/') != -1) {
            return false;
        }
        return this.userProvider.isPluginEnabledForCourse(courseId, siteId);
    };
    CoreUserParticipantsLinkHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__user__["a" /* CoreUserProvider */], __WEBPACK_IMPORTED_MODULE_2__core_login_providers_helper__["a" /* CoreLoginHelperProvider */]])
    ], CoreUserParticipantsLinkHandler);
    return CoreUserParticipantsLinkHandler;
}(__WEBPACK_IMPORTED_MODULE_1__core_contentlinks_classes_base_handler__["a" /* CoreContentLinksHandlerBase */]));

//# sourceMappingURL=participants-link-handler.js.map

/***/ }),

/***/ 1119:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonBadgesModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_badges__ = __webpack_require__(253);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_user_handler__ = __webpack_require__(1120);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_user_providers_user_delegate__ = __webpack_require__(116);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




var AddonBadgesModule = /** @class */ (function () {
    function AddonBadgesModule(userDelegate, userHandler) {
        userDelegate.registerHandler(userHandler);
    }
    AddonBadgesModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [],
            providers: [
                __WEBPACK_IMPORTED_MODULE_1__providers_badges__["a" /* AddonBadgesProvider */],
                __WEBPACK_IMPORTED_MODULE_2__providers_user_handler__["a" /* AddonBadgesUserHandler */]
            ]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__core_user_providers_user_delegate__["a" /* CoreUserDelegate */], __WEBPACK_IMPORTED_MODULE_2__providers_user_handler__["a" /* AddonBadgesUserHandler */]])
    ], AddonBadgesModule);
    return AddonBadgesModule;
}());

//# sourceMappingURL=badges.module.js.map

/***/ }),

/***/ 112:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreUserProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__ = __webpack_require__(9);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Service to provide user functionalities.
 */
var CoreUserProvider = /** @class */ (function () {
    function CoreUserProvider(logger, sitesProvider, utils) {
        this.sitesProvider = sitesProvider;
        this.utils = utils;
        this.ROOT_CACHE_KEY = 'mmUser:';
        // Variables for database.
        this.USERS_TABLE = 'users';
        this.tablesSchema = [
            {
                name: this.USERS_TABLE,
                columns: [
                    {
                        name: 'id',
                        type: 'INTEGER',
                        primaryKey: true
                    },
                    {
                        name: 'fullname',
                        type: 'TEXT'
                    },
                    {
                        name: 'profileimageurl',
                        type: 'TEXT'
                    }
                ]
            }
        ];
        this.logger = logger.getInstance('CoreUserProvider');
        this.sitesProvider.createTablesFromSchema(this.tablesSchema);
    }
    CoreUserProvider_1 = CoreUserProvider;
    /**
     * Change the given user profile picture.
     *
     * @param  {number} draftItemId New picture draft item id.
     * @param  {number} userId      User ID.
     * @return {Promise<string>}       Promise resolve with the new profileimageurl
     */
    CoreUserProvider.prototype.changeProfilePicture = function (draftItemId, userId) {
        var data = {
            draftitemid: draftItemId,
            delete: 0,
            userid: userId
        };
        return this.sitesProvider.getCurrentSite().write('core_user_update_picture', data).then(function (result) {
            if (!result.success) {
                return Promise.reject(null);
            }
            return result.profileimageurl;
        });
    };
    /**
     * Store user basic information in local DB to be retrieved if the WS call fails.
     *
     * @param  {number} userId  User ID.
     * @param {string} [siteId] ID of the site. If not defined, use current site.
     * @return {Promise<any>}   Promise resolve when the user is deleted.
     */
    CoreUserProvider.prototype.deleteStoredUser = function (userId, siteId) {
        var _this = this;
        if (isNaN(userId)) {
            return Promise.reject(null);
        }
        var promises = [];
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Invalidate WS calls.
        promises.push(this.invalidateUserCache(userId, siteId));
        promises.push(this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().deleteRecords(_this.USERS_TABLE, { id: userId });
        }));
        return Promise.all(promises);
    };
    /**
     * Get participants for a certain course.
     *
     * @param  {number} courseId    ID of the course.
     * @param  {number} limitFrom   Position of the first participant to get.
     * @param  {number} limitNumber Number of participants to get.
     * @param  {string} [siteId]    Site Id. If not defined, use current site.
     * @return {Promise<any>}       Promise to be resolved when the participants are retrieved.
     */
    CoreUserProvider.prototype.getParticipants = function (courseId, limitFrom, limitNumber, siteId) {
        var _this = this;
        if (limitFrom === void 0) { limitFrom = 0; }
        if (limitNumber === void 0) { limitNumber = CoreUserProvider_1.PARTICIPANTS_LIST_LIMIT; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            _this.logger.debug("Get participants for course '" + courseId + "' starting at '" + limitFrom + "'");
            var data = {
                courseid: courseId,
                options: [
                    {
                        name: 'limitfrom',
                        value: limitFrom
                    },
                    {
                        name: 'limitnumber',
                        value: limitNumber
                    },
                    {
                        name: 'sortby',
                        value: 'siteorder'
                    }
                ]
            }, preSets = {
                cacheKey: _this.getParticipantsListCacheKey(courseId)
            };
            return site.read('core_enrol_get_enrolled_users', data, preSets).then(function (users) {
                var canLoadMore = users.length >= limitNumber;
                _this.storeUsers(users, siteId);
                return { participants: users, canLoadMore: canLoadMore };
            });
        });
    };
    /**
     * Get cache key for participant list WS calls.
     *
     * @param  {number} courseId Course ID.
     * @return {string}          Cache key.
     */
    CoreUserProvider.prototype.getParticipantsListCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'list:' + courseId;
    };
    /**
     * Get user profile. The type of profile retrieved depends on the params.
     *
     * @param  {number} userId      User's ID.
     * @param  {number} [courseId]  Course ID to get course profile, undefined or 0 to get site profile.
     * @param  {boolean} [forceLocal] True to retrieve the user data from local DB, false to retrieve it from WS.
     * @param {string} [siteId] ID of the site. If not defined, use current site.
     * @return {Promise<any>}            Promise resolved with the user data.
     */
    CoreUserProvider.prototype.getProfile = function (userId, courseId, forceLocal, siteId) {
        var _this = this;
        if (forceLocal === void 0) { forceLocal = false; }
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (forceLocal) {
            return this.getUserFromLocalDb(userId, siteId).catch(function () {
                return _this.getUserFromWS(userId, courseId, siteId);
            });
        }
        return this.getUserFromWS(userId, courseId, siteId).catch(function () {
            return _this.getUserFromLocalDb(userId, siteId);
        });
    };
    /**
     * Get cache key for a user WS call.
     *
     * @param  {number} userId User ID.
     * @return {string}        Cache key.
     */
    CoreUserProvider.prototype.getUserCacheKey = function (userId) {
        return this.ROOT_CACHE_KEY + 'data:' + userId;
    };
    /**
     * Get user basic information from local DB.
     *
     * @param {number} userId User ID.
     * @param {string} [siteId] ID of the site. If not defined, use current site.
     * @return {Promise<any>}   Promise resolve when the user is retrieved.
     */
    CoreUserProvider.prototype.getUserFromLocalDb = function (userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getRecord(_this.USERS_TABLE, { id: userId });
        });
    };
    /**
     * Get user profile from WS.
     *
     * @param {number} userId         User ID.
     * @param {number} [courseId] Course ID to get course profile, undefined or 0 to get site profile.
     * @param {string} [siteId] ID of the site. If not defined, use current site.
     * @return {Promise<any>}           Promise resolve when the user is retrieved.
     */
    CoreUserProvider.prototype.getUserFromWS = function (userId, courseId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var presets = {
                cacheKey: _this.getUserCacheKey(userId)
            };
            var wsName, data;
            // Determine WS and data to use.
            if (courseId && courseId != site.getSiteHomeId()) {
                _this.logger.debug("Get participant with ID '" + userId + "' in course '" + courseId);
                wsName = 'core_user_get_course_user_profiles';
                data = {
                    userlist: [
                        {
                            userid: userId,
                            courseid: courseId
                        }
                    ]
                };
            }
            else {
                _this.logger.debug("Get user with ID '" + userId + "'");
                wsName = 'core_user_get_users_by_field';
                data = {
                    'field': 'id',
                    'values[0]': userId
                };
            }
            return site.read(wsName, data, presets).then(function (users) {
                if (users.length == 0) {
                    return Promise.reject('Cannot retrieve user info.');
                }
                var user = users.shift();
                if (user.country) {
                    user.country = _this.utils.getCountryName(user.country);
                }
                _this.storeUser(user.id, user.fullname, user.profileimageurl);
                return user;
            });
        });
    };
    /**
     * Invalidates user WS calls.
     *
     * @param {number} userId User ID.
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<any>}       Promise resolved when the data is invalidated.
     */
    CoreUserProvider.prototype.invalidateUserCache = function (userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getUserCacheKey(userId));
        });
    };
    /**
     * Invalidates participant list for a certain course.
     *
     * @param  {number} courseId Course ID.
     * @param  {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<any>}         Promise resolved when the list is invalidated.
     */
    CoreUserProvider.prototype.invalidateParticipantsList = function (courseId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getParticipantsListCacheKey(courseId));
        });
    };
    /**
     * Check if course participants is disabled in a certain site.
     *
     * @param  {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<boolean>}     Promise resolved with true if disabled, rejected or resolved with false otherwise.
     */
    CoreUserProvider.prototype.isParticipantsDisabled = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.isParticipantsDisabledInSite(site);
        });
    };
    /**
     * Check if course participants is disabled in a certain site.
     *
     * @param {CoreSite} [site] Site. If not defined, use current site.
     * @return {boolean} Whether it's disabled.
     */
    CoreUserProvider.prototype.isParticipantsDisabledInSite = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.isFeatureDisabled('$mmCoursesDelegate_mmaParticipants');
    };
    /**
     * Returns whether or not the participants addon is enabled for a certain course.
     *
     * @param {number} courseId Course ID.
     * @param  {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<any>}    Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    CoreUserProvider.prototype.isPluginEnabledForCourse = function (courseId, siteId) {
        if (!courseId) {
            return Promise.reject(null);
        }
        // Retrieving one participant will fail if browsing users is disabled by capabilities.
        return this.utils.promiseWorks(this.getParticipants(courseId, 0, 1, siteId));
    };
    /**
     * Check if update profile picture is disabled in a certain site.
     *
     * @param  {CoreSite} [site] Site. If not defined, use current site.
     * @return {boolean}       True if disabled, false otherwise.
     */
    CoreUserProvider.prototype.isUpdatePictureDisabledInSite = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.isFeatureDisabled('$mmUserDelegate_picture');
    };
    /**
     * Log User Profile View in Moodle.
     * @param  {number}       userId   User ID.
     * @param  {number}       [courseId] Course ID.
     * @return {Promise<any>}          Promise resolved when done.
     */
    CoreUserProvider.prototype.logView = function (userId, courseId) {
        var params = {
            userid: userId
        };
        if (courseId) {
            params['courseid'] = courseId;
        }
        return this.sitesProvider.getCurrentSite().write('core_user_view_user_profile', params);
    };
    /**
     * Log Participants list view in Moodle.
     * @param  {number}       courseId Course ID.
     * @return {Promise<any>}          Promise resolved when done.
     */
    CoreUserProvider.prototype.logParticipantsView = function (courseId) {
        return this.sitesProvider.getCurrentSite().write('core_user_view_user_list', {
            courseid: courseId
        });
    };
    /**
     * Store user basic information in local DB to be retrieved if the WS call fails.
     *
     * @param {number} userId   User ID.
     * @param {string} fullname User full name.
     * @param {string} avatar   User avatar URL.
     * @param  {string} [siteId] ID of the site. If not defined, use current site.
     * @return {Promise<any>}         Promise resolve when the user is stored.
     */
    CoreUserProvider.prototype.storeUser = function (userId, fullname, avatar, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var userRecord = {
                id: userId,
                fullname: fullname,
                profileimageurl: avatar
            };
            return site.getDb().insertOrUpdateRecord(_this.USERS_TABLE, userRecord, { id: userId });
        });
    };
    /**
     * Store users basic information in local DB.
     *
     * @param  {any[]} users     Users to store. Fields stored: id, fullname, profileimageurl.
     * @param  {string} [siteId] ID of the site. If not defined, use current site.
     * @return {Promise<any>}        Promise resolve when the user is stored.
     */
    CoreUserProvider.prototype.storeUsers = function (users, siteId) {
        var _this = this;
        var promises = [];
        users.forEach(function (user) {
            if (typeof user.id != 'undefined') {
                promises.push(_this.storeUser(user.id, user.fullname, user.profileimageurl, siteId));
            }
        });
        return Promise.all(promises);
    };
    CoreUserProvider.PARTICIPANTS_LIST_LIMIT = 50; // Max of participants to retrieve in each WS call.
    CoreUserProvider.PROFILE_REFRESHED = 'CoreUserProfileRefreshed';
    CoreUserProvider.PROFILE_PICTURE_UPDATED = 'CoreUserProfilePictureUpdated';
    CoreUserProvider = CoreUserProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], CoreUserProvider);
    return CoreUserProvider;
    var CoreUserProvider_1;
}());

//# sourceMappingURL=user.js.map

/***/ }),

/***/ 1120:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonBadgesUserHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_user_providers_user_delegate__ = __webpack_require__(116);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__badges__ = __webpack_require__(253);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Profile badges handler.
 */
var AddonBadgesUserHandler = /** @class */ (function () {
    function AddonBadgesUserHandler(badgesProvider) {
        this.badgesProvider = badgesProvider;
        this.name = 'mmaBadges';
        this.priority = 50;
        this.type = __WEBPACK_IMPORTED_MODULE_1__core_user_providers_user_delegate__["a" /* CoreUserDelegate */].TYPE_NEW_PAGE;
    }
    /**
     * Check if handler is enabled.
     *
     * @return {Promise<boolean>} Always enabled.
     */
    AddonBadgesUserHandler.prototype.isEnabled = function () {
        return this.badgesProvider.isPluginEnabled();
    };
    /**
     * Check if handler is enabled for this user in this context.
     *
     * @param {any} user     User to check.
     * @param {number} courseId Course ID.
     * @param  {any} [navOptions] Course navigation options for current user. See $mmCourses#getUserNavigationOptions.
     * @param  {any} [admOptions] Course admin options for current user. See $mmCourses#getUserAdministrationOptions.
     * @return  {boolean|Promise<boolean>}   Promise resolved with true if enabled, resolved with false otherwise.
     */
    AddonBadgesUserHandler.prototype.isEnabledForUser = function (user, courseId, navOptions, admOptions) {
        if (navOptions && typeof navOptions.badges != 'undefined') {
            return navOptions.badges;
        }
        // If we reach here, it means we are opening the user site profile.
        return true;
    };
    /**
     * Returns the data needed to render the handler.
     *
     * @return {CoreUserProfileHandlerData} Data needed to render the handler.
     */
    AddonBadgesUserHandler.prototype.getDisplayData = function (user, courseId) {
        return {
            icon: 'trophy',
            title: 'addon.badges.badges',
            class: '',
            action: function (event, navCtrl, user, courseId) {
                event.preventDefault();
                event.stopPropagation();
                navCtrl.push('AddonBadgesUserBadgesPage', { courseId: courseId, userId: user.id });
            }
        };
    };
    AddonBadgesUserHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__badges__["a" /* AddonBadgesProvider */]])
    ], AddonBadgesUserHandler);
    return AddonBadgesUserHandler;
}());

//# sourceMappingURL=user-handler.js.map

/***/ }),

/***/ 1121:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonCalendarModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_calendar__ = __webpack_require__(252);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_helper__ = __webpack_require__(642);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_mainmenu_handler__ = __webpack_require__(1122);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_mainmenu_providers_delegate__ = __webpack_require__(88);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_init__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_local_notifications__ = __webpack_require__(113);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_login_providers_helper__ = __webpack_require__(41);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








var AddonCalendarModule = /** @class */ (function () {
    function AddonCalendarModule(mainMenuDelegate, calendarHandler, initDelegate, calendarProvider, loginHelper, localNotificationsProvider) {
        mainMenuDelegate.registerHandler(calendarHandler);
        initDelegate.ready().then(function () {
            calendarProvider.scheduleAllSitesEventsNotifications();
        });
        localNotificationsProvider.registerClick(__WEBPACK_IMPORTED_MODULE_1__providers_calendar__["a" /* AddonCalendarProvider */].COMPONENT, function (data) {
            if (data.eventid) {
                initDelegate.ready().then(function () {
                    calendarProvider.isDisabled(data.siteId).then(function (disabled) {
                        if (disabled) {
                            // The calendar is disabled in the site, don't open it.
                            return;
                        }
                        loginHelper.redirect('AddonCalendarListPage', { eventid: data.eventid }, data.siteId);
                    });
                });
            }
        });
    }
    AddonCalendarModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [],
            providers: [
                __WEBPACK_IMPORTED_MODULE_1__providers_calendar__["a" /* AddonCalendarProvider */],
                __WEBPACK_IMPORTED_MODULE_2__providers_helper__["a" /* AddonCalendarHelperProvider */],
                __WEBPACK_IMPORTED_MODULE_3__providers_mainmenu_handler__["a" /* AddonCalendarMainMenuHandler */]
            ]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__core_mainmenu_providers_delegate__["a" /* CoreMainMenuDelegate */], __WEBPACK_IMPORTED_MODULE_3__providers_mainmenu_handler__["a" /* AddonCalendarMainMenuHandler */],
            __WEBPACK_IMPORTED_MODULE_5__providers_init__["a" /* CoreInitDelegate */], __WEBPACK_IMPORTED_MODULE_1__providers_calendar__["a" /* AddonCalendarProvider */], __WEBPACK_IMPORTED_MODULE_7__core_login_providers_helper__["a" /* CoreLoginHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_6__providers_local_notifications__["a" /* CoreLocalNotificationsProvider */]])
    ], AddonCalendarModule);
    return AddonCalendarModule;
}());

//# sourceMappingURL=calendar.module.js.map

/***/ }),

/***/ 1122:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonCalendarMainMenuHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__calendar__ = __webpack_require__(252);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Handler to inject an option into main menu.
 */
var AddonCalendarMainMenuHandler = /** @class */ (function () {
    function AddonCalendarMainMenuHandler(calendarProvider) {
        this.calendarProvider = calendarProvider;
        this.name = 'AddonCalendar';
        this.priority = 400;
    }
    /**
     * Check if the handler is enabled on a site level.
     *
     * @return {boolean} Whether or not the handler is enabled on a site level.
     */
    AddonCalendarMainMenuHandler.prototype.isEnabled = function () {
        return !this.calendarProvider.isCalendarDisabledInSite();
    };
    /**
     * Returns the data needed to render the handler.
     *
     * @return {CoreMainMenuHandlerData} Data needed to render the handler.
     */
    AddonCalendarMainMenuHandler.prototype.getDisplayData = function () {
        return {
            icon: 'calendar',
            title: 'addon.calendar.calendar',
            page: 'AddonCalendarListPage',
            class: 'addon-calendar-handler'
        };
    };
    AddonCalendarMainMenuHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__calendar__["a" /* AddonCalendarProvider */]])
    ], AddonCalendarMainMenuHandler);
    return AddonCalendarMainMenuHandler;
}());

//# sourceMappingURL=mainmenu-handler.js.map

/***/ }),

/***/ 1123:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonUserProfileFieldModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__checkbox_checkbox_module__ = __webpack_require__(1124);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__datetime_datetime_module__ = __webpack_require__(1126);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__menu_menu_module__ = __webpack_require__(1128);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__text_text_module__ = __webpack_require__(1130);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__textarea_textarea_module__ = __webpack_require__(1132);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.






var AddonUserProfileFieldModule = /** @class */ (function () {
    function AddonUserProfileFieldModule() {
    }
    AddonUserProfileFieldModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1__checkbox_checkbox_module__["a" /* AddonUserProfileFieldCheckboxModule */],
                __WEBPACK_IMPORTED_MODULE_2__datetime_datetime_module__["a" /* AddonUserProfileFieldDatetimeModule */],
                __WEBPACK_IMPORTED_MODULE_3__menu_menu_module__["a" /* AddonUserProfileFieldMenuModule */],
                __WEBPACK_IMPORTED_MODULE_4__text_text_module__["a" /* AddonUserProfileFieldTextModule */],
                __WEBPACK_IMPORTED_MODULE_5__textarea_textarea_module__["a" /* AddonUserProfileFieldTextareaModule */]
            ],
            providers: [],
            exports: []
        })
    ], AddonUserProfileFieldModule);
    return AddonUserProfileFieldModule;
}());

//# sourceMappingURL=userprofilefield.module.js.map

/***/ }),

/***/ 1124:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonUserProfileFieldCheckboxModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_handler__ = __webpack_require__(1125);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_user_providers_user_profile_field_delegate__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__component_checkbox__ = __webpack_require__(625);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__components_components_module__ = __webpack_require__(56);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};







var AddonUserProfileFieldCheckboxModule = /** @class */ (function () {
    function AddonUserProfileFieldCheckboxModule(userProfileFieldDelegate, handler) {
        userProfileFieldDelegate.registerHandler(handler);
    }
    AddonUserProfileFieldCheckboxModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_5__component_checkbox__["a" /* AddonUserProfileFieldCheckboxComponent */]
            ],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["g" /* IonicModule */],
                __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["b" /* TranslateModule */].forChild(),
                __WEBPACK_IMPORTED_MODULE_6__components_components_module__["a" /* CoreComponentsModule */]
            ],
            providers: [
                __WEBPACK_IMPORTED_MODULE_3__providers_handler__["a" /* AddonUserProfileFieldCheckboxHandler */]
            ],
            exports: [
                __WEBPACK_IMPORTED_MODULE_5__component_checkbox__["a" /* AddonUserProfileFieldCheckboxComponent */]
            ],
            entryComponents: [
                __WEBPACK_IMPORTED_MODULE_5__component_checkbox__["a" /* AddonUserProfileFieldCheckboxComponent */]
            ]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__core_user_providers_user_profile_field_delegate__["a" /* CoreUserProfileFieldDelegate */], __WEBPACK_IMPORTED_MODULE_3__providers_handler__["a" /* AddonUserProfileFieldCheckboxHandler */]])
    ], AddonUserProfileFieldCheckboxModule);
    return AddonUserProfileFieldCheckboxModule;
}());

//# sourceMappingURL=checkbox.module.js.map

/***/ }),

/***/ 1125:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonUserProfileFieldCheckboxHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__component_checkbox__ = __webpack_require__(625);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


/**
 * Checkbox user profile field handlers.
 */
var AddonUserProfileFieldCheckboxHandler = /** @class */ (function () {
    function AddonUserProfileFieldCheckboxHandler() {
        this.name = 'checkbox';
        // Nothing to do.
    }
    /**
     * Whether or not the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} True or promise resolved with true if enabled.
     */
    AddonUserProfileFieldCheckboxHandler.prototype.isEnabled = function () {
        return true;
    };
    /**
     * Get the data to send for the field based on the input data.
     *
     * @param  {any}     field          User field to get the data for.
     * @param  {boolean} signup         True if user is in signup page.
     * @param  {string}  [registerAuth] Register auth method. E.g. 'email'.
     * @param  {any}     formValues     Form Values.
     * @return {CoreUserProfileFieldHandlerData}  Data to send for the field.
     */
    AddonUserProfileFieldCheckboxHandler.prototype.getData = function (field, signup, registerAuth, formValues) {
        var name = 'profile_field_' + field.shortname;
        if (typeof formValues[name] != 'undefined') {
            return {
                type: 'checkbox',
                name: name,
                value: formValues[name] ? 1 : 0
            };
        }
    };
    /**
     * Return the Component to use to display the user profile field.
     *
     * @return {any}     The component to use, undefined if not found.
     */
    AddonUserProfileFieldCheckboxHandler.prototype.getComponent = function () {
        return __WEBPACK_IMPORTED_MODULE_1__component_checkbox__["a" /* AddonUserProfileFieldCheckboxComponent */];
    };
    AddonUserProfileFieldCheckboxHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [])
    ], AddonUserProfileFieldCheckboxHandler);
    return AddonUserProfileFieldCheckboxHandler;
}());

//# sourceMappingURL=handler.js.map

/***/ }),

/***/ 1126:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonUserProfileFieldDatetimeModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_handler__ = __webpack_require__(1127);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_user_providers_user_profile_field_delegate__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__component_datetime__ = __webpack_require__(626);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__components_components_module__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__pipes_pipes_module__ = __webpack_require__(153);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








var AddonUserProfileFieldDatetimeModule = /** @class */ (function () {
    function AddonUserProfileFieldDatetimeModule(userProfileFieldDelegate, handler) {
        userProfileFieldDelegate.registerHandler(handler);
    }
    AddonUserProfileFieldDatetimeModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_5__component_datetime__["a" /* AddonUserProfileFieldDatetimeComponent */]
            ],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["g" /* IonicModule */],
                __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["b" /* TranslateModule */].forChild(),
                __WEBPACK_IMPORTED_MODULE_6__components_components_module__["a" /* CoreComponentsModule */],
                __WEBPACK_IMPORTED_MODULE_7__pipes_pipes_module__["a" /* CorePipesModule */]
            ],
            providers: [
                __WEBPACK_IMPORTED_MODULE_3__providers_handler__["a" /* AddonUserProfileFieldDatetimeHandler */]
            ],
            exports: [
                __WEBPACK_IMPORTED_MODULE_5__component_datetime__["a" /* AddonUserProfileFieldDatetimeComponent */]
            ],
            entryComponents: [
                __WEBPACK_IMPORTED_MODULE_5__component_datetime__["a" /* AddonUserProfileFieldDatetimeComponent */]
            ]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__core_user_providers_user_profile_field_delegate__["a" /* CoreUserProfileFieldDelegate */], __WEBPACK_IMPORTED_MODULE_3__providers_handler__["a" /* AddonUserProfileFieldDatetimeHandler */]])
    ], AddonUserProfileFieldDatetimeModule);
    return AddonUserProfileFieldDatetimeModule;
}());

//# sourceMappingURL=datetime.module.js.map

/***/ }),

/***/ 1127:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonUserProfileFieldDatetimeHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__component_datetime__ = __webpack_require__(626);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


/**
 * Datetime user profile field handlers.
 */
var AddonUserProfileFieldDatetimeHandler = /** @class */ (function () {
    function AddonUserProfileFieldDatetimeHandler() {
        this.name = 'datetime';
        // Nothing to do.
    }
    /**
     * Whether or not the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} True or promise resolved with true if enabled.
     */
    AddonUserProfileFieldDatetimeHandler.prototype.isEnabled = function () {
        return true;
    };
    /**
     * Get the data to send for the field based on the input data.
     *
     * @param  {any}     field          User field to get the data for.
     * @param  {boolean} signup         True if user is in signup page.
     * @param  {string}  [registerAuth] Register auth method. E.g. 'email'.
     * @param  {any}     formValues     Form Values.
     * @return {CoreUserProfileFieldHandlerData}  Data to send for the field.
     */
    AddonUserProfileFieldDatetimeHandler.prototype.getData = function (field, signup, registerAuth, formValues) {
        var name = 'profile_field_' + field.shortname;
        if (formValues[name]) {
            var milliseconds = new Date(formValues[name]).getTime();
            return {
                type: 'datetime',
                name: 'profile_field_' + field.shortname,
                value: Math.round(milliseconds / 1000)
            };
        }
    };
    /**
     * Return the Component to use to display the user profile field.
     *
     * @return {any}     The component to use, undefined if not found.
     */
    AddonUserProfileFieldDatetimeHandler.prototype.getComponent = function () {
        return __WEBPACK_IMPORTED_MODULE_1__component_datetime__["a" /* AddonUserProfileFieldDatetimeComponent */];
    };
    AddonUserProfileFieldDatetimeHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [])
    ], AddonUserProfileFieldDatetimeHandler);
    return AddonUserProfileFieldDatetimeHandler;
}());

//# sourceMappingURL=handler.js.map

/***/ }),

/***/ 1128:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonUserProfileFieldMenuModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_handler__ = __webpack_require__(1129);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_user_providers_user_profile_field_delegate__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__component_menu__ = __webpack_require__(627);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__components_components_module__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__directives_directives_module__ = __webpack_require__(85);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








var AddonUserProfileFieldMenuModule = /** @class */ (function () {
    function AddonUserProfileFieldMenuModule(userProfileFieldDelegate, handler) {
        userProfileFieldDelegate.registerHandler(handler);
    }
    AddonUserProfileFieldMenuModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_5__component_menu__["a" /* AddonUserProfileFieldMenuComponent */]
            ],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["g" /* IonicModule */],
                __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["b" /* TranslateModule */].forChild(),
                __WEBPACK_IMPORTED_MODULE_6__components_components_module__["a" /* CoreComponentsModule */],
                __WEBPACK_IMPORTED_MODULE_7__directives_directives_module__["a" /* CoreDirectivesModule */]
            ],
            providers: [
                __WEBPACK_IMPORTED_MODULE_3__providers_handler__["a" /* AddonUserProfileFieldMenuHandler */]
            ],
            exports: [
                __WEBPACK_IMPORTED_MODULE_5__component_menu__["a" /* AddonUserProfileFieldMenuComponent */]
            ],
            entryComponents: [
                __WEBPACK_IMPORTED_MODULE_5__component_menu__["a" /* AddonUserProfileFieldMenuComponent */]
            ]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__core_user_providers_user_profile_field_delegate__["a" /* CoreUserProfileFieldDelegate */], __WEBPACK_IMPORTED_MODULE_3__providers_handler__["a" /* AddonUserProfileFieldMenuHandler */]])
    ], AddonUserProfileFieldMenuModule);
    return AddonUserProfileFieldMenuModule;
}());

//# sourceMappingURL=menu.module.js.map

/***/ }),

/***/ 1129:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonUserProfileFieldMenuHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__component_menu__ = __webpack_require__(627);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


/**
 * Menu user profile field handlers.
 */
var AddonUserProfileFieldMenuHandler = /** @class */ (function () {
    function AddonUserProfileFieldMenuHandler() {
        this.name = 'menu';
        // Nothing to do.
    }
    /**
     * Whether or not the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} True or promise resolved with true if enabled.
     */
    AddonUserProfileFieldMenuHandler.prototype.isEnabled = function () {
        return true;
    };
    /**
     * Get the data to send for the field based on the input data.
     *
     * @param  {any}     field          User field to get the data for.
     * @param  {boolean} signup         True if user is in signup page.
     * @param  {string}  [registerAuth] Register auth method. E.g. 'email'.
     * @param  {any}     formValues     Form Values.
     * @return {CoreUserProfileFieldHandlerData}  Data to send for the field.
     */
    AddonUserProfileFieldMenuHandler.prototype.getData = function (field, signup, registerAuth, formValues) {
        var name = 'profile_field_' + field.shortname;
        if (formValues[name]) {
            return {
                type: 'menu',
                name: name,
                value: formValues[name]
            };
        }
    };
    /**
     * Return the Component to use to display the user profile field.
     *
     * @return {any}     The component to use, undefined if not found.
     */
    AddonUserProfileFieldMenuHandler.prototype.getComponent = function () {
        return __WEBPACK_IMPORTED_MODULE_1__component_menu__["a" /* AddonUserProfileFieldMenuComponent */];
    };
    AddonUserProfileFieldMenuHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [])
    ], AddonUserProfileFieldMenuHandler);
    return AddonUserProfileFieldMenuHandler;
}());

//# sourceMappingURL=handler.js.map

/***/ }),

/***/ 113:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreLocalNotificationsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_local_notifications__ = __webpack_require__(138);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__app__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__config__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_dom__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__core_constants__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_rxjs__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_rxjs__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};










/*
  Generated class for the LocalNotificationsProvider provider.

  See https://angular.io/guide/dependency-injection for more info on providers
  and Angular DI.
*/
var CoreLocalNotificationsProvider = /** @class */ (function () {
    function CoreLocalNotificationsProvider(logger, localNotifications, platform, appProvider, utils, configProvider, domUtils) {
        this.localNotifications = localNotifications;
        this.platform = platform;
        this.appProvider = appProvider;
        this.utils = utils;
        this.configProvider = configProvider;
        this.domUtils = domUtils;
        // Variables for the database.
        this.SITES_TABLE = 'notification_sites'; // Store to asigne unique codes to each site.
        this.COMPONENTS_TABLE = 'notification_components'; // Store to asigne unique codes to each component.
        this.TRIGGERED_TABLE = 'notifications_triggered'; // Store to prevent re-triggering notifications.
        this.tablesSchema = [
            {
                name: this.SITES_TABLE,
                columns: [
                    {
                        name: 'id',
                        type: 'TEXT',
                        primaryKey: true
                    },
                    {
                        name: 'code',
                        type: 'INTEGER',
                        notNull: true
                    }
                ]
            },
            {
                name: this.COMPONENTS_TABLE,
                columns: [
                    {
                        name: 'id',
                        type: 'TEXT',
                        primaryKey: true
                    },
                    {
                        name: 'code',
                        type: 'INTEGER',
                        notNull: true
                    }
                ]
            },
            {
                name: this.TRIGGERED_TABLE,
                columns: [
                    {
                        name: 'id',
                        type: 'INTEGER',
                        primaryKey: true
                    },
                    {
                        name: 'at',
                        type: 'INTEGER',
                        notNull: true
                    }
                ]
            }
        ];
        this.codes = {};
        this.codeRequestsQueue = {};
        this.observables = {};
        this.logger = logger.getInstance('CoreLocalNotificationsProvider');
        this.appDB = appProvider.getDB();
        this.appDB.createTablesFromSchema(this.tablesSchema);
    }
    /**
     * Cancel a local notification.
     *
     * @param {number} id Notification id.
     * @param {string} component Component of the notification.
     * @param {string} siteId Site ID.
     * @return {Promise<any>} Promise resolved when the notification is cancelled.
     */
    CoreLocalNotificationsProvider.prototype.cancel = function (id, component, siteId) {
        var _this = this;
        return this.getUniqueNotificationId(id, component, siteId).then(function (uniqueId) {
            return _this.localNotifications.cancel(uniqueId);
        });
    };
    /**
     * Cancel all the scheduled notifications belonging to a certain site.
     *
     * @param {string} siteId Site ID.
     * @return {Promise<any>} Promise resolved when the notifications are cancelled.
     */
    CoreLocalNotificationsProvider.prototype.cancelSiteNotifications = function (siteId) {
        var _this = this;
        if (!this.isAvailable()) {
            return Promise.resolve();
        }
        else if (!siteId) {
            return Promise.reject(null);
        }
        return this.localNotifications.getAllScheduled().then(function (scheduled) {
            var ids = [];
            scheduled.forEach(function (notif) {
                if (typeof notif.data == 'string') {
                    notif.data = JSON.parse(notif.data);
                }
                if (typeof notif.data == 'object' && notif.data.siteId === siteId) {
                    ids.push(notif.id);
                }
            });
            return _this.localNotifications.cancel(ids);
        });
    };
    /**
     * Get a code to create unique notifications. If there's no code assigned, create a new one.
     *
     * @param {string} table Table to search in local DB.
     * @param {string} id ID of the element to get its code.
     * @return {Promise<number>} Promise resolved when the code is retrieved.
     */
    CoreLocalNotificationsProvider.prototype.getCode = function (table, id) {
        var _this = this;
        var key = table + '#' + id;
        // Check if the code is already in memory.
        if (typeof this.codes[key] != 'undefined') {
            return Promise.resolve(this.codes[key]);
        }
        // Check if we already have a code stored for that ID.
        return this.appDB.getRecord(table, { id: id }).then(function (entry) {
            _this.codes[key] = entry.code;
            return entry.code;
        }).catch(function () {
            // No code stored for that ID. Create a new code for it.
            return _this.appDB.getRecords(table, undefined, 'code DESC').then(function (entries) {
                var newCode = 0;
                if (entries.length > 0) {
                    newCode = entries[0].code + 1;
                }
                return _this.appDB.insertRecord(table, { id: id, code: newCode }).then(function () {
                    _this.codes[key] = newCode;
                    return newCode;
                });
            });
        });
    };
    /**
     * Get a notification component code to be used.
     * If it's the first time this component is used to send notifications, create a new code for it.
     *
     * @param {string} component Component name.
     * @return {Promise<number>} Promise resolved when the component code is retrieved.
     */
    CoreLocalNotificationsProvider.prototype.getComponentCode = function (component) {
        return this.requestCode(this.COMPONENTS_TABLE, component);
    };
    /**
     * Get a site code to be used.
     * If it's the first time this site is used to send notifications, create a new code for it.
     *
     * @param {string} siteId Site ID.
     * @return {Promise<number>} Promise resolved when the site code is retrieved.
     */
    CoreLocalNotificationsProvider.prototype.getSiteCode = function (siteId) {
        return this.requestCode(this.SITES_TABLE, siteId);
    };
    /**
     * Create a unique notification ID, trying to prevent collisions. Generated ID must be a Number (Android).
     * The generated ID shouldn't be higher than 2147483647 or it's going to cause problems in Android.
     * This function will prevent collisions and keep the number under Android limit if:
     *     -User has used less than 21 sites.
     *     -There are less than 11 components.
     *     -The notificationId passed as parameter is lower than 10000000.
     *
     * @param {number} notificationId Notification ID.
     * @param {string} component Component triggering the notification.
     * @param {string} siteId Site ID.
     * @return {Promise<number>} Promise resolved when the notification ID is generated.
     */
    CoreLocalNotificationsProvider.prototype.getUniqueNotificationId = function (notificationId, component, siteId) {
        var _this = this;
        if (!siteId || !component) {
            return Promise.reject(null);
        }
        return this.getSiteCode(siteId).then(function (siteCode) {
            return _this.getComponentCode(component).then(function (componentCode) {
                // We use the % operation to keep the number under Android's limit.
                return (siteCode * 100000000 + componentCode * 10000000 + notificationId) % 2147483647;
            });
        });
    };
    /**
     * Returns whether local notifications plugin is installed.
     *
     * @return {boolean} Whether local notifications plugin is installed.
     */
    CoreLocalNotificationsProvider.prototype.isAvailable = function () {
        var win = window;
        return this.appProvider.isDesktop() || !!(win.plugin && win.plugin.notification && win.plugin.notification.local);
    };
    /**
     * Check if a notification has been triggered with the same trigger time.
     *
     * @param {CoreILocalNotification} notification Notification to check.
     * @return {Promise<any>} Promise resolved with a boolean indicating if promise is triggered (true) or not.
     */
    CoreLocalNotificationsProvider.prototype.isTriggered = function (notification) {
        return this.appDB.getRecord(this.TRIGGERED_TABLE, { id: notification.id }).then(function (stored) {
            return stored.at === notification.at.getTime() / 1000;
        }).catch(function () {
            return false;
        });
    };
    /**
     * Notify notification click to observers. Only the observers with the same component as the notification will be notified.
     *
     * @param {any} data Data received by the notification.
     */
    CoreLocalNotificationsProvider.prototype.notifyClick = function (data) {
        var component = data.component;
        if (component) {
            if (this.observables[component]) {
                this.observables[component].next(data);
            }
        }
    };
    /**
     * Process the next request in queue.
     */
    CoreLocalNotificationsProvider.prototype.processNextRequest = function () {
        var _this = this;
        var nextKey = Object.keys(this.codeRequestsQueue)[0];
        var request, promise;
        if (typeof nextKey == 'undefined') {
            // No more requests in queue, stop.
            return;
        }
        request = this.codeRequestsQueue[nextKey];
        // Check if request is valid.
        if (typeof request == 'object' && typeof request.table != 'undefined' && typeof request.id != 'undefined') {
            // Get the code and resolve/reject all the promises of this request.
            promise = this.getCode(request.table, request.id).then(function (code) {
                request.promises.forEach(function (p) {
                    p.resolve(code);
                });
            }).catch(function (error) {
                request.promises.forEach(function (p) {
                    p.reject(error);
                });
            });
        }
        else {
            promise = Promise.resolve();
        }
        // Once this item is treated, remove it and process next.
        promise.finally(function () {
            delete _this.codeRequestsQueue[nextKey];
            _this.processNextRequest();
        });
    };
    /**
     * Register an observer to be notified when a notification belonging to a certain component is clicked.
     *
     * @param {string} component Component to listen notifications for.
     * @param {Function} callback Function to call with the data received by the notification.
     * @return {any} Object with an "off" property to stop listening for clicks.
     */
    CoreLocalNotificationsProvider.prototype.registerClick = function (component, callback) {
        var _this = this;
        this.logger.debug("Register observer '" + component + "' for notification click.");
        if (typeof this.observables[component] == 'undefined') {
            // No observable for this component, create a new one.
            this.observables[component] = new __WEBPACK_IMPORTED_MODULE_9_rxjs__["Subject"]();
        }
        this.observables[component].subscribe(callback);
        return {
            off: function () {
                _this.observables[component].unsubscribe(callback);
            }
        };
    };
    /**
     * Remove a notification from triggered store.
     *
     * @param {number} id Notification ID.
     * @return {Promise<any>} Promise resolved when it is removed.
     */
    CoreLocalNotificationsProvider.prototype.removeTriggered = function (id) {
        return this.appDB.deleteRecords(this.TRIGGERED_TABLE, { id: id });
    };
    /**
     * Request a unique code. The request will be added to the queue and the queue is going to be started if it's paused.
     *
     * @param {string} table Table to search in local DB.
     * @param {string} id ID of the element to get its code.
     * @return {Promise}      Promise resolved when the code is retrieved.
     */
    CoreLocalNotificationsProvider.prototype.requestCode = function (table, id) {
        var deferred = this.utils.promiseDefer(), key = table + '#' + id, isQueueEmpty = Object.keys(this.codeRequestsQueue).length == 0;
        if (typeof this.codeRequestsQueue[key] != 'undefined') {
            // There's already a pending request for this store and ID, add the promise to it.
            this.codeRequestsQueue[key].promises.push(deferred);
        }
        else {
            // Add a pending request to the queue.
            this.codeRequestsQueue[key] = {
                table: table,
                id: id,
                promises: [deferred]
            };
        }
        if (isQueueEmpty) {
            this.processNextRequest();
        }
        return deferred.promise;
    };
    /**
     * Reschedule all notifications that are already scheduled.
     *
     * @return {Promise<any>} Promise resolved when all notifications have been rescheduled.
     */
    CoreLocalNotificationsProvider.prototype.rescheduleAll = function () {
        var _this = this;
        // Get all the scheduled notifications.
        return this.localNotifications.getAllScheduled().then(function (notifications) {
            var promises = [];
            notifications.forEach(function (notification) {
                // Convert some properties to the needed types.
                notification.at = new Date(notification.at * 1000);
                notification.data = notification.data ? JSON.parse(notification.data) : {};
                promises.push(_this.scheduleNotification(notification));
            });
            return Promise.all(promises);
        });
    };
    /**
     * Schedule a local notification.
     *
     * @param {CoreILocalNotification} notification Notification to schedule. Its ID should be lower than 10000000 and it should
     *                                              be unique inside its component and site.
     * @param {string} component Component triggering the notification. It is used to generate unique IDs.
     * @param {string} siteId Site ID.
     * @return {Promise<any>} Promise resolved when the notification is scheduled.
     */
    CoreLocalNotificationsProvider.prototype.schedule = function (notification, component, siteId) {
        var _this = this;
        return this.getUniqueNotificationId(notification.id, component, siteId).then(function (uniqueId) {
            notification.id = uniqueId;
            notification.data = notification.data || {};
            notification.data.component = component;
            notification.data.siteId = siteId;
            if (_this.platform.is('android')) {
                notification.icon = notification.icon || 'res://icon';
                notification.smallIcon = notification.smallIcon || 'res://icon';
                notification.led = notification.led || 'FF9900';
                notification.ledOnTime = notification.ledOnTime || 1000;
                notification.ledOffTime = notification.ledOffTime || 1000;
            }
            return _this.scheduleNotification(notification);
        });
    };
    /**
     * Helper function to schedule a notification object if it hasn't been triggered already.
     *
     * @param {CoreILocalNotification} notification Notification to schedule.
     * @return {Promise<any>} Promise resolved when scheduled.
     */
    CoreLocalNotificationsProvider.prototype.scheduleNotification = function (notification) {
        var _this = this;
        // Check if the notification has been triggered already.
        return this.isTriggered(notification).then(function (triggered) {
            if (!triggered) {
                // Check if sound is enabled for notifications.
                return _this.configProvider.get(__WEBPACK_IMPORTED_MODULE_8__core_constants__["a" /* CoreConstants */].SETTINGS_NOTIFICATION_SOUND, true).then(function (soundEnabled) {
                    if (!soundEnabled) {
                        notification.sound = null;
                    }
                    else {
                        delete notification.sound; // Use default value.
                    }
                    // Remove from triggered, since the notification could be in there with a different time.
                    _this.removeTriggered(notification.id);
                    _this.localNotifications.schedule(notification);
                });
            }
        });
    };
    /**
     * Show an in app notification popover.
     *
     * @param {CoreILocalNotification} notification Notification.
     */
    CoreLocalNotificationsProvider.prototype.showNotificationPopover = function (notification) {
        // @todo Improve it. For now, show Toast.
        if (!notification || !notification.title || !notification.text) {
            // Invalid data.
            return;
        }
        this.domUtils.showToast(notification.text, false, 4000);
    };
    /**
     * Function to call when a notification is triggered. Stores the notification so it's not scheduled again unless the
     * time is changed.
     *
     * @param {CoreILocalNotification} notification Triggered notification.
     * @return {Promise<any>} Promise resolved when stored, rejected otherwise.
     */
    CoreLocalNotificationsProvider.prototype.trigger = function (notification) {
        if (this.platform.is('ios') && this.platform.version().num >= 10) {
            // In iOS10 show in app notification.
            this.showNotificationPopover(notification);
        }
        var entry = {
            id: notification.id,
            at: parseInt(notification.at, 10)
        };
        return this.appDB.insertOrUpdateRecord(this.TRIGGERED_TABLE, entry, { id: notification.id });
    };
    CoreLocalNotificationsProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__ionic_native_local_notifications__["a" /* LocalNotifications */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */],
            __WEBPACK_IMPORTED_MODULE_3__app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_7__utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_4__config__["a" /* CoreConfigProvider */],
            __WEBPACK_IMPORTED_MODULE_6__utils_dom__["a" /* CoreDomUtilsProvider */]])
    ], CoreLocalNotificationsProvider);
    return CoreLocalNotificationsProvider;
}());

//# sourceMappingURL=local-notifications.js.map

/***/ }),

/***/ 1130:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonUserProfileFieldTextModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_handler__ = __webpack_require__(1131);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_user_providers_user_profile_field_delegate__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__component_text__ = __webpack_require__(628);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__components_components_module__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__directives_directives_module__ = __webpack_require__(85);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








var AddonUserProfileFieldTextModule = /** @class */ (function () {
    function AddonUserProfileFieldTextModule(userProfileFieldDelegate, handler) {
        userProfileFieldDelegate.registerHandler(handler);
    }
    AddonUserProfileFieldTextModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_5__component_text__["a" /* AddonUserProfileFieldTextComponent */]
            ],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["g" /* IonicModule */],
                __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["b" /* TranslateModule */].forChild(),
                __WEBPACK_IMPORTED_MODULE_6__components_components_module__["a" /* CoreComponentsModule */],
                __WEBPACK_IMPORTED_MODULE_7__directives_directives_module__["a" /* CoreDirectivesModule */]
            ],
            providers: [
                __WEBPACK_IMPORTED_MODULE_3__providers_handler__["a" /* AddonUserProfileFieldTextHandler */]
            ],
            exports: [
                __WEBPACK_IMPORTED_MODULE_5__component_text__["a" /* AddonUserProfileFieldTextComponent */]
            ],
            entryComponents: [
                __WEBPACK_IMPORTED_MODULE_5__component_text__["a" /* AddonUserProfileFieldTextComponent */]
            ]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__core_user_providers_user_profile_field_delegate__["a" /* CoreUserProfileFieldDelegate */], __WEBPACK_IMPORTED_MODULE_3__providers_handler__["a" /* AddonUserProfileFieldTextHandler */]])
    ], AddonUserProfileFieldTextModule);
    return AddonUserProfileFieldTextModule;
}());

//# sourceMappingURL=text.module.js.map

/***/ }),

/***/ 1131:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonUserProfileFieldTextHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__component_text__ = __webpack_require__(628);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_text__ = __webpack_require__(19);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.



/**
 * Text user profile field handlers.
 */
var AddonUserProfileFieldTextHandler = /** @class */ (function () {
    function AddonUserProfileFieldTextHandler(textUtils) {
        this.textUtils = textUtils;
        this.name = 'text';
    }
    /**
     * Whether or not the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} True or promise resolved with true if enabled.
     */
    AddonUserProfileFieldTextHandler.prototype.isEnabled = function () {
        return true;
    };
    /**
     * Get the data to send for the field based on the input data.
     *
     * @param  {any}     field          User field to get the data for.
     * @param  {boolean} signup         True if user is in signup page.
     * @param  {string}  [registerAuth] Register auth method. E.g. 'email'.
     * @param  {any}     formValues     Form Values.
     * @return {CoreUserProfileFieldHandlerData}  Data to send for the field.
     */
    AddonUserProfileFieldTextHandler.prototype.getData = function (field, signup, registerAuth, formValues) {
        var name = 'profile_field_' + field.shortname;
        return {
            type: 'text',
            name: name,
            value: this.textUtils.cleanTags(formValues[name])
        };
    };
    /**
     * Return the Component to use to display the user profile field.
     *
     * @return {any}     The component to use, undefined if not found.
     */
    AddonUserProfileFieldTextHandler.prototype.getComponent = function () {
        return __WEBPACK_IMPORTED_MODULE_1__component_text__["a" /* AddonUserProfileFieldTextComponent */];
    };
    AddonUserProfileFieldTextHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_utils_text__["a" /* CoreTextUtilsProvider */]])
    ], AddonUserProfileFieldTextHandler);
    return AddonUserProfileFieldTextHandler;
}());

//# sourceMappingURL=handler.js.map

/***/ }),

/***/ 1132:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonUserProfileFieldTextareaModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_handler__ = __webpack_require__(1133);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_user_providers_user_profile_field_delegate__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__component_textarea__ = __webpack_require__(629);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__components_components_module__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__directives_directives_module__ = __webpack_require__(85);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








var AddonUserProfileFieldTextareaModule = /** @class */ (function () {
    function AddonUserProfileFieldTextareaModule(userProfileFieldDelegate, handler) {
        userProfileFieldDelegate.registerHandler(handler);
    }
    AddonUserProfileFieldTextareaModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_5__component_textarea__["a" /* AddonUserProfileFieldTextareaComponent */]
            ],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["g" /* IonicModule */],
                __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["b" /* TranslateModule */].forChild(),
                __WEBPACK_IMPORTED_MODULE_6__components_components_module__["a" /* CoreComponentsModule */],
                __WEBPACK_IMPORTED_MODULE_7__directives_directives_module__["a" /* CoreDirectivesModule */]
            ],
            providers: [
                __WEBPACK_IMPORTED_MODULE_3__providers_handler__["a" /* AddonUserProfileFieldTextareaHandler */]
            ],
            exports: [
                __WEBPACK_IMPORTED_MODULE_5__component_textarea__["a" /* AddonUserProfileFieldTextareaComponent */]
            ],
            entryComponents: [
                __WEBPACK_IMPORTED_MODULE_5__component_textarea__["a" /* AddonUserProfileFieldTextareaComponent */]
            ]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__core_user_providers_user_profile_field_delegate__["a" /* CoreUserProfileFieldDelegate */], __WEBPACK_IMPORTED_MODULE_3__providers_handler__["a" /* AddonUserProfileFieldTextareaHandler */]])
    ], AddonUserProfileFieldTextareaModule);
    return AddonUserProfileFieldTextareaModule;
}());

//# sourceMappingURL=textarea.module.js.map

/***/ }),

/***/ 1133:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonUserProfileFieldTextareaHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__component_textarea__ = __webpack_require__(629);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_text__ = __webpack_require__(19);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.



/**
 * Textarea user profile field handlers.
 */
var AddonUserProfileFieldTextareaHandler = /** @class */ (function () {
    function AddonUserProfileFieldTextareaHandler(textUtils) {
        this.textUtils = textUtils;
        this.name = 'textarea';
    }
    /**
     * Whether or not the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} True or promise resolved with true if enabled.
     */
    AddonUserProfileFieldTextareaHandler.prototype.isEnabled = function () {
        return true;
    };
    /**
     * Get the data to send for the field based on the input data.
     *
     * @param  {any}     field          User field to get the data for.
     * @param  {boolean} signup         True if user is in signup page.
     * @param  {string}  [registerAuth] Register auth method. E.g. 'email'.
     * @param  {any}     formValues     Form Values.
     * @return {CoreUserProfileFieldHandlerData}  Data to send for the field.
     */
    AddonUserProfileFieldTextareaHandler.prototype.getData = function (field, signup, registerAuth, formValues) {
        var name = 'profile_field_' + field.shortname;
        if (formValues[name]) {
            var text = formValues[name] || '';
            // Add some HTML to the message in case the user edited with textarea.
            text = this.textUtils.formatHtmlLines(text);
            return {
                type: 'textarea',
                name: name,
                value: JSON.stringify({
                    text: text,
                    format: 1 // Always send this format.
                })
            };
        }
    };
    /**
     * Return the Component to use to display the user profile field.
     *
     * @return {any}     The component to use, undefined if not found.
     */
    AddonUserProfileFieldTextareaHandler.prototype.getComponent = function () {
        return __WEBPACK_IMPORTED_MODULE_1__component_textarea__["a" /* AddonUserProfileFieldTextareaComponent */];
    };
    AddonUserProfileFieldTextareaHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_utils_text__["a" /* CoreTextUtilsProvider */]])
    ], AddonUserProfileFieldTextareaHandler);
    return AddonUserProfileFieldTextareaHandler;
}());

//# sourceMappingURL=handler.js.map

/***/ }),

/***/ 1134:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonFilesModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_files__ = __webpack_require__(155);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_helper__ = __webpack_require__(646);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_mainmenu_handler__ = __webpack_require__(1135);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_mainmenu_providers_delegate__ = __webpack_require__(88);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





var AddonFilesModule = /** @class */ (function () {
    function AddonFilesModule(mainMenuDelegate, filesHandler) {
        mainMenuDelegate.registerHandler(filesHandler);
    }
    AddonFilesModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [],
            providers: [
                __WEBPACK_IMPORTED_MODULE_1__providers_files__["a" /* AddonFilesProvider */],
                __WEBPACK_IMPORTED_MODULE_2__providers_helper__["a" /* AddonFilesHelperProvider */],
                __WEBPACK_IMPORTED_MODULE_3__providers_mainmenu_handler__["a" /* AddonFilesMainMenuHandler */]
            ]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__core_mainmenu_providers_delegate__["a" /* CoreMainMenuDelegate */], __WEBPACK_IMPORTED_MODULE_3__providers_mainmenu_handler__["a" /* AddonFilesMainMenuHandler */]])
    ], AddonFilesModule);
    return AddonFilesModule;
}());

//# sourceMappingURL=files.module.js.map

/***/ }),

/***/ 1135:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonFilesMainMenuHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__files__ = __webpack_require__(155);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Handler to inject an option into main menu.
 */
var AddonFilesMainMenuHandler = /** @class */ (function () {
    function AddonFilesMainMenuHandler(filesProvider) {
        this.filesProvider = filesProvider;
        this.name = 'AddonFiles';
        this.priority = 200;
    }
    /**
     * Check if the handler is enabled on a site level.
     *
     * @return {boolean} Whether or not the handler is enabled on a site level.
     */
    AddonFilesMainMenuHandler.prototype.isEnabled = function () {
        return this.filesProvider.isPluginEnabled();
    };
    /**
     * Returns the data needed to render the handler.
     *
     * @return {CoreMainMenuHandlerData} Data needed to render the handler.
     */
    AddonFilesMainMenuHandler.prototype.getDisplayData = function () {
        return {
            icon: 'folder',
            title: 'addon.files.files',
            page: 'AddonFilesListPage',
            class: 'addon-files-handler'
        };
    };
    AddonFilesMainMenuHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__files__["a" /* AddonFilesProvider */]])
    ], AddonFilesMainMenuHandler);
    return AddonFilesMainMenuHandler;
}());

//# sourceMappingURL=mainmenu-handler.js.map

/***/ }),

/***/ 114:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreWSProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_http__ = __webpack_require__(540);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_common_http__ = __webpack_require__(107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ionic_native_file_transfer__ = __webpack_require__(214);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__app__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__file__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__utils_mimetype__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__utils_text__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__core_constants__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_ts_md5_dist_md5__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_ts_md5_dist_md5___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12_ts_md5_dist_md5__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__classes_interceptor__ = __webpack_require__(541);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};














/**
 * This service allows performing WS calls and download/upload files.
 */
var CoreWSProvider = /** @class */ (function () {
    function CoreWSProvider(http, translate, appProvider, textUtils, logger, utils, fileProvider, fileTransfer, commonHttp, mimeUtils) {
        this.http = http;
        this.translate = translate;
        this.appProvider = appProvider;
        this.textUtils = textUtils;
        this.utils = utils;
        this.fileProvider = fileProvider;
        this.fileTransfer = fileTransfer;
        this.commonHttp = commonHttp;
        this.mimeUtils = mimeUtils;
        this.mimeTypeCache = {}; // A "cache" to store file mimetypes to prevent performing too many HEAD requests.
        this.ongoingCalls = {};
        this.retryCalls = [];
        this.retryTimeout = 0;
        this.logger = logger.getInstance('CoreWSProvider');
    }
    /**
     * Adds the call data to an special queue to be processed when retrying.
     *
     * @param {string} method The WebService method to be called.
     * @param {string} siteUrl Complete site url to perform the call.
     * @param {any} ajaxData Arguments to pass to the method.
     * @param {CoreWSPreSets} preSets Extra settings and information.
     * @return {Promise<any>} Deferred promise resolved with the response data in success and rejected with the error message
     *                        if it fails.
     */
    CoreWSProvider.prototype.addToRetryQueue = function (method, siteUrl, ajaxData, preSets) {
        var call = {
            method: method,
            siteUrl: siteUrl,
            ajaxData: ajaxData,
            preSets: preSets,
            deferred: this.utils.promiseDefer(),
        };
        this.retryCalls.push(call);
        return call.deferred.promise;
    };
    /**
     * A wrapper function for a moodle WebService call.
     *
     * @param {string} method The WebService method to be called.
     * @param {any} data Arguments to pass to the method. It's recommended to call convertValuesToString before passing the data.
     * @param {CoreWSPreSets} preSets Extra settings and information.
     * @return {Promise<any>} Promise resolved with the response data in success and rejected if it fails.
     */
    CoreWSProvider.prototype.call = function (method, data, preSets) {
        var siteUrl;
        if (!preSets) {
            return Promise.reject(this.createFakeWSError('core.unexpectederror', true));
        }
        else if (!this.appProvider.isOnline()) {
            return Promise.reject(this.createFakeWSError('core.networkerrormsg', true));
        }
        preSets.typeExpected = preSets.typeExpected || 'object';
        if (typeof preSets.responseExpected == 'undefined') {
            preSets.responseExpected = true;
        }
        data = data || {};
        data = this.utils.clone(data); // Clone the data so the changes don't affect the original data.
        data.wsfunction = method;
        data.wstoken = preSets.wsToken;
        siteUrl = preSets.siteUrl + '/webservice/rest/server.php?moodlewsrestformat=json';
        var promise = this.getPromiseHttp('post', preSets.siteUrl, data);
        if (!promise) {
            // There are some ongoing retry calls, wait for timeout.
            if (this.retryCalls.length > 0) {
                this.logger.warn('Calls locked, trying later...');
                promise = this.addToRetryQueue(method, siteUrl, data, preSets);
            }
            else {
                promise = this.performPost(method, siteUrl, data, preSets);
            }
        }
        return promise;
    };
    /**
     * Call a Moodle WS using the AJAX API. Please use it if the WS layer is not an option.
     *
     * @param {string} method The WebService method to be called.
     * @param {any} data Arguments to pass to the method.
     * @param {CoreWSAjaxPreSets} preSets Extra settings and information. Only some
     * @return {Promise<any>} Promise resolved with the response data in success and rejected with an object containing:
     *                                 - error: Error message.
     *                                 - errorcode: Error code returned by the site (if any).
     *                                 - available: 0 if unknown, 1 if available, -1 if not available.
     */
    CoreWSProvider.prototype.callAjax = function (method, data, preSets) {
        var _this = this;
        var siteUrl, ajaxData;
        if (typeof preSets.siteUrl == 'undefined') {
            return rejectWithError(this.translate.instant('core.unexpectederror'));
        }
        else if (!this.appProvider.isOnline()) {
            return rejectWithError(this.translate.instant('core.networkerrormsg'));
        }
        if (typeof preSets.responseExpected == 'undefined') {
            preSets.responseExpected = true;
        }
        ajaxData = [{
                index: 0,
                methodname: method,
                args: this.convertValuesToString(data)
            }];
        siteUrl = preSets.siteUrl + '/lib/ajax/service.php';
        var observable = this.http.post(siteUrl, JSON.stringify(ajaxData)).timeout(__WEBPACK_IMPORTED_MODULE_11__core_constants__["a" /* CoreConstants */].WS_TIMEOUT);
        return this.utils.observableToPromise(observable).then(function (data) {
            // Some moodle web services return null.
            // If the responseExpected value is set then so long as no data is returned, we create a blank object.
            if (!data && !preSets.responseExpected) {
                data = [{}];
            }
            // Check if error. Ajax layer should always return an object (if error) or an array (if success).
            if (!data || typeof data != 'object') {
                return rejectWithError(_this.translate.instant('core.serverconnection'));
            }
            else if (data.error) {
                return rejectWithError(data.error, data.errorcode);
            }
            // Get the first response since only one request was done.
            data = data[0];
            if (data.error) {
                return rejectWithError(data.exception.message, data.exception.errorcode);
            }
            return data.data;
        }, function (data) {
            var available = data.status == 404 ? -1 : 0;
            return rejectWithError(_this.translate.instant('core.serverconnection'), '', available);
        });
        // Convenience function to return an error.
        function rejectWithError(message, code, available) {
            if (typeof available == 'undefined') {
                if (code) {
                    available = code == 'invalidrecord' ? -1 : 1;
                }
                else {
                    available = 0;
                }
            }
            return Promise.reject({
                error: message,
                errorcode: code,
                available: available
            });
        }
    };
    /**
     * Converts an objects values to strings where appropriate.
     * Arrays (associative or otherwise) will be maintained.
     *
     * @param {object} data The data that needs all the non-object values set to strings.
     * @param {boolean} [stripUnicode] If Unicode long chars need to be stripped.
     * @return {object} The cleaned object, with multilevel array and objects preserved.
     */
    CoreWSProvider.prototype.convertValuesToString = function (data, stripUnicode) {
        var result;
        if (!Array.isArray(data) && typeof data == 'object') {
            result = {};
        }
        else {
            result = [];
        }
        for (var el in data) {
            if (typeof data[el] == 'object') {
                result[el] = this.convertValuesToString(data[el], stripUnicode);
            }
            else {
                if (typeof data[el] == 'string') {
                    result[el] = stripUnicode ? this.textUtils.stripUnicode(data[el]) : data[el];
                    if (stripUnicode && data[el] != result[el] && result[el].trim().length == 0) {
                        throw new Error();
                    }
                }
                else {
                    result[el] = data[el] + '';
                }
            }
        }
        return result;
    };
    /**
     * Create a "fake" WS error for local errors.
     *
     * @param {string} message The message to include in the error.
     * @param {boolean} [needsTranslate] If the message needs to be translated.
     * @return {CoreWSError} Fake WS error.
     */
    CoreWSProvider.prototype.createFakeWSError = function (message, needsTranslate) {
        if (needsTranslate) {
            message = this.translate.instant(message);
        }
        return {
            message: message
        };
    };
    /**
     * Downloads a file from Moodle using Cordova File API.
     *
     * @param {string} url Download url.
     * @param {string} path Local path to store the file.
     * @param {boolean} [addExtension] True if extension need to be added to the final path.
     * @param {Function} [onProgress] Function to call on progress.
     * @return {Promise<any>} Promise resolved with the downloaded file.
     */
    CoreWSProvider.prototype.downloadFile = function (url, path, addExtension, onProgress) {
        var _this = this;
        this.logger.debug('Downloading file', url, path, addExtension);
        if (!this.appProvider.isOnline()) {
            return Promise.reject(this.translate.instant('core.networkerrormsg'));
        }
        // Use a tmp path to download the file and then move it to final location.
        // This is because if the download fails, the local file is deleted.
        var tmpPath = path + '.tmp';
        // Create the tmp file as an empty file.
        return this.fileProvider.createFile(tmpPath).then(function (fileEntry) {
            var transfer = _this.fileTransfer.create();
            transfer.onProgress(onProgress);
            return transfer.download(url, fileEntry.toURL(), true).then(function () {
                var promise;
                if (addExtension) {
                    var ext_1 = _this.mimeUtils.getFileExtension(path);
                    // Google Drive extensions will be considered invalid since Moodle usually converts them.
                    if (!ext_1 || ext_1 == 'gdoc' || ext_1 == 'gsheet' || ext_1 == 'gslides' || ext_1 == 'gdraw') {
                        // Not valid, get the file's mimetype.
                        promise = _this.getRemoteFileMimeType(url).then(function (mime) {
                            if (mime) {
                                var remoteExt = _this.mimeUtils.getExtension(mime, url);
                                // If the file is from Google Drive, ignore mimetype application/json.
                                if (remoteExt && (!ext_1 || mime != 'application/json')) {
                                    if (ext_1) {
                                        // Remove existing extension since we will use another one.
                                        path = _this.mimeUtils.removeExtension(path);
                                    }
                                    path += '.' + remoteExt;
                                    return remoteExt;
                                }
                            }
                            return ext_1;
                        });
                    }
                    else {
                        promise = Promise.resolve(ext_1);
                    }
                }
                else {
                    promise = Promise.resolve('');
                }
                return promise.then(function (extension) {
                    return _this.fileProvider.moveFile(tmpPath, path).then(function (movedEntry) {
                        // Save the extension.
                        movedEntry.extension = extension;
                        movedEntry.path = path;
                        _this.logger.debug("Success downloading file " + url + " to " + path + " with extension " + extension);
                        return movedEntry;
                    });
                });
            });
        }).catch(function (err) {
            _this.logger.error("Error downloading " + url + " to " + path, err);
            return Promise.reject(err);
        });
    };
    /**
     * Get a promise from the cache.
     *
     * @param {string} method Method of the HTTP request.
     * @param {string} url Base URL of the HTTP request.
     * @param {any} [params] Params of the HTTP request.
     */
    CoreWSProvider.prototype.getPromiseHttp = function (method, url, params) {
        var queueItemId = this.getQueueItemId(method, url, params);
        if (typeof this.ongoingCalls[queueItemId] != 'undefined') {
            return this.ongoingCalls[queueItemId];
        }
        return false;
    };
    /**
     * Perform a HEAD request to get the mimetype of a remote file.
     *
     * @param {string} url File URL.
     * @param {boolean} [ignoreCache] True to ignore cache, false otherwise.
     * @return {Promise<string>} Promise resolved with the mimetype or '' if failure.
     */
    CoreWSProvider.prototype.getRemoteFileMimeType = function (url, ignoreCache) {
        var _this = this;
        if (this.mimeTypeCache[url] && !ignoreCache) {
            return Promise.resolve(this.mimeTypeCache[url]);
        }
        return this.performHead(url).then(function (data) {
            var mimeType = data.headers.get('Content-Type');
            if (mimeType) {
                // Remove "parameters" like charset.
                mimeType = mimeType.split(';')[0];
            }
            _this.mimeTypeCache[url] = mimeType;
            return mimeType || '';
        }).catch(function () {
            // Error, resolve with empty mimetype.
            return '';
        });
    };
    /**
     * Perform a HEAD request to get the size of a remote file.
     *
     * @param {string} url File URL.
     * @return {Promise<number>} Promise resolved with the size or -1 if failure.
     */
    CoreWSProvider.prototype.getRemoteFileSize = function (url) {
        return this.performHead(url).then(function (data) {
            var size = parseInt(data.headers.get('Content-Length'), 10);
            if (size) {
                return size;
            }
            return -1;
        }).catch(function () {
            // Error, return -1.
            return -1;
        });
    };
    /**
     * Get the unique queue item id of the cache for a HTTP request.
     *
     * @param {string} method Method of the HTTP request.
     * @param {string} url Base URL of the HTTP request.
     * @param {object} [params] Params of the HTTP request.
     * @return {string} Queue item ID.
     */
    CoreWSProvider.prototype.getQueueItemId = function (method, url, params) {
        if (params) {
            url += '###' + __WEBPACK_IMPORTED_MODULE_13__classes_interceptor__["a" /* CoreInterceptor */].serialize(params);
        }
        return method + '#' + __WEBPACK_IMPORTED_MODULE_12_ts_md5_dist_md5__["Md5"].hashAsciiStr(url);
    };
    /**
     * Perform a HEAD request and save the promise while waiting to be resolved.
     *
     * @param {string} url URL to perform the request.
     * @return {Promise<any>} Promise resolved with the response.
     */
    CoreWSProvider.prototype.performHead = function (url) {
        var promise = this.getPromiseHttp('head', url);
        if (!promise) {
            promise = this.utils.observableToPromise(this.commonHttp.head(url).timeout(__WEBPACK_IMPORTED_MODULE_11__core_constants__["a" /* CoreConstants */].WS_TIMEOUT));
            promise = this.setPromiseHttp(promise, 'head', url);
        }
        return promise;
    };
    /**
     * Perform the post call and save the promise while waiting to be resolved.
     *
     * @param {string} method The WebService method to be called.
     * @param {string} siteUrl Complete site url to perform the call.
     * @param {any} ajaxData Arguments to pass to the method.
     * @param {CoreWSPreSets} preSets Extra settings and information.
     * @return {Promise<any>} Promise resolved with the response data in success and rejected with CoreWSError if it fails.
     */
    CoreWSProvider.prototype.performPost = function (method, siteUrl, ajaxData, preSets) {
        var _this = this;
        // Perform the post request.
        var observable = this.http.post(siteUrl, ajaxData).timeout(__WEBPACK_IMPORTED_MODULE_11__core_constants__["a" /* CoreConstants */].WS_TIMEOUT);
        var promise;
        promise = this.utils.observableToPromise(observable).then(function (data) {
            // Some moodle web services return null.
            // If the responseExpected value is set to false, we create a blank object if the response is null.
            if (!data && !preSets.responseExpected) {
                data = {};
            }
            if (!data) {
                return Promise.reject(_this.createFakeWSError('core.serverconnection', true));
            }
            else if (typeof data != preSets.typeExpected) {
                _this.logger.warn('Response of type "' + typeof data + ("\" received, expecting \"" + preSets.typeExpected + "\""));
                return Promise.reject(_this.createFakeWSError('core.errorinvalidresponse', true));
            }
            if (typeof data.exception !== 'undefined') {
                return Promise.reject(data);
            }
            if (typeof data.debuginfo != 'undefined') {
                return Promise.reject(_this.createFakeWSError('Error. ' + data.message));
            }
            return data;
        }, function (error) {
            // If server has heavy load, retry after some seconds.
            if (error.status == 429) {
                var retryPromise = _this.addToRetryQueue(method, siteUrl, ajaxData, preSets);
                // Only process the queue one time.
                if (_this.retryTimeout == 0) {
                    _this.retryTimeout = parseInt(error.headers.get('Retry-After'), 10) || 5;
                    _this.logger.warn(error.statusText + ". Retrying in " + _this.retryTimeout + " seconds. " +
                        (_this.retryCalls.length + " calls left."));
                    setTimeout(function () {
                        _this.logger.warn("Retrying now with " + _this.retryCalls.length + " calls to process.");
                        // Finish timeout.
                        _this.retryTimeout = 0;
                        _this.processRetryQueue();
                    }, _this.retryTimeout * 1000);
                }
                else {
                    _this.logger.warn('Calls locked, trying later...');
                }
                return retryPromise;
            }
            return Promise.reject(_this.createFakeWSError('core.serverconnection', true));
        });
        promise = this.setPromiseHttp(promise, 'post', preSets.siteUrl, ajaxData);
        return promise;
    };
    /**
     * Retry all requests in the queue.
     * This function uses recursion in order to add a delay between requests to reduce stress.
     */
    CoreWSProvider.prototype.processRetryQueue = function () {
        var _this = this;
        if (this.retryCalls.length > 0 && this.retryTimeout == 0) {
            var call_1 = this.retryCalls.shift();
            // Add a delay between calls.
            setTimeout(function () {
                call_1.deferred.resolve(_this.performPost(call_1.method, call_1.siteUrl, call_1.ajaxData, call_1.preSets));
                _this.processRetryQueue();
            }, 200);
        }
        else {
            this.logger.warn("Retry queue has stopped with " + this.retryCalls.length + " calls and " + this.retryTimeout + " timeout secs.");
        }
    };
    /**
     * Save promise on the cache.
     *
     * @param {Promise<any>} promise Promise to be saved.
     * @param {string} method Method of the HTTP request.
     * @param {string} url Base URL of the HTTP request.
     * @param {any} [params] Params of the HTTP request.
     * @return {Promise<any>} The promise saved.
     */
    CoreWSProvider.prototype.setPromiseHttp = function (promise, method, url, params) {
        var _this = this;
        var queueItemId = this.getQueueItemId(method, url, params);
        var timeout;
        this.ongoingCalls[queueItemId] = promise;
        // HTTP not finished, but we should delete the promise after timeout.
        timeout = setTimeout(function () {
            delete _this.ongoingCalls[queueItemId];
        }, __WEBPACK_IMPORTED_MODULE_11__core_constants__["a" /* CoreConstants */].WS_TIMEOUT);
        // HTTP finished, delete from ongoing.
        return promise.finally(function () {
            delete _this.ongoingCalls[queueItemId];
            clearTimeout(timeout);
        });
    };
    /**
     * A wrapper function for a synchronous Moodle WebService call.
     * Warning: This function should only be used if synchronous is a must. It's recommended to use call.
     *
     * @param {string} method The WebService method to be called.
     * @param {any} data Arguments to pass to the method.
     * @param {CoreWSPreSets} preSets Extra settings and information.
     * @return {Promise} Promise resolved with the response data in success and rejected with the error message if it fails.
     * @return {any} Request response. If the request fails, returns an object with 'error'=true and 'message' properties.
     */
    CoreWSProvider.prototype.syncCall = function (method, data, preSets) {
        var errorResponse = {
            error: true,
            message: ''
        };
        var siteUrl, xhr;
        if (!preSets) {
            errorResponse.message = this.translate.instant('core.unexpectederror');
            return errorResponse;
        }
        else if (!this.appProvider.isOnline()) {
            errorResponse.message = this.translate.instant('core.networkerrormsg');
            return errorResponse;
        }
        preSets.typeExpected = preSets.typeExpected || 'object';
        if (typeof preSets.responseExpected == 'undefined') {
            preSets.responseExpected = true;
        }
        try {
            data = this.convertValuesToString(data, preSets.cleanUnicode);
        }
        catch (e) {
            // Empty cleaned text found.
            errorResponse.message = this.translate.instant('core.unicodenotsupportedcleanerror');
            return errorResponse;
        }
        data.wsfunction = method;
        data.wstoken = preSets.wsToken;
        siteUrl = preSets.siteUrl + '/webservice/rest/server.php?moodlewsrestformat=json';
        // Serialize data.
        data = __WEBPACK_IMPORTED_MODULE_13__classes_interceptor__["a" /* CoreInterceptor */].serialize(data);
        // Perform sync request using XMLHttpRequest.
        xhr = new window.XMLHttpRequest();
        xhr.open('post', siteUrl, false);
        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded;charset=utf-8');
        xhr.send(data);
        // Get response.
        data = ('response' in xhr) ? xhr.response : xhr.responseText;
        // Check status.
        xhr.status = Math.max(xhr.status === 1223 ? 204 : xhr.status, 0);
        if (xhr.status < 200 || xhr.status >= 300) {
            // Request failed.
            errorResponse.message = data;
            return errorResponse;
        }
        // Treat response.
        try {
            data = JSON.parse(data);
        }
        catch (ex) {
            // Ignore errors.
        }
        // Some moodle web services return null.
        // If the responseExpected value is set then so long as no data is returned, we create a blank object.
        if ((!data || !data.data) && !preSets.responseExpected) {
            data = {};
        }
        if (!data) {
            errorResponse.message = this.translate.instant('core.serverconnection');
        }
        else if (typeof data != preSets.typeExpected) {
            this.logger.warn('Response of type "' + typeof data + '" received, expecting "' + preSets.typeExpected + '"');
            errorResponse.message = this.translate.instant('core.errorinvalidresponse');
        }
        if (typeof data.exception != 'undefined' || typeof data.debuginfo != 'undefined') {
            errorResponse.message = data.message;
        }
        if (errorResponse.message !== '') {
            return errorResponse;
        }
        return data;
    };
    /*
     * Uploads a file.
     *
     * @param {string} filePath File path.
     * @param {CoreWSFileUploadOptions} options File upload options.
     * @param {CoreWSPreSets} preSets Must contain siteUrl and wsToken.
     * @param {Function} [onProgress] Function to call on progress.
     * @return {Promise<any>} Promise resolved when uploaded.
     */
    CoreWSProvider.prototype.uploadFile = function (filePath, options, preSets, onProgress) {
        var _this = this;
        this.logger.debug("Trying to upload file: " + filePath);
        if (!filePath || !options || !preSets) {
            return Promise.reject(null);
        }
        if (!this.appProvider.isOnline()) {
            return Promise.reject(this.translate.instant('core.networkerrormsg'));
        }
        var uploadUrl = preSets.siteUrl + '/webservice/upload.php', transfer = this.fileTransfer.create();
        transfer.onProgress(onProgress);
        options.httpMethod = 'POST';
        options.params = {
            token: preSets.wsToken,
            filearea: options.fileArea || 'draft',
            itemid: options.itemId || 0
        };
        options.chunkedMode = false;
        options.headers = {
            Connection: 'close'
        };
        return transfer.upload(filePath, uploadUrl, options, true).then(function (success) {
            var data = success.response;
            try {
                data = JSON.parse(data);
            }
            catch (err) {
                _this.logger.error('Error parsing response from upload:', err, data);
                return Promise.reject(_this.translate.instant('core.errorinvalidresponse'));
            }
            if (!data) {
                return Promise.reject(_this.translate.instant('core.serverconnection'));
            }
            else if (typeof data != 'object') {
                _this.logger.warn('Upload file: Response of type "' + typeof data + '" received, expecting "object"');
                return Promise.reject(_this.translate.instant('core.errorinvalidresponse'));
            }
            if (typeof data.exception !== 'undefined') {
                return Promise.reject(data.message);
            }
            else if (data && typeof data.error !== 'undefined') {
                return Promise.reject(data.error);
            }
            else if (data[0] && typeof data[0].error !== 'undefined') {
                return Promise.reject(data[0].error);
            }
            // We uploaded only 1 file, so we only return the first file returned.
            _this.logger.debug('Successfully uploaded file', filePath);
            return data[0];
        }).catch(function (error) {
            _this.logger.error('Error while uploading file', filePath, error);
            return Promise.reject(_this.translate.instant('core.errorinvalidresponse'));
        });
    };
    CoreWSProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__angular_common_http__["b" /* HttpClient */], __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_5__app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_9__utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_7__logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_10__utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_6__file__["a" /* CoreFileProvider */], __WEBPACK_IMPORTED_MODULE_4__ionic_native_file_transfer__["a" /* FileTransfer */], __WEBPACK_IMPORTED_MODULE_1__angular_http__["a" /* Http */],
            __WEBPACK_IMPORTED_MODULE_8__utils_mimetype__["a" /* CoreMimetypeUtilsProvider */]])
    ], CoreWSProvider);
    return CoreWSProvider;
}());

//# sourceMappingURL=ws.js.map

/***/ }),

/***/ 115:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSiteHomeProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__course_providers_course__ = __webpack_require__(37);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Service that provides some features regarding site home.
 */
var CoreSiteHomeProvider = /** @class */ (function () {
    function CoreSiteHomeProvider(logger, sitesProvider, courseProvider) {
        this.sitesProvider = sitesProvider;
        this.courseProvider = courseProvider;
        this.logger = logger.getInstance('CoreSiteHomeProvider');
    }
    /**
     * Returns whether or not the frontpage is available for the current site.
     *
     * @param {string} [siteId] The site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with boolean: whether it's available.
     */
    CoreSiteHomeProvider.prototype.isAvailable = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            // First check if it's disabled.
            if (_this.isDisabledInSite(site)) {
                return false;
            }
            // Use a WS call to check if there's content in the site home.
            var siteHomeId = site.getSiteHomeId(), preSets = { emergencyCache: false };
            _this.logger.debug('Using WS call to check if site home is available.');
            return _this.courseProvider.getSections(siteHomeId, false, true, preSets, site.id).then(function (sections) {
                if (!sections || !sections.length) {
                    return Promise.reject(null);
                }
                for (var i = 0; i < sections.length; i++) {
                    var section = sections[i];
                    if (section.summary || (section.modules && section.modules.length)) {
                        // It has content, return true.
                        return true;
                    }
                }
                return Promise.reject(null);
            }).catch(function () {
                var config = site.getStoredConfig();
                if (config && config.frontpageloggedin) {
                    var items = config.frontpageloggedin.split(',');
                    if (items.length > 0) {
                        // It's enabled.
                        return true;
                    }
                }
                return false;
            });
        }).catch(function () {
            return false;
        });
    };
    /**
     * Check if Site Home is disabled in a certain site.
     *
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<boolean>} Promise resolved with true if disabled, rejected or resolved with false otherwise.
     */
    CoreSiteHomeProvider.prototype.isDisabled = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.isDisabledInSite(site);
        });
    };
    /**
     * Check if Site Home is disabled in a certain site.
     *
     * @param {CoreSite} [site] Site. If not defined, use current site.
     * @return {boolean} Whether it's disabled.
     */
    CoreSiteHomeProvider.prototype.isDisabledInSite = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.isFeatureDisabled('$mmSideMenuDelegate_mmaFrontpage');
    };
    CoreSiteHomeProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_3__course_providers_course__["a" /* CoreCourseProvider */]])
    ], CoreSiteHomeProvider);
    return CoreSiteHomeProvider;
}());

//# sourceMappingURL=sitehome.js.map

/***/ }),

/***/ 116:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreUserDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__classes_delegate__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_courses_providers_courses__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_sites__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_events__ = __webpack_require__(21);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






/**
 * Service to interact with plugins to be shown in user profile. Provides functions to register a plugin
 * and notify an update in the data.
 */
var CoreUserDelegate = /** @class */ (function (_super) {
    __extends(CoreUserDelegate, _super);
    function CoreUserDelegate(loggerProvider, sitesProvider, coursesProvider, eventsProvider) {
        var _this = _super.call(this, 'CoreUserDelegate', loggerProvider, sitesProvider, eventsProvider) || this;
        _this.loggerProvider = loggerProvider;
        _this.sitesProvider = sitesProvider;
        _this.coursesProvider = coursesProvider;
        _this.eventsProvider = eventsProvider;
        _this.handlers = {};
        _this.enabledHandlers = {};
        _this.featurePrefix = '$mmUserDelegate_';
        return _this;
    }
    CoreUserDelegate_1 = CoreUserDelegate;
    /**
     * Get the profile handlers for a user.
     *
     * @param {any} user The user object.
     * @param {number} courseId The course ID.
     * @return {Promise<CoreUserProfileHandlerToDisplay[]>} Resolved with the handlers.
     */
    CoreUserDelegate.prototype.getProfileHandlersFor = function (user, courseId) {
        var _this = this;
        var handlers = [], promises = [];
        // Retrieve course options forcing cache.
        return this.coursesProvider.getUserCourses(true).then(function (courses) {
            var courseIds = courses.map(function (course) {
                return course.id;
            });
            return _this.coursesProvider.getCoursesAdminAndNavOptions(courseIds).then(function (options) {
                // For backwards compatibility we don't modify the courseId.
                var courseIdForOptions = courseId || _this.sitesProvider.getCurrentSiteHomeId(), navOptions = options.navOptions[courseIdForOptions], admOptions = options.admOptions[courseIdForOptions];
                var _loop_1 = function (name_1) {
                    // Checks if the handler is enabled for the user.
                    var handler = _this.handlers[name_1], isEnabledForUser = handler.isEnabledForUser(user, courseId, navOptions, admOptions), promise = Promise.resolve(isEnabledForUser).then(function (enabled) {
                        if (enabled) {
                            handlers.push({
                                data: handler.getDisplayData(user, courseId),
                                priority: handler.priority,
                                type: handler.type || CoreUserDelegate_1.TYPE_NEW_PAGE
                            });
                        }
                        else {
                            return Promise.reject(null);
                        }
                    }).catch(function () {
                        // Nothing to do here, it is not enabled for this user.
                    });
                    promises.push(promise);
                };
                for (var name_1 in _this.enabledHandlers) {
                    _loop_1(name_1);
                }
                return Promise.all(promises).then(function () {
                    return handlers;
                });
            });
        }).catch(function () {
            // Never fails.
            return handlers;
        });
    };
    /**
     * User profile handler type for communication.
     * @type {string}
     */
    CoreUserDelegate.TYPE_COMMUNICATION = 'communication';
    /**
     * User profile handler type for new page.
     * @type {string}
     */
    CoreUserDelegate.TYPE_NEW_PAGE = 'newpage';
    /**
     * User profile handler type for actions.
     * @type {string}
     */
    CoreUserDelegate.TYPE_ACTION = 'action';
    CoreUserDelegate = CoreUserDelegate_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_2__core_courses_providers_courses__["a" /* CoreCoursesProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_events__["a" /* CoreEventsProvider */]])
    ], CoreUserDelegate);
    return CoreUserDelegate;
    var CoreUserDelegate_1;
}(__WEBPACK_IMPORTED_MODULE_1__classes_delegate__["a" /* CoreDelegate */]));

//# sourceMappingURL=user-delegate.js.map

/***/ }),

/***/ 139:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFileUploaderProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_file__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_filepool__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_sites__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_mimetype__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_text__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_time__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_utils_utils__ = __webpack_require__(9);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};











/**
 * Service to upload files.
 */
var CoreFileUploaderProvider = /** @class */ (function () {
    function CoreFileUploaderProvider(logger, fileProvider, textUtils, utils, sitesProvider, timeUtils, mimeUtils, filepoolProvider, platform, translate) {
        this.fileProvider = fileProvider;
        this.textUtils = textUtils;
        this.utils = utils;
        this.sitesProvider = sitesProvider;
        this.timeUtils = timeUtils;
        this.mimeUtils = mimeUtils;
        this.filepoolProvider = filepoolProvider;
        this.platform = platform;
        this.translate = translate;
        this.logger = logger.getInstance('CoreFileUploaderProvider');
    }
    /**
     * Add a dot to the beginning of an extension.
     *
     * @param {string} extension Extension.
     * @return {string}           Treated extension.
     */
    CoreFileUploaderProvider.prototype.addDot = function (extension) {
        return '.' + extension;
    };
    /**
     * Compares two file lists and returns if they are different.
     *
     * @param {any[]} a First file list.
     * @param {any[]} b Second file list.
     * @return {boolean} Whether both lists are different.
     */
    CoreFileUploaderProvider.prototype.areFileListDifferent = function (a, b) {
        a = a || [];
        b = b || [];
        if (a.length != b.length) {
            return true;
        }
        // Currently we are going to compare the order of the files as well.
        // This function can be improved comparing more fields or not comparing the order.
        for (var i = 0; i < a.length; i++) {
            if ((a[i].name || a[i].filename) != (b[i].name || b[i].filename)) {
                return true;
            }
        }
        return false;
    };
    /**
     * Clear temporary attachments to be uploaded.
     * Attachments already saved in an offline store will NOT be deleted.
     *
     * @param {any[]} files List of files.
     */
    CoreFileUploaderProvider.prototype.clearTmpFiles = function (files) {
        // Delete the local files.
        files.forEach(function (file) {
            if (!file.offline && file.remove) {
                // Pass an empty function to prevent missing parameter error.
                file.remove(function () {
                    // Nothing to do.
                });
            }
        });
    };
    /**
     * Get the upload options for a file taken with the Camera Cordova plugin.
     *
     * @param {string} uri File URI.
     * @param {boolean} [isFromAlbum] True if the image was taken from album, false if it's a new image taken with camera.
     * @return {CoreFileUploaderOptions} Options.
     */
    CoreFileUploaderProvider.prototype.getCameraUploadOptions = function (uri, isFromAlbum) {
        var extension = this.mimeUtils.getExtension(uri), mimetype = this.mimeUtils.getMimeType(extension), isIOS = this.platform.is('ios'), options = {
            deleteAfterUpload: !isFromAlbum,
            mimeType: mimetype
        };
        if (isIOS && (mimetype == 'image/jpeg' || mimetype == 'image/png')) {
            // In iOS, the pictures can have repeated names, even if they come from the album.
            options.fileName = 'image_' + this.timeUtils.readableTimestamp() + '.' + extension;
        }
        else {
            // Use the same name that the file already has.
            options.fileName = this.fileProvider.getFileAndDirectoryFromPath(uri).name;
        }
        if (isFromAlbum) {
            // If the file was picked from the album, delete it only if it was copied to the app's folder.
            options.deleteAfterUpload = this.fileProvider.isFileInAppFolder(uri);
            if (this.platform.is('android')) {
                // Picking an image from album in Android adds a timestamp at the end of the file. Delete it.
                options.fileName = options.fileName.replace(/(\.[^\.]*)\?[^\.]*$/, '$1');
            }
        }
        return options;
    };
    /**
     * Get the upload options for a file of any type.
     *
     * @param {string} uri File URI.
     * @param {string} name File name.
     * @param {string} type File type.
     * @param {boolean} [deleteAfterUpload] Whether the file should be deleted after upload.
     * @param {string} [fileArea] File area to upload the file to. It defaults to 'draft'.
     * @param {number} [itemId] Draft ID to upload the file to, 0 to create new.
     * @return {CoreFileUploaderOptions} Options.
     */
    CoreFileUploaderProvider.prototype.getFileUploadOptions = function (uri, name, type, deleteAfterUpload, fileArea, itemId) {
        var options = {};
        options.fileName = name;
        options.mimeType = type || this.mimeUtils.getMimeType(this.mimeUtils.getFileExtension(options.fileName));
        options.deleteAfterUpload = !!deleteAfterUpload;
        options.itemId = itemId || 0;
        options.fileArea = fileArea;
        return options;
    };
    /**
     * Get the upload options for a file taken with the media capture Cordova plugin.
     *
     * @param {MediaFile} mediaFile File object to upload.
     * @return {CoreFileUploaderOptions} Options.
     */
    CoreFileUploaderProvider.prototype.getMediaUploadOptions = function (mediaFile) {
        var options = {};
        var filename = mediaFile.name, split;
        // Add a timestamp to the filename to make it unique.
        split = filename.split('.');
        split[0] += '_' + this.timeUtils.readableTimestamp();
        filename = split.join('.');
        options.fileName = filename;
        options.deleteAfterUpload = true;
        if (mediaFile.type) {
            options.mimeType = mediaFile.type;
        }
        else {
            options.mimeType = this.mimeUtils.getMimeType(this.mimeUtils.getFileExtension(options.fileName));
        }
        return options;
    };
    /**
     * Get the files stored in a folder, marking them as offline.
     *
     * @param {string} folderPath Folder where to get the files.
     * @return {Promise<any[]>} Promise resolved with the list of files.
     */
    CoreFileUploaderProvider.prototype.getStoredFiles = function (folderPath) {
        var _this = this;
        return this.fileProvider.getDirectoryContents(folderPath).then(function (files) {
            return _this.markOfflineFiles(files);
        });
    };
    /**
     * Get stored files from combined online and offline file object.
     *
     * @param {{online: any[], offline: number}} filesObject The combined offline and online files object.
     * @param {string} folderPath Folder path to get files from.
     * @return {Promise<any[]>} Promise resolved with files.
     */
    CoreFileUploaderProvider.prototype.getStoredFilesFromOfflineFilesObject = function (filesObject, folderPath) {
        var files = [];
        if (filesObject) {
            if (filesObject.online && filesObject.online.length > 0) {
                files = this.utils.clone(filesObject.online);
            }
            if (filesObject.offline > 0) {
                return this.getStoredFiles(folderPath).then(function (offlineFiles) {
                    return files.concat(offlineFiles);
                }).catch(function () {
                    // Ignore not found files.
                    return files;
                });
            }
        }
        return Promise.resolve(files);
    };
    /**
     * Check if a file's mimetype is invalid based on the list of accepted mimetypes. This function needs either the file's
     * mimetype or the file's path/name.
     *
     * @param {string[]} [mimetypes] List of supported mimetypes. If undefined, all mimetypes supported.
     * @param {string} [path] File's path or name.
     * @param {string} [mimetype] File's mimetype.
     * @return {string} Undefined if file is valid, error message if file is invalid.
     */
    CoreFileUploaderProvider.prototype.isInvalidMimetype = function (mimetypes, path, mimetype) {
        var extension;
        if (mimetypes) {
            // Verify that the mimetype of the file is supported.
            if (mimetype) {
                extension = this.mimeUtils.getExtension(mimetype);
            }
            else {
                extension = this.mimeUtils.getFileExtension(path);
                mimetype = this.mimeUtils.getMimeType(extension);
            }
            if (mimetype && mimetypes.indexOf(mimetype) == -1) {
                extension = extension || this.translate.instant('core.unknown');
                return this.translate.instant('core.fileuploader.invalidfiletype', { $a: extension });
            }
        }
    };
    /**
     * Mark files as offline.
     *
     * @param {any[]} files Files to mark as offline.
     * @return {any[]} Files marked as offline.
     */
    CoreFileUploaderProvider.prototype.markOfflineFiles = function (files) {
        // Mark the files as pending offline.
        files.forEach(function (file) {
            file.offline = true;
            file.filename = file.name;
        });
        return files;
    };
    /**
     * Parse filetypeList to get the list of allowed mimetypes and the data to render information.
     *
     * @param {string} filetypeList Formatted string list where the mimetypes can be checked.
     * @return {{info: any[], mimetypes: string[]}}  Mimetypes and the filetypes informations.
     */
    CoreFileUploaderProvider.prototype.prepareFiletypeList = function (filetypeList) {
        var _this = this;
        var filetypes = filetypeList.split(/[;, ]+/g), mimetypes = {}, // Use an object to prevent duplicates.
        typesInfo = [];
        filetypes.forEach(function (filetype) {
            filetype = filetype.trim();
            if (filetype) {
                if (filetype.indexOf('/') != -1) {
                    // It's a mimetype.
                    typesInfo.push({
                        name: _this.mimeUtils.getMimetypeDescription(filetype),
                        extlist: _this.mimeUtils.getExtensions(filetype).map(_this.addDot).join(' ')
                    });
                    mimetypes[filetype] = true;
                }
                else if (filetype.indexOf('.') === 0) {
                    // It's an extension.
                    var mimetype = _this.mimeUtils.getMimeType(filetype);
                    typesInfo.push({
                        name: mimetype ? _this.mimeUtils.getMimetypeDescription(mimetype) : false,
                        extlist: filetype
                    });
                    if (mimetype) {
                        mimetypes[mimetype] = true;
                    }
                }
                else {
                    // It's a group.
                    var groupExtensions = _this.mimeUtils.getGroupMimeInfo(filetype, 'extensions'), groupMimetypes = _this.mimeUtils.getGroupMimeInfo(filetype, 'mimetypes');
                    if (groupExtensions.length > 0) {
                        typesInfo.push({
                            name: _this.mimeUtils.getTranslatedGroupName(filetype),
                            extlist: groupExtensions ? groupExtensions.map(_this.addDot).join(' ') : ''
                        });
                        groupMimetypes.forEach(function (mimetype) {
                            if (mimetype) {
                                mimetypes[mimetype] = true;
                            }
                        });
                    }
                    else {
                        // Treat them as extensions.
                        filetype = _this.addDot(filetype);
                        var mimetype = _this.mimeUtils.getMimeType(filetype);
                        typesInfo.push({
                            name: mimetype ? _this.mimeUtils.getMimetypeDescription(mimetype) : false,
                            extlist: filetype
                        });
                        if (mimetype) {
                            mimetypes[mimetype] = true;
                        }
                    }
                }
            }
        });
        return {
            info: typesInfo,
            mimetypes: Object.keys(mimetypes)
        };
    };
    /**
     * Given a list of files (either online files or local files), store the local files in a local folder
     * to be uploaded later.
     *
     * @param {string} folderPath Path of the folder where to store the files.
     * @param {any[]} files List of files.
     * @return {Promise<{online: any[], offline: number}>} Promise resolved if success.
     */
    CoreFileUploaderProvider.prototype.storeFilesToUpload = function (folderPath, files) {
        var _this = this;
        var result = {
            online: [],
            offline: 0
        };
        if (!files || !files.length) {
            return Promise.resolve(result);
        }
        // Remove unused files from previous saves.
        return this.fileProvider.removeUnusedFiles(folderPath, files).then(function () {
            var promises = [];
            files.forEach(function (file) {
                if (file.filename && !file.name) {
                    // It's an online file, add it to the result and ignore it.
                    result.online.push({
                        filename: file.filename,
                        fileurl: file.fileurl
                    });
                }
                else if (!file.name) {
                    // Error.
                    promises.push(Promise.reject(null));
                }
                else if (file.fullPath && file.fullPath.indexOf(folderPath) != -1) {
                    // File already in the submission folder.
                    result.offline++;
                }
                else {
                    // Local file, copy it.
                    // Use copy instead of move to prevent having a unstable state if some copies succeed and others don't.
                    var destFile = _this.textUtils.concatenatePaths(folderPath, file.name);
                    promises.push(_this.fileProvider.copyFile(file.toURL(), destFile));
                    result.offline++;
                }
            });
            return Promise.all(promises).then(function () {
                return result;
            });
        });
    };
    /**
     * Upload a file.
     *
     * @param {string} uri File URI.
     * @param {CoreFileUploaderOptions} [options] Options for the upload.
     * @param {Function} [onProgress] Function to call on progress.
     * @param {string} [siteId] Id of the site to upload the file to. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreFileUploaderProvider.prototype.uploadFile = function (uri, options, onProgress, siteId) {
        var _this = this;
        options = options || {};
        var deleteAfterUpload = options.deleteAfterUpload, ftOptions = this.utils.clone(options);
        delete ftOptions.deleteAfterUpload;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.uploadFile(uri, ftOptions, onProgress);
        }).then(function (result) {
            if (deleteAfterUpload) {
                setTimeout(function () {
                    // Use set timeout, otherwise in Electron the upload threw an error sometimes.
                    _this.fileProvider.removeExternalFile(uri);
                }, 500);
            }
            return result;
        });
    };
    /**
     * Upload a file to a draft area. If the file is an online file it will be downloaded and then re-uploaded.
     *
     * @param {any} file Online file or local FileEntry.
     * @param {number} [itemId] Draft ID to use. Undefined or 0 to create a new draft ID.
     * @param {string} [component] The component to set to the downloaded files.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<number>} Promise resolved with the itemId.
     */
    CoreFileUploaderProvider.prototype.uploadOrReuploadFile = function (file, itemId, component, componentId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var promise, fileName;
        if (file.filename && !file.name) {
            // It's an online file. We need to download it and re-upload it.
            fileName = file.filename;
            promise = this.filepoolProvider.downloadUrl(siteId, file.url || file.fileurl, false, component, componentId, file.timemodified, undefined, undefined, file).then(function (path) {
                return _this.fileProvider.getExternalFile(path);
            });
        }
        else {
            // Local file, we already have the file entry.
            fileName = file.name;
            promise = Promise.resolve(file);
        }
        return promise.then(function (fileEntry) {
            // Now upload the file.
            var options = _this.getFileUploadOptions(fileEntry.toURL(), fileName, fileEntry.type, true, 'draft', itemId);
            return _this.uploadFile(fileEntry.toURL(), options, undefined, siteId).then(function (result) {
                return result.itemid;
            });
        });
    };
    /**
     * Given a list of files (either online files or local files), upload them to a draft area and return the draft ID.
     * Online files will be downloaded and then re-uploaded.
     * If there are no files to upload it will return a fake draft ID (1).
     *
     * @param {any[]} files List of files.
     * @param {string} [component] The component to set to the downloaded files.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<number>} Promise resolved with the itemId.
     */
    CoreFileUploaderProvider.prototype.uploadOrReuploadFiles = function (files, component, componentId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (!files || !files.length) {
            // Return fake draft ID.
            return Promise.resolve(1);
        }
        // Upload only the first file first to get a draft id.
        return this.uploadOrReuploadFile(files[0], 0, component, componentId, siteId).then(function (itemId) {
            var promises = [];
            for (var i = 1; i < files.length; i++) {
                var file = files[i];
                promises.push(_this.uploadOrReuploadFile(file, itemId, component, componentId, siteId));
            }
            return Promise.all(promises).then(function () {
                return itemId;
            });
        });
    };
    CoreFileUploaderProvider.LIMITED_SIZE_WARNING = 1048576; // 1 MB.
    CoreFileUploaderProvider.WIFI_SIZE_WARNING = 10485760; // 10 MB.
    CoreFileUploaderProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_file__["a" /* CoreFileProvider */], __WEBPACK_IMPORTED_MODULE_8__providers_utils_text__["a" /* CoreTextUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_10__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_9__providers_utils_time__["a" /* CoreTimeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_7__providers_utils_mimetype__["a" /* CoreMimetypeUtilsProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_filepool__["a" /* CoreFilepoolProvider */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */], __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */]])
    ], CoreFileUploaderProvider);
    return CoreFileUploaderProvider;
}());

//# sourceMappingURL=fileuploader.js.map

/***/ }),

/***/ 14:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreAppProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_keyboard__ = __webpack_require__(200);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_network__ = __webpack_require__(102);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__db__ = __webpack_require__(201);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__logger__ = __webpack_require__(5);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






/**
 * Factory to provide some global functionalities, like access to the global app database.
 * @description
 * Each service or component should be responsible of creating their own database tables. Example:
 *
 * constructor(appProvider: CoreAppProvider) {
 *     this.appDB = appProvider.getDB();
 *     this.appDB.createTableFromSchema(this.tableSchema);
 * }
 */
var CoreAppProvider = /** @class */ (function () {
    function CoreAppProvider(dbProvider, platform, keyboard, appCtrl, network, logger) {
        var _this = this;
        this.platform = platform;
        this.keyboard = keyboard;
        this.appCtrl = appCtrl;
        this.network = network;
        this.DBNAME = 'MoodleMobile';
        this.isKeyboardShown = false;
        this.logger = logger.getInstance('CoreAppProvider');
        this.db = dbProvider.getDB(this.DBNAME);
        this.keyboard.onKeyboardShow().subscribe(function (data) {
            _this.isKeyboardShown = true;
        });
        this.keyboard.onKeyboardHide().subscribe(function (data) {
            _this.isKeyboardShown = false;
        });
    }
    /**
     * Check if the browser supports mediaDevices.getUserMedia.
     *
     * @return {boolean} Whether the function is supported.
     */
    CoreAppProvider.prototype.canGetUserMedia = function () {
        return !!(navigator && navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
    };
    /**
     * Check if the browser supports MediaRecorder.
     *
     * @return {boolean} Whether the function is supported.
     */
    CoreAppProvider.prototype.canRecordMedia = function () {
        return !!window.MediaRecorder;
    };
    /**
     * Closes the keyboard.
     */
    CoreAppProvider.prototype.closeKeyboard = function () {
        if (this.isMobile()) {
            this.keyboard.close();
        }
    };
    /**
     * Get the application global database.
     *
     * @return {SQLiteDB} App's DB.
     */
    CoreAppProvider.prototype.getDB = function () {
        return this.db;
    };
    /**
     * Get the app's root NavController.
     *
     * @return {NavController} Root NavController.
     */
    CoreAppProvider.prototype.getRootNavController = function () {
        // Function getRootNav is deprecated. Get the first root nav, there should always be one.
        return this.appCtrl.getRootNavs()[0];
    };
    /**
     * Checks if the app is running in a desktop environment (not browser).
     *
     * @return {boolean} Whether the app is running in a desktop environment (not browser).
     */
    CoreAppProvider.prototype.isDesktop = function () {
        var process = window.process;
        return !!(process && process.versions && typeof process.versions.electron != 'undefined');
    };
    /**
     * Check if the keyboard is visible.
     *
     * @return {boolean} Whether keyboard is visible.
     */
    CoreAppProvider.prototype.isKeyboardVisible = function () {
        return this.isKeyboardShown;
    };
    /**
     * Check if the app is running in a Linux environment.
     *
     * @return {boolean} Whether it's running in a Linux environment.
     */
    CoreAppProvider.prototype.isLinux = function () {
        if (!this.isDesktop()) {
            return false;
        }
        try {
            return __webpack_require__(129).platform().indexOf('linux') === 0;
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Check if the app is running in a Mac OS environment.
     *
     * @return {boolean} Whether it's running in a Mac OS environment.
     */
    CoreAppProvider.prototype.isMac = function () {
        if (!this.isDesktop()) {
            return false;
        }
        try {
            return __webpack_require__(129).platform().indexOf('darwin') === 0;
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Checks if the app is running in a mobile or tablet device (Cordova).
     *
     * @return {boolean} Whether the app is running in a mobile or tablet device.
     */
    CoreAppProvider.prototype.isMobile = function () {
        return this.platform.is('cordova');
    };
    /**
     * Returns whether we are online.
     *
     * @return {boolean} Whether the app is online.
     */
    CoreAppProvider.prototype.isOnline = function () {
        var online = this.network.type !== null && this.network.type != Connection.NONE && this.network.type != Connection.UNKNOWN;
        // Double check we are not online because we cannot rely 100% in Cordova APIs. Also, check it in browser.
        if (!online && navigator.onLine) {
            online = true;
        }
        return online;
    };
    /**
     * Check if device uses a limited connection.
     *
     * @return {boolean} Whether the device uses a limited connection.
     */
    CoreAppProvider.prototype.isNetworkAccessLimited = function () {
        var type = this.network.type;
        if (type === null) {
            // Plugin not defined, probably in browser.
            return false;
        }
        var limited = [Connection.CELL_2G, Connection.CELL_3G, Connection.CELL_4G, Connection.CELL];
        return limited.indexOf(type) > -1;
    };
    /**
     * Check if the app is running in a Windows environment.
     *
     * @return {boolean} Whether it's running in a Windows environment.
     */
    CoreAppProvider.prototype.isWindows = function () {
        if (!this.isDesktop()) {
            return false;
        }
        try {
            return __webpack_require__(129).platform().indexOf('win') === 0;
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Open the keyboard.
     */
    CoreAppProvider.prototype.openKeyboard = function () {
        // Open keyboard is not supported in desktop and in iOS.
        if (this.isMobile() && !this.platform.is('ios')) {
            this.keyboard.show();
        }
    };
    /**
     * Start an SSO authentication process.
     * Please notice that this function should be called when the app receives the new token from the browser,
     * NOT when the browser is opened.
     */
    CoreAppProvider.prototype.startSSOAuthentication = function () {
        var _this = this;
        var cancelTimeout, resolvePromise;
        this.ssoAuthenticationPromise = new Promise(function (resolve, reject) {
            resolvePromise = resolve;
            // Resolve it automatically after 10 seconds (it should never take that long).
            cancelTimeout = setTimeout(function () {
                _this.finishSSOAuthentication();
            }, 10000);
        });
        // Store the resolve function in the promise itself.
        this.ssoAuthenticationPromise.resolve = resolvePromise;
        // If the promise is resolved because finishSSOAuthentication is called, stop the cancel promise.
        this.ssoAuthenticationPromise.then(function () {
            clearTimeout(cancelTimeout);
        });
    };
    /**
     * Finish an SSO authentication process.
     */
    CoreAppProvider.prototype.finishSSOAuthentication = function () {
        if (this.ssoAuthenticationPromise) {
            this.ssoAuthenticationPromise.resolve && this.ssoAuthenticationPromise.resolve();
            this.ssoAuthenticationPromise = undefined;
        }
    };
    /**
     * Check if there's an ongoing SSO authentication process.
     *
     * @return {boolean} Whether there's a SSO authentication ongoing.
     */
    CoreAppProvider.prototype.isSSOAuthenticationOngoing = function () {
        return !!this.ssoAuthenticationPromise;
    };
    /**
     * Returns a promise that will be resolved once SSO authentication finishes.
     *
     * @return {Promise<any>} Promise resolved once SSO authentication finishes.
     */
    CoreAppProvider.prototype.waitForSSOAuthentication = function () {
        return this.ssoAuthenticationPromise || Promise.resolve();
    };
    /**
     * Retrieve redirect data.
     *
     * @return {CoreRedirectData} Object with siteid, state, params and timemodified.
     */
    CoreAppProvider.prototype.getRedirect = function () {
        if (localStorage && localStorage.getItem) {
            try {
                var data = {
                    siteId: localStorage.getItem('mmCoreRedirectSiteId'),
                    page: localStorage.getItem('mmCoreRedirectState'),
                    params: localStorage.getItem('mmCoreRedirectParams'),
                    timemodified: parseInt(localStorage.getItem('mmCoreRedirectTime'), 10)
                };
                if (data.params) {
                    data.params = JSON.parse(data.params);
                }
                return data;
            }
            catch (ex) {
                this.logger.error('Error loading redirect data:', ex);
            }
        }
        return {};
    };
    /**
     * Store redirect params.
     *
     * @param {string} siteId Site ID.
     * @param {string} page Page to go.
     * @param {any} params Page params.
     */
    CoreAppProvider.prototype.storeRedirect = function (siteId, page, params) {
        if (localStorage && localStorage.setItem) {
            try {
                localStorage.setItem('mmCoreRedirectSiteId', siteId);
                localStorage.setItem('mmCoreRedirectState', page);
                localStorage.setItem('mmCoreRedirectParams', JSON.stringify(params));
                localStorage.setItem('mmCoreRedirectTime', String(Date.now()));
            }
            catch (ex) {
                // Ignore errors.
            }
        }
    };
    CoreAppProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__db__["a" /* CoreDbProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */], __WEBPACK_IMPORTED_MODULE_2__ionic_native_keyboard__["a" /* Keyboard */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["c" /* App */],
            __WEBPACK_IMPORTED_MODULE_3__ionic_native_network__["a" /* Network */], __WEBPACK_IMPORTED_MODULE_5__logger__["a" /* CoreLoggerProvider */]])
    ], CoreAppProvider);
    return CoreAppProvider;
}());

//# sourceMappingURL=app.js.map

/***/ }),

/***/ 140:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseModuleDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_events__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_sites__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__course__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__classes_delegate__ = __webpack_require__(67);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






/**
 * Delegate to register module handlers.
 */
var CoreCourseModuleDelegate = /** @class */ (function (_super) {
    __extends(CoreCourseModuleDelegate, _super);
    function CoreCourseModuleDelegate(loggerProvider, sitesProvider, eventsProvider, courseProvider) {
        var _this = _super.call(this, 'CoreCourseModuleDelegate', loggerProvider, sitesProvider, eventsProvider) || this;
        _this.sitesProvider = sitesProvider;
        _this.courseProvider = courseProvider;
        _this.handlers = {}; // All registered handlers.
        _this.enabledHandlers = {}; // Handlers enabled for the current site.
        _this.featurePrefix = '$mmCourseDelegate_';
        return _this;
    }
    /**
     * Get the component to render the module.
     *
     * @param {any} course The course object.
     * @param {any} module The module object.
     * @return {any} The component to use, undefined if not found.
     */
    CoreCourseModuleDelegate.prototype.getMainComponent = function (course, module) {
        var handler = this.enabledHandlers[module.modname];
        if (handler && handler.getMainComponent) {
            var component = handler.getMainComponent(course, module);
            if (component) {
                return component;
            }
        }
    };
    /**
     * Get the data required to display the module in the course contents view.
     *
     * @param {string} modname The name of the module type.
     * @param {any} module The module object.
     * @param {number} courseId The course ID.
     * @param {number} sectionId The section ID.
     * @return {CoreCourseModuleHandlerData} Data to render the module.
     */
    CoreCourseModuleDelegate.prototype.getModuleDataFor = function (modname, module, courseId, sectionId) {
        var _this = this;
        if (typeof this.enabledHandlers[modname] != 'undefined') {
            return this.enabledHandlers[modname].getData(module, courseId, sectionId);
        }
        // Return the default data.
        var defaultData = {
            icon: this.courseProvider.getModuleIconSrc(module.modname),
            title: module.name,
            class: 'core-course-default-handler core-course-module-' + module.modname + '-handler',
            action: function (event, navCtrl, module, courseId, options) {
                event.preventDefault();
                event.stopPropagation();
                navCtrl.push('CoreCourseUnsupportedModulePage', { module: module }, options);
            }
        };
        if (module.url) {
            defaultData.buttons = [{
                    icon: 'open',
                    label: 'core.openinbrowser',
                    action: function (e) {
                        e.preventDefault();
                        e.stopPropagation();
                        _this.sitesProvider.getCurrentSite().openInBrowserWithAutoLoginIfSameSite(module.url);
                    }
                }];
        }
        return defaultData;
    };
    /**
     * Check if a certain module type is disabled in a site.
     *
     * @param {string} modname The name of the module type.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with boolean: whether module is disabled.
     */
    CoreCourseModuleDelegate.prototype.isModuleDisabled = function (modname, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.isModuleDisabledInSite(modname, site);
        });
    };
    /**
     * Check if a certain module type is disabled in a site.
     *
     * @param {string} modname The name of the module type.
     * @param {CoreSite} [site] Site. If not defined, use current site.
     * @return {boolean} Whether module is disabled.
     */
    CoreCourseModuleDelegate.prototype.isModuleDisabledInSite = function (modname, site) {
        if (typeof this.handlers[modname] != 'undefined') {
            site = site || this.sitesProvider.getCurrentSite();
            return this.isFeatureDisabled(this.handlers[modname], site);
        }
        return false;
    };
    CoreCourseModuleDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_1__providers_events__["a" /* CoreEventsProvider */],
            __WEBPACK_IMPORTED_MODULE_4__course__["a" /* CoreCourseProvider */]])
    ], CoreCourseModuleDelegate);
    return CoreCourseModuleDelegate;
}(__WEBPACK_IMPORTED_MODULE_5__classes_delegate__["a" /* CoreDelegate */]));

//# sourceMappingURL=module-delegate.js.map

/***/ }),

/***/ 145:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreEmulatorCaptureHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_mimetype__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__ = __webpack_require__(9);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Helper service with some features to capture media (image, audio, video).
 */
var CoreEmulatorCaptureHelperProvider = /** @class */ (function () {
    function CoreEmulatorCaptureHelperProvider(utils, mimeUtils, modalCtrl) {
        this.utils = utils;
        this.mimeUtils = mimeUtils;
        this.modalCtrl = modalCtrl;
        this.possibleAudioMimeTypes = {
            'audio/webm': 'weba',
            'audio/ogg': 'ogg'
        };
        this.possibleVideoMimeTypes = {
            'video/webm;codecs=vp9': 'webm',
            'video/webm;codecs=vp8': 'webm',
            'video/ogg': 'ogv'
        };
        // Convert the window to "any" type because some of the variables used (like MediaRecorder) aren't in the window spec.
        this.win = window;
    }
    /**
     * Capture media (image, audio, video).
     *
     * @param {string} type Type of media: image, audio, video.
     * @param {any} [options] Optional options.
     * @return {Promise<any>} Promise resolved when captured, rejected if error.
     */
    CoreEmulatorCaptureHelperProvider.prototype.captureMedia = function (type, options) {
        options = options || {};
        try {
            // Build the params to send to the modal.
            var deferred_1 = this.utils.promiseDefer(), params = {
                type: type
            };
            var mimeAndExt = void 0, modal = void 0;
            // Initialize some data based on the type of media to capture.
            if (type == 'video') {
                mimeAndExt = this.getMimeTypeAndExtension(type, options.mimetypes);
                params.mimetype = mimeAndExt.mimetype;
                params.extension = mimeAndExt.extension;
            }
            else if (type == 'audio') {
                mimeAndExt = this.getMimeTypeAndExtension(type, options.mimetypes);
                params.mimetype = mimeAndExt.mimetype;
                params.extension = mimeAndExt.extension;
            }
            else if (type == 'image') {
                if (typeof options.sourceType != 'undefined' && options.sourceType != 1) {
                    return Promise.reject('This source type is not supported in desktop.');
                }
                if (options.cameraDirection == 1) {
                    params.facingMode = 'user';
                }
                if (options.encodingType == 1) {
                    params.mimetype = 'image/png';
                    params.extension = 'png';
                }
                else {
                    params.mimetype = 'image/jpeg';
                    params.extension = 'jpeg';
                }
                if (options.quality >= 0 && options.quality <= 100) {
                    params.quality = options.quality / 100;
                }
                if (options.destinationType == 0) {
                    params.returnDataUrl = true;
                }
            }
            if (options.duration) {
                params.maxTime = options.duration * 1000;
            }
            modal = this.modalCtrl.create('CoreEmulatorCaptureMediaPage', params);
            modal.present();
            modal.onDidDismiss(function (data, role) {
                if (role == 'success') {
                    deferred_1.resolve(data);
                }
                else {
                    deferred_1.reject(data);
                }
            });
            return deferred_1.promise;
        }
        catch (ex) {
            return Promise.reject(ex.toString());
        }
    };
    /**
     * Get the mimetype and extension to capture media.
     *
     * @param {string} type Type of media: image, audio, video.
     * @param {string[]} [mimetypes] List of supported mimetypes. If undefined, all mimetypes supported.
     * @return {{extension: string, mimetype: string}} An object with mimetype and extension to use.
     */
    CoreEmulatorCaptureHelperProvider.prototype.getMimeTypeAndExtension = function (type, mimetypes) {
        var result = {};
        if (mimetypes && mimetypes.length) {
            // Search for a supported mimetype.
            for (var i = 0; i < mimetypes.length; i++) {
                var mimetype = mimetypes[i], matches = mimetype.match(new RegExp('^' + type + '/'));
                if (matches && matches.length && this.win.MediaRecorder.isTypeSupported(mimetype)) {
                    result.mimetype = mimetype;
                    break;
                }
            }
        }
        if (result.mimetype) {
            // Found a supported mimetype in the mimetypes array, get the extension.
            result.extension = this.mimeUtils.getExtension(result.mimetype);
        }
        else if (type == 'video') {
            // No mimetype found, use default extension.
            result.mimetype = this.videoMimeType;
            result.extension = this.possibleVideoMimeTypes[result.mimetype];
        }
        else if (type == 'audio') {
            // No mimetype found, use default extension.
            result.mimetype = this.audioMimeType;
            result.extension = this.possibleAudioMimeTypes[result.mimetype];
        }
        return result;
    };
    /**
     * Init the getUserMedia function, using a deprecated function as fallback if the new one doesn't exist.
     *
     * @return {boolean} Whether the function is supported.
     */
    CoreEmulatorCaptureHelperProvider.prototype.initGetUserMedia = function () {
        var _this = this;
        var nav = navigator;
        // Check if there is a function to get user media.
        if (typeof nav.mediaDevices == 'undefined') {
            nav.mediaDevices = {};
        }
        if (!nav.mediaDevices.getUserMedia) {
            // New function doesn't exist, check if the deprecated function is supported.
            nav.getUserMedia = nav.getUserMedia || nav.webkitGetUserMedia || nav.mozGetUserMedia || nav.msGetUserMedia;
            if (nav.getUserMedia) {
                // Deprecated function exists, support the new function using the deprecated one.
                navigator.mediaDevices.getUserMedia = function (constraints) {
                    var deferred = _this.utils.promiseDefer();
                    nav.getUserMedia(constraints, deferred.resolve, deferred.reject);
                    return deferred.promise;
                };
            }
            else {
                return false;
            }
        }
        return true;
    };
    /**
     * Initialize the mimetypes to use when capturing.
     */
    CoreEmulatorCaptureHelperProvider.prototype.initMimeTypes = function () {
        // Determine video and audio mimetype to use.
        for (var mimeType in this.possibleVideoMimeTypes) {
            if (this.win.MediaRecorder.isTypeSupported(mimeType)) {
                this.videoMimeType = mimeType;
                break;
            }
        }
        for (var mimeType in this.possibleAudioMimeTypes) {
            if (this.win.MediaRecorder.isTypeSupported(mimeType)) {
                this.audioMimeType = mimeType;
                break;
            }
        }
    };
    /**
     * Load the Mocks that need it.
     *
     * @return {Promise<void>} Promise resolved when loaded.
     */
    CoreEmulatorCaptureHelperProvider.prototype.load = function () {
        if (typeof this.win.MediaRecorder != 'undefined' && this.initGetUserMedia()) {
            this.initMimeTypes();
        }
        return Promise.resolve();
    };
    CoreEmulatorCaptureHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_mimetype__["a" /* CoreMimetypeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["j" /* ModalController */]])
    ], CoreEmulatorCaptureHelperProvider);
    return CoreEmulatorCaptureHelperProvider;
}());

//# sourceMappingURL=capture-helper.js.map

/***/ }),

/***/ 146:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 153:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CorePipesModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__bytes_to_size__ = __webpack_require__(954);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__create_links__ = __webpack_require__(955);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__date_day_or_time__ = __webpack_require__(956);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__duration__ = __webpack_require__(957);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__format_date__ = __webpack_require__(958);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__no_tags__ = __webpack_require__(959);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__seconds_to_hms__ = __webpack_require__(960);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__time_ago__ = __webpack_require__(961);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__to_locale_string__ = __webpack_require__(962);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};










var CorePipesModule = /** @class */ (function () {
    function CorePipesModule() {
    }
    CorePipesModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_1__bytes_to_size__["a" /* CoreBytesToSizePipe */],
                __WEBPACK_IMPORTED_MODULE_2__create_links__["a" /* CoreCreateLinksPipe */],
                __WEBPACK_IMPORTED_MODULE_3__date_day_or_time__["a" /* CoreDateDayOrTimePipe */],
                __WEBPACK_IMPORTED_MODULE_4__duration__["a" /* CoreDurationPipe */],
                __WEBPACK_IMPORTED_MODULE_5__format_date__["a" /* CoreFormatDatePipe */],
                __WEBPACK_IMPORTED_MODULE_6__no_tags__["a" /* CoreNoTagsPipe */],
                __WEBPACK_IMPORTED_MODULE_7__seconds_to_hms__["a" /* CoreSecondsToHMSPipe */],
                __WEBPACK_IMPORTED_MODULE_8__time_ago__["a" /* CoreTimeAgoPipe */],
                __WEBPACK_IMPORTED_MODULE_9__to_locale_string__["a" /* CoreToLocaleStringPipe */]
            ],
            imports: [],
            exports: [
                __WEBPACK_IMPORTED_MODULE_1__bytes_to_size__["a" /* CoreBytesToSizePipe */],
                __WEBPACK_IMPORTED_MODULE_2__create_links__["a" /* CoreCreateLinksPipe */],
                __WEBPACK_IMPORTED_MODULE_3__date_day_or_time__["a" /* CoreDateDayOrTimePipe */],
                __WEBPACK_IMPORTED_MODULE_4__duration__["a" /* CoreDurationPipe */],
                __WEBPACK_IMPORTED_MODULE_5__format_date__["a" /* CoreFormatDatePipe */],
                __WEBPACK_IMPORTED_MODULE_6__no_tags__["a" /* CoreNoTagsPipe */],
                __WEBPACK_IMPORTED_MODULE_7__seconds_to_hms__["a" /* CoreSecondsToHMSPipe */],
                __WEBPACK_IMPORTED_MODULE_8__time_ago__["a" /* CoreTimeAgoPipe */],
                __WEBPACK_IMPORTED_MODULE_9__to_locale_string__["a" /* CoreToLocaleStringPipe */]
            ]
        })
    ], CorePipesModule);
    return CorePipesModule;
}());

//# sourceMappingURL=pipes.module.js.map

/***/ }),

/***/ 154:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseOptionsDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__classes_delegate__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_events__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_sites__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__courses_providers_courses__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__course__ = __webpack_require__(37);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








/**
 * Service to interact with plugins to be shown in each course (participants, learning plans, ...).
 */
var CoreCourseOptionsDelegate = /** @class */ (function (_super) {
    __extends(CoreCourseOptionsDelegate, _super);
    function CoreCourseOptionsDelegate(loggerProvider, sitesProvider, utils, eventsProvider, coursesProvider) {
        var _this = _super.call(this, 'CoreCourseOptionsDelegate', loggerProvider, sitesProvider, eventsProvider) || this;
        _this.sitesProvider = sitesProvider;
        _this.utils = utils;
        _this.eventsProvider = eventsProvider;
        _this.coursesProvider = coursesProvider;
        _this.handlers = {}; // All registered handlers.
        _this.enabledHandlers = {}; // Handlers enabled for the current site.
        _this.loaded = {};
        _this.lastUpdateHandlersForCoursesStart = {};
        _this.coursesHandlers = {};
        _this.featurePrefix = '$mmCoursesDelegate_';
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */].LOGOUT, function () {
            _this.clearCoursesHandlers();
        });
        return _this;
    }
    /**
     * Check if handlers are loaded for a certain course.
     *
     * @param {number} courseId The course ID to check.
     * @return {boolean} True if handlers are loaded, false otherwise.
     */
    CoreCourseOptionsDelegate.prototype.areHandlersLoaded = function (courseId) {
        return !!this.loaded[courseId];
    };
    /**
     * Clear all course options handlers.
     *
     * @param {number} [courseId] The course ID. If not defined, all handlers will be cleared.
     */
    CoreCourseOptionsDelegate.prototype.clearCoursesHandlers = function (courseId) {
        if (courseId) {
            this.loaded[courseId] = false;
            delete this.coursesHandlers[courseId];
        }
        else {
            this.loaded = {};
            this.coursesHandlers = {};
        }
    };
    /**
     * Clear all courses handlers and invalidate its options.
     *
     * @param {number} [courseId] The course ID. If not defined, all handlers will be cleared.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseOptionsDelegate.prototype.clearAndInvalidateCoursesOptions = function (courseId) {
        var promises = [];
        this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_6__courses_providers_courses__["a" /* CoreCoursesProvider */].EVENT_MY_COURSES_REFRESHED);
        // Invalidate course enabled data for the handlers that are enabled at site level.
        if (courseId) {
            // Invalidate only options for this course.
            promises.push(this.coursesProvider.invalidateCoursesAdminAndNavOptions([courseId]));
            promises.push(this.invalidateCourseHandlers(courseId));
        }
        else {
            // Invalidate all options.
            promises.push(this.coursesProvider.invalidateUserNavigationOptions());
            promises.push(this.coursesProvider.invalidateUserAdministrationOptions());
            for (var cId in this.coursesHandlers) {
                promises.push(this.invalidateCourseHandlers(parseInt(cId, 10)));
            }
        }
        this.clearCoursesHandlers(courseId);
        return Promise.all(promises);
    };
    /**
     * Get the handlers for a course using a certain access type.
     *
     * @param {number} courseId The course ID.
     * @param {boolean} refresh True if it should refresh the list.
     * @param {any} accessData Access type and data. Default, guest, ...
     * @param {any} [navOptions] Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.
     * @param {any} [admOptions] Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.
     * @return {Promise<CoreCourseOptionsHandler[]>} Promise resolved with array of handlers.
     */
    CoreCourseOptionsDelegate.prototype.getHandlersForAccess = function (courseId, refresh, accessData, navOptions, admOptions) {
        var _this = this;
        // If the handlers aren't loaded, do not refresh.
        if (!this.loaded[courseId]) {
            refresh = false;
        }
        if (refresh || !this.coursesHandlers[courseId] || this.coursesHandlers[courseId].access.type != accessData.type) {
            if (!this.coursesHandlers[courseId]) {
                this.coursesHandlers[courseId] = {};
            }
            this.coursesHandlers[courseId].access = accessData;
            this.coursesHandlers[courseId].navOptions = navOptions;
            this.coursesHandlers[courseId].admOptions = admOptions;
            this.coursesHandlers[courseId].deferred = this.utils.promiseDefer();
            this.updateHandlersForCourse(courseId, accessData, navOptions, admOptions);
        }
        return this.coursesHandlers[courseId].deferred.promise.then(function () {
            return _this.coursesHandlers[courseId].enabledHandlers;
        });
    };
    /**
     * Get the list of handlers that should be displayed for a course.
     * This function should be called only when the handlers need to be displayed, since it can call several WebServices.
     *
     * @param {any} course The course object.
     * @param {boolean} [refresh] True if it should refresh the list.
     * @param {boolean} [isGuest] Whether it's guest.
     * @param {any} [navOptions] Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.
     * @param {any} [admOptions] Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.
     * @return {Promise<CoreCourseOptionsHandlerToDisplay[]>} Promise resolved with array of handlers.
     */
    CoreCourseOptionsDelegate.prototype.getHandlersToDisplay = function (course, refresh, isGuest, navOptions, admOptions) {
        var _this = this;
        course.id = parseInt(course.id, 10);
        var accessData = {
            type: isGuest ? __WEBPACK_IMPORTED_MODULE_7__course__["a" /* CoreCourseProvider */].ACCESS_GUEST : __WEBPACK_IMPORTED_MODULE_7__course__["a" /* CoreCourseProvider */].ACCESS_DEFAULT
        };
        if (navOptions) {
            course.navOptions = navOptions;
        }
        if (admOptions) {
            course.admOptions = admOptions;
        }
        return this.loadCourseOptions(course, refresh).then(function () {
            // Call getHandlersForAccess to make sure the handlers have been loaded.
            return _this.getHandlersForAccess(course.id, refresh, accessData, course.navOptions, course.admOptions);
        }).then(function () {
            var handlersToDisplay = [];
            _this.coursesHandlers[course.id].enabledHandlers.forEach(function (handler) {
                handlersToDisplay.push({
                    data: handler.getDisplayData(course),
                    priority: handler.priority,
                    prefetch: handler.prefetch
                });
            });
            // Sort them by priority.
            handlersToDisplay.sort(function (a, b) {
                return b.priority - a.priority;
            });
            return handlersToDisplay;
        });
    };
    /**
     * Check if a course has any handler enabled for default access, using course object.
     *
     * @param {any} course The course object.
     * @param {boolean} [refresh] True if it should refresh the list.
     * @return {Promise<boolean>} Promise resolved with boolean: true if it has handlers, false otherwise.
     */
    CoreCourseOptionsDelegate.prototype.hasHandlersForCourse = function (course, refresh) {
        var _this = this;
        // Load course options if missing.
        return this.loadCourseOptions(course, refresh).then(function () {
            return _this.hasHandlersForDefault(course.id, refresh, course.navOptions, course.admOptions);
        });
    };
    /**
     * Check if a course has any handler enabled for default access.
     *
     * @param {number} courseId The course ID.
     * @param {boolean} [refresh] True if it should refresh the list.
     * @param {any} [navOptions] Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.
     * @param {any} [admOptions] Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.
     * @return {Promise<boolean>} Promise resolved with boolean: true if it has handlers, false otherwise.
     */
    CoreCourseOptionsDelegate.prototype.hasHandlersForDefault = function (courseId, refresh, navOptions, admOptions) {
        // Default access.
        var accessData = {
            type: __WEBPACK_IMPORTED_MODULE_7__course__["a" /* CoreCourseProvider */].ACCESS_DEFAULT
        };
        return this.getHandlersForAccess(courseId, refresh, accessData, navOptions, admOptions).then(function (handlers) {
            return !!(handlers && handlers.length);
        });
    };
    /**
     * Check if a course has any handler enabled for guest access.
     *
     * @param {number} courseId The course ID.
     * @param {boolean} [refresh] True if it should refresh the list.
     * @param {any} [navOptions] Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.
     * @param {any} [admOptions] Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.
     * @return {Promise<boolean>} Promise resolved with boolean: true if it has handlers, false otherwise.
     */
    CoreCourseOptionsDelegate.prototype.hasHandlersForGuest = function (courseId, refresh, navOptions, admOptions) {
        // Guest access.
        var accessData = {
            type: __WEBPACK_IMPORTED_MODULE_7__course__["a" /* CoreCourseProvider */].ACCESS_GUEST
        };
        return this.getHandlersForAccess(courseId, refresh, accessData, navOptions, admOptions).then(function (handlers) {
            return !!(handlers && handlers.length);
        });
    };
    /**
     * Invalidate the data to be able to determine if handlers are enabled for a certain course.
     *
     * @param {number} courseId Course ID.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseOptionsDelegate.prototype.invalidateCourseHandlers = function (courseId) {
        var promises = [], courseData = this.coursesHandlers[courseId];
        if (!courseData) {
            return Promise.resolve();
        }
        courseData.enabledHandlers.forEach(function (handler) {
            if (handler && handler.invalidateEnabledForCourse) {
                promises.push(Promise.resolve(handler.invalidateEnabledForCourse(courseId, courseData.navOptions, courseData.admOptions)));
            }
        });
        return this.utils.allPromises(promises);
    };
    /**
     * Check if a time belongs to the last update handlers for course call.
     * This is to handle the cases where updateHandlersForCourse don't finish in the same order as they're called.
     *
     * @param {number} courseId Course ID.
     * @param {number} time Time to check.
     * @return {boolean} Whether it's the last call.
     */
    CoreCourseOptionsDelegate.prototype.isLastUpdateCourseCall = function (courseId, time) {
        if (!this.lastUpdateHandlersForCoursesStart[courseId]) {
            return true;
        }
        return time == this.lastUpdateHandlersForCoursesStart[courseId];
    };
    /**
     * Load course options if missing.
     *
     * @param {any} course The course object.
     * @param {boolean} [refresh] True if it should refresh the list.
     * @return {Promise<void>} Promise resolved when done.
     */
    CoreCourseOptionsDelegate.prototype.loadCourseOptions = function (course, refresh) {
        if (typeof course.navOptions == 'undefined' || typeof course.admOptions == 'undefined' || refresh) {
            return this.coursesProvider.getCoursesAdminAndNavOptions([course.id]).then(function (options) {
                course.navOptions = options.navOptions[course.id];
                course.admOptions = options.admOptions[course.id];
            });
        }
        else {
            return Promise.resolve();
        }
    };
    /**
     * Update handlers for each course.
     *
     * @param {string} [siteId] Site ID.
     */
    CoreCourseOptionsDelegate.prototype.updateData = function (siteId) {
        if (this.sitesProvider.getCurrentSiteId() === siteId) {
            // Update handlers for all courses.
            for (var courseId in this.coursesHandlers) {
                var handler = this.coursesHandlers[courseId];
                this.updateHandlersForCourse(parseInt(courseId, 10), handler.access, handler.navOptions, handler.admOptions);
            }
        }
    };
    /**
     * Update the handlers for a certain course.
     *
     * @param {number} courseId The course ID.
     * @param {any} accessData Access type and data. Default, guest, ...
     * @param {any} [navOptions] Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.
     * @param {any} [admOptions] Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.
     * @return {Promise<any>} Resolved when updated.
     */
    CoreCourseOptionsDelegate.prototype.updateHandlersForCourse = function (courseId, accessData, navOptions, admOptions) {
        var _this = this;
        var promises = [], enabledForCourse = [], siteId = this.sitesProvider.getCurrentSiteId(), now = Date.now();
        this.lastUpdateHandlersForCoursesStart[courseId] = now;
        var _loop_1 = function (name_1) {
            var handler = this_1.enabledHandlers[name_1];
            // Checks if the handler is enabled for the user.
            promises.push(Promise.resolve(handler.isEnabledForCourse(courseId, accessData, navOptions, admOptions))
                .then(function (enabled) {
                if (enabled) {
                    enabledForCourse.push(handler);
                }
                else {
                    return Promise.reject(null);
                }
            }).catch(function () {
                // Nothing to do here, it is not enabled for this user.
            }));
        };
        var this_1 = this;
        for (var name_1 in this.enabledHandlers) {
            _loop_1(name_1);
        }
        return Promise.all(promises).then(function () {
            return true;
        }).catch(function () {
            // Never fails.
            return true;
        }).finally(function () {
            // Verify that this call is the last one that was started.
            // Check that site hasn't changed since the check started.
            if (_this.isLastUpdateCourseCall(courseId, now) && _this.sitesProvider.getCurrentSiteId() === siteId) {
                // Update the coursesHandlers array with the new enabled addons.
                _this.coursesHandlers[courseId].enabledHandlers = enabledForCourse;
                _this.loaded[courseId] = true;
                // Resolve the promise.
                _this.coursesHandlers[courseId].deferred.resolve();
            }
        });
    };
    CoreCourseOptionsDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_6__courses_providers_courses__["a" /* CoreCoursesProvider */]])
    ], CoreCourseOptionsDelegate);
    return CoreCourseOptionsDelegate;
}(__WEBPACK_IMPORTED_MODULE_1__classes_delegate__["a" /* CoreDelegate */]));

//# sourceMappingURL=options-delegate.js.map

/***/ }),

/***/ 155:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonFilesProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_sites__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_mimetype__ = __webpack_require__(38);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Service to handle my files and site files.
 */
var AddonFilesProvider = /** @class */ (function () {
    function AddonFilesProvider(sitesProvider, mimeUtils) {
        this.sitesProvider = sitesProvider;
        this.mimeUtils = mimeUtils;
        this.ROOT_CACHE_KEY = 'mmaFiles:';
    }
    /**
     * Check if core_user_get_private_files_info WS call is available.
     *
     * @return {boolean} Whether the WS is available, false otherwise.
     */
    AddonFilesProvider.prototype.canGetPrivateFilesInfo = function () {
        return this.sitesProvider.getCurrentSite().wsAvailable('core_user_get_private_files_info');
    };
    /**
     * Check if user can view his private files.
     *
     * @return {boolean} Whether the user can view his private files.
     */
    AddonFilesProvider.prototype.canViewPrivateFiles = function () {
        return this.sitesProvider.getCurrentSite().canAccessMyFiles() && !this.isPrivateFilesDisabledInSite();
    };
    /**
     * Check if user can view site files.
     *
     * @return {boolean} Whether the user can view site files.
     */
    AddonFilesProvider.prototype.canViewSiteFiles = function () {
        return !this.isSiteFilesDisabledInSite();
    };
    /**
     * Check if user can upload private files.
     *
     * @return {boolean} Whether the user can upload private files.
     */
    AddonFilesProvider.prototype.canUploadFiles = function () {
        var currentSite = this.sitesProvider.getCurrentSite();
        return currentSite.canAccessMyFiles() && currentSite.canUploadFiles() && !this.isUploadDisabledInSite();
    };
    /**
     * Get the list of files.
     *
     * @param {any} params A list of parameters accepted by the Web service.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved with the files.
     */
    AddonFilesProvider.prototype.getFiles = function (params, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var preSets = {
                cacheKey: _this.getFilesListCacheKey(params)
            };
            return site.read('core_files_get_files', params, preSets);
        }).then(function (result) {
            var entries = [];
            if (result.files) {
                result.files.forEach(function (entry) {
                    if (entry.isdir) {
                        // Create a "link" to load the folder.
                        entry.link = {
                            contextid: entry.contextid || '',
                            component: entry.component || '',
                            filearea: entry.filearea || '',
                            itemid: entry.itemid || 0,
                            filepath: entry.filepath || '',
                            filename: entry.filename || ''
                        };
                        if (entry.component) {
                            // Delete unused elements that may break the request.
                            entry.link.filename = '';
                        }
                    }
                    if (entry.isdir) {
                        entry.imgPath = _this.mimeUtils.getFolderIcon();
                    }
                    else {
                        entry.imgPath = _this.mimeUtils.getFileIcon(entry.filename);
                    }
                    entries.push(entry);
                });
            }
            return entries;
        });
    };
    /**
     * Get cache key for file list WS calls.
     *
     * @param {any} params Params of the WS.
     * @return {string} Cache key.
     */
    AddonFilesProvider.prototype.getFilesListCacheKey = function (params) {
        var root = !params.component ? 'site' : 'my';
        return this.ROOT_CACHE_KEY + 'list:' + root + ':' + params.contextid + ':' + params.filepath;
    };
    /**
     * Get the private files of the current user.
     *
     * @return {Promise<any[]>} Promise resolved with the files.
     */
    AddonFilesProvider.prototype.getPrivateFiles = function () {
        return this.getFiles(this.getPrivateFilesRootParams());
    };
    /**
     * Get params to get root private files directory.
     *
     * @return {any} Params.
     */
    AddonFilesProvider.prototype.getPrivateFilesRootParams = function () {
        return {
            contextid: -1,
            component: 'user',
            filearea: 'private',
            contextlevel: 'user',
            instanceid: this.sitesProvider.getCurrentSite().getUserId(),
            itemid: 0,
            filepath: '',
            filename: ''
        };
    };
    /**
     * Get private files info.
     *
     * @param {number} [userId] User ID. If not defined, current user in the site.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any>} Promise resolved with the info.
     */
    AddonFilesProvider.prototype.getPrivateFilesInfo = function (userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            var params = {
                userid: userId
            }, preSets = {
                cacheKey: _this.getPrivateFilesInfoCacheKey(userId)
            };
            return site.read('core_user_get_private_files_info', params, preSets);
        });
    };
    /**
     * Get the cache key for private files info WS calls.
     *
     * @param {number} userId User ID.
     * @return {string} Cache key.
     */
    AddonFilesProvider.prototype.getPrivateFilesInfoCacheKey = function (userId) {
        return this.getPrivateFilesInfoCommonCacheKey() + ':' + userId;
    };
    /**
     * Get the common part of the cache keys for private files info WS calls.
     *
     * @return {string} Cache key.
     */
    AddonFilesProvider.prototype.getPrivateFilesInfoCommonCacheKey = function () {
        return this.ROOT_CACHE_KEY + 'privateInfo';
    };
    /**
     * Get the site files.
     *
     * @return {Promise<any[]>} Promise resolved with the files.
     */
    AddonFilesProvider.prototype.getSiteFiles = function () {
        return this.getFiles(this.getSiteFilesRootParams());
    };
    /**
     * Get params to get root site files directory.
     *
     * @return {any} Params.
     */
    AddonFilesProvider.prototype.getSiteFilesRootParams = function () {
        return {
            contextid: 0,
            component: '',
            filearea: '',
            itemid: 0,
            filepath: '',
            filename: ''
        };
    };
    /**
     * Invalidates list of files in a certain directory.
     *
     * @param {string} root Root of the directory ('my' for private files, 'site' for site files).
     * @param {string} path Path to the directory.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonFilesProvider.prototype.invalidateDirectory = function (root, path, siteId) {
        var _this = this;
        var params;
        if (!path) {
            if (root === 'site') {
                params = this.getSiteFilesRootParams();
            }
            else if (root === 'my') {
                params = this.getPrivateFilesRootParams();
            }
        }
        else {
            params = path;
        }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getFilesListCacheKey(params));
        });
    };
    /**
     * Invalidates private files info for all users.
     *
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonFilesProvider.prototype.invalidatePrivateFilesInfo = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getPrivateFilesInfoCommonCacheKey());
        });
    };
    /**
     * Invalidates private files info for a certain user.
     *
     * @param {number} [userId] User ID. If not defined, current user in the site.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonFilesProvider.prototype.invalidatePrivateFilesInfoForUser = function (userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(_this.getPrivateFilesInfoCacheKey(userId));
        });
    };
    /**
     * Check if Files is disabled in a certain site.
     *
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<boolean>} Promise resolved with true if disabled, rejected or resolved with false otherwise.
     */
    AddonFilesProvider.prototype.isDisabled = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.isDisabledInSite(site);
        });
    };
    /**
     * Check if Files is disabled in a certain site.
     *
     * @param {CoreSite} [site] Site. If not defined, use current site.
     * @return {boolean} Whether it's disabled.
     */
    AddonFilesProvider.prototype.isDisabledInSite = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.isFeatureDisabled('$mmSideMenuDelegate_mmaFiles');
    };
    /**
     * Return whether or not the plugin is enabled.
     *
     * @return {boolean} True if enabled, false otherwise.
     */
    AddonFilesProvider.prototype.isPluginEnabled = function () {
        return this.canViewPrivateFiles() || this.canViewSiteFiles() || this.canUploadFiles();
    };
    /**
     * Check if private files is disabled in a certain site.
     *
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<boolean>} Promise resolved with true if disabled, rejected or resolved with false otherwise.
     */
    AddonFilesProvider.prototype.isPrivateFilesDisabled = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.isPrivateFilesDisabledInSite(site);
        });
    };
    /**
     * Check if private files is disabled in a certain site.
     *
     * @param {CoreSite} [site] Site. If not defined, use current site.
     * @return {boolean} Whether it's disabled.
     */
    AddonFilesProvider.prototype.isPrivateFilesDisabledInSite = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.isFeatureDisabled('files_privatefiles');
    };
    /**
     * Check if site files is disabled in a certain site.
     *
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<boolean>} Promise resolved with true if disabled, rejected or resolved with false otherwise.
     */
    AddonFilesProvider.prototype.isSiteFilesDisabled = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.isSiteFilesDisabledInSite(site);
        });
    };
    /**
     * Check if site files is disabled in a certain site.
     *
     * @param {CoreSite} [site] Site. If not defined, use current site.
     * @return {boolean} Whether it's disabled.
     */
    AddonFilesProvider.prototype.isSiteFilesDisabledInSite = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.isFeatureDisabled('files_sitefiles');
    };
    /**
     * Check if upload files is disabled in a certain site.
     *
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<boolean>} Promise resolved with true if disabled, rejected or resolved with false otherwise.
     */
    AddonFilesProvider.prototype.isUploadDisabled = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.isUploadDisabledInSite(site);
        });
    };
    /**
     * Check if upload files is disabled in a certain site.
     *
     * @param {CoreSite} [site] Site. If not defined, use current site.
     * @return {boolean} Whether it's disabled.
     */
    AddonFilesProvider.prototype.isUploadDisabledInSite = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.isFeatureDisabled('files_upload');
    };
    /**
     * Move a file from draft area to private files.
     *
     * @param {number} draftId The draft area ID of the file.
     * @param {string} [siteid] ID of the site. If not defined, use current site.
     * @return {Promise<any>} Promise resolved in success, rejected otherwise.
     */
    AddonFilesProvider.prototype.moveFromDraftToPrivate = function (draftId, siteId) {
        var params = {
            draftid: draftId
        }, preSets = {
            responseExpected: false
        };
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.write('core_user_add_user_private_files', params, preSets);
        });
    };
    /**
     * Check the Moodle version in order to check if upload files is working.
     *
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<boolean>} Promise resolved with true if WS is working, false otherwise.
     */
    AddonFilesProvider.prototype.versionCanUploadFiles = function (siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            // Upload private files doesn't work for Moodle 3.1.0 due to a bug.
            return site.isVersionGreaterEqualThan('3.1.1');
        });
    };
    AddonFilesProvider.PRIVATE_FILES_COMPONENT = 'mmaFilesMy';
    AddonFilesProvider.SITE_FILES_COMPONENT = 'mmaFilesSite';
    AddonFilesProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_mimetype__["a" /* CoreMimetypeUtilsProvider */]])
    ], AddonFilesProvider);
    return AddonFilesProvider;
}());

//# sourceMappingURL=files.js.map

/***/ }),

/***/ 156:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCoursesMyOverviewProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_sites__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_moment__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_moment__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Service that provides some features regarding course overview.
 */
var CoreCoursesMyOverviewProvider = /** @class */ (function () {
    function CoreCoursesMyOverviewProvider(sitesProvider) {
        this.sitesProvider = sitesProvider;
        this.ROOT_CACHE_KEY = 'myoverview:';
    }
    CoreCoursesMyOverviewProvider_1 = CoreCoursesMyOverviewProvider;
    /**
     * Get calendar action events for the given course.
     *
     * @param {number} courseId Only events in this course.
     * @param {number} [afterEventId] The last seen event id.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<{events: any[], canLoadMore: number}>} Promise resolved when the info is retrieved.
     */
    CoreCoursesMyOverviewProvider.prototype.getActionEventsByCourse = function (courseId, afterEventId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var time = __WEBPACK_IMPORTED_MODULE_2_moment__().subtract(14, 'days').unix(), // Check two weeks ago.
            data = {
                timesortfrom: time,
                courseid: courseId,
                limitnum: CoreCoursesMyOverviewProvider_1.EVENTS_LIMIT_PER_COURSE
            }, preSets = {
                cacheKey: _this.getActionEventsByCourseCacheKey(courseId)
            };
            if (afterEventId) {
                data.aftereventid = afterEventId;
            }
            return site.read('core_calendar_get_action_events_by_course', data, preSets).then(function (courseEvents) {
                if (courseEvents && courseEvents.events) {
                    return _this.treatCourseEvents(courseEvents, time);
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get cache key for get calendar action events for the given course value WS call.
     *
     * @param {number} courseId Only events in this course.
     * @return {string} Cache key.
     */
    CoreCoursesMyOverviewProvider.prototype.getActionEventsByCourseCacheKey = function (courseId) {
        return this.getActionEventsByCoursesCacheKey() + ':' + courseId;
    };
    /**
     * Get calendar action events for a given list of courses.
     *
     * @param {number[]} courseIds Course IDs.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<{[s: string]: {events: any[], canLoadMore: number}}>} Promise resolved when the info is retrieved.
     */
    CoreCoursesMyOverviewProvider.prototype.getActionEventsByCourses = function (courseIds, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var time = __WEBPACK_IMPORTED_MODULE_2_moment__().subtract(14, 'days').unix(), // Check two weeks ago.
            data = {
                timesortfrom: time,
                courseids: courseIds,
                limitnum: CoreCoursesMyOverviewProvider_1.EVENTS_LIMIT_PER_COURSE
            }, preSets = {
                cacheKey: _this.getActionEventsByCoursesCacheKey()
            };
            return site.read('core_calendar_get_action_events_by_courses', data, preSets).then(function (events) {
                if (events && events.groupedbycourse) {
                    var courseEvents_1 = {};
                    events.groupedbycourse.forEach(function (course) {
                        courseEvents_1[course.courseid] = _this.treatCourseEvents(course, time);
                    });
                    return courseEvents_1;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get cache key for get calendar action events for a given list of courses value WS call.
     *
     * @return {string} Cache key.
     */
    CoreCoursesMyOverviewProvider.prototype.getActionEventsByCoursesCacheKey = function () {
        return this.ROOT_CACHE_KEY + 'bycourse';
    };
    /**
     * Get calendar action events based on the timesort value.
     *
     * @param {number} [afterEventId] The last seen event id.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<{events: any[], canLoadMore: number}>} Promise resolved when the info is retrieved.
     */
    CoreCoursesMyOverviewProvider.prototype.getActionEventsByTimesort = function (afterEventId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var time = __WEBPACK_IMPORTED_MODULE_2_moment__().subtract(14, 'days').unix(), // Check two weeks ago.
            data = {
                timesortfrom: time,
                limitnum: CoreCoursesMyOverviewProvider_1.EVENTS_LIMIT
            }, preSets = {
                cacheKey: _this.getActionEventsByTimesortCacheKey(afterEventId, data.limitnum),
                getCacheUsingCacheKey: true,
                uniqueCacheKey: true
            };
            if (afterEventId) {
                data.aftereventid = afterEventId;
            }
            return site.read('core_calendar_get_action_events_by_timesort', data, preSets).then(function (events) {
                if (events && events.events) {
                    var canLoadMore = events.events.length >= data.limitnum ? events.lastid : undefined;
                    // Filter events by time in case it uses cache.
                    events = events.events.filter(function (element) {
                        return element.timesort >= time;
                    });
                    return {
                        events: events,
                        canLoadMore: canLoadMore
                    };
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get prefix cache key for calendar action events based on the timesort value WS calls.
     *
     * @return {string} Cache key.
     */
    CoreCoursesMyOverviewProvider.prototype.getActionEventsByTimesortPrefixCacheKey = function () {
        return this.ROOT_CACHE_KEY + 'bytimesort:';
    };
    /**
     * Get cache key for get calendar action events based on the timesort value WS call.
     *
     * @param {number} [afterEventId] The last seen event id.
     * @param {number} [limit] Limit num of the call.
     * @return {string} Cache key.
     */
    CoreCoursesMyOverviewProvider.prototype.getActionEventsByTimesortCacheKey = function (afterEventId, limit) {
        afterEventId = afterEventId || 0;
        limit = limit || 0;
        return this.getActionEventsByTimesortPrefixCacheKey() + afterEventId + ':' + limit;
    };
    /**
     * Invalidates get calendar action events for a given list of courses WS call.
     *
     * @param {string} [siteId] Site ID to invalidate. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesMyOverviewProvider.prototype.invalidateActionEventsByCourses = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getActionEventsByCoursesCacheKey());
        });
    };
    /**
     * Invalidates get calendar action events based on the timesort value WS call.
     *
     * @param {string} [siteId] Site ID to invalidate. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesMyOverviewProvider.prototype.invalidateActionEventsByTimesort = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getActionEventsByTimesortPrefixCacheKey());
        });
    };
    /**
     * Returns whether or not My Overview is available for a certain site.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with true if available, resolved with false or rejected otherwise.
     */
    CoreCoursesMyOverviewProvider.prototype.isAvailable = function (siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.wsAvailable('core_calendar_get_action_events_by_courses');
        });
    };
    /**
     * Check if My Overview is disabled in a certain site.
     *
     * @param {CoreSite} [site] Site. If not defined, use current site.
     * @return {boolean} Whether it's disabled.
     */
    CoreCoursesMyOverviewProvider.prototype.isDisabledInSite = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.isFeatureDisabled('$mmSideMenuDelegate_mmaMyOverview');
    };
    /**
     * Check if My Overview is available and not disabled.
     *
     * @return {Promise<boolean>} Promise resolved with true if enabled, resolved with false otherwise.
     */
    CoreCoursesMyOverviewProvider.prototype.isEnabled = function () {
        if (!this.isDisabledInSite()) {
            return this.isAvailable().catch(function () {
                return false;
            });
        }
        return Promise.resolve(false);
    };
    /**
     * Handles course events, filtering and treating if more can be loaded.
     *
     * @param {any} course Object containing response course events info.
     * @param {number} timeFrom Current time to filter events from.
     * @return {{events: any[], canLoadMore: number}} Object with course events and last loaded event id if more can be loaded.
     */
    CoreCoursesMyOverviewProvider.prototype.treatCourseEvents = function (course, timeFrom) {
        var canLoadMore = course.events.length >= CoreCoursesMyOverviewProvider_1.EVENTS_LIMIT_PER_COURSE ? course.lastid : undefined;
        // Filter events by time in case it uses cache.
        course.events = course.events.filter(function (element) {
            return element.timesort >= timeFrom;
        });
        return {
            events: course.events,
            canLoadMore: canLoadMore
        };
    };
    CoreCoursesMyOverviewProvider.EVENTS_LIMIT = 20;
    CoreCoursesMyOverviewProvider.EVENTS_LIMIT_PER_COURSE = 10;
    CoreCoursesMyOverviewProvider = CoreCoursesMyOverviewProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_sites__["a" /* CoreSitesProvider */]])
    ], CoreCoursesMyOverviewProvider);
    return CoreCoursesMyOverviewProvider;
    var CoreCoursesMyOverviewProvider_1;
}());

//# sourceMappingURL=my-overview.js.map

/***/ }),

/***/ 18:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreDomUtilsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__text__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__app__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__config__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__url__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_constants__ = __webpack_require__(26);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








/*
 * "Utils" service with helper functions for UI, DOM elements and HTML code.
 */
var CoreDomUtilsProvider = /** @class */ (function () {
    function CoreDomUtilsProvider(translate, loadingCtrl, toastCtrl, alertCtrl, textUtils, appProvider, platform, configProvider, urlUtils, modalCtrl) {
        this.translate = translate;
        this.loadingCtrl = loadingCtrl;
        this.toastCtrl = toastCtrl;
        this.alertCtrl = alertCtrl;
        this.textUtils = textUtils;
        this.appProvider = appProvider;
        this.platform = platform;
        this.configProvider = configProvider;
        this.urlUtils = urlUtils;
        this.modalCtrl = modalCtrl;
        // List of input types that support keyboard.
        this.INPUT_SUPPORT_KEYBOARD = ['date', 'datetime', 'datetime-local', 'email', 'month', 'number', 'password',
            'search', 'tel', 'text', 'time', 'url', 'week'];
        this.element = document.createElement('div'); // Fake element to use in some functions, to prevent creating it each time.
    }
    /**
     * Wraps a message with core-format-text if the message contains HTML tags.
     * @todo Finish the adaptation
     *
     * @param {string} message Message to wrap.
     * @return {string} Result message.
     */
    CoreDomUtilsProvider.prototype.addFormatTextIfNeeded = function (message) {
        // @todo
        if (this.textUtils.hasHTMLTags(message)) {
            return '<core-format-text watch="true">' + message + '</core-format-text>';
        }
        return message;
    };
    /**
     * Equivalent to element.closest(). If the browser doesn't support element.closest, it will
     * traverse the parents to achieve the same functionality.
     * Returns the closest ancestor of the current element (or the current element itself) which matches the selector.
     *
     * @param {HTMLElement} element DOM Element.
     * @param {string} selector Selector to search.
     * @return {Element} Closest ancestor.
     */
    CoreDomUtilsProvider.prototype.closest = function (element, selector) {
        var _this = this;
        // Try to use closest if the browser supports it.
        if (typeof element.closest == 'function') {
            return element.closest(selector);
        }
        if (!this.matchesFn) {
            // Find the matches function supported by the browser.
            ['matches', 'webkitMatchesSelector', 'mozMatchesSelector', 'msMatchesSelector', 'oMatchesSelector'].some(function (fn) {
                if (typeof document.body[fn] == 'function') {
                    _this.matchesFn = fn;
                    return true;
                }
                return false;
            });
            if (!this.matchesFn) {
                return;
            }
        }
        // Traverse parents.
        while (element) {
            if (element[this.matchesFn](selector)) {
                return element;
            }
            element = element.parentElement;
        }
    };
    /**
     * If the download size is higher than a certain threshold shows a confirm dialog.
     *
     * @param {any} size Object containing size to download and a boolean to indicate if its totally or partialy calculated.
     * @param {string} [message] Code of the message to show. Default: 'core.course.confirmdownload'.
     * @param {string} [unknownMessage] ID of the message to show if size is unknown.
     * @param {number} [wifiThreshold] Threshold to show confirm in WiFi connection. Default: CoreWifiDownloadThreshold.
     * @param {number} [limitedThreshold] Threshold to show confirm in limited connection. Default: CoreDownloadThreshold.
     * @param {boolean} [alwaysConfirm] True to show a confirm even if the size isn't high, false otherwise.
     * @return {Promise<void>} Promise resolved when the user confirms or if no confirm needed.
     */
    CoreDomUtilsProvider.prototype.confirmDownloadSize = function (size, message, unknownMessage, wifiThreshold, limitedThreshold, alwaysConfirm) {
        wifiThreshold = typeof wifiThreshold == 'undefined' ? __WEBPACK_IMPORTED_MODULE_7__core_constants__["a" /* CoreConstants */].WIFI_DOWNLOAD_THRESHOLD : wifiThreshold;
        limitedThreshold = typeof limitedThreshold == 'undefined' ? __WEBPACK_IMPORTED_MODULE_7__core_constants__["a" /* CoreConstants */].DOWNLOAD_THRESHOLD : limitedThreshold;
        if (size.size < 0 || (size.size == 0 && !size.total)) {
            // Seems size was unable to be calculated. Show a warning.
            unknownMessage = unknownMessage || 'core.course.confirmdownloadunknownsize';
            return this.showConfirm(this.translate.instant(unknownMessage));
        }
        else if (!size.total) {
            // Filesize is only partial.
            var readableSize = this.textUtils.bytesToSize(size.size, 2);
            return this.showConfirm(this.translate.instant('core.course.confirmpartialdownloadsize', { size: readableSize }));
        }
        else if (size.size >= wifiThreshold || (this.appProvider.isNetworkAccessLimited() && size.size >= limitedThreshold)) {
            message = message || 'core.course.confirmdownload';
            var readableSize = this.textUtils.bytesToSize(size.size, 2);
            return this.showConfirm(this.translate.instant(message, { size: readableSize }));
        }
        else if (alwaysConfirm) {
            return this.showConfirm(this.translate.instant('core.areyousure'));
        }
        return Promise.resolve();
    };
    /**
     * Extract the downloadable URLs from an HTML code.
     *
     * @param {string} html HTML code.
     * @return {string[]} List of file urls.
     */
    CoreDomUtilsProvider.prototype.extractDownloadableFilesFromHtml = function (html) {
        var urls = [];
        var elements;
        this.element.innerHTML = html;
        elements = this.element.querySelectorAll('a, img, audio, video, source, track');
        for (var i in elements) {
            var element = elements[i];
            var url = element.tagName === 'A' ? element.href : element.src;
            if (url && this.urlUtils.isDownloadableUrl(url) && urls.indexOf(url) == -1) {
                urls.push(url);
            }
            // Treat video poster.
            if (element.tagName == 'VIDEO' && element.getAttribute('poster')) {
                url = element.getAttribute('poster');
                if (url && this.urlUtils.isDownloadableUrl(url) && urls.indexOf(url) == -1) {
                    urls.push(url);
                }
            }
        }
        return urls;
    };
    /**
     * Extract the downloadable URLs from an HTML code and returns them in fake file objects.
     *
     * @param {string} html HTML code.
     * @return {any[]} List of fake file objects with file URLs.
     */
    CoreDomUtilsProvider.prototype.extractDownloadableFilesFromHtmlAsFakeFileObjects = function (html) {
        var urls = this.extractDownloadableFilesFromHtml(html);
        // Convert them to fake file objects.
        return urls.map(function (url) {
            return {
                fileurl: url
            };
        });
    };
    /**
     * Search all the URLs in a CSS file content.
     *
     * @param {string} code CSS code.
     * @return {string[]} List of URLs.
     */
    CoreDomUtilsProvider.prototype.extractUrlsFromCSS = function (code) {
        // First of all, search all the url(...) occurrences that don't include "data:".
        var urls = [], matches = code.match(/url\(\s*["']?(?!data:)([^)]+)\)/igm);
        // Extract the URL form each match.
        matches.forEach(function (match) {
            var submatches = match.match(/url\(\s*['"]?([^'"]*)['"]?\s*\)/im);
            if (submatches && submatches[1]) {
                urls.push(submatches[1]);
            }
        });
        return urls;
    };
    /**
     * Focus an element and open keyboard.
     *
     * @param {HTMLElement} el HTML element to focus.
     */
    CoreDomUtilsProvider.prototype.focusElement = function (el) {
        if (el && el.focus) {
            el.focus();
            if (this.platform.is('android') && this.supportsInputKeyboard(el)) {
                // On some Android versions the keyboard doesn't open automatically.
                this.appProvider.openKeyboard();
            }
        }
    };
    /**
     * Formats a size to be used as width/height of an element.
     * If the size is already valid (like '500px' or '50%') it won't be modified.
     * Returned size will have a format like '500px'.
     *
     * @param {any} size Size to format.
     * @return {string} Formatted size. If size is not valid, returns an empty string.
     */
    CoreDomUtilsProvider.prototype.formatPixelsSize = function (size) {
        if (typeof size == 'string' && (size.indexOf('px') > -1 || size.indexOf('%') > -1)) {
            // It seems to be a valid size.
            return size;
        }
        size = parseInt(size, 10);
        if (!isNaN(size)) {
            return size + 'px';
        }
        return '';
    };
    /**
     * Returns the contents of a certain selection in a DOM element.
     *
     * @param {HTMLElement} element DOM element to search in.
     * @param {string} selector Selector to search.
     * @return {string} Selection contents. Undefined if not found.
     */
    CoreDomUtilsProvider.prototype.getContentsOfElement = function (element, selector) {
        if (element) {
            var selected = element.querySelector(selector);
            if (selected) {
                return selected.innerHTML;
            }
        }
    };
    /**
     * Returns height of an element.
     *
     * @param {any} element DOM element to measure.
     * @param {boolean} [usePadding] Whether to use padding to calculate the measure.
     * @param {boolean} [useMargin] Whether to use margin to calculate the measure.
     * @param {boolean} [useBorder] Whether to use borders to calculate the measure.
     * @param {boolean} [innerMeasure] If inner measure is needed: padding, margin or borders will be substracted.
     * @return {number} Height in pixels.
     */
    CoreDomUtilsProvider.prototype.getElementHeight = function (element, usePadding, useMargin, useBorder, innerMeasure) {
        return this.getElementMeasure(element, false, usePadding, useMargin, useBorder, innerMeasure);
    };
    /**
     * Returns height or width of an element.
     *
     * @param {any} element DOM element to measure.
     * @param {boolean} [getWidth] Whether to get width or height.
     * @param {boolean} [usePadding] Whether to use padding to calculate the measure.
     * @param {boolean} [useMargin] Whether to use margin to calculate the measure.
     * @param {boolean} [useBorder] Whether to use borders to calculate the measure.
     * @param {boolean} [innerMeasure] If inner measure is needed: padding, margin or borders will be substracted.
     * @return {number} Measure in pixels.
     */
    CoreDomUtilsProvider.prototype.getElementMeasure = function (element, getWidth, usePadding, useMargin, useBorder, innerMeasure) {
        var offsetMeasure = getWidth ? 'offsetWidth' : 'offsetHeight', measureName = getWidth ? 'width' : 'height', clientMeasure = getWidth ? 'clientWidth' : 'clientHeight', priorSide = getWidth ? 'Left' : 'Top', afterSide = getWidth ? 'Right' : 'Bottom';
        var measure = element[offsetMeasure] || element[measureName] || element[clientMeasure] || 0;
        // Measure not correctly taken.
        if (measure <= 0) {
            var style = getComputedStyle(element);
            if (style && style.display == '') {
                element.style.display = 'inline-block';
                measure = element[offsetMeasure] || element[measureName] || element[clientMeasure] || 0;
                element.style.display = '';
            }
        }
        if (usePadding || useMargin || useBorder) {
            var computedStyle = getComputedStyle(element);
            var surround = 0;
            if (usePadding) {
                surround += parseInt(computedStyle['padding' + priorSide], 10) + parseInt(computedStyle['padding' + afterSide], 10);
            }
            if (useMargin) {
                surround += parseInt(computedStyle['margin' + priorSide], 10) + parseInt(computedStyle['margin' + afterSide], 10);
            }
            if (useBorder) {
                surround += parseInt(computedStyle['border' + priorSide], 10) + parseInt(computedStyle['border' + afterSide], 10);
            }
            if (innerMeasure) {
                measure = measure > surround ? measure - surround : 0;
            }
            else {
                measure += surround;
            }
        }
        return measure;
    };
    /**
     * Returns width of an element.
     *
     * @param {any} element DOM element to measure.
     * @param {boolean} [usePadding] Whether to use padding to calculate the measure.
     * @param {boolean} [useMargin] Whether to use margin to calculate the measure.
     * @param {boolean} [useBorder] Whether to use borders to calculate the measure.
     * @param {boolean} [innerMeasure] If inner measure is needed: padding, margin or borders will be substracted.
     * @return {number} Width in pixels.
     */
    CoreDomUtilsProvider.prototype.getElementWidth = function (element, usePadding, useMargin, useBorder, innerMeasure) {
        return this.getElementMeasure(element, true, usePadding, useMargin, useBorder, innerMeasure);
    };
    /**
     * Retrieve the position of a element relative to another element.
     *
     * @param {HTMLElement} container Element to search in.
     * @param {string} [selector] Selector to find the element to gets the position.
     * @param {string} [positionParentClass] Parent Class where to stop calculating the position. Default scroll-content.
     * @return {number[]} positionLeft, positionTop of the element relative to.
     */
    CoreDomUtilsProvider.prototype.getElementXY = function (container, selector, positionParentClass) {
        var element = (selector ? container.querySelector(selector) : container), offsetElement, positionTop = 0, positionLeft = 0;
        if (!positionParentClass) {
            positionParentClass = 'scroll-content';
        }
        if (!element) {
            return null;
        }
        while (element) {
            positionLeft += (element.offsetLeft - element.scrollLeft + element.clientLeft);
            positionTop += (element.offsetTop - element.scrollTop + element.clientTop);
            offsetElement = element.offsetParent;
            element = element.parentElement;
            // Every parent class has to be checked but the position has to be got form offsetParent.
            while (offsetElement != element && element) {
                // If positionParentClass element is reached, stop adding tops.
                if (element.className.indexOf(positionParentClass) != -1) {
                    element = null;
                }
                else {
                    element = element.parentElement;
                }
            }
            // Finally, check again.
            if (element && element.className.indexOf(positionParentClass) != -1) {
                element = null;
            }
        }
        return [positionLeft, positionTop];
    };
    /**
     * Given an error message, return a suitable error title.
     *
     * @param {string} message The error message.
     * @return {string} Title.
     */
    CoreDomUtilsProvider.prototype.getErrorTitle = function (message) {
        if (message == this.translate.instant('core.networkerrormsg') ||
            message == this.translate.instant('core.fileuploader.errormustbeonlinetoupload')) {
            return '<span class="core-icon-with-badge"><i class="icon ion-wifi"></i>\
                <i class="icon ion-alert-circled core-icon-badge"></i></span>';
        }
        return this.textUtils.decodeHTML(this.translate.instant('core.error'));
    };
    /**
     * Check if an element is outside of screen (viewport).
     *
     * @param {HTMLElement} scrollEl The element that must be scrolled.
     * @param {HTMLElement} element DOM element to check.
     * @return {boolean} Whether the element is outside of the viewport.
     */
    CoreDomUtilsProvider.prototype.isElementOutsideOfScreen = function (scrollEl, element) {
        var elementRect = element.getBoundingClientRect();
        var elementMidPoint, scrollElRect, scrollTopPos = 0;
        if (!elementRect) {
            return false;
        }
        elementMidPoint = Math.round((elementRect.bottom + elementRect.top) / 2);
        scrollElRect = scrollEl.getBoundingClientRect();
        scrollTopPos = (scrollElRect && scrollElRect.top) || 0;
        return elementMidPoint > window.innerHeight || elementMidPoint < scrollTopPos;
    };
    /**
     * Check if rich text editor is enabled.
     *
     * @return {Promise<boolean>} Promise resolved with boolean: true if enabled, false otherwise.
     */
    CoreDomUtilsProvider.prototype.isRichTextEditorEnabled = function () {
        if (this.isRichTextEditorSupported()) {
            return this.configProvider.get(__WEBPACK_IMPORTED_MODULE_7__core_constants__["a" /* CoreConstants */].SETTINGS_RICH_TEXT_EDITOR, true);
        }
        return Promise.resolve(false);
    };
    /**
     * Check if rich text editor is supported in the platform.
     *
     * @return {boolean} Whether it's supported.
     */
    CoreDomUtilsProvider.prototype.isRichTextEditorSupported = function () {
        // Disabled just for iOS.
        return !this.platform.is('ios');
    };
    /**
     * Move children from one HTMLElement to another.
     *
     * @param {HTMLElement} oldParent The old parent.
     * @param {HTMLElement} newParent The new parent.
     */
    CoreDomUtilsProvider.prototype.moveChildren = function (oldParent, newParent) {
        while (oldParent.childNodes.length > 0) {
            newParent.appendChild(oldParent.childNodes[0]);
        }
    };
    /**
     * Search and remove a certain element from inside another element.
     *
     * @param {HTMLElement} element DOM element to search in.
     * @param {string} selector Selector to search.
     */
    CoreDomUtilsProvider.prototype.removeElement = function (element, selector) {
        if (element) {
            var selected = element.querySelector(selector);
            if (selected) {
                selected.remove();
            }
        }
    };
    /**
     * Search and remove a certain element from an HTML code.
     *
     * @param {string} html HTML code to change.
     * @param {string} selector Selector to search.
     * @param {boolean} [removeAll] True if it should remove all matches found, false if it should only remove the first one.
     * @return {string} HTML without the element.
     */
    CoreDomUtilsProvider.prototype.removeElementFromHtml = function (html, selector, removeAll) {
        var selected;
        this.element.innerHTML = html;
        if (removeAll) {
            selected = this.element.querySelectorAll(selector);
            for (var i in selected) {
                selected[i].remove();
            }
        }
        else {
            selected = this.element.querySelector(selector);
            if (selected) {
                selected.remove();
            }
        }
        return this.element.innerHTML;
    };
    /**
     * Search for certain classes in an element contents and replace them with the specified new values.
     *
     * @param {HTMLElement} element DOM element.
     * @param {any} map Mapping of the classes to replace. Keys must be the value to replace, values must be
     *            the new class name. Example: {'correct': 'core-question-answer-correct'}.
     */
    CoreDomUtilsProvider.prototype.replaceClassesInElement = function (element, map) {
        for (var key in map) {
            var foundElements = element.querySelectorAll('.' + key);
            for (var i in foundElements) {
                var foundElement = foundElements[i];
                foundElement.className = foundElement.className.replace(key, map[key]);
            }
        }
    };
    /**
     * Given an HTML, search all links and media and tries to restore original sources using the paths object.
     *
     * @param {string} html HTML code.
     * @param {object} paths Object linking URLs in the html code with the real URLs to use.
     * @param {Function} [anchorFn] Function to call with each anchor. Optional.
     * @return {string} Treated HTML code.
     */
    CoreDomUtilsProvider.prototype.restoreSourcesInHtml = function (html, paths, anchorFn) {
        var media, anchors;
        this.element.innerHTML = html;
        // Treat elements with src (img, audio, video, ...).
        media = this.element.querySelectorAll('img, video, audio, source, track');
        for (var i in media) {
            var el = media[i];
            var newSrc = paths[this.textUtils.decodeURIComponent(el.getAttribute('src'))];
            if (typeof newSrc != 'undefined') {
                el.setAttribute('src', newSrc);
            }
            // Treat video posters.
            if (el.tagName == 'VIDEO' && el.getAttribute('poster')) {
                newSrc = paths[this.textUtils.decodeURIComponent(el.getAttribute('poster'))];
                if (typeof newSrc !== 'undefined') {
                    el.setAttribute('poster', newSrc);
                }
            }
        }
        // Now treat links.
        anchors = this.element.querySelectorAll('a');
        for (var i in anchors) {
            var anchor = anchors[i], href = this.textUtils.decodeURIComponent(anchor.getAttribute('href')), newUrl = paths[href];
            if (typeof newUrl != 'undefined') {
                anchor.setAttribute('href', newUrl);
                if (typeof anchorFn == 'function') {
                    anchorFn(anchor, href);
                }
            }
        }
        return this.element.innerHTML;
    };
    /**
     * Scroll to a certain element inside another element.
     *
     * @param {Content|HTMLElement} scrollEl The content that must be scrolled.
     * @param {HTMLElement} container Element to search in.
     * @param {string} [selector] Selector to find the element to scroll to. If not defined, scroll to the container.
     * @param {string} [scrollParentClass] Parent class where to stop calculating the position. Default scroll-content.
     * @return {boolean} True if the element is found, false otherwise.
     */
    CoreDomUtilsProvider.prototype.scrollToElement = function (scrollEl, container, selector, scrollParentClass) {
        var position = this.getElementXY(container, selector, scrollParentClass);
        if (!position) {
            return false;
        }
        scrollEl.scrollTo(position[0], position[1]);
        return true;
    };
    /**
     * Search for an input with error (core-input-error directive) and scrolls to it if found.
     *
     * @param {Content|HTMLElement} scrollEl The element that must be scrolled.
     * @param {HTMLElement} container Element to search in.
     * @param [scrollParentClass] Parent class where to stop calculating the position. Default scroll-content.
     * @return {boolean} True if the element is found, false otherwise.
     */
    CoreDomUtilsProvider.prototype.scrollToInputError = function (scrollEl, container, scrollParentClass) {
        if (!scrollEl) {
            return false;
        }
        return this.scrollToElement(scrollEl, container, '.core-input-error', scrollParentClass);
    };
    /**
     * Show an alert modal with a button to close it.
     *
     * @param {string} title Title to show.
     * @param {string} message Message to show.
     * @param {string} [buttonText] Text of the button.
     * @param {number} [autocloseTime] Number of milliseconds to wait to close the modal. If not defined, modal won't be closed.
     * @return {Alert} The alert modal.
     */
    CoreDomUtilsProvider.prototype.showAlert = function (title, message, buttonText, autocloseTime) {
        var alert = this.alertCtrl.create({
            title: title,
            message: this.addFormatTextIfNeeded(message),
            buttons: [buttonText || this.translate.instant('core.ok')]
        });
        alert.present();
        if (autocloseTime > 0) {
            setTimeout(function () {
                alert.dismiss();
            }, autocloseTime);
        }
        return alert;
    };
    /**
     * Show an alert modal with a button to close it, translating the values supplied.
     *
     * @param {string} title Title to show.
     * @param {string} message Message to show.
     * @param {string} [buttonText] Text of the button.
     * @param {number} [autocloseTime] Number of milliseconds to wait to close the modal. If not defined, modal won't be closed.
     * @return {Alert} The alert modal.
     */
    CoreDomUtilsProvider.prototype.showAlertTranslated = function (title, message, buttonText, autocloseTime) {
        title = title ? this.translate.instant(title) : title;
        message = message ? this.translate.instant(message) : message;
        buttonText = buttonText ? this.translate.instant(buttonText) : buttonText;
        return this.showAlert(title, message, buttonText, autocloseTime);
    };
    /**
     * Show a confirm modal.
     *
     * @param {string} message Message to show in the modal body.
     * @param {string} [title] Title of the modal.
     * @param {string} [okText] Text of the OK button.
     * @param {string} [cancelText] Text of the Cancel button.
     * @param {any} [options] More options. See https://ionicframework.com/docs/api/components/alert/AlertController/
     * @return {Promise<void>} Promise resolved if the user confirms and rejected if he cancels.
     */
    CoreDomUtilsProvider.prototype.showConfirm = function (message, title, okText, cancelText, options) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            options = options || {};
            options.message = _this.addFormatTextIfNeeded(message); // Add format-text to handle links.
            options.title = title;
            if (!title) {
                options.cssClass = 'core-nohead';
            }
            options.buttons = [
                {
                    text: cancelText || _this.translate.instant('core.cancel'),
                    role: 'cancel',
                    handler: function () {
                        reject();
                    }
                },
                {
                    text: okText || _this.translate.instant('core.ok'),
                    handler: function () {
                        resolve();
                    }
                }
            ];
            _this.alertCtrl.create(options).present();
        });
    };
    /**
     * Show an alert modal with an error message.
     *
     * @param {any} error Message to show.
     * @param {boolean} [needsTranslate] Whether the error needs to be translated.
     * @param {number} [autocloseTime] Number of milliseconds to wait to close the modal. If not defined, modal won't be closed.
     * @return {Alert} The alert modal.
     */
    CoreDomUtilsProvider.prototype.showErrorModal = function (error, needsTranslate, autocloseTime) {
        if (typeof error == 'object') {
            // We received an object instead of a string. Search for common properties.
            if (typeof error.content != 'undefined') {
                error = error.content;
            }
            else if (typeof error.body != 'undefined') {
                error = error.body;
            }
            else if (typeof error.message != 'undefined') {
                error = error.message;
            }
            else if (typeof error.error != 'undefined') {
                error = error.error;
            }
            else {
                // No common properties found, just stringify it.
                error = JSON.stringify(error);
            }
            // Try to remove tokens from the contents.
            var matches = error.match(/token"?[=|:]"?(\w*)/, '');
            if (matches && matches[1]) {
                error = error.replace(new RegExp(matches[1], 'g'), 'secret');
            }
        }
        var message = this.textUtils.decodeHTML(needsTranslate ? this.translate.instant(error) : error);
        return this.showAlert(this.getErrorTitle(message), message, undefined, autocloseTime);
    };
    /**
     * Show an alert modal with an error message. It uses a default message if error is not a string.
     *
     * @param {any} error Message to show.
     * @param {any} [defaultError] Message to show if the error is not a string.
     * @param {boolean} [needsTranslate] Whether the error needs to be translated.
     * @param {number} [autocloseTime] Number of milliseconds to wait to close the modal. If not defined, modal won't be closed.
     * @return {Alert} The alert modal.
     */
    CoreDomUtilsProvider.prototype.showErrorModalDefault = function (error, defaultError, needsTranslate, autocloseTime) {
        if (error != __WEBPACK_IMPORTED_MODULE_7__core_constants__["a" /* CoreConstants */].DONT_SHOW_ERROR) {
            if (error && typeof error != 'string') {
                error = error.message || error.error;
            }
            error = typeof error == 'string' ? error : defaultError;
            return this.showErrorModal(error, needsTranslate, autocloseTime);
        }
    };
    /**
     * Show an alert modal with the first warning error message. It uses a default message if error is not a string.
     *
     * @param {any} warnings Warnings returned.
     * @param {any} [defaultError] Message to show if the error is not a string.
     * @param {boolean} [needsTranslate] Whether the error needs to be translated.
     * @param {number} [autocloseTime] Number of milliseconds to wait to close the modal. If not defined, modal won't be closed.
     * @return {Alert} The alert modal.
     */
    CoreDomUtilsProvider.prototype.showErrorModalFirstWarning = function (warnings, defaultError, needsTranslate, autocloseTime) {
        var error = warnings && warnings.length && warnings[0].message;
        return this.showErrorModalDefault(error, defaultError, needsTranslate, autocloseTime);
    };
    /**
     * Displays a loading modal window.
     *
     * @param {string} [text] The text of the modal window. Default: core.loading.
     * @param {boolean} [needsTranslate] Whether the 'text' needs to be translated.
     * @return {Loading} Loading modal instance.
     * @description
     * Usage:
     *     let modal = domUtils.showModalLoading(myText);
     *     ...
     *     modal.dismiss();
     */
    CoreDomUtilsProvider.prototype.showModalLoading = function (text, needsTranslate) {
        if (!text) {
            text = this.translate.instant('core.loading');
        }
        else if (needsTranslate) {
            text = this.translate.instant(text);
        }
        var loader = this.loadingCtrl.create({
            content: text
        });
        loader.present();
        return loader;
    };
    /**
     * Show a prompt modal to input some data.
     *
     * @param {string} message Modal message.
     * @param {string} [title] Modal title.
     * @param {string} [placeholder] Placeholder of the input element. By default, "Password".
     * @param {string} [type] Type of the input element. By default, password.
     * @return {Promise<any>} Promise resolved with the input data if the user clicks OK, rejected if cancels.
     */
    CoreDomUtilsProvider.prototype.showPrompt = function (message, title, placeholder, type) {
        var _this = this;
        if (type === void 0) { type = 'password'; }
        return new Promise(function (resolve, reject) {
            _this.alertCtrl.create({
                message: _this.addFormatTextIfNeeded(message),
                title: title,
                inputs: [
                    {
                        name: 'promptinput',
                        placeholder: placeholder || _this.translate.instant('core.login.password'),
                        type: type
                    }
                ],
                buttons: [
                    {
                        text: _this.translate.instant('core.cancel'),
                        role: 'cancel',
                        handler: function () {
                            reject();
                        }
                    },
                    {
                        text: _this.translate.instant('core.ok'),
                        handler: function (data) {
                            resolve(data.promptinput);
                        }
                    }
                ]
            }).present();
        });
    };
    /**
     * Displays an autodimissable toast modal window.
     *
     * @param {string} text The text of the toast.
     * @param {boolean} [needsTranslate] Whether the 'text' needs to be translated.
     * @param {number} [duration=2000] Duration in ms of the dimissable toast.
     * @param {string} [cssClass=""] Class to add to the toast.
     * @return {Toast} Toast instance.
     */
    CoreDomUtilsProvider.prototype.showToast = function (text, needsTranslate, duration, cssClass) {
        if (duration === void 0) { duration = 2000; }
        if (cssClass === void 0) { cssClass = ''; }
        if (needsTranslate) {
            text = this.translate.instant(text);
        }
        var loader = this.toastCtrl.create({
            message: text,
            duration: duration,
            position: 'bottom',
            cssClass: cssClass,
            dismissOnPageChange: true
        });
        loader.present();
        return loader;
    };
    /**
     * Check if an element supports input via keyboard.
     *
     * @param {any} el HTML element to check.
     * @return {boolean} Whether it supports input using keyboard.
     */
    CoreDomUtilsProvider.prototype.supportsInputKeyboard = function (el) {
        return el && !el.disabled && (el.tagName.toLowerCase() == 'textarea' ||
            (el.tagName.toLowerCase() == 'input' && this.INPUT_SUPPORT_KEYBOARD.indexOf(el.type) != -1));
    };
    /**
     * View an image in a new page or modal.
     *
     * @param {string} image URL of the image.
     * @param {string} title Title of the page or modal.
     * @param {string} [component] Component to link the image to if needed.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     */
    CoreDomUtilsProvider.prototype.viewImage = function (image, title, component, componentId) {
        if (image) {
            var params = {
                title: title,
                image: image,
                component: component,
                componentId: componentId
            }, modal = this.modalCtrl.create('CoreViewerImagePage', params);
            modal.present();
        }
    };
    /**
     * Wrap an HTMLElement with another element.
     *
     * @param {HTMLElement} el The element to wrap.
     * @param {HTMLElement} wrapper Wrapper.
     */
    CoreDomUtilsProvider.prototype.wrapElement = function (el, wrapper) {
        // Insert the wrapper before the element.
        el.parentNode.insertBefore(wrapper, el);
        // Now move the element into the wrapper.
        wrapper.appendChild(el);
    };
    CoreDomUtilsProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["i" /* LoadingController */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["r" /* ToastController */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["b" /* AlertController */], __WEBPACK_IMPORTED_MODULE_3__text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_4__app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */], __WEBPACK_IMPORTED_MODULE_5__config__["a" /* CoreConfigProvider */], __WEBPACK_IMPORTED_MODULE_6__url__["a" /* CoreUrlUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["j" /* ModalController */]])
    ], CoreDomUtilsProvider);
    return CoreDomUtilsProvider;
}());

//# sourceMappingURL=dom.js.map

/***/ }),

/***/ 19:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreTextUtilsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lang__ = __webpack_require__(101);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/*
 * "Utils" service with helper functions for text.
*/
var CoreTextUtilsProvider = /** @class */ (function () {
    function CoreTextUtilsProvider(translate, langProvider, modalCtrl) {
        this.translate = translate;
        this.langProvider = langProvider;
        this.modalCtrl = modalCtrl;
        this.element = document.createElement('div'); // Fake element to use in some functions, to prevent creating it each time.
    }
    /**
     * Given a list of sentences, build a message with all of them wrapped in <p>.
     *
     * @param {string[]} messages Messages to show.
     * @return {string} Message with all the messages.
     */
    CoreTextUtilsProvider.prototype.buildMessage = function (messages) {
        var result = '';
        messages.forEach(function (message) {
            if (message) {
                result += "<p>" + message + "</p>";
            }
        });
        return result;
    };
    /**
     * Convert size in bytes into human readable format
     *
     * @param {number} bytes Number of bytes to convert.
     * @param {number} [precision=2] Number of digits after the decimal separator.
     * @return {string} Size in human readable format.
     */
    CoreTextUtilsProvider.prototype.bytesToSize = function (bytes, precision) {
        if (precision === void 0) { precision = 2; }
        if (typeof bytes == 'undefined' || bytes < 0) {
            return this.translate.instant('core.notapplicable');
        }
        if (precision < 0) {
            precision = 2;
        }
        var keys = ['core.sizeb', 'core.sizekb', 'core.sizemb', 'core.sizegb', 'core.sizetb'], units = this.translate.instant(keys);
        var pos = 0;
        if (bytes >= 1024) {
            while (bytes >= 1024) {
                pos++;
                bytes = bytes / 1024;
            }
            // Round to "precision" decimals if needed.
            bytes = Number(Math.round(parseFloat(bytes + 'e+' + precision)) + 'e-' + precision);
        }
        return this.translate.instant('core.humanreadablesize', { size: bytes, unit: units[keys[pos]] });
    };
    /**
     * Clean HTML tags.
     *
     * @param {string} text The text to be cleaned.
     * @param {boolean} [singleLine] True if new lines should be removed (all the text in a single line).
     * @return {string} Clean text.
     */
    CoreTextUtilsProvider.prototype.cleanTags = function (text, singleLine) {
        if (!text) {
            return '';
        }
        // First, we use a regexpr.
        text = text.replace(/(<([^>]+)>)/ig, '');
        // Then, we rely on the browser. We need to wrap the text to be sure is HTML.
        this.element.innerHTML = text;
        text = this.element.textContent;
        // Recover or remove new lines.
        text = this.replaceNewLines(text, singleLine ? ' ' : '<br>');
        return text;
    };
    /**
     * Concatenate two paths, adding a slash between them if needed.
     *
     * @param {string} leftPath Left path.
     * @param {string} rightPath Right path.
     * @return {string} Concatenated path.
     */
    CoreTextUtilsProvider.prototype.concatenatePaths = function (leftPath, rightPath) {
        if (!leftPath) {
            return rightPath;
        }
        else if (!rightPath) {
            return leftPath;
        }
        var lastCharLeft = leftPath.slice(-1), firstCharRight = rightPath.charAt(0);
        if (lastCharLeft === '/' && firstCharRight === '/') {
            return leftPath + rightPath.substr(1);
        }
        else if (lastCharLeft !== '/' && firstCharRight !== '/') {
            return leftPath + '/' + rightPath;
        }
        else {
            return leftPath + rightPath;
        }
    };
    /**
     * Count words in a text.
     *
     * @param {string} text Text to count.
     * @return {number} Number of words.
     */
    CoreTextUtilsProvider.prototype.countWords = function (text) {
        // Clean HTML scripts and tags.
        text = text.replace(/<script[^>]*>([\S\s]*?)<\/script>/gmi, '');
        text = text.replace(/<\/?(?!\!)[^>]*>/gi, '');
        // Decode HTML entities.
        text = this.decodeHTMLEntities(text);
        // Replace underscores (which are classed as word characters) with spaces.
        text = text.replace(/_/gi, ' ');
        // This RegEx will detect any word change including Unicode chars. Some languages without spaces won't be counted fine.
        return text.match(/\S+/gi).length;
    };
    /**
     * Decode an escaped HTML text. This implementation is based on PHP's htmlspecialchars_decode.
     *
     * @param {string|number} text Text to decode.
     * @return {string} Decoded text.
     */
    CoreTextUtilsProvider.prototype.decodeHTML = function (text) {
        if (typeof text == 'undefined' || text === null || (typeof text == 'number' && isNaN(text))) {
            return '';
        }
        else if (typeof text != 'string') {
            return '' + text;
        }
        return text
            .replace(/&amp;/g, '&')
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&quot;/g, '"')
            .replace(/&#039;/g, '')
            .replace(/&nbsp;/g, ' ');
    };
    /**
     * Decode HTML entities in a text. Equivalent to PHP html_entity_decode.
     *
     * @param {string} text Text to decode.
     * @return {string} Decoded text.
     */
    CoreTextUtilsProvider.prototype.decodeHTMLEntities = function (text) {
        if (text) {
            this.element.innerHTML = text;
            text = this.element.textContent;
            this.element.textContent = '';
        }
        return text;
    };
    /**
     * Same as Javascript's decodeURI, but if an exception is thrown it will return the original URI.
     *
     * @param {string} uri URI to decode.
     * @return {string} Decoded URI, or original URI if an exception is thrown.
     */
    CoreTextUtilsProvider.prototype.decodeURI = function (uri) {
        try {
            return decodeURI(uri);
        }
        catch (ex) {
            // Error, use the original URI.
        }
        return uri;
    };
    /**
     * Same as Javascript's decodeURIComponent, but if an exception is thrown it will return the original URI.
     *
     * @param {string} uri URI to decode.
     * @return {string} Decoded URI, or original URI if an exception is thrown.
     */
    CoreTextUtilsProvider.prototype.decodeURIComponent = function (uri) {
        try {
            return decodeURIComponent(uri);
        }
        catch (ex) {
            // Error, use the original URI.
        }
        return uri;
    };
    /**
     * Escapes some characters in a string to be used as a regular expression.
     *
     * @param {string} text Text to escape.
     * @return {string} Escaped text.
     */
    CoreTextUtilsProvider.prototype.escapeForRegex = function (text) {
        if (!text) {
            return '';
        }
        return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
    };
    /**
     * Escape an HTML text. This implementation is based on PHP's htmlspecialchars.
     *
     * @param {string|number} text Text to escape.
     * @return {string} Escaped text.
     */
    CoreTextUtilsProvider.prototype.escapeHTML = function (text) {
        if (typeof text == 'undefined' || text === null || (typeof text == 'number' && isNaN(text))) {
            return '';
        }
        else if (typeof text != 'string') {
            return '' + text;
        }
        return text
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');
    };
    /**
     * Shows a text on a new page.
     *
     * @param {string} title Title of the new state.
     * @param {string} text Content of the text to be expanded.
     * @param {string} [component] Component to link the embedded files to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     */
    CoreTextUtilsProvider.prototype.expandText = function (title, text, component, componentId) {
        if (text.length > 0) {
            var params = {
                title: title,
                content: text,
                component: component,
                componentId: componentId
            };
            // Open a modal with the contents.
            params.isModal = true;
            var modal = this.modalCtrl.create('CoreViewerTextPage', params);
            modal.present();
        }
    };
    /**
     * Formats a text, in HTML replacing new lines by correct html new lines.
     *
     * @param {string} text Text to format.
     * @return {string} Formatted text.
     */
    CoreTextUtilsProvider.prototype.formatHtmlLines = function (text) {
        var hasHTMLTags = this.hasHTMLTags(text);
        if (text.indexOf('<p>') == -1) {
            // Wrap the text in <p> tags.
            text = '<p>' + text + '</p>';
        }
        if (!hasHTMLTags) {
            // The text doesn't have HTML, replace new lines for <br>.
            return this.replaceNewLines(text, '<br>');
        }
        return text;
    };
    /**
     * Formats a text, treating multilang tags and cleaning HTML if needed.
     *
     * @param {string} text Text to format.
     * @param {boolean} [clean] Whether HTML tags should be removed.
     * @param {boolean} [singleLine] Whether new lines should be removed. Only valid if clean is true.
     * @param {number} [shortenLength] Number of characters to shorten the text.
     * @return {Promise<string>} Promise resolved with the formatted text.
     */
    CoreTextUtilsProvider.prototype.formatText = function (text, clean, singleLine, shortenLength) {
        var _this = this;
        return this.treatMultilangTags(text).then(function (formatted) {
            if (clean) {
                formatted = _this.cleanTags(formatted, singleLine);
            }
            if (shortenLength > 0) {
                formatted = _this.shortenText(formatted, shortenLength);
            }
            return formatted;
        });
    };
    /**
     * Get the pluginfile URL to replace @@PLUGINFILE@@ wildcards.
     *
     * @param {any[]} files Files to extract the URL from. They need to have the URL in a 'url' or 'fileurl' attribute.
     * @return {string} Pluginfile URL, undefined if no files found.
     */
    CoreTextUtilsProvider.prototype.getTextPluginfileUrl = function (files) {
        if (files && files.length) {
            var fileURL = files[0].url || files[0].fileurl;
            // Remove text after last slash (encoded or not).
            return fileURL.substr(0, Math.max(fileURL.lastIndexOf('/'), fileURL.lastIndexOf('%2F')));
        }
        return undefined;
    };
    /**
     * Check if a text contains HTML tags.
     *
     * @param {string} text Text to check.
     * @return {boolean} Whether it has HTML tags.
     */
    CoreTextUtilsProvider.prototype.hasHTMLTags = function (text) {
        return /<[a-z][\s\S]*>/i.test(text);
    };
    /**
     * Check if a text contains Unicode long chars.
     * Using as threshold Hex value D800
     *
     * @param {string} text Text to check.
     * @return {boolean} True if has Unicode chars, false otherwise.
     */
    CoreTextUtilsProvider.prototype.hasUnicode = function (text) {
        for (var x = 0; x < text.length; x++) {
            if (text.charCodeAt(x) > 55295) {
                return true;
            }
        }
        return false;
    };
    /**
     * Check if an object has any long Unicode char.
     *
     * @param {object} data Object to be checked.
     * @return {boolean} If the data has any long Unicode char on it.
     */
    CoreTextUtilsProvider.prototype.hasUnicodeData = function (data) {
        for (var el in data) {
            if (typeof data[el] == 'object') {
                if (this.hasUnicodeData(data[el])) {
                    return true;
                }
            }
            else if (typeof data[el] == 'string' && this.hasUnicode(data[el])) {
                return true;
            }
        }
        return false;
    };
    /**
     * Same as Javascript's JSON.parse, but if an exception is thrown it will return the original text.
     *
     * @param {string} json JSON text.
     * @return {any} JSON parsed as object or what it gets.
     */
    CoreTextUtilsProvider.prototype.parseJSON = function (json) {
        try {
            return JSON.parse(json);
        }
        catch (ex) {
            // Error, use the json text.
        }
        return json;
    };
    /**
     * Replace all characters that cause problems with files in Android and iOS.
     *
     * @param {string} text Text to treat.
     * @return {string} Treated text.
     */
    CoreTextUtilsProvider.prototype.removeSpecialCharactersForFiles = function (text) {
        return text.replace(/[#:\/\?\\]+/g, '_');
    };
    /**
     * Replace all the new lines on a certain text.
     *
     * @param {string} text The text to be treated.
     * @param {string} newValue Text to use instead of new lines.
     * @return {string} Treated text.
     */
    CoreTextUtilsProvider.prototype.replaceNewLines = function (text, newValue) {
        return text.replace(/(?:\r\n|\r|\n)/g, newValue);
    };
    /**
     * Replace @@PLUGINFILE@@ wildcards with the real URL in a text.
     *
     * @param {string} Text to treat.
     * @param {any[]} files Files to extract the pluginfile URL from. They need to have the URL in a url or fileurl attribute.
     * @return {string} Treated text.
     */
    CoreTextUtilsProvider.prototype.replacePluginfileUrls = function (text, files) {
        if (text) {
            var fileURL = this.getTextPluginfileUrl(files);
            if (fileURL) {
                return text.replace(/@@PLUGINFILE@@/g, fileURL);
            }
        }
        return text;
    };
    /**
     * Replace pluginfile URLs with @@PLUGINFILE@@ wildcards.
     *
     * @param {string} text Text to treat.
     * @param {any[]} files Files to extract the pluginfile URL from. They need to have the URL in a url or fileurl attribute.
     * @return {string} Treated text.
     */
    CoreTextUtilsProvider.prototype.restorePluginfileUrls = function (text, files) {
        if (text) {
            var fileURL = this.getTextPluginfileUrl(files);
            if (fileURL) {
                return text.replace(new RegExp(this.escapeForRegex(fileURL), 'g'), '@@PLUGINFILE@@');
            }
        }
        return text;
    };
    /**
     * Rounds a number to use a certain amout of decimals or less.
     * Difference between this function and float's toFixed:
     * 7.toFixed(2) -> 7.00
     * roundToDecimals(7, 2) -> 7
     *
     * @param {number} num Number to round.
     * @param {number} [decimals=2] Number of decimals. By default, 2.
     * @return {number} Rounded number.
     */
    CoreTextUtilsProvider.prototype.roundToDecimals = function (num, decimals) {
        if (decimals === void 0) { decimals = 2; }
        var multiplier = Math.pow(10, decimals);
        return Math.round(num * multiplier) / multiplier;
    };
    /**
     * Add quotes to HTML characters.
     *
     * Returns text with HTML characters (like "<", ">", etc.) properly quoted.
     * Based on Moodle's s() function.
     *
     * @param {string} text Text to treat.
     * @return {string} Treated text.
     */
    CoreTextUtilsProvider.prototype.s = function (text) {
        if (!text) {
            return '';
        }
        return this.escapeHTML(text).replace(/&amp;#(\d+|x[0-9a-f]+);/i, '&#$1;');
    };
    /**
     * Shortens a text to length and adds an ellipsis.
     *
     * @param {string} text The text to be shortened.
     * @param {number} length The desired length.
     * @return {string} Shortened text.
     */
    CoreTextUtilsProvider.prototype.shortenText = function (text, length) {
        if (text.length > length) {
            text = text.substr(0, length);
            // Now, truncate at the last word boundary (if exists).
            var lastWordPos = text.lastIndexOf(' ');
            if (lastWordPos > 0) {
                text = text.substr(0, lastWordPos);
            }
            text += '&hellip;';
        }
        return text;
    };
    /**
     * Strip Unicode long char of a given text.
     * Using as threshold Hex value D800
     *
     * @param {string} text Text to check.
     * @return {string} Without the Unicode chars.
     */
    CoreTextUtilsProvider.prototype.stripUnicode = function (text) {
        var stripped = '';
        for (var x = 0; x < text.length; x++) {
            if (text.charCodeAt(x) <= 55295) {
                stripped += text.charAt(x);
            }
        }
        return stripped;
    };
    /**
     * Treat the multilang tags from a HTML code, leaving only the current language.
     *
     * @param {string} text The text to be treated.
     * @return {Promise<string>} Promise resolved with the formatted text.
     */
    CoreTextUtilsProvider.prototype.treatMultilangTags = function (text) {
        if (!text) {
            return Promise.resolve('');
        }
        return this.langProvider.getCurrentLanguage().then(function (language) {
            // Match the current language.
            var anyLangRegEx = /<(?:lang|span)[^>]+lang="[a-zA-Z0-9_-]+"[^>]*>(.*?)<\/(?:lang|span)>/g;
            var currentLangRegEx = new RegExp('<(?:lang|span)[^>]+lang="' + language + '"[^>]*>(.*?)<\/(?:lang|span)>', 'g');
            if (!text.match(currentLangRegEx)) {
                // Current lang not found. Try to find the first language.
                var matches = text.match(anyLangRegEx);
                if (matches && matches[0]) {
                    language = matches[0].match(/lang="([a-zA-Z0-9_-]+)"/)[1];
                    currentLangRegEx = new RegExp('<(?:lang|span)[^>]+lang="' + language + '"[^>]*>(.*?)<\/(?:lang|span)>', 'g');
                }
                else {
                    // No multi-lang tag found, stop.
                    return text;
                }
            }
            // Extract contents of current language.
            text = text.replace(currentLangRegEx, '$1');
            // Delete the rest of languages
            text = text.replace(anyLangRegEx, '');
            return text;
        });
    };
    /**
     * If a number has only 1 digit, add a leading zero to it.
     *
     * @param {string|number} num Number to convert.
     * @return {string} Number with leading zeros.
     */
    CoreTextUtilsProvider.prototype.twoDigits = function (num) {
        if (num < 10) {
            return '0' + num;
        }
        else {
            return '' + num; // Convert to string for coherence.
        }
    };
    /**
     * Make a string's first character uppercase.
     *
     * @param {string} text Text to treat.
     * @return {string} Treated text.
     */
    CoreTextUtilsProvider.prototype.ucFirst = function (text) {
        return text.charAt(0).toUpperCase() + text.slice(1);
    };
    CoreTextUtilsProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_3__lang__["a" /* CoreLangProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["j" /* ModalController */]])
    ], CoreTextUtilsProvider);
    return CoreTextUtilsProvider;
}());

//# sourceMappingURL=text.js.map

/***/ }),

/***/ 201:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreDbProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_sqlite__ = __webpack_require__(450);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__classes_sqlitedb__ = __webpack_require__(451);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_emulator_classes_sqlitedb__ = __webpack_require__(687);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * This service allows interacting with the local database to store and retrieve data.
 */
var CoreDbProvider = /** @class */ (function () {
    function CoreDbProvider(sqlite, platform) {
        this.sqlite = sqlite;
        this.platform = platform;
        this.dbInstances = {};
    }
    /**
     * Get or create a database object.
     *
     * The database objects are cached statically.
     *
     * @param {string} name DB name.
     * @param {boolean} forceNew True if it should always create a new instance.
     * @return {SQLiteDB} DB.
     */
    CoreDbProvider.prototype.getDB = function (name, forceNew) {
        if (typeof this.dbInstances[name] === 'undefined' || forceNew) {
            if (this.platform.is('cordova')) {
                this.dbInstances[name] = new __WEBPACK_IMPORTED_MODULE_3__classes_sqlitedb__["a" /* SQLiteDB */](name, this.sqlite, this.platform);
            }
            else {
                this.dbInstances[name] = new __WEBPACK_IMPORTED_MODULE_4__core_emulator_classes_sqlitedb__["a" /* SQLiteDBMock */](name);
            }
        }
        return this.dbInstances[name];
    };
    /**
     * Delete a DB.
     *
     * @param {string} name DB name.
     * @return {Promise<any>} Promise resolved when the DB is deleted.
     */
    CoreDbProvider.prototype.deleteDB = function (name) {
        var _this = this;
        var promise;
        if (typeof this.dbInstances[name] != 'undefined') {
            // Close the database first.
            promise = this.dbInstances[name].close();
        }
        else {
            promise = Promise.resolve();
        }
        return promise.then(function () {
            var db = _this.dbInstances[name];
            delete _this.dbInstances[name];
            if (_this.platform.is('cordova')) {
                return _this.sqlite.deleteDatabase({
                    name: name,
                    location: 'default'
                });
            }
            else {
                // In WebSQL we cannot delete the database, just empty it.
                return db.emptyDatabase();
            }
        });
    };
    CoreDbProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__ionic_native_sqlite__["a" /* SQLite */], __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* Platform */]])
    ], CoreDbProvider);
    return CoreDbProvider;
}());

//# sourceMappingURL=db.js.map

/***/ }),

/***/ 21:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreEventsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_rxjs__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger__ = __webpack_require__(5);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/*
 * Service to send and listen to events.
 */
var CoreEventsProvider = /** @class */ (function () {
    function CoreEventsProvider(logger) {
        this.observables = {};
        this.uniqueEvents = {};
        this.logger = logger.getInstance('CoreEventsProvider');
    }
    /**
     * Listen for a certain event. To stop listening to the event:
     * let observer = eventsProvider.on('something', myCallBack);
     * ...
     * observer.off();
     *
     * @param {string} eventName Name of the event to listen to.
     * @param {Function} callBack Function to call when the event is triggered.
     * @param {string} [siteId] Site where to trigger the event. Undefined won't check the site.
     * @return {CoreEventObserver} Observer to stop listening.
     */
    CoreEventsProvider.prototype.on = function (eventName, callBack, siteId) {
        var _this = this;
        // If it's a unique event and has been triggered already, call the callBack.
        // We don't need to create an observer because the event won't be triggered again.
        if (this.uniqueEvents[eventName]) {
            callBack(this.uniqueEvents[eventName].data);
            // Return a fake observer to prevent errors.
            return {
                off: function () {
                    // Nothing to do.
                }
            };
        }
        this.logger.debug("New observer listening to event '" + eventName + "'");
        if (typeof this.observables[eventName] == 'undefined') {
            // No observable for this event, create a new one.
            this.observables[eventName] = new __WEBPACK_IMPORTED_MODULE_1_rxjs__["Subject"]();
        }
        var subscription = this.observables[eventName].subscribe(function (value) {
            if (!siteId || value.siteId == siteId) {
                callBack(value);
            }
        });
        // Create and return a CoreEventObserver.
        return {
            off: function () {
                _this.logger.debug("Stop listening to event '" + eventName + "'");
                subscription.unsubscribe();
            }
        };
    };
    /**
     * Triggers an event, notifying all the observers.
     *
     * @param {string} event Name of the event to trigger.
     * @param {any} [data] Data to pass to the observers.
     * @param {string} [siteId] Site where to trigger the event. Undefined means no Site.
     */
    CoreEventsProvider.prototype.trigger = function (eventName, data, siteId) {
        this.logger.debug("Event '" + eventName + "' triggered.");
        if (this.observables[eventName]) {
            if (siteId) {
                if (!data) {
                    data = {};
                }
                data.siteId = siteId;
            }
            this.observables[eventName].next(data);
        }
    };
    /**
     * Triggers a unique event, notifying all the observers. If the event has already been triggered, don't do anything.
     *
     * @param {string} event Name of the event to trigger.
     * @param {any} data Data to pass to the observers.
     * @param {string} [siteId] Site where to trigger the event. Undefined means no Site.
     */
    CoreEventsProvider.prototype.triggerUnique = function (eventName, data, siteId) {
        if (this.uniqueEvents[eventName]) {
            this.logger.debug("Unique event '" + eventName + "' ignored because it was already triggered.");
        }
        else {
            this.logger.debug("Unique event '" + eventName + "' triggered.");
            if (siteId) {
                if (!data) {
                    data = {};
                }
                data.siteId = siteId;
            }
            // Store the data so it can be passed to observers that register from now on.
            this.uniqueEvents[eventName] = {
                data: data
            };
            // Now pass the data to observers.
            if (this.observables[eventName]) {
                this.observables[eventName].next(data);
            }
        }
    };
    CoreEventsProvider.SESSION_EXPIRED = 'session_expired';
    CoreEventsProvider.PASSWORD_CHANGE_FORCED = 'password_change_forced';
    CoreEventsProvider.USER_NOT_FULLY_SETUP = 'user_not_fully_setup';
    CoreEventsProvider.SITE_POLICY_NOT_AGREED = 'site_policy_not_agreed';
    CoreEventsProvider.LOGIN = 'login';
    CoreEventsProvider.LOGOUT = 'logout';
    CoreEventsProvider.LANGUAGE_CHANGED = 'language_changed';
    CoreEventsProvider.NOTIFICATION_SOUND_CHANGED = 'notification_sound_changed';
    CoreEventsProvider.SITE_ADDED = 'site_added';
    CoreEventsProvider.SITE_UPDATED = 'site_updated';
    CoreEventsProvider.SITE_DELETED = 'site_deleted';
    CoreEventsProvider.COMPLETION_MODULE_VIEWED = 'completion_module_viewed';
    CoreEventsProvider.USER_DELETED = 'user_deleted';
    CoreEventsProvider.PACKAGE_STATUS_CHANGED = 'package_status_changed';
    CoreEventsProvider.COURSE_STATUS_CHANGED = 'course_status_changed';
    CoreEventsProvider.SECTION_STATUS_CHANGED = 'section_status_changed';
    CoreEventsProvider.REMOTE_ADDONS_LOADED = 'remote_addons_loaded';
    CoreEventsProvider.LOGIN_SITE_CHECKED = 'login_site_checked';
    CoreEventsProvider.LOGIN_SITE_UNCHECKED = 'login_site_unchecked';
    CoreEventsProvider.IAB_LOAD_START = 'inappbrowser_load_start';
    CoreEventsProvider.IAB_EXIT = 'inappbrowser_exit';
    CoreEventsProvider.APP_LAUNCHED_URL = 'app_launched_url'; // App opened with a certain URL (custom URL scheme).
    CoreEventsProvider.FILE_SHARED = 'file_shared';
    CoreEventsProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger__["a" /* CoreLoggerProvider */]])
    ], CoreEventsProvider);
    return CoreEventsProvider;
}());

//# sourceMappingURL=events.js.map

/***/ }),

/***/ 212:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 217:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFileUploaderDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_events__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_sites__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__classes_delegate__ = __webpack_require__(67);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Delegate to register handlers to be shown in the file picker.
 */
var CoreFileUploaderDelegate = /** @class */ (function (_super) {
    __extends(CoreFileUploaderDelegate, _super);
    function CoreFileUploaderDelegate(loggerProvider, sitesProvider, eventsProvider) {
        var _this = _super.call(this, 'CoreFileUploaderDelegate', loggerProvider, sitesProvider, eventsProvider) || this;
        _this.sitesProvider = sitesProvider;
        _this.eventsProvider = eventsProvider;
        _this.handlers = {}; // All registered handlers.
        _this.enabledHandlers = {}; // Handlers enabled for the current site.
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_1__providers_events__["a" /* CoreEventsProvider */].LOGOUT, _this.clearSiteHandlers.bind(_this));
        return _this;
    }
    /**
     * Clear current site handlers. Reserved for core use.
     */
    CoreFileUploaderDelegate.prototype.clearSiteHandlers = function () {
        this.enabledHandlers = {};
    };
    /**
     * Get the handlers for the current site.
     *
     * @param {string[]} [mimetypes] List of supported mimetypes. If undefined, all mimetypes supported.
     * @return {CoreFileUploaderHandlerDataToReturn[]} List of handlers data.
     */
    CoreFileUploaderDelegate.prototype.getHandlers = function (mimetypes) {
        var handlers = [];
        for (var name_1 in this.enabledHandlers) {
            var handler = this.enabledHandlers[name_1];
            var supportedMimetypes = void 0;
            if (mimetypes) {
                if (!handler.getSupportedMimetypes) {
                    // Handler doesn't implement a required function, don't add it.
                    continue;
                }
                supportedMimetypes = handler.getSupportedMimetypes(mimetypes);
                if (!supportedMimetypes.length) {
                    // Handler doesn't support any mimetype, don't add it.
                    continue;
                }
            }
            var data = handler.getData();
            data.priority = handler.priority;
            data.mimetypes = supportedMimetypes;
            handlers.push(data);
        }
        return handlers;
    };
    CoreFileUploaderDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_1__providers_events__["a" /* CoreEventsProvider */]])
    ], CoreFileUploaderDelegate);
    return CoreFileUploaderDelegate;
}(__WEBPACK_IMPORTED_MODULE_4__classes_delegate__["a" /* CoreDelegate */]));

//# sourceMappingURL=delegate.js.map

/***/ }),

/***/ 250:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseModulePrefetchDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_events__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_file__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_filepool__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_sites__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_time__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__course__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__classes_cache__ = __webpack_require__(980);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__constants__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_ts_md5_dist_md5__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_ts_md5_dist_md5___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_ts_md5_dist_md5__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_rxjs__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12_rxjs__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__classes_delegate__ = __webpack_require__(67);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};














/**
 * Delegate to register module prefetch handlers.
 */
var CoreCourseModulePrefetchDelegate = /** @class */ (function (_super) {
    __extends(CoreCourseModulePrefetchDelegate, _super);
    function CoreCourseModulePrefetchDelegate(loggerProvider, sitesProvider, utils, courseProvider, filepoolProvider, timeUtils, fileProvider, eventsProvider) {
        var _this = _super.call(this, 'CoreCourseModulePrefetchDelegate', loggerProvider, sitesProvider) || this;
        _this.sitesProvider = sitesProvider;
        _this.utils = utils;
        _this.courseProvider = courseProvider;
        _this.filepoolProvider = filepoolProvider;
        _this.timeUtils = timeUtils;
        _this.fileProvider = fileProvider;
        _this.eventsProvider = eventsProvider;
        // Variables for database.
        _this.CHECK_UPDATES_TIMES_TABLE = 'check_updates_times';
        _this.checkUpdatesTableSchema = {
            name: _this.CHECK_UPDATES_TIMES_TABLE,
            columns: [
                {
                    name: 'courseId',
                    type: 'INTEGER',
                    primaryKey: true
                },
                {
                    name: 'time',
                    type: 'INTEGER',
                    notNull: true
                }
            ]
        };
        _this.ROOT_CACHE_KEY = 'mmCourse:';
        _this.handlers = {}; // All registered handlers.
        _this.enabledHandlers = {}; // Handlers enabled for the current site.
        _this.statusCache = new __WEBPACK_IMPORTED_MODULE_9__classes_cache__["a" /* CoreCache */]();
        // Promises for check updates, to prevent performing the same request twice at the same time.
        _this.courseUpdatesPromises = {};
        // Promises and observables for prefetching, to prevent downloading same section twice at the same time and notify progress.
        _this.prefetchData = {};
        _this.sitesProvider.createTableFromSchema(_this.checkUpdatesTableSchema);
        return _this;
    }
    /**
     * Check if current site can check updates using core_course_check_updates.
     *
     * @return {boolean} True if can check updates, false otherwise.
     */
    CoreCourseModulePrefetchDelegate.prototype.canCheckUpdates = function () {
        return this.sitesProvider.getCurrentSite().wsAvailable('core_course_check_updates');
    };
    /**
     * Check if a certain module can use core_course_check_updates.
     *
     * @param {any} module Module.
     * @param {number} courseId Course ID the module belongs to.
     * @return {Promise<boolean>} Promise resolved with boolean: whether the module can use check updates WS.
     */
    CoreCourseModulePrefetchDelegate.prototype.canModuleUseCheckUpdates = function (module, courseId) {
        var handler = this.getPrefetchHandlerFor(module);
        if (!handler) {
            // Module not supported, cannot use check updates.
            return Promise.resolve(false);
        }
        if (handler.canUseCheckUpdates) {
            return Promise.resolve(handler.canUseCheckUpdates(module, courseId));
        }
        // By default, modules can use check updates.
        return Promise.resolve(true);
    };
    /**
     * Clear the status cache.
     */
    CoreCourseModulePrefetchDelegate.prototype.clearStatusCache = function () {
        this.statusCache.clear();
    };
    /**
     * Creates the list of modules to check for get course updates.
     *
     * @param {any[]} modules List of modules.
     * @param {number} courseId Course ID the modules belong to.
     * @return {Promise<{toCheck: any[], cannotUse: any[]}>} Promise resolved with the lists.
     */
    CoreCourseModulePrefetchDelegate.prototype.createToCheckList = function (modules, courseId) {
        var _this = this;
        var result = {
            toCheck: [],
            cannotUse: []
        }, promises = [];
        modules.forEach(function (module) {
            promises.push(_this.getModuleStatusAndDownloadTime(module, courseId).then(function (data) {
                if (data.status == __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].DOWNLOADED) {
                    // Module is downloaded and not outdated. Check if it can check updates.
                    return _this.canModuleUseCheckUpdates(module, courseId).then(function (canUse) {
                        if (canUse) {
                            // Can use check updates, add it to the tocheck list.
                            result.toCheck.push({
                                contextlevel: 'module',
                                id: module.id,
                                since: data.downloadTime || 0
                            });
                        }
                        else {
                            // Cannot use check updates, add it to the cannotUse array.
                            result.cannotUse.push(module);
                        }
                    });
                }
            }).catch(function () {
                // Ignore errors.
            }));
        });
        return Promise.all(promises).then(function () {
            // Sort toCheck list.
            result.toCheck.sort(function (a, b) {
                return a.id >= b.id ? 1 : -1;
            });
            return result;
        });
    };
    /**
     * Determines a module status based on current status, restoring downloads if needed.
     *
     * @param {any} module Module.
     * @param {string} status Current status.
     * @param {boolean} [canCheck] True if updates can be checked using core_course_check_updates.
     * @return {string} Module status.
     */
    CoreCourseModulePrefetchDelegate.prototype.determineModuleStatus = function (module, status, canCheck) {
        var handler = this.getPrefetchHandlerFor(module), siteId = this.sitesProvider.getCurrentSiteId();
        if (handler) {
            if (status == __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].DOWNLOADING) {
                // Check if the download is being handled.
                if (!this.filepoolProvider.getPackageDownloadPromise(siteId, handler.component, module.id)) {
                    // Not handled, the app was probably restarted or something weird happened.
                    // Re-start download (files already on queue or already downloaded will be skipped).
                    handler.prefetch(module);
                }
            }
            else if (handler.determineStatus) {
                // The handler implements a determineStatus function. Apply it.
                return handler.determineStatus(module, status, canCheck);
            }
        }
        return status;
    };
    /**
     * Check for updates in a course.
     *
     * @param {any[]} modules List of modules.
     * @param {number} courseId  Course ID the modules belong to.
     * @return {Promise<any>} Promise resolved with the updates. If a module is set to false, it means updates cannot be
     *                        checked for that module in the current site.
     */
    CoreCourseModulePrefetchDelegate.prototype.getCourseUpdates = function (modules, courseId) {
        var _this = this;
        if (!this.canCheckUpdates()) {
            return Promise.reject(null);
        }
        // Check if there's already a getCourseUpdates in progress.
        var id = __WEBPACK_IMPORTED_MODULE_11_ts_md5_dist_md5__["Md5"].hashAsciiStr(courseId + '#' + JSON.stringify(modules)), siteId = this.sitesProvider.getCurrentSiteId();
        if (this.courseUpdatesPromises[siteId] && this.courseUpdatesPromises[siteId][id]) {
            // There's already a get updates ongoing, return the promise.
            return this.courseUpdatesPromises[siteId][id];
        }
        else if (!this.courseUpdatesPromises[siteId]) {
            this.courseUpdatesPromises[siteId] = {};
        }
        this.courseUpdatesPromises[siteId][id] = this.createToCheckList(modules, courseId).then(function (data) {
            var result = {};
            // Mark as false the modules that cannot use check updates WS.
            data.cannotUse.forEach(function (module) {
                result[module.id] = false;
            });
            if (!data.toCheck.length) {
                // Nothing to check, no need to call the WS.
                return result;
            }
            // Get the site, maybe the user changed site.
            return _this.sitesProvider.getSite(siteId).then(function (site) {
                var params = {
                    courseid: courseId,
                    tocheck: data.toCheck
                }, preSets = {
                    cacheKey: _this.getCourseUpdatesCacheKey(courseId),
                    emergencyCache: false,
                    uniqueCacheKey: true
                };
                return site.read('core_course_check_updates', params, preSets).then(function (response) {
                    if (!response || typeof response.instances == 'undefined') {
                        return Promise.reject(null);
                    }
                    // Store the last execution of the check updates call.
                    var entry = {
                        courseId: courseId,
                        time: _this.timeUtils.timestamp()
                    };
                    site.getDb().insertOrUpdateRecord(_this.CHECK_UPDATES_TIMES_TABLE, entry, { courseId: courseId });
                    return _this.treatCheckUpdatesResult(data.toCheck, response, result);
                }).catch(function (error) {
                    // Cannot get updates.
                    // Get cached entries but discard modules with a download time higher than the last execution of check updates.
                    return site.getDb().getRecord(_this.CHECK_UPDATES_TIMES_TABLE, { courseId: courseId }).then(function (entry) {
                        preSets.getCacheUsingCacheKey = true;
                        preSets.omitExpires = true;
                        return site.read('core_course_check_updates', params, preSets).then(function (response) {
                            if (!response || typeof response.instances == 'undefined') {
                                return Promise.reject(error);
                            }
                            return _this.treatCheckUpdatesResult(data.toCheck, response, result, entry.time);
                        });
                    }, function () {
                        // No previous executions, return result as it is.
                        return result;
                    });
                });
            });
        }).finally(function () {
            // Get updates finished, delete the promise.
            delete _this.courseUpdatesPromises[siteId][id];
        });
        return this.courseUpdatesPromises[siteId][id];
    };
    /**
     * Check for updates in a course.
     *
     * @param {number} courseId Course ID the modules belong to.
     * @return {Promise<any>} Promise resolved with the updates.
     */
    CoreCourseModulePrefetchDelegate.prototype.getCourseUpdatesByCourseId = function (courseId) {
        var _this = this;
        if (!this.canCheckUpdates()) {
            return Promise.reject(null);
        }
        // Get course sections and all their modules.
        return this.courseProvider.getSections(courseId, false, true, { omitExpires: true }).then(function (sections) {
            return _this.getCourseUpdates(_this.courseProvider.getSectionsModules(sections), courseId);
        });
    };
    /**
     * Get cache key for course updates WS calls.
     *
     * @param {number} courseId Course ID.
     * @return {string} Cache key.
     */
    CoreCourseModulePrefetchDelegate.prototype.getCourseUpdatesCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'courseUpdates:' + courseId;
    };
    /**
     * Get modules download size. Only treat the modules with status not downloaded or outdated.
     *
     * @param {any[]} modules List of modules.
     * @param {number} courseId Course ID the modules belong to.
     * @return {Promise<{size: number, total: boolean}>} Promise resolved with the size and a boolean indicating if it was able
     *                                                   to calculate the total size.
     */
    CoreCourseModulePrefetchDelegate.prototype.getDownloadSize = function (modules, courseId) {
        var _this = this;
        // Get the status of each module.
        return this.getModulesStatus(modules, courseId).then(function (data) {
            var downloadableModules = data[__WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].NOT_DOWNLOADED].concat(data[__WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].OUTDATED]), promises = [], result = {
                size: 0,
                total: true
            };
            downloadableModules.forEach(function (module) {
                promises.push(_this.getModuleDownloadSize(module, courseId).then(function (size) {
                    result.total = result.total && size.total;
                    result.size += size.size;
                }));
            });
            return Promise.all(promises).then(function () {
                return result;
            });
        });
    };
    /**
     * Get the download size of a module.
     *
     * @param {any} module Module to get size.
     * @param {Number} courseId Course ID the module belongs to.
     * @param {boolean} [single] True if we're downloading a single module, false if we're downloading a whole section.
     * @return {Promise<{size: number, total: boolean}>} Promise resolved with the size and a boolean indicating if it was able
     *                                                   to calculate the total size.
     */
    CoreCourseModulePrefetchDelegate.prototype.getModuleDownloadSize = function (module, courseId, single) {
        var _this = this;
        var handler = this.getPrefetchHandlerFor(module);
        var downloadSize, packageId;
        // Check if the module has a prefetch handler.
        if (handler) {
            return this.isModuleDownloadable(module, courseId).then(function (downloadable) {
                if (!downloadable) {
                    return { size: 0, total: true };
                }
                packageId = _this.filepoolProvider.getPackageId(handler.component, module.id);
                downloadSize = _this.statusCache.getValue(packageId, 'downloadSize');
                if (typeof downloadSize != 'undefined') {
                    return downloadSize;
                }
                return Promise.resolve(handler.getDownloadSize(module, courseId, single)).then(function (size) {
                    return _this.statusCache.setValue(packageId, 'downloadSize', size);
                }).catch(function (error) {
                    var cachedSize = _this.statusCache.getValue(packageId, 'downloadSize', true);
                    if (cachedSize) {
                        return cachedSize;
                    }
                    return Promise.reject(error);
                });
            });
        }
        return Promise.resolve({ size: 0, total: false });
    };
    /**
     * Get the download size of a module.
     *
     * @param {any} module Module to get size.
     * @param {number} courseId Course ID the module belongs to.
     * @return {Promise<number>} Promise resolved with the size.
     */
    CoreCourseModulePrefetchDelegate.prototype.getModuleDownloadedSize = function (module, courseId) {
        var _this = this;
        var handler = this.getPrefetchHandlerFor(module);
        var downloadedSize, packageId, promise;
        // Check if the module has a prefetch handler.
        if (handler) {
            return this.isModuleDownloadable(module, courseId).then(function (downloadable) {
                if (!downloadable) {
                    return 0;
                }
                packageId = _this.filepoolProvider.getPackageId(handler.component, module.id);
                downloadedSize = _this.statusCache.getValue(packageId, 'downloadedSize');
                if (typeof downloadedSize != 'undefined') {
                    return downloadedSize;
                }
                if (handler.getDownloadedSize) {
                    // Handler implements a method to calculate the downloaded size, use it.
                    promise = Promise.resolve(handler.getDownloadedSize(module, courseId));
                }
                else {
                    // Handler doesn't implement it, get the module files and check if they're downloaded.
                    promise = _this.getModuleFiles(module, courseId).then(function (files) {
                        var siteId = _this.sitesProvider.getCurrentSiteId(), promises = [];
                        var size = 0;
                        // Retrieve file size if it's downloaded.
                        files.forEach(function (file) {
                            var fileUrl = file.url || file.fileurl;
                            promises.push(_this.filepoolProvider.getFilePathByUrl(siteId, fileUrl).then(function (path) {
                                return _this.fileProvider.getFileSize(path).catch(function () {
                                    // Error getting size. Check if the file is being downloaded.
                                    return _this.filepoolProvider.isFileDownloadingByUrl(siteId, fileUrl).then(function () {
                                        // If downloading, count as downloaded.
                                        return file.filesize;
                                    }).catch(function () {
                                        // Not downloading and not found in disk.
                                        return 0;
                                    });
                                }).then(function (fs) {
                                    size += fs;
                                });
                            }));
                        });
                        return Promise.all(promises).then(function () {
                            return size;
                        });
                    });
                }
                return promise.then(function (size) {
                    return _this.statusCache.setValue(packageId, 'downloadedSize', size);
                }).catch(function () {
                    return _this.statusCache.getValue(packageId, 'downloadedSize', true);
                });
            });
        }
        return Promise.resolve(0);
    };
    /**
     * Get module files.
     *
     * @param {any} module Module to get the files.
     * @param {number} courseId Course ID the module belongs to.
     * @return {Promise<any[]>} Promise resolved with the list of files.
     */
    CoreCourseModulePrefetchDelegate.prototype.getModuleFiles = function (module, courseId) {
        var handler = this.getPrefetchHandlerFor(module);
        if (handler.getFiles) {
            // The handler defines a function to get files, use it.
            return Promise.resolve(handler.getFiles(module, courseId));
        }
        else if (handler.loadContents) {
            // The handler defines a function to load contents, use it before returning module contents.
            return handler.loadContents(module, courseId).then(function () {
                return module.contents;
            });
        }
        else {
            return Promise.resolve(module.contents || []);
        }
    };
    /**
     * Get the module status.
     *
     * @param {any} module Module.
     * @param {number} courseId Course ID the module belongs to.
     * @param {any} [updates] Result of getCourseUpdates for all modules in the course. If not provided, it will be
     *                        calculated (slower). If it's false it means the site doesn't support check updates.
     * @param {boolean} [refresh] True if it should ignore the cache.
     * @param {number} [sectionId] ID of the section the module belongs to.
     * @return {Promise<string>} Promise resolved with the status.
     */
    CoreCourseModulePrefetchDelegate.prototype.getModuleStatus = function (module, courseId, updates, refresh, sectionId) {
        var _this = this;
        var handler = this.getPrefetchHandlerFor(module), siteId = this.sitesProvider.getCurrentSiteId(), canCheck = this.canCheckUpdates();
        if (handler) {
            // Check if the status is cached.
            var component_1 = handler.component, packageId_1 = this.filepoolProvider.getPackageId(component_1, module.id);
            var status_1 = this.statusCache.getValue(packageId_1, 'status'), updateStatus_1 = true, promise_1;
            if (!refresh && typeof status_1 != 'undefined') {
                return Promise.resolve(this.determineModuleStatus(module, status_1, canCheck));
            }
            // Check if the module is downloadable.
            return this.isModuleDownloadable(module, courseId).then(function (downloadable) {
                if (!downloadable) {
                    return __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].NOT_DOWNLOADABLE;
                }
                // Get the saved package status.
                return _this.filepoolProvider.getPackageStatus(siteId, component_1, module.id).then(function (currentStatus) {
                    status_1 = handler.determineStatus ? handler.determineStatus(module, status_1, canCheck) : status_1;
                    if (status_1 != __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].DOWNLOADED) {
                        return status_1;
                    }
                    // Module is downloaded. Determine if there are updated in the module to show them outdated.
                    if (typeof updates == 'undefined') {
                        // We don't have course updates, calculate them.
                        promise_1 = _this.getCourseUpdatesByCourseId(courseId);
                    }
                    else if (updates === false) {
                        // Cannot check updates.
                        return Promise.resolve();
                    }
                    else {
                        promise_1 = Promise.resolve(updates);
                    }
                    return promise_1.then(function (updates) {
                        if (!updates || updates[module.id] === false) {
                            // Cannot check updates, always show outdated.
                            return __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].OUTDATED;
                        }
                        // Check if the module has any update.
                        return _this.moduleHasUpdates(module, courseId, updates).then(function (hasUpdates) {
                            if (!hasUpdates) {
                                // No updates, keep current status.
                                return status_1;
                            }
                            // Has updates, mark the module as outdated.
                            status_1 = __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].OUTDATED;
                            return _this.filepoolProvider.storePackageStatus(siteId, component_1, module.id, status_1).catch(function () {
                                // Ignore errors.
                            }).then(function () {
                                return status_1;
                            });
                        }).catch(function () {
                            // Error checking if module has updates.
                            var status = _this.statusCache.getValue(packageId_1, 'status', true);
                            return _this.determineModuleStatus(module, status, canCheck);
                        });
                    }, function () {
                        // Error getting updates, show the stored status.
                        updateStatus_1 = false;
                        return currentStatus;
                    });
                });
            }).then(function (status) {
                if (updateStatus_1) {
                    _this.updateStatusCache(status, courseId, component_1, module.id, sectionId);
                }
                return _this.determineModuleStatus(module, status, canCheck);
            });
        }
        // No handler found, module not downloadable.
        return Promise.resolve(__WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].NOT_DOWNLOADABLE);
    };
    /**
     * Get the status of a list of modules, along with the lists of modules for each status.
     * @see {@link CoreFilepoolProvider.determinePackagesStatus}
     *
     * @param {any[]} modules List of modules to prefetch.
     * @param {number} courseId Course ID the modules belong to.
     * @param {number} [sectionId] ID of the section the modules belong to.
     * @param {boolean} [refresh] True if it should always check the DB (slower).
     * @return {Promise<any>} Promise resolved with an object with the following properties:
     *                                - status (string) Status of the module.
     *                                - total (number) Number of modules.
     *                                - CoreConstants.NOT_DOWNLOADED (any[]) Modules with state NOT_DOWNLOADED.
     *                                - CoreConstants.DOWNLOADED (any[]) Modules with state DOWNLOADED.
     *                                - CoreConstants.DOWNLOADING (any[]) Modules with state DOWNLOADING.
     *                                - CoreConstants.OUTDATED (any[]) Modules with state OUTDATED.
     */
    CoreCourseModulePrefetchDelegate.prototype.getModulesStatus = function (modules, courseId, sectionId, refresh) {
        var _this = this;
        var promises = [], result = {
            total: 0
        };
        var status = __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].NOT_DOWNLOADABLE;
        // Init result.
        result[__WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].NOT_DOWNLOADED] = [];
        result[__WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].DOWNLOADED] = [];
        result[__WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].DOWNLOADING] = [];
        result[__WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].OUTDATED] = [];
        // Check updates in course. Don't use getCourseUpdates because the list of modules might not be the whole course list.
        return this.getCourseUpdatesByCourseId(courseId).catch(function () {
            // Cannot get updates.
            return false;
        }).then(function (updates) {
            modules.forEach(function (module) {
                // Check if the module has a prefetch handler.
                var handler = _this.getPrefetchHandlerFor(module);
                if (handler) {
                    var packageId_2 = _this.filepoolProvider.getPackageId(handler.component, module.id);
                    promises.push(_this.getModuleStatus(module, courseId, updates, refresh).then(function (modStatus) {
                        if (modStatus != __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].NOT_DOWNLOADABLE) {
                            if (sectionId && sectionId > 0) {
                                // Store the section ID.
                                _this.statusCache.setValue(packageId_2, 'sectionId', sectionId);
                            }
                            status = _this.filepoolProvider.determinePackagesStatus(status, modStatus);
                            result[modStatus].push(module);
                            result.total++;
                        }
                    }).catch(function (error) {
                        var cacheStatus = _this.statusCache.getValue(packageId_2, 'status', true);
                        if (typeof cacheStatus == 'undefined') {
                            return Promise.reject(error);
                        }
                        if (cacheStatus != __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].NOT_DOWNLOADABLE) {
                            cacheStatus = _this.filepoolProvider.determinePackagesStatus(status, cacheStatus);
                            result[cacheStatus].push(module);
                            result.total++;
                        }
                    }));
                }
            });
            return Promise.all(promises).then(function () {
                result.status = status;
                return result;
            });
        });
    };
    /**
     * Get a module status and download time. It will only return the download time if the module is downloaded and not outdated.
     *
     * @param {any} module Module.
     * @param {number} courseId Course ID the module belongs to.
     * @return {Promise<{status: string, downloadTime?: number}>} Promise resolved with the data.
     */
    CoreCourseModulePrefetchDelegate.prototype.getModuleStatusAndDownloadTime = function (module, courseId) {
        var _this = this;
        var handler = this.getPrefetchHandlerFor(module), siteId = this.sitesProvider.getCurrentSiteId();
        if (handler) {
            // Get the status from the cache.
            var packageId = this.filepoolProvider.getPackageId(handler.component, module.id), status_2 = this.statusCache.getValue(packageId, 'status');
            if (typeof status_2 != 'undefined' && status_2 != __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].DOWNLOADED) {
                // Status is different than downloaded, just return the status.
                return Promise.resolve({
                    status: status_2
                });
            }
            // Check if the module is downloadable.
            return this.isModuleDownloadable(module, courseId).then(function (downloadable) {
                if (!downloadable) {
                    return {
                        status: __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].NOT_DOWNLOADABLE
                    };
                }
                // Get the stored data to get the status and downloadTime.
                return _this.filepoolProvider.getPackageData(siteId, handler.component, module.id).then(function (data) {
                    return {
                        status: data.status,
                        downloadTime: data.downloadTime || 0
                    };
                });
            });
        }
        // No handler found, module not downloadable.
        return Promise.resolve({
            status: __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].NOT_DOWNLOADABLE
        });
    };
    /**
     * Get a prefetch handler.
     *
     * @param {any} module The module to work on.
     * @return {CoreCourseModulePrefetchHandler} Prefetch handler.
     */
    CoreCourseModulePrefetchDelegate.prototype.getPrefetchHandlerFor = function (module) {
        return this.enabledHandlers[module.modname];
    };
    /**
     * Invalidate check updates WS call.
     *
     * @param {number} courseId Course ID.
     * @return {Promise<any>} Promise resolved when data is invalidated.
     */
    CoreCourseModulePrefetchDelegate.prototype.invalidateCourseUpdates = function (courseId) {
        return this.sitesProvider.getCurrentSite().invalidateWsCacheForKey(this.getCourseUpdatesCacheKey(courseId));
    };
    /**
     * Invalidate a list of modules in a course. This should only invalidate WS calls, not downloaded files.
     *
     * @param {any[]} modules List of modules.
     * @param {number} courseId Course ID.
     * @return {Promise<any>} Promise resolved when modules are invalidated.
     */
    CoreCourseModulePrefetchDelegate.prototype.invalidateModules = function (modules, courseId) {
        var _this = this;
        var promises = [];
        modules.forEach(function (module) {
            var handler = _this.getPrefetchHandlerFor(module);
            if (handler) {
                if (handler.invalidateModule) {
                    promises.push(handler.invalidateModule(module, courseId).catch(function () {
                        // Ignore errors.
                    }));
                }
                // Invalidate cache.
                _this.invalidateModuleStatusCache(module);
            }
        });
        promises.push(this.invalidateCourseUpdates(courseId));
        return Promise.all(promises);
    };
    /**
     * Invalidates the cache for a given module.
     *
     * @param {any} module Module to be invalidated.
     */
    CoreCourseModulePrefetchDelegate.prototype.invalidateModuleStatusCache = function (module) {
        var handler = this.getPrefetchHandlerFor(module);
        if (handler) {
            this.statusCache.invalidate(this.filepoolProvider.getPackageId(handler.component, module.id));
        }
    };
    /**
     * Check if a list of modules is being downloaded.
     *
     * @param {string} id An ID to identify the download.
     * @return {boolean} True if it's being downloaded, false otherwise.
     */
    CoreCourseModulePrefetchDelegate.prototype.isBeingDownloaded = function (id) {
        var siteId = this.sitesProvider.getCurrentSiteId();
        return !!(this.prefetchData[siteId] && this.prefetchData[siteId][id]);
    };
    /**
     * Check if a module is downloadable.
     *
     * @param {any} module Module.
     * @param {Number} courseId Course ID the module belongs to.
     * @return {Promise<boolean>} Promise resolved with true if downloadable, false otherwise.
     */
    CoreCourseModulePrefetchDelegate.prototype.isModuleDownloadable = function (module, courseId) {
        var _this = this;
        var handler = this.getPrefetchHandlerFor(module);
        if (handler) {
            if (typeof handler.isDownloadable == 'function') {
                var packageId_3 = this.filepoolProvider.getPackageId(handler.component, module.id), downloadable = this.statusCache.getValue(packageId_3, 'downloadable');
                if (typeof downloadable != 'undefined') {
                    return Promise.resolve(downloadable);
                }
                else {
                    return Promise.resolve(handler.isDownloadable(module, courseId)).then(function (downloadable) {
                        return _this.statusCache.setValue(packageId_3, 'downloadable', downloadable);
                    }).catch(function () {
                        // Something went wrong, assume it's not downloadable.
                        return false;
                    });
                }
            }
            else {
                // Function not defined, assume it's not downloadable.
                return Promise.resolve(true);
            }
        }
        else {
            // No handler for module, so it's not downloadable.
            return Promise.resolve(false);
        }
    };
    /**
     * Check if a module has updates based on the result of getCourseUpdates.
     *
     * @param {any} module Module.
     * @param {number} courseId Course ID the module belongs to.
     * @param {any} updates Result of getCourseUpdates.
     * @return {Promise<boolean>} Promise resolved with boolean: whether the module has updates.
     */
    CoreCourseModulePrefetchDelegate.prototype.moduleHasUpdates = function (module, courseId, updates) {
        var handler = this.getPrefetchHandlerFor(module), moduleUpdates = updates[module.id];
        if (handler && handler.hasUpdates) {
            // Handler implements its own function to check the updates, use it.
            return Promise.resolve(handler.hasUpdates(module, courseId, moduleUpdates));
        }
        else if (!moduleUpdates || !moduleUpdates.updates || !moduleUpdates.updates.length) {
            // Module doesn't have any update.
            return Promise.resolve(false);
        }
        else if (handler && handler.updatesNames && handler.updatesNames.test) {
            // Check the update names defined by the handler.
            for (var i = 0, len = moduleUpdates.updates.length; i < len; i++) {
                if (handler.updatesNames.test(moduleUpdates.updates[i].name)) {
                    return Promise.resolve(true);
                }
            }
            return Promise.resolve(false);
        }
        // Handler doesn't define hasUpdates or updatesNames and there is at least 1 update. Assume it has updates.
        return Promise.resolve(true);
    };
    /**
     * Prefetch a module.
     *
     * @param {any} module Module to prefetch.
     * @param {number} courseId Course ID the module belongs to.
     * @param {boolean} [single] True if we're downloading a single module, false if we're downloading a whole section.
     * @return {Promise<any>} Promise resolved when finished.
     */
    CoreCourseModulePrefetchDelegate.prototype.prefetchModule = function (module, courseId, single) {
        var handler = this.getPrefetchHandlerFor(module);
        // Check if the module has a prefetch handler.
        if (handler) {
            return handler.prefetch(module, courseId, single);
        }
        return Promise.resolve();
    };
    /**
     * Prefetches a list of modules using their prefetch handlers.
     * If a prefetch already exists for this site and id, returns the current promise.
     *
     * @param {string} id An ID to identify the download. It can be used to retrieve the download promise.
     * @param {any[]} modules List of modules to prefetch.
     * @param {number} courseId Course ID the modules belong to.
     * @param {CoreCourseModulesProgressFunction} [onProgress] Function to call everytime a module is downloaded.
     * @return {Promise<any>} Promise resolved when all modules have been prefetched.
     */
    CoreCourseModulePrefetchDelegate.prototype.prefetchModules = function (id, modules, courseId, onProgress) {
        var _this = this;
        var siteId = this.sitesProvider.getCurrentSiteId(), currentData = this.prefetchData[siteId] && this.prefetchData[siteId][id];
        if (currentData) {
            // There's a prefetch ongoing, return the current promise.
            if (onProgress) {
                currentData.subscriptions.push(currentData.observable.subscribe(onProgress));
            }
            return currentData.promise;
        }
        var count = 0;
        var promises = [], total = modules.length, moduleIds = modules.map(function (module) {
            return module.id;
        }), prefetchData = {
            observable: new __WEBPACK_IMPORTED_MODULE_12_rxjs__["BehaviorSubject"]({ count: count, total: total }),
            promise: undefined,
            subscriptions: []
        };
        if (onProgress) {
            prefetchData.observable.subscribe(onProgress);
        }
        modules.forEach(function (module) {
            // Check if the module has a prefetch handler.
            var handler = _this.getPrefetchHandlerFor(module);
            if (handler) {
                promises.push(_this.isModuleDownloadable(module, courseId).then(function (downloadable) {
                    if (!downloadable) {
                        return;
                    }
                    return handler.prefetch(module, courseId).then(function () {
                        var index = moduleIds.indexOf(id);
                        if (index > -1) {
                            // It's one of the modules we were expecting to download.
                            moduleIds.splice(index, 1);
                            count++;
                            prefetchData.observable.next({ count: count, total: total });
                        }
                    });
                }));
            }
        });
        // Set the promise.
        prefetchData.promise = Promise.all(promises).finally(function () {
            // Unsubscribe all observers.
            prefetchData.subscriptions.forEach(function (subscription) {
                subscription.unsubscribe();
            });
            delete _this.prefetchData[siteId][id];
        });
        // Store the prefetch data in the list.
        if (!this.prefetchData[siteId]) {
            this.prefetchData[siteId] = {};
        }
        this.prefetchData[siteId][id] = prefetchData;
        return prefetchData.promise;
    };
    /**
     * Remove module Files from handler.
     *
     * @param {any} module Module to remove the files.
     * @param {number} courseId Course ID the module belongs to.
     * @return {Promise<void>} Promise resolved when done.
     */
    CoreCourseModulePrefetchDelegate.prototype.removeModuleFiles = function (module, courseId) {
        var _this = this;
        var handler = this.getPrefetchHandlerFor(module), siteId = this.sitesProvider.getCurrentSiteId();
        var promise;
        if (handler && handler.removeFiles) {
            // Handler implements a method to remove the files, use it.
            promise = handler.removeFiles(module, courseId);
        }
        else {
            // No method to remove files, use get files to try to remove the files.
            promise = this.getModuleFiles(module, courseId).then(function (files) {
                var promises = [];
                files.forEach(function (file) {
                    promises.push(_this.filepoolProvider.removeFileByUrl(siteId, file.url || file.fileurl).catch(function () {
                        // Ignore errors.
                    }));
                });
                return Promise.all(promises);
            });
        }
        return promise.then(function () {
            if (handler) {
                // Update status of the module.
                var packageId = _this.filepoolProvider.getPackageId(handler.component, module.id);
                _this.statusCache.setValue(packageId, 'downloadedSize', 0);
                _this.filepoolProvider.storePackageStatus(siteId, handler.component, module.id, __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].NOT_DOWNLOADED);
            }
        });
    };
    /**
     * Set an on progress function for the download of a list of modules.
     *
     * @param {string} id An ID to identify the download.
     * @param {CoreCourseModulesProgressFunction} onProgress Function to call everytime a module is downloaded.
     */
    CoreCourseModulePrefetchDelegate.prototype.setOnProgress = function (id, onProgress) {
        var siteId = this.sitesProvider.getCurrentSiteId(), currentData = this.prefetchData[siteId] && this.prefetchData[siteId][id];
        if (currentData) {
            // There's a prefetch ongoing, return the current promise.
            currentData.subscriptions.push(currentData.observable.subscribe(onProgress));
        }
    };
    /**
     * Treat the result of the check updates WS call.
     *
     * @param {any[]} toCheckList List of modules to check (from createToCheckList).
     * @param {any} response WS call response.
     * @param {any} result Object where to store the result.
     * @param {number} [previousTime] Time of the previous check updates execution. If set, modules downloaded
     *                                after this time will be ignored.
     * @return {any} Result.
     */
    CoreCourseModulePrefetchDelegate.prototype.treatCheckUpdatesResult = function (toCheckList, response, result, previousTime) {
        // Format the response to index it by module ID.
        this.utils.arrayToObject(response.instances, 'id', result);
        // Treat warnings, adding the not supported modules.
        response.warnings.forEach(function (warning) {
            if (warning.warningcode == 'missingcallback') {
                result[warning.itemid] = false;
            }
        });
        if (previousTime) {
            // Remove from the list the modules downloaded after previousTime.
            toCheckList.forEach(function (entry) {
                if (result[entry.id] && entry.since > previousTime) {
                    delete result[entry.id];
                }
            });
        }
        return result;
    };
    /**
     * Update the status of a module in the "cache".
     *
     * @param {string} status New status.
     * @param {number} courseId Course ID of the module.
     * @param {string} component Package's component.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {number} [sectionId] Section ID of the module.
     */
    CoreCourseModulePrefetchDelegate.prototype.updateStatusCache = function (status, courseId, component, componentId, sectionId) {
        var packageId = this.filepoolProvider.getPackageId(component, componentId), cachedStatus = this.statusCache.getValue(packageId, 'status', true);
        var notify;
        // If the status has changed, notify that the section has changed.
        notify = typeof cachedStatus != 'undefined' && cachedStatus !== status;
        if (notify) {
            if (!sectionId) {
                sectionId = this.statusCache.getValue(packageId, 'sectionId', true);
            }
            // Invalidate and set again.
            this.statusCache.invalidate(packageId);
            this.statusCache.setValue(packageId, 'status', status);
            if (sectionId) {
                this.statusCache.setValue(packageId, 'sectionId', sectionId);
                this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_1__providers_events__["a" /* CoreEventsProvider */].SECTION_STATUS_CHANGED, {
                    sectionId: sectionId,
                    courseId: courseId
                }, this.sitesProvider.getCurrentSiteId());
            }
        }
        else {
            this.statusCache.setValue(packageId, 'status', status);
        }
    };
    CoreCourseModulePrefetchDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_7__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_8__course__["a" /* CoreCourseProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_filepool__["a" /* CoreFilepoolProvider */],
            __WEBPACK_IMPORTED_MODULE_6__providers_utils_time__["a" /* CoreTimeUtilsProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_file__["a" /* CoreFileProvider */],
            __WEBPACK_IMPORTED_MODULE_1__providers_events__["a" /* CoreEventsProvider */]])
    ], CoreCourseModulePrefetchDelegate);
    return CoreCourseModulePrefetchDelegate;
}(__WEBPACK_IMPORTED_MODULE_13__classes_delegate__["a" /* CoreDelegate */]));

//# sourceMappingURL=module-prefetch-delegate.js.map

/***/ }),

/***/ 251:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSplitViewComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(7);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
// Code based on https://github.com/martinpritchardelevate/ionic-split-pane-demo


/**
 * Directive to create a split view layout.
 *
 * @description
 * To init/change the right pane contents (content pane), inject this component in the master page.
 * @ViewChild(CoreSplitViewComponent) splitviewCtrl: CoreSplitViewComponent;
 * Then use the push function to load.
 *
 * Accepts the following params:
 *
 * @param {string|boolean} [when] When the split-pane should be shown. Can be a CSS media query expression, or a shortcut
 * expression. Can also be a boolean expression. Check split-pane component documentation for more information.
 *
 * Example:
 *
 * <core-split-view [when]="lg">
 *     <ion-content><!-- CONTENT TO SHOW ON THE LEFT PANEL (MENU) --></ion-content>
 * </core-split-view>
 */
var CoreSplitViewComponent = /** @class */ (function () {
    function CoreSplitViewComponent(masterNav, element) {
        this.masterNav = masterNav;
        this.when = 'md';
        this.isEnabled = false;
        this.masterPageName = '';
        this.masterPageIndex = 0;
        this.loadDetailPage = false;
        // Empty placeholder for the 'detail' page.
        this.detailPage = null;
        this.element = element.nativeElement;
    }
    /**
     * Component being initialized.
     */
    CoreSplitViewComponent.prototype.ngOnInit = function () {
        // Get the master page name and set an empty page as a placeholder.
        this.masterPageName = this.masterNav.getActive().component.name;
        this.masterPageIndex = this.masterNav.indexOf(this.masterNav.getActive());
        this.emptyDetails();
    };
    /**
     * Get the details NavController. If split view is not enabled, it will return the master nav.
     *
     * @return {NavController} Details NavController.
     */
    CoreSplitViewComponent.prototype.getDetailsNav = function () {
        if (this.isEnabled) {
            return this.detailNav;
        }
        else {
            return this.masterNav;
        }
    };
    /**
     * Get the master NavController.
     *
     * @return {NavController} Master NavController.
     */
    CoreSplitViewComponent.prototype.getMasterNav = function () {
        return this.masterNav;
    };
    /**
     * Check if both panels are shown. It depends on screen width.
     *
     * @return {boolean} If split view is enabled.
     */
    CoreSplitViewComponent.prototype.isOn = function () {
        return this.isEnabled;
    };
    /**
     * Push a page to the navigation stack. It will decide where to load it depending on the size of the screen.
     *
     * @param {any} page   The component class or deeplink name you want to push onto the navigation stack.
     * @param {any} params Any NavParams you want to pass along to the next view.
     */
    CoreSplitViewComponent.prototype.push = function (page, params) {
        if (this.isEnabled) {
            this.detailNav.setRoot(page, params);
        }
        else {
            this.loadDetailPage = {
                component: page,
                data: params
            };
            this.masterNav.push(page, params);
        }
    };
    /**
     * Set the details panel to default info.
     */
    CoreSplitViewComponent.prototype.emptyDetails = function () {
        this.loadDetailPage = false;
        this.detailNav.setRoot('CoreSplitViewPlaceholderPage');
    };
    /**
     * Splitpanel visibility has changed.
     *
     * @param {Boolean} isOn If it fits both panels at the same time.
     */
    CoreSplitViewComponent.prototype.onSplitPaneChanged = function (isOn) {
        this.isEnabled = isOn;
        if (this.masterNav && this.detailNav) {
            (isOn) ? this.activateSplitView() : this.deactivateSplitView();
        }
    };
    /**
     * Enable the split view, show both panels and do some magical navigation.
     */
    CoreSplitViewComponent.prototype.activateSplitView = function () {
        var currentView = this.masterNav.getActive(), currentPageName = currentView.component.name;
        if (this.masterNav.getPrevious().component.name == this.masterPageName) {
            if (currentPageName != this.masterPageName) {
                // CurrentView is a 'Detail' page remove it from the 'master' nav stack.
                this.masterNav.pop();
                // And add it to the 'detail' nav stack.
                this.detailNav.setRoot(currentView.component, currentView.data);
            }
            else if (this.loadDetailPage) {
                // MasterPage is shown, load the last detail page if found.
                this.detailNav.setRoot(this.loadDetailPage.component, this.loadDetailPage.data);
            }
            this.loadDetailPage = false;
        }
    };
    /**
     * Disabled the split view, show only one panel and do some magical navigation.
     */
    CoreSplitViewComponent.prototype.deactivateSplitView = function () {
        var detailView = this.detailNav.getActive(), currentPageName = detailView.component.name;
        if (currentPageName != 'CoreSplitViewPlaceholderPage') {
            // Current detail view is a 'Detail' page so, not the placeholder page, push it on 'master' nav stack.
            this.masterNav.insert(this.masterPageIndex + 1, detailView.component, detailView.data);
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])('detailNav'),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["k" /* Nav */])
    ], CoreSplitViewComponent.prototype, "detailNav", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreSplitViewComponent.prototype, "when", void 0);
    CoreSplitViewComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-split-view',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/components/split-view/split-view.html"*/'<ion-split-pane (ionChange)="onSplitPaneChanged($event._visible);" [when]="when">\n    <ion-menu [content]="detailNav" type="push">\n        <ng-content></ng-content>\n    </ion-menu>\n    <ion-nav [root]="detailPage" #detailNav main></ion-nav>\n</ion-split-pane>'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/components/split-view/split-view.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavController */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */]])
    ], CoreSplitViewComponent);
    return CoreSplitViewComponent;
}());

//# sourceMappingURL=split-view.js.map

/***/ }),

/***/ 252:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonCalendarProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_courses_providers_courses__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_time__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_groups__ = __webpack_require__(546);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_constants__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_local_notifications__ = __webpack_require__(113);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_config__ = __webpack_require__(65);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};









/**
 * Service to handle calendar events.
 */
var AddonCalendarProvider = /** @class */ (function () {
    function AddonCalendarProvider(logger, sitesProvider, groupsProvider, coursesProvider, timeUtils, localNotificationsProvider, configProvider) {
        this.sitesProvider = sitesProvider;
        this.groupsProvider = groupsProvider;
        this.coursesProvider = coursesProvider;
        this.timeUtils = timeUtils;
        this.localNotificationsProvider = localNotificationsProvider;
        this.configProvider = configProvider;
        this.DEFAULT_NOTIFICATION_TIME_SETTING = 'mmaCalendarDefaultNotifTime';
        this.ROOT_CACHE_KEY = 'mmaCalendar:';
        this.DEFAULT_NOTIFICATION_TIME = 60;
        // Variables for database.
        this.EVENTS_TABLE = 'calendar_events';
        this.tablesSchema = [
            {
                name: this.EVENTS_TABLE,
                columns: [
                    {
                        name: 'id',
                        type: 'INTEGER',
                        primaryKey: true
                    },
                    {
                        name: 'notificationtime',
                        type: 'INTEGER'
                    },
                    {
                        name: 'name',
                        type: 'TEXT',
                        notNull: true
                    },
                    {
                        name: 'description',
                        type: 'TEXT'
                    },
                    {
                        name: 'eventtype',
                        type: 'TEXT'
                    },
                    {
                        name: 'courseid',
                        type: 'INTEGER'
                    },
                    {
                        name: 'timestart',
                        type: 'INTEGER'
                    },
                    {
                        name: 'timeduration',
                        type: 'INTEGER'
                    },
                    {
                        name: 'categoryid',
                        type: 'INTEGER'
                    },
                    {
                        name: 'groupid',
                        type: 'INTEGER'
                    },
                    {
                        name: 'instance',
                        type: 'INTEGER'
                    },
                    {
                        name: 'modulename',
                        type: 'TEXT'
                    },
                    {
                        name: 'timemodified',
                        type: 'INTEGER'
                    },
                    {
                        name: 'repeatid',
                        type: 'INTEGER'
                    }
                ]
            }
        ];
        this.logger = logger.getInstance('AddonCalendarProvider');
        this.sitesProvider.createTablesFromSchema(this.tablesSchema);
    }
    AddonCalendarProvider_1 = AddonCalendarProvider;
    /**
     * Get the configured default notification time.
     *
     * @param  {string} [siteId] ID of the site. If not defined, use current site.
     * @return {Promise<number>}  Promise resolved with the default time.
     */
    AddonCalendarProvider.prototype.getDefaultNotificationTime = function (siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var key = this.DEFAULT_NOTIFICATION_TIME_SETTING + '#' + siteId;
        return this.configProvider.get(key, this.DEFAULT_NOTIFICATION_TIME);
    };
    /**
     * Get a calendar event. If the server request fails and data is not cached, try to get it from local DB.
     *
     * @param {number}  id        Event ID.
     * @param {boolean} [refresh] True when we should update the event data.
     * @param {string} [siteId] ID of the site. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the event data is retrieved.
     */
    AddonCalendarProvider.prototype.getEvent = function (id, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var preSets = {
                cacheKey: _this.getEventCacheKey(id)
            }, data = {
                options: {
                    userevents: 0,
                    siteevents: 0,
                },
                events: {
                    eventids: [
                        id
                    ]
                }
            };
            return site.read('core_calendar_get_calendar_events', data, preSets).then(function (response) {
                // The WebService returns all category events. Check the response to search for the event we want.
                var event = response.events.find(function (e) { return e.id == id; });
                return event || _this.getEventFromLocalDb(id);
            }).catch(function () {
                return _this.getEventFromLocalDb(id);
            });
        });
    };
    /**
     * Get cache key for a single event WS call.
     *
     * @param {number} id Event ID.
     * @return {string} Cache key.
     */
    AddonCalendarProvider.prototype.getEventCacheKey = function (id) {
        return this.ROOT_CACHE_KEY + 'events:' + id;
    };
    /**
     * Get a calendar event from local Db.
     *
     * @param  {number} id       Event ID.
     * @param  {string} [siteId] ID of the site the event belongs to. If not defined, use current site.
     * @return {Promise<any>}    Promise resolved when the event data is retrieved.
     */
    AddonCalendarProvider.prototype.getEventFromLocalDb = function (id, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getRecord(_this.EVENTS_TABLE, { id: id });
        });
    };
    /**
     * Get event notification time. Always returns number of minutes (0 if disabled).
     *
     * @param  {number} id       Event ID.
     * @param  {string} [siteId] ID of the site the event belongs to. If not defined, use current site.
     * @return {Promise<number>}  Event notification time in minutes. 0 if disabled.
     */
    AddonCalendarProvider.prototype.getEventNotificationTime = function (id, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.getEventNotificationTimeOption(id, siteId).then(function (time) {
            if (time == -1) {
                return _this.getDefaultNotificationTime(siteId);
            }
            return time;
        });
    };
    /**
     * Get event notification time for options. Returns -1 for default time.
     *
     * @param  {number} id       Event ID.
     * @param  {string} [siteId] ID of the site the event belongs to. If not defined, use current site.
     * @return {Promise<number>}  Promise with wvent notification time in minutes. 0 if disabled, -1 if default time.
     */
    AddonCalendarProvider.prototype.getEventNotificationTimeOption = function (id, siteId) {
        return this.getEventFromLocalDb(id, siteId).then(function (e) {
            return e.notificationtime || -1;
        }).catch(function () {
            return -1;
        });
    };
    /**
     * Get the events in a certain period. The period is calculated like this:
     *     start time: now + daysToStart
     *     end time: start time + daysInterval
     * E.g. using provider.getEventsList(30, 30) is going to get the events starting after 30 days from now
     * and ending before 60 days from now.
     *
     * @param {number} [daysToStart=0]   Number of days from now to start getting events.
     * @param {number} [daysInterval=30] Number of days between timestart and timeend.
     * @param {string} [siteId]          Site to get the events from. If not defined, use current site.
     * @return {Promise<any[]>}          Promise to be resolved when the participants are retrieved.
     */
    AddonCalendarProvider.prototype.getEventsList = function (daysToStart, daysInterval, siteId) {
        var _this = this;
        if (daysToStart === void 0) { daysToStart = 0; }
        if (daysInterval === void 0) { daysInterval = AddonCalendarProvider_1.DAYS_INTERVAL; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            siteId = site.getId();
            return _this.coursesProvider.getUserCourses(false, siteId).then(function (courses) {
                courses.push({ id: site.getSiteHomeId() }); // Add front page.
                return _this.groupsProvider.getUserGroups(courses, siteId).then(function (groups) {
                    var now = _this.timeUtils.timestamp(), start = now + (__WEBPACK_IMPORTED_MODULE_6__core_constants__["a" /* CoreConstants */].SECONDS_DAY * daysToStart), end = start + (__WEBPACK_IMPORTED_MODULE_6__core_constants__["a" /* CoreConstants */].SECONDS_DAY * daysInterval), data = {
                        options: {
                            userevents: 1,
                            siteevents: 1,
                            timestart: start,
                            timeend: end
                        },
                        events: {
                            courseids: [],
                            groupids: []
                        }
                    };
                    courses.forEach(function (course, index) {
                        data.events.courseids[index] = course.id;
                    });
                    groups.forEach(function (group, index) {
                        data.events.groupids[index] = group.id;
                    });
                    // We need to retrieve cached data using cache key because we have timestamp in the params.
                    var preSets = {
                        cacheKey: _this.getEventsListCacheKey(daysToStart, daysInterval),
                        getCacheUsingCacheKey: true
                    };
                    return site.read('core_calendar_get_calendar_events', data, preSets).then(function (response) {
                        _this.storeEventsInLocalDB(response.events, siteId);
                        return response.events;
                    });
                });
            });
        });
    };
    /**
     * Get prefix cache key for events list WS calls.
     *
     * @return {string} Prefix Cache key.
     */
    AddonCalendarProvider.prototype.getEventsListPrefixCacheKey = function () {
        return this.ROOT_CACHE_KEY + 'eventslist:';
    };
    /**
     * Get cache key for events list WS calls.
     *
     * @param {number} daysToStart  Number of days from now to start getting events.
     * @param {number} daysInterval Number of days between timestart and timeend.
     * @return {string} Cache key.
     */
    AddonCalendarProvider.prototype.getEventsListCacheKey = function (daysToStart, daysInterval) {
        return this.getEventsListPrefixCacheKey() + daysToStart + ':' + daysInterval;
    };
    /**
     * Invalidates events list and all the single events and related info.
     *
     * @param {any[]} courses List of courses or course ids.
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<any[]>} Promise resolved when the list is invalidated.
     */
    AddonCalendarProvider.prototype.invalidateEventsList = function (courses, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            siteId = site.getId();
            var promises = [];
            promises.push(_this.coursesProvider.invalidateUserCourses(siteId));
            promises.push(_this.groupsProvider.invalidateUserGroups(courses, siteId));
            promises.push(site.invalidateWsCacheForKeyStartingWith(_this.getEventsListPrefixCacheKey()));
            return Promise.all(promises);
        });
    };
    /**
     * Invalidates a single event.
     *
     * @param {number} eventId List of courses or course ids.
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the list is invalidated.
     */
    AddonCalendarProvider.prototype.invalidateEvent = function (eventId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getEventCacheKey(eventId));
        });
    };
    /**
     * Check if Calendar is disabled in a certain site.
     *
     * @param {CoreSite} [site] Site. If not defined, use current site.
     * @return {boolean} Whether it's disabled.
     */
    AddonCalendarProvider.prototype.isCalendarDisabledInSite = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.isFeatureDisabled('$mmSideMenuDelegate_mmaCalendar');
    };
    /**
     * Check if Calendar is disabled in a certain site.
     *
     * @param  {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<boolean>}     Promise resolved with true if disabled, rejected or resolved with false otherwise.
     */
    AddonCalendarProvider.prototype.isDisabled = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.isCalendarDisabledInSite(site);
        });
    };
    /**
     * Get the next events for all the sites and schedules their notifications.
     * If an event notification time is 0, cancel its scheduled notification (if any).
     * If local notification plugin is not enabled, resolve the promise.
     *
     * @return {Promise}         Promise resolved when all the notifications have been scheduled.
     */
    AddonCalendarProvider.prototype.scheduleAllSitesEventsNotifications = function () {
        var _this = this;
        if (this.localNotificationsProvider.isAvailable()) {
            return this.sitesProvider.getSitesIds().then(function (siteIds) {
                var promises = [];
                siteIds.forEach(function (siteId) {
                    // Check if calendar is disabled for the site.
                    promises.push(_this.isDisabled(siteId).then(function (disabled) {
                        if (!disabled) {
                            // Get first events.
                            return _this.getEventsList(undefined, undefined, siteId).then(function (events) {
                                return _this.scheduleEventsNotifications(events, siteId);
                            });
                        }
                    }));
                });
                return Promise.all(promises);
            });
        }
        else {
            return Promise.resolve([]);
        }
    };
    /**
     * Schedules an event notification. If time is 0, cancel scheduled notification if any.
     * If local notification plugin is not enabled, resolve the promise.
     *
     * @param  {any} event    Event to schedule.
     * @param  {number} time     Notification setting time (in minutes). E.g. 10 means "notificate 10 minutes before start".
     * @param  {string} [siteId] Site ID the event belongs to. If not defined, use current site.
     * @return {Promise<void>}    Promise resolved when the notification is scheduled.
     */
    AddonCalendarProvider.prototype.scheduleEventNotification = function (event, time, siteId) {
        var _this = this;
        if (this.localNotificationsProvider.isAvailable()) {
            siteId = siteId || this.sitesProvider.getCurrentSiteId();
            if (time === 0) {
                // Cancel if it was scheduled.
                return this.localNotificationsProvider.cancel(event.id, AddonCalendarProvider_1.COMPONENT, siteId);
            }
            // If time is -1, get event default time.
            var promise = time == -1 ? this.getDefaultNotificationTime(siteId) : Promise.resolve(time);
            return promise.then(function (time) {
                var timeEnd = (event.timestart + event.timeduration) * 1000;
                if (timeEnd <= new Date().getTime()) {
                    // The event has finished already, don't schedule it.
                    return Promise.resolve();
                }
                var dateTriggered = new Date((event.timestart - (time * 60)) * 1000), startDate = new Date(event.timestart * 1000), notification = {
                    id: event.id,
                    title: event.name,
                    text: startDate.toLocaleString(),
                    at: dateTriggered,
                    data: {
                        eventid: event.id,
                        siteid: siteId
                    }
                };
                return _this.localNotificationsProvider.schedule(notification, AddonCalendarProvider_1.COMPONENT, siteId);
            });
        }
        else {
            return Promise.resolve();
        }
    };
    /**
     * Schedules the notifications for a list of events.
     * If an event notification time is 0, cancel its scheduled notification (if any).
     * If local notification plugin is not enabled, resolve the promise.
     *
     * @param  {any[]} events Events to schedule.
     * @param  {string} [siteId] ID of the site the events belong to. If not defined, use current site.
     * @return {Promise<any[]>}         Promise resolved when all the notifications have been scheduled.
     */
    AddonCalendarProvider.prototype.scheduleEventsNotifications = function (events, siteId) {
        var _this = this;
        var promises = [];
        if (this.localNotificationsProvider.isAvailable()) {
            siteId = siteId || this.sitesProvider.getCurrentSiteId();
            events.forEach(function (e) {
                promises.push(_this.getEventNotificationTime(e.id, siteId).then(function (time) {
                    return _this.scheduleEventNotification(e, time, siteId);
                }));
            });
        }
        return Promise.all(promises);
    };
    /**
     * Set the default notification time.
     *
     * @param  {number} time     New default time.
     * @param  {string} [siteId] ID of the site. If not defined, use current site.
     * @return {Promise<any[]>}    Promise resolved when stored.
     */
    AddonCalendarProvider.prototype.setDefaultNotificationTime = function (time, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var key = this.DEFAULT_NOTIFICATION_TIME_SETTING + '#' + siteId;
        return this.configProvider.set(key, time);
    };
    /**
     * Store events in local DB.
     *
     * @param {any[]} events  Events to store.
     * @param  {string} [siteId] ID of the site the event belongs to. If not defined, use current site.
     * @return {Promise<any[]>}         Promise resolved when the events are stored.
     */
    AddonCalendarProvider.prototype.storeEventsInLocalDB = function (events, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            siteId = site.getId();
            var promises = [], db = site.getDb();
            events.forEach(function (event) {
                // Don't override event notification time if the user configured it.
                promises.push(_this.getEventFromLocalDb(event.id, siteId).catch(function () {
                    // Event not stored, return empty object.
                    return {};
                }).then(function (e) {
                    var eventRecord = {
                        id: event.id,
                        name: event.name,
                        description: event.description,
                        eventtype: event.eventtype,
                        courseid: event.courseid,
                        timestart: event.timestart,
                        timeduration: event.timeduration,
                        categoryid: event.categoryid,
                        groupid: event.groupid,
                        instance: event.instance,
                        modulename: event.modulename,
                        timemodified: event.timemodified,
                        repeatid: event.repeatid,
                        notificationtime: e.notificationtime || -1
                    };
                    return db.insertOrUpdateRecord(_this.EVENTS_TABLE, eventRecord, { id: eventRecord.id });
                }));
            });
            return Promise.all(promises);
        });
    };
    /**
     * Updates an event notification time and schedule a new notification.
     *
     * @param  {any} event Event to update its notification time.
     * @param  {number} time  New notification setting time (in minutes). E.g. 10 means "notificate 10 minutes before start".
     * @param  {string} [siteId] ID of the site the event belongs to. If not defined, use current site.
     * @return {Promise<void>} Promise resolved when the notification is updated.
     */
    AddonCalendarProvider.prototype.updateNotificationTime = function (event, time, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            if (!_this.sitesProvider.isLoggedIn()) {
                // Not logged in, we can't get the site DB. User logged out or session expired while an operation was ongoing.
                return Promise.reject(null);
            }
            event.notificationtime = time;
            return site.getDb().insertOrUpdateRecord(_this.EVENTS_TABLE, event, { id: event.id }).then(function () {
                return _this.scheduleEventNotification(event, time);
            });
        });
    };
    AddonCalendarProvider.DAYS_INTERVAL = 30;
    AddonCalendarProvider.COMPONENT = 'AddonCalendarEvents';
    AddonCalendarProvider.DEFAULT_NOTIFICATION_TIME_CHANGED = 'AddonCalendarDefaultNotificationTimeChangedEvent';
    AddonCalendarProvider = AddonCalendarProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_groups__["a" /* CoreGroupsProvider */],
            __WEBPACK_IMPORTED_MODULE_3__core_courses_providers_courses__["a" /* CoreCoursesProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_utils_time__["a" /* CoreTimeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_7__providers_local_notifications__["a" /* CoreLocalNotificationsProvider */], __WEBPACK_IMPORTED_MODULE_8__providers_config__["a" /* CoreConfigProvider */]])
    ], AddonCalendarProvider);
    return AddonCalendarProvider;
    var AddonCalendarProvider_1;
}());

//# sourceMappingURL=calendar.js.map

/***/ }),

/***/ 253:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonBadgesProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(8);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Service to handle badges.
 */
var AddonBadgesProvider = /** @class */ (function () {
    function AddonBadgesProvider(logger, sitesProvider) {
        this.sitesProvider = sitesProvider;
        this.logger = logger.getInstance('AddonBadgesProvider');
    }
    /**
     * Returns whether or not the badge plugin is enabled for a certain site.
     *
     * This method is called quite often and thus should only perform a quick
     * check, we should not be calling WS from here.
     *
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>}         Promise resolved with true if enabled, false otherwise.
     */
    AddonBadgesProvider.prototype.isPluginEnabled = function (siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            if (!site.canUseAdvancedFeature('enablebadges')) {
                return false;
            }
            else if (!site.wsAvailable('core_badges_get_user_badges') ||
                !site.wsAvailable('core_course_get_user_navigation_options')) {
                return false;
            }
            return true;
        });
    };
    /**
     * Get the cache key for the get badges call.
     *
     * @param  {Number} courseId ID of the course to get the badges from.
     * @param  {Number} userId   ID of the user to get the badges from.
     * @return {String}          Cache key.
     */
    AddonBadgesProvider.prototype.getBadgesCacheKey = function (courseId, userId) {
        return 'mmaBadges:badges:' + courseId + ':' + userId;
    };
    /**
     * Get issued badges for a certain user in a course.
     *
     * @param  {Number} courseId     ID of the course to get the badges from.
     * @param  {Number} userId       ID of the user to get the badges from.
     * @param  {String} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}             Promise to be resolved when the badges are retrieved.
     */
    AddonBadgesProvider.prototype.getUserBadges = function (courseId, userId, siteId) {
        var _this = this;
        this.logger.debug('Get badges for course ' + courseId);
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var data = {
                courseid: courseId,
                userid: userId
            }, presets = {
                cacheKey: _this.getBadgesCacheKey(courseId, userId)
            };
            return site.read('core_badges_get_user_badges', data, presets).then(function (response) {
                if (response && response.badges) {
                    return response.badges;
                }
                else {
                    return Promise.reject(null);
                }
            });
        });
    };
    /**
     * Invalidate get badges WS call.
     *
     * @param {Number} courseId  Course ID.
     * @param  {Number} userId   ID of the user to get the badges from.
     * @param  {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}         Promise resolved when data is invalidated.
     */
    AddonBadgesProvider.prototype.invalidateUserBadges = function (courseId, userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getBadgesCacheKey(courseId, userId));
        });
    };
    AddonBadgesProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */]])
    ], AddonBadgesProvider);
    return AddonBadgesProvider;
}());

//# sourceMappingURL=badges.js.map

/***/ }),

/***/ 254:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSharedFilesHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_app__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_file__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_init__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_sites__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_dom__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__sharedfiles__ = __webpack_require__(255);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__fileuploader_providers_fileuploader__ = __webpack_require__(139);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};












/**
 * Helper service to share files with the app.
 */
var CoreSharedFilesHelperProvider = /** @class */ (function () {
    function CoreSharedFilesHelperProvider(logger, alertCtrl, translate, utils, sitesProvider, modalCtrl, fileUploaderProvider, initDelegate, sharedFilesProvider, domUtils, fileProvider, appProvider) {
        this.alertCtrl = alertCtrl;
        this.translate = translate;
        this.utils = utils;
        this.sitesProvider = sitesProvider;
        this.modalCtrl = modalCtrl;
        this.fileUploaderProvider = fileUploaderProvider;
        this.initDelegate = initDelegate;
        this.sharedFilesProvider = sharedFilesProvider;
        this.domUtils = domUtils;
        this.fileProvider = fileProvider;
        this.appProvider = appProvider;
        this.logger = logger.getInstance('CoreSharedFilesHelperProvider');
    }
    /**
     * Ask a user if he wants to replace a file (using originalName) or rename it (using newName).
     *
     * @param {string} originalName Original name.
     * @param {string} newName New name.
     * @return {Promise<string>} Promise resolved with the name to use when the user chooses. Rejected if user cancels.
     */
    CoreSharedFilesHelperProvider.prototype.askRenameReplace = function (originalName, newName) {
        var deferred = this.utils.promiseDefer(), alert = this.alertCtrl.create({
            title: this.translate.instant('core.sharedfiles.sharedfiles'),
            message: this.translate.instant('core.sharedfiles.chooseactionrepeatedfile', { $a: newName }),
            buttons: [
                {
                    text: this.translate.instant('core.sharedfiles.rename'),
                    handler: function () {
                        deferred.resolve(newName);
                    }
                },
                {
                    text: this.translate.instant('core.sharedfiles.replace'),
                    handler: function () {
                        deferred.resolve(originalName);
                    }
                }
            ]
        });
        alert.present();
        return deferred.promise;
    };
    /**
     * Go to the choose site view.
     *
     * @param {string} filePath File path to send to the view.
     */
    CoreSharedFilesHelperProvider.prototype.goToChooseSite = function (filePath) {
        var navCtrl = this.appProvider.getRootNavController();
        navCtrl.push('CoreSharedFilesChooseSitePage', { filePath: filePath });
    };
    /**
     * Open the view to select a shared file.
     *
     * @param  {string[]} [mimetypes] List of supported mimetypes. If undefined, all mimetypes supported.
     * @return {Promise<any>} Promise resolved when a file is picked, rejected if file picker is closed without selecting a file.
     */
    CoreSharedFilesHelperProvider.prototype.pickSharedFile = function (mimetypes) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var modal = _this.modalCtrl.create('CoreSharedFilesListPage', { mimetypes: mimetypes, isModal: true, pick: true });
            modal.present();
            modal.onDidDismiss(function (file) {
                if (!file) {
                    // User cancelled.
                    reject();
                    return;
                }
                var error = _this.fileUploaderProvider.isInvalidMimetype(mimetypes, file.fullPath);
                if (error) {
                    reject(error);
                }
                else {
                    resolve({
                        path: file.fullPath,
                        treated: false
                    });
                }
            });
        });
    };
    /**
     * Checks if there is a new file received in iOS and move it to the shared folder of current site.
     * If more than one site is found, the user will have to choose the site where to store it in.
     * If more than one file is found, treat only the first one.
     *
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreSharedFilesHelperProvider.prototype.searchIOSNewSharedFiles = function () {
        var _this = this;
        return this.initDelegate.ready().then(function () {
            var navCtrl = _this.appProvider.getRootNavController();
            if (navCtrl && navCtrl.getActive().id == 'CoreSharedFilesChooseSite') {
                // We're already treating a shared file. Abort.
                return Promise.reject(null);
            }
            return _this.sharedFilesProvider.checkIOSNewFiles().then(function (fileEntry) {
                return _this.sitesProvider.getSitesIds().then(function (siteIds) {
                    if (!siteIds.length) {
                        // No sites stored, show error and delete the file.
                        _this.domUtils.showErrorModal('core.sharedfiles.errorreceivefilenosites', true);
                        return _this.sharedFilesProvider.deleteInboxFile(fileEntry);
                    }
                    else if (siteIds.length == 1) {
                        return _this.storeSharedFileInSite(fileEntry, siteIds[0]);
                    }
                    else {
                        _this.goToChooseSite(fileEntry.fullPath);
                    }
                });
            });
        });
    };
    /**
     * Store a shared file in a site's shared files folder.
     *
     * @param {any} fileEntry Shared file entry.
     * @param {string} [siteId]  Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreSharedFilesHelperProvider.prototype.storeSharedFileInSite = function (fileEntry, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // First of all check if there's already a file with the same name in the shared files folder.
        var sharedFilesDirPath = this.sharedFilesProvider.getSiteSharedFilesDirPath(siteId);
        return this.fileProvider.getUniqueNameInFolder(sharedFilesDirPath, fileEntry.name).then(function (newName) {
            if (newName == fileEntry.name) {
                // No file with the same name. Use the original file name.
                return newName;
            }
            else {
                // Repeated name. Ask the user what he wants to do.
                return _this.askRenameReplace(fileEntry.name, newName);
            }
        }).then(function (name) {
            return _this.sharedFilesProvider.storeFileInSite(fileEntry, name, siteId).catch(function (err) {
                _this.domUtils.showErrorModal(err || 'Error moving file.');
            }).finally(function () {
                _this.sharedFilesProvider.deleteInboxFile(fileEntry);
                _this.domUtils.showAlertTranslated('core.success', 'core.sharedfiles.successstorefile');
            });
        });
    };
    CoreSharedFilesHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["b" /* AlertController */], __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_9__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_7__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["j" /* ModalController */],
            __WEBPACK_IMPORTED_MODULE_11__fileuploader_providers_fileuploader__["a" /* CoreFileUploaderProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_init__["a" /* CoreInitDelegate */],
            __WEBPACK_IMPORTED_MODULE_10__sharedfiles__["a" /* CoreSharedFilesProvider */], __WEBPACK_IMPORTED_MODULE_8__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_file__["a" /* CoreFileProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_app__["a" /* CoreAppProvider */]])
    ], CoreSharedFilesHelperProvider);
    return CoreSharedFilesHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),

/***/ 255:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSharedFilesProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_app__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_events__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_file__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_sites__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_mimetype__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_text__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_ts_md5_dist_md5__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_ts_md5_dist_md5___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_ts_md5_dist_md5__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};









/**
 * Service to share files with the app.
 */
var CoreSharedFilesProvider = /** @class */ (function () {
    function CoreSharedFilesProvider(logger, fileProvider, appProvider, textUtils, mimeUtils, sitesProvider, eventsProvider) {
        this.fileProvider = fileProvider;
        this.textUtils = textUtils;
        this.mimeUtils = mimeUtils;
        this.sitesProvider = sitesProvider;
        this.eventsProvider = eventsProvider;
        // Variables for the database.
        this.SHARED_FILES_TABLE = 'wscache';
        this.tableSchema = {
            name: this.SHARED_FILES_TABLE,
            columns: [
                {
                    name: 'id',
                    type: 'TEXT',
                    primaryKey: true
                }
            ]
        };
        this.logger = logger.getInstance('CoreSharedFilesProvider');
        this.appDB = appProvider.getDB();
        this.appDB.createTableFromSchema(this.tableSchema);
    }
    CoreSharedFilesProvider_1 = CoreSharedFilesProvider;
    /**
     * Checks if there is a new file received in iOS. If more than one file is found, treat only the first one.
     * The file returned is marked as "treated" and will be deleted in the next execution.
     *
     * @return {Promise<any>} Promise resolved with a new file to be treated. If no new files found, promise is rejected.
     */
    CoreSharedFilesProvider.prototype.checkIOSNewFiles = function () {
        var _this = this;
        this.logger.debug('Search for new files on iOS');
        return this.fileProvider.getDirectoryContents('Inbox').then(function (entries) {
            if (entries.length > 0) {
                var promises_1 = [];
                var fileToReturn_1;
                entries.forEach(function (entry) {
                    var fileId = _this.getFileId(entry);
                    // Check if file was already treated.
                    promises_1.push(_this.isFileTreated(fileId).then(function () {
                        // File already treated, delete it. Don't return delete promise, we'll ignore errors.
                        _this.deleteInboxFile(entry);
                    }).catch(function () {
                        // File not treated before.
                        _this.logger.debug('Found new file ' + entry.name + ' shared with the app.');
                        if (!fileToReturn_1) {
                            fileToReturn_1 = entry;
                        }
                    }));
                });
                return Promise.all(promises_1).then(function () {
                    var fileId;
                    if (fileToReturn_1) {
                        // Mark it as "treated".
                        fileId = _this.getFileId(fileToReturn_1);
                        return _this.markAsTreated(fileId).then(function () {
                            _this.logger.debug('File marked as "treated": ' + fileToReturn_1.name);
                            return fileToReturn_1;
                        });
                    }
                    else {
                        return Promise.reject(null);
                    }
                });
            }
            else {
                return Promise.reject(null);
            }
        });
    };
    /**
     * Deletes a file in the Inbox folder (shared with the app).
     *
     * @param {any} entry FileEntry.
     * @return {Promise<any>} Promise resolved when done, rejected otherwise.
     */
    CoreSharedFilesProvider.prototype.deleteInboxFile = function (entry) {
        var _this = this;
        this.logger.debug('Delete inbox file: ' + entry.name);
        return this.fileProvider.removeFileByFileEntry(entry).catch(function () {
            // Ignore errors.
        }).then(function () {
            return _this.unmarkAsTreated(_this.getFileId(entry)).then(function () {
                _this.logger.debug('"Treated" mark removed from file: ' + entry.name);
            }).catch(function (error) {
                _this.logger.debug('Error deleting "treated" mark from file: ' + entry.name, error);
                return Promise.reject(error);
            });
        });
    };
    /**
     * Get the ID of a file for managing "treated" files.
     *
     * @param {any} entry FileEntry.
     * @return {string} File ID.
     */
    CoreSharedFilesProvider.prototype.getFileId = function (entry) {
        return __WEBPACK_IMPORTED_MODULE_8_ts_md5_dist_md5__["Md5"].hashAsciiStr(entry.name);
    };
    /**
     * Get the shared files stored in a site.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {string} [path] Path to search inside the site shared folder.
     * @param {string[]} [mimetypes] List of supported mimetypes. If undefined, all mimetypes supported.
     * @return {Promise<any[]>} Promise resolved with the files.
     */
    CoreSharedFilesProvider.prototype.getSiteSharedFiles = function (siteId, path, mimetypes) {
        var _this = this;
        var pathToGet = this.getSiteSharedFilesDirPath(siteId);
        if (path) {
            pathToGet = this.textUtils.concatenatePaths(pathToGet, path);
        }
        return this.fileProvider.getDirectoryContents(pathToGet).then(function (files) {
            if (mimetypes) {
                // Only show files with the right mimetype and the ones we cannot determine the mimetype.
                files = files.filter(function (file) {
                    var extension = _this.mimeUtils.getFileExtension(file.name), mimetype = _this.mimeUtils.getMimeType(extension);
                    return !mimetype || mimetypes.indexOf(mimetype) > -1;
                });
            }
            return files;
        }).catch(function () {
            // Directory not found, return empty list.
            return [];
        });
    };
    /**
     * Get the path to a site's shared files folder.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {string} Path.
     */
    CoreSharedFilesProvider.prototype.getSiteSharedFilesDirPath = function (siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.fileProvider.getSiteFolder(siteId) + '/' + CoreSharedFilesProvider_1.SHARED_FILES_FOLDER;
    };
    /**
     * Check if a file has been treated already.
     *
     * @param {string} fileId File ID.
     * @return {Promise<any>} Resolved if treated, rejected otherwise.
     */
    CoreSharedFilesProvider.prototype.isFileTreated = function (fileId) {
        return this.appDB.getRecord(this.SHARED_FILES_TABLE, { id: fileId });
    };
    /**
     * Mark a file as treated.
     *
     * @param {string} fileId File ID.
     * @return {Promise<any>} Promise resolved when marked.
     */
    CoreSharedFilesProvider.prototype.markAsTreated = function (fileId) {
        var _this = this;
        // Check if it's already marked.
        return this.isFileTreated(fileId).catch(function () {
            // Doesn't exist, insert it.
            return _this.appDB.insertRecord(_this.SHARED_FILES_TABLE, { id: fileId });
        });
    };
    /**
     * Store a file in a site's shared folder.
     *
     * @param {any} entry File entry.
     * @param {string} [newName] Name of the new file. If not defined, use original file's name.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}Promise resolved when done.
     */
    CoreSharedFilesProvider.prototype.storeFileInSite = function (entry, newName, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (!entry || !siteId) {
            return Promise.reject(null);
        }
        newName = newName || entry.name;
        var sharedFilesFolder = this.getSiteSharedFilesDirPath(siteId), newPath = this.textUtils.concatenatePaths(sharedFilesFolder, newName);
        // Create dir if it doesn't exist already.
        return this.fileProvider.createDir(sharedFilesFolder).then(function () {
            return _this.fileProvider.moveFile(entry.fullPath, newPath).then(function (newFile) {
                _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */].FILE_SHARED, { siteId: siteId, name: newName });
                return newFile;
            });
        });
    };
    /**
     * Unmark a file as treated.
     *
     * @param {string} fileId File ID.
     * @return {Promise<any>} Resolved when unmarked.
     */
    CoreSharedFilesProvider.prototype.unmarkAsTreated = function (fileId) {
        return this.appDB.deleteRecords(this.SHARED_FILES_TABLE, { id: fileId });
    };
    CoreSharedFilesProvider.SHARED_FILES_FOLDER = 'sharedfiles';
    CoreSharedFilesProvider = CoreSharedFilesProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_file__["a" /* CoreFileProvider */], __WEBPACK_IMPORTED_MODULE_1__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_7__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_utils_mimetype__["a" /* CoreMimetypeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_5__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */]])
    ], CoreSharedFilesProvider);
    return CoreSharedFilesProvider;
    var CoreSharedFilesProvider_1;
}());

//# sourceMappingURL=sharedfiles.js.map

/***/ }),

/***/ 26:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreConstants; });
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * Static class to contain all the core constants.
 */
var CoreConstants = /** @class */ (function () {
    function CoreConstants() {
    }
    CoreConstants.SECONDS_YEAR = 31536000;
    CoreConstants.SECONDS_WEEK = 604800;
    CoreConstants.SECONDS_DAY = 86400;
    CoreConstants.SECONDS_HOUR = 3600;
    CoreConstants.SECONDS_MINUTE = 60;
    CoreConstants.WIFI_DOWNLOAD_THRESHOLD = 104857600; // 100MB.
    CoreConstants.DOWNLOAD_THRESHOLD = 10485760; // 10MB.
    CoreConstants.DONT_SHOW_ERROR = 'CoreDontShowError';
    CoreConstants.NO_SITE_ID = 'NoSite';
    // Settings constants.
    CoreConstants.SETTINGS_RICH_TEXT_EDITOR = 'CoreSettingsRichTextEditor';
    CoreConstants.SETTINGS_NOTIFICATION_SOUND = 'CoreSettingsNotificationSound';
    CoreConstants.SETTINGS_SYNC_ONLY_ON_WIFI = 'CoreSettingsSyncOnlyOnWifi';
    // WS constants.
    CoreConstants.WS_TIMEOUT = 30000;
    CoreConstants.WS_PREFIX = 'local_mobile_';
    // Login constants.
    CoreConstants.LOGIN_SSO_CODE = 2; // SSO in browser window is required.
    CoreConstants.LOGIN_SSO_INAPP_CODE = 3; // SSO in embedded browser is required.
    CoreConstants.LOGIN_LAUNCH_DATA = 'CoreLoginLaunchData';
    // Download status constants.
    CoreConstants.DOWNLOADED = 'downloaded';
    CoreConstants.DOWNLOADING = 'downloading';
    CoreConstants.NOT_DOWNLOADED = 'notdownloaded';
    CoreConstants.OUTDATED = 'outdated';
    CoreConstants.NOT_DOWNLOADABLE = 'notdownloadable';
    return CoreConstants;
}());

//# sourceMappingURL=constants.js.map

/***/ }),

/***/ 268:
/***/ (function(module, exports) {

function webpackEmptyAsyncContext(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncatched exception popping up in devtools
	return Promise.resolve().then(function() {
		throw new Error("Cannot find module '" + req + "'.");
	});
}
webpackEmptyAsyncContext.keys = function() { return []; };
webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;
module.exports = webpackEmptyAsyncContext;
webpackEmptyAsyncContext.id = 268;

/***/ }),

/***/ 30:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFileProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_file__ = __webpack_require__(106);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__app__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_mimetype__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_text__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ionic_native_zip__ = __webpack_require__(213);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








/**
 * Factory to interact with the file system.
 */
var CoreFileProvider = /** @class */ (function () {
    function CoreFileProvider(logger, platform, file, appProvider, textUtils, zip, mimeUtils) {
        this.platform = platform;
        this.file = file;
        this.appProvider = appProvider;
        this.textUtils = textUtils;
        this.zip = zip;
        this.mimeUtils = mimeUtils;
        this.initialized = false;
        this.basePath = '';
        this.isHTMLAPI = false;
        this.logger = logger.getInstance('CoreFileProvider');
    }
    CoreFileProvider_1 = CoreFileProvider;
    /**
     * Sets basePath to use with HTML API. Reserved for core use.
     *
     * @param {string} path Base path to use.
     */
    CoreFileProvider.prototype.setHTMLBasePath = function (path) {
        this.isHTMLAPI = true;
        this.basePath = path;
    };
    /**
     * Checks if we're using HTML API.
     *
     * @return {boolean} True if uses HTML API, false otherwise.
     */
    CoreFileProvider.prototype.usesHTMLAPI = function () {
        return this.isHTMLAPI;
    };
    /**
     * Initialize basePath based on the OS if it's not initialized already.
     *
     * @return {Promise<void>} Promise to be resolved when the initialization is finished.
     */
    CoreFileProvider.prototype.init = function () {
        var _this = this;
        if (this.initialized) {
            return Promise.resolve();
        }
        return this.platform.ready().then(function () {
            if (_this.platform.is('android')) {
                _this.basePath = _this.file.externalApplicationStorageDirectory;
            }
            else if (_this.platform.is('ios')) {
                _this.basePath = _this.file.documentsDirectory;
            }
            else if (!_this.isAvailable() || _this.basePath === '') {
                _this.logger.error('Error getting device OS.');
                return Promise.reject(null);
            }
            _this.initialized = true;
            _this.logger.debug('FS initialized: ' + _this.basePath);
        });
    };
    /**
     * Check if the plugin is available.
     *
     * @return {boolean} Whether the plugin is available.
     */
    CoreFileProvider.prototype.isAvailable = function () {
        return typeof window.resolveLocalFileSystemURL !== 'undefined';
    };
    /**
     * Get a file.
     *
     * @param {string} path Relative path to the file.
     * @return {Promise<FileEntry>} Promise resolved when the file is retrieved.
     */
    CoreFileProvider.prototype.getFile = function (path) {
        var _this = this;
        return this.init().then(function () {
            _this.logger.debug('Get file: ' + path);
            return _this.file.resolveLocalFilesystemUrl(_this.addBasePathIfNeeded(path));
        }).then(function (entry) {
            return entry;
        });
    };
    /**
     * Get a directory.
     *
     * @param {string} path Relative path to the directory.
     * @return {Promise<DirectoryEntry>} Promise resolved when the directory is retrieved.
     */
    CoreFileProvider.prototype.getDir = function (path) {
        var _this = this;
        return this.init().then(function () {
            _this.logger.debug('Get directory: ' + path);
            return _this.file.resolveDirectoryUrl(_this.addBasePathIfNeeded(path));
        });
    };
    /**
     * Get site folder path.
     *
     * @param {string} siteId Site ID.
     * @return {string} Site folder path.
     */
    CoreFileProvider.prototype.getSiteFolder = function (siteId) {
        return CoreFileProvider_1.SITESFOLDER + '/' + siteId;
    };
    /**
     * Create a directory or a file.
     *
     * @param {boolean} isDirectory True if a directory should be created, false if it should create a file.
     * @param {string} path Relative path to the dir/file.
     * @param {boolean} [failIfExists] True if it should fail if the dir/file exists, false otherwise.
     * @param {string} [base] Base path to create the dir/file in. If not set, use basePath.
     * @return {Promise<any>} Promise to be resolved when the dir/file is created.
     */
    CoreFileProvider.prototype.create = function (isDirectory, path, failIfExists, base) {
        var _this = this;
        return this.init().then(function () {
            // Remove basePath if it's in the path.
            path = _this.removeStartingSlash(path.replace(_this.basePath, ''));
            base = base || _this.basePath;
            if (path.indexOf('/') == -1) {
                if (isDirectory) {
                    _this.logger.debug('Create dir ' + path + ' in ' + base);
                    return _this.file.createDir(base, path, !failIfExists);
                }
                else {
                    _this.logger.debug('Create file ' + path + ' in ' + base);
                    return _this.file.createFile(base, path, !failIfExists);
                }
            }
            else {
                // The file plugin doesn't allow creating more than 1 level at a time (e.g. tmp/folder).
                // We need to create them 1 by 1.
                var firstDir_1 = path.substr(0, path.indexOf('/')), restOfPath_1 = path.substr(path.indexOf('/') + 1);
                _this.logger.debug('Create dir ' + firstDir_1 + ' in ' + base);
                return _this.file.createDir(base, firstDir_1, true).then(function (newDirEntry) {
                    return _this.create(isDirectory, restOfPath_1, failIfExists, newDirEntry.toURL());
                }).catch(function (error) {
                    _this.logger.error('Error creating directory ' + firstDir_1 + ' in ' + base);
                    return Promise.reject(error);
                });
            }
        });
    };
    /**
     * Create a directory.
     *
     * @param {string} path Relative path to the directory.
     * @param {boolean} [failIfExists] True if it should fail if the directory exists, false otherwise.
     * @return {Promise<DirectoryEntry>} Promise to be resolved when the directory is created.
     */
    CoreFileProvider.prototype.createDir = function (path, failIfExists) {
        return this.create(true, path, failIfExists);
    };
    /**
     * Create a file.
     *
     * @param {string} path Relative path to the file.
     * @param {boolean} [failIfExists] True if it should fail if the file exists, false otherwise..
     * @return {Promise<FileEntry>} Promise to be resolved when the file is created.
     */
    CoreFileProvider.prototype.createFile = function (path, failIfExists) {
        return this.create(false, path, failIfExists);
    };
    /**
     * Removes a directory and all its contents.
     *
     * @param {string} path Relative path to the directory.
     * @return {Promise<any>} Promise to be resolved when the directory is deleted.
     */
    CoreFileProvider.prototype.removeDir = function (path) {
        var _this = this;
        return this.init().then(function () {
            // Remove basePath if it's in the path.
            path = _this.removeStartingSlash(path.replace(_this.basePath, ''));
            _this.logger.debug('Remove directory: ' + path);
            return _this.file.removeRecursively(_this.basePath, path);
        });
    };
    /**
     * Removes a file and all its contents.
     *
     * @param {string} path Relative path to the file.
     * @return {Promise<any>} Promise to be resolved when the file is deleted.
     */
    CoreFileProvider.prototype.removeFile = function (path) {
        var _this = this;
        return this.init().then(function () {
            // Remove basePath if it's in the path.
            path = _this.removeStartingSlash(path.replace(_this.basePath, ''));
            _this.logger.debug('Remove file: ' + path);
            return _this.file.removeFile(_this.basePath, path);
        });
    };
    /**
     * Removes a file given its FileEntry.
     *
     * @param {FileEntry} fileEntry File Entry.
     * @return {Promise<any>} Promise resolved when the file is deleted.
     */
    CoreFileProvider.prototype.removeFileByFileEntry = function (fileEntry) {
        return new Promise(function (resolve, reject) {
            fileEntry.remove(resolve, reject);
        });
    };
    /**
     * Retrieve the contents of a directory (not subdirectories).
     *
     * @param {string} path Relative path to the directory.
     * @return {Promise<any>} Promise to be resolved when the contents are retrieved.
     */
    CoreFileProvider.prototype.getDirectoryContents = function (path) {
        var _this = this;
        return this.init().then(function () {
            // Remove basePath if it's in the path.
            path = _this.removeStartingSlash(path.replace(_this.basePath, ''));
            _this.logger.debug('Get contents of dir: ' + path);
            return _this.file.listDir(_this.basePath, path);
        });
    };
    /**
     * Calculate the size of a directory or a file.
     *
     * @param {any} entry Directory or file.
     * @return {Promise<number>} Promise to be resolved when the size is calculated.
     */
    CoreFileProvider.prototype.getSize = function (entry) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (entry.isDirectory) {
                var directoryReader = entry.createReader();
                directoryReader.readEntries(function (entries) {
                    var promises = [];
                    for (var i = 0; i < entries.length; i++) {
                        promises.push(_this.getSize(entries[i]));
                    }
                    Promise.all(promises).then(function (sizes) {
                        var directorySize = 0;
                        for (var i = 0; i < sizes.length; i++) {
                            var fileSize = parseInt(sizes[i]);
                            if (isNaN(fileSize)) {
                                reject();
                                return;
                            }
                            directorySize += fileSize;
                        }
                        resolve(directorySize);
                    }, reject);
                }, reject);
            }
            else if (entry.isFile) {
                entry.file(function (file) {
                    resolve(file.size);
                }, reject);
            }
        });
    };
    /**
     * Calculate the size of a directory.
     *
     * @param {string} path Relative path to the directory.
     * @return {Promise<number>} Promise to be resolved when the size is calculated.
     */
    CoreFileProvider.prototype.getDirectorySize = function (path) {
        var _this = this;
        // Remove basePath if it's in the path.
        path = this.removeStartingSlash(path.replace(this.basePath, ''));
        this.logger.debug('Get size of dir: ' + path);
        return this.getDir(path).then(function (dirEntry) {
            return _this.getSize(dirEntry);
        });
    };
    /**
     * Calculate the size of a file.
     *
     * @param {string} path Relative path to the file.
     * @return {Promise<number>} Promise to be resolved when the size is calculated.
     */
    CoreFileProvider.prototype.getFileSize = function (path) {
        var _this = this;
        // Remove basePath if it's in the path.
        path = this.removeStartingSlash(path.replace(this.basePath, ''));
        this.logger.debug('Get size of file: ' + path);
        return this.getFile(path).then(function (fileEntry) {
            return _this.getSize(fileEntry);
        });
    };
    /**
     * Get file object from a FileEntry.
     *
     * @param {FileEntry} path Relative path to the file.
     * @return {Promise<any>} Promise to be resolved when the file is retrieved.
     */
    CoreFileProvider.prototype.getFileObjectFromFileEntry = function (entry) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.logger.debug('Get file object of: ' + entry.fullPath);
            entry.file(resolve, reject);
        });
    };
    /**
     * Calculate the free space in the disk.
     *
     * @return {Promise<number>} Promise resolved with the estimated free space in bytes.
     */
    CoreFileProvider.prototype.calculateFreeSpace = function () {
        return this.file.getFreeDiskSpace().then(function (size) {
            return size; // GetFreeDiskSpace returns KB.
        });
    };
    /**
     * Normalize a filename that usually comes URL encoded.
     *
     * @param {string} filename The file name.
     * @return {string} The file name normalized.
     */
    CoreFileProvider.prototype.normalizeFileName = function (filename) {
        filename = this.textUtils.decodeURIComponent(filename);
        return filename;
    };
    /**
     * Read a file from local file system.
     *
     * @param {string} path Relative path to the file.
     * @param {number} [format=FORMATTEXT] Format to read the file. Must be one of:
     *                                  FORMATTEXT
     *                                  FORMATDATAURL
     *                                  FORMATBINARYSTRING
     *                                  FORMATARRAYBUFFER
     * @return {Promise<any>} Promise to be resolved when the file is read.
     */
    CoreFileProvider.prototype.readFile = function (path, format) {
        if (format === void 0) { format = CoreFileProvider_1.FORMATTEXT; }
        // Remove basePath if it's in the path.
        path = this.removeStartingSlash(path.replace(this.basePath, ''));
        this.logger.debug('Read file ' + path + ' with format ' + format);
        switch (format) {
            case CoreFileProvider_1.FORMATDATAURL:
                return this.file.readAsDataURL(this.basePath, path);
            case CoreFileProvider_1.FORMATBINARYSTRING:
                return this.file.readAsBinaryString(this.basePath, path);
            case CoreFileProvider_1.FORMATARRAYBUFFER:
                return this.file.readAsArrayBuffer(this.basePath, path);
            default:
                return this.file.readAsText(this.basePath, path);
        }
    };
    /**
     * Read file contents from a file data object.
     *
     * @param {any} fileData File's data.
     * @param {number} [format=FORMATTEXT] Format to read the file. Must be one of:
     *                                  FORMATTEXT
     *                                  FORMATDATAURL
     *                                  FORMATBINARYSTRING
     *                                  FORMATARRAYBUFFER
     * @return {Promise<any>} Promise to be resolved when the file is read.
     */
    CoreFileProvider.prototype.readFileData = function (fileData, format) {
        if (format === void 0) { format = CoreFileProvider_1.FORMATTEXT; }
        format = format || CoreFileProvider_1.FORMATTEXT;
        this.logger.debug('Read file from file data with format ' + format);
        return new Promise(function (resolve, reject) {
            var reader = new FileReader();
            reader.onloadend = function (evt) {
                var target = evt.target; // Convert to <any> to be able to use non-standard properties.
                if (target.result !== undefined || target.result !== null) {
                    resolve(target.result);
                }
                else if (target.error !== undefined || target.error !== null) {
                    reject(target.error);
                }
                else {
                    reject({ code: null, message: 'READER_ONLOADEND_ERR' });
                }
            };
            switch (format) {
                case CoreFileProvider_1.FORMATDATAURL:
                    reader.readAsDataURL(fileData);
                    break;
                case CoreFileProvider_1.FORMATBINARYSTRING:
                    reader.readAsBinaryString(fileData);
                    break;
                case CoreFileProvider_1.FORMATARRAYBUFFER:
                    reader.readAsArrayBuffer(fileData);
                    break;
                default:
                    reader.readAsText(fileData);
            }
        });
    };
    /**
     * Writes some data in a file.
     *
     * @param {string} path Relative path to the file.
     * @param {any} data Data to write.
     * @return {Promise<any>} Promise to be resolved when the file is written.
     */
    CoreFileProvider.prototype.writeFile = function (path, data) {
        var _this = this;
        return this.init().then(function () {
            // Remove basePath if it's in the path.
            path = _this.removeStartingSlash(path.replace(_this.basePath, ''));
            _this.logger.debug('Write file: ' + path);
            // Create file (and parent folders) to prevent errors.
            return _this.createFile(path).then(function (fileEntry) {
                if (_this.isHTMLAPI && !_this.appProvider.isDesktop() &&
                    (typeof data == 'string' || data.toString() == '[object ArrayBuffer]')) {
                    // We need to write Blobs.
                    var type = _this.mimeUtils.getMimeType(_this.mimeUtils.getFileExtension(path));
                    data = new Blob([data], { type: type || 'text/plain' });
                }
                return _this.file.writeFile(_this.basePath, path, data, { replace: true }).then(function () {
                    return fileEntry;
                });
            });
        });
    };
    /**
     * Gets a file that might be outside the app's folder.
     *
     * @param {string} fullPath Absolute path to the file.
     * @return {Promise<FileEntry>} Promise to be resolved when the file is retrieved.
     */
    CoreFileProvider.prototype.getExternalFile = function (fullPath) {
        return this.file.resolveLocalFilesystemUrl(fullPath).then(function (entry) {
            return entry;
        });
    };
    /**
     * Removes a file that might be outside the app's folder.
     *
     * @param {string} fullPath Absolute path to the file.
     * @return {Promise<any>} Promise to be resolved when the file is removed.
     */
    CoreFileProvider.prototype.removeExternalFile = function (fullPath) {
        var directory = fullPath.substring(0, fullPath.lastIndexOf('/')), filename = fullPath.substr(fullPath.lastIndexOf('/') + 1);
        return this.file.removeFile(directory, filename);
    };
    /**
     * Get the base path where the application files are stored.
     *
     * @return {Promise<string>} Promise to be resolved when the base path is retrieved.
     */
    CoreFileProvider.prototype.getBasePath = function () {
        var _this = this;
        return this.init().then(function () {
            if (_this.basePath.slice(-1) == '/') {
                return _this.basePath;
            }
            else {
                return _this.basePath + '/';
            }
        });
    };
    /**
     * Get the base path where the application files are stored in the format to be used for downloads.
     * iOS: Internal URL (cdvfile://).
     * Others: basePath (file://)
     *
     * @return {Promise<string>} Promise to be resolved when the base path is retrieved.
     */
    CoreFileProvider.prototype.getBasePathToDownload = function () {
        var _this = this;
        return this.init().then(function () {
            if (_this.platform.is('ios')) {
                // In iOS we want the internal URL (cdvfile://localhost/persistent/...).
                return _this.file.resolveDirectoryUrl(_this.basePath).then(function (dirEntry) {
                    return dirEntry.toInternalURL();
                });
            }
            else {
                // In the other platforms we use the basePath as it is (file://...).
                return _this.basePath;
            }
        });
    };
    /**
     * Get the base path where the application files are stored. Returns the value instantly, without waiting for it to be ready.
     *
     * @return {string} Base path. If the service hasn't been initialized it will return an invalid value.
     */
    CoreFileProvider.prototype.getBasePathInstant = function () {
        if (!this.basePath) {
            return this.basePath;
        }
        else if (this.basePath.slice(-1) == '/') {
            return this.basePath;
        }
        else {
            return this.basePath + '/';
        }
    };
    /**
     * Move a file.
     *
     * @param {string} [originalPath] Path to the file to move.
     * @param {string} [newPath] New path of the file.
     * @return {Promise<any>} Promise resolved when the entry is moved.
     */
    CoreFileProvider.prototype.moveFile = function (originalPath, newPath) {
        var _this = this;
        return this.init().then(function () {
            // Remove basePath if it's in the paths.
            originalPath = _this.removeStartingSlash(originalPath.replace(_this.basePath, ''));
            newPath = _this.removeStartingSlash(newPath.replace(_this.basePath, ''));
            if (_this.isHTMLAPI) {
                // In Cordova API we need to calculate the longest matching path to make it work.
                // The function this.file.moveFile('a/', 'b/c.ext', 'a/', 'b/d.ext') doesn't work.
                // The function this.file.moveFile('a/b/', 'c.ext', 'a/b/', 'd.ext') works.
                var dirsA = originalPath.split('/'), dirsB = newPath.split('/');
                var commonPath = _this.basePath;
                for (var i = 0; i < dirsA.length; i++) {
                    var dir = dirsA[i];
                    if (dirsB[i] === dir) {
                        // Found a common folder, add it to common path and remove it from each specific path.
                        dir = dir + '/';
                        commonPath = _this.textUtils.concatenatePaths(commonPath, dir);
                        originalPath = originalPath.replace(dir, '');
                        newPath = newPath.replace(dir, '');
                    }
                    else {
                        // Folder doesn't match, stop searching.
                        break;
                    }
                }
                return _this.file.moveFile(commonPath, originalPath, commonPath, newPath);
            }
            else {
                return _this.file.moveFile(_this.basePath, originalPath, _this.basePath, newPath);
            }
        });
    };
    /**
     * Copy a file.
     *
     * @param {string} from Path to the file to move.
     * @param {string} to New path of the file.
     * @return {Promise<any>} Promise resolved when the entry is copied.
     */
    CoreFileProvider.prototype.copyFile = function (from, to) {
        var _this = this;
        var fromFileAndDir, toFileAndDir;
        return this.init().then(function () {
            // Paths cannot start with "/". Remove basePath if present.
            from = _this.removeStartingSlash(from.replace(_this.basePath, ''));
            to = _this.removeStartingSlash(to.replace(_this.basePath, ''));
            fromFileAndDir = _this.getFileAndDirectoryFromPath(from);
            toFileAndDir = _this.getFileAndDirectoryFromPath(to);
            if (toFileAndDir.directory) {
                // Create the target directory if it doesn't exist.
                return _this.createDir(toFileAndDir.directory);
            }
        }).then(function () {
            if (_this.isHTMLAPI) {
                // In HTML API, the file name cannot include a directory, otherwise it fails.
                var fromDir = _this.textUtils.concatenatePaths(_this.basePath, fromFileAndDir.directory), toDir = _this.textUtils.concatenatePaths(_this.basePath, toFileAndDir.directory);
                return _this.file.copyFile(fromDir, fromFileAndDir.name, toDir, toFileAndDir.name);
            }
            else {
                return _this.file.copyFile(_this.basePath, from, _this.basePath, to);
            }
        });
    };
    /**
     * Extract the file name and directory from a given path.
     *
     * @param {string} path Path to be extracted.
     * @return {any} Plain object containing the file name and directory.
     * @description
     * file.pdf         -> directory: '', name: 'file.pdf'
     * /file.pdf        -> directory: '', name: 'file.pdf'
     * path/file.pdf    -> directory: 'path', name: 'file.pdf'
     * path/            -> directory: 'path', name: ''
     * path             -> directory: '', name: 'path'
     */
    CoreFileProvider.prototype.getFileAndDirectoryFromPath = function (path) {
        var file = {
            directory: '',
            name: ''
        };
        file.directory = path.substring(0, path.lastIndexOf('/'));
        file.name = path.substr(path.lastIndexOf('/') + 1);
        return file;
    };
    /**
     * Get the internal URL of a file.
     *
     * @param {FileEntry} fileEntry File Entry.
     * @return {string} Internal URL.
     */
    CoreFileProvider.prototype.getInternalURL = function (fileEntry) {
        if (!fileEntry.toInternalURL) {
            // File doesn't implement toInternalURL, use toURL.
            return fileEntry.toURL();
        }
        return fileEntry.toInternalURL();
    };
    /**
     * Adds the basePath to a path if it doesn't have it already.
     *
     * @param {string} path Path to treat.
     * @return {string} Path with basePath added.
     */
    CoreFileProvider.prototype.addBasePathIfNeeded = function (path) {
        if (path.indexOf(this.basePath) > -1) {
            return path;
        }
        else {
            return this.textUtils.concatenatePaths(this.basePath, path);
        }
    };
    /**
     * Remove the base path from a path. If basePath isn't found, return false.
     *
     * @param {string} path Path to treat.
     * @return {string} Path without basePath if basePath was found, undefined otherwise.
     */
    CoreFileProvider.prototype.removeBasePath = function (path) {
        if (path.indexOf(this.basePath) > -1) {
            return path.replace(this.basePath, '');
        }
    };
    /**
     * Unzips a file.
     *
     * @param {string} path Path to the ZIP file.
     * @param {string} [destFolder] Path to the destination folder. If not defined, a new folder will be created with the
     *                     same location and name as the ZIP file (without extension).
     * @param {Function} [onProgress] Function to call on progress.
     * @return {Promise<any>} Promise resolved when the file is unzipped.
     */
    CoreFileProvider.prototype.unzipFile = function (path, destFolder, onProgress) {
        var _this = this;
        // Get the source file.
        return this.getFile(path).then(function (fileEntry) {
            // If destFolder is not set, use same location as ZIP file. We need to use absolute paths (including basePath).
            destFolder = _this.addBasePathIfNeeded(destFolder || _this.mimeUtils.removeExtension(path));
            return _this.zip.unzip(fileEntry.toURL(), destFolder, onProgress);
        });
    };
    /**
     * Search a string or regexp in a file contents and replace it. The result is saved in the same file.
     *
     * @param {string} path Path to the file.
     * @param {string|RegExp} search Value to search.
     * @param {string} newValue New value.
     * @return {Promise<any>} Promise resolved in success.
     */
    CoreFileProvider.prototype.replaceInFile = function (path, search, newValue) {
        var _this = this;
        return this.readFile(path).then(function (content) {
            if (typeof content == 'undefined' || content === null || !content.replace) {
                return Promise.reject(null);
            }
            if (content.match(search)) {
                content = content.replace(search, newValue);
                return _this.writeFile(path, content);
            }
        });
    };
    /**
     * Get a file/dir metadata given the file's entry.
     *
     * @param {Entry} fileEntry FileEntry retrieved from getFile or similar.
     * @return {Promise<any>} Promise resolved with metadata.
     */
    CoreFileProvider.prototype.getMetadata = function (fileEntry) {
        if (!fileEntry || !fileEntry.getMetadata) {
            return Promise.reject(null);
        }
        return new Promise(function (resolve, reject) {
            fileEntry.getMetadata(resolve, reject);
        });
    };
    /**
     * Get a file/dir metadata given the path.
     *
     * @param {string} path Path to the file/dir.
     * @param {boolean} [isDir] True if directory, false if file.
     * @return {Promise<any>} Promise resolved with metadata.
     */
    CoreFileProvider.prototype.getMetadataFromPath = function (path, isDir) {
        var _this = this;
        var promise;
        if (isDir) {
            promise = this.getDir(path);
        }
        else {
            promise = this.getFile(path);
        }
        return promise.then(function (entry) {
            return _this.getMetadata(entry);
        });
    };
    /**
     * Remove the starting slash of a path if it's there. E.g. '/sites/filepool' -> 'sites/filepool'.
     *
     * @param {string} path Path.
     * @return {string} Path without a slash in the first position.
     */
    CoreFileProvider.prototype.removeStartingSlash = function (path) {
        if (path[0] == '/') {
            return path.substr(1);
        }
        return path;
    };
    /**
     * Convenience function to copy or move an external file.
     *
     * @param {string} from Absolute path to the file to copy/move.
     * @param {string} to Relative new path of the file (inside the app folder).
     * @param {boolean} copy True to copy, false to move.
     * @return {Promise<any>} Promise resolved when the entry is copied/moved.
     */
    CoreFileProvider.prototype.copyOrMoveExternalFile = function (from, to, copy) {
        var _this = this;
        // Get the file to copy/move.
        return this.getExternalFile(from).then(function (fileEntry) {
            // Create the destination dir if it doesn't exist.
            var dirAndFile = _this.getFileAndDirectoryFromPath(to);
            return _this.createDir(dirAndFile.directory).then(function (dirEntry) {
                // Now copy/move the file.
                return new Promise(function (resolve, reject) {
                    if (copy) {
                        fileEntry.copyTo(dirEntry, dirAndFile.name, resolve, reject);
                    }
                    else {
                        fileEntry.moveTo(dirEntry, dirAndFile.name, resolve, reject);
                    }
                });
            });
        });
    };
    /**
     * Copy a file from outside of the app folder to somewhere inside the app folder.
     *
     * @param {string} from Absolute path to the file to copy.
     * @param {string} to Relative new path of the file (inside the app folder).
     * @return {Promise<any>} Promise resolved when the entry is copied.
     */
    CoreFileProvider.prototype.copyExternalFile = function (from, to) {
        return this.copyOrMoveExternalFile(from, to, true);
    };
    /**
     * Move a file from outside of the app folder to somewhere inside the app folder.
     *
     * @param {string} from Absolute path to the file to move.
     * @param {string} to Relative new path of the file (inside the app folder).
     * @return {Promise<any>} Promise resolved when the entry is moved.
     */
    CoreFileProvider.prototype.moveExternalFile = function (from, to) {
        return this.copyOrMoveExternalFile(from, to, false);
    };
    /**
     * Get a unique file name inside a folder, adding numbers to the file name if needed.
     *
     * @param {string} dirPath Path to the destination folder.
     * @param {string} fileName File name that wants to be used.
     * @param {string} [defaultExt] Default extension to use if no extension found in the file.
     * @return {Promise<string>} Promise resolved with the unique file name.
     */
    CoreFileProvider.prototype.getUniqueNameInFolder = function (dirPath, fileName, defaultExt) {
        var _this = this;
        // Get existing files in the folder.
        return this.getDirectoryContents(dirPath).then(function (entries) {
            var files = {};
            var num = 1, fileNameWithoutExtension = _this.mimeUtils.removeExtension(fileName), extension = _this.mimeUtils.getFileExtension(fileName) || defaultExt, newName;
            // Clean the file name.
            fileNameWithoutExtension = _this.textUtils.removeSpecialCharactersForFiles(_this.textUtils.decodeURIComponent(fileNameWithoutExtension));
            // Index the files by name.
            entries.forEach(function (entry) {
                files[entry.name] = entry;
            });
            // Format extension.
            if (extension) {
                extension = '.' + extension;
            }
            else {
                extension = '';
            }
            newName = fileNameWithoutExtension + extension;
            if (typeof files[newName] == 'undefined') {
                // No file with the same name.
                return newName;
            }
            else {
                // Repeated name. Add a number until we find a free name.
                do {
                    newName = fileNameWithoutExtension + '(' + num + ')' + extension;
                    num++;
                } while (typeof files[newName] != 'undefined');
                // Ask the user what he wants to do.
                return newName;
            }
        }).catch(function () {
            // Folder doesn't exist, name is unique. Clean it and return it.
            return _this.textUtils.removeSpecialCharactersForFiles(_this.textUtils.decodeURIComponent(fileName));
        });
    };
    /**
     * Remove app temporary folder.
     *
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreFileProvider.prototype.clearTmpFolder = function () {
        return this.removeDir(CoreFileProvider_1.TMPFOLDER);
    };
    /**
     * Given a folder path and a list of used files, remove all the files of the folder that aren't on the list of used files.
     *
     * @param {string} dirPath Folder path.
     * @param {any[]} files List of used files.
     * @return {Promise<any>} Promise resolved when done, rejected if failure.
     */
    CoreFileProvider.prototype.removeUnusedFiles = function (dirPath, files) {
        var _this = this;
        // Get the directory contents.
        return this.getDirectoryContents(dirPath).then(function (contents) {
            if (!contents.length) {
                return;
            }
            var filesMap = {}, promises = [];
            // Index the received files by fullPath and ignore the invalid ones.
            files.forEach(function (file) {
                if (file.fullPath) {
                    filesMap[file.fullPath] = file;
                }
            });
            // Check which of the content files aren't used anymore and delete them.
            contents.forEach(function (file) {
                if (!filesMap[file.fullPath]) {
                    // File isn't used, delete it.
                    promises.push(_this.removeFileByFileEntry(file));
                }
            });
            return Promise.all(promises);
        }).catch(function () {
            // Ignore errors, maybe it doesn't exist.
        });
    };
    /**
     * Check if a file is inside the app's folder.
     *
     * @param {string} path The absolute path of the file to check.
     * @return {boolean} Whether the file is in the app's folder.
     */
    CoreFileProvider.prototype.isFileInAppFolder = function (path) {
        return path.indexOf(this.basePath) != -1;
    };
    // Formats to read a file.
    CoreFileProvider.FORMATTEXT = 0;
    CoreFileProvider.FORMATDATAURL = 1;
    CoreFileProvider.FORMATBINARYSTRING = 2;
    CoreFileProvider.FORMATARRAYBUFFER = 3;
    // Folders.
    CoreFileProvider.SITESFOLDER = 'sites';
    CoreFileProvider.TMPFOLDER = 'tmp';
    CoreFileProvider = CoreFileProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */], __WEBPACK_IMPORTED_MODULE_2__ionic_native_file__["a" /* File */], __WEBPACK_IMPORTED_MODULE_3__app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_6__utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_7__ionic_native_zip__["a" /* Zip */], __WEBPACK_IMPORTED_MODULE_5__utils_mimetype__["a" /* CoreMimetypeUtilsProvider */]])
    ], CoreFileProvider);
    return CoreFileProvider;
    var CoreFileProvider_1;
}());

//# sourceMappingURL=file.js.map

/***/ }),

/***/ 312:
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"../addon/badges/pages/issued-badge/issued-badge.module": [
		1152,
		38
	],
	"../addon/badges/pages/user-badges/user-badges.module": [
		1153,
		37
	],
	"../addon/calendar/pages/event/event.module": [
		1154,
		36
	],
	"../addon/calendar/pages/list/list.module": [
		1155,
		35
	],
	"../addon/calendar/pages/settings/settings.module": [
		1156,
		34
	],
	"../addon/files/pages/list/list.module": [
		1157,
		33
	],
	"../components/split-view/placeholder/placeholder.module": [
		1158,
		32
	],
	"../core/contentlinks/pages/choose-site/choose-site.module": [
		1159,
		31
	],
	"../core/course/pages/section/section.module": [
		1161,
		3
	],
	"../core/course/pages/unsupported-module/unsupported-module.module": [
		1160,
		2
	],
	"../core/courses/pages/available-courses/available-courses.module": [
		1162,
		7
	],
	"../core/courses/pages/categories/categories.module": [
		1163,
		6
	],
	"../core/courses/pages/course-preview/course-preview.module": [
		1165,
		30
	],
	"../core/courses/pages/my-courses/my-courses.module": [
		1164,
		5
	],
	"../core/courses/pages/my-overview/my-overview.module": [
		1167,
		0
	],
	"../core/courses/pages/search/search.module": [
		1166,
		4
	],
	"../core/courses/pages/self-enrol-password/self-enrol-password.module": [
		1168,
		29
	],
	"../core/emulator/pages/capture-media/capture-media.module": [
		1169,
		28
	],
	"../core/login/pages/credentials/credentials.module": [
		1170,
		27
	],
	"../core/login/pages/email-signup/email-signup.module": [
		1173,
		26
	],
	"../core/login/pages/forgotten-password/forgotten-password.module": [
		1175,
		25
	],
	"../core/login/pages/init/init.module": [
		1171,
		24
	],
	"../core/login/pages/reconnect/reconnect.module": [
		1172,
		23
	],
	"../core/login/pages/site-error/site-error.module": [
		1174,
		22
	],
	"../core/login/pages/site-help/site-help.module": [
		1177,
		21
	],
	"../core/login/pages/site-policy/site-policy.module": [
		1176,
		20
	],
	"../core/login/pages/site/site.module": [
		1178,
		19
	],
	"../core/login/pages/sites/sites.module": [
		1179,
		18
	],
	"../core/mainmenu/pages/menu/menu.module": [
		1180,
		17
	],
	"../core/mainmenu/pages/more/more.module": [
		1181,
		16
	],
	"../core/sharedfiles/pages/choose-site/choose-site.module": [
		1182,
		15
	],
	"../core/sharedfiles/pages/list/list.module": [
		1183,
		14
	],
	"../core/sitehome/pages/index/index.module": [
		1184,
		1
	],
	"../core/user/pages/about/about.module": [
		1185,
		13
	],
	"../core/user/pages/participants/participants.module": [
		1187,
		12
	],
	"../core/user/pages/profile/profile.module": [
		1186,
		11
	],
	"../core/viewer/pages/iframe/iframe.module": [
		1188,
		10
	],
	"../core/viewer/pages/image/image.module": [
		1189,
		9
	],
	"../core/viewer/pages/text/text.module": [
		1190,
		8
	]
};
function webpackAsyncContext(req) {
	var ids = map[req];
	if(!ids)
		return Promise.reject(new Error("Cannot find module '" + req + "'."));
	return __webpack_require__.e(ids[1]).then(function() {
		return __webpack_require__(ids[0]);
	});
};
webpackAsyncContext.keys = function webpackAsyncContextKeys() {
	return Object.keys(map);
};
webpackAsyncContext.id = 312;
module.exports = webpackAsyncContext;

/***/ }),

/***/ 36:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreUrlUtilsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lang__ = __webpack_require__(101);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/*
 * "Utils" service with helper functions for URLs.
 */
var CoreUrlUtilsProvider = /** @class */ (function () {
    function CoreUrlUtilsProvider(langProvider) {
        this.langProvider = langProvider;
    }
    /**
     * Add or remove 'www' from a URL. The url needs to have http or https protocol.
     *
     * @param {string} url URL to modify.
     * @return {string} Modified URL.
     */
    CoreUrlUtilsProvider.prototype.addOrRemoveWWW = function (url) {
        if (url) {
            if (url.match(/http(s)?:\/\/www\./)) {
                // Already has www. Remove it.
                url = url.replace('www.', '');
            }
            else {
                url = url.replace('https://', 'https://www.');
                url = url.replace('http://', 'http://www.');
            }
        }
        return url;
    };
    /**
     * Extracts the parameters from a URL and stores them in an object.
     *
     * @param {string} url URL to treat.
     * @return {any} Object with the params.
     */
    CoreUrlUtilsProvider.prototype.extractUrlParams = function (url) {
        var regex = /[?&]+([^=&]+)=?([^&]*)?/gi, params = {};
        url.replace(regex, function (match, key, value) {
            params[key] = typeof value != 'undefined' ? value : '';
            return match;
        });
        return params;
    };
    /**
     * Generic function for adding the wstoken to Moodle urls and for pointing to the correct script.
     * For download remote files from Moodle we need to use the special /webservice/pluginfile passing
     * the ws token as a get parameter.
     *
     * @param {string} url The url to be fixed.
     * @param {string} token Token to use.
     * @return {string} Fixed URL.
     */
    CoreUrlUtilsProvider.prototype.fixPluginfileURL = function (url, token) {
        if (!url || !token) {
            return '';
        }
        // First check if we need to fix this url or is already fixed.
        if (url.indexOf('token=') != -1) {
            return url;
        }
        // Check if is a valid URL (contains the pluginfile endpoint).
        if (!this.isPluginFileUrl(url)) {
            return url;
        }
        // In which way the server is serving the files? Are we using slash parameters?
        if (url.indexOf('?file=') != -1 || url.indexOf('?forcedownload=') != -1 || url.indexOf('?rev=') != -1) {
            url += '&';
        }
        else {
            url += '?';
        }
        // Always send offline=1 (for external repositories). It shouldn't cause problems for local files or old Moodles.
        url += 'token=' + token + '&offline=1';
        // Some webservices returns directly the correct download url, others not.
        if (url.indexOf('/webservice/pluginfile') == -1) {
            url = url.replace('/pluginfile', '/webservice/pluginfile');
        }
        return url;
    };
    /**
     * Formats a URL, trim, lowercase, etc...
     *
     * @param {string} url The url to be formatted.
     * @return {string} Fromatted url.
     */
    CoreUrlUtilsProvider.prototype.formatURL = function (url) {
        url = url.trim();
        // Check if the URL starts by http or https.
        if (!/^http(s)?\:\/\/.*/i.test(url)) {
            // Test first allways https.
            url = 'https://' + url;
        }
        // http allways in lowercase.
        url = url.replace(/^http/i, 'http');
        url = url.replace(/^https/i, 'https');
        // Replace last slash.
        url = url.replace(/\/$/, '');
        return url;
    };
    /**
     * Returns the URL to the documentation of the app, based on Moodle version and current language.
     *
     * @param {string} [release] Moodle release.
     * @param {string} [page=Mobile_app] Docs page to go to.
     * @return {Promise<string>} Promise resolved with the Moodle docs URL.
     */
    CoreUrlUtilsProvider.prototype.getDocsUrl = function (release, page) {
        if (page === void 0) { page = 'Mobile_app'; }
        var docsUrl = 'https://docs.moodle.org/en/' + page;
        if (typeof release != 'undefined') {
            var version = release.substr(0, 3).replace('.', '');
            // Check is a valid number.
            if (parseInt(version) >= 24) {
                // Append release number.
                docsUrl = docsUrl.replace('https://docs.moodle.org/', 'https://docs.moodle.org/' + version + '/');
            }
        }
        return this.langProvider.getCurrentLanguage().then(function (lang) {
            return docsUrl.replace('/en/', '/' + lang + '/');
        }).catch(function () {
            return docsUrl;
        });
    };
    /**
     * Given a URL, returns what's after the last '/' without params.
     * Example:
     * http://mysite.com/a/course.html?id=1 -> course.html
     *
     * @param {string} url URL to treat.
     * @return {string} Last file without params.
     */
    CoreUrlUtilsProvider.prototype.getLastFileWithoutParams = function (url) {
        var filename = url.substr(url.lastIndexOf('/') + 1);
        if (filename.indexOf('?') != -1) {
            filename = filename.substr(0, filename.indexOf('?'));
        }
        return filename;
    };
    /**
     * Get the protocol from a URL.
     * E.g. http://www.google.com returns 'http'.
     *
     * @param {string} url URL to treat.
     * @return {string} Protocol, undefined if no protocol found.
     */
    CoreUrlUtilsProvider.prototype.getUrlProtocol = function (url) {
        if (!url) {
            return;
        }
        var matches = url.match(/^([^\/:\.\?]*):\/\//);
        if (matches && matches[1]) {
            return matches[1];
        }
    };
    /**
     * Get the scheme from a URL. Please notice that, if a URL has protocol, it will return the protocol.
     * E.g. javascript:doSomething() returns 'javascript'.
     *
     * @param {string} url URL to treat.
     * @return {string} Scheme, undefined if no scheme found.
     */
    CoreUrlUtilsProvider.prototype.getUrlScheme = function (url) {
        if (!url) {
            return;
        }
        var matches = url.match(/^([a-z][a-z0-9+\-.]*):/);
        if (matches && matches[1]) {
            return matches[1];
        }
    };
    /*
     * Gets a username from a URL like: user@mysite.com.
     *
     * @param {string} url URL to treat.
     * @return {string} Username. Undefined if no username found.
     */
    CoreUrlUtilsProvider.prototype.getUsernameFromUrl = function (url) {
        if (url.indexOf('@') > -1) {
            // Get URL without protocol.
            var withoutProtocol = url.replace(/.*?:\/\//, ''), matches = withoutProtocol.match(/[^@]*/);
            // Make sure that @ is at the start of the URL, not in a param at the end.
            if (matches && matches.length && !matches[0].match(/[\/|?]/)) {
                return matches[0];
            }
        }
    };
    /**
     * Returns if a URL has any protocol (not a relative URL).
     *
     * @param {string} url The url to test against the pattern.
     * @return {boolean} Whether the url is absolute.
     */
    CoreUrlUtilsProvider.prototype.isAbsoluteURL = function (url) {
        return /^[^:]{2,}:\/\//i.test(url) || /^(tel:|mailto:|geo:)/.test(url);
    };
    /**
     * Returns if a URL is downloadable: plugin file OR theme/image.php OR gravatar.
     *
     * @param {string} url The URL to test.
     * @return {boolean} Whether the URL is downloadable.
     */
    CoreUrlUtilsProvider.prototype.isDownloadableUrl = function (url) {
        return this.isPluginFileUrl(url) || this.isThemeImageUrl(url) || this.isGravatarUrl(url);
    };
    /**
     * Returns if a URL is a gravatar URL.
     *
     * @param {string} url The URL to test.
     * @return {boolean} Whether the URL is a gravatar URL.
     */
    CoreUrlUtilsProvider.prototype.isGravatarUrl = function (url) {
        return url && url.indexOf('gravatar.com/avatar') !== -1;
    };
    /**
     * Check if a URL uses http or https protocol.
     *
     * @param {string} url The url to test.
     * @return {boolean} Whether the url uses http or https protocol.
     */
    CoreUrlUtilsProvider.prototype.isHttpURL = function (url) {
        return /^https?\:\/\/.+/i.test(url);
    };
    /**
     * Returns if a URL is a pluginfile URL.
     *
     * @param {string} url The URL to test.
     * @return {boolean} Whether the URL is a pluginfile URL.
     */
    CoreUrlUtilsProvider.prototype.isPluginFileUrl = function (url) {
        return url && url.indexOf('/pluginfile.php') !== -1;
    };
    /**
     * Returns if a URL is a theme image URL.
     *
     * @param {string} url The URL to test.
     * @return {boolean} Whether the URL is a theme image URL.
     */
    CoreUrlUtilsProvider.prototype.isThemeImageUrl = function (url) {
        return url && url.indexOf('/theme/image.php') !== -1;
    };
    /**
     * Remove protocol and www from a URL.
     *
     * @param {string} url URL to treat.
     * @return {string} Treated URL.
     */
    CoreUrlUtilsProvider.prototype.removeProtocolAndWWW = function (url) {
        // Remove protocol.
        url = url.replace(/.*?:\/\//g, '');
        // Remove www.
        url = url.replace(/^www./, '');
        return url;
    };
    /**
     * Remove the parameters from a URL, returning the URL without them.
     *
     * @param {string} url URL to treat.
     * @return {string} URL without params.
     */
    CoreUrlUtilsProvider.prototype.removeUrlParams = function (url) {
        var matches = url.match(/^[^\?]+/);
        return matches && matches[0];
    };
    CoreUrlUtilsProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__lang__["a" /* CoreLangProvider */]])
    ], CoreUrlUtilsProvider);
    return CoreUrlUtilsProvider;
}());

//# sourceMappingURL=url.js.map

/***/ }),

/***/ 37:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_events__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_sites__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_time__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__constants__ = __webpack_require__(26);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








/**
 * Service that provides some features regarding a course.
 */
var CoreCourseProvider = /** @class */ (function () {
    function CoreCourseProvider(logger, sitesProvider, eventsProvider, utils, timeUtils, translate) {
        this.sitesProvider = sitesProvider;
        this.eventsProvider = eventsProvider;
        this.utils = utils;
        this.timeUtils = timeUtils;
        this.translate = translate;
        this.ROOT_CACHE_KEY = 'mmCourse:';
        // Variables for database.
        this.COURSE_STATUS_TABLE = 'course_status';
        this.courseStatusTableSchema = {
            name: this.COURSE_STATUS_TABLE,
            columns: [
                {
                    name: 'id',
                    type: 'INTEGER',
                    primaryKey: true
                },
                {
                    name: 'status',
                    type: 'TEXT',
                    notNull: true
                },
                {
                    name: 'previous',
                    type: 'TEXT'
                },
                {
                    name: 'updated',
                    type: 'INTEGER'
                },
                {
                    name: 'downloadTime',
                    type: 'INTEGER'
                },
                {
                    name: 'previousDownloadTime',
                    type: 'INTEGER'
                }
            ]
        };
        this.CORE_MODULES = [
            'assign', 'assignment', 'book', 'chat', 'choice', 'data', 'database', 'date', 'external-tool',
            'feedback', 'file', 'folder', 'forum', 'glossary', 'ims', 'imscp', 'label', 'lesson', 'lti', 'page', 'quiz',
            'resource', 'scorm', 'survey', 'url', 'wiki', 'workshop'
        ];
        this.logger = logger.getInstance('CoreCourseProvider');
        this.sitesProvider.createTableFromSchema(this.courseStatusTableSchema);
    }
    /**
     * Check if module completion could have changed. If it could have, trigger event. This function must be used,
     * for example, after calling a "module_view" WS since it can change the module completion.
     *
     * @param {number} courseId Course ID.
     * @param {any} completion Completion status of the module.
     */
    CoreCourseProvider.prototype.checkModuleCompletion = function (courseId, completion) {
        var _this = this;
        if (completion && completion.tracking === 2 && completion.state === 0) {
            this.invalidateSections(courseId).finally(function () {
                _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */].COMPLETION_MODULE_VIEWED, { courseId: courseId });
            });
        }
    };
    /**
     * Clear all courses status in a site.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<void>} Promise resolved when all status are cleared.
     */
    CoreCourseProvider.prototype.clearAllCoursesStatus = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            _this.logger.debug('Clear all course status for site ' + site.id);
            return site.getDb().deleteRecords(_this.COURSE_STATUS_TABLE).then(function () {
                _this.triggerCourseStatusChanged(-1, __WEBPACK_IMPORTED_MODULE_7__constants__["a" /* CoreConstants */].NOT_DOWNLOADED, site.id);
            });
        });
    };
    /**
     * Get completion status of all the activities in a course for a certain user.
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined, current user.
     * @return {Promise<any>} Promise resolved with the completion statuses: object where the key is module ID.
     */
    CoreCourseProvider.prototype.getActivitiesCompletionStatus = function (courseId, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            _this.logger.debug("Getting completion status for user " + userId + " in course " + courseId);
            var params = {
                courseid: courseId,
                userid: userId
            }, preSets = {
                cacheKey: _this.getActivitiesCompletionCacheKey(courseId, userId)
            };
            return site.read('core_completion_get_activities_completion_status', params, preSets).then(function (data) {
                if (data && data.statuses) {
                    return _this.utils.arrayToObject(data.statuses, 'cmid');
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get cache key for activities completion WS calls.
     *
     * @param {number} courseId Course ID.
     * @param {number} userId User ID.
     * @return {string} Cache key.
     */
    CoreCourseProvider.prototype.getActivitiesCompletionCacheKey = function (courseId, userId) {
        return this.ROOT_CACHE_KEY + 'activitiescompletion:' + courseId + ':' + userId;
    };
    /**
     * Get the data stored for a course.
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the data.
     */
    CoreCourseProvider.prototype.getCourseStatusData = function (courseId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getRecord(_this.COURSE_STATUS_TABLE, { id: courseId }).then(function (entry) {
                if (!entry) {
                    return Promise.reject(null);
                }
                return entry;
            });
        });
    };
    /**
     * Get a course status.
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<string>} Promise resolved with the status.
     */
    CoreCourseProvider.prototype.getCourseStatus = function (courseId, siteId) {
        return this.getCourseStatusData(courseId, siteId).then(function (entry) {
            return entry.status || __WEBPACK_IMPORTED_MODULE_7__constants__["a" /* CoreConstants */].NOT_DOWNLOADED;
        }).catch(function () {
            return __WEBPACK_IMPORTED_MODULE_7__constants__["a" /* CoreConstants */].NOT_DOWNLOADED;
        });
    };
    /**
     * Get a module from Moodle.
     *
     * @param {number} moduleId The module ID.
     * @param {number} [courseId] The course ID. Recommended to speed up the process and minimize data usage.
     * @param {number} [sectionId] The section ID.
     * @param {boolean} [preferCache] True if shouldn't call WS if data is cached, false otherwise.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the module.
     */
    CoreCourseProvider.prototype.getModule = function (moduleId, courseId, sectionId, preferCache, ignoreCache, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var promise;
        if (!courseId) {
            // No courseId passed, try to retrieve it.
            promise = this.getModuleBasicInfo(moduleId, siteId).then(function (module) {
                return module.course;
            });
        }
        else {
            promise = Promise.resolve(courseId);
        }
        return promise.then(function (cid) {
            courseId = cid;
            // Get the site.
            return _this.sitesProvider.getSite(siteId);
        }).then(function (site) {
            // We have courseId, we can use core_course_get_contents for compatibility.
            _this.logger.debug("Getting module " + moduleId + " in course " + courseId);
            var params = {
                courseid: courseId,
                options: [
                    {
                        name: 'cmid',
                        value: moduleId
                    }
                ]
            }, preSets = {
                cacheKey: _this.getModuleCacheKey(moduleId),
                omitExpires: preferCache
            };
            if (!preferCache && ignoreCache) {
                preSets.getFromCache = 0;
                preSets.emergencyCache = 0;
            }
            if (sectionId) {
                params.options.push({
                    name: 'sectionid',
                    value: sectionId
                });
            }
            return site.read('core_course_get_contents', params, preSets).catch(function () {
                // Error getting the module. Try to get all contents (without filtering by module).
                return _this.getSections(courseId, false, false, preSets, siteId);
            }).then(function (sections) {
                for (var i = 0; i < sections.length; i++) {
                    var section = sections[i];
                    for (var j = 0; j < section.modules.length; j++) {
                        var module_1 = section.modules[j];
                        if (module_1.id == moduleId) {
                            module_1.course = courseId;
                            return module_1;
                        }
                    }
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Gets a module basic info by module ID.
     *
     * @param {number} moduleId Module ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the module's info.
     */
    CoreCourseProvider.prototype.getModuleBasicInfo = function (moduleId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                cmid: moduleId
            }, preSets = {
                cacheKey: _this.getModuleCacheKey(moduleId)
            };
            return site.read('core_course_get_course_module', params, preSets).then(function (response) {
                if (response.warnings && response.warnings.length) {
                    return Promise.reject(response.warnings[0]);
                }
                else if (response.cm) {
                    return response.cm;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Gets a module basic grade info by module ID.
     *
     * @param {number} moduleId Module ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the module's grade info.
     */
    CoreCourseProvider.prototype.getModuleBasicGradeInfo = function (moduleId, siteId) {
        return this.getModuleBasicInfo(moduleId, siteId).then(function (info) {
            var grade = {
                advancedgrading: info.advancedgrading || false,
                grade: info.grade || false,
                gradecat: info.gradecat || false,
                gradepass: info.gradepass || false,
                outcomes: info.outcomes || false,
                scale: info.scale || false
            };
            if (grade.grade !== false || grade.advancedgrading !== false || grade.outcomes !== false) {
                return grade;
            }
            return false;
        });
    };
    /**
     * Gets a module basic info by instance.
     *
     * @param {number} id Instance ID.
     * @param {string} module Name of the module. E.g. 'glossary'.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the module's info.
     */
    CoreCourseProvider.prototype.getModuleBasicInfoByInstance = function (id, module, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                instance: id,
                module: module
            }, preSets = {
                cacheKey: _this.getModuleBasicInfoByInstanceCacheKey(id, module)
            };
            return site.read('core_course_get_course_module_by_instance', params, preSets).then(function (response) {
                if (response.warnings && response.warnings.length) {
                    return Promise.reject(response.warnings[0]);
                }
                else if (response.cm) {
                    return response.cm;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get cache key for get module by instance WS calls.
     *
     * @param {number} id Instance ID.
     * @param {string} module Name of the module. E.g. 'glossary'.
     * @return {string} Cache key.
     */
    CoreCourseProvider.prototype.getModuleBasicInfoByInstanceCacheKey = function (id, module) {
        return this.ROOT_CACHE_KEY + 'moduleByInstance:' + module + ':' + id;
    };
    /**
     * Get cache key for module WS calls.
     *
     * @param {number} moduleId Module ID.
     * @return {string} Cache key.
     */
    CoreCourseProvider.prototype.getModuleCacheKey = function (moduleId) {
        return this.ROOT_CACHE_KEY + 'module:' + moduleId;
    };
    /**
     * Returns the source to a module icon.
     *
     * @param {string} moduleName The module name.
     * @return {string} The IMG src.
     */
    CoreCourseProvider.prototype.getModuleIconSrc = function (moduleName) {
        if (this.CORE_MODULES.indexOf(moduleName) < 0) {
            moduleName = 'external-tool';
        }
        return 'assets/img/mod/' + moduleName + '.svg';
    };
    /**
     * Get the section ID a module belongs to.
     *
     * @param {number} moduleId The module ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<number>} Promise resolved with the section ID.
     */
    CoreCourseProvider.prototype.getModuleSectionId = function (moduleId, siteId) {
        // Try to get the section using getModuleBasicInfo.
        return this.getModuleBasicInfo(moduleId, siteId).then(function (module) {
            return module.section;
        });
    };
    /**
     * Return a specific section.
     *
     * @param {number} courseId The course ID.
     * @param {number} sectionId The section ID.
     * @param {boolean} [excludeModules] Do not return modules, return only the sections structure.
     * @param {boolean} [excludeContents] Do not return module contents (i.e: files inside a resource).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the section.
     */
    CoreCourseProvider.prototype.getSection = function (courseId, sectionId, excludeModules, excludeContents, siteId) {
        if (sectionId < 0) {
            return Promise.reject('Invalid section ID');
        }
        return this.getSections(courseId, excludeModules, excludeContents, undefined, siteId).then(function (sections) {
            for (var i = 0; i < sections.length; i++) {
                if (sections[i].id == sectionId) {
                    return sections[i];
                }
            }
            return Promise.reject('Unkown section');
        });
    };
    /**
     * Get the course sections.
     *
     * @param {number} courseId The course ID.
     * @param {boolean} [excludeModules] Do not return modules, return only the sections structure.
     * @param {boolean} [excludeContents] Do not return module contents (i.e: files inside a resource).
     * @param {CoreSiteWSPreSets} [preSets] Presets to use.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise}                The reject contains the error message, else contains the sections.
     */
    CoreCourseProvider.prototype.getSections = function (courseId, excludeModules, excludeContents, preSets, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            preSets = preSets || {};
            preSets.cacheKey = _this.getSectionsCacheKey(courseId);
            preSets.getCacheUsingCacheKey = true; // This is to make sure users don't lose offline access when updating.
            var params = {
                courseid: courseId,
                options: [
                    {
                        name: 'excludemodules',
                        value: excludeModules ? 1 : 0
                    },
                    {
                        name: 'excludecontents',
                        value: excludeContents ? 1 : 0
                    }
                ]
            };
            return site.read('core_course_get_contents', params, preSets).then(function (sections) {
                var siteHomeId = site.getSiteHomeId();
                var showSections = true;
                if (courseId == siteHomeId) {
                    showSections = site.getStoredConfig('numsections');
                }
                if (typeof showSections != 'undefined' && !showSections && sections.length > 0) {
                    // Get only the last section (Main menu block section).
                    sections.pop();
                }
                return sections;
            });
        });
    };
    /**
     * Get cache key for section WS call.
     *
     * @param {number} courseId Course ID.
     * @return {string} Cache key.
     */
    CoreCourseProvider.prototype.getSectionsCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'sections:' + courseId;
    };
    /**
     * Given a list of sections, returns the list of modules in the sections.
     *
     * @param {any[]} sections Sections.
     * @return {any[]} Modules.
     */
    CoreCourseProvider.prototype.getSectionsModules = function (sections) {
        if (!sections || !sections.length) {
            return [];
        }
        var modules = [];
        sections.forEach(function (section) {
            if (section.modules) {
                modules = modules.concat(section.modules);
            }
        });
        return modules;
    };
    /**
     * Invalidates module WS call.
     *
     * @param {number} moduleId Module ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCourseProvider.prototype.invalidateModule = function (moduleId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getModuleCacheKey(moduleId));
        });
    };
    /**
     * Invalidates module WS call.
     *
     * @param {number} id Instance ID.
     * @param {string} module Name of the module. E.g. 'glossary'.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCourseProvider.prototype.invalidateModuleByInstance = function (id, module, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getModuleBasicInfoByInstanceCacheKey(id, module));
        });
    };
    /**
     * Invalidates sections WS call.
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined, current user.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCourseProvider.prototype.invalidateSections = function (courseId, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var promises = [], siteHomeId = site.getSiteHomeId();
            userId = userId || site.getUserId();
            promises.push(site.invalidateWsCacheForKey(_this.getSectionsCacheKey(courseId)));
            promises.push(site.invalidateWsCacheForKey(_this.getActivitiesCompletionCacheKey(courseId, userId)));
            if (courseId == siteHomeId) {
                promises.push(site.invalidateConfig());
            }
            return Promise.all(promises);
        });
    };
    /**
     * Load module contents into module.contents if they aren't loaded already.
     *
     * @param {any} module Module to load the contents.
     * @param {number} [courseId] The course ID. Recommended to speed up the process and minimize data usage.
     * @param {number} [sectionId] The section ID.
     * @param {boolean} [preferCache] True if shouldn't call WS if data is cached, false otherwise.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<void>} Promise resolved when loaded.
     */
    CoreCourseProvider.prototype.loadModuleContents = function (module, courseId, sectionId, preferCache, ignoreCache, siteId) {
        if (!ignoreCache && module.contents && module.contents.length) {
            // Already loaded.
            return Promise.resolve();
        }
        return this.getModule(module.id, courseId, sectionId, preferCache, ignoreCache, siteId).then(function (mod) {
            module.contents = mod.contents;
        });
    };
    /**
     * Report a course and section as being viewed.
     *
     * @param {number} courseId  Course ID.
     * @param {number} [sectionNumber] Section number.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<void>} Promise resolved when the WS call is successful.
     */
    CoreCourseProvider.prototype.logView = function (courseId, sectionNumber, siteId) {
        var params = {
            courseid: courseId
        };
        if (typeof sectionNumber != 'undefined') {
            params.sectionnumber = sectionNumber;
        }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.write('core_course_view_course', params).then(function (response) {
                if (!response.status) {
                    return Promise.reject(null);
                }
            });
        });
    };
    /**
     * Change the course status, setting it to the previous status.
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<string>} Promise resolved when the status is changed. Resolve param: new status.
     */
    CoreCourseProvider.prototype.setCoursePreviousStatus = function (courseId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        this.logger.debug("Set previous status for course " + courseId + " in site " + siteId);
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var db = site.getDb(), newData = {};
            // Get current stored data.
            return _this.getCourseStatusData(courseId, siteId).then(function (entry) {
                _this.logger.debug("Set previous status '" + entry.status + "' for course " + courseId);
                newData.status = entry.previous || __WEBPACK_IMPORTED_MODULE_7__constants__["a" /* CoreConstants */].NOT_DOWNLOADED;
                newData.updated = Date.now();
                if (entry.status == __WEBPACK_IMPORTED_MODULE_7__constants__["a" /* CoreConstants */].DOWNLOADING) {
                    // Going back from downloading to previous status, restore previous download time.
                    newData.downloadTime = entry.previousDownloadTime;
                }
                return db.updateRecords(_this.COURSE_STATUS_TABLE, newData, { id: courseId }).then(function () {
                    // Success updating, trigger event.
                    _this.triggerCourseStatusChanged(courseId, newData.status, siteId);
                    return newData.status;
                });
            });
        });
    };
    /**
     * Store course status.
     *
     * @param {number} courseId Course ID.
     * @param {string} status New course status.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<void>} Promise resolved when the status is stored.
     */
    CoreCourseProvider.prototype.setCourseStatus = function (courseId, status, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        this.logger.debug("Set status '" + status + "' for course " + courseId + " in site " + siteId);
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var downloadTime, previousDownloadTime;
            if (status == __WEBPACK_IMPORTED_MODULE_7__constants__["a" /* CoreConstants */].DOWNLOADING) {
                // Set download time if course is now downloading.
                downloadTime = _this.timeUtils.timestamp();
            }
            // Search current status to set it as previous status.
            return _this.getCourseStatusData(courseId, siteId).then(function (entry) {
                if (typeof downloadTime == 'undefined') {
                    // Keep previous download time.
                    downloadTime = entry.downloadTime;
                    previousDownloadTime = entry.previousDownloadTime;
                }
                else {
                    // The downloadTime will be updated, store current time as previous.
                    previousDownloadTime = entry.downloadTime;
                }
                return entry.status;
            }).catch(function () {
                // No previous status.
            }).then(function (previousStatus) {
                if (previousStatus != status) {
                    // Status has changed, update it.
                    var data = {
                        id: courseId,
                        status: status,
                        previous: previousStatus,
                        updated: new Date().getTime(),
                        downloadTime: downloadTime,
                        previousDownloadTime: previousDownloadTime
                    };
                    return site.getDb().insertOrUpdateRecord(_this.COURSE_STATUS_TABLE, data, { id: courseId });
                }
            }).then(function () {
                // Success inserting, trigger event.
                _this.triggerCourseStatusChanged(courseId, status, siteId);
            });
        });
    };
    /**
     * Translate a module name to current language.
     *
     * @param {string} moduleName The module name.
     * @return {string} Translated name.
     */
    CoreCourseProvider.prototype.translateModuleName = function (moduleName) {
        if (this.CORE_MODULES.indexOf(moduleName) < 0) {
            moduleName = 'external-tool';
        }
        var langKey = 'core.mod_' + moduleName, translated = this.translate.instant(langKey);
        return translated !== langKey ? translated : moduleName;
    };
    /**
     * Trigger COURSE_STATUS_CHANGED with the right data.
     *
     * @param {number} courseId Course ID.
     * @param {string} status New course status.
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    CoreCourseProvider.prototype.triggerCourseStatusChanged = function (courseId, status, siteId) {
        this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */].COURSE_STATUS_CHANGED, {
            courseId: courseId,
            status: status
        }, siteId);
    };
    CoreCourseProvider.ALL_SECTIONS_ID = -1;
    CoreCourseProvider.ACCESS_GUEST = 'courses_access_guest';
    CoreCourseProvider.ACCESS_DEFAULT = 'courses_access_default';
    CoreCourseProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */],
            __WEBPACK_IMPORTED_MODULE_6__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_utils_time__["a" /* CoreTimeUtilsProvider */], __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
    ], CoreCourseProvider);
    return CoreCourseProvider;
}());

//# sourceMappingURL=course.js.map

/***/ }),

/***/ 38:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreMimetypeUtilsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__text__ = __webpack_require__(19);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/*
 * "Utils" service with helper functions for mimetypes and extensions.
 */
var CoreMimetypeUtilsProvider = /** @class */ (function () {
    function CoreMimetypeUtilsProvider(http, logger, translate, textUtils) {
        var _this = this;
        this.translate = translate;
        this.textUtils = textUtils;
        this.extToMime = {}; // Object to map extensions -> mimetypes.
        this.mimeToExt = {}; // Object to map mimetypes -> extensions.
        this.groupsMimeInfo = {}; // Object to hold extensions and mimetypes that belong to a certain "group" (audio, video, ...).
        this.extensionRegex = /^[a-z0-9]+$/;
        this.wsProvider = {}; // @todo
        this.logger = logger.getInstance('CoreMimetypeUtilsProvider');
        http.get('assets/exttomime.json').subscribe(function (result) {
            _this.extToMime = result;
        }, function (err) {
            // Error, shouldn't happen.
        });
        http.get('assets/mimetoext.json').subscribe(function (result) {
            _this.mimeToExt = result;
        }, function (err) {
            // Error, shouldn't happen.
        });
    }
    /**
     * Check if a file extension can be embedded without using iframes.
     *
     * @param {string} extension Extension.
     * @return {boolean} Whether it can be embedded.
     */
    CoreMimetypeUtilsProvider.prototype.canBeEmbedded = function (extension) {
        return this.isExtensionInGroup(extension, ['web_image', 'web_video', 'web_audio']);
    };
    /**
     * Clean a extension, removing the dot, hash, extra params...
     *
     * @param {string} extension Extension to clean.
     * @return {string} Clean extension.
     */
    CoreMimetypeUtilsProvider.prototype.cleanExtension = function (extension) {
        if (!extension) {
            return extension;
        }
        // If the extension has parameters, remove them.
        var position = extension.indexOf('?');
        if (position > -1) {
            extension = extension.substr(0, position);
        }
        // Remove hash in extension if there's any (added by filepool).
        extension = extension.replace(/_.{32}$/, '');
        // Remove dot from the extension if found.
        if (extension && extension[0] == '.') {
            extension = extension.substr(1);
        }
        return extension;
    };
    /**
     * Fill the mimetypes and extensions info for a certain group.
     *
     * @param {string} group Group name.
     */
    CoreMimetypeUtilsProvider.prototype.fillGroupMimeInfo = function (group) {
        var mimetypes = {}, // Use an object to prevent duplicates.
        extensions = []; // Extensions are unique.
        for (var extension in this.extToMime) {
            var data = this.extToMime[extension];
            if (data.type && data.groups && data.groups.indexOf(group) != -1) {
                // This extension has the group, add it to the list.
                mimetypes[data.type] = true;
                extensions.push(extension);
            }
        }
        this.groupsMimeInfo[group] = {
            mimetypes: Object.keys(mimetypes),
            extensions: extensions
        };
    };
    /**
     * Get the extension of a mimetype. Returns undefined if not found.
     *
     * @param {string} mimetype Mimetype.
     * @param {string} [url] URL of the file. It will be used if there's more than one possible extension.
     * @return {string} Extension.
     */
    CoreMimetypeUtilsProvider.prototype.getExtension = function (mimetype, url) {
        mimetype = mimetype || '';
        mimetype = mimetype.split(';')[0]; // Remove codecs from the mimetype if any.
        if (mimetype == 'application/x-forcedownload' || mimetype == 'application/forcedownload') {
            // Couldn't get the right mimetype, try to guess it.
            return this.guessExtensionFromUrl(url);
        }
        var extensions = this.mimeToExt[mimetype];
        if (extensions && extensions.length) {
            if (extensions.length > 1 && url) {
                // There's more than one possible extension. Check if the URL has extension.
                var candidate = this.guessExtensionFromUrl(url);
                if (extensions.indexOf(candidate) != -1) {
                    return candidate;
                }
            }
            return extensions[0];
        }
    };
    /**
     * Get the "type" (string) of an extension, something like "image", "video" or "audio".
     *
     * @param {string} extension Extension.
     * @return {string} Type of the extension.
     */
    CoreMimetypeUtilsProvider.prototype.getExtensionType = function (extension) {
        extension = this.cleanExtension(extension);
        if (this.extToMime[extension] && this.extToMime[extension].string) {
            return this.extToMime[extension].string;
        }
    };
    /**
     * Get all the possible extensions of a mimetype. Returns empty array if not found.
     *
     * @param {string} mimetype Mimetype.
     * @return {string[]} Extensions.
     */
    CoreMimetypeUtilsProvider.prototype.getExtensions = function (mimetype) {
        mimetype = mimetype || '';
        mimetype = mimetype.split(';')[0]; // Remove codecs from the mimetype if any.
        return this.mimeToExt[mimetype] || [];
    };
    /**
     * Get a file icon URL based on its file name.
     *
     * @param {string} The name of the file.
     * @return {string} The path to a file icon.
     */
    CoreMimetypeUtilsProvider.prototype.getFileIcon = function (filename) {
        var ext = this.getFileExtension(filename);
        var icon = 'unknown';
        if (ext && this.extToMime[ext]) {
            if (this.extToMime[ext].icon) {
                icon = this.extToMime[ext].icon;
            }
            else {
                var type = this.extToMime[ext].type.split('/')[0];
                if (type == 'video' || type == 'text' || type == 'image' || type == 'document' || type == 'audio') {
                    icon = type;
                }
            }
        }
        return 'assets/img/files/' + icon + '-64.png';
    };
    /**
     * Get the folder icon URL.
     *
     * @return {string} The path to a folder icon.
     */
    CoreMimetypeUtilsProvider.prototype.getFolderIcon = function () {
        return 'assets/img/files/folder-64.png';
    };
    /**
     * Get the mimetype of a file given its URL. It'll try to guess it using the URL, if that fails then it'll
     * perform a HEAD request to get it. It's done in this order because pluginfile.php can return wrong mimetypes.
     *
     * @param {string} url The URL of the file.
     * @return {Promise<string>} Promise resolved with the mimetype.
     */
    CoreMimetypeUtilsProvider.prototype.getMimeTypeFromUrl = function (url) {
        // First check if it can be guessed from the URL.
        var extension = this.guessExtensionFromUrl(url), mimetype = this.getMimeType(extension);
        if (mimetype) {
            return Promise.resolve(mimetype);
        }
        // Can't be guessed, get the remote mimetype.
        return this.wsProvider.getRemoteFileMimeType(url).then(function (mimetype) {
            return mimetype || '';
        });
    };
    /**
     * Guess the extension of a file from its URL.
     * This is very weak and unreliable.
     *
     * @param {string} fileUrl The file URL.
     * @return {string} The lowercased extension without the dot, or undefined.
     */
    CoreMimetypeUtilsProvider.prototype.guessExtensionFromUrl = function (fileUrl) {
        var split = fileUrl.split('.');
        var candidate, extension, position;
        if (split.length > 1) {
            candidate = split.pop().toLowerCase();
            // Remove params if any.
            position = candidate.indexOf('?');
            if (position > -1) {
                candidate = candidate.substr(0, position);
            }
            if (this.extensionRegex.test(candidate)) {
                extension = candidate;
            }
        }
        // Check extension corresponds to a mimetype to know if it's valid.
        if (extension && typeof this.getMimeType(extension) == 'undefined') {
            this.logger.warn('Guess file extension: Not valid extension ' + extension);
            return;
        }
        return extension;
    };
    /**
     * Returns the file extension of a file.
     * When the file does not have an extension, it returns undefined.
     *
     * @param {string} filename The file name.
     * @return {string} The lowercased extension, or undefined.
     */
    CoreMimetypeUtilsProvider.prototype.getFileExtension = function (filename) {
        var dot = filename.lastIndexOf('.');
        var ext;
        if (dot > -1) {
            ext = filename.substr(dot + 1).toLowerCase();
            ext = this.cleanExtension(ext);
            // Check extension corresponds to a mimetype to know if it's valid.
            if (typeof this.getMimeType(ext) == 'undefined') {
                this.logger.warn('Get file extension: Not valid extension ' + ext);
                return;
            }
        }
        return ext;
    };
    /**
     * Get the mimetype/extension info belonging to a certain group.
     *
     * @param {string} group Group name.
     * @param {string} [field] The field to get. If not supplied, all the info will be returned.
     * @return {any} Info for the group.
     */
    CoreMimetypeUtilsProvider.prototype.getGroupMimeInfo = function (group, field) {
        if (typeof this.groupsMimeInfo[group] == 'undefined') {
            this.fillGroupMimeInfo(group);
        }
        if (field) {
            return this.groupsMimeInfo[group][field];
        }
        return this.groupsMimeInfo[group];
    };
    /**
     * Get the mimetype of an extension. Returns undefined if not found.
     *
     * @param {string} extension Extension.
     * @return {string} Mimetype.
     */
    CoreMimetypeUtilsProvider.prototype.getMimeType = function (extension) {
        extension = this.cleanExtension(extension);
        if (this.extToMime[extension] && this.extToMime[extension].type) {
            return this.extToMime[extension].type;
        }
    };
    /**
     * Obtains descriptions for file types (e.g. 'Microsoft Word document') from the language file.
     * Based on Moodle's get_mimetype_description.
     *
     * @param {any} obj Instance of FileEntry OR object with 'filename' and 'mimetype' OR string with mimetype.
     * @param {boolean} [capitalise] If true, capitalises first character of result.
     * @return {string} Type description.
     */
    CoreMimetypeUtilsProvider.prototype.getMimetypeDescription = function (obj, capitalise) {
        var langPrefix = 'assets.mimetypes.';
        var filename = '', mimetype = '', extension = '';
        if (typeof obj == 'object' && typeof obj.file == 'function') {
            // It's a FileEntry. Don't use the file function because it's asynchronous and the type isn't reliable.
            filename = obj.name;
        }
        else if (typeof obj == 'object') {
            filename = obj.filename || '';
            mimetype = obj.mimetype || '';
        }
        else {
            mimetype = obj;
        }
        if (filename) {
            extension = this.getFileExtension(filename);
            if (!mimetype) {
                // Try to calculate the mimetype using the extension.
                mimetype = this.getMimeType(extension);
            }
        }
        if (!mimetype) {
            // Don't have the mimetype, stop.
            return '';
        }
        if (!extension) {
            extension = this.getExtension(mimetype);
        }
        var mimetypeStr = this.getMimetypeType(mimetype) || '', chunks = mimetype.split('/'), attr = {
            mimetype: mimetype,
            ext: extension || '',
            mimetype1: chunks[0],
            mimetype2: chunks[1] || '',
        }, translateParams = {};
        for (var key in attr) {
            var value = attr[key];
            translateParams[key] = value;
            translateParams[key.toUpperCase()] = value.toUpperCase();
            translateParams[this.textUtils.ucFirst(key)] = this.textUtils.ucFirst(value);
        }
        // MIME types may include + symbol but this is not permitted in string ids.
        var safeMimetype = mimetype.replace(/\+/g, '_'), safeMimetypeStr = mimetypeStr.replace(/\+/g, '_'), safeMimetypeTrns = this.translate.instant(langPrefix + safeMimetype, { $a: translateParams }), safeMimetypeStrTrns = this.translate.instant(langPrefix + safeMimetypeStr, { $a: translateParams }), defaultTrns = this.translate.instant(langPrefix + 'default', { $a: translateParams });
        var result = mimetype;
        if (safeMimetypeTrns != langPrefix + safeMimetype) {
            result = safeMimetypeTrns;
        }
        else if (safeMimetypeStrTrns != langPrefix + safeMimetypeStr) {
            result = safeMimetypeStrTrns;
        }
        else if (defaultTrns != langPrefix + 'default') {
            result = defaultTrns;
        }
        if (capitalise) {
            result = this.textUtils.ucFirst(result);
        }
        return result;
    };
    /**
     * Get the "type" (string) of a mimetype, something like "image", "video" or "audio".
     *
     * @param {string} mimetype Mimetype.
     * @return {string} Type of the mimetype.
     */
    CoreMimetypeUtilsProvider.prototype.getMimetypeType = function (mimetype) {
        mimetype = mimetype.split(';')[0]; // Remove codecs from the mimetype if any.
        var extensions = this.mimeToExt[mimetype];
        if (!extensions) {
            return;
        }
        for (var i = 0; i < extensions.length; i++) {
            var extension = extensions[i];
            if (this.extToMime[extension] && this.extToMime[extension].string) {
                return this.extToMime[extension].string;
            }
        }
    };
    /**
     * Given a group name, return the translated name.
     *
     * @param {string} name Group name.
     * @return {string} Translated name.
     */
    CoreMimetypeUtilsProvider.prototype.getTranslatedGroupName = function (name) {
        var key = 'assets.mimetypes.group:' + name, translated = this.translate.instant(key);
        return translated != key ? translated : name;
    };
    /**
     * Check if an extension belongs to at least one of the groups.
     * Similar to Moodle's file_mimetype_in_typegroup, but using the extension instead of mimetype.
     *
     * @param {string} extension Extension.
     * @param {string[]} groups List of groups to check.
     * @return {boolean} Whether the extension belongs to any of the groups.
     */
    CoreMimetypeUtilsProvider.prototype.isExtensionInGroup = function (extension, groups) {
        extension = this.cleanExtension(extension);
        if (groups && groups.length && this.extToMime[extension] && this.extToMime[extension].groups) {
            for (var i = 0; i < this.extToMime[extension].groups.length; i++) {
                var group = this.extToMime[extension].groups[i];
                if (groups.indexOf(group) != -1) {
                    return true;
                }
            }
        }
        return false;
    };
    /**
     * Remove the extension from a path (if any).
     *
     * @param {string} path Path.
     * @return {string} Path without extension.
     */
    CoreMimetypeUtilsProvider.prototype.removeExtension = function (path) {
        var position = path.lastIndexOf('.');
        var extension;
        if (position > -1) {
            // Check extension corresponds to a mimetype to know if it's valid.
            extension = path.substr(position + 1);
            if (typeof this.getMimeType(extension) != 'undefined') {
                return path.substr(0, position); // Remove extension.
            }
        }
        return path;
    };
    CoreMimetypeUtilsProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_common_http__["b" /* HttpClient */], __WEBPACK_IMPORTED_MODULE_2__logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_4__text__["a" /* CoreTextUtilsProvider */]])
    ], CoreMimetypeUtilsProvider);
    return CoreMimetypeUtilsProvider;
}());

//# sourceMappingURL=mimetype.js.map

/***/ }),

/***/ 41:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreLoginHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_app__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_config__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_events__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_init__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_sites__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_ws__ = __webpack_require__(114);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_utils_dom__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_utils_text__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_utils_url__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__configconstants__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__constants__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_ts_md5_dist_md5__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_ts_md5_dist_md5___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_16_ts_md5_dist_md5__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

















/**
 * Helper provider that provides some common features regarding authentication.
 */
var CoreLoginHelperProvider = /** @class */ (function () {
    function CoreLoginHelperProvider(logger, sitesProvider, domUtils, wsProvider, translate, textUtils, eventsProvider, appProvider, utils, urlUtils, configProvider, platform, initDelegate) {
        this.sitesProvider = sitesProvider;
        this.domUtils = domUtils;
        this.wsProvider = wsProvider;
        this.translate = translate;
        this.textUtils = textUtils;
        this.eventsProvider = eventsProvider;
        this.appProvider = appProvider;
        this.utils = utils;
        this.urlUtils = urlUtils;
        this.configProvider = configProvider;
        this.platform = platform;
        this.initDelegate = initDelegate;
        this.isSSOConfirmShown = false;
        this.isOpenEditAlertShown = false;
        this.waitingForBrowser = false;
        this.logger = logger.getInstance('CoreLoginHelper');
    }
    /**
     * Accept site policy.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved if success, rejected if failure.
     */
    CoreLoginHelperProvider.prototype.acceptSitePolicy = function (siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.write('core_user_agree_site_policy', {}).then(function (result) {
                if (!result.status) {
                    // Error.
                    if (result.warnings && result.warnings.length) {
                        // Check if there is a warning 'alreadyagreed'.
                        for (var i in result.warnings) {
                            var warning = result.warnings[i];
                            if (warning.warningcode == 'alreadyagreed') {
                                // Policy already agreed, treat it as a success.
                                return;
                            }
                        }
                        // Another warning, reject.
                        return Promise.reject(result.warnings[0]);
                    }
                    else {
                        return Promise.reject(null);
                    }
                }
            });
        });
    };
    /**
     * Function to handle URL received by Custom URL Scheme. If it's a SSO login, perform authentication.
     *
     * @param {string} url URL received.
     * @return {boolean} True if it's a SSO URL, false otherwise.
     */
    CoreLoginHelperProvider.prototype.appLaunchedByURL = function (url) {
        var _this = this;
        var ssoScheme = __WEBPACK_IMPORTED_MODULE_14__configconstants__["a" /* CoreConfigConstants */].customurlscheme + '://token=';
        if (url.indexOf(ssoScheme) == -1) {
            return false;
        }
        if (this.appProvider.isSSOAuthenticationOngoing()) {
            // Authentication ongoing, probably duplicated request.
            return true;
        }
        if (this.appProvider.isDesktop()) {
            // In desktop, make sure InAppBrowser is closed.
            this.utils.closeInAppBrowser(true);
        }
        // App opened using custom URL scheme. Probably an SSO authentication.
        this.appProvider.startSSOAuthentication();
        this.logger.debug('App launched by URL with an SSO');
        // Delete the sso scheme from the URL.
        url = url.replace(ssoScheme, '');
        // Some platforms like Windows add a slash at the end. Remove it.
        // Some sites add a # at the end of the URL. If it's there, remove it.
        url = url.replace(/\/?#?\/?$/, '');
        // Decode from base64.
        try {
            url = atob(url);
        }
        catch (err) {
            // Error decoding the parameter.
            this.logger.error('Error decoding parameter received for login SSO');
            return false;
        }
        var modal = this.domUtils.showModalLoading('core.login.authenticating', true);
        var siteData;
        // Wait for app to be ready.
        this.initDelegate.ready().then(function () {
            return _this.validateBrowserSSOLogin(url);
        }).then(function (data) {
            siteData = data;
            return _this.handleSSOLoginAuthentication(siteData.siteUrl, siteData.token, siteData.privateToken);
        }).then(function () {
            if (siteData.pageName) {
                // State defined, go to that state instead of site initial page.
                _this.appProvider.getRootNavController().push(siteData.pageName, siteData.pageParams);
            }
            else {
                _this.goToSiteInitialPage();
            }
        }).catch(function (errorMessage) {
            if (typeof errorMessage == 'string' && errorMessage != '') {
                _this.domUtils.showErrorModal(errorMessage);
            }
        }).finally(function () {
            modal.dismiss();
            _this.appProvider.finishSSOAuthentication();
        });
        return true;
    };
    /**
     * Check if a site allows requesting a password reset through the app.
     *
     * @param {string} siteUrl URL of the site.
     * @return {Promise<any>} Promise resolved with boolean: whether can be done through the app.
     */
    CoreLoginHelperProvider.prototype.canRequestPasswordReset = function (siteUrl) {
        return this.requestPasswordReset(siteUrl).then(function () {
            return true;
        }).catch(function (error) {
            return error.available == 1 || error.errorcode != 'invalidrecord';
        });
    };
    /**
     * Function called when an SSO InAppBrowser is closed or the app is resumed. Check if user needs to be logged out.
     */
    CoreLoginHelperProvider.prototype.checkLogout = function () {
        var navCtrl = this.appProvider.getRootNavController();
        if (!this.appProvider.isSSOAuthenticationOngoing() && this.sitesProvider.isLoggedIn() &&
            this.sitesProvider.getCurrentSite().isLoggedOut() && navCtrl.getActive().name == 'CoreLoginReconnectPage') {
            // User must reauthenticate but he closed the InAppBrowser without doing so, logout him.
            this.sitesProvider.logout();
        }
    };
    /**
     * Show a confirm modal if needed and open a browser to perform SSO login.
     *
     * @param  {string} siteurl     URL of the site where the SSO login will be performed.
     * @param  {number} typeOfLogin CoreConstants.LOGIN_SSO_CODE or CoreConstants.LOGIN_SSO_INAPP_CODE.
     * @param  {string} [service]   The service to use. If not defined, external service will be used.
     * @param  {string} [launchUrl] The URL to open for SSO. If not defined, local_mobile launch URL will be used.
     * @return {Void}
     */
    CoreLoginHelperProvider.prototype.confirmAndOpenBrowserForSSOLogin = function (siteUrl, typeOfLogin, service, launchUrl) {
        var _this = this;
        // Show confirm only if it's needed. Treat "false" (string) as false to prevent typing errors.
        var showConfirmation = this.shouldShowSSOConfirm(typeOfLogin);
        var promise;
        if (showConfirmation) {
            promise = this.domUtils.showConfirm(this.translate.instant('core.login.logininsiterequired'));
        }
        else {
            promise = Promise.resolve();
        }
        promise.then(function () {
            _this.openBrowserForSSOLogin(siteUrl, typeOfLogin, service, launchUrl);
        }, function () {
            // User cancelled, ignore.
        });
    };
    /**
     * Format profile fields, filtering the ones that shouldn't be shown on signup and classifying them in categories.
     *
     * @param {any[]} profileFields Profile fields to format.
     * @return {any} Categories with the fields to show in each one.
     */
    CoreLoginHelperProvider.prototype.formatProfileFieldsForSignup = function (profileFields) {
        if (!profileFields) {
            return [];
        }
        var categories = {};
        profileFields.forEach(function (field) {
            if (!field.signup) {
                // Not a signup field, ignore it.
                return;
            }
            if (!categories[field.categoryid]) {
                categories[field.categoryid] = {
                    id: field.categoryid,
                    name: field.categoryname,
                    fields: []
                };
            }
            categories[field.categoryid].fields.push(field);
        });
        return Object.keys(categories).map(function (index) {
            return categories[index];
        });
    };
    /**
     * Builds an object with error messages for some common errors.
     * Please notice that this function doesn't support all possible error types.
     *
     * @param {string} [requiredMsg] Code of the string for required error.
     * @param {string} [emailMsg] Code of the string for invalid email error.
     * @param {string} [patternMsg] Code of the string for pattern not match error.
     * @param {string} [urlMsg] Code of the string for invalid url error.
     * @param {string} [minlengthMsg] Code of the string for "too short" error.
     * @param {string} [maxlengthMsg] Code of the string for "too long" error.
     * @param {string} [minMsg] Code of the string for min value error.
     * @param {string} [maxMsg] Code of the string for max value error.
     * @return {any} Object with the errors.
     */
    CoreLoginHelperProvider.prototype.getErrorMessages = function (requiredMsg, emailMsg, patternMsg, urlMsg, minlengthMsg, maxlengthMsg, minMsg, maxMsg) {
        var errors = {};
        if (requiredMsg) {
            errors.required = errors.requiredTrue = this.translate.instant(requiredMsg);
        }
        if (emailMsg) {
            errors.email = this.translate.instant(emailMsg);
        }
        if (patternMsg) {
            errors.pattern = this.translate.instant(patternMsg);
        }
        if (urlMsg) {
            errors.url = this.translate.instant(urlMsg);
        }
        if (minlengthMsg) {
            errors.minlength = this.translate.instant(minlengthMsg);
        }
        if (maxlengthMsg) {
            errors.maxlength = this.translate.instant(maxlengthMsg);
        }
        if (minMsg) {
            errors.min = this.translate.instant(minMsg);
        }
        if (maxMsg) {
            errors.max = this.translate.instant(maxMsg);
        }
        return errors;
    };
    /**
     * Get the site policy.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<string>} Promise resolved with the site policy.
     */
    CoreLoginHelperProvider.prototype.getSitePolicy = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            // Check if it's stored in the site config.
            var sitePolicy = site.getStoredConfig('sitepolicy');
            if (typeof sitePolicy != 'undefined') {
                return sitePolicy ? sitePolicy : Promise.reject(null);
            }
            // Not in the config, try to get it using auth_email_get_signup_settings.
            return _this.wsProvider.callAjax('auth_email_get_signup_settings', {}, { siteUrl: site.getURL() }).then(function (settings) {
                return settings.sitepolicy ? settings.sitepolicy : Promise.reject(null);
            });
        });
    };
    /**
     * Get fixed site or sites.
     *
     * @return {string|any[]} Fixed site or list of fixed sites.
     */
    CoreLoginHelperProvider.prototype.getFixedSites = function () {
        return __WEBPACK_IMPORTED_MODULE_14__configconstants__["a" /* CoreConfigConstants */].siteurl;
    };
    /**
     * Get the valid identity providers from a site config.
     *
     * @param {any} siteConfig Site's public config.
     * @return {any[]} Valid identity providers.
     */
    CoreLoginHelperProvider.prototype.getValidIdentityProviders = function (siteConfig) {
        var validProviders = [], httpUrl = this.textUtils.concatenatePaths(siteConfig.wwwroot, 'auth/oauth2/'), httpsUrl = this.textUtils.concatenatePaths(siteConfig.httpswwwroot, 'auth/oauth2/');
        if (siteConfig.identityproviders && siteConfig.identityproviders.length) {
            siteConfig.identityproviders.forEach(function (provider) {
                if (provider.url && (provider.url.indexOf(httpsUrl) != -1 || provider.url.indexOf(httpUrl) != -1)) {
                    validProviders.push(provider);
                }
            });
        }
        return validProviders;
    };
    /**
     * Go to the page to add a new site.
     * If a fixed URL is configured, go to credentials instead.
     *
     * @param {boolean} [setRoot] True to set the new page as root, false to add it to the stack.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreLoginHelperProvider.prototype.goToAddSite = function (setRoot) {
        var pageName, params;
        if (this.isFixedUrlSet()) {
            // Fixed URL is set, go to credentials page.
            var url = typeof __WEBPACK_IMPORTED_MODULE_14__configconstants__["a" /* CoreConfigConstants */].siteurl == 'string' ?
                __WEBPACK_IMPORTED_MODULE_14__configconstants__["a" /* CoreConfigConstants */].siteurl : __WEBPACK_IMPORTED_MODULE_14__configconstants__["a" /* CoreConfigConstants */].siteurl[0].url;
            pageName = 'CoreLoginCredentialsPage';
            params = { siteUrl: url };
        }
        else {
            pageName = 'CoreLoginSitePage';
        }
        if (setRoot) {
            return this.appProvider.getRootNavController().setRoot(pageName, params, { animate: false });
        }
        else {
            return this.appProvider.getRootNavController().push(pageName, params);
        }
    };
    /**
     * Go to the initial page of a site depending on 'userhomepage' setting.
     *
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreLoginHelperProvider.prototype.goToSiteInitialPage = function () {
        return this.appProvider.getRootNavController().setRoot('CoreMainMenuPage');
    };
    /**
     * Convenient helper to handle authentication in the app using a token received by SSO login. If it's a new account,
     * the site is stored and the user is authenticated. If the account already exists, update its token.
     *
     * @param {string} siteUrl Site's URL.
     * @param {string} token User's token.
     * @param {string} [privateToken] User's private token.
     * @return {Promise<any>} Promise resolved when the user is authenticated with the token.
     */
    CoreLoginHelperProvider.prototype.handleSSOLoginAuthentication = function (siteUrl, token, privateToken) {
        var _this = this;
        if (this.sitesProvider.isLoggedIn()) {
            // User logged in, he is reconnecting. Retrieve username.
            var info_1 = this.sitesProvider.getCurrentSite().getInfo();
            if (typeof info_1 != 'undefined' && typeof info_1.username != 'undefined') {
                return this.sitesProvider.updateSiteToken(info_1.siteurl, info_1.username, token, privateToken).then(function () {
                    _this.sitesProvider.updateSiteInfoByUrl(info_1.siteurl, info_1.username);
                }).catch(function () {
                    // Error updating token, return proper error message.
                    return Promise.reject(_this.translate.instant('core.login.errorupdatesite'));
                });
            }
            return Promise.reject(this.translate.instant('core.login.errorupdatesite'));
        }
        else {
            return this.sitesProvider.newSite(siteUrl, token, privateToken);
        }
    };
    /**
     * Check if the app is configured to use several fixed URLs.
     *
     * @return {boolean} Whether there are several fixed URLs.
     */
    CoreLoginHelperProvider.prototype.hasSeveralFixedSites = function () {
        return __WEBPACK_IMPORTED_MODULE_14__configconstants__["a" /* CoreConfigConstants */].siteurl && Array.isArray(__WEBPACK_IMPORTED_MODULE_14__configconstants__["a" /* CoreConfigConstants */].siteurl) &&
            __WEBPACK_IMPORTED_MODULE_14__configconstants__["a" /* CoreConfigConstants */].siteurl.length > 1;
    };
    /**
     * Function called when a page starts loading in any InAppBrowser window.
     *
     * @param {string} url Loaded url.
     */
    CoreLoginHelperProvider.prototype.inAppBrowserLoadStart = function (url) {
        // URLs with a custom scheme can be prefixed with "http://" or "https://", we need to remove this.
        url = url.replace(/^https?:\/\//, '');
        if (this.appLaunchedByURL(url)) {
            // Close the browser if it's a valid SSO URL.
            this.utils.closeInAppBrowser(false);
        }
        else if (this.platform.is('android')) {
            // Check if the URL has a custom URL scheme. In Android they need to be opened manually.
            var urlScheme = this.urlUtils.getUrlProtocol(url);
            if (urlScheme && urlScheme !== 'file' && urlScheme !== 'cdvfile') {
                // Open in browser should launch the right app if found and do nothing if not found.
                this.utils.openInBrowser(url);
                // At this point the InAppBrowser is showing a "Webpage not available" error message.
                // Try to navigate to last loaded URL so this error message isn't found.
                if (this.lastInAppUrl) {
                    this.utils.openInApp(this.lastInAppUrl);
                }
                else {
                    // No last URL loaded, close the InAppBrowser.
                    this.utils.closeInAppBrowser(false);
                }
            }
            else {
                this.lastInAppUrl = url;
            }
        }
    };
    /**
     * Given a site public config, check if email signup is disabled.
     *
     * @param {any} config Site public config.
     * @return {boolean} Whether email signup is disabled.
     */
    CoreLoginHelperProvider.prototype.isEmailSignupDisabled = function (config) {
        var disabledFeatures = config && config.tool_mobile_disabledfeatures;
        if (!disabledFeatures) {
            return false;
        }
        var regEx = new RegExp('(,|^)\\$mmLoginEmailSignup(,|$)', 'g');
        return !!disabledFeatures.match(regEx);
    };
    /**
     * Check if the app is configured to use a fixed URL (only 1).
     *
     * @return {boolean} Whether there is 1 fixed URL.
     */
    CoreLoginHelperProvider.prototype.isFixedUrlSet = function () {
        if (Array.isArray(__WEBPACK_IMPORTED_MODULE_14__configconstants__["a" /* CoreConfigConstants */].siteurl)) {
            return __WEBPACK_IMPORTED_MODULE_14__configconstants__["a" /* CoreConfigConstants */].siteurl.length == 1;
        }
        return !!__WEBPACK_IMPORTED_MODULE_14__configconstants__["a" /* CoreConfigConstants */].siteurl;
    };
    /**
     * Check if current site is logged out, triggering mmCoreEventSessionExpired if it is.
     *
     * @param {string} [pageName] Name of the page to go once authenticated if logged out. If not defined, site initial page.
     * @param {any} [params] Params of the page to go once authenticated if logged out.
     * @return {boolean} True if user is logged out, false otherwise.
     */
    CoreLoginHelperProvider.prototype.isSiteLoggedOut = function (pageName, params) {
        var site = this.sitesProvider.getCurrentSite();
        if (!site) {
            return false;
        }
        if (site.isLoggedOut()) {
            this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_5__providers_events__["a" /* CoreEventsProvider */].SESSION_EXPIRED, {
                pageName: pageName,
                params: params
            }, site.getId());
            return true;
        }
        return false;
    };
    /**
     * Check if SSO login should use an embedded browser.
     *
     * @param {number} code Code to check.
     * @return {boolean} True if embedded browser, false othwerise.
     */
    CoreLoginHelperProvider.prototype.isSSOEmbeddedBrowser = function (code) {
        if (this.appProvider.isLinux()) {
            // In Linux desktop apps, always use embedded browser.
            return true;
        }
        return code == __WEBPACK_IMPORTED_MODULE_15__constants__["a" /* CoreConstants */].LOGIN_SSO_INAPP_CODE;
    };
    /**
     * Check if SSO login is needed based on code returned by the WS.
     *
     * @param {number} code Code to check.
     * @return {boolean} True if SSO login is needed, false othwerise.
     */
    CoreLoginHelperProvider.prototype.isSSOLoginNeeded = function (code) {
        return code == __WEBPACK_IMPORTED_MODULE_15__constants__["a" /* CoreConstants */].LOGIN_SSO_CODE || code == __WEBPACK_IMPORTED_MODULE_15__constants__["a" /* CoreConstants */].LOGIN_SSO_INAPP_CODE;
    };
    /**
     * Load a site and load a certain page in that site.
     *
     * @param {string} page Name of the page to load.
     * @param {any} params Params to pass to the page.
     * @param {string} siteId Site to load.
     */
    CoreLoginHelperProvider.prototype.loadSiteAndPage = function (page, params, siteId) {
        var _this = this;
        if (siteId == __WEBPACK_IMPORTED_MODULE_15__constants__["a" /* CoreConstants */].NO_SITE_ID) {
            // Page doesn't belong to a site, just load the page.
            this.appProvider.getRootNavController().setRoot(page, params);
        }
        else {
            var modal_1 = this.domUtils.showModalLoading();
            this.sitesProvider.loadSite(siteId).then(function () {
                if (!_this.isSiteLoggedOut(page, params)) {
                    _this.loadPageInMainMenu(page, params);
                }
            }).catch(function () {
                // Site doesn't exist.
                _this.appProvider.getRootNavController().setRoot('CoreLoginSitesPage');
            }).finally(function () {
                modal_1.dismiss();
            });
        }
    };
    /**
     * Load a certain page in the main menu page.
     *
     * @param {string} page Name of the page to load.
     * @param {any} params Params to pass to the page.
     */
    CoreLoginHelperProvider.prototype.loadPageInMainMenu = function (page, params) {
        this.appProvider.getRootNavController().setRoot('CoreMainMenuPage', { redirectPage: page, redirectParams: params });
    };
    /**
     * Open a browser to perform OAuth login (Google, Facebook, Microsoft).
     *
     * @param {string} siteUrl URL of the site where the login will be performed.
     * @param {any} provider The identity provider.
     * @param {string} [launchUrl] The URL to open for SSO. If not defined, tool/mobile launch URL will be used.
     * @param {string} [pageName] Name of the page to go once authenticated. If not defined, site initial page.
     * @param {any} [pageParams] Params of the state to go once authenticated.
     * @return {boolean} True if success, false if error.
     */
    CoreLoginHelperProvider.prototype.openBrowserForOAuthLogin = function (siteUrl, provider, launchUrl, pageName, pageParams) {
        launchUrl = launchUrl || siteUrl + '/admin/tool/mobile/launch.php';
        if (!provider || !provider.url) {
            return false;
        }
        var service = this.sitesProvider.determineService(siteUrl), params = this.urlUtils.extractUrlParams(provider.url);
        var loginUrl = this.prepareForSSOLogin(siteUrl, service, launchUrl, pageName, pageParams);
        if (!params.id) {
            return false;
        }
        loginUrl += '&oauthsso=' + params.id;
        if (this.appProvider.isLinux()) {
            // In Linux desktop apps, always use embedded browser.
            this.utils.openInApp(loginUrl);
        }
        else {
            // Always open it in browser because the user might have the session stored in there.
            this.utils.openInBrowser(loginUrl);
            if (navigator.app) {
                navigator.app.exitApp();
            }
        }
        return true;
    };
    /**
     * Open a browser to perform SSO login.
     *
     * @param {string} siteurl URL of the site where the SSO login will be performed.
     * @param {number} typeOfLogin CoreConstants.LOGIN_SSO_CODE or CoreConstants.LOGIN_SSO_INAPP_CODE.
     * @param {string} [service] The service to use. If not defined, external service will be used.
     * @param {string} [launchUrl] The URL to open for SSO. If not defined, local_mobile launch URL will be used.
     * @param {string} [pageName] Name of the page to go once authenticated. If not defined, site initial page.
     * @param {any} [pageParams] Params of the state to go once authenticated.
     */
    CoreLoginHelperProvider.prototype.openBrowserForSSOLogin = function (siteUrl, typeOfLogin, service, launchUrl, pageName, pageParams) {
        var loginUrl = this.prepareForSSOLogin(siteUrl, service, launchUrl, pageName, pageParams);
        if (this.isSSOEmbeddedBrowser(typeOfLogin)) {
            var options = {
                clearsessioncache: 'yes',
                closebuttoncaption: this.translate.instant('core.login.cancel'),
            };
            this.utils.openInApp(loginUrl, options);
        }
        else {
            this.utils.openInBrowser(loginUrl);
            if (navigator.app) {
                navigator.app.exitApp();
            }
        }
    };
    /**
     * Convenient helper to open change password page.
     *
     * @param {string} siteUrl Site URL to construct change password URL.
     * @param {string} error Error message.
     */
    CoreLoginHelperProvider.prototype.openChangePassword = function (siteUrl, error) {
        var _this = this;
        var alert = this.domUtils.showAlert(this.translate.instant('core.notice'), error, undefined, 3000);
        alert.onDidDismiss(function () {
            _this.utils.openInApp(siteUrl + '/login/change_password.php');
        });
    };
    /**
     * Open forgotten password in inappbrowser.
     *
     * @param {string} siteUrl URL of the site.
     */
    CoreLoginHelperProvider.prototype.openForgottenPassword = function (siteUrl) {
        this.utils.openInApp(siteUrl + '/login/forgot_password.php');
    };
    /*
     * Function to open in app browser to change password or complete user profile.
     *
     * @param {string} siteId The site ID.
     * @param {string} path The relative path of the URL to open.
     * @param {string} alertMessage The key of the message to display before opening the in app browser.
     * @param {boolean} [invalidateCache] Whether to invalidate site's cache (e.g. when the user is forced to change password).
     */
    CoreLoginHelperProvider.prototype.openInAppForEdit = function (siteId, path, alertMessage, invalidateCache) {
        var _this = this;
        if (!siteId || siteId !== this.sitesProvider.getCurrentSiteId()) {
            // Site that triggered the event is not current site, nothing to do.
            return;
        }
        var currentSite = this.sitesProvider.getCurrentSite(), siteUrl = currentSite && currentSite.getURL();
        if (!currentSite || !siteUrl) {
            return;
        }
        if (!this.isOpenEditAlertShown && !this.waitingForBrowser) {
            this.isOpenEditAlertShown = true;
            if (invalidateCache) {
                currentSite.invalidateWsCache();
            }
            // Open change password.
            alertMessage = this.translate.instant(alertMessage) + '<br>' + this.translate.instant('core.redirectingtosite');
            currentSite.openInAppWithAutoLogin(siteUrl + path, undefined, alertMessage).then(function () {
                _this.waitingForBrowser = true;
            }).finally(function () {
                _this.isOpenEditAlertShown = false;
            });
        }
    };
    /**
     * Prepare the app to perform SSO login.
     *
     * @param {string} siteUrl URL of the site where the SSO login will be performed.
     * @param {string} [service] The service to use. If not defined, external service will be used.
     * @param {string} [launchUrl] The URL to open for SSO. If not defined, local_mobile launch URL will be used.
     * @param {string} [pageName] Name of the page to go once authenticated. If not defined, site initial page.
     * @param {any} [pageParams] Params of the state to go once authenticated.
     */
    CoreLoginHelperProvider.prototype.prepareForSSOLogin = function (siteUrl, service, launchUrl, pageName, pageParams) {
        service = service || __WEBPACK_IMPORTED_MODULE_14__configconstants__["a" /* CoreConfigConstants */].wsextservice;
        launchUrl = launchUrl || siteUrl + '/local/mobile/launch.php';
        var passport = Math.random() * 1000;
        var loginUrl = launchUrl + '?service=' + service;
        loginUrl += '&passport=' + passport;
        loginUrl += '&urlscheme=' + __WEBPACK_IMPORTED_MODULE_14__configconstants__["a" /* CoreConfigConstants */].customurlscheme;
        // Store the siteurl and passport in $mmConfig for persistence.
        // We are "configuring" the app to wait for an SSO. $mmConfig shouldn't be used as a temporary storage.
        this.configProvider.set(__WEBPACK_IMPORTED_MODULE_15__constants__["a" /* CoreConstants */].LOGIN_LAUNCH_DATA, JSON.stringify({
            siteUrl: siteUrl,
            passport: passport,
            pageName: pageName || '',
            pageParams: pageParams || {}
        }));
        return loginUrl;
    };
    /**
     * Redirect to a new page, setting it as the root page and loading the right site if needed.
     *
     * @param {string} page Name of the page to load.
     * @param {any} params Params to pass to the page.
     * @param {string} [siteId] Site to load. If not defined, current site.
     */
    CoreLoginHelperProvider.prototype.redirect = function (page, params, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (this.sitesProvider.isLoggedIn()) {
            if (siteId && siteId != this.sitesProvider.getCurrentSiteId()) {
                // Target page belongs to a different site. Change site.
                // @todo Store redirect once we have addon manager.
                this.sitesProvider.logout().then(function () {
                    _this.loadSiteAndPage(page, params, siteId);
                });
            }
            else {
                this.loadPageInMainMenu(page, params);
            }
        }
        else {
            if (siteId) {
                this.loadSiteAndPage(page, params, siteId);
            }
            else {
                this.appProvider.getRootNavController().setRoot('CoreLoginSitesPage');
            }
        }
    };
    /**
     * Request a password reset.
     *
     * @param {string} siteUrl URL of the site.
     * @param {string} [username] Username to search.
     * @param {string} [email] Email to search.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreLoginHelperProvider.prototype.requestPasswordReset = function (siteUrl, username, email) {
        var params = {};
        if (username) {
            params.username = username;
        }
        if (email) {
            params.email = email;
        }
        return this.wsProvider.callAjax('core_auth_request_password_reset', params, { siteUrl: siteUrl });
    };
    /**
     * Function that should be called when the session expires. Reserved for core use.
     *
     * @param {any} data Data received by the SESSION_EXPIRED event.
     */
    CoreLoginHelperProvider.prototype.sessionExpired = function (data) {
        var _this = this;
        var siteId = data && data.siteId, currentSite = this.sitesProvider.getCurrentSite(), siteUrl = currentSite && currentSite.getURL();
        var promise;
        if (!currentSite || !siteUrl) {
            return;
        }
        if (siteId && siteId !== currentSite.getId()) {
            return; // Site that triggered the event is not current site.
        }
        // Check authentication method.
        this.sitesProvider.checkSite(siteUrl).then(function (result) {
            if (result.warning) {
                _this.domUtils.showErrorModal(result.warning, true, 4000);
            }
            if (_this.isSSOLoginNeeded(result.code)) {
                // SSO. User needs to authenticate in a browser. Check if we need to display a message.
                if (!_this.appProvider.isSSOAuthenticationOngoing() && !_this.isSSOConfirmShown && !_this.waitingForBrowser) {
                    _this.isSSOConfirmShown = true;
                    if (_this.shouldShowSSOConfirm(result.code)) {
                        promise = _this.domUtils.showConfirm(_this.translate.instant('core.login.' +
                            (currentSite.isLoggedOut() ? 'loggedoutssodescription' : 'reconnectssodescription')));
                    }
                    else {
                        promise = Promise.resolve();
                    }
                    promise.then(function () {
                        _this.waitingForBrowser = true;
                        _this.openBrowserForSSOLogin(result.siteUrl, result.code, result.service, result.config && result.config.launchurl, data.pageName, data.params);
                    }).catch(function () {
                        // User cancelled, logout him.
                        _this.sitesProvider.logout();
                    }).finally(function () {
                        _this.isSSOConfirmShown = false;
                    });
                }
            }
            else {
                var info = currentSite.getInfo();
                if (typeof info != 'undefined' && typeof info.username != 'undefined') {
                    _this.appProvider.getRootNavController().setRoot('CoreLoginReconnectPage', {
                        infoSiteUrl: info.siteurl,
                        siteUrl: result.siteUrl,
                        siteId: siteId,
                        pageName: data.pageName,
                        pageParams: data.params,
                        siteConfig: result.config
                    });
                }
            }
        }).catch(function (error) {
            // Error checking site.
            if (currentSite.isLoggedOut()) {
                // Site is logged out, show error and logout the user.
                _this.domUtils.showErrorModalDefault(error, 'core.networkerrormsg', true);
                _this.sitesProvider.logout();
            }
        });
    };
    /**
     * Check if a confirm should be shown to open a SSO authentication.
     *
     * @param {number} typeOfLogin CoreConstants.LOGIN_SSO_CODE or CoreConstants.LOGIN_SSO_INAPP_CODE.
     * @return {boolean} True if confirm modal should be shown, false otherwise.
     */
    CoreLoginHelperProvider.prototype.shouldShowSSOConfirm = function (typeOfLogin) {
        return !this.isSSOEmbeddedBrowser(typeOfLogin) &&
            (!__WEBPACK_IMPORTED_MODULE_14__configconstants__["a" /* CoreConfigConstants */].skipssoconfirmation || String(__WEBPACK_IMPORTED_MODULE_14__configconstants__["a" /* CoreConfigConstants */].skipssoconfirmation) === 'false');
    };
    /**
     * Function called when site policy is not agreed. Reserved for core use.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    CoreLoginHelperProvider.prototype.sitePolicyNotAgreed = function (siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (!siteId || siteId != this.sitesProvider.getCurrentSiteId()) {
            // Only current site allowed.
            return;
        }
        if (!this.sitesProvider.getCurrentSite().wsAvailable('core_user_agree_site_policy')) {
            // WS not available, stop.
            return;
        }
        this.appProvider.getRootNavController().setRoot('CoreLoginSitePolicyPage', { siteId: siteId });
    };
    /**
     * Convenient helper to handle get User Token error. It redirects to change password page if forcepassword is set.
     *
     * @param {string} siteUrl Site URL to construct change password URL.
     * @param {any} error Error object containing errorcode and error message.
     */
    CoreLoginHelperProvider.prototype.treatUserTokenError = function (siteUrl, error) {
        if (typeof error == 'string') {
            this.domUtils.showErrorModal(error);
        }
        else if (error.errorcode == 'forcepasswordchangenotice') {
            this.openChangePassword(siteUrl, error.error);
        }
        else {
            this.domUtils.showErrorModal(error.error);
        }
    };
    /**
     * Convenient helper to validate a browser SSO login.
     *
     * @param {string} url URL received, to be validated.
     * @return {Promise<CoreLoginSSOData>} Promise resolved on success.
     */
    CoreLoginHelperProvider.prototype.validateBrowserSSOLogin = function (url) {
        var _this = this;
        // Split signature:::token
        var params = url.split(':::');
        return this.configProvider.get(__WEBPACK_IMPORTED_MODULE_15__constants__["a" /* CoreConstants */].LOGIN_LAUNCH_DATA).then(function (data) {
            try {
                data = JSON.parse(data);
            }
            catch (ex) {
                return Promise.reject(null);
            }
            var passport = data.passport;
            var launchSiteURL = data.siteUrl;
            // Reset temporary values.
            _this.configProvider.delete(__WEBPACK_IMPORTED_MODULE_15__constants__["a" /* CoreConstants */].LOGIN_LAUNCH_DATA);
            // Validate the signature.
            // We need to check both http and https.
            var signature = __WEBPACK_IMPORTED_MODULE_16_ts_md5_dist_md5__["Md5"].hashAsciiStr(launchSiteURL + passport);
            if (signature != params[0]) {
                if (launchSiteURL.indexOf('https://') != -1) {
                    launchSiteURL = launchSiteURL.replace('https://', 'http://');
                }
                else {
                    launchSiteURL = launchSiteURL.replace('http://', 'https://');
                }
                signature = __WEBPACK_IMPORTED_MODULE_16_ts_md5_dist_md5__["Md5"].hashAsciiStr(launchSiteURL + passport);
            }
            if (signature == params[0]) {
                _this.logger.debug('Signature validated');
                return {
                    siteUrl: launchSiteURL,
                    token: params[1],
                    privateToken: params[2],
                    pageName: data.pageName,
                    pageParams: data.pageParams
                };
            }
            else {
                _this.logger.debug('Invalid signature in the URL request yours: ' + params[0] + ' mine: '
                    + signature + ' for passport ' + passport);
                return Promise.reject(_this.translate.instant('core.unexpectederror'));
            }
        });
    };
    CoreLoginHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_7__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_8__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_10__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_9__providers_ws__["a" /* CoreWSProvider */], __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_11__providers_utils_text__["a" /* CoreTextUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_5__providers_events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_13__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_12__providers_utils_url__["a" /* CoreUrlUtilsProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_config__["a" /* CoreConfigProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */],
            __WEBPACK_IMPORTED_MODULE_6__providers_init__["a" /* CoreInitDelegate */]])
    ], CoreLoginHelperProvider);
    return CoreLoginHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),

/***/ 42:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreTimeUtilsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_moment__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_constants__ = __webpack_require__(26);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/*
 * "Utils" service with helper functions for date and time.
*/
var CoreTimeUtilsProvider = /** @class */ (function () {
    function CoreTimeUtilsProvider(translate) {
        this.translate = translate;
    }
    /**
     * Returns hours, minutes and seconds in a human readable format
     *
     * @param {number} seconds A number of seconds
     * @return {string} Seconds in a human readable format.
     */
    CoreTimeUtilsProvider.prototype.formatTime = function (seconds) {
        var totalSecs, years, days, hours, mins, secs, remainder;
        totalSecs = Math.abs(seconds);
        years = Math.floor(totalSecs / __WEBPACK_IMPORTED_MODULE_3__core_constants__["a" /* CoreConstants */].SECONDS_YEAR);
        remainder = totalSecs - (years * __WEBPACK_IMPORTED_MODULE_3__core_constants__["a" /* CoreConstants */].SECONDS_YEAR);
        days = Math.floor(remainder / __WEBPACK_IMPORTED_MODULE_3__core_constants__["a" /* CoreConstants */].SECONDS_DAY);
        remainder = totalSecs - (days * __WEBPACK_IMPORTED_MODULE_3__core_constants__["a" /* CoreConstants */].SECONDS_DAY);
        hours = Math.floor(remainder / __WEBPACK_IMPORTED_MODULE_3__core_constants__["a" /* CoreConstants */].SECONDS_HOUR);
        remainder = remainder - (hours * __WEBPACK_IMPORTED_MODULE_3__core_constants__["a" /* CoreConstants */].SECONDS_HOUR);
        mins = Math.floor(remainder / __WEBPACK_IMPORTED_MODULE_3__core_constants__["a" /* CoreConstants */].SECONDS_MINUTE);
        secs = remainder - (mins * __WEBPACK_IMPORTED_MODULE_3__core_constants__["a" /* CoreConstants */].SECONDS_MINUTE);
        var ss = this.translate.instant('core.' + (secs == 1 ? 'sec' : 'secs')), sm = this.translate.instant('core.' + (mins == 1 ? 'min' : 'mins')), sh = this.translate.instant('core.' + (hours == 1 ? 'hour' : 'hours')), sd = this.translate.instant('core.' + (days == 1 ? 'day' : 'days')), sy = this.translate.instant('core.' + (years == 1 ? 'year' : 'years'));
        var oyears = '', odays = '', ohours = '', omins = '', osecs = '';
        if (years) {
            oyears = years + ' ' + sy;
        }
        if (days) {
            odays = days + ' ' + sd;
        }
        if (hours) {
            ohours = hours + ' ' + sh;
        }
        if (mins) {
            omins = mins + ' ' + sm;
        }
        if (secs) {
            osecs = secs + ' ' + ss;
        }
        if (years) {
            return oyears + ' ' + odays;
        }
        if (days) {
            return odays + ' ' + ohours;
        }
        if (hours) {
            return ohours + ' ' + omins;
        }
        if (mins) {
            return omins + ' ' + osecs;
        }
        if (secs) {
            return osecs;
        }
        return this.translate.instant('core.now');
    };
    /**
     * Returns hours, minutes and seconds in a human readable format.
     *
     * @param {number} duration Duration in seconds
     * @param {number} [precision] Number of elements to have in precission. 0 or undefined to full precission.
     * @return {string} Duration in a human readable format.
     */
    CoreTimeUtilsProvider.prototype.formatDuration = function (duration, precision) {
        precision = precision || 5;
        var eventDuration = __WEBPACK_IMPORTED_MODULE_2_moment__["duration"](duration, 'seconds');
        var durationString = '';
        if (precision && eventDuration.years() > 0) {
            durationString += ' ' + __WEBPACK_IMPORTED_MODULE_2_moment__["duration"](eventDuration.years(), 'years').humanize();
            precision--;
        }
        if (precision && eventDuration.months() > 0) {
            durationString += ' ' + __WEBPACK_IMPORTED_MODULE_2_moment__["duration"](eventDuration.months(), 'months').humanize();
            precision--;
        }
        if (precision && eventDuration.days() > 0) {
            durationString += ' ' + __WEBPACK_IMPORTED_MODULE_2_moment__["duration"](eventDuration.days(), 'days').humanize();
            precision--;
        }
        if (precision && eventDuration.hours() > 0) {
            durationString += ' ' + __WEBPACK_IMPORTED_MODULE_2_moment__["duration"](eventDuration.hours(), 'hours').humanize();
            precision--;
        }
        if (precision && eventDuration.minutes() > 0) {
            durationString += ' ' + __WEBPACK_IMPORTED_MODULE_2_moment__["duration"](eventDuration.minutes(), 'minutes').humanize();
            precision--;
        }
        return durationString.trim();
    };
    /**
     * Return the current timestamp in a "readable" format: YYYYMMDDHHmmSS.
     *
     * @return {string} The readable timestamp.
     */
    CoreTimeUtilsProvider.prototype.readableTimestamp = function () {
        return __WEBPACK_IMPORTED_MODULE_2_moment__(Date.now()).format('YYYYMMDDHHmmSS');
    };
    /**
     * Return the current timestamp (UNIX format, seconds).
     *
     * @return {number} The current timestamp in seconds.
     */
    CoreTimeUtilsProvider.prototype.timestamp = function () {
        return Math.round(Date.now() / 1000);
    };
    /**
     * Return the localized ISO format (i.e DDMMYY) from the localized moment format. Useful for translations.
     *
     * @param {any} localizedFormat Format to use.
     * @return {string} Localized ISO format
     */
    CoreTimeUtilsProvider.prototype.getLocalizedDateFormat = function (localizedFormat) {
        return __WEBPACK_IMPORTED_MODULE_2_moment__["localeData"]().longDateFormat(localizedFormat);
    };
    CoreTimeUtilsProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
    ], CoreTimeUtilsProvider);
    return CoreTimeUtilsProvider;
}());

//# sourceMappingURL=time.js.map

/***/ }),

/***/ 451:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SQLiteDB; });
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * Class to interact with the local database.
 *
 * @description
 * This class allows creating and interacting with a SQLite database.
 *
 * You need to supply some dependencies when creating the instance:
 * this.db = new SQLiteDB('MyDB', sqlite, platform);
 */
var SQLiteDB = /** @class */ (function () {
    /**
     * Create and open the database.
     *
     * @param {string} name Database name.
     * @param {SQLite} sqlite SQLite library.
     * @param {Platform} platform Ionic platform.
     */
    function SQLiteDB(name, sqlite, platform) {
        this.name = name;
        this.sqlite = sqlite;
        this.platform = platform;
        this.init();
    }
    /**
     * Helper function to create a table if it doesn't exist.
     *
     * @param {string} name The table name.
     * @param {any[]} columns The columns to create in the table. Each column can have:
     *                    * {string} name  Column's name.
     *                    * {string} [type] Column's type.
     *                    * {boolean} [primaryKey] If column is primary key. Use it only if primary key is a single column.
     *                    * {boolean} [autoIncrement] Whether it should be autoincremented. Only if primaryKey is true.
     *                    * {boolean} [notNull] True if column shouldn't be null.
     *                    * {boolean} [unique] Whether the column is unique.
     *                    * {string} [check] Check constraint for the column.
     *                    * {string} [default] Default value for the column.
     * @param {string[]} [primaryKeys] Names of columns that are primary key. Use it for compound primary keys.
     * @param {string[][]} [uniqueKeys] List of sets of unique columns. E.g: [['section', 'title'], ['author', 'title']].
     * @param {any[]} [foreignKeys] List of foreign keys. Each key can have:
     *                    * {string[]} columns Columns to include in this foreign key.
     *                    * {string} table The external table referenced by this key.
     *                    * {string[]} [foreignColumns] List of referenced columns from the referenced table.
     *                    * {string} [actions] Text with the actions to apply to the foreign key.
     * @param {string} [tableCheck] Check constraint for the table.
     * @return SQL query.
     */
    SQLiteDB.prototype.buildCreateTableSql = function (name, columns, primaryKeys, uniqueKeys, foreignKeys, tableCheck) {
        var columnsSql = [];
        var sql = "CREATE TABLE IF NOT EXISTS " + name + " (";
        // First define all the columns.
        for (var index in columns) {
            var column = columns[index];
            var columnSql = column.name || '';
            if (column.type) {
                columnSql += ' ' + column.type;
            }
            if (column.primaryKey) {
                columnSql += ' PRIMARY KEY';
                if (column.autoIncrement) {
                    columnSql += ' AUTOINCREMENT';
                }
            }
            if (column.notNull) {
                columnSql += ' NOT NULL';
            }
            if (column.unique) {
                columnSql += ' UNIQUE';
            }
            if (column.check) {
                columnSql += " CHECK (" + column.check + ")";
            }
            if (typeof column.default != 'undefined') {
                columnSql += " DEFAULT " + column.default;
            }
            columnsSql.push(columnSql);
        }
        sql += columnsSql.join(', ');
        // Now add the table constraints.
        if (primaryKeys && primaryKeys.length) {
            sql += ", PRIMARY KEY (" + primaryKeys.join(', ') + ")";
        }
        if (uniqueKeys && uniqueKeys.length) {
            for (var index in uniqueKeys) {
                var setOfKeys = uniqueKeys[index];
                if (setOfKeys && setOfKeys.length) {
                    sql += ", UNIQUE (" + setOfKeys.join(', ') + ")";
                }
            }
        }
        if (tableCheck) {
            sql += ", CHECK (" + tableCheck + ")";
        }
        for (var index in foreignKeys) {
            var foreignKey = foreignKeys[index];
            if (!foreignKey.columns || !!foreignKey.columns.length) {
                return;
            }
            sql += ", FOREIGN KEY (" + foreignKey.columns.join(', ') + ") REFERENCES " + foreignKey.table + " ";
            if (foreignKey.foreignColumns && foreignKey.foreignColumns.length) {
                sql += "(" + foreignKey.foreignColumns.join(', ') + ")";
            }
            if (foreignKey.actions) {
                sql += " " + foreignKey.actions;
            }
        }
        return sql + ')';
    };
    /**
     * Close the database.
     *
     * @return {Promise<any>} Promise resolved when done.
     */
    SQLiteDB.prototype.close = function () {
        var _this = this;
        return this.ready().then(function () {
            return _this.db.close();
        });
    };
    /**
     * Count the records in a table where all the given conditions met.
     *
     * @param {string} table The table to query.
     * @param {object} [conditions] The conditions to build the where clause. Must not contain numeric indexes.
     * @return {Promise<number>} Promise resolved with the count of records returned from the specified criteria.
     */
    SQLiteDB.prototype.countRecords = function (table, conditions) {
        var selectAndParams = this.whereClause(conditions);
        return this.countRecordsSelect(table, selectAndParams[0], selectAndParams[1]);
    };
    /**
     * Count the records in a table which match a particular WHERE clause.
     *
     * @param {string} table The table to query.
     * @param {string} [select] A fragment of SQL to be used in a where clause in the SQL call.
     * @param {any} [params] An array of sql parameters.
     * @param {string} [countItem] The count string to be used in the SQL call. Default is COUNT('x').
     * @return {Promise<number>} Promise resolved with the count of records returned from the specified criteria.
     */
    SQLiteDB.prototype.countRecordsSelect = function (table, select, params, countItem) {
        if (select === void 0) { select = ''; }
        if (countItem === void 0) { countItem = 'COUNT(\'x\')'; }
        if (select) {
            select = 'WHERE ' + select;
        }
        return this.countRecordsSql("SELECT " + countItem + " FROM " + table + " " + select, params);
    };
    /**
     * Get the result of a SQL SELECT COUNT(...) query.
     *
     * Given a query that counts rows, return that count.
     *
     * @param {string} sql The SQL string you wish to be executed.
     * @param {any} [params] An array of sql parameters.
     * @return {Promise<number>} Promise resolved with the count.
     */
    SQLiteDB.prototype.countRecordsSql = function (sql, params) {
        return this.getFieldSql(sql, params).then(function (count) {
            if (typeof count != 'number' || count < 0) {
                return 0;
            }
            return count;
        });
    };
    /**
     * Create a table if it doesn't exist.
     *
     * @param {string} name The table name.
     * @param {any[]} columns The columns to create in the table. Each column can have:
     *                    * {string} name  Column's name.
     *                    * {string} [type] Column's type.
     *                    * {boolean} [primaryKey] If column is primary key. Use it only if primary key is a single column.
     *                    * {boolean} [autoIncrement] Whether it should be autoincremented. Only if primaryKey is true.
     *                    * {boolean} [notNull] True if column shouldn't be null.
     *                    * {boolean} [unique] Whether the column is unique.
     *                    * {string} [check] Check constraint for the column.
     *                    * {string} [default] Default value for the column.
     * @param {string[]} [primaryKeys] Names of columns that are primary key. Use it for compound primary keys.
     * @param {string[][]} [uniqueKeys] List of sets of unique columns. E.g: [['section', 'title'], ['author', 'title']].
     * @param {any[]} [foreignKeys] List of foreign keys. Each key can have:
     *                    * {string[]} columns Columns to include in this foreign key.
     *                    * {string} table The external table referenced by this key.
     *                    * {string[]} [foreignColumns] List of referenced columns from the referenced table.
     *                    * {string} [actions] Text with the actions to apply to the foreign key.
     * @param {string} [tableCheck] Check constraint for the table.
     * @return {Promise<any>} Promise resolved when success.
     */
    SQLiteDB.prototype.createTable = function (name, columns, primaryKeys, uniqueKeys, foreignKeys, tableCheck) {
        var sql = this.buildCreateTableSql(name, columns, primaryKeys, uniqueKeys, foreignKeys, tableCheck);
        return this.execute(sql);
    };
    /**
     * Create a table if it doesn't exist from a schema.
     *
     * @param {any} table Table schema.
     * @return {Promise<any>} Promise resolved when success.
     */
    SQLiteDB.prototype.createTableFromSchema = function (table) {
        return this.createTable(table.name, table.columns, table.primaryKeys, table.uniqueKeys, table.foreignKeys, table.tableCheck);
    };
    /**
     * Create several tables if they don't exist from a list of schemas.
     *
     * @param {any[]} tables List of table schema.
     * @return {Promise<any>} Promise resolved when success.
     */
    SQLiteDB.prototype.createTablesFromSchema = function (tables) {
        var _this = this;
        var promises = [];
        tables.forEach(function (table) {
            promises.push(_this.createTableFromSchema(table));
        });
        return Promise.all(promises);
    };
    /**
     * Delete the records from a table where all the given conditions met.
     * If conditions not specified, table is truncated.
     *
     * @param {string} table The table to delete from.
     * @param {object} [conditions] The conditions to build the where clause. Must not contain numeric indexes.
     * @return {Promise<any>} Promise resolved when done.
     */
    SQLiteDB.prototype.deleteRecords = function (table, conditions) {
        if (conditions === null || typeof conditions == 'undefined') {
            // No conditions, delete the whole table.
            return this.execute("DELETE FROM TABLE " + table);
        }
        var selectAndParams = this.whereClause(conditions);
        return this.deleteRecordsSelect(table, selectAndParams[0], selectAndParams[1]);
    };
    /**
     * Delete the records from a table where one field match one list of values.
     *
     * @param {string} table The table to delete from.
     * @param {string} field The name of a field.
     * @param {any[]} values The values field might take.
     * @return {Promise<any>} Promise resolved when done.
     */
    SQLiteDB.prototype.deleteRecordsList = function (table, field, values) {
        var selectAndParams = this.whereClauseList(field, values);
        return this.deleteRecordsSelect(table, selectAndParams[0], selectAndParams[1]);
    };
    /**
     * Delete one or more records from a table which match a particular WHERE clause.
     *
     * @param {string} table The table to delete from.
     * @param {string} [select] A fragment of SQL to be used in a where clause in the SQL call.
     * @param {any[]} [params] Array of sql parameters.
     * @return {Promise<any>} Promise resolved when done.
     */
    SQLiteDB.prototype.deleteRecordsSelect = function (table, select, params) {
        if (select === void 0) { select = ''; }
        if (select) {
            select = 'WHERE ' + select;
        }
        return this.execute("DELETE FROM " + table + " " + select, params);
    };
    /**
     * Execute a SQL query.
     * IMPORTANT: Use this function only if you cannot use any of the other functions in this API. Please take into account that
     * these query will be run in SQLite (Mobile) and Web SQL (desktop), so your query should work in both environments.
     *
     * @param {string} sql SQL query to execute.
     * @param {any[]} params Query parameters.
     * @return {Promise<any>} Promise resolved with the result.
     */
    SQLiteDB.prototype.execute = function (sql, params) {
        var _this = this;
        return this.ready().then(function () {
            return _this.db.executeSql(sql, params);
        });
    };
    /**
     * Execute a set of SQL queries. This operation is atomic.
     * IMPORTANT: Use this function only if you cannot use any of the other functions in this API. Please take into account that
     * these query will be run in SQLite (Mobile) and Web SQL (desktop), so your query should work in both environments.
     *
     * @param {any[]} sqlStatements SQL statements to execute.
     * @return {Promise<any>} Promise resolved with the result.
     */
    SQLiteDB.prototype.executeBatch = function (sqlStatements) {
        var _this = this;
        return this.ready().then(function () {
            return _this.db.sqlBatch(sqlStatements);
        });
    };
    /**
     * Format the data to insert in the database. Removes undefined entries so they are stored as null instead of 'undefined'.
     *
     * @param {object} data Data to insert.
     */
    SQLiteDB.prototype.formatDataToInsert = function (data) {
        // Remove undefined entries and convert null to "NULL".
        for (var name_1 in data) {
            var value = data[name_1];
            if (typeof value == 'undefined') {
                delete data[name_1];
            }
        }
    };
    /**
     * Get all the records from a table.
     *
     * @param {string} table The table to query.
     * @return {Promise<any>} Promise resolved with the records.
     */
    SQLiteDB.prototype.getAllRecords = function (table) {
        return this.getRecords(table);
    };
    /**
     * Get a single field value from a table record where all the given conditions met.
     *
     * @param {string} table The table to query.
     * @param {string} field The field to return the value of.
     * @param {object} [conditions] The conditions to build the where clause. Must not contain numeric indexes.
     * @return {Promise<any>} Promise resolved with the field's value.
     */
    SQLiteDB.prototype.getField = function (table, field, conditions) {
        var selectAndParams = this.whereClause(conditions);
        return this.getFieldSelect(table, field, selectAndParams[0], selectAndParams[1]);
    };
    /**
     * Get a single field value from a table record which match a particular WHERE clause.
     *
     * @param {string} table The table to query.
     * @param {string} field The field to return the value of.
     * @param {string} [select=''] A fragment of SQL to be used in a where clause returning one row with one column.
     * @param {any[]} [params] Array of sql parameters.
     * @return {Promise<any>} Promise resolved with the field's value.
     */
    SQLiteDB.prototype.getFieldSelect = function (table, field, select, params) {
        if (select === void 0) { select = ''; }
        if (select) {
            select = 'WHERE ' + select;
        }
        return this.getFieldSql("SELECT " + field + " FROM " + table + " " + select, params);
    };
    /**
     * Get a single field value (first field) using a SQL statement.
     *
     * @param {string} sql The SQL query returning one row with one column.
     * @param {any[]} [params] An array of sql parameters.
     * @return {Promise<any>} Promise resolved with the field's value.
     */
    SQLiteDB.prototype.getFieldSql = function (sql, params) {
        return this.getRecordSql(sql, params).then(function (record) {
            if (!record) {
                return Promise.reject(null);
            }
            // Return the first property.
            return record[Object.keys(record)[0]];
        });
    };
    /**
     * Constructs 'IN()' or '=' sql fragment
     *
     * @param {any} items A single value or array of values for the expression. It doesn't accept objects.
     * @param {boolean} [equal=true] True means we want to equate to the constructed expression.
     * @param {any} [onEmptyItems] This defines the behavior when the array of items provided is empty. Defaults to false,
     *              meaning return empty. Other values will become part of the returned SQL fragment.
     * @return {any[]} A list containing the constructed sql fragment and an array of parameters.
     */
    SQLiteDB.prototype.getInOrEqual = function (items, equal, onEmptyItems) {
        if (equal === void 0) { equal = true; }
        var sql, params;
        if (typeof onEmptyItems == 'undefined') {
            onEmptyItems = false;
        }
        // Default behavior, return empty data on empty array.
        if (Array.isArray(items) && !items.length && onEmptyItems === false) {
            return ['', []];
        }
        // Handle onEmptyItems on empty array of items.
        if (Array.isArray(items) && !items.length) {
            if (onEmptyItems === null) {
                sql = equal ? ' IS NULL' : ' IS NOT NULL';
                return [sql, []];
            }
            else {
                items = [onEmptyItems]; // Rest of cases, prepare items for processing.
            }
        }
        if (!Array.isArray(items) || items.length == 1) {
            sql = equal ? '= ?' : '<> ?';
            params = Array.isArray(items) ? items : [items];
        }
        else {
            sql = (equal ? '' : 'NOT ') + 'IN (' + ',?'.repeat(items.length).substr(1) + ')';
            params = items;
        }
        return [sql, params];
    };
    /**
     * Get the database name.
     *
     * @return {string} Database name.
     */
    SQLiteDB.prototype.getName = function () {
        return this.name;
    };
    /**
     * Get a single database record where all the given conditions met.
     *
     * @param {string} table The table to query.
     * @param {object} [conditions] The conditions to build the where clause. Must not contain numeric indexes.
     * @param {string} [fields='*'] A comma separated list of fields to return.
     * @return {Promise<any>} Promise resolved with the record, rejected if not found.
     */
    SQLiteDB.prototype.getRecord = function (table, conditions, fields) {
        if (fields === void 0) { fields = '*'; }
        var selectAndParams = this.whereClause(conditions);
        return this.getRecordSelect(table, selectAndParams[0], selectAndParams[1], fields);
    };
    /**
     * Get a single database record as an object which match a particular WHERE clause.
     *
     * @param {string} table The table to query.
     * @param {string} [select] A fragment of SQL to be used in a where clause in the SQL call.
     * @param {any[]} [params] An array of sql parameters.
     * @param {string} [fields='*'] A comma separated list of fields to return.
     * @return {Promise<any>} Promise resolved with the record, rejected if not found.
     */
    SQLiteDB.prototype.getRecordSelect = function (table, select, params, fields) {
        if (select === void 0) { select = ''; }
        if (params === void 0) { params = []; }
        if (fields === void 0) { fields = '*'; }
        if (select) {
            select = ' WHERE ' + select;
        }
        return this.getRecordSql("SELECT " + fields + " FROM " + table + " " + select, params);
    };
    /**
     * Get a single database record as an object using a SQL statement.
     *
     * The SQL statement should normally only return one record.
     * It is recommended to use getRecordsSql() if more matches possible!
     *
     * @param {string} sql The SQL string you wish to be executed, should normally only return one record.
     * @param {any[]} [params] List of sql parameters
     * @return {Promise<any>} Promise resolved with the records.
     */
    SQLiteDB.prototype.getRecordSql = function (sql, params) {
        return this.getRecordsSql(sql, params, 0, 1).then(function (result) {
            if (!result || !result.length) {
                // Not found, reject.
                return Promise.reject(null);
            }
            // Return only the first record.
            return result[0];
        });
    };
    /**
     * Get a number of records where all the given conditions met.
     *
     * @param {string} table The table to query.
     * @param {object} [conditions] The conditions to build the where clause. Must not contain numeric indexes.
     * @param {string} [sort=''] An order to sort the results in.
     * @param {string} [fields='*'] A comma separated list of fields to return.
     * @param {number} [limitFrom=0] Return a subset of records, starting at this point.
     * @param {number} [limitNum=0] Return a subset comprising this many records in total.
     * @return {Promise<any>} Promise resolved with the records.
     */
    SQLiteDB.prototype.getRecords = function (table, conditions, sort, fields, limitFrom, limitNum) {
        if (sort === void 0) { sort = ''; }
        if (fields === void 0) { fields = '*'; }
        if (limitFrom === void 0) { limitFrom = 0; }
        if (limitNum === void 0) { limitNum = 0; }
        var selectAndParams = this.whereClause(conditions);
        return this.getRecordsSelect(table, selectAndParams[0], selectAndParams[1], sort, fields, limitFrom, limitNum);
    };
    /**
     * Get a number of records where one field match one list of values.
     *
     * @param {string} table The database table to be checked against.
     * @param {string} field The name of a field.
     * @param {any[]} values The values field might take.
     * @param {string} [sort=''] An order to sort the results in.
     * @param {string} [fields='*'] A comma separated list of fields to return.
     * @param {number} [limitFrom=0] Return a subset of records, starting at this point.
     * @param {number} [limitNum=0] Return a subset comprising this many records in total.
     * @return {Promise<any>} Promise resolved with the records.
     */
    SQLiteDB.prototype.getRecordsList = function (table, field, values, sort, fields, limitFrom, limitNum) {
        if (sort === void 0) { sort = ''; }
        if (fields === void 0) { fields = '*'; }
        if (limitFrom === void 0) { limitFrom = 0; }
        if (limitNum === void 0) { limitNum = 0; }
        var selectAndParams = this.whereClauseList(field, values);
        return this.getRecordsSelect(table, selectAndParams[0], selectAndParams[1], sort, fields, limitFrom, limitNum);
    };
    /**
     * Get a number of records which match a particular WHERE clause.
     *
     * @param {string} table The table to query.
     * @param {string} [select] A fragment of SQL to be used in a where clause in the SQL call.
     * @param {any[]} [params] An array of sql parameters.
     * @param {string} [sort=''] An order to sort the results in.
     * @param {string} [fields='*'] A comma separated list of fields to return.
     * @param {number} [limitFrom=0] Return a subset of records, starting at this point.
     * @param {number} [limitNum=0] Return a subset comprising this many records in total.
     * @return {Promise<any>} Promise resolved with the records.
     */
    SQLiteDB.prototype.getRecordsSelect = function (table, select, params, sort, fields, limitFrom, limitNum) {
        if (select === void 0) { select = ''; }
        if (params === void 0) { params = []; }
        if (sort === void 0) { sort = ''; }
        if (fields === void 0) { fields = '*'; }
        if (limitFrom === void 0) { limitFrom = 0; }
        if (limitNum === void 0) { limitNum = 0; }
        if (select) {
            select = ' WHERE ' + select;
        }
        if (sort) {
            sort = ' ORDER BY ' + sort;
        }
        var sql = "SELECT " + fields + " FROM " + table + " " + select + " " + sort;
        return this.getRecordsSql(sql, params, limitFrom, limitNum);
    };
    /**
     * Get a number of records using a SQL statement.
     *
     * @param {string} sql The SQL select query to execute.
     * @param {any[]} [params] List of sql parameters
     * @param {number} [limitFrom] Return a subset of records, starting at this point.
     * @param {number} [limitNum] Return a subset comprising this many records.
     * @return {Promise<any>} Promise resolved with the records.
     */
    SQLiteDB.prototype.getRecordsSql = function (sql, params, limitFrom, limitNum) {
        var limits = this.normaliseLimitFromNum(limitFrom, limitNum);
        if (limits[0] || limits[1]) {
            if (limits[1] < 1) {
                limits[1] = Number.MAX_VALUE;
            }
            sql += ' LIMIT ' + limits[0] + ', ' + limits[1];
        }
        return this.execute(sql, params).then(function (result) {
            // Retrieve the records.
            var records = [];
            for (var i = 0; i < result.rows.length; i++) {
                records.push(result.rows.item(i));
            }
            return records;
        });
    };
    /**
     * Given a data object, returns the SQL query and the params to insert that record.
     *
     * @param {string} table The database table.
     * @param {object} data A data object with values for one or more fields in the record.
     * @return {any[]} Array with the SQL query and the params.
     */
    SQLiteDB.prototype.getSqlInsertQuery = function (table, data) {
        this.formatDataToInsert(data);
        var keys = Object.keys(data), fields = keys.join(','), questionMarks = ',?'.repeat(keys.length).substr(1);
        return [
            "INSERT INTO " + table + " (" + fields + ") VALUES (" + questionMarks + ")",
            keys.map(function (key) { return data[key]; })
        ];
    };
    /**
     * Initialize the database.
     */
    SQLiteDB.prototype.init = function () {
        var _this = this;
        this.promise = this.platform.ready().then(function () {
            return _this.sqlite.create({
                name: _this.name,
                location: 'default'
            });
        }).then(function (db) {
            _this.db = db;
        });
    };
    /**
     * Insert or update a record.
     *
     * @param {string} table The database table.
     * @param {object} data An object with the fields to insert/update: fieldname=>fieldvalue.
     * @param {object} conditions The conditions to check if the record already exists.
     * @return {Promise<any>} Promise resolved with done.
     */
    SQLiteDB.prototype.insertOrUpdateRecord = function (table, data, conditions) {
        var _this = this;
        return this.getRecord(table, conditions || data).then(function () {
            // It exists, update it.
            return _this.updateRecords(table, data, conditions);
        }).catch(function () {
            // Doesn't exist, insert it.
            return _this.insertRecord(table, data);
        });
    };
    /**
     * Insert a record into a table and return the "rowId" field.
     *
     * @param {string} table The database table to be inserted into.
     * @param {object} data A data object with values for one or more fields in the record.
     * @return {Promise<number>} Promise resolved with new rowId. Please notice this rowId is internal from SQLite.
     */
    SQLiteDB.prototype.insertRecord = function (table, data) {
        var sqlAndParams = this.getSqlInsertQuery(table, data);
        return this.execute(sqlAndParams[0], sqlAndParams[1]).then(function (result) {
            return result.insertId;
        });
    };
    /**
     * Insert multiple records into database as fast as possible.
     *
     * @param {string} table The database table to be inserted into.
     * @param {object[]} dataObjects List of objects to be inserted.
     * @return {Promise<any>} Promise resolved when done.
     */
    SQLiteDB.prototype.insertRecords = function (table, dataObjects) {
        var _this = this;
        if (!Array.isArray(dataObjects)) {
            return Promise.reject(null);
        }
        var statements = [];
        dataObjects.forEach(function (dataObject) {
            statements.push(_this.getSqlInsertQuery(table, dataObject));
        });
        return this.executeBatch(statements);
    };
    /**
     * Ensures that limit params are numeric and positive integers, to be passed to the database.
     * We explicitly treat null, '' and -1 as 0 in order to provide compatibility with how limit
     * values have been passed historically.
     *
     * @param {any} limitFrom Where to start results from.
     * @param {any} limitNum How many results to return.
     * @return {number[]} Normalised limit params in array: [limitFrom, limitNum].
     */
    SQLiteDB.prototype.normaliseLimitFromNum = function (limitFrom, limitNum) {
        // We explicilty treat these cases as 0.
        if (typeof limitFrom == 'undefined' || limitFrom === null || limitFrom === '' || limitFrom === -1) {
            limitFrom = 0;
        }
        if (typeof limitNum == 'undefined' || limitNum === null || limitNum === '' || limitNum === -1) {
            limitNum = 0;
        }
        limitFrom = parseInt(limitFrom, 10);
        limitNum = parseInt(limitNum, 10);
        limitFrom = Math.max(0, limitFrom);
        limitNum = Math.max(0, limitNum);
        return [limitFrom, limitNum];
    };
    /**
     * Open the database. Only needed if it was closed before, a database is automatically opened when created.
     *
     * @return {Promise<void>} Promise resolved when open.
     */
    SQLiteDB.prototype.open = function () {
        var _this = this;
        return this.ready().then(function () {
            return _this.db.open();
        });
    };
    /**
     * Wait for the DB to be ready.
     *
     * @return {Promise<void>} Promise resolved when ready.
     */
    SQLiteDB.prototype.ready = function () {
        return this.promise;
    };
    /**
     * Test whether a record exists in a table where all the given conditions met.
     *
     * @param {string} table The table to check.
     * @param {object} [conditions] The conditions to build the where clause. Must not contain numeric indexes.
     * @return {Promise<void>} Promise resolved if exists, rejected otherwise.
     */
    SQLiteDB.prototype.recordExists = function (table, conditions) {
        return this.getRecord(table, conditions).then(function (record) {
            if (!record) {
                return Promise.reject(null);
            }
        });
    };
    /**
     * Test whether any records exists in a table which match a particular WHERE clause.
     *
     * @param {string} table The table to query.
     * @param {string} [select] A fragment of SQL to be used in a where clause in the SQL call.
     * @param {any[]} [params] An array of sql parameters.
     * @return {Promise<any>} Promise resolved if exists, rejected otherwise.
     */
    SQLiteDB.prototype.recordExistsSelect = function (table, select, params) {
        if (select === void 0) { select = ''; }
        if (params === void 0) { params = []; }
        return this.getRecordSelect(table, select, params).then(function (record) {
            if (!record) {
                return Promise.reject(null);
            }
        });
    };
    /**
     * Test whether a SQL SELECT statement returns any records.
     *
     * @param {string} sql The SQL query returning one row with one column.
     * @param {any[]} [params] An array of sql parameters.
     * @return {Promise<any>} Promise resolved if exists, rejected otherwise.
     */
    SQLiteDB.prototype.recordExistsSql = function (sql, params) {
        return this.getRecordSql(sql, params).then(function (record) {
            if (!record) {
                return Promise.reject(null);
            }
        });
    };
    /**
     * Update one or more records in a table.
     *
     * @param {string} string table The database table to update.
     * @param {any} data An object with the fields to update: fieldname=>fieldvalue.
     * @param {any} [conditions] The conditions to build the where clause. Must not contain numeric indexes.
     * @return {Promise<any>} Promise resolved when updated.
     */
    SQLiteDB.prototype.updateRecords = function (table, data, conditions) {
        if (!data || !Object.keys(data).length) {
            // No fields to update, consider it's done.
            return Promise.resolve();
        }
        var whereAndParams = this.whereClause(conditions), sets = [];
        var sql, params;
        this.formatDataToInsert(data);
        for (var key in data) {
            sets.push(key + " = ?");
        }
        sql = "UPDATE " + table + " SET " + sets.join(', ') + " WHERE " + whereAndParams[0];
        // Create the list of params using the "data" object and the params for the where clause.
        params = Object.keys(data).map(function (key) { return data[key]; }).concat(whereAndParams[1]);
        return this.execute(sql, params);
    };
    /**
     * Update one or more records in a table. It accepts a WHERE clause as a string.
     *
     * @param {string} string table The database table to update.
     * @param {any} data An object with the fields to update: fieldname=>fieldvalue.
     * @param {string} [where] Where clause. Must not include the "WHERE" word.
     * @param {any[]} [whereParams] Params for the where clause.
     * @return {Promise<any>} Promise resolved when updated.
     */
    SQLiteDB.prototype.updateRecordsWhere = function (table, data, where, whereParams) {
        if (!data || !Object.keys(data).length) {
            // No fields to update, consider it's done.
            return Promise.resolve();
        }
        var sets = [];
        var sql, params;
        for (var key in data) {
            sets.push(key + " = ?");
        }
        sql = "UPDATE " + table + " SET " + sets.join(', ');
        if (where) {
            sql += " WHERE " + where;
        }
        // Create the list of params using the "data" object and the params for the where clause.
        params = Object.keys(data).map(function (key) { return data[key]; });
        if (where && whereParams) {
            params = params.concat(whereParams[1]);
        }
        return this.execute(sql, params);
    };
    /**
     * Returns the SQL WHERE conditions.
     *
     * @param {object} [conditions] The conditions to build the where clause. Must not contain numeric indexes.
     * @return {any[]} An array list containing sql 'where' part and 'params'.
     */
    SQLiteDB.prototype.whereClause = function (conditions) {
        if (conditions === void 0) { conditions = {}; }
        if (!conditions || !Object.keys(conditions).length) {
            return ['', []];
        }
        var where = [], params = [];
        for (var key in conditions) {
            var value = conditions[key];
            if (typeof value == 'undefined' || value === null) {
                where.push(key + ' IS NULL');
            }
            else {
                where.push(key + ' = ?');
                params.push(value);
            }
        }
        return [where.join(' AND '), params];
    };
    /**
     * Returns SQL WHERE conditions for the ..._list group of methods.
     *
     * @param {string} field The name of a field.
     * @param {any[]} values The values field might take.
     * @return {any[]} An array containing sql 'where' part and 'params'.
     */
    SQLiteDB.prototype.whereClauseList = function (field, values) {
        if (!values || !values.length) {
            return ['1 = 2', []]; // Fake condition, won't return rows ever.
        }
        var params = [];
        var select = '';
        values.forEach(function (value) {
            if (typeof value == 'boolean') {
                value = Number(value);
            }
            if (typeof value == 'undefined' || value === null) {
                select = field + ' IS NULL';
            }
            else {
                params.push(value);
            }
        });
        if (params && params.length) {
            if (select !== '') {
                select = select + ' OR ';
            }
            if (params.length == 1) {
                select = select + field + ' = ?';
            }
            else {
                var questionMarks = ',?'.repeat(params.length).substr(1);
                select = select + field + ' IN (' + questionMarks + ')';
            }
        }
        return [select, params];
    };
    return SQLiteDB;
}());

//# sourceMappingURL=sqlitedb.js.map

/***/ }),

/***/ 46:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreConfigConstants; });
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// tslint:disable: variable-name
var CoreConfigConstants = /** @class */ (function () {
    function CoreConfigConstants() {
    }
    CoreConfigConstants.app_id = 'com.moodle.moodlemobile';
    CoreConfigConstants.appname = 'Moodle Mobile';
    CoreConfigConstants.desktopappname = 'Moodle Desktop';
    CoreConfigConstants.versioncode = 3000;
    CoreConfigConstants.versionname = '3.3.5';
    CoreConfigConstants.cache_expiration_time = 300000;
    CoreConfigConstants.default_lang = 'en';
    CoreConfigConstants.languages = {
        'ar': '',
        'bg': '',
        'ca': 'Catal',
        'cs': 'etina',
        'da': 'Dansk',
        'de': 'Deutsch',
        'de-du': 'Deutsch - Du',
        'el': '',
        'en': 'English',
        'es': 'Espaol',
        'es-mx': 'Espaol - Mxico',
        'eu': 'Euskara',
        'fa': '',
        'fr': 'Franais',
        'he': '',
        'hu': 'magyar',
        'it': 'Italiano',
        'lt': 'Lietuvi',
        'ja': '',
        'nl': 'Nederlands',
        'pl': 'Polski',
        'pt-br': 'Portugus - Brasil',
        'pt': 'Portugus - Portugal',
        'ro': 'Romn',
        'ru': '',
        'sr-cr': '',
        'sr-lt': 'Srpski',
        'sv': 'Svenska',
        'tr': 'Trke',
        'uk': '',
        'zh-cn': '',
        'zh-tw': ''
    };
    CoreConfigConstants.wsservice = 'moodle_mobile_app';
    CoreConfigConstants.wsextservice = 'local_mobile';
    CoreConfigConstants.demo_sites = {
        student: {
            url: 'http://school.demo.moodle.net',
            username: 'student',
            password: 'moodle'
        },
        teacher: {
            url: 'http://school.demo.moodle.net',
            username: 'teacher',
            password: 'moodle'
        }
    };
    CoreConfigConstants.gcmpn = '694767596569';
    CoreConfigConstants.customurlscheme = 'moodlemobile';
    CoreConfigConstants.siteurl = '';
    CoreConfigConstants.multisitesdisplay = '';
    CoreConfigConstants.skipssoconfirmation = false;
    CoreConfigConstants.forcedefaultlanguage = false;
    CoreConfigConstants.privacypolicy = 'https://moodle.org/mod/page/view.php?id=8148';
    return CoreConfigConstants;
}());

//# sourceMappingURL=configconstants.js.map

/***/ }),

/***/ 5:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreLoggerProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_moment__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_moment__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Helper service to display messages in the console.
 *
 * @description
 * This service is meant to improve log messages, adding a timestamp and a name to all log messages.
 *
 * In your class constructor, call getInstance to configure your class name:
 * this.logger = logger.getInstance('InitPage');
 *
 * Then you can call the log function you want to use in this logger instance.
 */
var CoreLoggerProvider = /** @class */ (function () {
    function CoreLoggerProvider() {
        /** Whether the logging is enabled. */
        this.enabled = true;
        // Nothing to do.
    }
    /**
     * Get a logger instance for a certain class, service or component.
     *
     * @param {string} className Name to use in the messages.
     * @return {ant} Instance.
     */
    CoreLoggerProvider.prototype.getInstance = function (className) {
        className = className || '';
        return {
            log: this.prepareLogFn(console.log.bind(console), className),
            info: this.prepareLogFn(console.info.bind(console), className),
            warn: this.prepareLogFn(console.warn.bind(console), className),
            debug: this.prepareLogFn(console.debug.bind(console), className),
            error: this.prepareLogFn(console.error.bind(console), className)
        };
    };
    /**
     * Prepare a logging function, concatenating the timestamp and class name to all messages.
     *
     * @param {Function} logFn Log function to use.
     * @param {string} className Name to use in the messages.
     * @return {Function} Prepared function.
     */
    CoreLoggerProvider.prototype.prepareLogFn = function (logFn, className) {
        var _this = this;
        // Return our own function that will call the logging function with the treated message.
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (_this.enabled) {
                var now = __WEBPACK_IMPORTED_MODULE_1_moment__().format('l LTS');
                args[0] = now + ' ' + className + ': ' + args[0]; // Prepend timestamp and className to the original message.
                logFn.apply(null, args);
            }
        };
    };
    CoreLoggerProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [])
    ], CoreLoggerProvider);
    return CoreLoggerProvider;
}());

//# sourceMappingURL=logger.js.map

/***/ }),

/***/ 51:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreInitDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_utils__ = __webpack_require__(9);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/*
 * Provider for initialisation mechanisms.
 */
var CoreInitDelegate = /** @class */ (function () {
    function CoreInitDelegate(logger, platform, utils) {
        this.utils = utils;
        this.initProcesses = {};
        this.logger = logger.getInstance('CoreInitDelegate');
    }
    CoreInitDelegate_1 = CoreInitDelegate;
    /**
     * Executes the registered init processes.
     *
     * Reserved for core use, do not call directly.
     */
    CoreInitDelegate.prototype.executeInitProcesses = function () {
        var _this = this;
        var ordered = [];
        if (typeof this.readiness == 'undefined') {
            this.initReadiness();
        }
        // Re-ordering by priority.
        for (var name_1 in this.initProcesses) {
            ordered.push(this.initProcesses[name_1]);
        }
        ordered.sort(function (a, b) {
            return b.priority - a.priority;
        });
        ordered = ordered.map(function (data) {
            return {
                context: _this,
                func: _this.prepareProcess,
                params: [data],
                blocking: !!data.blocking
            };
        });
        // Execute all the processes in order to solve dependencies.
        this.utils.executeOrderedPromises(ordered).finally(this.readiness.resolve);
    };
    /**
     * Init the readiness promise.
     */
    CoreInitDelegate.prototype.initReadiness = function () {
        var _this = this;
        this.readiness = this.utils.promiseDefer();
        this.readiness.promise.then(function () { return _this.readiness.resolved = true; });
    };
    /**
     * Instantly returns if the app is ready.
     *
     * To be notified when the app is ready, refer to {@link $mmApp#ready}.
     *
     * @return {boolean} Whether it's ready.
     */
    CoreInitDelegate.prototype.isReady = function () {
        return this.readiness.resolved;
    };
    /**
     * Convenience function to return a function that executes the process.
     *
     * @param {CoreInitHandler} data The data of the process.
     * @return {Promise<any>} Promise of the process.
     */
    CoreInitDelegate.prototype.prepareProcess = function (data) {
        var promise;
        this.logger.debug("Executing init process '" + data.name + "'");
        try {
            promise = data.load();
        }
        catch (e) {
            this.logger.error('Error while calling the init process \'' + data.name + '\'. ' + e);
            return;
        }
        return promise;
    };
    /**
     * Notifies when the app is ready. This returns a promise that is resolved when the app is initialised.
     *
     * @return {Promise<any>} Resolved when the app is initialised. Never rejected.
     */
    CoreInitDelegate.prototype.ready = function () {
        if (typeof this.readiness === 'undefined') {
            // Prevent race conditions if this is called before executeInitProcesses.
            this.initReadiness();
        }
        return this.readiness.promise;
    };
    /**
     * Registers an initialisation process.
     *
     * @description
     * Init processes can be used to add initialisation logic to the app. Anything that should block the user interface while
     * some processes are done should be an init process. It is recommended to use a priority lower than MAX_RECOMMENDED_PRIORITY
     * to make sure that your process does not happen before some essential other core processes.
     *
     * An init process should never change state or prompt user interaction.
     *
     * This delegate cannot be used in remote addons.
     *
     * @param {CoreInitHandler} instance The instance of the handler.
     */
    CoreInitDelegate.prototype.registerProcess = function (handler) {
        if (typeof handler.priority == 'undefined') {
            handler.priority = CoreInitDelegate_1.DEFAULT_PRIORITY;
        }
        if (typeof this.initProcesses[handler.name] != 'undefined') {
            this.logger.log("Process '" + handler.name + "' already registered.");
            return;
        }
        this.logger.log("Registering process '" + handler.name + "'.");
        this.initProcesses[handler.name] = handler;
    };
    CoreInitDelegate.DEFAULT_PRIORITY = 100; // Default priority for init processes.
    CoreInitDelegate.MAX_RECOMMENDED_PRIORITY = 600;
    CoreInitDelegate = CoreInitDelegate_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */], __WEBPACK_IMPORTED_MODULE_3__utils_utils__["a" /* CoreUtilsProvider */]])
    ], CoreInitDelegate);
    return CoreInitDelegate;
    var CoreInitDelegate_1;
}());

//# sourceMappingURL=init.js.map

/***/ }),

/***/ 537:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreExternalContentDirective; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_filepool__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_sites__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_dom__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_url__ = __webpack_require__(36);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








/**
 * Directive to handle external content.
 *
 * This directive should be used with any element that links to external content
 * which we want to have available when the app is offline. Typically media and links.
 *
 * If a file is downloaded, its URL will be replaced by the local file URL.
 */
var CoreExternalContentDirective = /** @class */ (function () {
    function CoreExternalContentDirective(element, logger, filepoolProvider, platform, sitesProvider, domUtils, urlUtils, appProvider) {
        this.filepoolProvider = filepoolProvider;
        this.platform = platform;
        this.sitesProvider = sitesProvider;
        this.domUtils = domUtils;
        this.urlUtils = urlUtils;
        this.appProvider = appProvider;
        // This directive can be added dynamically. In that case, the first param is the HTMLElement.
        this.element = element.nativeElement || element;
        this.logger = logger.getInstance('CoreExternalContentDirective');
    }
    /**
     * View has been initialized
     */
    CoreExternalContentDirective.prototype.ngAfterViewInit = function () {
        var currentSite = this.sitesProvider.getCurrentSite(), siteId = this.siteId || (currentSite && currentSite.getId()), tagName = this.element.tagName;
        var targetAttr, sourceAttr;
        if (tagName === 'A') {
            targetAttr = 'href';
            sourceAttr = 'href';
        }
        else if (tagName === 'IMG') {
            targetAttr = 'src';
            sourceAttr = 'src';
        }
        else if (tagName === 'AUDIO' || tagName === 'VIDEO' || tagName === 'SOURCE' || tagName === 'TRACK') {
            targetAttr = 'src';
            sourceAttr = 'targetSrc';
            if (tagName === 'VIDEO') {
                var poster = this.element.poster;
                if (poster) {
                    // Handle poster.
                    this.handleExternalContent('poster', poster, siteId).catch(function () {
                        // Ignore errors.
                    });
                }
            }
        }
        else {
            // Unsupported tag.
            this.logger.warn('Directive attached to non-supported tag: ' + tagName);
            return;
        }
        var url = this.element.getAttribute(sourceAttr) || this.element.getAttribute(targetAttr);
        this.handleExternalContent(targetAttr, url, siteId).catch(function () {
            // Ignore errors.
        });
    };
    /**
     * Add a new source with a certain URL as a sibling of the current element.
     *
     * @param {string} url URL to use in the source.
     */
    CoreExternalContentDirective.prototype.addSource = function (url) {
        if (this.element.tagName !== 'SOURCE') {
            return;
        }
        var newSource = document.createElement('source'), type = this.element.getAttribute('type');
        newSource.setAttribute('src', url);
        if (type) {
            if (this.platform.is('android') && type == 'video/quicktime') {
                // Fix for VideoJS/Chrome bug https://github.com/videojs/video.js/issues/423 .
                newSource.setAttribute('type', 'video/mp4');
            }
            else {
                newSource.setAttribute('type', type);
            }
        }
        this.element.parentNode.insertBefore(newSource, this.element);
    };
    /**
     * Handle external content, setting the right URL.
     *
     * @param {string} targetAttr Attribute to modify.
     * @param {string} url Original URL to treat.
     * @param {string} [siteId] Site ID.
     * @return {Promise<any>} Promise resolved if the element is successfully treated.
     */
    CoreExternalContentDirective.prototype.handleExternalContent = function (targetAttr, url, siteId) {
        var _this = this;
        var tagName = this.element.tagName;
        if (tagName == 'VIDEO' && targetAttr != 'poster') {
            var video = this.element;
            if (video.textTracks) {
                // It's a video with subtitles. In iOS, subtitles position is wrong so it needs to be fixed.
                video.textTracks.onaddtrack = function (event) {
                    var track = event.track;
                    if (track) {
                        track.oncuechange = function () {
                            var line = _this.platform.is('tablet') || _this.platform.is('android') ? 90 : 80;
                            // Position all subtitles to a percentage of video height.
                            Array.from(track.cues).forEach(function (cue) {
                                cue.snapToLines = false;
                                cue.line = line;
                                cue.size = 100; // This solves some Android issue.
                            });
                            // Delete listener.
                            track.oncuechange = null;
                        };
                    }
                };
            }
        }
        if (!url || !url.match(/^https?:\/\//i) || (tagName === 'A' && !this.urlUtils.isDownloadableUrl(url))) {
            this.logger.debug('Ignoring non-downloadable URL: ' + url);
            if (tagName === 'SOURCE') {
                // Restoring original src.
                this.addSource(url);
            }
            return Promise.reject(null);
        }
        // Get the webservice pluginfile URL, we ignore failures here.
        return this.sitesProvider.getSite(siteId).then(function (site) {
            if (!site.canDownloadFiles() && _this.urlUtils.isPluginFileUrl(url)) {
                _this.element.parentElement.removeChild(_this.element); // Remove element since it'll be broken.
                return Promise.reject(null);
            }
            // Download images, tracks and posters if size is unknown.
            var dwnUnknown = tagName == 'IMG' || tagName == 'TRACK' || targetAttr == 'poster';
            var promise;
            if (targetAttr === 'src' && tagName !== 'SOURCE' && tagName !== 'TRACK') {
                promise = _this.filepoolProvider.getSrcByUrl(siteId, url, _this.component, _this.componentId, 0, true, dwnUnknown);
            }
            else {
                promise = _this.filepoolProvider.getUrlByUrl(siteId, url, _this.component, _this.componentId, 0, true, dwnUnknown);
            }
            return promise.then(function (finalUrl) {
                _this.logger.debug('Using URL ' + finalUrl + ' for ' + url);
                if (tagName === 'SOURCE') {
                    // The browser does not catch changes in SRC, we need to add a new source.
                    // @todo: Check if changing src works in Android 4.4, maybe the problem was only in 4.1-4.3.
                    _this.addSource(finalUrl);
                }
                else {
                    _this.element.setAttribute(targetAttr, finalUrl);
                }
                // Set events to download big files (not downloaded automatically).
                if (finalUrl.indexOf('http') === 0 && targetAttr != 'poster' &&
                    (tagName == 'VIDEO' || tagName == 'AUDIO' || tagName == 'A' || tagName == 'SOURCE')) {
                    var eventName = tagName == 'A' ? 'click' : 'play';
                    var clickableEl = _this.element;
                    if (tagName == 'SOURCE') {
                        clickableEl = _this.domUtils.closest(_this.element, 'video,audio');
                        if (!clickableEl) {
                            return;
                        }
                    }
                    clickableEl.addEventListener(eventName, function () {
                        // User played media or opened a downloadable link.
                        // Download the file if in wifi and it hasn't been downloaded already (for big files).
                        if (!_this.appProvider.isNetworkAccessLimited()) {
                            // We aren't using the result, so it doesn't matter which of the 2 functions we call.
                            _this.filepoolProvider.getUrlByUrl(siteId, url, _this.component, _this.componentId, 0, false);
                        }
                    });
                }
            });
        });
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreExternalContentDirective.prototype, "siteId", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreExternalContentDirective.prototype, "component", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreExternalContentDirective.prototype, "componentId", void 0);
    CoreExternalContentDirective = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["s" /* Directive */])({
            selector: '[core-external-content]'
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_3__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_filepool__["a" /* CoreFilepoolProvider */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */], __WEBPACK_IMPORTED_MODULE_5__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_7__providers_utils_url__["a" /* CoreUrlUtilsProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */]])
    ], CoreExternalContentDirective);
    return CoreExternalContentDirective;
}());

//# sourceMappingURL=external-content.js.map

/***/ }),

/***/ 538:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CorePluginFileDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__logger__ = __webpack_require__(5);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Delegate to register pluginfile information handlers.
 */
var CorePluginFileDelegate = /** @class */ (function () {
    function CorePluginFileDelegate(logger) {
        this.handlers = {};
        this.logger = logger.getInstance('CorePluginFileDelegate');
    }
    /**
     * Get the handler for a certain pluginfile url.
     *
     * @param {string} pluginType Type of the plugin.
     * @return {CorePluginFileHandler} Handler. Undefined if no handler found for the plugin.
     */
    CorePluginFileDelegate.prototype.getPluginHandler = function (pluginType) {
        if (typeof this.handlers[pluginType] != 'undefined') {
            return this.handlers[pluginType];
        }
    };
    /**
     * Get the RegExp of the component and filearea described in the URL.
     *
     * @param {string[]} args Arguments of the pluginfile URL defining component and filearea at least.
     * @return {RegExp}  RegExp to match the revision or undefined if not found.
     */
    CorePluginFileDelegate.prototype.getComponentRevisionRegExp = function (args) {
        // Get handler based on component (args[1]).
        var handler = this.getPluginHandler(args[1]);
        if (handler && handler.getComponentRevisionRegExp) {
            return handler.getComponentRevisionRegExp(args);
        }
    };
    /**
     * Register a handler.
     *
     * @param {CorePluginFileHandler} handler The handler to register.
     * @return {boolean} True if registered successfully, false otherwise.
     */
    CorePluginFileDelegate.prototype.registerHandler = function (handler) {
        if (typeof this.handlers[handler.name] !== 'undefined') {
            this.logger.log("Addon '" + handler.name + "' already registered");
            return false;
        }
        this.logger.log("Registered addon '" + handler.name + "'");
        this.handlers[handler.name] = handler;
        return true;
    };
    /**
     * Removes the revision number from a file URL.
     *
     * @param {string} url URL to be replaced.
     * @param {string[]} args Arguments of the pluginfile URL defining component and filearea at least.
     * @return {string} Replaced URL without revision.
     */
    CorePluginFileDelegate.prototype.removeRevisionFromUrl = function (url, args) {
        // Get handler based on component (args[1]).
        var handler = this.getPluginHandler(args[1]);
        if (handler && handler.getComponentRevisionRegExp && handler.getComponentRevisionReplace) {
            var revisionRegex = handler.getComponentRevisionRegExp(args);
            if (revisionRegex) {
                return url.replace(revisionRegex, handler.getComponentRevisionReplace(args));
            }
        }
        return url;
    };
    CorePluginFileDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__logger__["a" /* CoreLoggerProvider */]])
    ], CorePluginFileDelegate);
    return CorePluginFileDelegate;
}());

//# sourceMappingURL=plugin-file-delegate.js.map

/***/ }),

/***/ 539:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSitesFactoryProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__classes_site__ = __webpack_require__(950);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/*
 * Provider to create sites instances.
*/
var CoreSitesFactoryProvider = /** @class */ (function () {
    function CoreSitesFactoryProvider(injector) {
        this.injector = injector;
    }
    /**
     * Make a site object.
     *
     * @param {string} id Site ID.
     * @param {string} siteUrl Site URL.
     * @param {string} [token] Site's WS token.
     * @param {any} [info] Site info.
     * @param {string} [privateToken] Private token.
     * @param {any} [config] Site public config.
     * @param {boolean} [loggedOut] Whether user is logged out.
     * @return {CoreSite} Site instance.
     * @description
     * This returns a site object.
     */
    CoreSitesFactoryProvider.prototype.makeSite = function (id, siteUrl, token, info, privateToken, config, loggedOut) {
        return new __WEBPACK_IMPORTED_MODULE_1__classes_site__["a" /* CoreSite */](this.injector, id, siteUrl, token, info, privateToken, config, loggedOut);
    };
    /**
     * Gets the list of Site methods.
     *
     * @return {string[]} List of methods.
     */
    CoreSitesFactoryProvider.prototype.getSiteMethods = function () {
        var methods = [];
        for (var name_1 in __WEBPACK_IMPORTED_MODULE_1__classes_site__["a" /* CoreSite */].prototype) {
            methods.push(name_1);
        }
        return methods;
    };
    CoreSitesFactoryProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["C" /* Injector */]])
    ], CoreSitesFactoryProvider);
    return CoreSitesFactoryProvider;
}());

//# sourceMappingURL=sites-factory.js.map

/***/ }),

/***/ 541:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreInterceptor; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

/**
 * Interceptor for Http calls. Adds the header 'Content-Type'='application/x-www-form-urlencoded'
 * and serializes the parameters if needed.
 */
var CoreInterceptor = /** @class */ (function () {
    function CoreInterceptor() {
        // Nothing to do.
    }
    CoreInterceptor_1 = CoreInterceptor;
    CoreInterceptor.prototype.intercept = function (req, next) {
        // Add the header and serialize the body if needed.
        var newReq = req.clone({
            headers: req.headers.set('Content-Type', 'application/x-www-form-urlencoded'),
            body: typeof req.body == 'object' && String(req.body) != '[object File]' ?
                CoreInterceptor_1.serialize(req.body) : req.body
        });
        // Pass on the cloned request instead of the original request.
        return next.handle(newReq);
    };
    /**
     * Serialize an object to be used in a request.
     *
     * @param {any} obj Object to serialize.
     * @param {boolean} [addNull] Add null values to the serialized as empty parameters.
     * @return {string} Serialization of the object.
     */
    CoreInterceptor.serialize = function (obj, addNull) {
        var query = '', fullSubName, subValue, innerObj;
        for (var name_1 in obj) {
            var value = obj[name_1];
            if (value instanceof Array) {
                for (var i = 0; i < value.length; ++i) {
                    subValue = value[i];
                    fullSubName = name_1 + '[' + i + ']';
                    innerObj = {};
                    innerObj[fullSubName] = subValue;
                    query += this.serialize(innerObj) + '&';
                }
            }
            else if (value instanceof Object) {
                for (var subName in value) {
                    subValue = value[subName];
                    fullSubName = name_1 + '[' + subName + ']';
                    innerObj = {};
                    innerObj[fullSubName] = subValue;
                    query += this.serialize(innerObj) + '&';
                }
            }
            else if (addNull || (typeof value != 'undefined' && value !== null)) {
                query += encodeURIComponent(name_1) + '=' + encodeURIComponent(value) + '&';
            }
        }
        return query.length ? query.substr(0, query.length - 1) : query;
    };
    CoreInterceptor = CoreInterceptor_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [])
    ], CoreInterceptor);
    return CoreInterceptor;
    var CoreInterceptor_1;
}());

//# sourceMappingURL=interceptor.js.map

/***/ }),

/***/ 542:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreLinkDirective; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_url__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_contentlinks_providers_helper__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__configconstants__ = __webpack_require__(46);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








/**
 * Directive to open a link in external browser.
 */
var CoreLinkDirective = /** @class */ (function () {
    function CoreLinkDirective(element, domUtils, utils, sitesProvider, urlUtils, contentLinksHelper, navCtrl) {
        this.domUtils = domUtils;
        this.utils = utils;
        this.sitesProvider = sitesProvider;
        this.urlUtils = urlUtils;
        this.contentLinksHelper = contentLinksHelper;
        this.navCtrl = navCtrl;
        this.autoLogin = 'check'; // If the link should be open with auto-login. Accepts the following values:
        // This directive can be added dynamically. In that case, the first param is the anchor HTMLElement.
        this.element = element.nativeElement || element;
    }
    /**
     * Function executed when the component is initialized.
     */
    CoreLinkDirective.prototype.ngOnInit = function () {
        var _this = this;
        this.inApp = this.utils.isTrueOrOne(this.inApp);
        this.element.addEventListener('click', function (event) {
            // If the event prevented default action, do nothing.
            if (!event.defaultPrevented) {
                var href_1 = _this.element.getAttribute('href');
                if (href_1) {
                    event.preventDefault();
                    event.stopPropagation();
                    if (_this.utils.isTrueOrOne(_this.capture)) {
                        _this.contentLinksHelper.handleLink(href_1, undefined, _this.navCtrl).then(function (treated) {
                            if (!treated) {
                                _this.navigate(href_1);
                            }
                        });
                    }
                    else {
                        _this.navigate(href_1);
                    }
                }
            }
        });
    };
    /**
     * Convenience function to correctly navigate, open file or url in the browser.
     *
     * @param {string} href HREF to be opened.
     */
    CoreLinkDirective.prototype.navigate = function (href) {
        var _this = this;
        var contentLinksScheme = __WEBPACK_IMPORTED_MODULE_7__configconstants__["a" /* CoreConfigConstants */].customurlscheme + '://link=';
        if (href.indexOf('cdvfile://') === 0 || href.indexOf('file://') === 0) {
            // We have a local file.
            this.utils.openFile(href).catch(function (error) {
                _this.domUtils.showErrorModal(error);
            });
        }
        else if (href.charAt(0) == '#') {
            href = href.substr(1);
            // In site links
            if (href.charAt(0) == '/') {
                // @todo: Investigate how to achieve this behaviour.
                // $location.url(href);
            }
            else {
                // Look for id or name.
                var scrollEl = this.domUtils.closest(this.element, 'scroll-content');
                this.domUtils.scrollToElement(scrollEl, document.body, '#' + href + ', [name=\'' + href + '\']');
            }
        }
        else if (href.indexOf(contentLinksScheme) === 0) {
            // Link should be treated by Custom URL Scheme. Encode the right part, otherwise ':' is removed in iOS.
            href = contentLinksScheme + encodeURIComponent(href.replace(contentLinksScheme, ''));
            this.utils.openInBrowser(href);
        }
        else {
            // It's an external link, we will open with browser. Check if we need to auto-login.
            if (!this.sitesProvider.isLoggedIn()) {
                // Not logged in, cannot auto-login.
                if (this.inApp) {
                    this.utils.openInApp(href);
                }
                else {
                    this.utils.openInBrowser(href);
                }
            }
            else {
                // Check if URL does not have any protocol, so it's a relative URL.
                if (!this.urlUtils.isAbsoluteURL(href)) {
                    // Add the site URL at the begining.
                    if (href.charAt(0) == '/') {
                        href = this.sitesProvider.getCurrentSite().getURL() + href;
                    }
                    else {
                        href = this.sitesProvider.getCurrentSite().getURL() + '/' + href;
                    }
                }
                if (this.autoLogin == 'yes') {
                    if (this.inApp) {
                        this.sitesProvider.getCurrentSite().openInAppWithAutoLogin(href);
                    }
                    else {
                        this.sitesProvider.getCurrentSite().openInBrowserWithAutoLogin(href);
                    }
                }
                else if (this.autoLogin == 'no') {
                    if (this.inApp) {
                        this.utils.openInApp(href);
                    }
                    else {
                        this.utils.openInBrowser(href);
                    }
                }
                else {
                    if (this.inApp) {
                        this.sitesProvider.getCurrentSite().openInAppWithAutoLoginIfSameSite(href);
                    }
                    else {
                        this.sitesProvider.getCurrentSite().openInBrowserWithAutoLoginIfSameSite(href);
                    }
                }
            }
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreLinkDirective.prototype, "capture", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreLinkDirective.prototype, "inApp", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreLinkDirective.prototype, "autoLogin", void 0);
    CoreLinkDirective = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["s" /* Directive */])({
            selector: '[core-link]'
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_utils_url__["a" /* CoreUrlUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_6__core_contentlinks_providers_helper__["a" /* CoreContentLinksHelperProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavController */]])
    ], CoreLinkDirective);
    return CoreLinkDirective;
}());

//# sourceMappingURL=link.js.map

/***/ }),

/***/ 543:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreContextMenuComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__context_menu_popover__ = __webpack_require__(544);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_rxjs__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_rxjs__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * This component adds a button (usually in the navigation bar) that displays a context menu popover.
 */
var CoreContextMenuComponent = /** @class */ (function () {
    function CoreContextMenuComponent(translate, popoverCtrl) {
        var _this = this;
        this.translate = translate;
        this.popoverCtrl = popoverCtrl;
        this.items = [];
        // Create the stream and subscribe to it. We ignore successive changes during 250ms.
        this.itemsChangedStream = new __WEBPACK_IMPORTED_MODULE_4_rxjs__["Subject"]();
        this.itemsChangedStream.auditTime(250).subscribe(function () {
            // Hide the menu if all items are hidden.
            _this.hideMenu = !_this.items.some(function (item) {
                return !item.hidden;
            });
        });
    }
    /**
     * Component being initialized.
     */
    CoreContextMenuComponent.prototype.ngOnInit = function () {
        this.icon = this.icon || 'more';
        this.ariaLabel = this.title || this.translate.instant('core.info');
    };
    /**
     * Add a context menu item.
     *
     * @param {CoreContextMenuItemComponent} item The item to add.
     */
    CoreContextMenuComponent.prototype.addItem = function (item) {
        this.items.push(item);
        this.itemsChanged();
    };
    /**
     * Function called when the items change.
     */
    CoreContextMenuComponent.prototype.itemsChanged = function () {
        this.itemsChangedStream.next();
    };
    /**
     * Remove an item from the context menu.
     *
     * @param {CoreContextMenuItemComponent} item The item to remove.
     */
    CoreContextMenuComponent.prototype.removeItem = function (item) {
        var index = this.items.indexOf(item);
        if (index >= 0) {
            this.items.splice(index, 1);
        }
        this.itemsChanged();
    };
    /**
     * Show the context menu.
     *
     * @param {MouseEvent} event Event.
     */
    CoreContextMenuComponent.prototype.showContextMenu = function (event) {
        var popover = this.popoverCtrl.create(__WEBPACK_IMPORTED_MODULE_3__context_menu_popover__["a" /* CoreContextMenuPopoverComponent */], { title: this.title, items: this.items });
        popover.present({
            ev: event
        });
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreContextMenuComponent.prototype, "icon", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreContextMenuComponent.prototype, "title", void 0);
    CoreContextMenuComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-context-menu',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/components/context-menu/context-menu.html"*/'<button [hidden]="hideMenu" ion-button clear icon-only [attr.aria-label]="ariaLabel" (click)="showContextMenu($event)">\n    <ion-icon [name]="icon"></ion-icon>\n</button>\n<ng-content></ng-content>'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/components/context-menu/context-menu.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["o" /* PopoverController */]])
    ], CoreContextMenuComponent);
    return CoreContextMenuComponent;
}());

//# sourceMappingURL=context-menu.js.map

/***/ }),

/***/ 544:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreContextMenuPopoverComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger__ = __webpack_require__(5);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Component to display a list of items received by param in a popover.
 */
var CoreContextMenuPopoverComponent = /** @class */ (function () {
    function CoreContextMenuPopoverComponent(navParams, viewCtrl, logger) {
        this.viewCtrl = viewCtrl;
        this.title = navParams.get('title');
        this.items = navParams.get('items') || [];
        this.logger = logger.getInstance('CoreContextMenuPopoverComponent');
    }
    /**
     * Close the popover.
     */
    CoreContextMenuPopoverComponent.prototype.closeMenu = function () {
        this.viewCtrl.dismiss();
    };
    /**
     * Function called when an item is clicked.
     *
     * @param {Event} event Click event.
     * @param {CoreContextMenuItemComponent} item Item clicked.
     * @return {boolean} Return true if success, false if error.
     */
    CoreContextMenuPopoverComponent.prototype.itemClicked = function (event, item) {
        if (item.action.observers.length > 0) {
            event.preventDefault();
            event.stopPropagation();
            if (!item.iconAction) {
                this.logger.warn('Items with action must have an icon action to work', item);
                return false;
            }
            else if (item.iconAction == 'spinner') {
                return false;
            }
            if (item.closeOnClick) {
                this.closeMenu();
            }
            item.action.emit(this.closeMenu.bind(this));
        }
        else if (item.href && item.closeOnClick) {
            this.closeMenu();
        }
        return true;
    };
    CoreContextMenuPopoverComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-context-menu-popover',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/components/context-menu/context-menu-popover.html"*/'<ion-list>\n    <ion-list-header *ngIf="title">{{title}}</ion-list-header>\n    <a ion-item text-wrap *ngFor="let item of items" core-link [capture]="item.captureLink" [autoLogin]="item.autoLogin" [href]="item.href" (click)="itemClicked($event, item)" [attr.aria-label]="item.ariaAction" [hidden]="item.hidden" [attr.detail-none]="!item.href || item.iconAction">\n        <ion-icon *ngIf="item.iconDescription" [name]="item.iconDescription" [attr.aria-label]="item.ariaDescription" item-start></ion-icon>\n        <core-format-text [clean]="true" [text]="item.content"></core-format-text>\n        <ion-icon *ngIf="(item.href || item.action) && item.iconAction && item.iconAction != \'spinner\'" [name]="item.iconAction" item-end></ion-icon>\n        <ion-spinner *ngIf="(item.href || item.action) && item.iconAction == \'spinner\'" item-end></ion-spinner>\n        <ion-badge class="{{item.badgeClass}}" item-end *ngIf="item.badge">{{item.badge}}</ion-badge>\n    </a>\n</ion-list>'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/components/context-menu/context-menu-popover.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["m" /* NavParams */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["s" /* ViewController */], __WEBPACK_IMPORTED_MODULE_2__providers_logger__["a" /* CoreLoggerProvider */]])
    ], CoreContextMenuPopoverComponent);
    return CoreContextMenuPopoverComponent;
}());

//# sourceMappingURL=context-menu-popover.js.map

/***/ }),

/***/ 545:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreTabsComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(7);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * This component displays some tabs that usually share data between them.
 *
 * If your tabs don't share any data then you should probably use ion-tabs. This component doesn't use different ion-nav
 * for each tab, so it will not load pages.
 *
 * Example usage:
 *
 * <core-tabs selectedIndex="1">
 *     <core-tab [title]="'core.courses.timeline' | translate" (ionSelect)="switchTab('timeline')">
 *         <ng-template> <!-- This ng-template is required, @see CoreTabComponent. -->
 *             <!-- Tab contents. -->
 *         </ng-template>
 *     </core-tab>
 * </core-tabs>
 *
 * Obviously, the tab contents will only be shown if that tab is selected.
 */
var CoreTabsComponent = /** @class */ (function () {
    function CoreTabsComponent(element, content) {
        this.content = content;
        this.selectedIndex = 0; // Index of the tab to select.
        this.hideUntil = true; // Determine when should the contents be shown.
        this.ionChange = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */](); // Emitted when the tab changes.
        this.tabs = []; // List of tabs.
        this.initialized = false;
        this.afterViewInitTriggered = false;
        this.tabsShown = true;
        this.tabBarElement = element.nativeElement;
    }
    /**
     * Component being initialized.
     */
    CoreTabsComponent.prototype.ngOnInit = function () {
        this.originalTabsContainer = this.originalTabsRef.nativeElement;
        this.topTabsElement = this.topTabs.nativeElement;
    };
    /**
     * View has been initialized.
     */
    CoreTabsComponent.prototype.ngAfterViewInit = function () {
        this.afterViewInitTriggered = true;
        if (!this.initialized && this.hideUntil) {
            // Tabs should be shown, initialize them.
            this.initializeTabs();
        }
    };
    /**
     * Detect changes on input properties.
     */
    CoreTabsComponent.prototype.ngOnChanges = function (changes) {
        var _this = this;
        // We need to wait for ngAfterViewInit because we need core-tab components to be executed.
        if (!this.initialized && this.hideUntil && this.afterViewInitTriggered) {
            // Tabs should be shown, initialize them.
            // Use a setTimeout so child core-tab update their inputs before initializing the tabs.
            setTimeout(function () {
                _this.initializeTabs();
            });
        }
    };
    /**
     * Add a new tab if it isn't already in the list of tabs.
     *
     * @param {CoreTabComponent} tab The tab to add.
     */
    CoreTabsComponent.prototype.addTab = function (tab) {
        // Check if tab is already in the list.
        if (this.getIndex(tab) == -1) {
            this.tabs.push(tab);
            this.sortTabs();
        }
    };
    /**
     * Get the index of tab.
     *
     * @param  {any}    tab [description]
     * @return {number}     [description]
     */
    CoreTabsComponent.prototype.getIndex = function (tab) {
        for (var i = 0; i < this.tabs.length; i++) {
            var t = this.tabs[i];
            if (t === tab || (typeof t.id != 'undefined' && t.id === tab.id)) {
                return i;
            }
        }
        return -1;
    };
    /**
     * Get the current selected tab.
     *
     * @return {CoreTabComponent} Selected tab.
     */
    CoreTabsComponent.prototype.getSelected = function () {
        return this.tabs[this.selected];
    };
    /**
     * Initialize the tabs, determining the first tab to be shown.
     */
    CoreTabsComponent.prototype.initializeTabs = function () {
        var selectedIndex = this.selectedIndex || 0, selectedTab = this.tabs[selectedIndex];
        if (!selectedTab || !selectedTab.enabled || !selectedTab.show) {
            // The tab is not enabled or not shown. Get the first tab that is enabled.
            selectedTab = this.tabs.find(function (tab, index) {
                if (tab.enabled && tab.show) {
                    selectedIndex = index;
                    return true;
                }
                return false;
            });
        }
        if (selectedTab) {
            this.selectTab(selectedIndex);
        }
        // Setup tab scrolling.
        this.tabBarHeight = this.topTabsElement.offsetHeight;
        this.originalTabsContainer.style.paddingBottom = this.tabBarHeight + 'px';
        if (this.content) {
            this.scroll = this.content.getScrollElement();
            if (this.scroll) {
                this.scroll.classList.add('no-scroll');
            }
        }
        this.initialized = true;
    };
    /**
     * Show or hide the tabs. This is used when the user is scrolling inside a tab.
     *
     * @param {any} e Scroll event.
     */
    CoreTabsComponent.prototype.showHideTabs = function (e) {
        if (e.target.scrollTop < this.tabBarHeight) {
            if (!this.tabsShown) {
                this.tabBarElement.classList.remove('tabs-hidden');
                this.tabsShown = true;
            }
        }
        else {
            if (this.tabsShown) {
                this.tabBarElement.classList.add('tabs-hidden');
                this.tabsShown = false;
            }
        }
    };
    /**
     * Remove a tab from the list of tabs.
     *
     * @param {CoreTabComponent} tab The tab to remove.
     */
    CoreTabsComponent.prototype.removeTab = function (tab) {
        var index = this.getIndex(tab);
        this.tabs.splice(index, 1);
    };
    /**
     * Select a certain tab.
     *
     * @param {number} index The index of the tab to select.
     */
    CoreTabsComponent.prototype.selectTab = function (index) {
        if (index == this.selected) {
            // Already selected.
            return;
        }
        if (index < 0 || index >= this.tabs.length) {
            // Index isn't valid, select the first one.
            index = 0;
        }
        var currentTab = this.getSelected(), newTab = this.tabs[index];
        if (!newTab.enabled || !newTab.show) {
            // The tab isn't enabled or shown, stop.
            return;
        }
        if (currentTab) {
            // Unselect previous selected tab.
            currentTab.unselectTab();
        }
        this.selected = index;
        newTab.selectTab();
        this.ionChange.emit(newTab);
    };
    /**
     * Sort the tabs, keeping the same order as in the original list.
     */
    CoreTabsComponent.prototype.sortTabs = function () {
        var _this = this;
        if (this.originalTabsContainer) {
            var newTabs_1 = [];
            var newSelected_1;
            this.tabs.forEach(function (tab, index) {
                var originalIndex = Array.prototype.indexOf.call(_this.originalTabsContainer.children, tab.element);
                if (originalIndex != -1) {
                    newTabs_1[originalIndex] = tab;
                    if (_this.selected == index) {
                        newSelected_1 = originalIndex;
                    }
                }
            });
            this.tabs = newTabs_1;
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreTabsComponent.prototype, "selectedIndex", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreTabsComponent.prototype, "hideUntil", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreTabsComponent.prototype, "ionChange", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])('originalTabs'),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */])
    ], CoreTabsComponent.prototype, "originalTabsRef", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])('topTabs'),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */])
    ], CoreTabsComponent.prototype, "topTabs", void 0);
    CoreTabsComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-tabs',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/components/tabs/tabs.html"*/'<core-loading [hideUntil]="hideUntil" class="core-loading-center">\n    <div class="core-tabs-bar" #topTabs>\n        <ng-container *ngFor="let tab of tabs; let idx = index">\n            <a *ngIf="tab.show" [attr.aria-selected]="selected == idx" (click)="selectTab(idx)">\n                <ion-icon *ngIf="tab.icon" [name]="tab.icon"></ion-icon>\n                <span *ngIf="tab.title">{{ tab.title }}</span>\n                <ion-badge *ngIf="tab.badge" [color]="tab.badgeStyle" class="tab-badge">{{tab.badge}}</ion-badge>\n            </a>\n        </ng-container>\n    </div>\n    <div class="core-tabs-content-container" #originalTabs>\n        <ng-content></ng-content>\n    </div>\n</core-loading>'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/components/tabs/tabs.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["e" /* Content */]])
    ], CoreTabsComponent);
    return CoreTabsComponent;
}());

//# sourceMappingURL=tabs.js.map

/***/ }),

/***/ 546:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreGroupsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__sites__ = __webpack_require__(8);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/*
 * Service to handle groups.
*/
var CoreGroupsProvider = /** @class */ (function () {
    function CoreGroupsProvider(sitesProvider, translate) {
        this.sitesProvider = sitesProvider;
        this.translate = translate;
        this.ROOT_CACHE_KEY = 'mmGroups:';
    }
    CoreGroupsProvider_1 = CoreGroupsProvider;
    /**
     * Check if group mode of an activity is enabled.
     *
     * @param {number} cmId Course module ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with true if the activity has groups, resolved with false otherwise.
     */
    CoreGroupsProvider.prototype.activityHasGroups = function (cmId, siteId) {
        return this.getActivityGroupMode(cmId, siteId).then(function (groupmode) {
            return groupmode === CoreGroupsProvider_1.SEPARATEGROUPS || groupmode === CoreGroupsProvider_1.VISIBLEGROUPS;
        }).catch(function () {
            return false;
        });
    };
    /**
     * Get the groups allowed in an activity.
     *
     * @param {number} cmId Course module ID.
     * @param {number} [userId] User ID. If not defined, use current user.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the groups are retrieved.
     */
    CoreGroupsProvider.prototype.getActivityAllowedGroups = function (cmId, userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            var params = {
                cmid: cmId,
                userid: userId
            }, preSets = {
                cacheKey: _this.getActivityAllowedGroupsCacheKey(cmId, userId)
            };
            return site.read('core_group_get_activity_allowed_groups', params, preSets).then(function (response) {
                if (!response || !response.groups) {
                    return Promise.reject(null);
                }
                return response.groups;
            });
        });
    };
    /**
     * Get cache key for group mode WS calls.
     *
     * @param {number} cmId Course module ID.
     * @param {number} userId User ID.
     * @return {string} Cache key.
     */
    CoreGroupsProvider.prototype.getActivityAllowedGroupsCacheKey = function (cmId, userId) {
        return this.ROOT_CACHE_KEY + 'allowedgroups:' + cmId + ':' + userId;
    };
    /**
     * Get the groups allowed in an activity if they are allowed.
     *
     * @param {number} cmId Course module ID.
     * @param {number} [userId] User ID. If not defined, use current user.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved when the groups are retrieved. If not allowed, empty array will be returned.
     */
    CoreGroupsProvider.prototype.getActivityAllowedGroupsIfEnabled = function (cmId, userId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Get real groupmode, in case it's forced by the course.
        return this.activityHasGroups(cmId, siteId).then(function (hasGroups) {
            if (hasGroups) {
                // Get the groups available for the user.
                return _this.getActivityAllowedGroups(cmId, userId, siteId);
            }
            return [];
        });
    };
    /**
     * Helper function to get activity group info (group mode and list of groups).
     *
     * @param {number} cmId Course module ID.
     * @param {boolean} [addAllParts=true] Whether to add the all participants option. Always true for visible groups.
     * @param {number} [userId] User ID. If not defined, use current user.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<CoreGroupInfo>} Promise resolved with the group info.
     */
    CoreGroupsProvider.prototype.getActivityGroupInfo = function (cmId, addAllParts, userId, siteId) {
        var _this = this;
        if (addAllParts === void 0) { addAllParts = true; }
        var groupInfo = {
            groups: []
        };
        return this.getActivityGroupMode(cmId, siteId).then(function (groupMode) {
            groupInfo.separateGroups = groupMode === CoreGroupsProvider_1.SEPARATEGROUPS;
            groupInfo.visibleGroups = groupMode === CoreGroupsProvider_1.VISIBLEGROUPS;
            if (groupInfo.separateGroups || groupInfo.visibleGroups) {
                return _this.getActivityAllowedGroups(cmId, userId, siteId);
            }
            return [];
        }).then(function (groups) {
            if (groups.length <= 0) {
                groupInfo.separateGroups = false;
                groupInfo.visibleGroups = false;
            }
            else {
                if (addAllParts || groupInfo.visibleGroups) {
                    groupInfo.groups.push({ id: 0, name: _this.translate.instant('core.allparticipants') });
                }
                groupInfo.groups = groupInfo.groups.concat(groups);
            }
            return groupInfo;
        });
    };
    /**
     * Get the group mode of an activity.
     *
     * @param {number} cmId Course module ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<number>} Promise resolved when the group mode is retrieved.
     */
    CoreGroupsProvider.prototype.getActivityGroupMode = function (cmId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                cmid: cmId
            }, preSets = {
                cacheKey: _this.getActivityGroupModeCacheKey(cmId)
            };
            return site.read('core_group_get_activity_groupmode', params, preSets).then(function (response) {
                if (!response || typeof response.groupmode == 'undefined') {
                    return Promise.reject(null);
                }
                return response.groupmode;
            });
        });
    };
    /**
     * Get cache key for group mode WS calls.
     *
     * @param {number} cmId Course module ID.
     * @return {string} Cache key.
     */
    CoreGroupsProvider.prototype.getActivityGroupModeCacheKey = function (cmId) {
        return this.ROOT_CACHE_KEY + 'groupmode:' + cmId;
    };
    /**
     * Get user groups in all the supplied courses.
     *
     * @param {any[]} courses List of courses or course ids to get the groups from.
     * @param {string} [siteId] Site to get the groups from. If not defined, use current site.
     * @param {number} [userId] ID of the user. If not defined, use the userId related to siteId.
     * @return {Promise<any[]>} Promise resolved when the groups are retrieved.
     */
    CoreGroupsProvider.prototype.getUserGroups = function (courses, siteId, userId) {
        var _this = this;
        var promises = [];
        var groups = [];
        courses.forEach(function (course) {
            var courseId = typeof course == 'object' ? course.id : course;
            promises.push(_this.getUserGroupsInCourse(courseId, siteId, userId).then(function (courseGroups) {
                groups = groups.concat(courseGroups);
            }));
        });
        return Promise.all(promises).then(function () {
            return groups;
        });
    };
    /**
     * Get user groups in a course.
     *
     * @param {number} courseId ID of the course.
     * @param {string} [siteId] Site to get the groups from. If not defined, use current site.
     * @param {number} [userId] ID of the user. If not defined, use ID related to siteid.
     * @return {Promise<any[]>} Promise resolved when the groups are retrieved.
     */
    CoreGroupsProvider.prototype.getUserGroupsInCourse = function (courseId, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var data = {
                userid: userId || site.getUserId(),
                courseid: courseId
            }, preSets = {
                cacheKey: _this.getUserGroupsInCourseCacheKey(courseId, userId)
            };
            return site.read('core_group_get_course_user_groups', data, preSets).then(function (response) {
                if (response && response.groups) {
                    return response.groups;
                }
                else {
                    return Promise.reject(null);
                }
            });
        });
    };
    /**
     * Get cache key for user groups in course WS calls.
     *
     * @param {number} courseId Course ID.
     * @param {number} userId User ID.
     * @return {string} Cache key.
     */
    CoreGroupsProvider.prototype.getUserGroupsInCourseCacheKey = function (courseId, userId) {
        return this.ROOT_CACHE_KEY + 'courseGroups:' + courseId + ':' + userId;
    };
    /**
     * Invalidates activity allowed groups.
     *
     * @param {number} cmId Course module ID.
     * @param {number} [userId] User ID. If not defined, use current user.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreGroupsProvider.prototype.invalidateActivityAllowedGroups = function (cmId, userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(_this.getActivityAllowedGroupsCacheKey(cmId, userId));
        });
    };
    /**
     * Invalidates activity group mode.
     *
     * @param {number} cmId Course module ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreGroupsProvider.prototype.invalidateActivityGroupMode = function (cmId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getActivityGroupModeCacheKey(cmId));
        });
    };
    /**
     * Invalidates all activity group info: mode and allowed groups.
     *
     * @param {number} cmId Course module ID.
     * @param {number} [userId] User ID. If not defined, use current user.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreGroupsProvider.prototype.invalidateActivityGroupInfo = function (cmId, userId, siteId) {
        var promises = [];
        promises.push(this.invalidateActivityAllowedGroups(cmId, userId, siteId));
        promises.push(this.invalidateActivityGroupMode(cmId, siteId));
        return Promise.all(promises);
    };
    /**
     * Invalidates user groups in courses.
     *
     * @param {any[]} courses List of courses or course ids.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined, use current user.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreGroupsProvider.prototype.invalidateUserGroups = function (courses, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var promises = [];
            userId = userId || site.getUserId();
            courses.forEach(function (course) {
                var courseId = typeof course == 'object' ? course.id : course;
                promises.push(_this.invalidateUserGroupsInCourse(courseId, site.id, userId));
            });
            return Promise.all(promises);
        });
    };
    /**
     * Invalidates user groups in course.
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined, use current user.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreGroupsProvider.prototype.invalidateUserGroupsInCourse = function (courseId, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(_this.getUserGroupsInCourseCacheKey(courseId, userId));
        });
    };
    // Group mode constants.
    CoreGroupsProvider.NOGROUPS = 0;
    CoreGroupsProvider.SEPARATEGROUPS = 1;
    CoreGroupsProvider.VISIBLEGROUPS = 2;
    CoreGroupsProvider = CoreGroupsProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
    ], CoreGroupsProvider);
    return CoreGroupsProvider;
    var CoreGroupsProvider_1;
}());

//# sourceMappingURL=groups.js.map

/***/ }),

/***/ 547:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseFormatDefaultHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__courses_providers_courses__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__course__ = __webpack_require__(37);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Default handler used when the course format doesn't have a specific implementation.
 */
var CoreCourseFormatDefaultHandler = /** @class */ (function () {
    function CoreCourseFormatDefaultHandler(coursesProvider) {
        this.coursesProvider = coursesProvider;
        this.name = 'default';
    }
    /**
     * Whether or not the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} True or promise resolved with true if enabled.
     */
    CoreCourseFormatDefaultHandler.prototype.isEnabled = function () {
        return true;
    };
    /**
     * Get the title to use in course page.
     *
     * @param {any} course The course.
     * @return {string} Title.
     */
    CoreCourseFormatDefaultHandler.prototype.getCourseTitle = function (course) {
        return course.fullname || '';
    };
    /**
     * Whether it allows seeing all sections at the same time. Defaults to true.
     *
     * @param {any} course The course to check.
     * @type {boolean} Whether it can view all sections.
     */
    CoreCourseFormatDefaultHandler.prototype.canViewAllSections = function (course) {
        return true;
    };
    /**
     * Whether the default section selector should be displayed. Defaults to true.
     *
     * @param {any} course The course to check.
     * @type {boolean} Whether the default section selector should be displayed.
     */
    CoreCourseFormatDefaultHandler.prototype.displaySectionSelector = function (course) {
        return true;
    };
    /**
     * Given a list of sections, get the "current" section that should be displayed first.
     *
     * @param {any} course The course to get the title.
     * @param {any[]} sections List of sections.
     * @return {any|Promise<any>} Current section (or promise resolved with current section).
     */
    CoreCourseFormatDefaultHandler.prototype.getCurrentSection = function (course, sections) {
        // We need the "marker" to determine the current section.
        return this.coursesProvider.getCoursesByField('id', course.id).catch(function () {
            // Ignore errors.
        }).then(function (courses) {
            if (courses && courses[0]) {
                // Find the marked section.
                var course_1 = courses[0];
                for (var i = 0; i < sections.length; i++) {
                    var section = sections[i];
                    if (section.section == course_1.marker) {
                        return section;
                    }
                }
            }
            // Marked section not found or we couldn't retrieve the marker. Return the first section.
            for (var i = 0; i < sections.length; i++) {
                var section = sections[i];
                if (section.id != __WEBPACK_IMPORTED_MODULE_2__course__["a" /* CoreCourseProvider */].ALL_SECTIONS_ID) {
                    return section;
                }
            }
            return Promise.reject(null);
        });
    };
    /**
     * Invalidate the data required to load the course format.
     *
     * @param {any} course The course to get the title.
     * @param {any[]} sections List of sections.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCourseFormatDefaultHandler.prototype.invalidateData = function (course, sections) {
        return this.coursesProvider.invalidateCoursesByField('id', course.id);
    };
    /**
     * Open the page to display a course. If not defined, the page CoreCourseSectionPage will be opened.
     * Implement it only if you want to create your own page to display the course. In general it's better to use the method
     * getCourseFormatComponent because it will display the course handlers at the top.
     * Your page should include the course handlers using CoreCoursesDelegate.
     *
     * @param {NavController} navCtrl The NavController instance to use.
     * @param {any} course The course to open. It should contain a "format" attribute.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseFormatDefaultHandler.prototype.openCourse = function (navCtrl, course) {
        return navCtrl.push('CoreCourseSectionPage', { course: course });
    };
    CoreCourseFormatDefaultHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__courses_providers_courses__["a" /* CoreCoursesProvider */]])
    ], CoreCourseFormatDefaultHandler);
    return CoreCourseFormatDefaultHandler;
}());

//# sourceMappingURL=default-format.js.map

/***/ }),

/***/ 548:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreUserParticipantsComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_user__ = __webpack_require__(112);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__components_split_view_split_view__ = __webpack_require__(251);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Component that displays the list of course participants.
 */
var CoreUserParticipantsComponent = /** @class */ (function () {
    function CoreUserParticipantsComponent(userProvider, domUtils) {
        this.userProvider = userProvider;
        this.domUtils = domUtils;
        this.participants = [];
        this.canLoadMore = false;
        this.participantsLoaded = false;
    }
    /**
     * View loaded.
     */
    CoreUserParticipantsComponent.prototype.ngOnInit = function () {
        var _this = this;
        // Get first participants.
        this.fetchData(true).then(function () {
            if (!_this.participantId && _this.splitviewCtrl.isOn() && _this.participants.length > 0) {
                // Take first and load it.
                _this.gotoParticipant(_this.participants[0].id);
            }
            // Add log in Moodle.
            _this.userProvider.logParticipantsView(_this.courseId).catch(function () {
                // Ignore errors.
            });
        }).finally(function () {
            _this.participantsLoaded = true;
        });
    };
    /**
     * Fetch all the data required for the view.
     *
     * @param {boolean} [refresh] Empty events array first.
     * @return {Promise<any>}     Resolved when done.
     */
    CoreUserParticipantsComponent.prototype.fetchData = function (refresh) {
        var _this = this;
        if (refresh === void 0) { refresh = false; }
        var firstToGet = refresh ? 0 : this.participants.length;
        return this.userProvider.getParticipants(this.courseId, firstToGet).then(function (data) {
            if (refresh) {
                _this.participants = data.participants;
            }
            else {
                _this.participants = _this.participants.concat(data.participants);
            }
            _this.canLoadMore = data.canLoadMore;
        }).catch(function (error) {
            _this.domUtils.showErrorModalDefault(error, 'Error loading participants');
            _this.canLoadMore = false; // Set to false to prevent infinite calls with infinite-loading.
        });
    };
    /**
     * Refresh data.
     *
     * @param {any} refresher Refresher.
     */
    CoreUserParticipantsComponent.prototype.refreshParticipants = function (refresher) {
        var _this = this;
        this.userProvider.invalidateParticipantsList(this.courseId).finally(function () {
            _this.fetchData(true).finally(function () {
                refresher.complete();
            });
        });
    };
    /**
     * Navigate to a particular user profile.
     * @param {number} userId  User Id where to navigate.
     */
    CoreUserParticipantsComponent.prototype.gotoParticipant = function (userId) {
        this.participantId = userId;
        this.splitviewCtrl.push('CoreUserProfilePage', { userId: userId, courseId: this.courseId });
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])(__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["e" /* Content */]),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["e" /* Content */])
    ], CoreUserParticipantsComponent.prototype, "content", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])(__WEBPACK_IMPORTED_MODULE_4__components_split_view_split_view__["a" /* CoreSplitViewComponent */]),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_4__components_split_view_split_view__["a" /* CoreSplitViewComponent */])
    ], CoreUserParticipantsComponent.prototype, "splitviewCtrl", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreUserParticipantsComponent.prototype, "courseId", void 0);
    CoreUserParticipantsComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-user-participants',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/core/user/components/participants/participants.html"*/'<core-split-view>\n    <ion-content>\n        <ion-refresher [enabled]="participantsLoaded" (ionRefresh)="refreshParticipants($event)">\n            <ion-refresher-content pullingText="{{ \'core.pulltorefresh\' | translate }}"></ion-refresher-content>\n        </ion-refresher>\n        <core-loading [hideUntil]="participantsLoaded">\n            <core-empty-box *ngIf="participants && participants.length == 0" icon="person" [message]="\'core.user.noparticipants\' | translate">\n            </core-empty-box>\n\n            <ion-list *ngIf="participants && participants.length > 0" no-margin>\n                <a ion-item text-wrap *ngFor="let participant of participants" [title]="participant.fullname" (click)="gotoParticipant(participant.id)" [class.core-split-item-selected]="participant.id == participantId">\n                    <ion-avatar item-start>\n                        <img src="{{participant.profileimageurl}}" [alt]="\'core.pictureof\' | translate:{$a: participant.fullname}" core-external-content>\n                    </ion-avatar>\n                    <h2><core-format-text [text]="participant.fullname"></core-format-text></h2>\n                    <p *ngIf="participant.lastaccess"><strong>{{ \'core.lastaccess\' | translate }}: </strong>{{ participant.lastaccess * 1000 | coreFormatDate:"dfmediumdate"}}</p>\n                </a>\n            </ion-list>\n\n            <ion-infinite-scroll [enabled]="canLoadMore" (ionInfinite)="$event.waitFor(fetchData())">\n               <ion-infinite-scroll-content></ion-infinite-scroll-content>\n            </ion-infinite-scroll>\n        </core-loading>\n    </ion-content>\n</core-split-view>'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/core/user/components/participants/participants.html"*/,
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_user__["a" /* CoreUserProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__["a" /* CoreDomUtilsProvider */]])
    ], CoreUserParticipantsComponent);
    return CoreUserParticipantsComponent;
}());

//# sourceMappingURL=participants.js.map

/***/ }),

/***/ 56:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreComponentsModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__directives_directives_module__ = __webpack_require__(85);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__pipes_pipes_module__ = __webpack_require__(153);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__loading_loading__ = __webpack_require__(963);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__mark_required_mark_required__ = __webpack_require__(964);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__input_errors_input_errors__ = __webpack_require__(965);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__show_password_show_password__ = __webpack_require__(966);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__split_view_split_view__ = __webpack_require__(251);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__iframe_iframe__ = __webpack_require__(967);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__progress_bar_progress_bar__ = __webpack_require__(968);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__empty_box_empty_box__ = __webpack_require__(969);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__search_box_search_box__ = __webpack_require__(970);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__file_file__ = __webpack_require__(971);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__context_menu_context_menu__ = __webpack_require__(543);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__context_menu_context_menu_item__ = __webpack_require__(972);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__context_menu_context_menu_popover__ = __webpack_require__(544);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__course_picker_menu_course_picker_menu_popover__ = __webpack_require__(645);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__chrono_chrono__ = __webpack_require__(973);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__local_file_local_file__ = __webpack_require__(974);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__site_picker_site_picker__ = __webpack_require__(975);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__tabs_tabs__ = __webpack_require__(545);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__tabs_tab__ = __webpack_require__(976);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__rich_text_editor_rich_text_editor__ = __webpack_require__(977);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__navbar_buttons_navbar_buttons__ = __webpack_require__(978);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__dynamic_component_dynamic_component__ = __webpack_require__(979);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};



























var CoreComponentsModule = /** @class */ (function () {
    function CoreComponentsModule() {
    }
    CoreComponentsModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_5__loading_loading__["a" /* CoreLoadingComponent */],
                __WEBPACK_IMPORTED_MODULE_6__mark_required_mark_required__["a" /* CoreMarkRequiredComponent */],
                __WEBPACK_IMPORTED_MODULE_7__input_errors_input_errors__["a" /* CoreInputErrorsComponent */],
                __WEBPACK_IMPORTED_MODULE_8__show_password_show_password__["a" /* CoreShowPasswordComponent */],
                __WEBPACK_IMPORTED_MODULE_9__split_view_split_view__["a" /* CoreSplitViewComponent */],
                __WEBPACK_IMPORTED_MODULE_10__iframe_iframe__["a" /* CoreIframeComponent */],
                __WEBPACK_IMPORTED_MODULE_11__progress_bar_progress_bar__["a" /* CoreProgressBarComponent */],
                __WEBPACK_IMPORTED_MODULE_12__empty_box_empty_box__["a" /* CoreEmptyBoxComponent */],
                __WEBPACK_IMPORTED_MODULE_13__search_box_search_box__["a" /* CoreSearchBoxComponent */],
                __WEBPACK_IMPORTED_MODULE_14__file_file__["a" /* CoreFileComponent */],
                __WEBPACK_IMPORTED_MODULE_15__context_menu_context_menu__["a" /* CoreContextMenuComponent */],
                __WEBPACK_IMPORTED_MODULE_16__context_menu_context_menu_item__["a" /* CoreContextMenuItemComponent */],
                __WEBPACK_IMPORTED_MODULE_17__context_menu_context_menu_popover__["a" /* CoreContextMenuPopoverComponent */],
                __WEBPACK_IMPORTED_MODULE_18__course_picker_menu_course_picker_menu_popover__["a" /* CoreCoursePickerMenuPopoverComponent */],
                __WEBPACK_IMPORTED_MODULE_19__chrono_chrono__["a" /* CoreChronoComponent */],
                __WEBPACK_IMPORTED_MODULE_20__local_file_local_file__["a" /* CoreLocalFileComponent */],
                __WEBPACK_IMPORTED_MODULE_21__site_picker_site_picker__["a" /* CoreSitePickerComponent */],
                __WEBPACK_IMPORTED_MODULE_22__tabs_tabs__["a" /* CoreTabsComponent */],
                __WEBPACK_IMPORTED_MODULE_23__tabs_tab__["a" /* CoreTabComponent */],
                __WEBPACK_IMPORTED_MODULE_24__rich_text_editor_rich_text_editor__["a" /* CoreRichTextEditorComponent */],
                __WEBPACK_IMPORTED_MODULE_25__navbar_buttons_navbar_buttons__["a" /* CoreNavBarButtonsComponent */],
                __WEBPACK_IMPORTED_MODULE_26__dynamic_component_dynamic_component__["a" /* CoreDynamicComponent */]
            ],
            entryComponents: [
                __WEBPACK_IMPORTED_MODULE_17__context_menu_context_menu_popover__["a" /* CoreContextMenuPopoverComponent */],
                __WEBPACK_IMPORTED_MODULE_18__course_picker_menu_course_picker_menu_popover__["a" /* CoreCoursePickerMenuPopoverComponent */]
            ],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["g" /* IonicModule */],
                __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["b" /* TranslateModule */].forChild(),
                __WEBPACK_IMPORTED_MODULE_3__directives_directives_module__["a" /* CoreDirectivesModule */],
                __WEBPACK_IMPORTED_MODULE_4__pipes_pipes_module__["a" /* CorePipesModule */]
            ],
            exports: [
                __WEBPACK_IMPORTED_MODULE_5__loading_loading__["a" /* CoreLoadingComponent */],
                __WEBPACK_IMPORTED_MODULE_6__mark_required_mark_required__["a" /* CoreMarkRequiredComponent */],
                __WEBPACK_IMPORTED_MODULE_7__input_errors_input_errors__["a" /* CoreInputErrorsComponent */],
                __WEBPACK_IMPORTED_MODULE_8__show_password_show_password__["a" /* CoreShowPasswordComponent */],
                __WEBPACK_IMPORTED_MODULE_9__split_view_split_view__["a" /* CoreSplitViewComponent */],
                __WEBPACK_IMPORTED_MODULE_10__iframe_iframe__["a" /* CoreIframeComponent */],
                __WEBPACK_IMPORTED_MODULE_11__progress_bar_progress_bar__["a" /* CoreProgressBarComponent */],
                __WEBPACK_IMPORTED_MODULE_12__empty_box_empty_box__["a" /* CoreEmptyBoxComponent */],
                __WEBPACK_IMPORTED_MODULE_13__search_box_search_box__["a" /* CoreSearchBoxComponent */],
                __WEBPACK_IMPORTED_MODULE_14__file_file__["a" /* CoreFileComponent */],
                __WEBPACK_IMPORTED_MODULE_15__context_menu_context_menu__["a" /* CoreContextMenuComponent */],
                __WEBPACK_IMPORTED_MODULE_16__context_menu_context_menu_item__["a" /* CoreContextMenuItemComponent */],
                __WEBPACK_IMPORTED_MODULE_19__chrono_chrono__["a" /* CoreChronoComponent */],
                __WEBPACK_IMPORTED_MODULE_20__local_file_local_file__["a" /* CoreLocalFileComponent */],
                __WEBPACK_IMPORTED_MODULE_21__site_picker_site_picker__["a" /* CoreSitePickerComponent */],
                __WEBPACK_IMPORTED_MODULE_22__tabs_tabs__["a" /* CoreTabsComponent */],
                __WEBPACK_IMPORTED_MODULE_23__tabs_tab__["a" /* CoreTabComponent */],
                __WEBPACK_IMPORTED_MODULE_24__rich_text_editor_rich_text_editor__["a" /* CoreRichTextEditorComponent */],
                __WEBPACK_IMPORTED_MODULE_25__navbar_buttons_navbar_buttons__["a" /* CoreNavBarButtonsComponent */],
                __WEBPACK_IMPORTED_MODULE_26__dynamic_component_dynamic_component__["a" /* CoreDynamicComponent */]
            ]
        })
    ], CoreComponentsModule);
    return CoreComponentsModule;
}());

//# sourceMappingURL=components.module.js.map

/***/ }),

/***/ 57:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCoursesProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(8);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Service that provides some features regarding lists of courses and categories.
 */
var CoreCoursesProvider = /** @class */ (function () {
    function CoreCoursesProvider(logger, sitesProvider) {
        this.sitesProvider = sitesProvider;
        this.ROOT_CACHE_KEY = 'mmCourses:';
        this.logger = logger.getInstance('CoreCoursesProvider');
    }
    CoreCoursesProvider_1 = CoreCoursesProvider;
    /**
     * Get categories. They can be filtered by id.
     *
     * @param {number} categoryId Category ID to get.
     * @param {boolean} [addSubcategories] If it should add subcategories to the list.
     * @param {string} [siteId] Site to get the courses from. If not defined, use current site.
     * @return {Promise<any[]>} Promise resolved with the categories.
     */
    CoreCoursesProvider.prototype.getCategories = function (categoryId, addSubcategories, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            // Get parent when id is the root category.
            var criteriaKey = categoryId == 0 ? 'parent' : 'id', data = {
                criteria: [
                    { key: criteriaKey, value: categoryId }
                ],
                addsubcategories: addSubcategories ? 1 : 0
            }, preSets = {
                cacheKey: _this.getCategoriesCacheKey(categoryId, addSubcategories)
            };
            return site.read('core_course_get_categories', data, preSets);
        });
    };
    /**
     * Get cache key for get categories methods WS call.
     *
     * @param {number} categoryId Category ID to get.
     * @param {boolean} [addSubcategories] If add subcategories to the list.
     * @return {string} Cache key.
     */
    CoreCoursesProvider.prototype.getCategoriesCacheKey = function (categoryId, addSubcategories) {
        return this.ROOT_CACHE_KEY + 'categories:' + categoryId + ':' + !!addSubcategories;
    };
    /**
     * Given a list of course IDs to get course admin and nav options, return the list of courseIds to use.
     *
     * @param {number[]} courseIds Course IDs.
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise}            Promise resolved with the list of course IDs.
     */
    CoreCoursesProvider.prototype.getCourseIdsForAdminAndNavOptions = function (courseIds, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var siteHomeId = site.getSiteHomeId();
            if (courseIds.length == 1) {
                // Only 1 course, check if it belongs to the user courses. If so, use all user courses.
                return _this.getUserCourses(true, siteId).then(function (courses) {
                    var courseId = courseIds[0];
                    var useAllCourses = false;
                    if (courseId == siteHomeId) {
                        // It's site home, use all courses.
                        useAllCourses = true;
                    }
                    else {
                        for (var i = 0; i < courses.length; i++) {
                            if (courses[i].id == courseId) {
                                useAllCourses = true;
                                break;
                            }
                        }
                    }
                    if (useAllCourses) {
                        // User is enrolled, retrieve all the courses.
                        courseIds = courses.map(function (course) {
                            return course.id;
                        });
                        // Always add the site home ID.
                        courseIds.push(siteHomeId);
                    }
                    return courseIds;
                }).catch(function () {
                    // Ignore errors.
                    return courseIds;
                });
            }
            else {
                return courseIds;
            }
        });
    };
    /**
     * Check if My Courses is disabled in a certain site.
     *
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<boolean>} Promise resolved with true if disabled, rejected or resolved with false otherwise.
     */
    CoreCoursesProvider.prototype.isMyCoursesDisabled = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.isMyCoursesDisabledInSite(site);
        });
    };
    /**
     * Check if My Courses is disabled in a certain site.
     *
     * @param {CoreSite} [site] Site. If not defined, use current site.
     * @return {boolean} Whether it's disabled.
     */
    CoreCoursesProvider.prototype.isMyCoursesDisabledInSite = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.isFeatureDisabled('$mmSideMenuDelegate_mmCourses');
    };
    /**
     * Check if Search Courses is disabled in a certain site.
     *
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<boolean>} Promise resolved with true if disabled, rejected or resolved with false otherwise.
     */
    CoreCoursesProvider.prototype.isSearchCoursesDisabled = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.isSearchCoursesDisabledInSite(site);
        });
    };
    /**
     * Check if Search Courses is disabled in a certain site.
     *
     * @param {CoreSite} [site] Site. If not defined, use current site.
     * @return {boolean} Whether it's disabled.
     */
    CoreCoursesProvider.prototype.isSearchCoursesDisabledInSite = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.isFeatureDisabled('$mmCoursesDelegate_search');
    };
    /**
     * Get course.
     *
     * @param {number} id ID of the course to get.
     * @param {string} [siteId] Site to get the courses from. If not defined, use current site.
     * @return {Promise<any>} Promise resolved with the course.
     */
    CoreCoursesProvider.prototype.getCourse = function (id, siteId) {
        return this.getCourses([id], siteId).then(function (courses) {
            if (courses && courses.length > 0) {
                return courses[0];
            }
            return Promise.reject(null);
        });
    };
    /**
     * Get the enrolment methods from a course.
     *
     * @param {number} id ID of the course.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any[]} Promise resolved with the methods.
     */
    CoreCoursesProvider.prototype.getCourseEnrolmentMethods = function (id, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                courseid: id
            }, preSets = {
                cacheKey: _this.getCourseEnrolmentMethodsCacheKey(id)
            };
            return site.read('core_enrol_get_course_enrolment_methods', params, preSets);
        });
    };
    /**
     * Get cache key for get course enrolment methods WS call.
     *
     * @param {number} id Course ID.
     * @return {string} Cache key.
     */
    CoreCoursesProvider.prototype.getCourseEnrolmentMethodsCacheKey = function (id) {
        return this.ROOT_CACHE_KEY + 'enrolmentmethods:' + id;
    };
    /**
     * Get info from a course guest enrolment method.
     *
     * @param {number} instanceId Guest instance ID.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the info is retrieved.
     */
    CoreCoursesProvider.prototype.getCourseGuestEnrolmentInfo = function (instanceId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                instanceid: instanceId
            }, preSets = {
                cacheKey: _this.getCourseGuestEnrolmentInfoCacheKey(instanceId)
            };
            return site.read('enrol_guest_get_instance_info', params, preSets).then(function (response) {
                return response.instanceinfo;
            });
        });
    };
    /**
     * Get cache key for get course guest enrolment methods WS call.
     *
     * @param {number} instanceId Guest instance ID.
     * @return {string} Cache key.
     */
    CoreCoursesProvider.prototype.getCourseGuestEnrolmentInfoCacheKey = function (instanceId) {
        return this.ROOT_CACHE_KEY + 'guestinfo:' + instanceId;
    };
    /**
     * Get courses.
     * Warning: if the user doesn't have permissions to view some of the courses passed the WS call will fail.
     * The user must be able to view ALL the courses passed.
     *
     * @param {number[]} ids List of IDs of the courses to get.
     * @param {string} [siteId] Site to get the courses from. If not defined, use current site.
     * @return {Promise<any[]>}  Promise resolved with the courses.
     */
    CoreCoursesProvider.prototype.getCourses = function (ids, siteId) {
        var _this = this;
        if (!Array.isArray(ids)) {
            return Promise.reject(null);
        }
        else if (ids.length === 0) {
            return Promise.resolve([]);
        }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var data = {
                options: {
                    ids: ids
                }
            }, preSets = {
                cacheKey: _this.getCoursesCacheKey(ids)
            };
            return site.read('core_course_get_courses', data, preSets);
        });
    };
    /**
     * Get cache key for get courses WS call.
     *
     * @param {number[]} ids Courses IDs.
     * @return {string} Cache key.
     */
    CoreCoursesProvider.prototype.getCoursesCacheKey = function (ids) {
        return this.ROOT_CACHE_KEY + 'course:' + JSON.stringify(ids);
    };
    /**
     * Get courses. They can be filtered by field.
     *
     * @param {string} [field] The field to search. Can be left empty for all courses or:
     *                             id: course id.
     *                             ids: comma separated course ids.
     *                             shortname: course short name.
     *                             idnumber: course id number.
     *                             category: category id the course belongs to.
     * @param {any} [value] The value to match.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any[]>} Promise resolved with the courses.
     */
    CoreCoursesProvider.prototype.getCoursesByField = function (field, value, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var data = {
                field: field || '',
                value: field ? value : ''
            }, preSets = {
                cacheKey: _this.getCoursesByFieldCacheKey(field, value)
            };
            return site.read('core_course_get_courses_by_field', data, preSets).then(function (courses) {
                if (courses.courses) {
                    // Courses will be sorted using sortorder if avalaible.
                    return courses.courses.sort(function (a, b) {
                        if (typeof a.sortorder == 'undefined' && typeof b.sortorder == 'undefined') {
                            return b.id - a.id;
                        }
                        if (typeof a.sortorder == 'undefined') {
                            return 1;
                        }
                        if (typeof b.sortorder == 'undefined') {
                            return -1;
                        }
                        return a.sortorder - b.sortorder;
                    });
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get cache key for get courses WS call.
     *
     * @param {string} [field] The field to search.
     * @param {any} [value] The value to match.
     * @return {string} Cache key.
     */
    CoreCoursesProvider.prototype.getCoursesByFieldCacheKey = function (field, value) {
        field = field || '';
        value = field ? value : '';
        return this.ROOT_CACHE_KEY + 'coursesbyfield:' + field + ':' + value;
    };
    /**
     * Check if get courses by field WS is available.
     *
     * @return {boolean} Whether get courses by field is available.
     */
    CoreCoursesProvider.prototype.isGetCoursesByFieldAvailable = function () {
        return this.sitesProvider.getCurrentSite().wsAvailable('core_course_get_courses_by_field');
    };
    /**
     * Get the navigation and administration options for the given courses.
     *
     * @param {number[]} courseIds IDs of courses to get.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<{navOptions: any, admOptions: any}>} Promise resolved with the options for each course.
     */
    CoreCoursesProvider.prototype.getCoursesAdminAndNavOptions = function (courseIds, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Get the list of courseIds to use based on the param.
        return this.getCourseIdsForAdminAndNavOptions(courseIds, siteId).then(function (courseIds) {
            var promises = [];
            var navOptions, admOptions;
            // Get user navigation and administration options.
            promises.push(_this.getUserNavigationOptions(courseIds, siteId).catch(function () {
                // Couldn't get it, return empty options.
                return {};
            }).then(function (options) {
                navOptions = options;
            }));
            promises.push(_this.getUserAdministrationOptions(courseIds, siteId).catch(function () {
                // Couldn't get it, return empty options.
                return {};
            }).then(function (options) {
                admOptions = options;
            }));
            return Promise.all(promises).then(function () {
                return { navOptions: navOptions, admOptions: admOptions };
            });
        });
    };
    /**
     * Get the common part of the cache keys for user administration options WS calls.
     *
     * @return {string} Cache key.
     */
    CoreCoursesProvider.prototype.getUserAdministrationOptionsCommonCacheKey = function () {
        return this.ROOT_CACHE_KEY + 'administrationOptions:';
    };
    /**
     * Get cache key for get user administration options WS call.
     *
     * @param {number[]} courseIds IDs of courses to get.
     * @return {string} Cache key.
     */
    CoreCoursesProvider.prototype.getUserAdministrationOptionsCacheKey = function (courseIds) {
        return this.getUserAdministrationOptionsCommonCacheKey() + courseIds.join(',');
    };
    /**
     * Get user administration options for a set of courses.
     *
     * @param {number[]} courseIds IDs of courses to get.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with administration options for each course.
     */
    CoreCoursesProvider.prototype.getUserAdministrationOptions = function (courseIds, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                courseids: courseIds
            }, preSets = {
                cacheKey: _this.getUserAdministrationOptionsCacheKey(courseIds)
            };
            return site.read('core_course_get_user_administration_options', params, preSets).then(function (response) {
                // Format returned data.
                return _this.formatUserAdminOrNavOptions(response.courses);
            });
        });
    };
    /**
     * Get the common part of the cache keys for user navigation options WS calls.
     *
     * @param {number[]} courseIds IDs of courses to get.
     * @return {string} Cache key.
     */
    CoreCoursesProvider.prototype.getUserNavigationOptionsCommonCacheKey = function () {
        return this.ROOT_CACHE_KEY + 'navigationOptions:';
    };
    /**
     * Get cache key for get user navigation options WS call.
     *
     * @return {string} Cache key.
     */
    CoreCoursesProvider.prototype.getUserNavigationOptionsCacheKey = function (courseIds) {
        return this.getUserNavigationOptionsCommonCacheKey() + courseIds.join(',');
    };
    /**
     * Get user navigation options for a set of courses.
     *
     * @param {number[]} courseIds IDs of courses to get.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with navigation options for each course.
     */
    CoreCoursesProvider.prototype.getUserNavigationOptions = function (courseIds, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                courseids: courseIds
            }, preSets = {
                cacheKey: _this.getUserNavigationOptionsCacheKey(courseIds)
            };
            return site.read('core_course_get_user_navigation_options', params, preSets).then(function (response) {
                // Format returned data.
                return _this.formatUserAdminOrNavOptions(response.courses);
            });
        });
    };
    /**
     * Format user navigation or administration options.
     *
     * @param {any[]} courses Navigation or administration options for each course.
     * @return {any} Formatted options.
     */
    CoreCoursesProvider.prototype.formatUserAdminOrNavOptions = function (courses) {
        var result = {};
        courses.forEach(function (course) {
            var options = {};
            if (course.options) {
                course.options.forEach(function (option) {
                    options[option.name] = option.available;
                });
            }
            result[course.id] = options;
        });
        return result;
    };
    /**
     * Get a course the user is enrolled in. This function relies on getUserCourses.
     * preferCache=true will try to speed up the response, but the data returned might not be updated.
     *
     * @param {number} id ID of the course to get.
     * @param {boolean} [preferCache] True if shouldn't call WS if data is cached, false otherwise.
     * @param {string} [siteId] Site to get the courses from. If not defined, use current site.
     * @return {Promise<any>} Promise resolved with the course.
     */
    CoreCoursesProvider.prototype.getUserCourse = function (id, preferCache, siteId) {
        if (!id) {
            return Promise.reject(null);
        }
        return this.getUserCourses(preferCache, siteId).then(function (courses) {
            var course;
            for (var i in courses) {
                if (courses[i].id == id) {
                    course = courses[i];
                    break;
                }
            }
            return course ? course : Promise.reject(null);
        });
    };
    /**
     * Get user courses.
     *
     * @param {boolean} [preferCache] True if shouldn't call WS if data is cached, false otherwise.
     * @param {string} [siteId] Site to get the courses from. If not defined, use current site.
     * @return {Promise<any[]>} Promise resolved with the courses.
     */
    CoreCoursesProvider.prototype.getUserCourses = function (preferCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var userId = site.getUserId(), data = {
                userid: userId
            }, preSets = {
                cacheKey: _this.getUserCoursesCacheKey(),
                omitExpires: !!preferCache
            };
            return site.read('core_enrol_get_users_courses', data, preSets);
        });
    };
    /**
     * Get cache key for get user courses WS call.
     *
     * @return {string} Cache key.
     */
    CoreCoursesProvider.prototype.getUserCoursesCacheKey = function () {
        return this.ROOT_CACHE_KEY + 'usercourses';
    };
    /**
     * Invalidates get categories WS call.
     *
     * @param {number} categoryId Category ID to get.
     * @param {boolean} [addSubcategories] If it should add subcategories to the list.
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesProvider.prototype.invalidateCategories = function (categoryId, addSubcategories, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getCategoriesCacheKey(categoryId, addSubcategories));
        });
    };
    /**
     * Invalidates get course WS call.
     *
     * @param {number} id Course ID.
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesProvider.prototype.invalidateCourse = function (id, siteId) {
        return this.invalidateCourses([id], siteId);
    };
    /**
     * Invalidates get course enrolment methods WS call.
     *
     * @param {number} id Course ID.
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesProvider.prototype.invalidateCourseEnrolmentMethods = function (id, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getCourseEnrolmentMethodsCacheKey(id));
        });
    };
    /**
     * Invalidates get course guest enrolment info WS call.
     *
     * @param {number} instanceId Guest instance ID.
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesProvider.prototype.invalidateCourseGuestEnrolmentInfo = function (instanceId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getCourseGuestEnrolmentInfoCacheKey(instanceId));
        });
    };
    /**
     * Invalidates the navigation and administration options for the given courses.
     *
     * @param {number[]} courseIds IDs of courses to get.
     * @param {string} [siteId] Site ID to invalidate. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesProvider.prototype.invalidateCoursesAdminAndNavOptions = function (courseIds, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.getCourseIdsForAdminAndNavOptions(courseIds, siteId).then(function (ids) {
            var promises = [];
            promises.push(_this.invalidateUserAdministrationOptionsForCourses(ids, siteId));
            promises.push(_this.invalidateUserNavigationOptionsForCourses(ids, siteId));
            return Promise.all(promises);
        });
    };
    /**
     * Invalidates get courses WS call.
     *
     * @param {number[]} ids Courses IDs.
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesProvider.prototype.invalidateCourses = function (ids, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getCoursesCacheKey(ids));
        });
    };
    /**
     * Invalidates get courses by field WS call.
     *
     * @param {string} [field] See getCoursesByField for info.
     * @param {any} [value] The value to match.
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesProvider.prototype.invalidateCoursesByField = function (field, value, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getCoursesByFieldCacheKey(field, value));
        });
    };
    /**
     * Invalidates all user administration options.
     *
     * @param {string} [siteId] Site ID to invalidate. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesProvider.prototype.invalidateUserAdministrationOptions = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getUserAdministrationOptionsCommonCacheKey());
        });
    };
    /**
     * Invalidates user administration options for certain courses.
     *
     * @param {number[]} courseIds IDs of courses.
     * @param {string} [siteId] Site ID to invalidate. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesProvider.prototype.invalidateUserAdministrationOptionsForCourses = function (courseIds, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getUserAdministrationOptionsCacheKey(courseIds));
        });
    };
    /**
     * Invalidates get user courses WS call.
     *
     * @param {string} [siteId] Site ID to invalidate. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesProvider.prototype.invalidateUserCourses = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getUserCoursesCacheKey());
        });
    };
    /**
     * Invalidates all user navigation options.
     *
     * @param {string} [siteId] Site ID to invalidate. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesProvider.prototype.invalidateUserNavigationOptions = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getUserNavigationOptionsCommonCacheKey());
        });
    };
    /**
     * Invalidates user navigation options for certain courses.
     *
     * @param {number[]} courseIds IDs of courses.
     * @param {string} [siteId] Site ID to invalidate. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesProvider.prototype.invalidateUserNavigationOptionsForCourses = function (courseIds, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getUserNavigationOptionsCacheKey(courseIds));
        });
    };
    /**
     * Check if WS to retrieve guest enrolment data is available.
     *
     * @return {boolean} Whether guest WS is available.
     */
    CoreCoursesProvider.prototype.isGuestWSAvailable = function () {
        var currentSite = this.sitesProvider.getCurrentSite();
        return currentSite && currentSite.wsAvailable('enrol_guest_get_instance_info');
    };
    /**
     * Search courses.
     *
     * @param {string} text Text to search.
     * @param {number} [page=0] Page to get.
     * @param {number} [perPage] Number of courses per page. Defaults to CoreCoursesProvider.SEARCH_PER_PAGE.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<{total: number, courses: any[]}>} Promise resolved with the courses and the total of matches.
     */
    CoreCoursesProvider.prototype.search = function (text, page, perPage, siteId) {
        if (page === void 0) { page = 0; }
        perPage = perPage || CoreCoursesProvider_1.SEARCH_PER_PAGE;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                criterianame: 'search',
                criteriavalue: text,
                page: page,
                perpage: perPage
            }, preSets = {
                getFromCache: false
            };
            return site.read('core_course_search_courses', params, preSets).then(function (response) {
                return { total: response.total, courses: response.courses };
            });
        });
    };
    /**
     * Self enrol current user in a certain course.
     *
     * @param {number} courseId Course ID.
     * @param {string} [password] Password to use.
     * @param {number} [instanceId] Enrol instance ID.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any>} Promise resolved if the user is enrolled. If the password is invalid, the promise is rejected
     *                        with an object with code = CoreCoursesProvider.ENROL_INVALID_KEY.
     */
    CoreCoursesProvider.prototype.selfEnrol = function (courseId, password, instanceId, siteId) {
        if (password === void 0) { password = ''; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                courseid: courseId,
                password: password
            };
            if (instanceId) {
                params.instanceid = instanceId;
            }
            return site.write('enrol_self_enrol_user', params).then(function (response) {
                if (response) {
                    if (response.status) {
                        return true;
                    }
                    else if (response.warnings && response.warnings.length) {
                        var message_1;
                        response.warnings.forEach(function (warning) {
                            // Invalid password warnings.
                            if (warning.warningcode == '2' || warning.warningcode == '3' || warning.warningcode == '4') {
                                message_1 = warning.message;
                            }
                        });
                        if (message_1) {
                            return Promise.reject({ code: CoreCoursesProvider_1.ENROL_INVALID_KEY, message: message_1 });
                        }
                        else {
                            return Promise.reject(response.warnings[0]);
                        }
                    }
                }
                return Promise.reject(null);
            });
        });
    };
    CoreCoursesProvider.SEARCH_PER_PAGE = 20;
    CoreCoursesProvider.ENROL_INVALID_KEY = 'CoreCoursesEnrolInvalidKey';
    CoreCoursesProvider.EVENT_MY_COURSES_UPDATED = 'courses_my_courses_updated';
    CoreCoursesProvider.EVENT_MY_COURSES_REFRESHED = 'courses_my_courses_refreshed';
    CoreCoursesProvider = CoreCoursesProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */]])
    ], CoreCoursesProvider);
    return CoreCoursesProvider;
    var CoreCoursesProvider_1;
}());

//# sourceMappingURL=courses.js.map

/***/ }),

/***/ 590:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FileTransferErrorMock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return FileTransferMock; });
/* unused harmony export FileTransferObjectMock */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_file_transfer__ = __webpack_require__(214);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_file__ = __webpack_require__(30);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Mock the File Transfer Error.
 */
var FileTransferErrorMock = /** @class */ (function () {
    // tslint:disable-next-line: variable-name
    function FileTransferErrorMock(code, source, target, http_status, body, exception) {
        this.code = code;
        this.source = source;
        this.target = target;
        this.http_status = http_status;
        this.body = body;
        this.exception = exception;
    }
    FileTransferErrorMock.FILE_NOT_FOUND_ERR = 1;
    FileTransferErrorMock.INVALID_URL_ERR = 2;
    FileTransferErrorMock.CONNECTION_ERR = 3;
    FileTransferErrorMock.ABORT_ERR = 4;
    FileTransferErrorMock.NOT_MODIFIED_ERR = 5;
    return FileTransferErrorMock;
}());

/**
 * Emulates the Cordova FileTransfer plugin in desktop apps and in browser.
 */
var FileTransferMock = /** @class */ (function (_super) {
    __extends(FileTransferMock, _super);
    function FileTransferMock(appProvider, fileProvider) {
        var _this = _super.call(this) || this;
        _this.appProvider = appProvider;
        _this.fileProvider = fileProvider;
        return _this;
    }
    /**
     * Creates a new FileTransferObjectMock object.
     *
     * @return {FileTransferObjectMock}
     */
    FileTransferMock.prototype.create = function () {
        return new FileTransferObjectMock(this.appProvider, this.fileProvider);
    };
    FileTransferMock = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_file__["a" /* CoreFileProvider */]])
    ], FileTransferMock);
    return FileTransferMock;
}(__WEBPACK_IMPORTED_MODULE_1__ionic_native_file_transfer__["a" /* FileTransfer */]));

/**
 * Emulates the FileTransferObject class in desktop apps and in browser.
 */
var FileTransferObjectMock = /** @class */ (function (_super) {
    __extends(FileTransferObjectMock, _super);
    function FileTransferObjectMock(appProvider, fileProvider) {
        var _this = _super.call(this) || this;
        _this.appProvider = appProvider;
        _this.fileProvider = fileProvider;
        return _this;
    }
    /**
     * Aborts an in-progress transfer. The onerror callback is passed a FileTransferError
     * object which has an error code of FileTransferError.ABORT_ERR.
     */
    FileTransferObjectMock.prototype.abort = function () {
        if (this.xhr) {
            this.xhr.abort();
            this.reject(new FileTransferErrorMock(FileTransferErrorMock.ABORT_ERR, this.source, this.target, null, null, null));
        }
    };
    /**
     * Downloads a file from server.
     *
     * @param {string} source URL of the server to download the file, as encoded by encodeURI().
     * @param {string} target Filesystem url representing the file on the device.
     * @param {boolean} [trustAllHosts] If set to true, it accepts all security certificates.
     * @param {object} [options] Optional parameters, currently only supports headers.
     * @returns {Promise<any>} Returns a Promise that resolves to a FileEntry object.
     */
    FileTransferObjectMock.prototype.download = function (source, target, trustAllHosts, options) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            // Use XMLHttpRequest instead of HttpClient to support onprogress and abort.
            var basicAuthHeader = _this.getBasicAuthHeader(source), xhr = new XMLHttpRequest(), isDesktop = _this.appProvider.isDesktop();
            var headers = null;
            _this.xhr = xhr;
            _this.source = source;
            _this.target = target;
            _this.reject = reject;
            if (basicAuthHeader) {
                source = source.replace(_this.getUrlCredentials(source) + '@', '');
                options = options || {};
                options.headers = options.headers || {};
                options.headers[basicAuthHeader.name] = basicAuthHeader.value;
            }
            if (options) {
                headers = options.headers || null;
            }
            // Prepare the request.
            xhr.open('GET', source, true);
            xhr.responseType = isDesktop ? 'arraybuffer' : 'blob';
            for (var name_1 in headers) {
                xhr.setRequestHeader(name_1, headers[name_1]);
            }
            xhr.onprogress = function (xhr, ev) {
                if (_this.progressListener) {
                    _this.progressListener(ev);
                }
            };
            xhr.onerror = function (err) {
                reject(new FileTransferError(-1, source, target, xhr.status, xhr.statusText));
            };
            xhr.onload = function () {
                // Finished dowloading the file.
                var response = xhr.response;
                if (!response) {
                    reject();
                }
                else {
                    var basePath = _this.fileProvider.getBasePathInstant();
                    target = target.replace(basePath, ''); // Remove basePath from the target.
                    target = target.replace(/%20/g, ' '); // Replace all %20 with spaces.
                    if (isDesktop) {
                        // In desktop we need to convert the arraybuffer into a Buffer.
                        response = Buffer.from(new Uint8Array(response));
                    }
                    _this.fileProvider.writeFile(target, response).then(resolve, reject);
                }
            };
            xhr.send();
        });
    };
    /**
     * Given a URL, check if it has a credentials in it and, if so, return them in a header object.
     * This code is extracted from Cordova FileTransfer plugin.
     *
     * @param {string} urlString The URL to get the credentials from.
     * @return {any} The header with the credentials, null if no credentials.
     */
    FileTransferObjectMock.prototype.getBasicAuthHeader = function (urlString) {
        var header = null;
        // MS Windows doesn't support credentials in http uris so we detect them by regexp and strip off from result url.
        if (window.btoa) {
            var credentials = this.getUrlCredentials(urlString);
            if (credentials) {
                var authHeader = 'Authorization', authHeaderValue = 'Basic ' + window.btoa(credentials);
                header = {
                    name: authHeader,
                    value: authHeaderValue
                };
            }
        }
        return header;
    };
    /**
     * Given an instance of XMLHttpRequest, get the response headers as an object.
     *
     * @param {XMLHttpRequest} xhr XMLHttpRequest instance.
     * @return {{[s: string]: any}} Object with the headers.
     */
    FileTransferObjectMock.prototype.getHeadersAsObject = function (xhr) {
        var headersString = xhr.getAllResponseHeaders(), result = {};
        if (headersString) {
            var headers = headersString.split('\n');
            for (var i in headers) {
                var headerString = headers[i], separatorPos = headerString.indexOf(':');
                if (separatorPos != -1) {
                    result[headerString.substr(0, separatorPos)] = headerString.substr(separatorPos + 1).trim();
                }
            }
        }
        return result;
    };
    /**
     * Get the credentials from a URL.
     * This code is extracted from Cordova FileTransfer plugin.
     *
     * @param {string} urlString The URL to get the credentials from.
     * @return {string} Retrieved credentials.
     */
    FileTransferObjectMock.prototype.getUrlCredentials = function (urlString) {
        var credentialsPattern = /^https?\:\/\/(?:(?:(([^:@\/]*)(?::([^@\/]*))?)?@)?([^:\/?#]*)(?::(\d*))?).*$/, credentials = credentialsPattern.exec(urlString);
        return credentials && credentials[1];
    };
    /**
     * Registers a listener that gets called whenever a new chunk of data is transferred.
     *
     * @param {Function} listener Listener that takes a progress event.
     */
    FileTransferObjectMock.prototype.onProgress = function (listener) {
        this.progressListener = listener;
    };
    /**
     * Sends a file to a server.
     *
     * @param {string} fileUrl Filesystem URL representing the file on the device or a data URI.
     * @param {string} url URL of the server to receive the file, as encoded by encodeURI().
     * @param {FileUploadOptions} [options] Optional parameters.
     * @param {boolean} [trustAllHosts] If set to true, it accepts all security certificates.
     * @returns {Promise<FileUploadResult>} Promise that resolves to a FileUploadResult and rejects with FileTransferError.
     */
    FileTransferObjectMock.prototype.upload = function (fileUrl, url, options, trustAllHosts) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var basicAuthHeader = _this.getBasicAuthHeader(url);
            var fileKey = null, fileName = null, mimeType = null, params = null, headers = null, httpMethod = null;
            if (basicAuthHeader) {
                url = url.replace(_this.getUrlCredentials(url) + '@', '');
                options = options || {};
                options.headers = options.headers || {};
                options.headers[basicAuthHeader.name] = basicAuthHeader.value;
            }
            if (options) {
                fileKey = options.fileKey;
                fileName = options.fileName;
                mimeType = options.mimeType;
                headers = options.headers;
                httpMethod = options.httpMethod || 'POST';
                if (httpMethod.toUpperCase() == 'PUT') {
                    httpMethod = 'PUT';
                }
                else {
                    httpMethod = 'POST';
                }
                if (options.params) {
                    params = options.params;
                }
                else {
                    params = {};
                }
            }
            // Add fileKey and fileName to the headers.
            headers = headers || {};
            if (!headers['Content-Disposition']) {
                headers['Content-Disposition'] = 'form-data;' + (fileKey ? ' name="' + fileKey + '";' : '') +
                    (fileName ? ' filename="' + fileName + '"' : '');
            }
            // Adding a Content-Type header with the mimeType makes the request fail (it doesn't detect the token in the params).
            // Don't include this header, and delete it if it's supplied.
            delete headers['Content-Type'];
            // Get the file to upload.
            _this.fileProvider.getFile(fileUrl).then(function (fileEntry) {
                return _this.fileProvider.getFileObjectFromFileEntry(fileEntry);
            }).then(function (file) {
                // Use XMLHttpRequest instead of HttpClient to support onprogress and abort.
                var xhr = new XMLHttpRequest();
                xhr.open(httpMethod || 'POST', url);
                for (var name_2 in headers) {
                    // Filter "unsafe" headers.
                    if (name_2 != 'Connection') {
                        xhr.setRequestHeader(name_2, headers[name_2]);
                    }
                }
                xhr.onprogress = function (ev) {
                    if (_this.progressListener) {
                        _this.progressListener(ev);
                    }
                };
                _this.xhr = xhr;
                _this.source = fileUrl;
                _this.target = url;
                _this.reject = reject;
                xhr.onerror = function () {
                    reject(new FileTransferError(-1, fileUrl, url, xhr.status, xhr.statusText));
                };
                xhr.onload = function () {
                    // Finished uploading the file.
                    resolve({
                        bytesSent: file.size,
                        responseCode: xhr.status,
                        response: xhr.response,
                        headers: _this.getHeadersAsObject(xhr)
                    });
                };
                // Create a form data to send params and the file.
                var fd = new FormData();
                for (var name_3 in params) {
                    fd.append(name_3, params[name_3]);
                }
                fd.append('file', file);
                xhr.send(fd);
            }).catch(reject);
        });
    };
    return FileTransferObjectMock;
}(__WEBPACK_IMPORTED_MODULE_1__ionic_native_file_transfer__["b" /* FileTransferObject */]));

//# sourceMappingURL=file-transfer.js.map
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(82).Buffer))

/***/ }),

/***/ 592:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 623:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseFormatSingleActivityComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_module_delegate__ = __webpack_require__(140);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__components_unsupported_module_unsupported_module__ = __webpack_require__(640);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Component to display single activity format. It will determine the right component to use and instantiate it.
 *
 * The instantiated component will receive the course and the module as inputs.
 */
var CoreCourseFormatSingleActivityComponent = /** @class */ (function () {
    function CoreCourseFormatSingleActivityComponent(moduleDelegate) {
        this.moduleDelegate = moduleDelegate;
        this.data = {}; // Data to pass to the component.
    }
    /**
     * Detect changes on input properties.
     */
    CoreCourseFormatSingleActivityComponent.prototype.ngOnChanges = function (changes) {
        if (this.course && this.sections && this.sections.length) {
            // In single activity the module should only have 1 section and 1 module. Get the module.
            var module_1 = this.sections[0] && this.sections[0].modules && this.sections[0].modules[0];
            if (module_1 && !this.componentClass) {
                // We haven't obtained the class yet. Get it now.
                this.componentClass = this.moduleDelegate.getMainComponent(this.course, module_1) ||
                    __WEBPACK_IMPORTED_MODULE_2__components_unsupported_module_unsupported_module__["a" /* CoreCourseUnsupportedModuleComponent */];
            }
            this.data.courseId = this.course.id;
            this.data.module = module_1;
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreCourseFormatSingleActivityComponent.prototype, "course", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Array)
    ], CoreCourseFormatSingleActivityComponent.prototype, "sections", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Boolean)
    ], CoreCourseFormatSingleActivityComponent.prototype, "downloadEnabled", void 0);
    CoreCourseFormatSingleActivityComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-course-format-single-activity',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/core/course/formats/singleactivity/components/singleactivity.html"*/'<core-dynamic-component [component]="componentClass" [data]="data"></core-dynamic-component>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/core/course/formats/singleactivity/components/singleactivity.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_module_delegate__["a" /* CoreCourseModuleDelegate */]])
    ], CoreCourseFormatSingleActivityComponent);
    return CoreCourseFormatSingleActivityComponent;
}());

//# sourceMappingURL=singleactivity.js.map

/***/ }),

/***/ 624:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseFormatSingleActivityHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_singleactivity__ = __webpack_require__(623);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Handler to support singleactivity course format.
 */
var CoreCourseFormatSingleActivityHandler = /** @class */ (function () {
    function CoreCourseFormatSingleActivityHandler() {
        this.name = 'singleactivity';
        // Nothing to do.
    }
    /**
     * Whether or not the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} True or promise resolved with true if enabled.
     */
    CoreCourseFormatSingleActivityHandler.prototype.isEnabled = function () {
        return true;
    };
    /**
     * Whether it allows seeing all sections at the same time. Defaults to true.
     *
     * @param {any} course The course to check.
     * @type {boolean} Whether it can view all sections.
     */
    CoreCourseFormatSingleActivityHandler.prototype.canViewAllSections = function (course) {
        return false;
    };
    /**
     * Get the title to use in course page. If not defined, course fullname.
     * This function will be called without sections first, and then call it again when the sections are retrieved.
     *
     * @param {any} course The course.
     * @param {any[]} [sections] List of sections.
     * @return {string} Title.
     */
    CoreCourseFormatSingleActivityHandler.prototype.getCourseTitle = function (course, sections) {
        if (sections && sections[0] && sections[0].modules && sections[0].modules[0]) {
            return sections[0].modules[0].name;
        }
        return course.fullname || '';
    };
    /**
     * Whether the default section selector should be displayed. Defaults to true.
     *
     * @param {any} course The course to check.
     * @type {boolean} Whether the default section selector should be displayed.
     */
    CoreCourseFormatSingleActivityHandler.prototype.displaySectionSelector = function (course) {
        return false;
    };
    /**
     * Return the Component to use to display the course format instead of using the default one.
     * Use it if you want to display a format completely different from the default one.
     * If you want to customize the default format there are several methods to customize parts of it.
     *
     * @param {any} course The course to render.
     * @return {any} The component to use, undefined if not found.
     */
    CoreCourseFormatSingleActivityHandler.prototype.getCourseFormatComponent = function (course) {
        return __WEBPACK_IMPORTED_MODULE_1__components_singleactivity__["a" /* CoreCourseFormatSingleActivityComponent */];
    };
    CoreCourseFormatSingleActivityHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [])
    ], CoreCourseFormatSingleActivityHandler);
    return CoreCourseFormatSingleActivityHandler;
}());

//# sourceMappingURL=handler.js.map

/***/ }),

/***/ 625:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonUserProfileFieldCheckboxComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_forms__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__ = __webpack_require__(9);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Directive to render a checkbox user profile field.
 */
var AddonUserProfileFieldCheckboxComponent = /** @class */ (function () {
    function AddonUserProfileFieldCheckboxComponent(fb, utils) {
        this.fb = fb;
        this.utils = utils;
    }
    /**
     * Component being initialized.
     */
    AddonUserProfileFieldCheckboxComponent.prototype.ngOnInit = function () {
        var field = this.field;
        if (field && this.edit && this.form) {
            field.modelName = 'profile_field_' + field.shortname;
            // Initialize the value.
            var formData = {
                value: this.utils.isTrueOrOne(field.defaultdata),
                disabled: this.disabled
            };
            this.form.addControl(field.modelName, this.fb.control(formData, field.required && !field.locked ? __WEBPACK_IMPORTED_MODULE_1__angular_forms__["h" /* Validators */].requiredTrue : null));
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], AddonUserProfileFieldCheckboxComponent.prototype, "field", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Boolean)
    ], AddonUserProfileFieldCheckboxComponent.prototype, "edit", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Boolean)
    ], AddonUserProfileFieldCheckboxComponent.prototype, "disabled", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_1__angular_forms__["c" /* FormGroup */])
    ], AddonUserProfileFieldCheckboxComponent.prototype, "form", void 0);
    AddonUserProfileFieldCheckboxComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'addon-user-profile-field-checkbox',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/addon/userprofilefield/checkbox/component/checkbox.html"*/'<!-- Render (no edit). -->\n<ion-item *ngIf="!edit && field && field.name">\n    <h2>{{ field.name }}</h2>\n    <p *ngIf="field.value != \'0\'">\n        {{ \'core.yes\' | translate }}\n    </p>\n    <p *ngIf="field.value == \'0\'">\n        {{ \'core.no\' | translate }}\n    </p>\n</ion-item>\n<!-- Edit. -->\n<ion-item *ngIf="edit && field && field.shortname" [formGroup]="form">\n    <ion-label [core-mark-required]="field.required">{{ field.name }}</ion-label>\n    <ion-checkbox item-end [formControlName]="field.modelName">\n    </ion-checkbox>\n    <core-input-errors [control]="form.controls[field.modelName]" [errorMessages]="errors"></core-input-errors>\n</ion-item>'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/addon/userprofilefield/checkbox/component/checkbox.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_forms__["a" /* FormBuilder */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], AddonUserProfileFieldCheckboxComponent);
    return AddonUserProfileFieldCheckboxComponent;
}());

//# sourceMappingURL=checkbox.js.map

/***/ }),

/***/ 626:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonUserProfileFieldDatetimeComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_forms__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_time__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__ = __webpack_require__(9);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Directive to render a datetime user profile field.
 */
var AddonUserProfileFieldDatetimeComponent = /** @class */ (function () {
    function AddonUserProfileFieldDatetimeComponent(fb, timeUtils, utils) {
        this.fb = fb;
        this.timeUtils = timeUtils;
        this.utils = utils;
        this.edit = false; // True if editing the field. Defaults to false.
        this.disabled = false; // True if disabled. Defaults to false.
    }
    /**
     * Component being initialized.
     */
    AddonUserProfileFieldDatetimeComponent.prototype.ngOnInit = function () {
        var field = this.field;
        var year;
        if (field && this.edit && this.form) {
            field.modelName = 'profile_field_' + field.shortname;
            // Check if it's only date or it has time too.
            var hasTime = this.utils.isTrueOrOne(field.param3);
            field.format = hasTime ? this.timeUtils.getLocalizedDateFormat('LLL') : this.timeUtils.getLocalizedDateFormat('LL');
            // Check min value.
            if (field.param1) {
                year = parseInt(field.param1, 10);
                if (year) {
                    field.min = year;
                }
            }
            // Check max value.
            if (field.param2) {
                year = parseInt(field.param2, 10);
                if (year) {
                    field.max = year;
                }
            }
            var formData = {
                value: field.defaultdata,
                disabled: this.disabled
            };
            this.form.addControl(field.modelName, this.fb.control(formData, field.required && !field.locked ? __WEBPACK_IMPORTED_MODULE_1__angular_forms__["h" /* Validators */].required : null));
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], AddonUserProfileFieldDatetimeComponent.prototype, "field", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], AddonUserProfileFieldDatetimeComponent.prototype, "edit", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], AddonUserProfileFieldDatetimeComponent.prototype, "disabled", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_1__angular_forms__["c" /* FormGroup */])
    ], AddonUserProfileFieldDatetimeComponent.prototype, "form", void 0);
    AddonUserProfileFieldDatetimeComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'addon-user-profile-field-datetime',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/addon/userprofilefield/datetime/component/datetime.html"*/'<!-- Render (no edit). -->\n<ion-item *ngIf="!edit && field && field.name">\n    <h2>{{ field.name }}</h2>\n    <p>{{ field.value * 1000 | coreFormatDate:"dfmediumdate"}}</p>\n</ion-item>\n<!-- Edit. -->\n<ion-item *ngIf="edit && field && field.shortname" text-wrap [formGroup]="form">\n    <ion-label stacked [core-mark-required]="field.required">{{ field.name }}</ion-label>\n    <ion-datetime [formControlName]="field.modelName" [placeholder]="\'core.choosedots\' |translate" [displayFormat]="field.format" core-input-errors [max]="field.max" [min]="field.min"></ion-datetime>\n</ion-item>'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/addon/userprofilefield/datetime/component/datetime.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_forms__["a" /* FormBuilder */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_time__["a" /* CoreTimeUtilsProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], AddonUserProfileFieldDatetimeComponent);
    return AddonUserProfileFieldDatetimeComponent;
}());

//# sourceMappingURL=datetime.js.map

/***/ }),

/***/ 627:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonUserProfileFieldMenuComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_forms__ = __webpack_require__(28);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Directive to render a menu user profile field.
 */
var AddonUserProfileFieldMenuComponent = /** @class */ (function () {
    function AddonUserProfileFieldMenuComponent(fb) {
        this.fb = fb;
        this.edit = false; // True if editing the field. Defaults to false.
        this.disabled = false; // True if disabled. Defaults to false.
    }
    /**
     * Component being initialized.
     */
    AddonUserProfileFieldMenuComponent.prototype.ngOnInit = function () {
        var field = this.field;
        if (field && this.edit && this.form) {
            field.modelName = 'profile_field_' + field.shortname;
            // Parse options.
            if (field.param1) {
                field.options = field.param1.split(/\r\n|\r|\n/g);
            }
            else {
                field.options = [];
            }
            var formData = {
                value: field.defaultdata,
                disabled: this.disabled
            };
            // Initialize the value using default data.
            this.form.addControl(field.modelName, this.fb.control(formData, field.required && !field.locked ? __WEBPACK_IMPORTED_MODULE_1__angular_forms__["h" /* Validators */].required : null));
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], AddonUserProfileFieldMenuComponent.prototype, "field", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], AddonUserProfileFieldMenuComponent.prototype, "edit", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], AddonUserProfileFieldMenuComponent.prototype, "disabled", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_1__angular_forms__["c" /* FormGroup */])
    ], AddonUserProfileFieldMenuComponent.prototype, "form", void 0);
    AddonUserProfileFieldMenuComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'addon-user-profile-field-menu',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/addon/userprofilefield/menu/component/menu.html"*/'<!-- Render (no edit). -->\n<ion-item *ngIf="!edit && field && field.name">\n    <h2>{{ field.name }}</h2>\n    <p><core-format-text [text]="field.value"></core-format-text></p>\n</ion-item>\n<!-- Edit. -->\n<ion-item *ngIf="edit && field && field.shortname" text-wrap [formGroup]="form">\n    <ion-label stacked [core-mark-required]="field.required">{{ field.name }}</ion-label>\n    <ion-select [formControlName]="field.modelName" [placeholder]="\'core.choosedots\' |translate" core-input-errors>\n        <ion-option value="">{{ \'core.choosedots\' |translate }}</ion-option>\n        <ion-option *ngFor="let option of field.options" [value]="option">{{option}}</ion-option>\n    </ion-select>\n</ion-item>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/addon/userprofilefield/menu/component/menu.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_forms__["a" /* FormBuilder */]])
    ], AddonUserProfileFieldMenuComponent);
    return AddonUserProfileFieldMenuComponent;
}());

//# sourceMappingURL=menu.js.map

/***/ }),

/***/ 628:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonUserProfileFieldTextComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_forms__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__ = __webpack_require__(9);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Directive to render a text user profile field.
 */
var AddonUserProfileFieldTextComponent = /** @class */ (function () {
    function AddonUserProfileFieldTextComponent(fb, utils) {
        this.fb = fb;
        this.utils = utils;
        this.edit = false; // True if editing the field. Defaults to false.
        this.disabled = false; // True if disabled. Defaults to false.
    }
    /**
     * Component being initialized.
     */
    AddonUserProfileFieldTextComponent.prototype.ngOnInit = function () {
        var field = this.field;
        if (field && this.edit && this.form) {
            field.modelName = 'profile_field_' + field.shortname;
            // Check max length.
            if (field.param2) {
                field.maxlength = parseInt(field.param2, 10) || '';
            }
            // Check if it's a password or text.
            field.inputType = this.utils.isTrueOrOne(field.param3) ? 'password' : 'text';
            var formData = {
                value: field.defaultdata,
                disabled: this.disabled
            };
            // Initialize the value using default data.
            this.form.addControl(field.modelName, this.fb.control(formData, field.required && !field.locked ? __WEBPACK_IMPORTED_MODULE_1__angular_forms__["h" /* Validators */].required : null));
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], AddonUserProfileFieldTextComponent.prototype, "field", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], AddonUserProfileFieldTextComponent.prototype, "edit", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], AddonUserProfileFieldTextComponent.prototype, "disabled", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_1__angular_forms__["c" /* FormGroup */])
    ], AddonUserProfileFieldTextComponent.prototype, "form", void 0);
    AddonUserProfileFieldTextComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'addon-user-profile-field-text',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/addon/userprofilefield/text/component/text.html"*/'<!-- Render (no edit). -->\n<ion-item *ngIf="!edit && field && field.name">\n    <h2>{{ field.name }}</h2>\n    <p><core-format-text [text]="field.value"></core-format-text></p>\n</ion-item>\n<!-- Edit. -->\n<ion-item *ngIf="edit && field && field.shortname" text-wrap [formGroup]="form">\n    <ion-label stacked [core-mark-required]="field.required">{{ field.name }}</ion-label>\n    <ion-input [type]="field.inputType" [formControlName]="field.modelName" [placeholder]="field.name" maxlength="{{field.maxlength}}" core-input-errors></ion-input>\n</ion-item>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/addon/userprofilefield/text/component/text.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_forms__["a" /* FormBuilder */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], AddonUserProfileFieldTextComponent);
    return AddonUserProfileFieldTextComponent;
}());

//# sourceMappingURL=text.js.map

/***/ }),

/***/ 629:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonUserProfileFieldTextareaComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_forms__ = __webpack_require__(28);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Directive to render a textarea user profile field.
 */
var AddonUserProfileFieldTextareaComponent = /** @class */ (function () {
    function AddonUserProfileFieldTextareaComponent() {
        this.edit = false; // True if editing the field. Defaults to false.
        this.disabled = false; // True if disabled. Defaults to false.
        // Nothing to do.
    }
    /**
     * Component being initialized.
     */
    AddonUserProfileFieldTextareaComponent.prototype.ngOnInit = function () {
        var field = this.field;
        if (field && this.edit && this.form) {
            field.modelName = 'profile_field_' + field.shortname;
            var formData = {
                value: field.defaultdata,
                disabled: this.disabled
            };
            this.control = new __WEBPACK_IMPORTED_MODULE_1__angular_forms__["b" /* FormControl */](formData, field.required && !field.locked ? __WEBPACK_IMPORTED_MODULE_1__angular_forms__["h" /* Validators */].required : null);
            this.form.addControl(field.modelName, this.control);
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], AddonUserProfileFieldTextareaComponent.prototype, "field", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], AddonUserProfileFieldTextareaComponent.prototype, "edit", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], AddonUserProfileFieldTextareaComponent.prototype, "disabled", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_1__angular_forms__["c" /* FormGroup */])
    ], AddonUserProfileFieldTextareaComponent.prototype, "form", void 0);
    AddonUserProfileFieldTextareaComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'addon-user-profile-field-textarea',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/addon/userprofilefield/textarea/component/textarea.html"*/'<!-- Render (no edit). -->\n<ion-item *ngIf="!edit && field && field.name">\n    <h2>{{ field.name }}</h2>\n    <p><core-format-text [text]="field.value"></core-format-text></p>\n</ion-item>\n<!-- Edit. -->\n<ion-item *ngIf="edit && field && field.shortname" text-wrap [formGroup]="form">\n    <ion-label stacked [core-mark-required]="field.required">{{ field.name }}</ion-label>\n    <core-rich-text-editor item-content [control]="control" [placeholder]="field.name"></core-rich-text-editor>\n</ion-item>'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/addon/userprofilefield/textarea/component/textarea.html"*/
        }),
        __metadata("design:paramtypes", [])
    ], AddonUserProfileFieldTextareaComponent);
    return AddonUserProfileFieldTextareaComponent;
}());

//# sourceMappingURL=textarea.js.map

/***/ }),

/***/ 639:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_filepool__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_sites__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_dom__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_text__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_time__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__options_delegate__ = __webpack_require__(154);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__sitehome_providers_sitehome__ = __webpack_require__(115);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__course__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__module_delegate__ = __webpack_require__(140);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__module_prefetch_delegate__ = __webpack_require__(250);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__login_providers_helper__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__constants__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_moment__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_15_moment__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
















/**
 * Helper to gather some common course functions.
 */
var CoreCourseHelperProvider = /** @class */ (function () {
    function CoreCourseHelperProvider(courseProvider, domUtils, moduleDelegate, prefetchDelegate, filepoolProvider, sitesProvider, textUtils, timeUtils, utils, translate, loginHelper, courseOptionsDelegate, siteHomeProvider) {
        this.courseProvider = courseProvider;
        this.domUtils = domUtils;
        this.moduleDelegate = moduleDelegate;
        this.prefetchDelegate = prefetchDelegate;
        this.filepoolProvider = filepoolProvider;
        this.sitesProvider = sitesProvider;
        this.textUtils = textUtils;
        this.timeUtils = timeUtils;
        this.utils = utils;
        this.translate = translate;
        this.loginHelper = loginHelper;
        this.courseOptionsDelegate = courseOptionsDelegate;
        this.siteHomeProvider = siteHomeProvider;
        this.courseDwnPromises = {};
    }
    /**
     * This function treats every module on the sections provided to load the handler data, treat completion
     * and navigate to a module page if required. It also returns if sections has content.
     *
     * @param {any[]} sections List of sections to treat modules.
     * @param {number} courseId Course ID of the modules.
     * @param {any[]} [completionStatus] List of completion status.
     * @return {boolean} Whether the sections have content.
     */
    CoreCourseHelperProvider.prototype.addHandlerDataForModules = function (sections, courseId, completionStatus) {
        var _this = this;
        var hasContent = false;
        sections.forEach(function (section) {
            if (!section || !_this.sectionHasContent(section) || !section.modules) {
                return;
            }
            hasContent = true;
            section.modules.forEach(function (module) {
                module.handlerData = _this.moduleDelegate.getModuleDataFor(module.modname, module, courseId, section.id);
                if (completionStatus && typeof completionStatus[module.id] != 'undefined') {
                    // Check if activity has completions and if it's marked.
                    module.completionstatus = completionStatus[module.id];
                    module.completionstatus.courseId = courseId;
                }
            });
        });
        return hasContent;
    };
    /**
     * Calculate the status of a section.
     *
     * @param {any} section Section to calculate its status. It can't be "All sections".
     * @param {number} courseId Course ID the section belongs to.
     * @param {boolean} [refresh] True if it shouldn't use module status cache (slower).
     * @return {Promise<any>} Promise resolved when the status is calculated.
     */
    CoreCourseHelperProvider.prototype.calculateSectionStatus = function (section, courseId, refresh) {
        var _this = this;
        if (section.id == __WEBPACK_IMPORTED_MODULE_10__course__["a" /* CoreCourseProvider */].ALL_SECTIONS_ID) {
            return Promise.reject(null);
        }
        // Get the status of this section.
        return this.prefetchDelegate.getModulesStatus(section.modules, courseId, section.id, refresh).then(function (result) {
            // Check if it's being downloaded.
            var downloadId = _this.getSectionDownloadId(section);
            if (_this.prefetchDelegate.isBeingDownloaded(downloadId)) {
                result.status = __WEBPACK_IMPORTED_MODULE_14__constants__["a" /* CoreConstants */].DOWNLOADING;
            }
            // Set this section data.
            section.showDownload = result.status === __WEBPACK_IMPORTED_MODULE_14__constants__["a" /* CoreConstants */].NOT_DOWNLOADED;
            section.showRefresh = result.status === __WEBPACK_IMPORTED_MODULE_14__constants__["a" /* CoreConstants */].OUTDATED;
            if (result.status !== __WEBPACK_IMPORTED_MODULE_14__constants__["a" /* CoreConstants */].DOWNLOADING || !_this.prefetchDelegate.isBeingDownloaded(section.id)) {
                section.isDownloading = false;
                section.total = 0;
            }
            else {
                // Section is being downloaded.
                section.isDownloading = true;
                _this.prefetchDelegate.setOnProgress(downloadId, function (data) {
                    section.count = data.count;
                    section.total = data.total;
                });
            }
            return result;
        });
    };
    /**
     * Calculate the status of a list of sections, setting attributes to determine the icons/data to be shown.
     *
     * @param {any[]} sections Sections to calculate their status.
     * @param {number} courseId Course ID the sections belong to.
     * @param {boolean} [refresh] True if it shouldn't use module status cache (slower).
     * @return {Promise<void>} Promise resolved when the states are calculated.
     */
    CoreCourseHelperProvider.prototype.calculateSectionsStatus = function (sections, courseId, refresh) {
        var _this = this;
        var promises = [];
        var allSectionsSection, allSectionsStatus;
        sections.forEach(function (section) {
            if (section.id === __WEBPACK_IMPORTED_MODULE_10__course__["a" /* CoreCourseProvider */].ALL_SECTIONS_ID) {
                // "All sections" section status is calculated using the status of the rest of sections.
                allSectionsSection = section;
                section.isCalculating = true;
            }
            else {
                section.isCalculating = true;
                promises.push(_this.calculateSectionStatus(section, courseId, refresh).then(function (result) {
                    // Calculate "All sections" status.
                    allSectionsStatus = _this.filepoolProvider.determinePackagesStatus(allSectionsStatus, result.status);
                }).finally(function () {
                    section.isCalculating = false;
                }));
            }
        });
        return Promise.all(promises).then(function () {
            if (allSectionsSection) {
                // Set "All sections" data.
                allSectionsSection.showDownload = allSectionsStatus === __WEBPACK_IMPORTED_MODULE_14__constants__["a" /* CoreConstants */].NOT_DOWNLOADED;
                allSectionsSection.showRefresh = allSectionsStatus === __WEBPACK_IMPORTED_MODULE_14__constants__["a" /* CoreConstants */].OUTDATED;
                allSectionsSection.isDownloading = allSectionsStatus === __WEBPACK_IMPORTED_MODULE_14__constants__["a" /* CoreConstants */].DOWNLOADING;
            }
        }).finally(function () {
            if (allSectionsSection) {
                allSectionsSection.isCalculating = false;
            }
        });
    };
    /**
     * Show a confirm and prefetch a course. It will retrieve the sections and the course options if not provided.
     * This function will set the icon to "spinner" when starting and it will also set it back to the initial icon if the
     * user cancels. All the other updates of the icon should be made when CoreEventsProvider.COURSE_STATUS_CHANGED is received.
     *
     * @param {any} iconData An object where to store the course icon. It will be stored with the name "prefetchCourseIcon".
     * @param {any} course Course to prefetch.
     * @param {any[]} [sections] List of course sections.
     * @param {CoreCourseOptionsHandlerToDisplay[]} courseHandlers List of course handlers.
     * @return {Promise<boolean>} Promise resolved with true when the download finishes, resolved with false if user doesn't
     *                            confirm, rejected if an error occurs.
     */
    CoreCourseHelperProvider.prototype.confirmAndPrefetchCourse = function (iconData, course, sections, courseHandlers) {
        var _this = this;
        var initialIcon = iconData.prefetchCourseIcon, siteId = this.sitesProvider.getCurrentSiteId();
        var promise;
        iconData.prefetchCourseIcon = 'spinner';
        // Get the sections first if needed.
        if (sections) {
            promise = Promise.resolve(sections);
        }
        else {
            promise = this.courseProvider.getSections(course.id, false, true);
        }
        return promise.then(function (sections) {
            // Confirm the download.
            return _this.confirmDownloadSizeSection(course.id, undefined, sections, true).then(function () {
                // User confirmed, get the course handlers if needed.
                if (courseHandlers) {
                    promise = Promise.resolve(courseHandlers);
                }
                else {
                    promise = _this.courseOptionsDelegate.getHandlersToDisplay(course);
                }
                return promise.then(function (handlers) {
                    // Now we have all the data, download the course.
                    return _this.prefetchCourse(course, sections, handlers, siteId);
                }).then(function () {
                    // Download successful.
                    return true;
                });
            }, function (error) {
                // User cancelled or there was an error calculating the size.
                iconData.prefetchCourseIcon = initialIcon;
                if (error) {
                    return Promise.reject(error);
                }
                return false;
            });
        });
    };
    /**
     * Confirm and prefetches a list of courses.
     *
     * @param {any[]} courses List of courses to download.
     * @param {Function} [onProgress] Function to call everytime a course is downloaded.
     * @return {Promise<boolean>} Resolved with true when downloaded, resolved with false if user cancels, rejected if error.
     */
    CoreCourseHelperProvider.prototype.confirmAndPrefetchCourses = function (courses, onProgress) {
        var _this = this;
        var siteId = this.sitesProvider.getCurrentSiteId();
        // Confirm the download without checking size because it could take a while.
        return this.domUtils.showConfirm(this.translate.instant('core.areyousure')).then(function () {
            var promises = [], total = courses.length;
            var count = 0;
            courses.forEach(function (course) {
                var subPromises = [];
                var sections, handlers, success = true;
                // Get the sections and the handlers.
                subPromises.push(_this.courseProvider.getSections(course.id, false, true).then(function (courseSections) {
                    sections = courseSections;
                }));
                subPromises.push(_this.courseOptionsDelegate.getHandlersToDisplay(course).then(function (cHandlers) {
                    handlers = cHandlers;
                }));
                promises.push(Promise.all(subPromises).then(function () {
                    return _this.prefetchCourse(course, sections, handlers, siteId);
                }).catch(function (error) {
                    success = false;
                    return Promise.reject(error);
                }).finally(function () {
                    // Course downloaded or failed, notify the progress.
                    count++;
                    if (onProgress) {
                        onProgress({ count: count, total: total, courseId: course.id, success: success });
                    }
                }));
            });
            if (onProgress) {
                // Notify the start of the download.
                onProgress({ count: 0, total: total, success: true });
            }
            return _this.utils.allPromises(promises).then(function () {
                return true;
            });
        }, function () {
            // User cancelled.
            return false;
        });
    };
    /**
     * Show confirmation dialog and then remove a module files.
     *
     * @param {any} module Module to remove the files.
     * @param {number} courseId Course ID the module belongs to.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseHelperProvider.prototype.confirmAndRemoveFiles = function (module, courseId) {
        var _this = this;
        return this.domUtils.showConfirm(this.translate.instant('course.confirmdeletemodulefiles')).then(function () {
            return _this.prefetchDelegate.removeModuleFiles(module, courseId);
        });
    };
    /**
     * Calculate the size to download a section and show a confirm modal if needed.
     *
     * @param {number} courseId Course ID the section belongs to.
     * @param {any} [section] Section. If not provided, all sections.
     * @param {any[]} [sections] List of sections. Used when downloading all the sections.
     * @param {boolean} [alwaysConfirm] True to show a confirm even if the size isn't high, false otherwise.
     * @return {Promise<any>} Promise resolved if the user confirms or there's no need to confirm.
     */
    CoreCourseHelperProvider.prototype.confirmDownloadSizeSection = function (courseId, section, sections, alwaysConfirm) {
        var _this = this;
        var sizePromise;
        // Calculate the size of the download.
        if (section && section.id != __WEBPACK_IMPORTED_MODULE_10__course__["a" /* CoreCourseProvider */].ALL_SECTIONS_ID) {
            sizePromise = this.prefetchDelegate.getDownloadSize(section.modules, courseId);
        }
        else {
            var promises_1 = [], results_1 = {
                size: 0,
                total: true
            };
            sections.forEach(function (s) {
                if (s.id != __WEBPACK_IMPORTED_MODULE_10__course__["a" /* CoreCourseProvider */].ALL_SECTIONS_ID) {
                    promises_1.push(_this.prefetchDelegate.getDownloadSize(s.modules, courseId).then(function (sectionSize) {
                        results_1.total = results_1.total && sectionSize.total;
                        results_1.size += sectionSize.size;
                    }));
                }
            });
            sizePromise = Promise.all(promises_1).then(function () {
                return results_1;
            });
        }
        return sizePromise.then(function (size) {
            // Show confirm modal if needed.
            return _this.domUtils.confirmDownloadSize(size, undefined, undefined, undefined, undefined, alwaysConfirm);
        });
    };
    /**
     * Determine the status of a list of courses.
     *
     * @param {any[]} courses Courses
     * @return {Promise<string>} Promise resolved with the status.
     */
    CoreCourseHelperProvider.prototype.determineCoursesStatus = function (courses) {
        var _this = this;
        // Get the status of each course.
        var promises = [], siteId = this.sitesProvider.getCurrentSiteId();
        courses.forEach(function (course) {
            promises.push(_this.courseProvider.getCourseStatus(course.id, siteId));
        });
        return Promise.all(promises).then(function (statuses) {
            // Now determine the status of the whole list.
            var status = statuses[0];
            for (var i = 1; i < statuses.length; i++) {
                status = _this.filepoolProvider.determinePackagesStatus(status, statuses[i]);
            }
            return status;
        });
    };
    /**
     * Get a course download promise (if any).
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Download promise, undefined if not found.
     */
    CoreCourseHelperProvider.prototype.getCourseDownloadPromise = function (courseId, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.courseDwnPromises[siteId] && this.courseDwnPromises[siteId][courseId];
    };
    /**
     * Get a course status icon.
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<string>} Promise resolved with the icon name.
     */
    CoreCourseHelperProvider.prototype.getCourseStatusIcon = function (courseId, siteId) {
        var _this = this;
        return this.courseProvider.getCourseStatus(courseId, siteId).then(function (status) {
            return _this.getCourseStatusIconFromStatus(status);
        });
    };
    /**
     * Get a course status icon from status.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourseHelper#getCourseStatusIconFromStatus
     * @param {String} status Course status.
     * @return {String}       Icon name.
     */
    CoreCourseHelperProvider.prototype.getCourseStatusIconFromStatus = function (status) {
        if (status == __WEBPACK_IMPORTED_MODULE_14__constants__["a" /* CoreConstants */].DOWNLOADED) {
            // Always show refresh icon, we cannot knew if there's anything new in course options.
            return 'refresh';
        }
        else if (status == __WEBPACK_IMPORTED_MODULE_14__constants__["a" /* CoreConstants */].DOWNLOADING) {
            return 'spinner';
        }
        else {
            return 'cloud-download';
        }
    };
    /**
     * Get the course ID from a module instance ID, showing an error message if it can't be retrieved.
     *
     * @param {number} id Instance ID.
     * @param {string} module Name of the module. E.g. 'glossary'.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<number>} Promise resolved with the module's course ID.
     */
    CoreCourseHelperProvider.prototype.getModuleCourseIdByInstance = function (id, module, siteId) {
        var _this = this;
        return this.courseProvider.getModuleBasicInfoByInstance(id, module, siteId).then(function (cm) {
            return cm.course;
        }).catch(function (error) {
            _this.domUtils.showErrorModalDefault(error, 'core.course.errorgetmodule', true);
            return Promise.reject(null);
        });
    };
    /**
     * Get prefetch info for a module.
     *
     * @param {any} module Module to get the info from.
     * @param {number} courseId Course ID the section belongs to.
     * @param {boolean} [invalidateCache] Invalidates the cache first.
     * @param {string} [component] Component of the module.
     * @return {Promise<CoreCourseModulePrefetchInfo>} Promise resolved with the info.
     */
    CoreCourseHelperProvider.prototype.getModulePrefetchInfo = function (module, courseId, invalidateCache, component) {
        var _this = this;
        var moduleInfo = {}, siteId = this.sitesProvider.getCurrentSiteId(), promises = [];
        if (invalidateCache) {
            this.prefetchDelegate.invalidateModuleStatusCache(module);
        }
        promises.push(this.prefetchDelegate.getModuleDownloadedSize(module, courseId).then(function (moduleSize) {
            moduleInfo.size = moduleSize;
            moduleInfo.sizeReadable = _this.textUtils.bytesToSize(moduleSize, 2);
        }));
        // @todo: Decide what to display instead of timemodified. Last check_updates?
        promises.push(this.prefetchDelegate.getModuleStatus(module, courseId).then(function (moduleStatus) {
            moduleInfo.status = moduleStatus;
            switch (moduleStatus) {
                case __WEBPACK_IMPORTED_MODULE_14__constants__["a" /* CoreConstants */].NOT_DOWNLOADED:
                    moduleInfo.statusIcon = 'cloud-download';
                    break;
                case __WEBPACK_IMPORTED_MODULE_14__constants__["a" /* CoreConstants */].DOWNLOADING:
                    moduleInfo.statusIcon = 'spinner';
                    break;
                case __WEBPACK_IMPORTED_MODULE_14__constants__["a" /* CoreConstants */].OUTDATED:
                    moduleInfo.statusIcon = 'ion-android-refresh';
                    break;
                default:
                    moduleInfo.statusIcon = '';
                    break;
            }
        }));
        // Get the time it was downloaded (if it was downloaded).
        promises.push(this.filepoolProvider.getPackageData(siteId, component, module.id).then(function (data) {
            if (data && data.downloadTime && (data.status == __WEBPACK_IMPORTED_MODULE_14__constants__["a" /* CoreConstants */].OUTDATED || data.status == __WEBPACK_IMPORTED_MODULE_14__constants__["a" /* CoreConstants */].DOWNLOADED)) {
                var now = _this.timeUtils.timestamp();
                moduleInfo.downloadTime = data.downloadTime;
                if (now - data.downloadTime < 7 * 86400) {
                    moduleInfo.downloadTimeReadable = __WEBPACK_IMPORTED_MODULE_15_moment__(data.downloadTime * 1000).fromNow();
                }
                else {
                    moduleInfo.downloadTimeReadable = __WEBPACK_IMPORTED_MODULE_15_moment__(data.downloadTime * 1000).calendar();
                }
            }
        }).catch(function () {
            // Not downloaded.
            moduleInfo.downloadTime = 0;
        }));
        return Promise.all(promises).then(function () {
            return moduleInfo;
        });
    };
    /**
     * Get the download ID of a section. It's used to interact with CoreCourseModulePrefetchDelegate.
     *
     * @param {any} section Section.
     * @return {string} Section download ID.
     */
    CoreCourseHelperProvider.prototype.getSectionDownloadId = function (section) {
        return 'Section-' + section.id;
    };
    /**
     * Navigate to a module.
     *
     * @param {number} moduleId Module's ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [courseId] Course ID. If not defined we'll try to retrieve it from the site.
     * @param {number} [sectionId] Section the module belongs to. If not defined we'll try to retrieve it from the site.
     * @return {Promise<void>} Promise resolved when done.
     */
    CoreCourseHelperProvider.prototype.navigateToModule = function (moduleId, siteId, courseId, sectionId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var modal = this.domUtils.showModalLoading();
        var promise, site;
        if (courseId && sectionId) {
            // No need to retrieve more data.
            promise = Promise.resolve();
        }
        else if (!courseId) {
            // We don't have courseId.
            promise = this.courseProvider.getModuleBasicInfo(moduleId, siteId).then(function (module) {
                courseId = module.course;
                sectionId = module.section;
            });
        }
        else {
            // We don't have sectionId but we have courseId.
            promise = this.courseProvider.getModuleSectionId(moduleId, siteId).then(function (id) {
                sectionId = id;
            });
        }
        return promise.then(function () {
            // Get the site.
            return _this.sitesProvider.getSite(siteId);
        }).then(function (s) {
            site = s;
            // Get the module.
            return _this.courseProvider.getModule(moduleId, courseId, sectionId, false, false, siteId);
        }).then(function (module) {
            var params = {
                course: { id: courseId },
                module: module,
                sectionId: sectionId
            };
            module.handlerData = _this.moduleDelegate.getModuleDataFor(module.modname, module, courseId, sectionId);
            if (courseId == site.getSiteHomeId()) {
                // Check if site home is available.
                return _this.siteHomeProvider.isAvailable().then(function () {
                    _this.loginHelper.redirect('CoreSiteHomeIndexPage', params, siteId);
                });
            }
            else {
                _this.loginHelper.redirect('CoreCourseSectionPage', params, siteId);
            }
        }).catch(function (error) {
            _this.domUtils.showErrorModalDefault(error, 'core.course.errorgetmodule', true);
        }).finally(function () {
            modal.dismiss();
        });
    };
    /**
     * Open a module.
     *
     * @param {NavController} navCtrl The NavController to use.
     * @param {any} module The module to open.
     * @param {number} courseId The course ID of the module.
     * @param {number} [sectionId] The section ID of the module.
     */
    CoreCourseHelperProvider.prototype.openModule = function (navCtrl, module, courseId, sectionId) {
        if (!module.handlerData) {
            module.handlerData = this.moduleDelegate.getModuleDataFor(module.modname, module, courseId, sectionId);
        }
        module.handlerData.action(new Event('click'), navCtrl, module, courseId, { animate: false });
    };
    /**
     * Prefetch all the activities in a course and also the course addons.
     *
     * @param {any} course The course to prefetch.
     * @param {any[]} sections List of course sections.
     * @param {CoreCourseOptionsHandlerToDisplay[]} courseHandlers List of course options handlers.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise}                Promise resolved when the download finishes.
     */
    CoreCourseHelperProvider.prototype.prefetchCourse = function (course, sections, courseHandlers, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (this.courseDwnPromises[siteId] && this.courseDwnPromises[siteId][course.id]) {
            // There's already a download ongoing for this course, return the promise.
            return this.courseDwnPromises[siteId][course.id];
        }
        else if (!this.courseDwnPromises[siteId]) {
            this.courseDwnPromises[siteId] = {};
        }
        // First of all, mark the course as being downloaded.
        this.courseDwnPromises[siteId][course.id] = this.courseProvider.setCourseStatus(course.id, __WEBPACK_IMPORTED_MODULE_14__constants__["a" /* CoreConstants */].DOWNLOADING, siteId).then(function () {
            var promises = [];
            var allSectionsSection = sections[0];
            // Prefetch all the sections. If the first section is "All sections", use it. Otherwise, use a fake "All sections".
            if (sections[0].id != __WEBPACK_IMPORTED_MODULE_10__course__["a" /* CoreCourseProvider */].ALL_SECTIONS_ID) {
                allSectionsSection = { id: __WEBPACK_IMPORTED_MODULE_10__course__["a" /* CoreCourseProvider */].ALL_SECTIONS_ID };
            }
            promises.push(_this.prefetchSection(allSectionsSection, course.id, sections));
            // Prefetch course options.
            courseHandlers.forEach(function (handler) {
                if (handler.prefetch) {
                    promises.push(handler.prefetch(course));
                }
            });
            return _this.utils.allPromises(promises);
        }).then(function () {
            // Download success, mark the course as downloaded.
            return _this.courseProvider.setCourseStatus(course.id, __WEBPACK_IMPORTED_MODULE_14__constants__["a" /* CoreConstants */].DOWNLOADED, siteId);
        }).catch(function (error) {
            // Error, restore previous status.
            return _this.courseProvider.setCoursePreviousStatus(course.id, siteId).then(function () {
                return Promise.reject(error);
            });
        }).finally(function () {
            delete _this.courseDwnPromises[siteId][course.id];
        });
        return this.courseDwnPromises[siteId][course.id];
    };
    /**
     * Helper function to prefetch a module, showing a confirmation modal if the size is big
     * and invalidating contents if refreshing.
     *
     * @param {handler} handler Prefetch handler to use. Must implement 'prefetch' and 'invalidateContent'.
     * @param {any} module Module to download.
     * @param {any} size Object containing size to download (in bytes) and a boolean to indicate if its totally calculated.
     * @param {number} courseId Course ID of the module.
     * @param {boolean} [refresh] True if refreshing, false otherwise.
     * @return {Promise<any>} Promise resolved when downloaded.
     */
    CoreCourseHelperProvider.prototype.prefetchModule = function (handler, module, size, courseId, refresh) {
        // Show confirmation if needed.
        return this.domUtils.confirmDownloadSize(size).then(function () {
            // Invalidate content if refreshing and download the data.
            var promise = refresh ? handler.invalidateContent(module.id, courseId) : Promise.resolve();
            return promise.catch(function () {
                // Ignore errors.
            }).then(function () {
                return handler.prefetch(module, courseId, true);
            });
        });
    };
    /**
     * Prefetch one section or all the sections.
     * If the section is "All sections" it will prefetch all the sections.
     *
     * @param {any} section Section.
     * @param {number} courseId Course ID the section belongs to.
     * @param {any[]} [sections] List of sections. Used when downloading all the sections.
     * @return {Promise<any>} Promise resolved when the prefetch is finished.
     */
    CoreCourseHelperProvider.prototype.prefetchSection = function (section, courseId, sections) {
        var _this = this;
        if (section.id != __WEBPACK_IMPORTED_MODULE_10__course__["a" /* CoreCourseProvider */].ALL_SECTIONS_ID) {
            // Download only this section.
            return this.prefetchSingleSectionIfNeeded(section, courseId).then(function () {
                // Calculate the status of the section that finished.
                return _this.calculateSectionStatus(section, courseId);
            });
        }
        else {
            // Download all the sections except "All sections".
            var promises_2 = [];
            var allSectionsStatus_1;
            section.isDownloading = true;
            sections.forEach(function (section) {
                if (section.id != __WEBPACK_IMPORTED_MODULE_10__course__["a" /* CoreCourseProvider */].ALL_SECTIONS_ID) {
                    promises_2.push(_this.prefetchSingleSectionIfNeeded(section, courseId).then(function () {
                        // Calculate the status of the section that finished.
                        return _this.calculateSectionStatus(section, courseId).then(function (result) {
                            // Calculate "All sections" status.
                            allSectionsStatus_1 = _this.filepoolProvider.determinePackagesStatus(allSectionsStatus_1, result.status);
                        });
                    }));
                }
            });
            return this.utils.allPromises(promises_2).then(function () {
                // Set "All sections" data.
                section.showDownload = allSectionsStatus_1 === __WEBPACK_IMPORTED_MODULE_14__constants__["a" /* CoreConstants */].NOT_DOWNLOADED;
                section.showRefresh = allSectionsStatus_1 === __WEBPACK_IMPORTED_MODULE_14__constants__["a" /* CoreConstants */].OUTDATED;
                section.isDownloading = allSectionsStatus_1 === __WEBPACK_IMPORTED_MODULE_14__constants__["a" /* CoreConstants */].DOWNLOADING;
            }).finally(function () {
                section.isDownloading = false;
            });
        }
    };
    /**
     * Prefetch a certain section if it needs to be prefetched.
     * If the section is "All sections" it will be ignored.
     *
     * @param {any} section Section to prefetch.
     * @param {number} courseId Course ID the section belongs to.
     * @return {Promise<any>} Promise resolved when the section is prefetched.
     */
    CoreCourseHelperProvider.prototype.prefetchSingleSectionIfNeeded = function (section, courseId) {
        var _this = this;
        if (section.id == __WEBPACK_IMPORTED_MODULE_10__course__["a" /* CoreCourseProvider */].ALL_SECTIONS_ID) {
            return Promise.resolve();
        }
        section.isDownloading = true;
        // Validate the section needs to be downloaded and calculate amount of modules that need to be downloaded.
        return this.prefetchDelegate.getModulesStatus(section.modules, courseId, section.id).then(function (result) {
            if (result.status == __WEBPACK_IMPORTED_MODULE_14__constants__["a" /* CoreConstants */].DOWNLOADED || result.status == __WEBPACK_IMPORTED_MODULE_14__constants__["a" /* CoreConstants */].NOT_DOWNLOADABLE) {
                // Section is downloaded or not downloadable, nothing to do.
                return;
            }
            return _this.prefetchSingleSection(section, result, courseId);
        }, function (error) {
            section.isDownloading = false;
            return Promise.reject(error);
        });
    };
    /**
     * Start or restore the prefetch of a section.
     * If the section is "All sections" it will be ignored.
     *
     * @param {any} section Section to download.
     * @param {any} result Result of CoreCourseModulePrefetchDelegate.getModulesStatus for this section.
     * @param {number} courseId Course ID the section belongs to.
     * @return {Promise<any>} Promise resolved when the section has been prefetched.
     */
    CoreCourseHelperProvider.prototype.prefetchSingleSection = function (section, result, courseId) {
        if (section.id == __WEBPACK_IMPORTED_MODULE_10__course__["a" /* CoreCourseProvider */].ALL_SECTIONS_ID) {
            return Promise.resolve();
        }
        if (section.total > 0) {
            // Already being downloaded.
            return Promise.resolve();
        }
        // We only download modules with status notdownloaded, downloading or outdated.
        var modules = result[__WEBPACK_IMPORTED_MODULE_14__constants__["a" /* CoreConstants */].OUTDATED].concat(result[__WEBPACK_IMPORTED_MODULE_14__constants__["a" /* CoreConstants */].NOT_DOWNLOADED])
            .concat(result[__WEBPACK_IMPORTED_MODULE_14__constants__["a" /* CoreConstants */].DOWNLOADING]), downloadId = this.getSectionDownloadId(section);
        section.isDownloading = true;
        // Prefetch all modules to prevent incoeherences in download count and to download stale data not marked as outdated.
        return this.prefetchDelegate.prefetchModules(downloadId, modules, courseId, function (data) {
            section.count = data.count;
            section.total = data.total;
        });
    };
    /**
     * Check if a section has content.
     *
     * @param {any} section Section to check.
     * @return {boolean} Whether the section has content.
     */
    CoreCourseHelperProvider.prototype.sectionHasContent = function (section) {
        if (section.id == __WEBPACK_IMPORTED_MODULE_10__course__["a" /* CoreCourseProvider */].ALL_SECTIONS_ID || section.hiddenbynumsections) {
            return false;
        }
        return (typeof section.availabilityinfo != 'undefined' && section.availabilityinfo != '') ||
            section.summary != '' || (section.modules && section.modules.length > 0);
    };
    CoreCourseHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_10__course__["a" /* CoreCourseProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_11__module_delegate__["a" /* CoreCourseModuleDelegate */], __WEBPACK_IMPORTED_MODULE_12__module_prefetch_delegate__["a" /* CoreCourseModulePrefetchDelegate */],
            __WEBPACK_IMPORTED_MODULE_2__providers_filepool__["a" /* CoreFilepoolProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_5__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_utils_time__["a" /* CoreTimeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_7__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_13__login_providers_helper__["a" /* CoreLoginHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_8__options_delegate__["a" /* CoreCourseOptionsDelegate */], __WEBPACK_IMPORTED_MODULE_9__sitehome_providers_sitehome__["a" /* CoreSiteHomeProvider */]])
    ], CoreCourseHelperProvider);
    return CoreCourseHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),

/***/ 640:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseUnsupportedModuleComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_course__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_module_delegate__ = __webpack_require__(140);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Component that displays info about an unsupported module.
 */
var CoreCourseUnsupportedModuleComponent = /** @class */ (function () {
    function CoreCourseUnsupportedModuleComponent(courseProvider, moduleDelegate) {
        this.courseProvider = courseProvider;
        this.moduleDelegate = moduleDelegate;
    }
    /**
     * Component being initialized.
     */
    CoreCourseUnsupportedModuleComponent.prototype.ngOnInit = function () {
        this.isDisabledInSite = this.moduleDelegate.isModuleDisabledInSite(this.module.modname);
        this.isSupportedByTheApp = this.moduleDelegate.hasHandler(this.module.modname);
        this.moduleName = this.courseProvider.translateModuleName(this.module.modname);
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreCourseUnsupportedModuleComponent.prototype, "course", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreCourseUnsupportedModuleComponent.prototype, "module", void 0);
    CoreCourseUnsupportedModuleComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-course-unsupported-module',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/core/course/components/unsupported-module/unsupported-module.html"*/'<div padding>\n    <core-course-module-description [description]="module.description"></core-course-module-description>\n    <h2 *ngIf="!isDisabledInSite && isSupportedByTheApp">{{ \'core.whoops\' | translate }}</h2>\n    <h2 *ngIf="isDisabledInSite ||!isSupportedByTheApp">{{ \'core.uhoh\' | translate }}</h2>\n\n    <p class="core-big" *ngIf="isDisabledInSite">{{ \'core.course.activitydisabled\' | translate }}</p>\n    <p class="core-big" *ngIf="!isDisabledInSite && isSupportedByTheApp">{{ \'core.course.activitynotyetviewablesiteupgradeneeded\' | translate }}</p>\n    <p class="core-big" *ngIf="!isDisabledInSite && !isSupportedByTheApp">{{ \'core.course.activitynotyetviewableremoteaddon\' | translate }}</p>\n    <p *ngIf="isDisabledInSite ||!isSupportedByTheApp"><strong>{{ \'core.course.askadmintosupport\' | translate }}</strong></p>\n\n    <div *ngIf="module.url">\n        <p><strong>{{ \'core.course.useactivityonbrowser\' | translate }}</strong></p>\n        <a ion-button block icon-end [href]="module.url" core-link>\n            {{ \'core.openinbrowser\' | translate }}\n            <ion-icon name="open"></ion-icon>\n        </a>\n    </div>\n</div>'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/core/course/components/unsupported-module/unsupported-module.html"*/,
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_course__["a" /* CoreCourseProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_module_delegate__["a" /* CoreCourseModuleDelegate */]])
    ], CoreCourseUnsupportedModuleComponent);
    return CoreCourseUnsupportedModuleComponent;
}());

//# sourceMappingURL=unsupported-module.js.map

/***/ }),

/***/ 641:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreUserComponentsModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__participants_participants__ = __webpack_require__(548);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__user_profile_field_user_profile_field__ = __webpack_require__(981);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__components_components_module__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__directives_directives_module__ = __webpack_require__(85);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__pipes_pipes_module__ = __webpack_require__(153);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};









var CoreUserComponentsModule = /** @class */ (function () {
    function CoreUserComponentsModule() {
    }
    CoreUserComponentsModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_4__participants_participants__["a" /* CoreUserParticipantsComponent */],
                __WEBPACK_IMPORTED_MODULE_5__user_profile_field_user_profile_field__["a" /* CoreUserProfileFieldComponent */]
            ],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1__angular_common__["b" /* CommonModule */],
                __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["g" /* IonicModule */],
                __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["b" /* TranslateModule */].forChild(),
                __WEBPACK_IMPORTED_MODULE_6__components_components_module__["a" /* CoreComponentsModule */],
                __WEBPACK_IMPORTED_MODULE_7__directives_directives_module__["a" /* CoreDirectivesModule */],
                __WEBPACK_IMPORTED_MODULE_8__pipes_pipes_module__["a" /* CorePipesModule */]
            ],
            providers: [],
            exports: [
                __WEBPACK_IMPORTED_MODULE_4__participants_participants__["a" /* CoreUserParticipantsComponent */],
                __WEBPACK_IMPORTED_MODULE_5__user_profile_field_user_profile_field__["a" /* CoreUserProfileFieldComponent */]
            ],
            entryComponents: [
                __WEBPACK_IMPORTED_MODULE_4__participants_participants__["a" /* CoreUserParticipantsComponent */]
            ]
        })
    ], CoreUserComponentsModule);
    return CoreUserComponentsModule;
}());

//# sourceMappingURL=components.module.js.map

/***/ }),

/***/ 642:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonCalendarHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_course_providers_course__ = __webpack_require__(37);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Service that provides some features regarding lists of courses and categories.
 */
var AddonCalendarHelperProvider = /** @class */ (function () {
    function AddonCalendarHelperProvider(logger, courseProvider) {
        this.courseProvider = courseProvider;
        this.EVENTICONS = {
            course: 'ionic',
            group: 'people',
            site: 'globe',
            user: 'person',
            category: 'albums'
        };
        this.logger = logger.getInstance('AddonCalendarHelperProvider');
    }
    /**
     * Convenience function to format some event data to be rendered.
     *
     * @param {any} e Event to format.
     */
    AddonCalendarHelperProvider.prototype.formatEventData = function (e) {
        e.icon = this.EVENTICONS[e.eventtype] || false;
        if (!e.icon) {
            e.icon = this.courseProvider.getModuleIconSrc(e.modulename);
            e.moduleIcon = e.icon;
        }
    };
    AddonCalendarHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__core_course_providers_course__["a" /* CoreCourseProvider */]])
    ], AddonCalendarHelperProvider);
    return AddonCalendarHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),

/***/ 643:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreMainMenuProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_lang__ = __webpack_require__(101);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__configconstants__ = __webpack_require__(46);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Service that provides some features regarding Main Menu.
 */
var CoreMainMenuProvider = /** @class */ (function () {
    function CoreMainMenuProvider(langProvider, sitesProvider) {
        this.langProvider = langProvider;
        this.sitesProvider = sitesProvider;
    }
    /**
     * Get a list of custom menu items for a certain site.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<CoreMainMenuCustomItem[]>} List of custom menu items.
     */
    CoreMainMenuProvider.prototype.getCustomMenuItems = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var itemsString = site.getStoredConfig('tool_mobile_custommenuitems'), map = {}, result = [];
            var items, position = 0; // Position of each item, to keep the same order as it's configured.
            if (!itemsString || typeof itemsString != 'string') {
                // Setting not valid.
                return result;
            }
            // Add items to the map.
            items = itemsString.split(/(?:\r\n|\r|\n)/);
            items.forEach(function (item) {
                var values = item.split('|'), label = values[0] ? values[0].trim() : values[0], url = values[1] ? values[1].trim() : values[1], type = values[2] ? values[2].trim() : values[2], lang = (values[3] ? values[3].trim() : values[3]) || 'none';
                var id, icon = values[4] ? values[4].trim() : values[4];
                if (!label || !url || !type) {
                    // Invalid item, ignore it.
                    return;
                }
                id = url + '#' + type;
                if (!icon) {
                    // Icon not defined, use default one.
                    icon = type == 'embedded' ? 'qr-scanner' : 'link';
                }
                if (!map[id]) {
                    // New entry, add it to the map.
                    map[id] = {
                        url: url,
                        type: type,
                        position: position,
                        labels: {}
                    };
                    position++;
                }
                map[id].labels[lang.toLowerCase()] = {
                    label: label,
                    icon: icon
                };
            });
            if (!position) {
                // No valid items found, stop.
                return result;
            }
            return _this.langProvider.getCurrentLanguage().then(function (currentLang) {
                var fallbackLang = __WEBPACK_IMPORTED_MODULE_3__configconstants__["a" /* CoreConfigConstants */].default_lang || 'en';
                // Get the right label for each entry and add it to the result.
                for (var id in map) {
                    var entry = map[id];
                    var data = entry.labels[currentLang] || entry.labels[currentLang + '_only'] ||
                        entry.labels.none || entry.labels[fallbackLang];
                    if (!data) {
                        // No valid label found, get the first one that is not "_only".
                        for (var lang in entry.labels) {
                            if (lang.indexOf('_only') == -1) {
                                data = entry.labels[lang];
                                break;
                            }
                        }
                        if (!data) {
                            // No valid label, ignore this entry.
                            return;
                        }
                    }
                    result[entry.position] = {
                        url: entry.url,
                        type: entry.type,
                        label: data.label,
                        icon: data.icon
                    };
                }
                return result;
            });
        });
    };
    CoreMainMenuProvider.NUM_MAIN_HANDLERS = 4;
    CoreMainMenuProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_lang__["a" /* CoreLangProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */]])
    ], CoreMainMenuProvider);
    return CoreMainMenuProvider;
}());

//# sourceMappingURL=mainmenu.js.map

/***/ }),

/***/ 644:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreUserHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(10);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Service that provides some features regarding users information.
 */
var CoreUserHelperProvider = /** @class */ (function () {
    function CoreUserHelperProvider(logger, translate) {
        this.translate = translate;
        this.logger = logger.getInstance('CoreUserHelperProvider');
    }
    /**
     * Formats a user address, concatenating address, city and country.
     *
     * @param {string} address Address.
     * @param {string} city    City.
     * @param {string} country Country.
     * @return {string} Formatted address.
     */
    CoreUserHelperProvider.prototype.formatAddress = function (address, city, country) {
        var separator = this.translate.instant('core.listsep');
        var values = [address, city, country];
        values = values.filter(function (value) {
            return value && value.length > 0;
        });
        return values.join(separator + ' ');
    };
    /**
     * Formats a user role list, translating and concatenating them.
     *
     * @param {any[]} [roles] List of user roles.
     * @return {string} The formatted roles.
     */
    CoreUserHelperProvider.prototype.formatRoleList = function (roles) {
        var _this = this;
        if (!roles || roles.length <= 0) {
            return '';
        }
        var separator = this.translate.instant('core.listsep');
        return roles.map(function (value) {
            var translation = _this.translate.instant('core.user.' + value.shortname);
            return translation.indexOf('core.user.') < 0 ? translation : value.shortname;
        }).join(separator + ' ');
    };
    CoreUserHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */]])
    ], CoreUserHelperProvider);
    return CoreUserHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),

/***/ 645:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCoursePickerMenuPopoverComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(7);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Component to display a list of courses.
 */
var CoreCoursePickerMenuPopoverComponent = /** @class */ (function () {
    function CoreCoursePickerMenuPopoverComponent(navParams, viewCtrl) {
        this.viewCtrl = viewCtrl;
        this.courseId = -1;
        this.courses = navParams.get('courses') || [];
        this.courseId = navParams.get('courseId') || -1;
    }
    /**
     * Function called when a course is clicked.
     *
     * @param {Event} event Click event.
     * @param {any} course Course object clicked.
     * @return {boolean} Return true if success, false if error.
     */
    CoreCoursePickerMenuPopoverComponent.prototype.coursePicked = function (event, course) {
        this.viewCtrl.dismiss(course);
        return true;
    };
    CoreCoursePickerMenuPopoverComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-course-picker-menu-popover',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/components/course-picker-menu/course-picker-menu-popover.html"*/'<ion-list radio-group [(ngModel)]="courseId">\n    <ion-item text-wrap *ngFor="let course of courses" >\n        <ion-label><core-format-text [text]="course.fullname"></core-format-text></ion-label>\n        <ion-radio value="{{course.id}}" (ionSelect)="coursePicked($event, course)" ></ion-radio>\n    </ion-item>\n</ion-list>'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/components/course-picker-menu/course-picker-menu-popover.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["m" /* NavParams */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["s" /* ViewController */]])
    ], CoreCoursePickerMenuPopoverComponent);
    return CoreCoursePickerMenuPopoverComponent;
}());

//# sourceMappingURL=course-picker-menu-popover.js.map

/***/ }),

/***/ 646:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonFilesHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_sites__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_dom__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_fileuploader_providers_helper__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__files__ = __webpack_require__(155);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Service that provides some features regarding private and site files.
 */
var AddonFilesHelperProvider = /** @class */ (function () {
    function AddonFilesHelperProvider(sitesProvider, fileUploaderHelper, filesProvider, domUtils) {
        this.sitesProvider = sitesProvider;
        this.fileUploaderHelper = fileUploaderHelper;
        this.filesProvider = filesProvider;
        this.domUtils = domUtils;
    }
    /**
     * Select a file, upload it and move it to private files.
     *
     * @param {any} [info] Private files info. See AddonFilesProvider.getPrivateFilesInfo.
     * @return {Promise<any>} Promise resolved when a file is uploaded, rejected otherwise.
     */
    AddonFilesHelperProvider.prototype.uploadPrivateFile = function (info) {
        var _this = this;
        // Calculate the max size.
        var currentSite = this.sitesProvider.getCurrentSite();
        var maxSize = currentSite.getInfo().usermaxuploadfilesize, userQuota = currentSite.getInfo().userquota;
        if (userQuota === 0) {
            // 0 means ignore user quota. In the app it is -1.
            userQuota = -1;
        }
        else if (userQuota > 0 && typeof info != 'undefined') {
            userQuota = userQuota - info.filesizewithoutreferences;
        }
        if (typeof userQuota != 'undefined') {
            // Use the minimum value.
            maxSize = Math.min(maxSize, userQuota);
        }
        // Select and upload the file.
        return this.fileUploaderHelper.selectAndUploadFile(maxSize).then(function (result) {
            if (!result) {
                return Promise.reject(null);
            }
            // File uploaded. Move it to private files.
            var modal = _this.domUtils.showModalLoading('core.fileuploader.uploading', true);
            return _this.filesProvider.moveFromDraftToPrivate(result.itemid).catch(function (error) {
                _this.domUtils.showErrorModalDefault(error, 'core.fileuploader.errorwhileuploading', true);
                return Promise.reject(null);
            }).finally(function () {
                modal.dismiss();
            });
        }).then(function () {
            _this.domUtils.showToast('core.fileuploader.fileuploaded', true, undefined, 'core-toast-success');
        });
    };
    AddonFilesHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_3__core_fileuploader_providers_helper__["a" /* CoreFileUploaderHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_4__files__["a" /* AddonFilesProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_dom__["a" /* CoreDomUtilsProvider */]])
    ], AddonFilesHelperProvider);
    return AddonFilesHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),

/***/ 647:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_platform_browser_dynamic__ = __webpack_require__(648);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__app_module__ = __webpack_require__(652);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_promise_prototype_finally__ = __webpack_require__(1136);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_promise_prototype_finally___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_promise_prototype_finally__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.



Object(__WEBPACK_IMPORTED_MODULE_2_promise_prototype_finally__["shim"])(); // Support promise.finally.
Object(__WEBPACK_IMPORTED_MODULE_0__angular_platform_browser_dynamic__["a" /* platformBrowserDynamic */])().bootstrapModule(__WEBPACK_IMPORTED_MODULE_1__app_module__["a" /* AppModule */]);
//# sourceMappingURL=main.js.map

/***/ }),

/***/ 65:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreConfigProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__app__ = __webpack_require__(14);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Factory to provide access to dynamic and permanent config and settings.
 * It should not be abused into a temporary storage.
 */
var CoreConfigProvider = /** @class */ (function () {
    function CoreConfigProvider(appProvider) {
        this.TABLE_NAME = 'core_config';
        this.tableSchema = {
            name: this.TABLE_NAME,
            columns: [
                {
                    name: 'name',
                    type: 'TEXT',
                    unique: true,
                    notNull: true
                },
                {
                    name: 'value'
                }
            ]
        };
        this.appDB = appProvider.getDB();
        this.appDB.createTableFromSchema(this.tableSchema);
    }
    /**
     * Deletes an app setting.
     *
     * @param {string} name The config name.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreConfigProvider.prototype.delete = function (name) {
        return this.appDB.deleteRecords(this.TABLE_NAME, { name: name });
    };
    /**
     * Get an app setting.
     *
     * @param {string} name The config name.
     * @param {any} [defaultValue] Default value to use if the entry is not found.
     * @return {Promise<any>} Resolves upon success along with the config data. Reject on failure.
     */
    CoreConfigProvider.prototype.get = function (name, defaultValue) {
        return this.appDB.getRecord(this.TABLE_NAME, { name: name }).then(function (entry) {
            return entry.value;
        }).catch(function (error) {
            if (typeof defaultValue != 'undefined') {
                return defaultValue;
            }
            else {
                return Promise.reject(error);
            }
        });
    };
    /**
     * Set an app setting.
     *
     * @param {string} name The config name.
     * @param {boolean|number|string} value The config value. Can only store primitive values, not objects.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreConfigProvider.prototype.set = function (name, value) {
        return this.appDB.insertOrUpdateRecord(this.TABLE_NAME, { name: name, value: value }, { name: name });
    };
    CoreConfigProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__app__["a" /* CoreAppProvider */]])
    ], CoreConfigProvider);
    return CoreConfigProvider;
}());

//# sourceMappingURL=config.js.map

/***/ }),

/***/ 652:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export createTranslateLoader */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AppModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_platform_browser__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__angular_http__ = __webpack_require__(540);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__angular_common_http__ = __webpack_require__(107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ngx_translate_core__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ngx_translate_http_loader__ = __webpack_require__(999);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__app_component__ = __webpack_require__(1001);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__classes_interceptor__ = __webpack_require__(541);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_db__ = __webpack_require__(201);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_app__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_config__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_lang__ = __webpack_require__(101);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_utils_text__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_utils_dom__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_utils_time__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_utils_url__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__providers_utils_mimetype__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__providers_init__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__providers_file__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__providers_ws__ = __webpack_require__(114);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__providers_events__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__providers_sites_factory__ = __webpack_require__(539);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__providers_sites__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__providers_local_notifications__ = __webpack_require__(113);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__providers_groups__ = __webpack_require__(546);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__providers_cron__ = __webpack_require__(1002);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__providers_file_session__ = __webpack_require__(1003);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__providers_filepool__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__providers_update_manager__ = __webpack_require__(1004);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__providers_plugin_file_delegate__ = __webpack_require__(538);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_33__providers_sync__ = __webpack_require__(1005);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_34__components_components_module__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_35__core_emulator_emulator_module__ = __webpack_require__(1006);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_36__core_login_login_module__ = __webpack_require__(1087);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_37__core_mainmenu_mainmenu_module__ = __webpack_require__(1088);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_38__core_courses_courses_module__ = __webpack_require__(1089);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_39__core_fileuploader_fileuploader_module__ = __webpack_require__(1094);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_40__core_sharedfiles_sharedfiles_module__ = __webpack_require__(1100);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_41__core_course_course_module__ = __webpack_require__(1102);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_42__core_sitehome_sitehome_module__ = __webpack_require__(1110);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_43__core_contentlinks_contentlinks_module__ = __webpack_require__(1113);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_44__core_user_user_module__ = __webpack_require__(1114);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_45__addon_badges_badges_module__ = __webpack_require__(1119);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_46__addon_calendar_calendar_module__ = __webpack_require__(1121);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_47__addon_userprofilefield_userprofilefield_module__ = __webpack_require__(1123);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_48__addon_files_files_module__ = __webpack_require__(1134);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


































// Core modules.











// Addon modules.




// For translate loader. AoT requires an exported function for factories.
function createTranslateLoader(http) {
    return new __WEBPACK_IMPORTED_MODULE_6__ngx_translate_http_loader__["a" /* TranslateHttpLoader */](http, './assets/lang/', '.json');
}
var AppModule = /** @class */ (function () {
    function AppModule(platform, initDelegate, updateManager, sitesProvider) {
        // Register a handler for platform ready.
        initDelegate.registerProcess({
            name: 'CorePlatformReady',
            priority: __WEBPACK_IMPORTED_MODULE_20__providers_init__["a" /* CoreInitDelegate */].MAX_RECOMMENDED_PRIORITY + 400,
            blocking: true,
            load: platform.ready
        });
        // Register the update manager as an init process.
        initDelegate.registerProcess(updateManager);
        // Restore the user's session during the init process.
        initDelegate.registerProcess({
            name: 'CoreRestoreSession',
            priority: __WEBPACK_IMPORTED_MODULE_20__providers_init__["a" /* CoreInitDelegate */].MAX_RECOMMENDED_PRIORITY + 200,
            blocking: false,
            load: sitesProvider.restoreSession.bind(sitesProvider)
        });
        // Execute the init processes.
        initDelegate.executeInitProcesses();
    }
    AppModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_7__app_component__["a" /* MoodleMobileApp */]
            ],
            imports: [
                __WEBPACK_IMPORTED_MODULE_0__angular_platform_browser__["a" /* BrowserModule */],
                __WEBPACK_IMPORTED_MODULE_4__angular_common_http__["c" /* HttpClientModule */],
                __WEBPACK_IMPORTED_MODULE_3__angular_http__["b" /* HttpModule */],
                __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["g" /* IonicModule */].forRoot(__WEBPACK_IMPORTED_MODULE_7__app_component__["a" /* MoodleMobileApp */], {
                    pageTransition: 'ios-transition'
                }, {
                    links: [
                        { loadChildren: '../addon/badges/pages/issued-badge/issued-badge.module#AddonBadgesIssuedBadgePageModule', name: 'AddonBadgesIssuedBadgePage', segment: 'addon-badges-issued-badge', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../addon/badges/pages/user-badges/user-badges.module#AddonBadgesUserBadgesPageModule', name: 'AddonBadgesUserBadgesPage', segment: 'addon-badges-user-badges', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../addon/calendar/pages/event/event.module#AddonCalendarEventPageModule', name: 'AddonCalendarEventPage', segment: 'addon-calendar-event', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../addon/calendar/pages/list/list.module#AddonCalendarListPageModule', name: 'AddonCalendarListPage', segment: 'addon-calendar-list', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../addon/calendar/pages/settings/settings.module#AddonCalendarSettingsPageModule', name: 'AddonCalendarSettingsPage', segment: 'addon-calendar-settings', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../addon/files/pages/list/list.module#AddonFilesListPageModule', name: 'AddonFilesListPage', segment: 'addon-files-list', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../components/split-view/placeholder/placeholder.module#CorePlaceholderPageModule', name: 'CoreSplitViewPlaceholderPage', segment: 'core-placeholder', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/contentlinks/pages/choose-site/choose-site.module#CoreContentLinksChooseSitePageModule', name: 'CoreContentLinksChooseSitePage', segment: 'core-content-links-choose-site', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/course/pages/unsupported-module/unsupported-module.module#CoreCourseUnsupportedModulePageModule', name: 'CoreCourseUnsupportedModulePage', segment: 'core-course-unsupported-module', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/course/pages/section/section.module#CoreCourseSectionPageModule', name: 'CoreCourseSectionPage', segment: 'core-course-section', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/courses/pages/available-courses/available-courses.module#CoreCoursesAvailableCoursesPageModule', name: 'CoreCoursesAvailableCoursesPage', segment: 'core-courses-available-courses', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/courses/pages/categories/categories.module#CoreCoursesCategoriesPageModule', name: 'CoreCoursesCategoriesPage', segment: 'core-courses-categories', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/courses/pages/my-courses/my-courses.module#CoreCoursesMyCoursesPageModule', name: 'CoreCoursesMyCoursesPage', segment: 'core-courses-my-courses', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/courses/pages/course-preview/course-preview.module#CoreCoursesCoursePreviewPageModule', name: 'CoreCoursesCoursePreviewPage', segment: 'core-courses-course-preview', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/courses/pages/search/search.module#CoreCoursesSearchPageModule', name: 'CoreCoursesSearchPage', segment: 'core-courses-search', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/courses/pages/my-overview/my-overview.module#CoreCoursesMyOverviewPageModule', name: 'CoreCoursesMyOverviewPage', segment: 'core-courses-my-overview', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/courses/pages/self-enrol-password/self-enrol-password.module#CoreCoursesSelfEnrolPasswordPageModule', name: 'CoreCoursesSelfEnrolPasswordPage', segment: 'core-courses-self-enrol-password', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/emulator/pages/capture-media/capture-media.module#CoreEmulatorCaptureMediaPageModule', name: 'CoreEmulatorCaptureMediaPage', segment: 'core-emulator-capture-media', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/login/pages/credentials/credentials.module#CoreLoginCredentialsPageModule', name: 'CoreLoginCredentialsPage', segment: 'core-login-credentials', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/login/pages/init/init.module#CoreLoginInitPageModule', name: 'CoreLoginInitPage', segment: 'core-login-init', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/login/pages/reconnect/reconnect.module#CoreLoginReconnectPageModule', name: 'CoreLoginReconnectPage', segment: 'core-login-reconnect', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/login/pages/email-signup/email-signup.module#CoreLoginCredentialsPageModule', name: 'CoreLoginEmailSignupPage', segment: 'core-login-email-signup', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/login/pages/site-error/site-error.module#CoreLoginSiteErrorPageModule', name: 'CoreLoginSiteErrorPage', segment: 'core-login-site-error', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/login/pages/forgotten-password/forgotten-password.module#CoreLoginForgottenPasswordPageModule', name: 'CoreLoginForgottenPasswordPage', segment: 'core-login-forgotten-password', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/login/pages/site-policy/site-policy.module#CoreLoginSitePolicyPageModule', name: 'CoreLoginSitePolicyPage', segment: 'core-login-site-policy', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/login/pages/site-help/site-help.module#CoreLoginSiteHelpPageModule', name: 'CoreLoginSiteHelpPage', segment: 'core-login-site-help', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/login/pages/site/site.module#CoreLoginSitePageModule', name: 'CoreLoginSitePage', segment: 'core-login-site', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/login/pages/sites/sites.module#CoreLoginSitesPageModule', name: 'CoreLoginSitesPage', segment: 'core-login-sites', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/mainmenu/pages/menu/menu.module#CoreMainMenuPageModule', name: 'CoreMainMenuPage', segment: 'core-mainmenu', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/mainmenu/pages/more/more.module#CoreMainMenuPageModule', name: 'CoreMainMenuMorePage', segment: 'core-mainmenu-more', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/sharedfiles/pages/choose-site/choose-site.module#CoreSharedFilesChooseSitePageModule', name: 'CoreSharedFilesChooseSitePage', segment: 'core-shared-files-choose-site', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/sharedfiles/pages/list/list.module#CoreSharedFilesListPageModule', name: 'CoreSharedFilesListPage', segment: 'core-shared-files-list', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/sitehome/pages/index/index.module#CoreSiteHomeIndexPageModule', name: 'CoreSiteHomeIndexPage', segment: 'core-sitehome-index', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/user/pages/about/about.module#CoreUserAboutPageModule', name: 'CoreUserAboutPage', segment: 'core-user-about', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/user/pages/profile/profile.module#CoreUserProfilePageModule', name: 'CoreUserProfilePage', segment: 'core-user-profile', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/user/pages/participants/participants.module#CoreUserParticipantsPageModule', name: 'CoreUserParticipantsPage', segment: 'core-user-participants', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/viewer/pages/iframe/iframe.module#CoreViewerIframePageModule', name: 'CoreViewerIframePage', segment: 'core-viewer-iframe', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/viewer/pages/image/image.module#CoreViewerImagePageModule', name: 'CoreViewerImagePage', segment: 'core-viewer-image', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/viewer/pages/text/text.module#CoreViewerTextPageModule', name: 'CoreViewerTextPage', segment: 'core-viewer-text', priority: 'low', defaultHistory: [] }
                    ]
                }),
                __WEBPACK_IMPORTED_MODULE_5__ngx_translate_core__["b" /* TranslateModule */].forRoot({
                    loader: {
                        provide: __WEBPACK_IMPORTED_MODULE_5__ngx_translate_core__["a" /* TranslateLoader */],
                        useFactory: (createTranslateLoader),
                        deps: [__WEBPACK_IMPORTED_MODULE_4__angular_common_http__["b" /* HttpClient */]]
                    }
                }),
                __WEBPACK_IMPORTED_MODULE_34__components_components_module__["a" /* CoreComponentsModule */],
                __WEBPACK_IMPORTED_MODULE_35__core_emulator_emulator_module__["a" /* CoreEmulatorModule */],
                __WEBPACK_IMPORTED_MODULE_36__core_login_login_module__["a" /* CoreLoginModule */],
                __WEBPACK_IMPORTED_MODULE_37__core_mainmenu_mainmenu_module__["a" /* CoreMainMenuModule */],
                __WEBPACK_IMPORTED_MODULE_38__core_courses_courses_module__["a" /* CoreCoursesModule */],
                __WEBPACK_IMPORTED_MODULE_39__core_fileuploader_fileuploader_module__["a" /* CoreFileUploaderModule */],
                __WEBPACK_IMPORTED_MODULE_40__core_sharedfiles_sharedfiles_module__["a" /* CoreSharedFilesModule */],
                __WEBPACK_IMPORTED_MODULE_41__core_course_course_module__["a" /* CoreCourseModule */],
                __WEBPACK_IMPORTED_MODULE_42__core_sitehome_sitehome_module__["a" /* CoreSiteHomeModule */],
                __WEBPACK_IMPORTED_MODULE_43__core_contentlinks_contentlinks_module__["a" /* CoreContentLinksModule */],
                __WEBPACK_IMPORTED_MODULE_44__core_user_user_module__["a" /* CoreUserModule */],
                __WEBPACK_IMPORTED_MODULE_45__addon_badges_badges_module__["a" /* AddonBadgesModule */],
                __WEBPACK_IMPORTED_MODULE_46__addon_calendar_calendar_module__["a" /* AddonCalendarModule */],
                __WEBPACK_IMPORTED_MODULE_47__addon_userprofilefield_userprofilefield_module__["a" /* AddonUserProfileFieldModule */],
                __WEBPACK_IMPORTED_MODULE_48__addon_files_files_module__["a" /* AddonFilesModule */]
            ],
            bootstrap: [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["f" /* IonicApp */]],
            entryComponents: [
                __WEBPACK_IMPORTED_MODULE_7__app_component__["a" /* MoodleMobileApp */]
            ],
            providers: [
                {
                    provide: __WEBPACK_IMPORTED_MODULE_4__angular_common_http__["a" /* HTTP_INTERCEPTORS */],
                    useClass: __WEBPACK_IMPORTED_MODULE_8__classes_interceptor__["a" /* CoreInterceptor */],
                    multi: true,
                },
                __WEBPACK_IMPORTED_MODULE_9__providers_logger__["a" /* CoreLoggerProvider */],
                __WEBPACK_IMPORTED_MODULE_10__providers_db__["a" /* CoreDbProvider */],
                __WEBPACK_IMPORTED_MODULE_11__providers_app__["a" /* CoreAppProvider */],
                __WEBPACK_IMPORTED_MODULE_12__providers_config__["a" /* CoreConfigProvider */],
                __WEBPACK_IMPORTED_MODULE_13__providers_lang__["a" /* CoreLangProvider */],
                __WEBPACK_IMPORTED_MODULE_14__providers_utils_text__["a" /* CoreTextUtilsProvider */],
                __WEBPACK_IMPORTED_MODULE_15__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
                __WEBPACK_IMPORTED_MODULE_16__providers_utils_time__["a" /* CoreTimeUtilsProvider */],
                __WEBPACK_IMPORTED_MODULE_17__providers_utils_url__["a" /* CoreUrlUtilsProvider */],
                __WEBPACK_IMPORTED_MODULE_18__providers_utils_utils__["a" /* CoreUtilsProvider */],
                __WEBPACK_IMPORTED_MODULE_19__providers_utils_mimetype__["a" /* CoreMimetypeUtilsProvider */],
                __WEBPACK_IMPORTED_MODULE_20__providers_init__["a" /* CoreInitDelegate */],
                __WEBPACK_IMPORTED_MODULE_21__providers_file__["a" /* CoreFileProvider */],
                __WEBPACK_IMPORTED_MODULE_22__providers_ws__["a" /* CoreWSProvider */],
                __WEBPACK_IMPORTED_MODULE_23__providers_events__["a" /* CoreEventsProvider */],
                __WEBPACK_IMPORTED_MODULE_24__providers_sites_factory__["a" /* CoreSitesFactoryProvider */],
                __WEBPACK_IMPORTED_MODULE_25__providers_sites__["a" /* CoreSitesProvider */],
                __WEBPACK_IMPORTED_MODULE_26__providers_local_notifications__["a" /* CoreLocalNotificationsProvider */],
                __WEBPACK_IMPORTED_MODULE_27__providers_groups__["a" /* CoreGroupsProvider */],
                __WEBPACK_IMPORTED_MODULE_28__providers_cron__["a" /* CoreCronDelegate */],
                __WEBPACK_IMPORTED_MODULE_29__providers_file_session__["a" /* CoreFileSessionProvider */],
                __WEBPACK_IMPORTED_MODULE_30__providers_filepool__["a" /* CoreFilepoolProvider */],
                __WEBPACK_IMPORTED_MODULE_31__providers_update_manager__["a" /* CoreUpdateManagerProvider */],
                __WEBPACK_IMPORTED_MODULE_32__providers_plugin_file_delegate__["a" /* CorePluginFileDelegate */],
                __WEBPACK_IMPORTED_MODULE_33__providers_sync__["a" /* CoreSyncProvider */]
            ]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* Platform */], __WEBPACK_IMPORTED_MODULE_20__providers_init__["a" /* CoreInitDelegate */], __WEBPACK_IMPORTED_MODULE_31__providers_update_manager__["a" /* CoreUpdateManagerProvider */],
            __WEBPACK_IMPORTED_MODULE_25__providers_sites__["a" /* CoreSitesProvider */]])
    ], AppModule);
    return AppModule;
}());

//# sourceMappingURL=app.module.js.map

/***/ }),

/***/ 66:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFilepoolProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_network__ = __webpack_require__(102);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__app__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__events__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__file__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__init__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__plugin_file_delegate__ = __webpack_require__(538);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__sites__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__ws__ = __webpack_require__(114);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__utils_mimetype__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__utils_text__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__utils_time__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__utils_url__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__core_constants__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_ts_md5_dist_md5__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_ts_md5_dist_md5___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_16_ts_md5_dist_md5__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

















/*
 * Factory for handling downloading files and retrieve downloaded files.
 *
 * @description
 * This factory is responsible for handling downloading files.
 *
 * The two main goals of this is to keep the content available offline, and improve the user experience by caching
 * the content locally.
 */
var CoreFilepoolProvider = /** @class */ (function () {
    function CoreFilepoolProvider(logger, appProvider, fileProvider, sitesProvider, wsProvider, textUtils, utils, mimeUtils, urlUtils, timeUtils, eventsProvider, initDelegate, network, pluginFileDelegate) {
        var _this = this;
        this.appProvider = appProvider;
        this.fileProvider = fileProvider;
        this.sitesProvider = sitesProvider;
        this.wsProvider = wsProvider;
        this.textUtils = textUtils;
        this.utils = utils;
        this.mimeUtils = mimeUtils;
        this.urlUtils = urlUtils;
        this.timeUtils = timeUtils;
        this.eventsProvider = eventsProvider;
        this.pluginFileDelegate = pluginFileDelegate;
        // Constants.
        this.QUEUE_PROCESS_INTERVAL = 0;
        this.FOLDER = 'filepool';
        this.WIFI_DOWNLOAD_THRESHOLD = 20971520; // 20MB.
        this.DOWNLOAD_THRESHOLD = 2097152; // 2MB.
        this.QUEUE_RUNNING = 'mmFilepool:QUEUE_RUNNING';
        this.QUEUE_PAUSED = 'mmFilepool:QUEUE_PAUSED';
        this.ERR_QUEUE_IS_EMPTY = 'mmFilepoolError:ERR_QUEUE_IS_EMPTY';
        this.ERR_FS_OR_NETWORK_UNAVAILABLE = 'mmFilepoolError:ERR_FS_OR_NETWORK_UNAVAILABLE';
        this.ERR_QUEUE_ON_PAUSE = 'mmFilepoolError:ERR_QUEUE_ON_PAUSE';
        // Variables for database.
        this.QUEUE_TABLE = 'filepool_files_queue'; // Queue of files to download.
        this.FILES_TABLE = 'filepool_files'; // Downloaded files.
        this.LINKS_TABLE = 'filepool_files_links'; // Links between downloaded files and components.
        this.PACKAGES_TABLE = 'filepool_packages'; // Downloaded packages (sets of files).
        this.appTablesSchema = [
            {
                name: this.QUEUE_TABLE,
                columns: [
                    {
                        name: 'siteId',
                        type: 'TEXT'
                    },
                    {
                        name: 'fileId',
                        type: 'TEXT'
                    },
                    {
                        name: 'added',
                        type: 'INTEGER'
                    },
                    {
                        name: 'priority',
                        type: 'INTEGER'
                    },
                    {
                        name: 'url',
                        type: 'TEXT'
                    },
                    {
                        name: 'revision',
                        type: 'INTEGER'
                    },
                    {
                        name: 'timemodified',
                        type: 'INTEGER'
                    },
                    {
                        name: 'isexternalfile',
                        type: 'INTEGER'
                    },
                    {
                        name: 'repositorytype',
                        type: 'TEXT'
                    },
                    {
                        name: 'path',
                        type: 'TEXT'
                    },
                    {
                        name: 'links',
                        type: 'TEXT'
                    }
                ],
                primaryKeys: ['siteId', 'fileId']
            }
        ];
        this.sitesTablesSchema = [
            {
                name: this.FILES_TABLE,
                columns: [
                    {
                        name: 'fileId',
                        type: 'TEXT',
                        primaryKey: true
                    },
                    {
                        name: 'url',
                        type: 'TEXT',
                        notNull: true
                    },
                    {
                        name: 'revision',
                        type: 'INTEGER'
                    },
                    {
                        name: 'timemodified',
                        type: 'INTEGER'
                    },
                    {
                        name: 'stale',
                        type: 'INTEGER'
                    },
                    {
                        name: 'downloadTime',
                        type: 'INTEGER'
                    },
                    {
                        name: 'isexternalfile',
                        type: 'INTEGER'
                    },
                    {
                        name: 'repositorytype',
                        type: 'TEXT'
                    },
                    {
                        name: 'path',
                        type: 'TEXT'
                    },
                    {
                        name: 'extension',
                        type: 'TEXT'
                    }
                ]
            },
            {
                name: this.LINKS_TABLE,
                columns: [
                    {
                        name: 'fileId',
                        type: 'TEXT'
                    },
                    {
                        name: 'component',
                        type: 'TEXT'
                    },
                    {
                        name: 'componentId',
                        type: 'TEXT'
                    }
                ],
                primaryKeys: ['fileId', 'component', 'componentId']
            },
            {
                name: this.PACKAGES_TABLE,
                columns: [
                    {
                        name: 'id',
                        type: 'TEXT',
                        primaryKey: true
                    },
                    {
                        name: 'component',
                        type: 'TEXT'
                    },
                    {
                        name: 'componentId',
                        type: 'TEXT'
                    },
                    {
                        name: 'status',
                        type: 'TEXT'
                    },
                    {
                        name: 'previous',
                        type: 'TEXT'
                    },
                    {
                        name: 'updated',
                        type: 'INTEGER'
                    },
                    {
                        name: 'downloadTime',
                        type: 'INTEGER'
                    },
                    {
                        name: 'previousDownloadTime',
                        type: 'INTEGER'
                    },
                    {
                        name: 'extra',
                        type: 'TEXT'
                    }
                ]
            },
        ];
        this.tokenRegex = new RegExp('(\\?|&)token=([A-Za-z0-9]+)');
        this.urlAttributes = [
            this.tokenRegex,
            new RegExp('(\\?|&)forcedownload=[0-1]'),
            new RegExp('(\\?|&)preview=[A-Za-z0-9]+'),
            new RegExp('(\\?|&)offline=[0-1]', 'g')
        ];
        this.queueDeferreds = {}; // To handle file downloads using the queue.
        this.sizeCache = {}; // A "cache" to store file sizes to prevent performing too many HEAD requests.
        // Variables to prevent downloading packages/files twice at the same time.
        this.packagesPromises = {};
        this.filePromises = {};
        this.logger = logger.getInstance('CoreFilepoolProvider');
        this.appDB = this.appProvider.getDB();
        this.appDB.createTablesFromSchema(this.appTablesSchema);
        this.sitesProvider.createTablesFromSchema(this.sitesTablesSchema);
        initDelegate.ready().then(function () {
            // Waiting for the app to be ready to start processing the queue.
            _this.checkQueueProcessing();
            // Start queue when device goes online.
            network.onConnect().subscribe(function () {
                _this.checkQueueProcessing();
            });
        });
    }
    /**
     * Link a file with a component.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @param {string} component The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<any>} Promise resolved on success.
     */
    CoreFilepoolProvider.prototype.addFileLink = function (siteId, fileId, component, componentId) {
        var _this = this;
        if (!component) {
            return Promise.reject(null);
        }
        componentId = this.fixComponentId(componentId);
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            var newEntry = {
                fileId: fileId,
                component: component,
                componentId: componentId || ''
            };
            return db.insertOrUpdateRecord(_this.LINKS_TABLE, newEntry, undefined);
        });
    };
    /**
     * Link a file with a component by URL.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The file Url.
     * @param {string} component The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<any>} Promise resolved on success.
     * @description
     * Use this method to create a link between a URL and a component. You usually do not need to call this manually since
     * downloading a file automatically does this. Note that this method does not check if the file exists in the pool.
     */
    CoreFilepoolProvider.prototype.addFileLinkByUrl = function (siteId, fileUrl, component, componentId) {
        var _this = this;
        return this.fixPluginfileURL(siteId, fileUrl).then(function (fileUrl) {
            var fileId = _this.getFileIdByUrl(fileUrl);
            return _this.addFileLink(siteId, fileId, component, componentId);
        });
    };
    /**
     * Link a file with several components.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @param {any[]} links Array of objects containing the component and optionally componentId.
     * @return {Promise<any>} Promise resolved on success.
     */
    CoreFilepoolProvider.prototype.addFileLinks = function (siteId, fileId, links) {
        var _this = this;
        var promises = [];
        links.forEach(function (link) {
            promises.push(_this.addFileLink(siteId, fileId, link.component, link.componentId));
        });
        return Promise.all(promises);
    };
    /**
     * Add files to queue using a URL.
     *
     * @param {string} siteId The site ID.
     * @param {any[]} files Array of files to add.
     * @param {string} [component] The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component (optional).
     * @return {Promise<any>} Resolved on success.
     */
    CoreFilepoolProvider.prototype.addFilesToQueue = function (siteId, files, component, componentId) {
        return this.downloadOrPrefetchFiles(siteId, files, true, false, component, componentId);
    };
    /**
     * Add a file to the pool.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @param {any} data Additional information to store about the file (timemodified, url, ...). See FILES_TABLE schema.
     * @return {Promise<any>} Promise resolved on success.
     */
    CoreFilepoolProvider.prototype.addFileToPool = function (siteId, fileId, data) {
        var _this = this;
        var values = Object.assign({}, data);
        values.fileId = fileId;
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            return db.insertOrUpdateRecord(_this.FILES_TABLE, values, { fileId: fileId });
        });
    };
    /**
     * Add a file to the queue.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @param {string} url The absolute URL to the file.
     * @param {number} priority The priority this file should get in the queue (range 0-999).
     * @param {number} revision The revision of the file.
     * @param {number} timemodified The time this file was modified. Can be used to check file state.
     * @param {string} [filePath] Filepath to download the file to. If not defined, download to the filepool folder.
     * @param {any} options Extra options (isexternalfile, repositorytype).
     * @param {any} [link] The link to add for the file.
     * @return {Promise<any>} Promise resolved when the file is downloaded.
     */
    CoreFilepoolProvider.prototype.addToQueue = function (siteId, fileId, url, priority, revision, timemodified, filePath, onProgress, options, link) {
        var _this = this;
        if (options === void 0) { options = {}; }
        this.logger.debug("Adding " + fileId + " to the queue");
        return this.appDB.insertRecord(this.QUEUE_TABLE, {
            siteId: siteId,
            fileId: fileId,
            url: url,
            priority: priority,
            revision: revision,
            timemodified: timemodified,
            path: filePath,
            isexternalfile: options.isexternalfile ? 1 : 0,
            repositorytype: options.repositorytype,
            links: JSON.stringify(link ? [link] : []),
            added: Date.now()
        }).then(function () {
            // Check if the queue is running.
            _this.checkQueueProcessing();
            _this.notifyFileDownloading(siteId, fileId);
            return _this.getQueuePromise(siteId, fileId, true, onProgress);
        });
    };
    /**
     * Add an entry to queue using a URL.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The absolute URL to the file.
     * @param {string} [component] The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component (optional).
     * @param {number} [timemodified=0] The time this file was modified. Can be used to check file state.
     * @param {string} [filePath] Filepath to download the file to. If not defined, download to the filepool folder.
     * @param {Function} [onProgress] Function to call on progress.
     * @param {number} [priority=0] The priority this file should get in the queue (range 0-999).
     * @param {any} [options] Extra options (isexternalfile, repositorytype).
     * @return {Promise} Resolved on success.
     */
    CoreFilepoolProvider.prototype.addToQueueByUrl = function (siteId, fileUrl, component, componentId, timemodified, filePath, onProgress, priority, options) {
        var _this = this;
        if (timemodified === void 0) { timemodified = 0; }
        if (priority === void 0) { priority = 0; }
        if (options === void 0) { options = {}; }
        var fileId, link, revision, queueDeferred;
        if (!this.fileProvider.isAvailable()) {
            return Promise.reject(null);
        }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            if (!site.canDownloadFiles()) {
                return Promise.reject(null);
            }
            return _this.fixPluginfileURL(siteId, fileUrl).then(function (fileUrl) {
                var primaryKey = { siteId: siteId, fileId: fileId };
                revision = _this.getRevisionFromUrl(fileUrl);
                fileId = _this.getFileIdByUrl(fileUrl);
                // Set up the component.
                if (typeof component != 'undefined') {
                    link = {
                        component: component,
                        componentId: _this.fixComponentId(componentId)
                    };
                }
                // Retrieve the queue deferred now if it exists.
                // This is to prevent errors if file is removed from queue while we're checking if the file is in queue.
                queueDeferred = _this.getQueueDeferred(siteId, fileId, false, onProgress);
                return _this.hasFileInQueue(siteId, fileId).then(function (entry) {
                    var newData = {};
                    var foundLink = false;
                    if (entry) {
                        // We already have the file in queue, we update the priority and links.
                        if (entry.priority < priority) {
                            newData.priority = priority;
                        }
                        if (revision && entry.revision !== revision) {
                            newData.revision = revision;
                        }
                        if (timemodified && entry.timemodified !== timemodified) {
                            newData.timemodified = timemodified;
                        }
                        if (filePath && entry.path !== filePath) {
                            newData.path = filePath;
                        }
                        if (entry.isexternalfile !== options.isexternalfile) {
                            newData.isexternalfile = options.isexternalfile;
                        }
                        if (entry.repositorytype !== options.repositorytype) {
                            newData.repositorytype = options.repositorytype;
                        }
                        if (link) {
                            // We need to add the new link if it does not exist yet.
                            if (entry.links && entry.links.length) {
                                for (var i in entry.links) {
                                    var fileLink = entry.links[i];
                                    if (fileLink.component == link.component && fileLink.componentId == link.componentId) {
                                        foundLink = true;
                                        break;
                                    }
                                }
                            }
                            if (!foundLink) {
                                newData.links = entry.links || [];
                                newData.links.push(link);
                                newData.links = JSON.stringify(entry.links);
                            }
                        }
                        if (Object.keys(newData).length) {
                            // Update only when required.
                            _this.logger.debug("Updating file " + fileId + " which is already in queue");
                            return _this.appDB.updateRecords(_this.QUEUE_TABLE, newData, primaryKey).then(function () {
                                return _this.getQueuePromise(siteId, fileId, true, onProgress);
                            });
                        }
                        _this.logger.debug("File " + fileId + " already in queue and does not require update");
                        if (queueDeferred) {
                            // If we were able to retrieve the queue deferred before, we use that one.
                            return queueDeferred.promise;
                        }
                        else {
                            // Create a new deferred and return its promise.
                            return _this.getQueuePromise(siteId, fileId, true, onProgress);
                        }
                    }
                    else {
                        return _this.addToQueue(siteId, fileId, fileUrl, priority, revision, timemodified, filePath, onProgress, options, link);
                    }
                }, function () {
                    // Unsure why we could not get the record, let's add to the queue anyway.
                    return _this.addToQueue(siteId, fileId, fileUrl, priority, revision, timemodified, filePath, onProgress, options, link);
                });
            });
        });
    };
    /**
     * Adds a file to the queue if the size is allowed to be downloaded.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The absolute URL to the file.
     * @param {string} component The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {number} [timemodified=0] The time this file was modified.
     * @param {boolean} [checkSize=true] True if we shouldn't download files if their size is big, false otherwise.
     * @param {boolean} [downloadUnknown] True to download file in WiFi if their size is unknown, false otherwise.
     *                                    Ignored if checkSize=false.
     * @param {any} [options] Extra options (isexternalfile, repositorytype).
     * @return {Promise<any>} Promise resolved when the file is downloaded.
     */
    CoreFilepoolProvider.prototype.addToQueueIfNeeded = function (siteId, fileUrl, component, componentId, timemodified, checkSize, downloadUnknown, options) {
        var _this = this;
        if (timemodified === void 0) { timemodified = 0; }
        if (checkSize === void 0) { checkSize = true; }
        if (options === void 0) { options = {}; }
        var promise;
        if (checkSize) {
            if (typeof this.sizeCache[fileUrl] != 'undefined') {
                promise = Promise.resolve(this.sizeCache[fileUrl]);
            }
            else {
                if (!this.appProvider.isOnline()) {
                    // Cannot check size in offline, stop.
                    return Promise.reject(null);
                }
                promise = this.wsProvider.getRemoteFileSize(fileUrl);
            }
            // Calculate the size of the file.
            return promise.then(function (size) {
                var isWifi = !_this.appProvider.isNetworkAccessLimited(), sizeUnknown = size <= 0;
                if (!sizeUnknown) {
                    // Store the size in the cache.
                    _this.sizeCache[fileUrl] = size;
                }
                // Check if the file should be downloaded.
                if (sizeUnknown) {
                    if (downloadUnknown && isWifi) {
                        return _this.addToQueueByUrl(siteId, fileUrl, component, componentId, timemodified, undefined, undefined, 0, options);
                    }
                }
                else if (size <= _this.DOWNLOAD_THRESHOLD || (isWifi && size <= _this.WIFI_DOWNLOAD_THRESHOLD)) {
                    return _this.addToQueueByUrl(siteId, fileUrl, component, componentId, timemodified, undefined, undefined, 0, options);
                }
            });
        }
        else {
            // No need to check size, just add it to the queue.
            return this.addToQueueByUrl(siteId, fileUrl, component, componentId, timemodified, undefined, undefined, 0, options);
        }
    };
    /**
     * Check the queue processing.
     *
     * @description
     * In mose cases, this will enable the queue processing if it was paused.
     * Though, this will disable the queue if we are missing network or if the file system
     * is not accessible. Also, this will have no effect if the queue is already running.
     */
    CoreFilepoolProvider.prototype.checkQueueProcessing = function () {
        if (!this.fileProvider.isAvailable() || !this.appProvider.isOnline()) {
            this.queueState = this.QUEUE_PAUSED;
            return;
        }
        else if (this.queueState === this.QUEUE_RUNNING) {
            return;
        }
        this.queueState = this.QUEUE_RUNNING;
        this.processQueue();
    };
    /**
     * Clear all packages status in a site.
     *
     * @param {string} siteId Site ID.
     * @return {Promise<any>} Promise resolved when all status are cleared.
     */
    CoreFilepoolProvider.prototype.clearAllPackagesStatus = function (siteId) {
        var _this = this;
        this.logger.debug('Clear all packages status for site ' + siteId);
        return this.sitesProvider.getSite(siteId).then(function (site) {
            // Get all the packages to be able to "notify" the change in the status.
            return site.getDb().getAllRecords(_this.PACKAGES_TABLE).then(function (entries) {
                // Delete all the entries.
                return site.getDb().deleteRecords(_this.PACKAGES_TABLE).then(function () {
                    entries.forEach(function (entry) {
                        // Trigger module status changed, setting it as not downloaded.
                        _this.triggerPackageStatusChanged(siteId, __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED, entry.component, entry.componentId);
                    });
                });
            });
        });
    };
    /**
     * Clears the filepool. Use it only when all the files from a site are deleted.
     *
     * @param  {string} siteId ID of the site to clear.
     * @return {Promise<any>} Promise resolved when the filepool is cleared.
     */
    CoreFilepoolProvider.prototype.clearFilepool = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            return db.deleteRecords(_this.FILES_TABLE);
        });
    };
    /**
     * Returns whether a component has files in the pool.
     *
     * @param {string} siteId The site ID.
     * @param {string} component The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<void>} Resolved means yes, rejected means no.
     */
    CoreFilepoolProvider.prototype.componentHasFiles = function (siteId, component, componentId) {
        var _this = this;
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            var conditions = {
                component: component,
                componentId: componentId || ''
            };
            return db.countRecords(_this.LINKS_TABLE, conditions).then(function (count) {
                if (count <= 0) {
                    return Promise.reject(null);
                }
            });
        });
    };
    /**
     * Given the current status of a list of packages and the status of one of the packages,
     * determine the new status for the list of packages. The status of a list of packages is:
     *     - CoreConstants.NOT_DOWNLOADABLE if there are no downloadable packages.
     *     - CoreConstants.NOT_DOWNLOADED if at least 1 package has status CoreConstants.NOT_DOWNLOADED.
     *     - CoreConstants.DOWNLOADED if ALL the downloadable packages have status CoreConstants.DOWNLOADED.
     *     - CoreConstants.DOWNLOADING if ALL the downloadable packages have status CoreConstants.DOWNLOADING or
     *                                     CoreConstants.DOWNLOADED, with at least 1 package with CoreConstants.DOWNLOADING.
     *     - CoreConstants.OUTDATED if ALL the downloadable packages have status CoreConstants.OUTDATED or CoreConstants.DOWNLOADED
     *                                     or CoreConstants.DOWNLOADING, with at least 1 package with CoreConstants.OUTDATED.
     *
     * @param {string} current Current status of the list of packages.
     * @param {string} packagestatus Status of one of the packages.
     * @return {string} New status for the list of packages;
     */
    CoreFilepoolProvider.prototype.determinePackagesStatus = function (current, packageStatus) {
        if (!current) {
            current = __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADABLE;
        }
        if (packageStatus === __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED) {
            // If 1 package is not downloaded the status of the whole list will always be not downloaded.
            return __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED;
        }
        else if (packageStatus === __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].DOWNLOADED && current === __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADABLE) {
            // If all packages are downloaded or not downloadable with at least 1 downloaded, status will be downloaded.
            return __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].DOWNLOADED;
        }
        else if (packageStatus === __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].DOWNLOADING &&
            (current === __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADABLE || current === __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].DOWNLOADED)) {
            // If all packages are downloading/downloaded/notdownloadable with at least 1 downloading, status will be downloading.
            return __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].DOWNLOADING;
        }
        else if (packageStatus === __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].OUTDATED && current !== __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED) {
            // If there are no packages notdownloaded and there is at least 1 outdated, status will be outdated.
            return __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].OUTDATED;
        }
        // Status remains the same.
        return current;
    };
    /**
     * Downloads a URL and update or add it to the pool.
     *
     * This uses the file system, you should always make sure that it is accessible before calling this method.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The file URL.
     * @param {any} [options] Extra options (revision, timemodified, isexternalfile, repositorytype).
     * @param {string} [filePath] Filepath to download the file to. If defined, no extension will be added.
     * @param {Function} [onProgress] Function to call on progress.
     * @param {CoreFilepoolFileEntry} [poolFileObject] When set, the object will be updated, a new entry will not be created.
     * @return {Promise<any>} Resolved with internal URL on success, rejected otherwise.
     */
    CoreFilepoolProvider.prototype.downloadForPoolByUrl = function (siteId, fileUrl, options, filePath, onProgress, poolFileObject) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var fileId = this.getFileIdByUrl(fileUrl), extension = this.mimeUtils.guessExtensionFromUrl(fileUrl), addExtension = typeof filePath == 'undefined', pathPromise = filePath ? filePath : this.getFilePath(siteId, fileId, extension);
        return Promise.resolve(pathPromise).then(function (filePath) {
            if (poolFileObject && poolFileObject.fileId !== fileId) {
                _this.logger.error('Invalid object to update passed');
                return Promise.reject(null);
            }
            var downloadId = _this.getFileDownloadId(fileUrl, filePath);
            if (_this.filePromises[siteId] && _this.filePromises[siteId][downloadId]) {
                // There's already a download ongoing for this file in this location, return the promise.
                return _this.filePromises[siteId][downloadId];
            }
            else if (!_this.filePromises[siteId]) {
                _this.filePromises[siteId] = {};
            }
            _this.filePromises[siteId][downloadId] = _this.sitesProvider.getSite(siteId).then(function (site) {
                if (!site.canDownloadFiles()) {
                    return Promise.reject(null);
                }
                return _this.wsProvider.downloadFile(fileUrl, filePath, addExtension, onProgress).then(function (fileEntry) {
                    var data = poolFileObject || {};
                    data.downloadTime = Date.now();
                    data.stale = 0;
                    data.url = fileUrl;
                    data.revision = options.revision;
                    data.timemodified = options.timemodified;
                    data.isexternalfile = options.isexternalfile ? 1 : 0;
                    data.repositorytype = options.repositorytype;
                    data.path = fileEntry.path;
                    data.extension = fileEntry.extension;
                    return _this.addFileToPool(siteId, fileId, data).then(function () {
                        return fileEntry.toURL();
                    });
                });
            }).finally(function () {
                // Download finished, delete the promise.
                delete _this.filePromises[siteId][downloadId];
            });
            return _this.filePromises[siteId][downloadId];
        });
    };
    /**
     * Download or prefetch several files into the filepool folder.
     *
     * @param {string} siteId The site ID.
     * @param {any[]} files Array of files to download.
     * @param {boolean} prefetch True if should prefetch the contents (queue), false if they should be downloaded right now.
     * @param {boolean} [ignoreStale] True if 'stale' should be ignored. Only if prefetch=false.
     * @param {string} [component] The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<any>} Resolved on success.
     */
    CoreFilepoolProvider.prototype.downloadOrPrefetchFiles = function (siteId, files, prefetch, ignoreStale, component, componentId) {
        var _this = this;
        var promises = [];
        // Download files.
        files.forEach(function (file) {
            var url = file.url || file.fileurl, timemodified = file.timemodified, options = {
                isexternalfile: file.isexternalfile,
                repositorytype: file.repositorytype
            };
            if (prefetch) {
                promises.push(_this.addToQueueByUrl(siteId, url, component, componentId, timemodified, undefined, undefined, 0, options));
            }
            else {
                promises.push(_this.downloadUrl(siteId, url, ignoreStale, component, componentId, timemodified, undefined, undefined, options));
            }
        });
        return this.utils.allPromises(promises);
    };
    /**
     * Downloads or prefetches a list of files as a "package".
     *
     * @param {string} siteId The site ID.
     * @param {any[]} fileList List of files to download.
     * @param {boolean} [prefetch] True if should prefetch the contents (queue), false if they should be downloaded right now.
     * @param {string} [component] The component to link the file to.
     * @param {string|number} [componentId]  An ID to use in conjunction with the component.
     * @param {string} [extra] Extra data to store for the package.
     * @param {string} [dirPath] Name of the directory where to store the files (inside filepool dir). If not defined, store
     *                           the files directly inside the filepool folder.
     * @param {Function} [onProgress] Function to call on progress.
     * @return {Promise<any>} Promise resolved when the package is downloaded.
     */
    CoreFilepoolProvider.prototype.downloadOrPrefetchPackage = function (siteId, fileList, prefetch, component, componentId, extra, dirPath, onProgress) {
        var _this = this;
        var packageId = this.getPackageId(component, componentId);
        var promise;
        if (this.packagesPromises[siteId] && this.packagesPromises[siteId][packageId]) {
            // There's already a download ongoing for this package, return the promise.
            return this.packagesPromises[siteId][packageId];
        }
        else if (!this.packagesPromises[siteId]) {
            this.packagesPromises[siteId] = {};
        }
        // Set package as downloading.
        promise = this.storePackageStatus(siteId, __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].DOWNLOADING, component, componentId).then(function () {
            var promises = [];
            var packageLoaded = 0;
            fileList.forEach(function (file) {
                var fileUrl = file.url || file.fileurl, options = {
                    isexternalfile: file.isexternalfile,
                    repositorytype: file.repositorytype
                };
                var path, promise, fileLoaded = 0, onFileProgress;
                if (onProgress) {
                    // There's a onProgress event, create a function to receive file download progress events.
                    onFileProgress = function (progress) {
                        if (progress && progress.loaded) {
                            // Add the new size loaded to the package loaded.
                            packageLoaded = packageLoaded + (progress.loaded - fileLoaded);
                            fileLoaded = progress.loaded;
                            onProgress({
                                packageDownload: true,
                                loaded: packageLoaded,
                                fileProgress: progress
                            });
                        }
                    };
                }
                if (dirPath) {
                    // Calculate the path to the file.
                    path = file.filename;
                    if (file.filepath !== '/') {
                        path = file.filepath.substr(1) + path;
                    }
                    path = _this.textUtils.concatenatePaths(dirPath, path);
                }
                if (prefetch) {
                    promise = _this.addToQueueByUrl(siteId, fileUrl, component, componentId, file.timemodified, path, undefined, 0, options);
                }
                else {
                    promise = _this.downloadUrl(siteId, fileUrl, false, component, componentId, file.timemodified, onFileProgress, path, options);
                }
                // Using undefined for success & fail will pass the success/failure to the parent promise.
                promises.push(promise);
            });
            return Promise.all(promises).then(function () {
                // Success prefetching, store package as downloaded.
                return _this.storePackageStatus(siteId, __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].DOWNLOADED, component, componentId, extra);
            }).catch(function () {
                // Error downloading, go back to previous status and reject the promise.
                return _this.setPackagePreviousStatus(siteId, component, componentId).then(function () {
                    return Promise.reject(null);
                });
            });
        }).finally(function () {
            // Download finished, delete the promise.
            delete _this.packagesPromises[siteId][packageId];
        });
        this.packagesPromises[siteId][packageId] = promise;
        return promise;
    };
    /**
     * Downloads a list of files.
     *
     * @param {string} siteId The site ID.
     * @param {any[]} fileList List of files to download.
     * @param {string} component The component to link the file to.
     * @param {string|number} [componentId] An ID to identify the download.
     * @param {string} [extra] Extra data to store for the package.
     * @param {string} [dirPath] Name of the directory where to store the files (inside filepool dir). If not defined, store
     *                           the files directly inside the filepool folder.
     * @param {Function} [onProgress] Function to call on progress.
     * @return {Promise<any>}  Promise resolved when all files are downloaded.
     */
    CoreFilepoolProvider.prototype.downloadPackage = function (siteId, fileList, component, componentId, extra, dirPath, onProgress) {
        return this.downloadOrPrefetchPackage(siteId, fileList, false, component, componentId, extra, dirPath, onProgress);
    };
    /**
     * Downloads a file on the spot.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The file URL.
     * @param {boolean} [ignoreStale] Whether 'stale' should be ignored.
     * @param {string} [component] The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {number} [timemodified=0] The time this file was modified. Can be used to check file state.
     * @param {string} [filePath] Filepath to download the file to. If not defined, download to the filepool folder.
     * @param {any} [options] Extra options (isexternalfile, repositorytype).
     * @return {Promise<any>} Resolved with internal URL on success, rejected otherwise.
     * @description
     * Downloads a file on the spot.
     *
     * This will also take care of adding the file to the pool if it's missing. However, please note that this will
     * not force a file to be re-downloaded if it is already part of the pool. You should mark a file as stale using
     * invalidateFileByUrl to trigger a download.
     */
    CoreFilepoolProvider.prototype.downloadUrl = function (siteId, fileUrl, ignoreStale, component, componentId, timemodified, onProgress, filePath, options) {
        var _this = this;
        if (timemodified === void 0) { timemodified = 0; }
        if (options === void 0) { options = {}; }
        var fileId, promise;
        if (this.fileProvider.isAvailable()) {
            return this.fixPluginfileURL(siteId, fileUrl).then(function (fixedUrl) {
                fileUrl = fixedUrl;
                options = Object.assign({}, options); // Create a copy to prevent modifying the original object.
                options.timemodified = timemodified || 0;
                options.revision = _this.getRevisionFromUrl(fileUrl);
                fileId = _this.getFileIdByUrl(fileUrl);
                return _this.hasFileInPool(siteId, fileId).then(function (fileObject) {
                    if (typeof fileObject === 'undefined') {
                        // We do not have the file, download and add to pool.
                        _this.notifyFileDownloading(siteId, fileId);
                        return _this.downloadForPoolByUrl(siteId, fileUrl, options, filePath, onProgress);
                    }
                    else if (_this.isFileOutdated(fileObject, options.revision, options.timemodified) &&
                        _this.appProvider.isOnline() && !ignoreStale) {
                        // The file is outdated, force the download and update it.
                        _this.notifyFileDownloading(siteId, fileId);
                        return _this.downloadForPoolByUrl(siteId, fileUrl, options, filePath, onProgress, fileObject);
                    }
                    // Everything is fine, return the file on disk.
                    if (filePath) {
                        promise = _this.getInternalUrlByPath(filePath);
                    }
                    else {
                        promise = _this.getInternalUrlById(siteId, fileId);
                    }
                    return promise.then(function (response) {
                        return response;
                    }, function () {
                        // The file was not found in the pool, weird.
                        _this.notifyFileDownloading(siteId, fileId);
                        return _this.downloadForPoolByUrl(siteId, fileUrl, options, filePath, onProgress, fileObject);
                    });
                }, function () {
                    // The file is not in the pool just yet.
                    _this.notifyFileDownloading(siteId, fileId);
                    return _this.downloadForPoolByUrl(siteId, fileUrl, options, filePath, onProgress);
                }).then(function (response) {
                    if (typeof component != 'undefined') {
                        _this.addFileLink(siteId, fileId, component, componentId);
                    }
                    _this.notifyFileDownloaded(siteId, fileId);
                    return response;
                }, function (err) {
                    _this.notifyFileDownloadError(siteId, fileId);
                    return Promise.reject(err);
                });
            });
        }
        else {
            return Promise.reject(null);
        }
    };
    /**
     * Fill Missing Extension In the File Object if needed.
     * This is to migrate from old versions.
     *
     * @param {CoreFilepoolFileEntry} fileObject File object to be migrated.
     * @param {string} siteId SiteID to get migrated.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreFilepoolProvider.prototype.fillExtensionInFile = function (entry, siteId) {
        var _this = this;
        if (typeof entry.extension != 'undefined') {
            // Already filled.
            return Promise.resolve();
        }
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            var extension = _this.mimeUtils.getFileExtension(entry.path);
            if (!extension) {
                // Files does not have extension. Invalidate file (stale = true).
                // Minor problem: file will remain in the filesystem once downloaded again.
                _this.logger.debug('Staled file with no extension ' + entry.fileId);
                return db.updateRecords(_this.FILES_TABLE, { stale: 1 }, { fileId: entry.fileId });
            }
            // File has extension. Save extension, and add extension to path.
            var fileId = entry.fileId;
            entry.fileId = _this.mimeUtils.removeExtension(fileId);
            entry.extension = extension;
            return db.updateRecords(_this.FILES_TABLE, entry, { fileId: fileId }).then(function () {
                if (entry.fileId == fileId) {
                    // File ID hasn't changed, we're done.
                    _this.logger.debug('Removed extesion ' + extension + ' from file ' + entry.fileId);
                    return;
                }
                // Now update the links.
                return db.updateRecords(_this.LINKS_TABLE, { fileId: entry.fileId }, { fileId: fileId });
            });
        });
    };
    /**
     * Fill Missing Extension In Files, used to migrate from previous file handling.
     * Reserved for core use, please do not call.
     *
     * @param {string} siteId SiteID to get migrated
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreFilepoolProvider.prototype.fillMissingExtensionInFiles = function (siteId) {
        var _this = this;
        this.logger.debug('Fill missing extensions in files of ' + siteId);
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            return db.getAllRecords(_this.FILES_TABLE).then(function (entries) {
                var promises = [];
                entries.forEach(function (entry) {
                    promises.push(_this.fillExtensionInFile(entry, siteId));
                });
                return Promise.all(promises);
            });
        });
    };
    /**
     * Fix a component ID to always be a Number if possible.
     *
     * @param {string|number} componentId The component ID.
     * @return {string|number} The normalised component ID. -1 when undefined was passed.
     */
    CoreFilepoolProvider.prototype.fixComponentId = function (componentId) {
        if (typeof componentId == 'number') {
            return componentId;
        }
        // Try to convert it to a number.
        var id = parseInt(componentId, 10);
        if (isNaN(id)) {
            // Not a number.
            if (typeof componentId == 'undefined' || componentId === null) {
                return -1;
            }
            else {
                return componentId;
            }
        }
        return id;
    };
    /**
     * Add the wstoken url and points to the correct script.
     *
     * @param {string} siteId  The site ID.
     * @param {string} fileUrl The file URL.
     * @return {Promise}       Resolved with fixed URL on success, rejected otherwise.
     */
    CoreFilepoolProvider.prototype.fixPluginfileURL = function (siteId, fileUrl) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.fixPluginfileURL(fileUrl);
        });
    };
    /**
     * Convenience function to get component files.
     *
     * @param {SQLiteDB} db Site's DB.
     * @param {string} component The component to get.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<any[]>} Promise resolved with the files.
     */
    CoreFilepoolProvider.prototype.getComponentFiles = function (db, component, componentId) {
        var conditions = {
            component: component,
            componentId: componentId || ''
        };
        return db.getRecords(this.LINKS_TABLE, conditions);
    };
    /**
     * Returns the local URL of a directory.
     *
     * @param {string} siteId  The site ID.
     * @param {string} fileUrl The file URL.
     * @return {Promise}       Resolved with the URL. Rejected otherwise.
     */
    CoreFilepoolProvider.prototype.getDirectoryUrlByUrl = function (siteId, fileUrl) {
        var _this = this;
        if (this.fileProvider.isAvailable()) {
            return this.fixPluginfileURL(siteId, fileUrl).then(function (fileUrl) {
                var fileId = _this.getFileIdByUrl(fileUrl), filePath = _this.getFilePath(siteId, fileId, ''); // No extension, the function will return a string.
                return _this.fileProvider.getDir(filePath).then(function (dirEntry) {
                    return dirEntry.toURL();
                });
            });
        }
        return Promise.reject(null);
    };
    /**
     * Get the ID of a file download. Used to keep track of filePromises.
     *
     * @param {string} fileUrl  The file URL.
     * @param {string} filePath The file destination path.
     * @return {string}         File download ID.
     */
    CoreFilepoolProvider.prototype.getFileDownloadId = function (fileUrl, filePath) {
        return __WEBPACK_IMPORTED_MODULE_16_ts_md5_dist_md5__["Md5"].hashAsciiStr(fileUrl + '###' + filePath);
    };
    /**
     * Get the name of the event used to notify download events (CoreEventsProvider).
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @return {string} Event name.
     */
    CoreFilepoolProvider.prototype.getFileEventName = function (siteId, fileId) {
        return 'mmFilepoolFile:' + siteId + ':' + fileId;
    };
    /**
     * Get the name of the event used to notify download events (CoreEventsProvider).
     *
     * @param {string} siteId  The site ID.
     * @param {string} fileUrl The absolute URL to the file.
     * @return {Promise}       Promise resolved with event name.
     */
    CoreFilepoolProvider.prototype.getFileEventNameByUrl = function (siteId, fileUrl) {
        var _this = this;
        return this.fixPluginfileURL(siteId, fileUrl).then(function (fileUrl) {
            var fileId = _this.getFileIdByUrl(fileUrl);
            return _this.getFileEventName(siteId, fileId);
        });
    };
    /**
     * Creates a unique ID based on a URL.
     *
     * This has a minimal handling of pluginfiles in order to generate a clean file ID which will not change if
     * pointing to the same pluginfile URL even if the token or extra attributes have changed.
     *
     * @param {string} fileUrl The absolute URL to the file.
     * @return {string} The file ID.
     */
    CoreFilepoolProvider.prototype.getFileIdByUrl = function (fileUrl) {
        var url = this.removeRevisionFromUrl(fileUrl), filename;
        // Decode URL.
        url = this.textUtils.decodeHTML(this.textUtils.decodeURIComponent(url));
        if (url.indexOf('/webservice/pluginfile') !== -1) {
            // Remove attributes that do not matter.
            this.urlAttributes.forEach(function (regex) {
                url = url.replace(regex, '');
            });
        }
        // Try to guess the filename the target file should have.
        // We want to keep the original file name so people can easily identify the files after the download.
        filename = this.guessFilenameFromUrl(url);
        return filename + '_' + __WEBPACK_IMPORTED_MODULE_16_ts_md5_dist_md5__["Md5"].hashAsciiStr('url:' + url);
    };
    /**
     * Get the links of a file.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @return {Promise<any[]>} Promise resolved with the links.
     */
    CoreFilepoolProvider.prototype.getFileLinks = function (siteId, fileId) {
        var _this = this;
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            return db.getRecords(_this.LINKS_TABLE, { fileId: fileId });
        });
    };
    /**
     * Get the path to a file. This does not check if the file exists or not.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @param {string} [extension] Previously calculated extension. Empty to not add any. Undefined to calculate it.
     * @return {string|Promise<string>} The path to the file relative to storage root.
     */
    CoreFilepoolProvider.prototype.getFilePath = function (siteId, fileId, extension) {
        var path = this.getFilepoolFolderPath(siteId) + '/' + fileId;
        if (typeof extension == 'undefined') {
            // We need the extension to be able to open files properly.
            return this.hasFileInPool(siteId, fileId).then(function (entry) {
                if (entry.extension) {
                    path += '.' + entry.extension;
                }
                return path;
            }).catch(function () {
                // If file not found, use the path without extension.
                return path;
            });
        }
        else {
            if (extension) {
                path += '.' + extension;
            }
            return path;
        }
    };
    /**
     * Get the path to a file from its URL. This does not check if the file exists or not.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The file URL.
     * @return {Promise<string>} Promise resolved with the path to the file relative to storage root.
     */
    CoreFilepoolProvider.prototype.getFilePathByUrl = function (siteId, fileUrl) {
        var _this = this;
        return this.fixPluginfileURL(siteId, fileUrl).then(function (fileUrl) {
            var fileId = _this.getFileIdByUrl(fileUrl);
            return _this.getFilePath(siteId, fileId);
        });
    };
    /**
     * Get site Filepool Folder Path
     *
     * @param {string} siteId The site ID.
     * @return {string} The root path to the filepool of the site.
     */
    CoreFilepoolProvider.prototype.getFilepoolFolderPath = function (siteId) {
        return this.fileProvider.getSiteFolder(siteId) + '/' + this.FOLDER;
    };
    /**
     * Get all the matching files from a component. Returns objects containing properties like path, extension and url.
     *
     * @param {string} siteId The site ID.
     * @param {string} component The component to get.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<any[]>} Promise resolved with the files on success.
     */
    CoreFilepoolProvider.prototype.getFilesByComponent = function (siteId, component, componentId) {
        var _this = this;
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            return _this.getComponentFiles(db, component, componentId).then(function (items) {
                var promises = [], files = [];
                items.forEach(function (item) {
                    promises.push(db.getRecord(_this.FILES_TABLE, { fileId: item.fileId }).then(function (fileEntry) {
                        if (!fileEntry) {
                            return;
                        }
                        files.push({
                            url: fileEntry.url,
                            path: fileEntry.path,
                            extension: fileEntry.extension,
                            revision: fileEntry.revision,
                            timemodified: fileEntry.timemodified
                        });
                    }).catch(function () {
                        // File not found, ignore error.
                    }));
                });
                return Promise.all(promises).then(function () {
                    return files;
                });
            });
        });
    };
    /**
     * Get the size of all the files from a component.
     *
     * @param {string} siteId The site ID.
     * @param {string} component    The component to get.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<number>} Promise resolved with the size on success.
     */
    CoreFilepoolProvider.prototype.getFilesSizeByComponent = function (siteId, component, componentId) {
        var _this = this;
        return this.getFilesByComponent(siteId, component, componentId).then(function (files) {
            var promises = [];
            var size = 0;
            files.forEach(function (file) {
                promises.push(_this.fileProvider.getFileSize(file.path).then(function (fs) {
                    size += fs;
                }).catch(function () {
                    // Ignore failures, maybe some file was deleted.
                }));
            });
            return Promise.all(promises).then(function () {
                return size;
            });
        });
    };
    /**
     * Returns the file state: mmCoreDownloaded, mmCoreDownloading, mmCoreNotDownloaded or mmCoreOutdated.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl File URL.
     * @param {number} [timemodified=0] The time this file was modified.
     * @param {string} [filePath] Filepath to download the file to. If defined, no extension will be added.
     * @return {Promise<string>} Promise resolved with the file state.
     */
    CoreFilepoolProvider.prototype.getFileStateByUrl = function (siteId, fileUrl, timemodified, filePath) {
        var _this = this;
        if (timemodified === void 0) { timemodified = 0; }
        var fileId, revision;
        return this.fixPluginfileURL(siteId, fileUrl).then(function (fixedUrl) {
            fileUrl = fixedUrl;
            revision = _this.getRevisionFromUrl(fileUrl);
            fileId = _this.getFileIdByUrl(fileUrl);
            // Check if the file is in queue (waiting to be downloaded).
            return _this.hasFileInQueue(siteId, fileId).then(function () {
                return __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].DOWNLOADING;
            }).catch(function () {
                // Check if the file is being downloaded right now.
                var extension = _this.mimeUtils.guessExtensionFromUrl(fileUrl), path = filePath ? filePath : _this.getFilePath(siteId, fileId, extension);
                return Promise.resolve(path).then(function (filePath) {
                    var downloadId = _this.getFileDownloadId(fileUrl, filePath);
                    if (_this.filePromises[siteId] && _this.filePromises[siteId][downloadId]) {
                        return __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].DOWNLOADING;
                    }
                    // File is not being downloaded. Check if it's downloaded and if it's outdated.
                    return _this.hasFileInPool(siteId, fileId).then(function (entry) {
                        if (_this.isFileOutdated(entry, revision, timemodified)) {
                            return __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].OUTDATED;
                        }
                        else {
                            return __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].DOWNLOADED;
                        }
                    }).catch(function () {
                        return __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED;
                    });
                });
            });
        });
    };
    /**
     * Returns an absolute URL to access the file URL.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The absolute URL to the file.
     * @param {string} [mode=url] The type of URL to return. Accepts 'url' or 'src'.
     * @param {string} component The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {number} [timemodified=0] The time this file was modified.
     * @param {boolean} [checkSize=true] True if we shouldn't download files if their size is big, false otherwise.
     * @param {boolean} [downloadUnknown] True to download file in WiFi if their size is unknown, false otherwise.
     *                                    Ignored if checkSize=false.
     * @param {any} [options] Extra options (isexternalfile, repositorytype).
     * @return {Promise<string>} Resolved with the URL to use.
     * @description
     * This will return a URL pointing to the content of the requested URL.
     *
     * This handles the queue and validity of the file. If there is a local file and it's valid, return the local URL.
     * If the file isn't downloaded or it's outdated, return the online URL and add it to the queue to be downloaded later.
     */
    CoreFilepoolProvider.prototype.getFileUrlByUrl = function (siteId, fileUrl, component, componentId, mode, timemodified, checkSize, downloadUnknown, options) {
        var _this = this;
        if (mode === void 0) { mode = 'url'; }
        if (timemodified === void 0) { timemodified = 0; }
        if (checkSize === void 0) { checkSize = true; }
        if (options === void 0) { options = {}; }
        var fileId, revision;
        var addToQueue = function (fileUrl) {
            // Add the file to queue if needed and ignore errors.
            _this.addToQueueIfNeeded(siteId, fileUrl, component, componentId, timemodified, checkSize, downloadUnknown, options).catch(function () {
                // Ignore errors.
            });
        };
        return this.fixPluginfileURL(siteId, fileUrl).then(function (fixedUrl) {
            fileUrl = fixedUrl;
            revision = _this.getRevisionFromUrl(fileUrl);
            fileId = _this.getFileIdByUrl(fileUrl);
            return _this.hasFileInPool(siteId, fileId).then(function (entry) {
                var response;
                if (typeof entry === 'undefined') {
                    // We do not have the file, add it to the queue, and return real URL.
                    addToQueue(fileUrl);
                    response = fileUrl;
                }
                else if (_this.isFileOutdated(entry, revision, timemodified) && _this.appProvider.isOnline()) {
                    // The file is outdated, we add to the queue and return real URL.
                    addToQueue(fileUrl);
                    response = fileUrl;
                }
                else {
                    // We found the file entry, now look for the file on disk.
                    if (mode === 'src') {
                        response = _this.getInternalSrcById(siteId, fileId);
                    }
                    else {
                        response = _this.getInternalUrlById(siteId, fileId);
                    }
                    response = response.then(function (internalUrl) {
                        // The file is on disk.
                        return internalUrl;
                    }).catch(function () {
                        // We could not retrieve the file, delete the entries associated with that ID.
                        _this.logger.debug('File ' + fileId + ' not found on disk');
                        _this.removeFileById(siteId, fileId);
                        addToQueue(fileUrl);
                        if (_this.appProvider.isOnline()) {
                            // We still have a chance to serve the right content.
                            return fileUrl;
                        }
                        return Promise.reject(null);
                    });
                }
                return response;
            }, function () {
                // We do not have the file in store yet. Add to queue and return the fixed URL.
                addToQueue(fileUrl);
                return fileUrl;
            });
        });
    };
    /**
     * Returns the internal SRC of a file.
     *
     * The returned URL from this method is typically used with IMG tags.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @return {Promise<string>} Resolved with the internal URL. Rejected otherwise.
     */
    CoreFilepoolProvider.prototype.getInternalSrcById = function (siteId, fileId) {
        var _this = this;
        if (this.fileProvider.isAvailable()) {
            return Promise.resolve(this.getFilePath(siteId, fileId)).then(function (path) {
                return _this.fileProvider.getFile(path).then(function (fileEntry) {
                    // We use toInternalURL so images are loaded in iOS8 using img HTML tags.
                    return _this.fileProvider.getInternalURL(fileEntry);
                });
            });
        }
        return Promise.reject(null);
    };
    /**
     * Returns the local URL of a file.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @return {Promise<string>} Resolved with the URL. Rejected otherwise.
     */
    CoreFilepoolProvider.prototype.getInternalUrlById = function (siteId, fileId) {
        var _this = this;
        if (this.fileProvider.isAvailable()) {
            return Promise.resolve(this.getFilePath(siteId, fileId)).then(function (path) {
                return _this.fileProvider.getFile(path).then(function (fileEntry) {
                    return fileEntry.toURL();
                });
            });
        }
        return Promise.reject(null);
    };
    /**
     * Returns the local URL of a file.
     *
     * @param {string} filePath The file path.
     * @return {Promise<string>} Resolved with the URL.
     */
    CoreFilepoolProvider.prototype.getInternalUrlByPath = function (filePath) {
        if (this.fileProvider.isAvailable()) {
            return this.fileProvider.getFile(filePath).then(function (fileEntry) {
                return fileEntry.toURL();
            });
        }
        return Promise.reject(null);
    };
    /**
     * Returns the local URL of a file.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The file URL.
     * @return {Promise<string>} Resolved with the URL. Rejected otherwise.
     */
    CoreFilepoolProvider.prototype.getInternalUrlByUrl = function (siteId, fileUrl) {
        var _this = this;
        if (this.fileProvider.isAvailable()) {
            return this.fixPluginfileURL(siteId, fileUrl).then(function (fileUrl) {
                var fileId = _this.getFileIdByUrl(fileUrl);
                return _this.getInternalUrlById(siteId, fileId);
            });
        }
        return Promise.reject(null);
    };
    /**
     * Get the data stored for a package.
     *
     * @param {string} siteId Site ID.
     * @param {string} component Package's component.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<CoreFilepoolPackageEntry>} Promise resolved with the data.
     */
    CoreFilepoolProvider.prototype.getPackageData = function (siteId, component, componentId) {
        var _this = this;
        componentId = this.fixComponentId(componentId);
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var packageId = _this.getPackageId(component, componentId);
            return site.getDb().getRecord(_this.PACKAGES_TABLE, { id: packageId });
        });
    };
    /**
     * Creates the name for a package directory (hash).
     *
     * @param {string} url An URL to identify the package.
     * @return {string} The directory name.
     */
    CoreFilepoolProvider.prototype.getPackageDirNameByUrl = function (url) {
        var candidate, extension = '';
        url = this.removeRevisionFromUrl(url);
        if (url.indexOf('/webservice/pluginfile') !== -1) {
            // Remove attributes that do not matter.
            this.urlAttributes.forEach(function (regex) {
                url = url.replace(regex, '');
            });
            // Guess the extension of the URL. This is for backwards compatibility.
            candidate = this.mimeUtils.guessExtensionFromUrl(url);
            if (candidate && candidate !== 'php') {
                extension = '.' + candidate;
            }
        }
        return __WEBPACK_IMPORTED_MODULE_16_ts_md5_dist_md5__["Md5"].hashAsciiStr('url:' + url) + extension;
    };
    /**
     * Get the path to a directory to store a package files. This does not check if the file exists or not.
     *
     * @param {string} siteId The site ID.
     * @param {string} url An URL to identify the package.
     * @return {Promise<string>} Promise resolved with the path of the package.
     */
    CoreFilepoolProvider.prototype.getPackageDirPathByUrl = function (siteId, url) {
        var _this = this;
        return this.fixPluginfileURL(siteId, url).then(function (fixedUrl) {
            var dirName = _this.getPackageDirNameByUrl(fixedUrl);
            return _this.getFilePath(siteId, dirName, '');
        });
    };
    /**
     * Returns the local URL of a package directory.
     *
     * @param {string} siteId The site ID.
     * @param {string} url An URL to identify the package.
     * @return {Promise<string>} Resolved with the URL.
     */
    CoreFilepoolProvider.prototype.getPackageDirUrlByUrl = function (siteId, url) {
        var _this = this;
        if (this.fileProvider.isAvailable()) {
            return this.fixPluginfileURL(siteId, url).then(function (fixedUrl) {
                var dirName = _this.getPackageDirNameByUrl(fixedUrl), dirPath = _this.getFilePath(siteId, dirName, ''); // No extension, the function will return a string.
                return _this.fileProvider.getDir(dirPath).then(function (dirEntry) {
                    return dirEntry.toURL();
                });
            });
        }
        return Promise.reject(null);
    };
    /**
     * Get a download promise. If the promise is not set, return undefined.
     *
     * @param {string} siteId Site ID.
     * @param {string} component The component of the package.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<any>} Download promise or undefined.
     */
    CoreFilepoolProvider.prototype.getPackageDownloadPromise = function (siteId, component, componentId) {
        var packageId = this.getPackageId(component, componentId);
        if (this.packagesPromises[siteId] && this.packagesPromises[siteId][packageId]) {
            return this.packagesPromises[siteId][packageId];
        }
    };
    /**
     * Get a package extra data.
     *
     * @param {string} siteId Site ID.
     * @param {string} component Package's component.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<string>} Promise resolved with the extra data.
     */
    CoreFilepoolProvider.prototype.getPackageExtra = function (siteId, component, componentId) {
        return this.getPackageData(siteId, component, componentId).then(function (entry) {
            return entry.extra;
        });
    };
    /**
     * Get the ID of a package.
     *
     * @param {string} component Package's component.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {string} Package ID.
     */
    CoreFilepoolProvider.prototype.getPackageId = function (component, componentId) {
        return __WEBPACK_IMPORTED_MODULE_16_ts_md5_dist_md5__["Md5"].hashAsciiStr(component + '#' + this.fixComponentId(componentId));
    };
    /**
     * Get a package previous status.
     *
     * @param {string} siteId Site ID.
     * @param {string} component Package's component.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<string>} Promise resolved with the status.
     */
    CoreFilepoolProvider.prototype.getPackagePreviousStatus = function (siteId, component, componentId) {
        return this.getPackageData(siteId, component, componentId).then(function (entry) {
            return entry.previous || __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED;
        }).catch(function () {
            return __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED;
        });
    };
    /**
     * Get a package status.
     *
     * @param {string} siteId Site ID.
     * @param {string} component Package's component.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<string>} Promise resolved with the status.
     */
    CoreFilepoolProvider.prototype.getPackageStatus = function (siteId, component, componentId) {
        return this.getPackageData(siteId, component, componentId).then(function (entry) {
            return entry.status || __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED;
        }).catch(function () {
            return __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED;
        });
    };
    /**
     * Return the array of arguments of the pluginfile url.
     *
     * @param {string} url URL to get the args.
     * @return {string[]} The args found, undefined if not a pluginfile.
     */
    CoreFilepoolProvider.prototype.getPluginFileArgs = function (url) {
        if (!this.urlUtils.isPluginFileUrl(url)) {
            // Not pluginfile, return.
            return;
        }
        var relativePath = url.substr(url.indexOf('/pluginfile.php') + 16), args = relativePath.split('/');
        if (args.length < 3) {
            // To be a plugin file it should have at least contextId, Component and Filearea.
            return;
        }
        return args;
    };
    /**
     * Get the deferred object for a file in the queue.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @param {boolean} [create=true] True if it should create a new deferred if it doesn't exist.
     * @param {Function} [onProgress] Function to call on progress.
     * @return {any} Deferred.
     */
    CoreFilepoolProvider.prototype.getQueueDeferred = function (siteId, fileId, create, onProgress) {
        if (create === void 0) { create = true; }
        if (!this.queueDeferreds[siteId]) {
            if (!create) {
                return;
            }
            this.queueDeferreds[siteId] = {};
        }
        if (!this.queueDeferreds[siteId][fileId]) {
            if (!create) {
                return;
            }
            this.queueDeferreds[siteId][fileId] = this.utils.promiseDefer();
        }
        if (onProgress) {
            this.queueDeferreds[siteId][fileId].onProgress = onProgress;
        }
        return this.queueDeferreds[siteId][fileId];
    };
    /**
     * Get the on progress for a file in the queue.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @return {Function} On progress function, undefined if not found.
     */
    CoreFilepoolProvider.prototype.getQueueOnProgress = function (siteId, fileId) {
        var deferred = this.getQueueDeferred(siteId, fileId, false);
        if (deferred) {
            return deferred.onProgress;
        }
    };
    /**
     * Get the promise for a file in the queue.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @param {boolean} [create=true] True if it should create a new promise if it doesn't exist.
     * @param {Function} [onProgress] Function to call on progress.
     * @return {Promise<any>} Promise.
     */
    CoreFilepoolProvider.prototype.getQueuePromise = function (siteId, fileId, create, onProgress) {
        if (create === void 0) { create = true; }
        return this.getQueueDeferred(siteId, fileId, create, onProgress).promise;
    };
    /**
     * Get a revision number from a list of files (highest revision).
     *
     * @param {any[]} files Package files.
     * @return {number} Highest revision.
     */
    CoreFilepoolProvider.prototype.getRevisionFromFileList = function (files) {
        var _this = this;
        var revision = 0;
        files.forEach(function (file) {
            if (file.url || file.fileurl) {
                var r = _this.getRevisionFromUrl(file.url || file.fileurl);
                if (r > revision) {
                    revision = r;
                }
            }
        });
        return revision;
    };
    /**
     * Get the revision number from a file URL.
     *
     * @param {string} url URL to get the revision number.
     * @return {number} Revision number.
     */
    CoreFilepoolProvider.prototype.getRevisionFromUrl = function (url) {
        var args = this.getPluginFileArgs(url);
        if (!args) {
            // Not a pluginfile, no revision will be found.
            return 0;
        }
        var revisionRegex = this.pluginFileDelegate.getComponentRevisionRegExp(args);
        if (!revisionRegex) {
            return 0;
        }
        var matches = url.match(revisionRegex);
        if (matches && typeof matches[1] != 'undefined') {
            return parseInt(matches[1], 10);
        }
        return 0;
    };
    /**
     * Returns an absolute URL to use in IMG tags.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The absolute URL to the file.
     * @param {string} [mode=url] The type of URL to return. Accepts 'url' or 'src'.
     * @param {string} component The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {number} [timemodified=0] The time this file was modified.
     * @param {boolean} [checkSize=true] True if we shouldn't download files if their size is big, false otherwise.
     * @param {boolean} [downloadUnknown] True to download file in WiFi if their size is unknown, false otherwise.
     *                                    Ignored if checkSize=false.
     * @param {any} [options] Extra options (isexternalfile, repositorytype).
     * @return {Promise<string>} Resolved with the URL to use.
     * @description
     * This will return a URL pointing to the content of the requested URL.
     * The URL returned is compatible to use with IMG tags.
     */
    CoreFilepoolProvider.prototype.getSrcByUrl = function (siteId, fileUrl, component, componentId, timemodified, checkSize, downloadUnknown, options) {
        if (timemodified === void 0) { timemodified = 0; }
        if (checkSize === void 0) { checkSize = true; }
        if (options === void 0) { options = {}; }
        return this.getFileUrlByUrl(siteId, fileUrl, component, componentId, 'src', timemodified, checkSize, downloadUnknown, options);
    };
    /**
     * Get time modified from a list of files.
     *
     * @param {any[]} files List of files.
     * @return {number} Time modified.
     */
    CoreFilepoolProvider.prototype.getTimemodifiedFromFileList = function (files) {
        var timemodified = 0;
        files.forEach(function (file) {
            if (file.timemodified > timemodified) {
                timemodified = file.timemodified;
            }
        });
        return timemodified;
    };
    /**
     * Returns an absolute URL to access the file.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The absolute URL to the file.
     * @param {string} [mode=url] The type of URL to return. Accepts 'url' or 'src'.
     * @param {string} component The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {number} [timemodified=0] The time this file was modified.
     * @param {boolean} [checkSize=true] True if we shouldn't download files if their size is big, false otherwise.
     * @param {boolean} [downloadUnknown] True to download file in WiFi if their size is unknown, false otherwise.
     *                                    Ignored if checkSize=false.
     * @param {any} [options] Extra options (isexternalfile, repositorytype).
     * @return {Promise<string>} Resolved with the URL to use.
     * @description
     * This will return a URL pointing to the content of the requested URL.
     * The URL returned is compatible to use with a local browser.
     */
    CoreFilepoolProvider.prototype.getUrlByUrl = function (siteId, fileUrl, component, componentId, timemodified, checkSize, downloadUnknown, options) {
        if (timemodified === void 0) { timemodified = 0; }
        if (checkSize === void 0) { checkSize = true; }
        if (options === void 0) { options = {}; }
        return this.getFileUrlByUrl(siteId, fileUrl, component, componentId, 'url', timemodified, checkSize, downloadUnknown, options);
    };
    /**
     * Guess the filename of a file from its URL. This is very weak and unreliable.
     *
     * @param {string} fileUrl The file URL.
     * @return {string}        The filename treated so it doesn't have any special character.
     */
    CoreFilepoolProvider.prototype.guessFilenameFromUrl = function (fileUrl) {
        var filename = '';
        if (fileUrl.indexOf('/webservice/pluginfile') !== -1) {
            // It's a pluginfile URL. Search for the 'file' param to extract the name.
            var params = this.urlUtils.extractUrlParams(fileUrl);
            if (params.file) {
                filename = params.file.substr(params.file.lastIndexOf('/') + 1);
            }
            else {
                // 'file' param not found. Extract what's after the last '/' without params.
                filename = this.urlUtils.getLastFileWithoutParams(fileUrl);
            }
        }
        else if (this.urlUtils.isGravatarUrl(fileUrl)) {
            // Extract gravatar ID.
            filename = 'gravatar_' + this.urlUtils.getLastFileWithoutParams(fileUrl);
        }
        else if (this.urlUtils.isThemeImageUrl(fileUrl)) {
            // Extract user ID.
            var matches = fileUrl.match(/\/core\/([^\/]*)\//);
            if (matches && matches[1]) {
                filename = matches[1];
            }
            // Attach a constant and the image type.
            filename = 'default_' + filename + '_' + this.urlUtils.getLastFileWithoutParams(fileUrl);
        }
        else {
            // Another URL. Just get what's after the last /.
            filename = this.urlUtils.getLastFileWithoutParams(fileUrl);
        }
        // Remove the extension from the filename.
        filename = this.mimeUtils.removeExtension(filename);
        return this.textUtils.removeSpecialCharactersForFiles(filename);
    };
    /**
     * Check if the file is already in the pool. This does not check if the file is on the disk.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The file URL.
     * @return {Promise<CoreFilepoolFileEntry>} Resolved with file object from DB on success, rejected otherwise.
     */
    CoreFilepoolProvider.prototype.hasFileInPool = function (siteId, fileId) {
        var _this = this;
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            return db.getRecord(_this.FILES_TABLE, { fileId: fileId }).then(function (entry) {
                if (typeof entry === 'undefined') {
                    return Promise.reject(null);
                }
                return entry;
            });
        });
    };
    /**
     * Check if the file is in the queue.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The file URL.
     * @return {Promise} Resolved with file object from DB on success, rejected otherwise.
     */
    CoreFilepoolProvider.prototype.hasFileInQueue = function (siteId, fileId) {
        return this.appDB.getRecord(this.QUEUE_TABLE, { siteId: siteId, fileId: fileId }).then(function (entry) {
            if (typeof entry === 'undefined') {
                return Promise.reject(null);
            }
            // Convert the links to an object.
            entry.links = JSON.parse(entry.links);
            return entry;
        });
    };
    /**
     * Invalidate all the files in a site.
     *
     * @param {string} siteId The site ID.
     * @param {boolean} [onlyUnknown=true] True to only invalidate files from external repos or without revision/timemodified.
     *                                     It is advised to set it to true to reduce the performance and data usage of the app.
     * @return {Promise<any>} Resolved on success.
     */
    CoreFilepoolProvider.prototype.invalidateAllFiles = function (siteId, onlyUnknown) {
        var _this = this;
        if (onlyUnknown === void 0) { onlyUnknown = true; }
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            var where, whereParams;
            if (onlyUnknown) {
                where = 'isexternalfile = ? OR (revision < ? AND timemodified = ?)';
                whereParams = [0, 1, 0];
            }
            return db.updateRecordsWhere(_this.FILES_TABLE, { stale: 1 }, where, whereParams);
        });
    };
    /**
     * Invalidate a file by URL.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The file URL.
     * @return {Promise<any>} Resolved on success.
     * @description
     * Invalidates a file by marking it stale. It will not be added to the queue automatically, but the next time this file
     * is requested it will be added to the queue.
     * You can manully call addToQueueByUrl to add this file to the queue immediately.
     * Please note that, if a file is stale, the user will be presented the stale file if there is no network access.
     */
    CoreFilepoolProvider.prototype.invalidateFileByUrl = function (siteId, fileUrl) {
        var _this = this;
        return this.fixPluginfileURL(siteId, fileUrl).then(function (fileUrl) {
            var fileId = _this.getFileIdByUrl(fileUrl);
            return _this.sitesProvider.getSiteDb(siteId).then(function (db) {
                return db.updateRecords(_this.FILES_TABLE, { stale: 1 }, { fileId: fileId });
            });
        });
    };
    /**
     * Invalidate all the matching files from a component.
     *
     * @param {string} siteId The site ID.
     * @param {string} component The component to invalidate.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {boolean} [onlyUnknown=true] True to only invalidate files from external repos or without revision/timemodified.
     *                                     It is advised to set it to true to reduce the performance and data usage of the app.
     * @return {Promise<any>} Resolved when done.
     */
    CoreFilepoolProvider.prototype.invalidateFilesByComponent = function (siteId, component, componentId, onlyUnknown) {
        var _this = this;
        if (onlyUnknown === void 0) { onlyUnknown = true; }
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            return _this.getComponentFiles(db, component, componentId).then(function (items) {
                var fileIds = items.map(function (item) {
                    return item.fileId;
                }), whereAndParams = db.getInOrEqual(fileIds);
                if (onlyUnknown) {
                    whereAndParams[0] += ' AND (isexternalfile = ? OR (revision < ? AND timemodified = ?))';
                    whereAndParams[1] = whereAndParams[1].params.concat([0, 1, 0]);
                }
                return db.updateRecordsWhere(_this.FILES_TABLE, { stale: 1 }, whereAndParams[0], whereAndParams[1]);
            });
        });
    };
    /**
     * Check if a file is downloading.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl File URL.
     * @param {Promise<any>} Promise resolved if file is downloading, rejected otherwise.
     */
    CoreFilepoolProvider.prototype.isFileDownloadingByUrl = function (siteId, fileUrl) {
        var _this = this;
        return this.fixPluginfileURL(siteId, fileUrl).then(function (fileUrl) {
            var fileId = _this.getFileIdByUrl(fileUrl);
            return _this.hasFileInQueue(siteId, fileId);
        });
    };
    /**
     * Check if a file is outdated.
     *
     * @param {CoreFilepoolFileEntry} entry Filepool entry.
     * @param {number} [revision]  File revision number.
     * @param {number} [timemodified] The time this file was modified.
     * @param {boolean} Whether the file is outdated.
     */
    CoreFilepoolProvider.prototype.isFileOutdated = function (entry, revision, timemodified) {
        return !!entry.stale || revision > entry.revision || timemodified > entry.timemodified;
    };
    /**
     * Check if cannot determine if a file has been updated.
     *
     * @param {CoreFilepoolFileEntry} entry Filepool entry.
     * @return {boolean} Whether it cannot determine updates.
     */
    CoreFilepoolProvider.prototype.isFileUpdateUnknown = function (entry) {
        return !!entry.isexternalfile || (entry.revision < 1 && !entry.timemodified);
    };
    /**
     * Notify a file has been deleted.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     */
    CoreFilepoolProvider.prototype.notifyFileDeleted = function (siteId, fileId) {
        this.eventsProvider.trigger(this.getFileEventName(siteId, fileId), { action: 'deleted' });
    };
    /**
     * Notify a file has been downloaded.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     */
    CoreFilepoolProvider.prototype.notifyFileDownloaded = function (siteId, fileId) {
        this.eventsProvider.trigger(this.getFileEventName(siteId, fileId), { action: 'download', success: true });
    };
    /**
     * Notify error occurred while downloading a file.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     */
    CoreFilepoolProvider.prototype.notifyFileDownloadError = function (siteId, fileId) {
        this.eventsProvider.trigger(this.getFileEventName(siteId, fileId), { action: 'download', success: false });
    };
    /**
     * Notify a file starts being downloaded or added to queue.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     */
    CoreFilepoolProvider.prototype.notifyFileDownloading = function (siteId, fileId) {
        this.eventsProvider.trigger(this.getFileEventName(siteId, fileId), { action: 'downloading' });
    };
    /**
     * Notify a file has been outdated.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     */
    CoreFilepoolProvider.prototype.notifyFileOutdated = function (siteId, fileId) {
        this.eventsProvider.trigger(this.getFileEventName(siteId, fileId), { action: 'outdated' });
    };
    /**
     * Prefetches a list of files.
     *
     * @param {string} siteId The site ID.
     * @param {any[]} fileList List of files to download.
     * @param {string} component The component to link the file to.
     * @param {string|number} [componentId] An ID to identify the download.
     * @param {string} [extra] Extra data to store for the package.
     * @param {string} [dirPath] Name of the directory where to store the files (inside filepool dir). If not defined, store
     *                           the files directly inside the filepool folder.
     * @param {Function} [onProgress] Function to call on progress.
     * @return {Promise<any>}  Promise resolved when all files are downloaded.
     */
    CoreFilepoolProvider.prototype.prefetchPackage = function (siteId, fileList, component, componentId, extra, dirPath, onProgress) {
        return this.downloadOrPrefetchPackage(siteId, fileList, true, component, componentId, extra, dirPath, onProgress);
    };
    /**
     * Process the queue.
     *
     * @description
     * This loops over itself to keep on processing the queue in the background.
     * The queue process is site agnostic.
     */
    CoreFilepoolProvider.prototype.processQueue = function () {
        var _this = this;
        var promise;
        if (this.queueState !== this.QUEUE_RUNNING) {
            // Silently ignore, the queue is on pause.
            promise = Promise.reject(this.ERR_QUEUE_ON_PAUSE);
        }
        else if (!this.fileProvider.isAvailable() || !this.appProvider.isOnline()) {
            promise = Promise.reject(this.ERR_FS_OR_NETWORK_UNAVAILABLE);
        }
        else {
            promise = this.processImportantQueueItem();
        }
        promise.then(function () {
            // All good, we schedule next execution.
            setTimeout(function () {
                _this.processQueue();
            }, _this.QUEUE_PROCESS_INTERVAL);
        }, function (error) {
            // We had an error, in which case we pause the processing.
            if (error === _this.ERR_FS_OR_NETWORK_UNAVAILABLE) {
                _this.logger.debug('Filesysem or network unavailable, pausing queue processing.');
            }
            else if (error === _this.ERR_QUEUE_IS_EMPTY) {
                _this.logger.debug('Queue is empty, pausing queue processing.');
            }
            _this.queueState = _this.QUEUE_PAUSED;
        });
    };
    /**
     * Process the most important queue item.
     *
     * @return {Promise} Resolved on success. Rejected on failure.
     */
    CoreFilepoolProvider.prototype.processImportantQueueItem = function () {
        var _this = this;
        return this.appDB.getRecords(this.QUEUE_TABLE, undefined, 'priority DESC, added ASC', undefined, 0, 1).then(function (items) {
            var item = items.pop();
            if (!item) {
                return Promise.reject(_this.ERR_QUEUE_IS_EMPTY);
            }
            // Convert the links to an object.
            item.links = JSON.parse(item.links);
            return _this.processQueueItem(item);
        }, function () {
            return Promise.reject(_this.ERR_QUEUE_IS_EMPTY);
        });
    };
    /**
     * Process a queue item.
     *
     * @param {CoreFilepoolQueueEntry} item The object from the queue store.
     * @return {Promise<any>} Resolved on success. Rejected on failure.
     */
    CoreFilepoolProvider.prototype.processQueueItem = function (item) {
        var _this = this;
        // Cast optional fields to undefined instead of null.
        var siteId = item.siteId, fileId = item.fileId, fileUrl = item.url, options = {
            revision: item.revision || undefined,
            timemodified: item.timemodified || undefined,
            isexternalfile: item.isexternalfile || undefined,
            repositorytype: item.repositorytype || undefined
        }, filePath = item.path || undefined, links = item.links || [];
        this.logger.debug('Processing queue item: ' + siteId + ', ' + fileId);
        // Check if the file is already in pool.
        return this.hasFileInPool(siteId, fileId).catch(function () {
            // File not in pool.
        }).then(function (entry) {
            if (entry && !_this.isFileOutdated(entry, options.revision, options.timemodified)) {
                // We have the file, it is not stale, we can update links and remove from queue.
                _this.logger.debug('Queued file already in store, ignoring...');
                _this.addFileLinks(siteId, fileId, links);
                _this.removeFromQueue(siteId, fileId).finally(function () {
                    _this.treatQueueDeferred(siteId, fileId, true);
                });
                _this.notifyFileDownloaded(siteId, fileId);
                return;
            }
            // The file does not exist, or is stale, ... download it.
            var onProgress = _this.getQueueOnProgress(siteId, fileId);
            return _this.downloadForPoolByUrl(siteId, fileUrl, options, filePath, onProgress, entry).then(function () {
                // Success, we add links and remove from queue.
                _this.addFileLinks(siteId, fileId, links);
                _this.treatQueueDeferred(siteId, fileId, true);
                _this.notifyFileDownloaded(siteId, fileId);
                // Wait for the item to be removed from queue before resolving the promise.
                // If the item could not be removed from queue we still resolve the promise.
                return _this.removeFromQueue(siteId, fileId).catch(function () {
                    // Ignore errors.
                });
            }, function (errorObject) {
                // Whoops, we have an error...
                var dropFromQueue = false;
                if (errorObject && errorObject.source === fileUrl) {
                    // This is most likely a FileTransfer error.
                    if (errorObject.code === 1) {
                        // The file was not found, most likely a 404, we remove from queue.
                        dropFromQueue = true;
                    }
                    else if (errorObject.code === 2) {
                        // The URL is invalid, we drop the file from the queue.
                        dropFromQueue = true;
                    }
                    else if (errorObject.code === 3) {
                        // If there was an HTTP status, then let's remove from the queue.
                        dropFromQueue = true;
                    }
                    else if (errorObject.code === 4) {
                        // The transfer was aborted, we will keep the file in queue.
                    }
                    else if (errorObject.code === 5) {
                        // We have the latest version of the file, HTTP 304 status.
                        dropFromQueue = true;
                    }
                    else {
                        // Unknown error, let's remove the file from the queue to avoi locking down the queue.
                        dropFromQueue = true;
                    }
                }
                else {
                    dropFromQueue = true;
                }
                if (dropFromQueue) {
                    _this.logger.debug('Item dropped from queue due to error: ' + fileUrl, errorObject);
                    return _this.removeFromQueue(siteId, fileId).catch(function () {
                        // Consider this as a silent error, never reject the promise here.
                    }).then(function () {
                        _this.treatQueueDeferred(siteId, fileId, false);
                        _this.notifyFileDownloadError(siteId, fileId);
                    });
                }
                else {
                    // We considered the file as legit but did not get it, failure.
                    _this.treatQueueDeferred(siteId, fileId, false);
                    _this.notifyFileDownloadError(siteId, fileId);
                    return Promise.reject(errorObject);
                }
            });
        });
    };
    /**
     * Remove a file from the queue.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @return {Promise<any>} Resolved on success. Rejected on failure. It is advised to silently ignore failures.
     */
    CoreFilepoolProvider.prototype.removeFromQueue = function (siteId, fileId) {
        return this.appDB.deleteRecords(this.QUEUE_TABLE, { siteId: siteId, fileId: fileId });
    };
    /**
     * Remove a file from the pool.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @return {Promise<any>} Resolved on success.
     */
    CoreFilepoolProvider.prototype.removeFileById = function (siteId, fileId) {
        var _this = this;
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            // Get the path to the file first since it relies on the file object stored in the pool.
            return Promise.resolve(_this.getFilePath(siteId, fileId)).then(function (path) {
                var promises = [];
                // Remove entry from filepool store.
                promises.push(db.deleteRecords(_this.FILES_TABLE, { fileId: fileId }));
                // Remove links.
                promises.push(db.deleteRecords(_this.LINKS_TABLE, { fileId: fileId }));
                // Remove the file.
                if (_this.fileProvider.isAvailable()) {
                    promises.push(_this.fileProvider.removeFile(path).catch(function (error) {
                        if (error && error.code == 1) {
                            // Not found, ignore error since maybe it was deleted already.
                        }
                        else {
                            return Promise.reject(error);
                        }
                    }));
                }
                return Promise.all(promises).then(function () {
                    _this.notifyFileDeleted(siteId, fileId);
                });
            });
        });
    };
    /**
     * Delete all the matching files from a component.
     *
     * @param {string} siteId The site ID.
     * @param {string} component The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<any>} Resolved on success.
     */
    CoreFilepoolProvider.prototype.removeFilesByComponent = function (siteId, component, componentId) {
        var _this = this;
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            return _this.getComponentFiles(db, component, componentId);
        }).then(function (items) {
            return Promise.all(items.map(function (item) {
                return _this.removeFileById(siteId, item.fileId);
            }));
        });
    };
    /**
     * Remove a file from the pool.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The file URL.
     * @return {Promise<any>} Resolved on success, rejected on failure.
     */
    CoreFilepoolProvider.prototype.removeFileByUrl = function (siteId, fileUrl) {
        var _this = this;
        return this.fixPluginfileURL(siteId, fileUrl).then(function (fileUrl) {
            var fileId = _this.getFileIdByUrl(fileUrl);
            return _this.removeFileById(siteId, fileId);
        });
    };
    /**
     * Removes the revision number from a file URL.
     *
     * @param {string} url URL to remove the revision number.
     * @return {string} URL without revision number.
     * @description
     * The revision is used to know if a file has changed. We remove it from the URL to prevent storing a file per revision.
     */
    CoreFilepoolProvider.prototype.removeRevisionFromUrl = function (url) {
        var args = this.getPluginFileArgs(url);
        if (!args) {
            // Not a pluginfile, no revision will be found.
            return url;
        }
        return this.pluginFileDelegate.removeRevisionFromUrl(url, args);
    };
    /**
     * Change the package status, setting it to the previous status.
     *
     * @param {string} siteId Site ID.
     * @param {string} component Package's component.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<string>} Promise resolved when the status is changed. Resolve param: new status.
     */
    CoreFilepoolProvider.prototype.setPackagePreviousStatus = function (siteId, component, componentId) {
        var _this = this;
        componentId = this.fixComponentId(componentId);
        this.logger.debug("Set previous status for package " + component + " " + componentId);
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var packageId = _this.getPackageId(component, componentId);
            // Get current stored data, we'll only update 'status' and 'updated' fields.
            return site.getDb().getRecord(_this.PACKAGES_TABLE, { id: packageId }).then(function (entry) {
                var newData = {};
                if (entry.status == __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].DOWNLOADING) {
                    // Going back from downloading to previous status, restore previous download time.
                    newData.downloadTime = entry.previousDownloadTime;
                }
                newData.status = entry.previous || __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].DOWNLOADED;
                newData.updated = Date.now();
                _this.logger.debug("Set previous status '" + entry.status + "' for package " + component + " " + componentId);
                return site.getDb().updateRecords(_this.PACKAGES_TABLE, newData, { id: packageId }).then(function () {
                    // Success updating, trigger event.
                    _this.triggerPackageStatusChanged(site.id, newData.status, component, componentId);
                    return newData.status;
                });
            });
        });
    };
    /**
     * Convenience function to check if a file should be downloaded before opening it.
     *
     * @param {string} url File online URL.
     * @param {number} size File size.
     * @return {Promise}     Promise resolved if should download before open, rejected otherwise.
     * @description
     * Convenience function to check if a file should be downloaded before opening it.
     *
     * The default behaviour in the app is to download first and then open the local file in the following cases:
     *     - The file is small (less than DOWNLOAD_THRESHOLD).
     *     - The file cannot be streamed.
     * If the file is big and can be streamed, the promise returned by this function will be rejected.
     */
    CoreFilepoolProvider.prototype.shouldDownloadBeforeOpen = function (url, size) {
        if (size >= 0 && size <= this.DOWNLOAD_THRESHOLD) {
            // The file is small, download it.
            return Promise.resolve();
        }
        if (this.appProvider.isDesktop()) {
            // In desktop always download first.
            return Promise.resolve();
        }
        return this.mimeUtils.getMimeTypeFromUrl(url).then(function (mimetype) {
            // If the file is streaming (audio or video) we reject.
            if (mimetype.indexOf('video') != -1 || mimetype.indexOf('audio') != -1) {
                return Promise.reject(null);
            }
        });
    };
    /**
     * Store package status.
     *
     * @param {string} siteId Site ID.
     * @param {string} status New package status.
     * @param {string} component Package's component.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {string} [extra] Extra data to store for the package. If you want to store more than 1 value, use JSON.stringify.
     * @return {Promise<any>} Promise resolved when status is stored.
     */
    CoreFilepoolProvider.prototype.storePackageStatus = function (siteId, status, component, componentId, extra) {
        var _this = this;
        this.logger.debug("Set status '" + status + "'' for package " + component + " " + componentId);
        componentId = this.fixComponentId(componentId);
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var packageId = _this.getPackageId(component, componentId);
            var downloadTime, previousDownloadTime;
            if (status == __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].DOWNLOADING) {
                // Set download time if package is now downloading.
                downloadTime = _this.timeUtils.timestamp();
            }
            // Search current status to set it as previous status.
            return site.getDb().getRecord(_this.PACKAGES_TABLE, { id: packageId }).then(function (entry) {
                if (typeof extra == 'undefined' || extra === null) {
                    extra = entry.extra;
                }
                if (typeof downloadTime == 'undefined') {
                    // Keep previous download time.
                    downloadTime = entry.downloadTime;
                    previousDownloadTime = entry.previousDownloadTime;
                }
                else {
                    // The downloadTime will be updated, store current time as previous.
                    previousDownloadTime = entry.downloadTime;
                }
                return entry.status;
            }).catch(function () {
                // No previous status.
            }).then(function (previousStatus) {
                var packageEntry = {
                    id: packageId,
                    component: component,
                    componentId: componentId,
                    status: status,
                    previous: previousStatus,
                    updated: Date.now(),
                    downloadTime: downloadTime,
                    previousDownloadTime: previousDownloadTime,
                    extra: extra
                };
                var promise;
                if (previousStatus === status) {
                    // The package already has this status, no need to change it.
                    promise = Promise.resolve();
                }
                else {
                    promise = site.getDb().insertOrUpdateRecord(_this.PACKAGES_TABLE, packageEntry, { id: packageId });
                }
                return promise.then(function () {
                    // Success inserting, trigger event.
                    _this.triggerPackageStatusChanged(siteId, status, component, componentId);
                });
            });
        });
    };
    /**
     * Remove extension from fileId in queue, used to migrate from previous file handling.
     *
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreFilepoolProvider.prototype.treatExtensionInQueue = function () {
        var _this = this;
        this.logger.debug('Treat extensions in queue');
        return this.appDB.getAllRecords(this.QUEUE_TABLE).then(function (entries) {
            var promises = [];
            entries.forEach(function (entry) {
                // For files in the queue, we only need to remove the extension from the fileId.
                // After downloading, additional info will be added.
                var fileId = entry.fileId;
                entry.fileId = _this.mimeUtils.removeExtension(fileId);
                if (fileId == entry.fileId) {
                    return;
                }
                promises.push(_this.appDB.updateRecords(_this.QUEUE_TABLE, { fileId: entry.fileId }, { fileId: fileId }));
            });
            return Promise.all(promises);
        });
    };
    /**
     * Resolves or rejects a queue deferred and removes it from the list.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @param {boolean} resolve True if promise should be resolved, false if it should be rejected.
     */
    CoreFilepoolProvider.prototype.treatQueueDeferred = function (siteId, fileId, resolve) {
        if (this.queueDeferreds[siteId] && this.queueDeferreds[siteId][fileId]) {
            if (resolve) {
                this.queueDeferreds[siteId][fileId].resolve();
            }
            else {
                this.queueDeferreds[siteId][fileId].reject();
            }
            delete this.queueDeferreds[siteId][fileId];
        }
    };
    /**
     * Trigger mmCoreEventPackageStatusChanged with the right data.
     *
     * @param {string} siteId Site ID.
     * @param {string} status New package status.
     * @param {string} component  Package's component.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     */
    CoreFilepoolProvider.prototype.triggerPackageStatusChanged = function (siteId, status, component, componentId) {
        var data = {
            component: component,
            componentId: this.fixComponentId(componentId),
            status: status
        };
        this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_3__events__["a" /* CoreEventsProvider */].PACKAGE_STATUS_CHANGED, data, siteId);
    };
    /**
     * Update the download time of a package. This doesn't modify the previous download time.
     * This function should be used if a package generates some new data during a download. Calling this function
     * right after generating the data in the download will prevent detecting this data as an update.
     *
     * @param {string} siteId Site ID.
     * @param {string} component Package's component.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<any>} Promise resolved when status is stored.
     */
    CoreFilepoolProvider.prototype.updatePackageDownloadTime = function (siteId, component, componentId) {
        var _this = this;
        componentId = this.fixComponentId(componentId);
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var packageId = _this.getPackageId(component, componentId);
            return site.getDb().updateRecords(_this.PACKAGES_TABLE, { downloadTime: _this.timeUtils.timestamp() }, { id: packageId });
        });
    };
    CoreFilepoolProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_4__file__["a" /* CoreFileProvider */],
            __WEBPACK_IMPORTED_MODULE_8__sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_9__ws__["a" /* CoreWSProvider */], __WEBPACK_IMPORTED_MODULE_11__utils_text__["a" /* CoreTextUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_14__utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_10__utils_mimetype__["a" /* CoreMimetypeUtilsProvider */], __WEBPACK_IMPORTED_MODULE_13__utils_url__["a" /* CoreUrlUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_12__utils_time__["a" /* CoreTimeUtilsProvider */], __WEBPACK_IMPORTED_MODULE_3__events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_5__init__["a" /* CoreInitDelegate */],
            __WEBPACK_IMPORTED_MODULE_1__ionic_native_network__["a" /* Network */], __WEBPACK_IMPORTED_MODULE_7__plugin_file_delegate__["a" /* CorePluginFileDelegate */]])
    ], CoreFilepoolProvider);
    return CoreFilepoolProvider;
}());

//# sourceMappingURL=filepool.js.map

/***/ }),

/***/ 67:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_events__ = __webpack_require__(21);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Superclass to help creating delegates
 */
var CoreDelegate = /** @class */ (function () {
    /**
     * Constructor of the Delegate.
     *
     * @param {string} delegateName Delegate name used for logging purposes.
     * @param {CoreLoggerProvider}   loggerProvider CoreLoggerProvider instance, cannot be directly injected.
     * @param {CoreSitesProvider}    sitesProvider  CoreSitesProvider instance, cannot be directly injected.
     * @param {CoreEventsProvider}   [eventsProvider]  CoreEventsProvider instance, cannot be directly injected.
     *                                                  If not set, no events will be fired.
     */
    function CoreDelegate(delegateName, loggerProvider, sitesProvider, eventsProvider) {
        this.loggerProvider = loggerProvider;
        this.sitesProvider = sitesProvider;
        this.eventsProvider = eventsProvider;
        /**
         * List of registered handlers.
         * @type {any}
         */
        this.handlers = {};
        /**
         * List of registered handlers enabled for the current site.
         * @type {any}
         */
        this.enabledHandlers = {};
        this.logger = this.loggerProvider.getInstance(delegateName);
        if (eventsProvider) {
            // Update handlers on this cases.
            eventsProvider.on(__WEBPACK_IMPORTED_MODULE_3__providers_events__["a" /* CoreEventsProvider */].LOGIN, this.updateHandlers.bind(this));
            eventsProvider.on(__WEBPACK_IMPORTED_MODULE_3__providers_events__["a" /* CoreEventsProvider */].SITE_UPDATED, this.updateHandlers.bind(this));
            eventsProvider.on(__WEBPACK_IMPORTED_MODULE_3__providers_events__["a" /* CoreEventsProvider */].REMOTE_ADDONS_LOADED, this.updateHandlers.bind(this));
        }
    }
    /**
     * Execute a certain function in a enabled handler.
     * If the handler isn't found or function isn't defined, call the same function in the default handler.
     *
     * @param {string} handlerName The handler name.
     * @param {string} fnName Name of the function to execute.
     * @param {any[]} params Parameters to pass to the function.
     * @return {any} Function returned value or default value.
     */
    CoreDelegate.prototype.executeFunctionOnEnabled = function (handlerName, fnName, params) {
        return this.execute(this.enabledHandlers[handlerName], fnName, params);
    };
    /**
     * Execute a certain function in a handler.
     * If the handler isn't found or function isn't defined, call the same function in the default handler.
     *
     * @param {string} handlerName The handler name.
     * @param {string} fnName Name of the function to execute.
     * @param {any[]} params Parameters to pass to the function.
     * @return {any} Function returned value or default value.
     */
    CoreDelegate.prototype.executeFunction = function (handlerName, fnName, params) {
        return this.execute(this.handlers[handlerName], fnName, params);
    };
    /**
     * Execute a certain function in a handler.
     * If the handler isn't found or function isn't defined, call the same function in the default handler.
     *
     * @param {any} handler The handler.
     * @param {string} fnName Name of the function to execute.
     * @param {any[]} params Parameters to pass to the function.
     * @return {any} Function returned value or default value.
     */
    CoreDelegate.prototype.execute = function (handler, fnName, params) {
        if (handler && handler[fnName]) {
            return handler[fnName].apply(handler, params);
        }
        else if (this.defaultHandler && this.defaultHandler[fnName]) {
            return this.defaultHandler[fnName].apply(this, params);
        }
    };
    /**
     * Get a handler.
     *
     * @param  {string} handlerName The handler name.
     * @param  {boolean} [enabled]  Only enabled, or any.
     * @return {any}                Handler.
     */
    CoreDelegate.prototype.getHandler = function (handlerName, enabled) {
        if (enabled === void 0) { enabled = false; }
        return enabled ? this.enabledHandlers[handlerName] : this.handlers[handlerName];
    };
    /**
     * Check if a handler name has a registered handler (not necessarily enabled).
     *
     * @param {string} name The handler name.
     * @param  {boolean} [enabled]  Only enabled, or any.
     * @return {boolean} If the handler is registered or not.
     */
    CoreDelegate.prototype.hasHandler = function (name, enabled) {
        if (enabled === void 0) { enabled = false; }
        return enabled ? typeof this.enabledHandlers[name] !== 'undefined' : typeof this.handlers[name] !== 'undefined';
    };
    /**
     * Check if a time belongs to the last update handlers call.
     * This is to handle the cases where updateHandlers don't finish in the same order as they're called.
     *
     * @param {number} time Time to check.
     * @return {boolean} Whether it's the last call.
     */
    CoreDelegate.prototype.isLastUpdateCall = function (time) {
        if (!this.lastUpdateHandlersStart) {
            return true;
        }
        return time == this.lastUpdateHandlersStart;
    };
    /**
     * Register a handler.
     *
     * @param {CoreDelegateHandler} handler The handler delegate object to register.
     * @return {boolean} True when registered, false if already registered.
     */
    CoreDelegate.prototype.registerHandler = function (handler) {
        if (typeof this.handlers[handler.name] !== 'undefined') {
            this.logger.log("Addon '" + handler.name + "' already registered");
            return false;
        }
        this.logger.log("Registered addon '" + handler.name + "'");
        this.handlers[handler.name] = handler;
        return true;
    };
    /**
     * Update the handler for the current site.
     *
     * @param {CoreDelegateHandler} handler The handler to check.
     * @param {number} time Time this update process started.
     * @return {Promise<void>} Resolved when done.
     */
    CoreDelegate.prototype.updateHandler = function (handler, time) {
        var _this = this;
        var siteId = this.sitesProvider.getCurrentSiteId(), currentSite = this.sitesProvider.getCurrentSite();
        var promise;
        if (!this.sitesProvider.isLoggedIn()) {
            promise = Promise.reject(null);
        }
        else if (this.isFeatureDisabled(handler, currentSite)) {
            promise = Promise.resolve(false);
        }
        else {
            promise = Promise.resolve(handler.isEnabled());
        }
        // Checks if the handler is enabled.
        return promise.catch(function () {
            return false;
        }).then(function (enabled) {
            // Verify that this call is the last one that was started.
            // Check that site hasn't changed since the check started.
            if (_this.isLastUpdateCall(time) && _this.sitesProvider.getCurrentSiteId() === siteId) {
                if (enabled) {
                    _this.enabledHandlers[handler.name] = handler;
                }
                else {
                    delete _this.enabledHandlers[handler.name];
                }
            }
        });
    };
    /**
     * Check if feature is enabled or disabled in the site, depending on the feature prefix and the handler name.
     *
     * @param  {CoreDelegateHandler} handler Handler to check.
     * @param  {any}                 site    Site to check.
     * @return {boolean}                     Whether is enabled or disabled in site.
     */
    CoreDelegate.prototype.isFeatureDisabled = function (handler, site) {
        return typeof this.featurePrefix != 'undefined' && site.isFeatureDisabled(this.featurePrefix + handler.name);
    };
    /**
     * Update the handlers for the current site.
     *
     * @return {Promise<void>} Resolved when done.
     */
    CoreDelegate.prototype.updateHandlers = function () {
        var _this = this;
        var promises = [], now = Date.now();
        this.logger.debug('Updating handlers for current site.');
        this.lastUpdateHandlersStart = now;
        // Loop over all the handlers.
        for (var name_1 in this.handlers) {
            promises.push(this.updateHandler(this.handlers[name_1], now));
        }
        return Promise.all(promises).then(function () {
            return true;
        }, function () {
            // Never reject.
            return true;
        }).then(function () {
            // Verify that this call is the last one that was started.
            if (_this.isLastUpdateCall(now)) {
                _this.updateData();
            }
        });
    };
    /**
     * Update handlers Data.
     * Override this function to update handlers data.
     */
    CoreDelegate.prototype.updateData = function () {
        // To be overridden.
    };
    CoreDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [String, __WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_events__["a" /* CoreEventsProvider */]])
    ], CoreDelegate);
    return CoreDelegate;
}());

//# sourceMappingURL=delegate.js.map

/***/ }),

/***/ 678:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreAutoFocusDirective; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_dom__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__ = __webpack_require__(9);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Directive to auto focus an element when a view is loaded.
 *
 * You can apply it conditionallity assigning it a boolean value: <ion-input [core-auto-focus]="{{showKeyboard}}">
 */
var CoreAutoFocusDirective = /** @class */ (function () {
    function CoreAutoFocusDirective(element, domUtils, utils, navCtrl) {
        this.domUtils = domUtils;
        this.utils = utils;
        this.navCtrl = navCtrl;
        this.coreAutoFocus = true;
        this.element = element.nativeElement || element;
    }
    /**
     * Component being initialized.
     */
    CoreAutoFocusDirective.prototype.ngOnInit = function () {
        var _this = this;
        if (this.navCtrl.isTransitioning()) {
            // Navigating to a new page. Wait for the transition to be over.
            var subscription_1 = this.navCtrl.viewDidEnter.subscribe(function () {
                _this.autoFocus();
                subscription_1.unsubscribe();
            });
        }
        else {
            this.autoFocus();
        }
    };
    /**
     * Function after the view is initialized.
     */
    CoreAutoFocusDirective.prototype.autoFocus = function () {
        var _this = this;
        var autoFocus = this.utils.isTrueOrOne(this.coreAutoFocus);
        if (autoFocus) {
            // If it's a ion-input or ion-textarea, search the right input to use.
            var element_1 = this.element;
            if (this.element.tagName == 'ION-INPUT') {
                element_1 = this.element.querySelector('input') || element_1;
            }
            else if (this.element.tagName == 'ION-TEXTAREA') {
                element_1 = this.element.querySelector('textarea') || element_1;
            }
            // Wait a bit to make sure the view is loaded.
            setTimeout(function () {
                _this.domUtils.focusElement(element_1);
            }, 200);
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])('core-auto-focus'),
        __metadata("design:type", Object)
    ], CoreAutoFocusDirective.prototype, "coreAutoFocus", void 0);
    CoreAutoFocusDirective = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["s" /* Directive */])({
            selector: '[core-auto-focus]'
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavController */]])
    ], CoreAutoFocusDirective);
    return CoreAutoFocusDirective;
}());

//# sourceMappingURL=auto-focus.js.map

/***/ }),

/***/ 680:
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./af": 328,
	"./af.js": 328,
	"./ar": 329,
	"./ar-dz": 330,
	"./ar-dz.js": 330,
	"./ar-kw": 331,
	"./ar-kw.js": 331,
	"./ar-ly": 332,
	"./ar-ly.js": 332,
	"./ar-ma": 333,
	"./ar-ma.js": 333,
	"./ar-sa": 334,
	"./ar-sa.js": 334,
	"./ar-tn": 335,
	"./ar-tn.js": 335,
	"./ar.js": 329,
	"./az": 336,
	"./az.js": 336,
	"./be": 337,
	"./be.js": 337,
	"./bg": 338,
	"./bg.js": 338,
	"./bm": 339,
	"./bm.js": 339,
	"./bn": 340,
	"./bn.js": 340,
	"./bo": 341,
	"./bo.js": 341,
	"./br": 342,
	"./br.js": 342,
	"./bs": 343,
	"./bs.js": 343,
	"./ca": 344,
	"./ca.js": 344,
	"./cs": 345,
	"./cs.js": 345,
	"./cv": 346,
	"./cv.js": 346,
	"./cy": 347,
	"./cy.js": 347,
	"./da": 348,
	"./da.js": 348,
	"./de": 349,
	"./de-at": 350,
	"./de-at.js": 350,
	"./de-ch": 351,
	"./de-ch.js": 351,
	"./de.js": 349,
	"./dv": 352,
	"./dv.js": 352,
	"./el": 353,
	"./el.js": 353,
	"./en-au": 354,
	"./en-au.js": 354,
	"./en-ca": 355,
	"./en-ca.js": 355,
	"./en-gb": 356,
	"./en-gb.js": 356,
	"./en-ie": 357,
	"./en-ie.js": 357,
	"./en-nz": 358,
	"./en-nz.js": 358,
	"./eo": 359,
	"./eo.js": 359,
	"./es": 360,
	"./es-do": 361,
	"./es-do.js": 361,
	"./es-us": 362,
	"./es-us.js": 362,
	"./es.js": 360,
	"./et": 363,
	"./et.js": 363,
	"./eu": 364,
	"./eu.js": 364,
	"./fa": 365,
	"./fa.js": 365,
	"./fi": 366,
	"./fi.js": 366,
	"./fo": 367,
	"./fo.js": 367,
	"./fr": 368,
	"./fr-ca": 369,
	"./fr-ca.js": 369,
	"./fr-ch": 370,
	"./fr-ch.js": 370,
	"./fr.js": 368,
	"./fy": 371,
	"./fy.js": 371,
	"./gd": 372,
	"./gd.js": 372,
	"./gl": 373,
	"./gl.js": 373,
	"./gom-latn": 374,
	"./gom-latn.js": 374,
	"./gu": 375,
	"./gu.js": 375,
	"./he": 376,
	"./he.js": 376,
	"./hi": 377,
	"./hi.js": 377,
	"./hr": 378,
	"./hr.js": 378,
	"./hu": 379,
	"./hu.js": 379,
	"./hy-am": 380,
	"./hy-am.js": 380,
	"./id": 381,
	"./id.js": 381,
	"./is": 382,
	"./is.js": 382,
	"./it": 383,
	"./it.js": 383,
	"./ja": 384,
	"./ja.js": 384,
	"./jv": 385,
	"./jv.js": 385,
	"./ka": 386,
	"./ka.js": 386,
	"./kk": 387,
	"./kk.js": 387,
	"./km": 388,
	"./km.js": 388,
	"./kn": 389,
	"./kn.js": 389,
	"./ko": 390,
	"./ko.js": 390,
	"./ky": 391,
	"./ky.js": 391,
	"./lb": 392,
	"./lb.js": 392,
	"./lo": 393,
	"./lo.js": 393,
	"./lt": 394,
	"./lt.js": 394,
	"./lv": 395,
	"./lv.js": 395,
	"./me": 396,
	"./me.js": 396,
	"./mi": 397,
	"./mi.js": 397,
	"./mk": 398,
	"./mk.js": 398,
	"./ml": 399,
	"./ml.js": 399,
	"./mr": 400,
	"./mr.js": 400,
	"./ms": 401,
	"./ms-my": 402,
	"./ms-my.js": 402,
	"./ms.js": 401,
	"./my": 403,
	"./my.js": 403,
	"./nb": 404,
	"./nb.js": 404,
	"./ne": 405,
	"./ne.js": 405,
	"./nl": 406,
	"./nl-be": 407,
	"./nl-be.js": 407,
	"./nl.js": 406,
	"./nn": 408,
	"./nn.js": 408,
	"./pa-in": 409,
	"./pa-in.js": 409,
	"./pl": 410,
	"./pl.js": 410,
	"./pt": 411,
	"./pt-br": 412,
	"./pt-br.js": 412,
	"./pt.js": 411,
	"./ro": 413,
	"./ro.js": 413,
	"./ru": 414,
	"./ru.js": 414,
	"./sd": 415,
	"./sd.js": 415,
	"./se": 416,
	"./se.js": 416,
	"./si": 417,
	"./si.js": 417,
	"./sk": 418,
	"./sk.js": 418,
	"./sl": 419,
	"./sl.js": 419,
	"./sq": 420,
	"./sq.js": 420,
	"./sr": 421,
	"./sr-cyrl": 422,
	"./sr-cyrl.js": 422,
	"./sr.js": 421,
	"./ss": 423,
	"./ss.js": 423,
	"./sv": 424,
	"./sv.js": 424,
	"./sw": 425,
	"./sw.js": 425,
	"./ta": 426,
	"./ta.js": 426,
	"./te": 427,
	"./te.js": 427,
	"./tet": 428,
	"./tet.js": 428,
	"./th": 429,
	"./th.js": 429,
	"./tl-ph": 430,
	"./tl-ph.js": 430,
	"./tlh": 431,
	"./tlh.js": 431,
	"./tr": 432,
	"./tr.js": 432,
	"./tzl": 433,
	"./tzl.js": 433,
	"./tzm": 434,
	"./tzm-latn": 435,
	"./tzm-latn.js": 435,
	"./tzm.js": 434,
	"./uk": 436,
	"./uk.js": 436,
	"./ur": 437,
	"./ur.js": 437,
	"./uz": 438,
	"./uz-latn": 439,
	"./uz-latn.js": 439,
	"./uz.js": 438,
	"./vi": 440,
	"./vi.js": 440,
	"./x-pseudo": 441,
	"./x-pseudo.js": 441,
	"./yo": 442,
	"./yo.js": 442,
	"./zh-cn": 443,
	"./zh-cn.js": 443,
	"./zh-hk": 444,
	"./zh-hk.js": 444,
	"./zh-tw": 445,
	"./zh-tw.js": 445
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number or string
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 680;

/***/ }),

/***/ 687:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SQLiteDBMock; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__classes_sqlitedb__ = __webpack_require__(451);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

/**
 * Class to mock the interaction with the SQLite database.
 */
var SQLiteDBMock = /** @class */ (function (_super) {
    __extends(SQLiteDBMock, _super);
    /**
     * Create and open the database.
     *
     * @param {string} name Database name.
     */
    function SQLiteDBMock(name) {
        var _this = _super.call(this, name, null, null) || this;
        _this.name = name;
        return _this;
    }
    /**
     * Close the database.
     *
     * @return {Promise<any>} Promise resolved when done.
     */
    SQLiteDBMock.prototype.close = function () {
        // WebSQL databases aren't closed.
        return Promise.resolve();
    };
    /**
     * Drop all the data in the database.
     *
     * @return {Promise<any>} Promise resolved when done.
     */
    SQLiteDBMock.prototype.emptyDatabase = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.db.transaction(function (tx) {
                // Query all tables from sqlite_master that we have created and can modify.
                var args = [], query = "SELECT * FROM sqlite_master\n                            WHERE name NOT LIKE 'sqlite\\_%' escape '\\' AND name NOT LIKE '\\_%' escape '\\'";
                tx.executeSql(query, args, function (tx, result) {
                    if (result.rows.length <= 0) {
                        // No tables to delete, stop.
                        resolve();
                        return;
                    }
                    // Drop all the tables.
                    var promises = [];
                    var _loop_1 = function (i) {
                        promises.push(new Promise(function (resolve, reject) {
                            // Drop the table.
                            var name = JSON.stringify(result.rows.item(i).name);
                            tx.executeSql('DROP TABLE ' + name, [], resolve, reject);
                        }));
                    };
                    for (var i = 0; i < result.rows.length; i++) {
                        _loop_1(i);
                    }
                    Promise.all(promises).then(resolve, reject);
                }, reject);
            });
        });
    };
    /**
     * Execute a SQL query.
     * IMPORTANT: Use this function only if you cannot use any of the other functions in this API. Please take into account that
     * these query will be run in SQLite (Mobile) and Web SQL (desktop), so your query should work in both environments.
     *
     * @param {string} sql SQL query to execute.
     * @param {any[]} params Query parameters.
     * @return {Promise<any>} Promise resolved with the result.
     */
    SQLiteDBMock.prototype.execute = function (sql, params) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            // With WebSQL, all queries must be run in a transaction.
            _this.db.transaction(function (tx) {
                tx.executeSql(sql, params, function (tx, results) {
                    resolve(results);
                }, function (tx, error) {
                    reject(error);
                });
            });
        });
    };
    /**
     * Execute a set of SQL queries. This operation is atomic.
     * IMPORTANT: Use this function only if you cannot use any of the other functions in this API. Please take into account that
     * these query will be run in SQLite (Mobile) and Web SQL (desktop), so your query should work in both environments.
     *
     * @param {any[]} sqlStatements SQL statements to execute.
     * @return {Promise<any>} Promise resolved with the result.
     */
    SQLiteDBMock.prototype.executeBatch = function (sqlStatements) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            // Create a transaction to execute the queries.
            _this.db.transaction(function (tx) {
                var promises = [];
                // Execute all the queries. Each statement can be a string or an array.
                sqlStatements.forEach(function (statement) {
                    promises.push(new Promise(function (resolve, reject) {
                        var query, params;
                        if (Array.isArray(statement)) {
                            query = statement[0];
                            params = statement[1];
                        }
                        else {
                            query = statement;
                            params = null;
                        }
                        tx.executeSql(query, params, function (tx, results) {
                            resolve(results);
                        }, reject);
                    }));
                });
                Promise.all(promises).then(resolve, reject);
            });
        });
    };
    /**
     * Initialize the database.
     */
    SQLiteDBMock.prototype.init = function () {
        // This DB is for desktop apps, so use a big size to be sure it isn't filled.
        this.db = window.openDatabase(this.name, '1.0', this.name, 500 * 1024 * 1024);
        this.promise = Promise.resolve();
    };
    /**
     * Open the database. Only needed if it was closed before, a database is automatically opened when created.
     *
     * @return {Promise<any>} Promise resolved when done.
     */
    SQLiteDBMock.prototype.open = function () {
        // WebSQL databases can't closed, so the open method isn't needed.
        return Promise.resolve();
    };
    return SQLiteDBMock;
}(__WEBPACK_IMPORTED_MODULE_0__classes_sqlitedb__["a" /* SQLiteDB */]));

//# sourceMappingURL=sqlitedb.js.map

/***/ }),

/***/ 70:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFileUploaderHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_media_capture__ = __webpack_require__(215);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_camera__ = __webpack_require__(216);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ngx_translate_core__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_app__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_file__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_dom__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_text__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__fileuploader__ = __webpack_require__(139);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__delegate__ = __webpack_require__(217);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};













/**
 * Helper service to upload files.
 */
var CoreFileUploaderHelperProvider = /** @class */ (function () {
    function CoreFileUploaderHelperProvider(logger, appProvider, translate, fileUploaderProvider, domUtils, textUtils, fileProvider, utils, actionSheetCtrl, uploaderDelegate, mediaCapture, camera, platform) {
        this.appProvider = appProvider;
        this.translate = translate;
        this.fileUploaderProvider = fileUploaderProvider;
        this.domUtils = domUtils;
        this.textUtils = textUtils;
        this.fileProvider = fileProvider;
        this.utils = utils;
        this.actionSheetCtrl = actionSheetCtrl;
        this.uploaderDelegate = uploaderDelegate;
        this.mediaCapture = mediaCapture;
        this.camera = camera;
        this.platform = platform;
        this.logger = logger.getInstance('CoreFileUploaderProvider');
    }
    /**
     * Show a confirmation modal to the user if the size of the file is bigger than the allowed threshold.
     *
     * @param {number} size File size.
     * @param {boolean} [alwaysConfirm] True to show a confirm even if the size isn't high.
     * @param {boolean} [allowOffline] True to allow uploading in offline.
     * @param {number} [wifiThreshold] Threshold for WiFi connection. Default: CoreFileUploaderProvider.WIFI_SIZE_WARNING.
     * @param {number} [limitedThreshold] Threshold for limited connection. Default: CoreFileUploaderProvider.LIMITED_SIZE_WARNING.
     * @return {Promise<void>} Promise resolved when the user confirms or if there's no need to show a modal.
     */
    CoreFileUploaderHelperProvider.prototype.confirmUploadFile = function (size, alwaysConfirm, allowOffline, wifiThreshold, limitedThreshold) {
        if (size == 0) {
            return Promise.resolve();
        }
        if (!allowOffline && !this.appProvider.isOnline()) {
            return Promise.reject(this.translate.instant('core.fileuploader.errormustbeonlinetoupload'));
        }
        wifiThreshold = typeof wifiThreshold == 'undefined' ? __WEBPACK_IMPORTED_MODULE_11__fileuploader__["a" /* CoreFileUploaderProvider */].WIFI_SIZE_WARNING : wifiThreshold;
        limitedThreshold = typeof limitedThreshold == 'undefined' ?
            __WEBPACK_IMPORTED_MODULE_11__fileuploader__["a" /* CoreFileUploaderProvider */].LIMITED_SIZE_WARNING : limitedThreshold;
        if (size < 0) {
            return this.domUtils.showConfirm(this.translate.instant('core.fileuploader.confirmuploadunknownsize'));
        }
        else if (size >= wifiThreshold || (this.appProvider.isNetworkAccessLimited() && size >= limitedThreshold)) {
            var readableSize = this.textUtils.bytesToSize(size, 2);
            return this.domUtils.showConfirm(this.translate.instant('core.fileuploader.confirmuploadfile', { size: readableSize }));
        }
        else if (alwaysConfirm) {
            return this.domUtils.showConfirm(this.translate.instant('core.areyousure'));
        }
        else {
            return Promise.resolve();
        }
    };
    /**
     * Create a temporary copy of a file and upload it.
     *
     * @param {any} file File to copy and upload.
     * @param {boolean} [upload] True if the file should be uploaded, false to return the copy of the file.
     * @param {string} [name] Name to use when uploading the file. If not defined, use the file's name.
     * @return {Promise<any>} Promise resolved when the file is uploaded.
     */
    CoreFileUploaderHelperProvider.prototype.copyAndUploadFile = function (file, upload, name) {
        var _this = this;
        name = name || file.name;
        var modal = this.domUtils.showModalLoading('core.fileuploader.readingfile', true);
        var fileData;
        // We have the data of the file to be uploaded, but not its URL (needed). Create a copy of the file to upload it.
        return this.fileProvider.readFileData(file, __WEBPACK_IMPORTED_MODULE_6__providers_file__["a" /* CoreFileProvider */].FORMATARRAYBUFFER).then(function (data) {
            fileData = data;
            // Get unique name for the copy.
            return _this.fileProvider.getUniqueNameInFolder(__WEBPACK_IMPORTED_MODULE_6__providers_file__["a" /* CoreFileProvider */].TMPFOLDER, name);
        }).then(function (newName) {
            var filePath = _this.textUtils.concatenatePaths(__WEBPACK_IMPORTED_MODULE_6__providers_file__["a" /* CoreFileProvider */].TMPFOLDER, newName);
            return _this.fileProvider.writeFile(filePath, fileData);
        }).catch(function (error) {
            _this.logger.error('Error reading file to upload.', error);
            modal.dismiss();
            return Promise.reject(_this.translate.instant('core.fileuploader.errorreadingfile'));
        }).then(function (fileEntry) {
            modal.dismiss();
            if (upload) {
                // Pass true to delete the copy after the upload.
                return _this.uploadGenericFile(fileEntry.toURL(), name, file.type, true);
            }
            else {
                return fileEntry;
            }
        });
    };
    /**
     * Copy or move a file to the app temporary folder.
     *
     * @param {string} path  Path of the file.
     * @param {boolean} shouldDelete True if original file should be deleted (move), false otherwise (copy).
     * @param {number} [maxSize] Max size of the file. If not defined or -1, no max size.
     * @param {string} [defaultExt] Defaut extension to use if the file doesn't have any.
     * @return {Promise<any>} Promise resolved with the copied file.
     */
    CoreFileUploaderHelperProvider.prototype.copyToTmpFolder = function (path, shouldDelete, maxSize, defaultExt) {
        var _this = this;
        var fileName = this.fileProvider.getFileAndDirectoryFromPath(path).name, promise, fileTooLarge;
        // Check that size isn't too large.
        if (typeof maxSize != 'undefined' && maxSize != -1) {
            promise = this.fileProvider.getExternalFile(path).then(function (fileEntry) {
                return _this.fileProvider.getFileObjectFromFileEntry(fileEntry).then(function (file) {
                    if (file.size > maxSize) {
                        fileTooLarge = file;
                    }
                });
            }).catch(function () {
                // Ignore failures.
            });
        }
        else {
            promise = Promise.resolve();
        }
        return promise.then(function () {
            if (fileTooLarge) {
                return _this.errorMaxBytes(maxSize, fileTooLarge.name);
            }
            // File isn't too large.
            // Picking an image from album in Android adds a timestamp at the end of the file. Delete it.
            fileName = fileName.replace(/(\.[^\.]*)\?[^\.]*$/, '$1');
            // Get a unique name in the folder to prevent overriding another file.
            return _this.fileProvider.getUniqueNameInFolder(__WEBPACK_IMPORTED_MODULE_6__providers_file__["a" /* CoreFileProvider */].TMPFOLDER, fileName, defaultExt);
        }).then(function (newName) {
            // Now move or copy the file.
            var destPath = _this.textUtils.concatenatePaths(__WEBPACK_IMPORTED_MODULE_6__providers_file__["a" /* CoreFileProvider */].TMPFOLDER, newName);
            if (shouldDelete) {
                return _this.fileProvider.moveExternalFile(path, destPath);
            }
            else {
                return _this.fileProvider.copyExternalFile(path, destPath);
            }
        });
    };
    /**
     * Function called when trying to upload a file bigger than max size. Shows an error.
     *
     * @param {number} maxSize Max size (bytes).
     * @param {string} fileName Name of the file.
     * @return {Promise<any>} Rejected promise.
     */
    CoreFileUploaderHelperProvider.prototype.errorMaxBytes = function (maxSize, fileName) {
        var errorMessage = this.translate.instant('core.fileuploader.maxbytesfile', {
            $a: {
                file: fileName,
                size: this.textUtils.bytesToSize(maxSize, 2)
            }
        });
        this.domUtils.showErrorModal(errorMessage);
        return Promise.reject(null);
    };
    /**
     * Function called when the file picker is closed.
     */
    CoreFileUploaderHelperProvider.prototype.filePickerClosed = function () {
        if (this.filePickerDeferred) {
            this.filePickerDeferred.reject();
            this.filePickerDeferred = undefined;
        }
        // Close the action sheet if it's opened.
        if (this.actionSheet) {
            this.actionSheet.dismiss();
        }
    };
    /**
     * Function to call once a file is uploaded using the file picker.
     *
     * @param {any} result Result of the upload process.
     */
    CoreFileUploaderHelperProvider.prototype.fileUploaded = function (result) {
        if (this.filePickerDeferred) {
            this.filePickerDeferred.resolve(result);
            this.filePickerDeferred = undefined;
        }
        // Close the action sheet if it's opened.
        if (this.actionSheet) {
            this.actionSheet.dismiss();
        }
    };
    /**
     * Open the "file picker" to select and upload a file.
     *
     * @param {number} [maxSize] Max size of the file to upload. If not defined or -1, no max size.
     * @param {string} [title] File picker title.
     * @param {string[]} [mimetypes] List of supported mimetypes. If undefined, all mimetypes supported.
     * @return {Promise<any>} Promise resolved when a file is uploaded, rejected if file picker is closed without a file uploaded.
     *                        The resolve value is the response of the upload request.
     */
    CoreFileUploaderHelperProvider.prototype.selectAndUploadFile = function (maxSize, title, mimetypes) {
        return this.selectFileWithPicker(maxSize, false, title, mimetypes, true);
    };
    /**
     * Open the "file picker" to select a file without uploading it.
     *
     * @param {number} [maxSize] Max size of the file. If not defined or -1, no max size.
     * @param {boolean} [allowOffline] True to allow selecting in offline, false to require connection.
     * @param {string} [title] File picker title.
     * @param {string[]} [mimetypes] List of supported mimetypes. If undefined, all mimetypes supported.
     * @return {Promise<any>} Promise resolved when a file is selected, rejected if file picker is closed without selecting a file.
     *                        The resolve value is the FileEntry of a copy of the picked file, so it can be deleted afterwards.
     */
    CoreFileUploaderHelperProvider.prototype.selectFile = function (maxSize, allowOffline, title, mimetypes) {
        return this.selectFileWithPicker(maxSize, allowOffline, title, mimetypes, false);
    };
    /**
     * Open the "file picker" to select a file and maybe uploading it.
     *
     * @param {number} [maxSize] Max size of the file. If not defined or -1, no max size.
     * @param {boolean} [allowOffline] True to allow selecting in offline, false to require connection.
     * @param {string} [title] File picker title.
     * @param {string[]} [mimetypes] List of supported mimetypes. If undefined, all mimetypes supported.
     * @param {boolean} [upload] Whether the file should be uploaded.
     * @return {Promise<any>} Promise resolved when a file is selected/uploaded, rejected if file picker is closed.
     */
    CoreFileUploaderHelperProvider.prototype.selectFileWithPicker = function (maxSize, allowOffline, title, mimetypes, upload) {
        var _this = this;
        // Create the cancel button and get the handlers to upload the file.
        var buttons = [{
                text: this.translate.instant('core.cancel'),
                role: 'cancel',
                handler: function () {
                    // User cancelled the action sheet.
                    _this.filePickerClosed();
                }
            }], handlers = this.uploaderDelegate.getHandlers(mimetypes);
        this.filePickerDeferred = this.utils.promiseDefer();
        // Sort the handlers by priority.
        handlers.sort(function (a, b) {
            return a.priority <= b.priority ? 1 : -1;
        });
        // Create a button for each handler.
        handlers.forEach(function (handler) {
            buttons.push({
                text: _this.translate.instant(handler.title),
                icon: handler.icon,
                cssClass: handler.class,
                handler: function () {
                    if (!handler.action) {
                        // Nothing to do.
                        return false;
                    }
                    if (!allowOffline && !_this.appProvider.isOnline()) {
                        // Not allowed, show error.
                        _this.domUtils.showErrorModal('core.fileuploader.errormustbeonlinetoupload', true);
                        return false;
                    }
                    handler.action(maxSize, upload, allowOffline, handler.mimetypes).then(function (data) {
                        if (data.treated) {
                            // The handler already treated the file. Return the result.
                            return data.result;
                        }
                        else {
                            // The handler didn't treat the file, we need to do it.
                            if (data.fileEntry) {
                                // The handler provided us a fileEntry, use it.
                                return _this.uploadFileEntry(data.fileEntry, data.delete, maxSize, upload, allowOffline);
                            }
                            else if (data.path) {
                                // The handler provided a path. First treat it like it's a relative path.
                                return _this.fileProvider.getFile(data.path).catch(function () {
                                    // File not found, it's probably an absolute path.
                                    return _this.fileProvider.getExternalFile(data.path);
                                }).then(function (fileEntry) {
                                    // File found, treat it.
                                    return _this.uploadFileEntry(fileEntry, data.delete, maxSize, upload, allowOffline);
                                });
                            }
                            // Nothing received, fail.
                            return Promise.reject('No file received');
                        }
                    }).then(function (result) {
                        // Success uploading or picking, return the result.
                        _this.fileUploaded(result);
                    }).catch(function (error) {
                        if (error) {
                            _this.domUtils.showErrorModal(error);
                        }
                    });
                    // Do not close the action sheet, it will be closed if success.
                    return false;
                }
            });
        });
        this.actionSheet = this.actionSheetCtrl.create({
            title: title ? title : this.translate.instant('core.fileuploader.' + (upload ? 'uploadafile' : 'selectafile')),
            buttons: buttons
        });
        this.actionSheet.present();
        // Call afterRender for each button.
        setTimeout(function () {
            handlers.forEach(function (handler) {
                if (handler.afterRender) {
                    handler.afterRender(maxSize, upload, allowOffline, handler.mimetypes);
                }
            });
        }, 500);
        return this.filePickerDeferred.promise;
    };
    /**
     * Convenience function to upload a file on a certain site, showing a confirm if needed.
     *
     * @param {any} fileEntry FileEntry of the file to upload.
     * @param {boolean} [deleteAfterUpload] Whether the file should be deleted after upload.
     * @param {string} [siteId] Id of the site to upload the file to. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the file is uploaded.
     */
    CoreFileUploaderHelperProvider.prototype.showConfirmAndUploadInSite = function (fileEntry, deleteAfterUpload, siteId) {
        var _this = this;
        return this.fileProvider.getFileObjectFromFileEntry(fileEntry).then(function (file) {
            return _this.confirmUploadFile(file.size).then(function () {
                return _this.uploadGenericFile(fileEntry.toURL(), file.name, file.type, deleteAfterUpload, siteId).then(function () {
                    _this.domUtils.showToast('core.fileuploader.fileuploaded', true, undefined, 'core-toast-success');
                });
            }).catch(function (err) {
                if (err) {
                    _this.domUtils.showErrorModal(err);
                }
                return Promise.reject(null);
            });
        }, function () {
            _this.domUtils.showErrorModal('core.fileuploader.errorreadingfile', true);
            return Promise.reject(null);
        });
    };
    /**
     * Treat a capture audio/video error.
     *
     * @param {any} error Error returned by the Cordova plugin. Can be a string or an object.
     * @param {string} defaultMessage Key of the default message to show.
     * @return {Promise<any>} Rejected promise. If it doesn't have an error message it means it was cancelled.
     */
    CoreFileUploaderHelperProvider.prototype.treatCaptureError = function (error, defaultMessage) {
        // Cancelled or error. If cancelled, error is an object with code = 3.
        if (error) {
            if (typeof error === 'string') {
                this.logger.error('Error while recording audio/video: ' + error);
                if (error.indexOf('No Activity found') > -1) {
                    // User doesn't have an app to do this.
                    return Promise.reject(this.translate.instant('core.fileuploader.errornoapp'));
                }
                else {
                    return Promise.reject(this.translate.instant(defaultMessage));
                }
            }
            else {
                if (error.code != 3) {
                    // Error, not cancelled.
                    this.logger.error('Error while recording audio/video', error);
                    return Promise.reject(this.translate.instant(defaultMessage));
                }
                else {
                    this.logger.debug('Cancelled');
                }
            }
        }
        return Promise.reject(null);
    };
    /**
     * Treat a capture image or browse album error.
     *
     * @param {string} error Error returned by the Cordova plugin.
     * @param {string} defaultMessage Key of the default message to show.
     * @return {Promise<any>} Rejected promise. If it doesn't have an error message it means it was cancelled.
     */
    CoreFileUploaderHelperProvider.prototype.treatImageError = function (error, defaultMessage) {
        // Cancelled or error.
        if (error) {
            if (typeof error == 'string') {
                if (error.toLowerCase().indexOf('error') > -1 || error.toLowerCase().indexOf('unable') > -1) {
                    this.logger.error('Error getting image: ' + error);
                    return Promise.reject(error);
                }
                else {
                    // User cancelled.
                    this.logger.debug('Cancelled');
                }
            }
            else {
                return Promise.reject(this.translate.instant(defaultMessage));
            }
        }
        return Promise.reject(null);
    };
    /**
     * Convenient helper for the user to record and upload a video.
     *
     * @param {boolean} isAudio True if uploading an audio, false if it's a video.
     * @param {number} maxSize Max size of the upload. -1 for no max size.
     * @param {boolean} [upload] True if the file should be uploaded, false to return the picked file.
     * @param {string[]} [mimetypes] List of supported mimetypes. If undefined, all mimetypes supported.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreFileUploaderHelperProvider.prototype.uploadAudioOrVideo = function (isAudio, maxSize, upload, mimetypes) {
        var _this = this;
        this.logger.debug('Trying to record a video file');
        var options = { limit: 1, mimetypes: mimetypes }, promise = isAudio ? this.mediaCapture.captureAudio(options) : this.mediaCapture.captureVideo(options);
        // The mimetypes param is only for desktop apps, the Cordova plugin doesn't support it.
        return promise.then(function (medias) {
            // We used limit 1, we only want 1 media.
            var media = medias[0], path = media.fullPath, error = _this.fileUploaderProvider.isInvalidMimetype(mimetypes, path); // Verify that the mimetype is supported.
            if (error) {
                return Promise.reject(error);
            }
            if (upload) {
                return _this.uploadFile(path, maxSize, true, _this.fileUploaderProvider.getMediaUploadOptions(media));
            }
            else {
                // Copy or move the file to our temporary folder.
                return _this.copyToTmpFolder(path, true, maxSize);
            }
        }, function (error) {
            var defaultError = isAudio ? 'core.fileuploader.errorcapturingaudio' : 'core.fileuploader.errorcapturingvideo';
            return _this.treatCaptureError(error, defaultError);
        });
    };
    /**
     * Uploads a file of any type.
     * This function will not check the size of the file, please check it before calling this function.
     *
     * @param {string} uri File URI.
     * @param {string} name File name.
     * @param {string} type File type.
     * @param {boolean} [deleteAfterUpload] Whether the file should be deleted after upload.
     * @param {string} [siteId] Id of the site to upload the file to. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the file is uploaded.
     */
    CoreFileUploaderHelperProvider.prototype.uploadGenericFile = function (uri, name, type, deleteAfterUpload, siteId) {
        var options = this.fileUploaderProvider.getFileUploadOptions(uri, name, type, deleteAfterUpload);
        return this.uploadFile(uri, -1, false, options, siteId);
    };
    /**
     * Convenient helper for the user to upload an image, either from the album or taking it with the camera.
     *
     * @param {boolean} fromAlbum True if the image should be selected from album, false if it should be taken with camera.
     * @param {number} maxSize Max size of the upload. -1 for no max size.
     * @param {boolean} [upload] True if the file should be uploaded, false to return the picked file.
     * @param {string[]} [mimetypes] List of supported mimetypes. If undefined, all mimetypes supported.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreFileUploaderHelperProvider.prototype.uploadImage = function (fromAlbum, maxSize, upload, mimetypes) {
        var _this = this;
        this.logger.debug('Trying to capture an image with camera');
        var options = {
            quality: 50,
            destinationType: this.camera.DestinationType.FILE_URI,
            correctOrientation: true
        };
        if (fromAlbum) {
            var imageSupported = !mimetypes || this.utils.indexOfRegexp(mimetypes, /^image\//) > -1, videoSupported = !mimetypes || this.utils.indexOfRegexp(mimetypes, /^video\//) > -1;
            options.sourceType = this.camera.PictureSourceType.PHOTOLIBRARY;
            options.popoverOptions = {
                x: 10,
                y: 10,
                width: this.platform.width() - 200,
                height: this.platform.height() - 200,
                arrowDir: this.camera.PopoverArrowDirection.ARROW_ANY
            };
            // Determine the mediaType based on the mimetypes.
            if (imageSupported && !videoSupported) {
                options.mediaType = this.camera.MediaType.PICTURE;
            }
            else if (!imageSupported && videoSupported) {
                options.mediaType = this.camera.MediaType.VIDEO;
            }
            else if (this.platform.is('ios')) {
                // Only get all media in iOS because in Android using this option allows uploading any kind of file.
                options.mediaType = this.camera.MediaType.ALLMEDIA;
            }
        }
        else if (mimetypes) {
            if (mimetypes.indexOf('image/jpeg') > -1) {
                options.encodingType = this.camera.EncodingType.JPEG;
            }
            else if (mimetypes.indexOf('image/png') > -1) {
                options.encodingType = this.camera.EncodingType.PNG;
            }
        }
        return this.camera.getPicture(options).then(function (path) {
            var error = _this.fileUploaderProvider.isInvalidMimetype(mimetypes, path); // Verify that the mimetype is supported.
            if (error) {
                return Promise.reject(error);
            }
            if (upload) {
                return _this.uploadFile(path, maxSize, true, _this.fileUploaderProvider.getCameraUploadOptions(path, fromAlbum));
            }
            else {
                // Copy or move the file to our temporary folder.
                return _this.copyToTmpFolder(path, !fromAlbum, maxSize, 'jpg');
            }
        }, function (error) {
            var defaultError = fromAlbum ? 'core.fileuploader.errorgettingimagealbum' : 'core.fileuploader.errorcapturingimage';
            return _this.treatImageError(error, defaultError);
        });
    };
    /**
     * Upload a file given the file entry.
     *
     * @param {any} fileEntry The file entry.
     * @param {boolean} deleteAfter True if the file should be deleted once treated.
     * @param {number} [maxSize] Max size of the file. If not defined or -1, no max size.
     * @param {boolean} [upload] True if the file should be uploaded, false to return the picked file.
     * @param {boolean} [allowOffline] True to allow selecting in offline, false to require connection.
     * @param {string} [name] Name to use when uploading the file. If not defined, use the file's name.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreFileUploaderHelperProvider.prototype.uploadFileEntry = function (fileEntry, deleteAfter, maxSize, upload, allowOffline, name) {
        var _this = this;
        return this.fileProvider.getFileObjectFromFileEntry(fileEntry).then(function (file) {
            return _this.uploadFileObject(file, maxSize, upload, allowOffline, name).then(function (result) {
                if (deleteAfter) {
                    // We have uploaded and deleted a copy of the file. Now delete the original one.
                    _this.fileProvider.removeFileByFileEntry(fileEntry);
                }
                return result;
            });
        });
    };
    /**
     * Upload a file given the file object.
     *
     * @param {any} file The file object.
     * @param {number} [maxSize] Max size of the file. If not defined or -1, no max size.
     * @param {boolean} [upload] True if the file should be uploaded, false to return the picked file.
     * @param {boolean} [allowOffline] True to allow selecting in offline, false to require connection.
     * @param {string} [name] Name to use when uploading the file. If not defined, use the file's name.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreFileUploaderHelperProvider.prototype.uploadFileObject = function (file, maxSize, upload, allowOffline, name) {
        var _this = this;
        if (maxSize != -1 && file.size > maxSize) {
            return this.errorMaxBytes(maxSize, file.name);
        }
        return this.confirmUploadFile(file.size, false, allowOffline).then(function () {
            // We have the data of the file to be uploaded, but not its URL (needed). Create a copy of the file to upload it.
            return _this.copyAndUploadFile(file, upload, name);
        });
    };
    /**
     * Convenience function to upload a file, allowing to retry if it fails.
     *
     * @param {string} path Absolute path of the file to upload.
     * @param {number} maxSize Max size of the upload. -1 for no max size.
     * @param {boolean} checkSize True to check size.
     * @param {CoreFileUploaderOptions} Options.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved if the file is uploaded, rejected otherwise.
     */
    CoreFileUploaderHelperProvider.prototype.uploadFile = function (path, maxSize, checkSize, options, siteId) {
        var _this = this;
        var errorStr = this.translate.instant('core.error'), retryStr = this.translate.instant('core.retry'), uploadingStr = this.translate.instant('core.fileuploader.uploading'), errorUploading = function (error) {
            // Allow the user to retry.
            return _this.domUtils.showConfirm(error, errorStr, retryStr).then(function () {
                // Try again.
                return _this.uploadFile(path, maxSize, checkSize, options, siteId);
            }, function () {
                // User cancelled. Delete the file if needed.
                if (options.deleteAfterUpload) {
                    _this.fileProvider.removeExternalFile(path);
                }
                return Promise.reject(null);
            });
        };
        var promise, file;
        if (!this.appProvider.isOnline()) {
            return errorUploading(this.translate.instant('core.fileuploader.errormustbeonlinetoupload'));
        }
        if (checkSize) {
            // Check that file size is the right one.
            promise = this.fileProvider.getExternalFile(path).then(function (fileEntry) {
                return _this.fileProvider.getFileObjectFromFileEntry(fileEntry).then(function (f) {
                    file = f;
                    return file.size;
                });
            }).catch(function () {
                // Ignore failures.
            });
        }
        else {
            promise = Promise.resolve(0);
        }
        return promise.then(function (size) {
            if (maxSize != -1 && size > maxSize) {
                return _this.errorMaxBytes(maxSize, file.name);
            }
            if (size > 0) {
                return _this.confirmUploadFile(size);
            }
        }).then(function () {
            // File isn't too large and user confirmed, let's upload.
            var modal = _this.domUtils.showModalLoading(uploadingStr);
            return _this.fileUploaderProvider.uploadFile(path, options, function (progress) {
                // Progress uploading.
                if (progress && progress.lengthComputable) {
                    var perc = Math.min((progress.loaded / progress.total) * 100, 100);
                    if (perc >= 0) {
                        modal.setContent(_this.translate.instant('core.fileuploader.uploadingperc', { $a: perc.toFixed(1) }));
                        if (modal._cmp && modal._cmp.changeDetectorRef) {
                            // Force a change detection, otherwise the content is not updated.
                            modal._cmp.changeDetectorRef.detectChanges();
                        }
                    }
                }
            }, siteId).catch(function (error) {
                _this.logger.error('Error uploading file.', error);
                modal.dismiss();
                if (typeof error != 'string') {
                    error = _this.translate.instant('core.fileuploader.errorwhileuploading');
                }
                return errorUploading(error);
            }).finally(function () {
                modal.dismiss();
            });
        });
    };
    CoreFileUploaderHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_7__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_4__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_11__fileuploader__["a" /* CoreFileUploaderProvider */], __WEBPACK_IMPORTED_MODULE_8__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_9__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_file__["a" /* CoreFileProvider */], __WEBPACK_IMPORTED_MODULE_10__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["a" /* ActionSheetController */], __WEBPACK_IMPORTED_MODULE_12__delegate__["a" /* CoreFileUploaderDelegate */],
            __WEBPACK_IMPORTED_MODULE_2__ionic_native_media_capture__["a" /* MediaCapture */], __WEBPACK_IMPORTED_MODULE_3__ionic_native_camera__["a" /* Camera */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */]])
    ], CoreFileUploaderHelperProvider);
    return CoreFileUploaderHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),

/***/ 71:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreUserProfileFieldDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__classes_delegate__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_sites__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_events__ = __webpack_require__(21);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Service to interact with user profile fields. Provides functions to register a plugin.
 */
var CoreUserProfileFieldDelegate = /** @class */ (function (_super) {
    __extends(CoreUserProfileFieldDelegate, _super);
    function CoreUserProfileFieldDelegate(loggerProvider, sitesProvider, eventsProvider) {
        var _this = _super.call(this, 'CoreUserProfileFieldDelegate', loggerProvider, sitesProvider, eventsProvider) || this;
        _this.loggerProvider = loggerProvider;
        _this.sitesProvider = sitesProvider;
        _this.eventsProvider = eventsProvider;
        _this.handlers = {};
        _this.enabledHandlers = {};
        return _this;
    }
    /**
     * Get the component to use to display an user field.
     *
     * @param  {any} field      User field to get the directive for.
     * @param  {boolean} signup         True if user is in signup page.
     * @return {any} The component to use, undefined if not found.
     */
    CoreUserProfileFieldDelegate.prototype.getComponent = function (field, signup) {
        var type = field.type || field.datatype;
        if (signup) {
            return this.executeFunction(type, 'getComponent');
        }
        else {
            return this.executeFunctionOnEnabled(type, 'getComponent');
        }
    };
    /**
     * Get the data to send for a certain field based on the input data.
     *
     * @param  {any}     field          User field to get the data for.
     * @param  {boolean} signup         True if user is in signup page.
     * @param  {string}  registerAuth   Register auth method. E.g. 'email'.
     * @param  {any}     formValues     Form values.
     * @return {Promise<any>}           Data to send for the field.
     */
    CoreUserProfileFieldDelegate.prototype.getDataForField = function (field, signup, registerAuth, formValues) {
        var type = field.type || field.datatype, handler = this.getHandler(type, !signup);
        if (handler) {
            var name_1 = 'profile_field_' + field.shortname;
            if (handler.getData) {
                return Promise.resolve(handler.getData(field, signup, registerAuth, formValues));
            }
            else if (field.shortname && typeof formValues[name_1] != 'undefined') {
                // Handler doesn't implement the function, but the form has data for the field.
                return Promise.resolve({
                    type: type,
                    name: name_1,
                    value: formValues[name_1]
                });
            }
        }
        return Promise.reject(null);
    };
    /**
     * Get the data to send for a list of fields based on the input data.
     *
     * @param  {any[]}   fields           User fields to get the data for.
     * @param  {boolean} [signup]       True if user is in signup page.
     * @param  {string}  [registerAuth] Register auth method. E.g. 'email'.
     * @param  {any}     formValues     Form values.
     * @return {Promise<any>}           Data to send.
     */
    CoreUserProfileFieldDelegate.prototype.getDataForFields = function (fields, signup, registerAuth, formValues) {
        var _this = this;
        if (signup === void 0) { signup = false; }
        if (registerAuth === void 0) { registerAuth = ''; }
        var result = [], promises = [];
        fields.forEach(function (field) {
            promises.push(_this.getDataForField(field, signup, registerAuth, formValues).then(function (data) {
                if (data) {
                    result.push(data);
                }
            }).catch(function () {
                // Ignore errors.
            }));
        });
        return Promise.all(promises).then(function () {
            return result;
        });
    };
    CoreUserProfileFieldDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_events__["a" /* CoreEventsProvider */]])
    ], CoreUserProfileFieldDelegate);
    return CoreUserProfileFieldDelegate;
}(__WEBPACK_IMPORTED_MODULE_1__classes_delegate__["a" /* CoreDelegate */]));

//# sourceMappingURL=user-profile-field-delegate.js.map

/***/ }),

/***/ 8:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSitesProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__app__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__events__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__sites_factory__ = __webpack_require__(539);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__utils_url__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__core_constants__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__configconstants__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_ts_md5_dist_md5__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_ts_md5_dist_md5___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_ts_md5_dist_md5__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};












/*
 * Service to manage and interact with sites.
 * It allows creating tables in the databases of all sites. Each service or component should be responsible of creating
 * their own database tables. Example:
 *
 * constructor(sitesProvider: CoreSitesProvider) {
 *     this.sitesProvider.createTableFromSchema(this.tableSchema);
 *
 * This provider will automatically create the tables in the databases of all the instantiated sites, and also to the
 * databases of sites instantiated from now on.
*/
var CoreSitesProvider = /** @class */ (function () {
    function CoreSitesProvider(logger, http, sitesFactory, appProvider, utils, translate, eventsProvider, urlUtils) {
        this.http = http;
        this.sitesFactory = sitesFactory;
        this.appProvider = appProvider;
        this.utils = utils;
        this.translate = translate;
        this.eventsProvider = eventsProvider;
        this.urlUtils = urlUtils;
        // Variables for the database.
        this.SITES_TABLE = 'sites';
        this.CURRENT_SITE_TABLE = 'current_site';
        this.appTablesSchema = [
            {
                name: this.SITES_TABLE,
                columns: [
                    {
                        name: 'id',
                        type: 'TEXT',
                        primaryKey: true
                    },
                    {
                        name: 'siteUrl',
                        type: 'TEXT',
                        notNull: true
                    },
                    {
                        name: 'token',
                        type: 'TEXT'
                    },
                    {
                        name: 'info',
                        type: 'TEXT'
                    },
                    {
                        name: 'privateToken',
                        type: 'TEXT'
                    },
                    {
                        name: 'config',
                        type: 'TEXT'
                    },
                    {
                        name: 'loggedOut',
                        type: 'INTEGER'
                    }
                ]
            },
            {
                name: this.CURRENT_SITE_TABLE,
                columns: [
                    {
                        name: 'id',
                        type: 'INTEGER',
                        primaryKey: true
                    },
                    {
                        name: 'siteId',
                        type: 'TEXT',
                        notNull: true,
                        unique: true
                    }
                ]
            }
        ];
        // Constants to validate a site version.
        this.VALID_VERSION = 1;
        this.LEGACY_APP_VERSION = 0;
        this.INVALID_VERSION = -1;
        this.services = {};
        this.sessionRestored = false;
        this.sites = {};
        this.siteTablesSchemas = []; // Schemas for site tables. Other providers can add schemas in here.
        this.logger = logger.getInstance('CoreSitesProvider');
        this.appDB = appProvider.getDB();
        this.appDB.createTablesFromSchema(this.appTablesSchema);
    }
    /**
     * Get the demo data for a certain "name" if it is a demo site.
     *
     * @param {string} name Name of the site to check.
     * @return {any} Site data if it's a demo site, undefined otherwise.
     */
    CoreSitesProvider.prototype.getDemoSiteData = function (name) {
        var demoSites = __WEBPACK_IMPORTED_MODULE_10__configconstants__["a" /* CoreConfigConstants */].demo_sites;
        if (typeof demoSites != 'undefined' && typeof demoSites[name] != 'undefined') {
            return demoSites[name];
        }
    };
    /**
     * Check if a site is valid and if it has specifics settings for authentication (like force to log in using the browser).
     * It will test both protocols if the first one fails: http and https.
     *
     * @param {string} siteUrl URL of the site to check.
     * @param {string} [protocol=https://] Protocol to use first.
     * @return {Promise<CoreSiteCheckResponse>} A promise resolved when the site is checked.
     */
    CoreSitesProvider.prototype.checkSite = function (siteUrl, protocol) {
        var _this = this;
        if (protocol === void 0) { protocol = 'https://'; }
        // The formatURL function adds the protocol if is missing.
        siteUrl = this.urlUtils.formatURL(siteUrl);
        if (!this.urlUtils.isHttpURL(siteUrl)) {
            return Promise.reject(this.translate.instant('core.login.invalidsite'));
        }
        else if (!this.appProvider.isOnline()) {
            return Promise.reject(this.translate.instant('core.networkerrormsg'));
        }
        else {
            return this.checkSiteWithProtocol(siteUrl, protocol).catch(function (error) {
                // Do not continue checking if a critical error happened.
                if (error.critical) {
                    return Promise.reject(error.error);
                }
                // Retry with the other protocol.
                protocol = protocol == 'https://' ? 'http://' : 'https://';
                return _this.checkSiteWithProtocol(siteUrl, protocol).catch(function (secondError) {
                    // Site doesn't exist.
                    if (secondError.error) {
                        return Promise.reject(secondError.error);
                    }
                    else if (error.error) {
                        return Promise.reject(error.error);
                    }
                    return Promise.reject(_this.translate.instant('core.login.checksiteversion'));
                });
            });
        }
    };
    /**
     * Helper function to check if a site is valid and if it has specifics settings for authentication.
     *
     * @param {string} siteUrl URL of the site to check.
     * @param {string} protocol Protocol to use.
     * @return {Promise<CoreSiteCheckResponse>} A promise resolved when the site is checked.
     */
    CoreSitesProvider.prototype.checkSiteWithProtocol = function (siteUrl, protocol) {
        var _this = this;
        var publicConfig;
        // Now, replace the siteUrl with the protocol.
        siteUrl = siteUrl.replace(/^http(s)?\:\/\//i, protocol);
        return this.siteExists(siteUrl).catch(function (error) {
            // Do not continue checking if WS are not enabled.
            if (error.errorcode && error.errorcode == 'enablewsdescription') {
                return rejectWithCriticalError(error.error, error.errorcode);
            }
            // Site doesn't exist. Try to add or remove 'www'.
            var treatedUrl = _this.urlUtils.addOrRemoveWWW(siteUrl);
            return _this.siteExists(treatedUrl).then(function () {
                // Success, use this new URL as site url.
                siteUrl = treatedUrl;
            }).catch(function (secondError) {
                // Do not continue checking if WS are not enabled.
                if (secondError.errorcode && secondError.errorcode == 'enablewsdescription') {
                    return rejectWithCriticalError(secondError.error, secondError.errorcode);
                }
                error = secondError || error;
                return Promise.reject({ error: typeof error == 'object' ? error.error : error });
            });
        }).then(function () {
            // Create a temporary site to check if local_mobile is installed.
            var temporarySite = _this.sitesFactory.makeSite(undefined, siteUrl);
            return temporarySite.checkLocalMobilePlugin().then(function (data) {
                data.service = data.service || __WEBPACK_IMPORTED_MODULE_10__configconstants__["a" /* CoreConfigConstants */].wsservice;
                _this.services[siteUrl] = data.service; // No need to store it in DB.
                if (data.coreSupported ||
                    (data.code != __WEBPACK_IMPORTED_MODULE_9__core_constants__["a" /* CoreConstants */].LOGIN_SSO_CODE && data.code != __WEBPACK_IMPORTED_MODULE_9__core_constants__["a" /* CoreConstants */].LOGIN_SSO_INAPP_CODE)) {
                    // SSO using local_mobile not needed, try to get the site public config.
                    return temporarySite.getPublicConfig().then(function (config) {
                        publicConfig = config;
                        // Check that the user can authenticate.
                        if (!config.enablewebservices) {
                            return rejectWithCriticalError(_this.translate.instant('core.login.webservicesnotenabled'));
                        }
                        else if (!config.enablemobilewebservice) {
                            return rejectWithCriticalError(_this.translate.instant('core.login.mobileservicesnotenabled'));
                        }
                        else if (config.maintenanceenabled) {
                            var message = _this.translate.instant('core.sitemaintenance');
                            if (config.maintenancemessage) {
                                message += config.maintenancemessage;
                            }
                            return rejectWithCriticalError(message);
                        }
                        // Everything ok.
                        if (data.code === 0) {
                            data.code = config.typeoflogin;
                        }
                        return data;
                    }, function (error) {
                        // Error, check if not supported.
                        if (error.available === 1) {
                            // Service supported but an error happened. Return error.
                            return Promise.reject({ error: error.error });
                        }
                        return data;
                    });
                }
                return data;
            }).then(function (data) {
                siteUrl = temporarySite.getURL();
                return { siteUrl: siteUrl, code: data.code, warning: data.warning, service: data.service, config: publicConfig };
            });
        });
        // Return a rejected promise with a "critical" error.
        function rejectWithCriticalError(message, errorCode) {
            return Promise.reject({
                error: message,
                errorcode: errorCode,
                critical: true
            });
        }
    };
    /**
     * Check if a site exists.
     *
     * @param  {string} siteUrl URL of the site to check.
     * @return {Promise} A promise to be resolved if the site exists.
     */
    CoreSitesProvider.prototype.siteExists = function (siteUrl) {
        var data = {};
        if (!this.appProvider.isMobile()) {
            // Send fake parameters for CORS. This is only needed in browser.
            data.username = 'a';
            data.password = 'b';
            data.service = 'c';
        }
        var observable = this.http.post(siteUrl + '/login/token.php', data).timeout(__WEBPACK_IMPORTED_MODULE_9__core_constants__["a" /* CoreConstants */].WS_TIMEOUT);
        return this.utils.observableToPromise(observable).catch(function (error) {
            return Promise.reject(error.message);
        }).then(function (data) {
            if (data.errorcode && (data.errorcode == 'enablewsdescription' || data.errorcode == 'requirecorrectaccess')) {
                return Promise.reject({ errorcode: data.errorcode, error: data.error });
            }
            else if (data.error && data.error == 'Web services must be enabled in Advanced features.') {
                return Promise.reject({ errorcode: 'enablewsdescription', error: data.error });
            }
            // Other errors are not being checked because invalid login will be always raised and we cannot differ them.
        });
    };
    /**
     * Gets a user token from the server.
     *
     * @param {string} siteUrl The site url.
     * @param {string} username User name.
     * @param {string} password Password.
     * @param {string} [service] Service to use. If not defined, it will be searched in memory.
     * @param {boolean} [retry] Whether we are retrying with a prefixed URL.
     * @return {Promise<CoreSiteUserTokenResponse>} A promise resolved when the token is retrieved.
     */
    CoreSitesProvider.prototype.getUserToken = function (siteUrl, username, password, service, retry) {
        var _this = this;
        if (!this.appProvider.isOnline()) {
            return Promise.reject(this.translate.instant('core.networkerrormsg'));
        }
        if (!service) {
            service = this.determineService(siteUrl);
        }
        var params = {
            username: username,
            password: password,
            service: service
        }, observable = this.http.post(siteUrl + '/login/token.php', params).timeout(__WEBPACK_IMPORTED_MODULE_9__core_constants__["a" /* CoreConstants */].WS_TIMEOUT);
        return this.utils.observableToPromise(observable).then(function (data) {
            if (typeof data == 'undefined') {
                return Promise.reject(_this.translate.instant('core.cannotconnect'));
            }
            else {
                if (typeof data.token != 'undefined') {
                    return { token: data.token, siteUrl: siteUrl, privateToken: data.privatetoken };
                }
                else {
                    if (typeof data.error != 'undefined') {
                        // We only allow one retry (to avoid loops).
                        if (!retry && data.errorcode == 'requirecorrectaccess') {
                            siteUrl = _this.urlUtils.addOrRemoveWWW(siteUrl);
                            return _this.getUserToken(siteUrl, username, password, service, true);
                        }
                        else if (typeof data.errorcode != 'undefined') {
                            return Promise.reject({ error: data.error, errorcode: data.errorcode });
                        }
                        else {
                            return Promise.reject(data.error);
                        }
                    }
                    else {
                        return Promise.reject(_this.translate.instant('core.login.invalidaccount'));
                    }
                }
            }
        }, function () {
            return Promise.reject(_this.translate.instant('core.cannotconnect'));
        });
    };
    /**
     * Add a new site to the site list and authenticate the user in this site.
     *
     * @param {string} siteUrl The site url.
     * @param {string} token User's token.
     * @param {string} [privateToken=''] User's private token.
     * @return {Promise<any>} A promise resolved when the site is added and the user is authenticated.
     */
    CoreSitesProvider.prototype.newSite = function (siteUrl, token, privateToken) {
        var _this = this;
        if (privateToken === void 0) { privateToken = ''; }
        // Create a "candidate" site to fetch the site info.
        var candidateSite = this.sitesFactory.makeSite(undefined, siteUrl, token, undefined, privateToken);
        return candidateSite.fetchSiteInfo().then(function (info) {
            var result = _this.isValidMoodleVersion(info);
            if (result == _this.VALID_VERSION) {
                // Set site ID and info.
                var siteId_1 = _this.createSiteID(info.siteurl, info.username);
                candidateSite.setId(siteId_1);
                candidateSite.setInfo(info);
                // Try to get the site config.
                return _this.getSiteConfig(candidateSite).then(function (config) {
                    candidateSite.setConfig(config);
                    // Add site to sites list.
                    _this.addSite(siteId_1, siteUrl, token, info, privateToken, config);
                    // Turn candidate site into current site.
                    _this.currentSite = candidateSite;
                    _this.sites[siteId_1] = candidateSite;
                    // Store session.
                    _this.login(siteId_1);
                    _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_4__events__["a" /* CoreEventsProvider */].SITE_ADDED, {}, siteId_1);
                    if (_this.siteTablesSchemas.length) {
                        // Create tables in the site's database.
                        candidateSite.getDb().createTablesFromSchema(_this.siteTablesSchemas);
                    }
                    return siteId_1;
                });
            }
            else if (result == _this.LEGACY_APP_VERSION) {
                return Promise.reject(_this.translate.instant('core.login.legacymoodleversion'));
            }
            else {
                return Promise.reject(_this.translate.instant('core.login.invalidmoodleversion'));
            }
        });
    };
    /**
     * Create a site ID based on site URL and username.
     *
     * @param {string} siteUrl The site url.
     * @param {string} username Username.
     * @return {string} Site ID.
     */
    CoreSitesProvider.prototype.createSiteID = function (siteUrl, username) {
        return __WEBPACK_IMPORTED_MODULE_11_ts_md5_dist_md5__["Md5"].hashAsciiStr(siteUrl + username);
    };
    /**
     * Function for determine which service we should use (default or extended plugin).
     *
     * @param {string} siteUrl The site URL.
     * @return {string} The service shortname.
     */
    CoreSitesProvider.prototype.determineService = function (siteUrl) {
        // We need to try siteUrl in both https or http (due to loginhttps setting).
        // First http://
        siteUrl = siteUrl.replace('https://', 'http://');
        if (this.services[siteUrl]) {
            return this.services[siteUrl];
        }
        // Now https://
        siteUrl = siteUrl.replace('http://', 'https://');
        if (this.services[siteUrl]) {
            return this.services[siteUrl];
        }
        // Return default service.
        return __WEBPACK_IMPORTED_MODULE_10__configconstants__["a" /* CoreConfigConstants */].wsservice;
    };
    /**
     * Check for the minimum required version.
     *
     * @param {any} info Site info.
     * @return {number} Either VALID_VERSION, LEGACY_APP_VERSION or INVALID_VERSION.
     */
    CoreSitesProvider.prototype.isValidMoodleVersion = function (info) {
        if (!info) {
            return this.INVALID_VERSION;
        }
        var version24 = 2012120300, // Moodle 2.4 version.
        release24 = '2.4', version31 = 2016052300, release31 = '3.1';
        // Try to validate by version.
        if (info.version) {
            var version = parseInt(info.version, 10);
            if (!isNaN(version)) {
                if (version >= version31) {
                    return this.VALID_VERSION;
                }
                else if (version >= version24) {
                    return this.LEGACY_APP_VERSION;
                }
                else {
                    return this.INVALID_VERSION;
                }
            }
        }
        // We couldn't validate by version number. Let's try to validate by release number.
        if (info.release) {
            var matches = info.release.match(/^([\d|\.]*)/);
            if (matches && matches.length > 1) {
                if (matches[1] >= release31) {
                    return this.VALID_VERSION;
                }
                else if (matches[1] >= release24) {
                    return this.LEGACY_APP_VERSION;
                }
                else {
                    return this.INVALID_VERSION;
                }
            }
        }
        // Couldn't validate it.
        return this.INVALID_VERSION;
    };
    /**
     * Check if site info is valid. If it's not, return error message.
     *
     * @param {any} info Site info.
     * @return {any} True if valid, object with error message to show and its params if not valid.
     */
    CoreSitesProvider.prototype.validateSiteInfo = function (info) {
        if (!info.firstname || !info.lastname) {
            var moodleLink = "<a core-link href=\"" + info.siteurl + "\">" + info.siteurl + "</a>";
            return { error: 'core.requireduserdatamissing', params: { $a: moodleLink } };
        }
        return true;
    };
    /**
     * Saves a site in local DB.
     *
     * @param {string} id Site ID.
     * @param {string} siteUrl Site URL.
     * @param {string} token User's token in the site.
     * @param {any} info Site's info.
     * @param {string} [privateToken=''] User's private token.
     * @param {any} [config] Site config (from tool_mobile_get_config).
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreSitesProvider.prototype.addSite = function (id, siteUrl, token, info, privateToken, config) {
        if (privateToken === void 0) { privateToken = ''; }
        var entry = {
            id: id,
            siteUrl: siteUrl,
            token: token,
            info: info ? JSON.stringify(info) : info,
            privateToken: privateToken,
            config: config ? JSON.stringify(config) : config,
            loggedOut: 0
        };
        return this.appDB.insertOrUpdateRecord(this.SITES_TABLE, entry, { id: id });
    };
    /**
     * Login a user to a site from the list of sites.
     *
     * @param {string} siteId ID of the site to load.
     * @return {Promise}      Promise to be resolved when the site is loaded.
     */
    CoreSitesProvider.prototype.loadSite = function (siteId) {
        var _this = this;
        this.logger.debug("Load site " + siteId);
        return this.getSite(siteId).then(function (site) {
            _this.currentSite = site;
            _this.login(siteId);
            if (site.isLoggedOut()) {
                // Logged out, nothing else to do.
                return;
            }
            // Check if local_mobile was installed to Moodle.
            return site.checkIfLocalMobileInstalledAndNotUsed().then(function () {
                // Local mobile was added. Throw invalid session to force reconnect and create a new token.
                _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_4__events__["a" /* CoreEventsProvider */].SESSION_EXPIRED, {}, siteId);
            }, function () {
                // Update site info. We don't block the UI.
                _this.updateSiteInfo(siteId);
            });
        });
    };
    /**
     * Get current site.
     *
     * @return {CoreSite} Current site.
     */
    CoreSitesProvider.prototype.getCurrentSite = function () {
        return this.currentSite;
    };
    /**
     * Get current site ID.
     *
     * @return {string} Current site ID.
     */
    CoreSitesProvider.prototype.getCurrentSiteId = function () {
        if (this.currentSite) {
            return this.currentSite.getId();
        }
        else {
            return '';
        }
    };
    /**
     * Get the site home ID of the current site.
     *
     * @return {number} Current site home ID.
     */
    CoreSitesProvider.prototype.getCurrentSiteHomeId = function () {
        if (this.currentSite) {
            return this.currentSite.getSiteHomeId();
        }
        else {
            return 1;
        }
    };
    /**
     * Check if the user is logged in a site.
     *
     * @return {boolean} Whether the user is logged in a site.
     */
    CoreSitesProvider.prototype.isLoggedIn = function () {
        return typeof this.currentSite != 'undefined' && typeof this.currentSite.token != 'undefined' &&
            this.currentSite.token != '';
    };
    /**
     * Delete a site from the sites list.
     *
     * @param {string} siteId ID of the site to delete.
     * @return {Promise<any>} Promise to be resolved when the site is deleted.
     */
    CoreSitesProvider.prototype.deleteSite = function (siteId) {
        var _this = this;
        this.logger.debug("Delete site " + siteId);
        if (typeof this.currentSite != 'undefined' && this.currentSite.id == siteId) {
            this.logout();
        }
        return this.getSite(siteId).then(function (site) {
            return site.deleteDB().then(function () {
                // Site DB deleted, now delete the app from the list of sites.
                delete _this.sites[siteId];
                return _this.appDB.deleteRecords(_this.SITES_TABLE, { id: siteId }).then(function () {
                    // Site deleted from sites list, now delete the folder.
                    return site.deleteFolder();
                }, function () {
                    // DB remove shouldn't fail, but we'll go ahead even if it does.
                    return site.deleteFolder();
                }).then(function () {
                    _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_4__events__["a" /* CoreEventsProvider */].SITE_DELETED, site, siteId);
                });
            });
        });
    };
    /**
     * Check if there are no sites stored.
     *
     * @return {Promise<void>} Promise resolved if there are no sites, and rejected if there is at least one.
     */
    CoreSitesProvider.prototype.hasNoSites = function () {
        return this.appDB.countRecords(this.SITES_TABLE).then(function (count) {
            if (count > 0) {
                return Promise.reject(null);
            }
        });
    };
    /**
     * Check if there are sites stored.
     *
     * @return {Promise<void>} Promise resolved if there is at least one site, and rejected if there aren't.
     */
    CoreSitesProvider.prototype.hasSites = function () {
        return this.appDB.countRecords(this.SITES_TABLE).then(function (count) {
            if (count == 0) {
                return Promise.reject(null);
            }
        });
    };
    /**
     * Returns a site object.
     *
     * @param {string} [siteId] The site ID. If not defined, current site (if available).
     * @return {Promise<CoreSite>} Promise resolved with the site.
     */
    CoreSitesProvider.prototype.getSite = function (siteId) {
        var _this = this;
        if (!siteId) {
            return this.currentSite ? Promise.resolve(this.currentSite) : Promise.reject(null);
        }
        else if (this.currentSite && this.currentSite.getId() == siteId) {
            return Promise.resolve(this.currentSite);
        }
        else if (typeof this.sites[siteId] != 'undefined') {
            return Promise.resolve(this.sites[siteId]);
        }
        else {
            // Retrieve and create the site.
            return this.appDB.getRecord(this.SITES_TABLE, { id: siteId }).then(function (data) {
                return _this.makeSiteFromSiteListEntry(data);
            });
        }
    };
    /**
     * Create a site from an entry of the sites list DB. The new site is added to the list of "cached" sites: this.sites.
     *
     * @param {any} entry Site list entry.
     * @return {CoreSite} Created site.
     */
    CoreSitesProvider.prototype.makeSiteFromSiteListEntry = function (entry) {
        var site, info = entry.info, config = entry.config;
        // Try to parse info and config.
        try {
            info = info ? JSON.parse(info) : info;
        }
        catch (ex) {
            // Ignore errors.
        }
        try {
            config = config ? JSON.parse(config) : config;
        }
        catch (ex) {
            // Ignore errors.
        }
        site = this.sitesFactory.makeSite(entry.id, entry.siteUrl, entry.token, info, entry.privateToken, config, entry.loggedOut == 1);
        this.sites[entry.id] = site;
        if (this.siteTablesSchemas.length) {
            // Create tables in the site's database.
            site.getDb().createTablesFromSchema(this.siteTablesSchemas);
        }
        return site;
    };
    /**
     * Returns if the site is the current one.
     *
     * @param {string|CoreSite} [site] Site object or siteId to be compared. If not defined, use current site.
     * @return {boolean} Whether site or siteId is the current one.
     */
    CoreSitesProvider.prototype.isCurrentSite = function (site) {
        if (!site || !this.currentSite) {
            return !!this.currentSite;
        }
        var siteId = typeof site == 'object' ? site.getId() : site;
        return this.currentSite.getId() === siteId;
    };
    /**
     * Returns the database object of a site.
     *
     * @param {string} [siteId] The site ID. If not defined, current site (if available).
     * @return {Promise<SQLiteDB>} Promise resolved with the database.
     */
    CoreSitesProvider.prototype.getSiteDb = function (siteId) {
        return this.getSite(siteId).then(function (site) {
            return site.getDb();
        });
    };
    /**
     * Returns the site home ID of a site.
     *
     * @param  {number} [siteId] The site ID. If not defined, current site (if available).
     * @return {Promise}         Promise resolved with site home ID.
     */
    CoreSitesProvider.prototype.getSiteHomeId = function (siteId) {
        return this.getSite(siteId).then(function (site) {
            return site.getSiteHomeId();
        });
    };
    /**
     * Get the list of sites stored.
     *
     * @param {String[]} [ids] IDs of the sites to get. If not defined, return all sites.
     * @return {Promise<CoreSiteBasicInfo[]>} Promise resolved when the sites are retrieved.
     */
    CoreSitesProvider.prototype.getSites = function (ids) {
        return this.appDB.getAllRecords(this.SITES_TABLE).then(function (sites) {
            var formattedSites = [];
            sites.forEach(function (site) {
                if (!ids || ids.indexOf(site.id) > -1) {
                    // Try to parse info.
                    var siteInfo = site.info;
                    try {
                        siteInfo = siteInfo ? JSON.parse(siteInfo) : siteInfo;
                    }
                    catch (ex) {
                        // Ignore errors.
                    }
                    var basicInfo = {
                        id: site.id,
                        siteUrl: site.siteUrl,
                        fullName: siteInfo && siteInfo.fullname,
                        siteName: siteInfo && siteInfo.sitename,
                        avatar: siteInfo && siteInfo.userpictureurl
                    };
                    formattedSites.push(basicInfo);
                }
            });
            return formattedSites;
        });
    };
    /**
     * Get the list of IDs of sites stored.
     *
     * @return {Promise<string[]>} Promise resolved when the sites IDs are retrieved.
     */
    CoreSitesProvider.prototype.getSitesIds = function () {
        return this.appDB.getAllRecords(this.SITES_TABLE).then(function (sites) {
            return sites.map(function (site) {
                return site.id;
            });
        });
    };
    /**
     * Login the user in a site.
     *
     * @param {string} siteid ID of the site the user is accessing.
     * @return {Promise<void>} Promise resolved when current site is stored.
     */
    CoreSitesProvider.prototype.login = function (siteId) {
        var _this = this;
        var entry = {
            id: 1,
            siteId: siteId
        };
        return this.appDB.insertOrUpdateRecord(this.CURRENT_SITE_TABLE, entry, { id: 1 }).then(function () {
            _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_4__events__["a" /* CoreEventsProvider */].LOGIN, {}, siteId);
        });
    };
    /**
     * Logout the user.
     *
     * @return {Promise<any>} Promise resolved when the user is logged out.
     */
    CoreSitesProvider.prototype.logout = function () {
        var _this = this;
        if (!this.currentSite) {
            // Already logged out.
            return Promise.resolve();
        }
        var siteId = this.currentSite.getId(), siteConfig = this.currentSite.getStoredConfig(), promises = [];
        this.currentSite = undefined;
        if (siteConfig && siteConfig.tool_mobile_forcelogout == '1') {
            promises.push(this.setSiteLoggedOut(siteId, true));
        }
        promises.push(this.appDB.deleteRecords(this.CURRENT_SITE_TABLE, { id: 1 }));
        return Promise.all(promises).finally(function () {
            _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_4__events__["a" /* CoreEventsProvider */].LOGOUT, {}, siteId);
        });
    };
    /**
     * Restores the session to the previous one so the user doesn't has to login everytime the app is started.
     *
     * @return {Promise<any>} Promise resolved if a session is restored.
     */
    CoreSitesProvider.prototype.restoreSession = function () {
        var _this = this;
        if (this.sessionRestored) {
            return Promise.reject(null);
        }
        this.sessionRestored = true;
        return this.appDB.getRecord(this.CURRENT_SITE_TABLE, { id: 1 }).then(function (currentSite) {
            var siteId = currentSite.siteId;
            _this.logger.debug("Restore session in site " + siteId);
            return _this.loadSite(siteId);
        });
    };
    /**
     * Mark or unmark a site as logged out so the user needs to authenticate again.
     *
     * @param {string} siteId ID of the site.
     * @param {boolean} loggedOut True to set the site as logged out, false otherwise.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreSitesProvider.prototype.setSiteLoggedOut = function (siteId, loggedOut) {
        var _this = this;
        return this.getSite(siteId).then(function (site) {
            var newValues = {
                token: '',
                loggedOut: loggedOut ? 1 : 0
            };
            site.setLoggedOut(loggedOut);
            return _this.appDB.updateRecords(_this.SITES_TABLE, newValues, { id: siteId });
        });
    };
    /**
     * Updates a site's token.
     *
     * @param {string} siteUrl Site's URL.
     * @param {string} username Username.
     * @param {string} token User's new token.
     * @param {string} [privateToken=''] User's private token.
     * @return {Promise<any>} A promise resolved when the site is updated.
     */
    CoreSitesProvider.prototype.updateSiteToken = function (siteUrl, username, token, privateToken) {
        if (privateToken === void 0) { privateToken = ''; }
        var siteId = this.createSiteID(siteUrl, username);
        return this.updateSiteTokenBySiteId(siteId, token, privateToken);
    };
    /**
     * Updates a site's token using siteId.
     *
     * @param {string} siteId Site Id.
     * @param {string} token User's new token.
     * @param {string} [privateToken=''] User's private token.
     * @return {Promise<any>} A promise resolved when the site is updated.
     */
    CoreSitesProvider.prototype.updateSiteTokenBySiteId = function (siteId, token, privateToken) {
        var _this = this;
        if (privateToken === void 0) { privateToken = ''; }
        return this.getSite(siteId).then(function (site) {
            var newValues = {
                token: token,
                privateToken: privateToken,
                loggedOut: 0
            };
            site.token = token;
            site.privateToken = privateToken;
            site.setLoggedOut(false); // Token updated means the user authenticated again, not logged out anymore.
            return _this.appDB.updateRecords(_this.SITES_TABLE, newValues, { id: siteId });
        });
    };
    /**
     * Updates a site's info.
     *
     * @param {string} siteid Site's ID.
     * @return {Promise<any>} A promise resolved when the site is updated.
     */
    CoreSitesProvider.prototype.updateSiteInfo = function (siteId) {
        var _this = this;
        return this.getSite(siteId).then(function (site) {
            return site.fetchSiteInfo().then(function (info) {
                site.setInfo(info);
                // Try to get the site config.
                return _this.getSiteConfig(site).catch(function () {
                    // Error getting config, keep the current one.
                }).then(function (config) {
                    var newValues = {
                        info: JSON.stringify(info),
                        loggedOut: site.isLoggedOut() ? 1 : 0
                    };
                    if (typeof config != 'undefined') {
                        site.setConfig(config);
                        newValues.config = JSON.stringify(config);
                    }
                    return _this.appDB.updateRecords(_this.SITES_TABLE, newValues, { id: siteId }).finally(function () {
                        _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_4__events__["a" /* CoreEventsProvider */].SITE_UPDATED, {}, siteId);
                    });
                });
            });
        });
    };
    /**
     * Updates a site's info.
     *
     * @param {string} siteUrl  Site's URL.
     * @param {string} username Username.
     * @return {Promise<any>} A promise to be resolved when the site is updated.
     */
    CoreSitesProvider.prototype.updateSiteInfoByUrl = function (siteUrl, username) {
        var siteId = this.createSiteID(siteUrl, username);
        return this.updateSiteInfo(siteId);
    };
    /**
     * Get the site IDs a URL belongs to.
     * Someone can have more than one account in the same site, that's why this function returns an array of IDs.
     *
     * @param {string} url URL to check.
     * @param {boolean} [prioritize] True if it should prioritize current site. If the URL belongs to current site then it won't
     *                               check any other site, it will only return current site.
     * @param {string} [username] If set, it will return only the sites where the current user has this username.
     * @return {Promise<string[]>} Promise resolved with the site IDs (array).
     */
    CoreSitesProvider.prototype.getSiteIdsFromUrl = function (url, prioritize, username) {
        var _this = this;
        // If prioritize is true, check current site first.
        if (prioritize && this.currentSite && this.currentSite.containsUrl(url)) {
            if (!username || this.currentSite.getInfo().username == username) {
                return Promise.resolve([this.currentSite.getId()]);
            }
        }
        // Check if URL has http(s) protocol.
        if (!url.match(/^https?:\/\//i)) {
            // URL doesn't have http(s) protocol. Check if it has any protocol.
            if (this.urlUtils.isAbsoluteURL(url)) {
                // It has some protocol. Return empty array.
                return Promise.resolve([]);
            }
            else {
                // No protocol, probably a relative URL. Return current site.
                if (this.currentSite) {
                    return Promise.resolve([this.currentSite.getId()]);
                }
                else {
                    return Promise.resolve([]);
                }
            }
        }
        return this.appDB.getAllRecords(this.SITES_TABLE).then(function (siteEntries) {
            var ids = [];
            siteEntries.forEach(function (site) {
                if (!_this.sites[site.id]) {
                    _this.makeSiteFromSiteListEntry(site);
                }
                if (_this.sites[site.id].containsUrl(url)) {
                    if (!username || _this.sites[site.id].getInfo().username == username) {
                        ids.push(site.id);
                    }
                }
            });
            return ids;
        }).catch(function () {
            // Shouldn't happen.
            return [];
        });
    };
    /**
     * Get the site ID stored in DB as current site.
     *
     * @return {Promise<string>} Promise resolved with the site ID.
     */
    CoreSitesProvider.prototype.getStoredCurrentSiteId = function () {
        return this.appDB.getRecord(this.CURRENT_SITE_TABLE, { id: 1 }).then(function (currentSite) {
            return currentSite.siteId;
        });
    };
    /**
     * Get the public config of a certain site.
     *
     * @param {string} siteUrl URL of the site.
     * @return {Promise<any>} Promise resolved with the public config.
     */
    CoreSitesProvider.prototype.getSitePublicConfig = function (siteUrl) {
        var temporarySite = this.sitesFactory.makeSite(undefined, siteUrl);
        return temporarySite.getPublicConfig();
    };
    /**
     * Get site config.
     *
     * @param {any} site The site to get the config.
     * @return {Promise<any>} Promise resolved with config if available.
     */
    CoreSitesProvider.prototype.getSiteConfig = function (site) {
        if (!site.wsAvailable('tool_mobile_get_config')) {
            // WS not available, cannot get config.
            return Promise.resolve();
        }
        return site.getConfig(undefined, true);
    };
    /**
     * Check if a certain feature is disabled in a site.
     *
     * @param {string} name Name of the feature to check.
     * @param {string} [siteId] The site ID. If not defined, current site (if available).
     * @return {Promise<boolean>} Promise resolved with true if disabled.
     */
    CoreSitesProvider.prototype.isFeatureDisabled = function (name, siteId) {
        return this.getSite(siteId).then(function (site) {
            return site.isFeatureDisabled(name);
        });
    };
    /**
     * Create a table in all the sites databases.
     *
     * @param {any} table Table schema.
     */
    CoreSitesProvider.prototype.createTableFromSchema = function (table) {
        this.createTablesFromSchema([table]);
    };
    /**
     * Create several tables in all the sites databases.
     *
     * @param {any[]} tables List of tables schema.
     */
    CoreSitesProvider.prototype.createTablesFromSchema = function (tables) {
        // Add the tables to the list of schemas. This list is to create all the tables in new sites.
        this.siteTablesSchemas = this.siteTablesSchemas.concat(tables);
        // Now create these tables in current sites.
        for (var id in this.sites) {
            this.sites[id].getDb().createTablesFromSchema(tables);
        }
    };
    CoreSitesProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["b" /* HttpClient */], __WEBPACK_IMPORTED_MODULE_6__sites_factory__["a" /* CoreSitesFactoryProvider */],
            __WEBPACK_IMPORTED_MODULE_3__app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_8__utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_4__events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_7__utils_url__["a" /* CoreUrlUtilsProvider */]])
    ], CoreSitesProvider);
    return CoreSitesProvider;
}());

//# sourceMappingURL=sites.js.map

/***/ }),

/***/ 84:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreContentLinksHandlerBase; });
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * Base handler to be registered in CoreContentLinksHandler. It is useful to minimize the amount of
 * functions that handlers need to implement.
 *
 * It allows you to specify a "pattern" (RegExp) that will be used to check if the handler handles a URL and to get its site URL.
 */
var CoreContentLinksHandlerBase = /** @class */ (function () {
    function CoreContentLinksHandlerBase() {
        /**
         * A name to identify the handler.
         * @type {string}
         */
        this.name = 'CoreContentLinksHandlerBase';
        /**
         * Handler's priority. The highest priority is treated first.
         * @type {number}
         */
        this.priority = 0;
        /**
         * Whether the isEnabled function should be called for all the users in a site. It should be true only if the isEnabled call
         * can return different values for different users in same site.
         * @type {boolean}
         */
        this.checkAllUsers = false;
        /**
         * Name of the feature this handler is related to.
         * It will be used to check if the feature is disabled (@see CoreSite.isFeatureDisabled).
         * @type {string}
         */
        this.featureName = '';
        // Nothing to do.
    }
    /**
     * Get the list of actions for a link (url).
     *
     * @param {string[]} siteIds List of sites the URL belongs to.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {CoreContentLinksAction[]|Promise<CoreContentLinksAction[]>} List of (or promise resolved with list of) actions.
     */
    CoreContentLinksHandlerBase.prototype.getActions = function (siteIds, url, params, courseId) {
        return [];
    };
    /**
     * Check if a URL is handled by this handler.
     *
     * @param {string} url The URL to check.
     * @return {boolean} Whether the URL is handled by this handler
     */
    CoreContentLinksHandlerBase.prototype.handles = function (url) {
        return this.pattern && url.search(this.pattern) >= 0;
    };
    /**
     * If the URL is handled by this handler, return the site URL.
     *
     * @param {string} url The URL to check.
     * @return {string} Site URL if it is handled, undefined otherwise.
     */
    CoreContentLinksHandlerBase.prototype.getSiteUrl = function (url) {
        if (this.pattern) {
            var position = url.search(this.pattern);
            if (position > -1) {
                return url.substr(0, position);
            }
        }
    };
    /**
     * Check if the handler is enabled for a certain site (site + user) and a URL.
     * If not defined, defaults to true.
     *
     * @param {string} siteId The site ID.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {boolean|Promise<boolean>} Whether the handler is enabled for the URL and site.
     */
    CoreContentLinksHandlerBase.prototype.isEnabled = function (siteId, url, params, courseId) {
        return true;
    };
    return CoreContentLinksHandlerBase;
}());

//# sourceMappingURL=base-handler.js.map

/***/ }),

/***/ 85:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreDirectivesModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__auto_focus__ = __webpack_require__(678);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__external_content__ = __webpack_require__(537);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__format_text__ = __webpack_require__(951);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__link__ = __webpack_require__(542);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__keep_keyboard__ = __webpack_require__(952);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__user_link__ = __webpack_require__(953);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};







var CoreDirectivesModule = /** @class */ (function () {
    function CoreDirectivesModule() {
    }
    CoreDirectivesModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_1__auto_focus__["a" /* CoreAutoFocusDirective */],
                __WEBPACK_IMPORTED_MODULE_2__external_content__["a" /* CoreExternalContentDirective */],
                __WEBPACK_IMPORTED_MODULE_3__format_text__["a" /* CoreFormatTextDirective */],
                __WEBPACK_IMPORTED_MODULE_5__keep_keyboard__["a" /* CoreKeepKeyboardDirective */],
                __WEBPACK_IMPORTED_MODULE_4__link__["a" /* CoreLinkDirective */],
                __WEBPACK_IMPORTED_MODULE_6__user_link__["a" /* CoreUserLinkDirective */]
            ],
            imports: [],
            exports: [
                __WEBPACK_IMPORTED_MODULE_1__auto_focus__["a" /* CoreAutoFocusDirective */],
                __WEBPACK_IMPORTED_MODULE_2__external_content__["a" /* CoreExternalContentDirective */],
                __WEBPACK_IMPORTED_MODULE_3__format_text__["a" /* CoreFormatTextDirective */],
                __WEBPACK_IMPORTED_MODULE_5__keep_keyboard__["a" /* CoreKeepKeyboardDirective */],
                __WEBPACK_IMPORTED_MODULE_4__link__["a" /* CoreLinkDirective */],
                __WEBPACK_IMPORTED_MODULE_6__user_link__["a" /* CoreUserLinkDirective */]
            ]
        })
    ], CoreDirectivesModule);
    return CoreDirectivesModule;
}());

//# sourceMappingURL=directives.module.js.map

/***/ }),

/***/ 86:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseFormatDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_events__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_sites__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__course__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__default_format__ = __webpack_require__(547);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__classes_delegate__ = __webpack_require__(67);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};







/**
 * Service to interact with course formats. Provides the functions to register and interact with the addons.
 */
var CoreCourseFormatDelegate = /** @class */ (function (_super) {
    __extends(CoreCourseFormatDelegate, _super);
    function CoreCourseFormatDelegate(loggerProvider, sitesProvider, eventsProvider, defaultHandler) {
        var _this = _super.call(this, 'CoreCoursesCourseFormatDelegate', loggerProvider, sitesProvider, eventsProvider) || this;
        _this.sitesProvider = sitesProvider;
        _this.defaultHandler = defaultHandler;
        _this.handlers = {}; // All registered handlers.
        _this.enabledHandlers = {}; // Handlers enabled for the current site.
        _this.featurePrefix = 'CoreCourseFormatHandler_';
        return _this;
    }
    /**
     * Whether it allows seeing all sections at the same time. Defaults to true.
     *
     * @param {any} course The course to check.
     * @return {boolean} Whether it allows seeing all sections at the same time.
     */
    CoreCourseFormatDelegate.prototype.canViewAllSections = function (course) {
        return this.executeFunction(course.format, 'canViewAllSections', [course]);
    };
    /**
     * Whether the default section selector should be displayed. Defaults to true.
     *
     * @param {any} course The course to check.
     * @return {boolean} Whether the section selector should be displayed.
     */
    CoreCourseFormatDelegate.prototype.displaySectionSelector = function (course) {
        return this.executeFunction(course.format, 'displaySectionSelector', [course]);
    };
    /**
     * Execute a certain function in a course format handler.
     * If the handler isn't found or function isn't defined, call the same function in the default handler.
     *
     * @param {string} format The format name.
     * @param {string} fnName Name of the function to execute.
     * @param {any[]} params Parameters to pass to the function.
     * @return {any} Function returned value or default value.
     */
    CoreCourseFormatDelegate.prototype.executeFunction = function (format, fnName, params) {
        var handler = this.enabledHandlers[format];
        if (handler && handler[fnName]) {
            return handler[fnName].apply(handler, params);
        }
        else if (this.defaultHandler[fnName]) {
            return this.defaultHandler[fnName].apply(this.defaultHandler, params);
        }
    };
    /**
     * Get the component to use to display all sections in a course.
     *
     * @param {any} course The course to render.
     * @return {any} The component to use, undefined if not found.
     */
    CoreCourseFormatDelegate.prototype.getAllSectionsComponent = function (course) {
        return this.executeFunction(course.format, 'getAllSectionsComponent', [course]);
    };
    /**
     * Get the component to use to display a course format.
     *
     * @param {any} course The course to render.
     * @return {any} The component to use, undefined if not found.
     */
    CoreCourseFormatDelegate.prototype.getCourseFormatComponent = function (course) {
        return this.executeFunction(course.format, 'getCourseFormatComponent', [course]);
    };
    /**
     * Get the component to use to display the course summary in the default course format.
     *
     * @param {any} course The course to render.
     * @return {any} The component to use, undefined if not found.
     */
    CoreCourseFormatDelegate.prototype.getCourseSummaryComponent = function (course) {
        return this.executeFunction(course.format, 'getCourseSummaryComponent', [course]);
    };
    /**
     * Given a course, return the title to use in the course page.
     *
     * @param {any} course The course to get the title.
     * @param {any[]} [sections] List of sections.
     * @return {string} Course title.
     */
    CoreCourseFormatDelegate.prototype.getCourseTitle = function (course, sections) {
        return this.executeFunction(course.format, 'getCourseTitle', [course, sections]);
    };
    /**
     * Given a course and a list of sections, return the current section that should be displayed first.
     *
     * @param {any} course The course to get the title.
     * @param {any[]} sections List of sections.
     * @return {Promise<any>} Promise resolved with current section.
     */
    CoreCourseFormatDelegate.prototype.getCurrentSection = function (course, sections) {
        // Convert the result to a Promise if it isn't.
        return Promise.resolve(this.executeFunction(course.format, 'getCurrentSection', [course, sections])).catch(function () {
            // This function should never fail. Just return the first section.
            if (sections[0].id != __WEBPACK_IMPORTED_MODULE_4__course__["a" /* CoreCourseProvider */].ALL_SECTIONS_ID) {
                return sections[0];
            }
            return sections[1];
        });
    };
    /**
     * Get the component to use to display the section selector inside the default course format.
     *
     * @param {any} course The course to render.
     * @return {any} The component to use, undefined if not found.
     */
    CoreCourseFormatDelegate.prototype.getSectionSelectorComponent = function (course) {
        return this.executeFunction(course.format, 'getSectionSelectorComponent', [course]);
    };
    /**
     * Get the component to use to display a single section. This component will only be used if the user is viewing
     * a single section. If all the sections are displayed at once then it won't be used.
     *
     * @param {any} course The course to render.
     * @return {any} The component to use, undefined if not found.
     */
    CoreCourseFormatDelegate.prototype.getSingleSectionComponent = function (course) {
        return this.executeFunction(course.format, 'getSingleSectionComponent', [course]);
    };
    /**
     * Invalidate the data required to load the course format.
     *
     * @param {any} course The course to get the title.
     * @param {any[]} sections List of sections.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCourseFormatDelegate.prototype.invalidateData = function (course, sections) {
        return this.executeFunction(course.format, 'invalidateData', [course, sections]);
    };
    /**
     * Open a course.
     *
     * @param {NavController} navCtrl The NavController instance to use.
     * @param {any} course The course to open. It should contain a "format" attribute.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseFormatDelegate.prototype.openCourse = function (navCtrl, course) {
        if (this.enabledHandlers[course.format] && this.enabledHandlers[course.format].openCourse) {
            return this.enabledHandlers[course.format].openCourse(navCtrl, course);
        }
        return navCtrl.push('CoreCourseSectionPage', { course: course });
    };
    CoreCourseFormatDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_1__providers_events__["a" /* CoreEventsProvider */],
            __WEBPACK_IMPORTED_MODULE_5__default_format__["a" /* CoreCourseFormatDefaultHandler */]])
    ], CoreCourseFormatDelegate);
    return CoreCourseFormatDelegate;
}(__WEBPACK_IMPORTED_MODULE_6__classes_delegate__["a" /* CoreDelegate */]));

//# sourceMappingURL=format-delegate.js.map

/***/ }),

/***/ 87:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreContentLinksDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_url__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__ = __webpack_require__(9);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Delegate to register handlers to handle links.
 */
var CoreContentLinksDelegate = /** @class */ (function () {
    function CoreContentLinksDelegate(logger, sitesProvider, urlUtils, utils) {
        this.sitesProvider = sitesProvider;
        this.urlUtils = urlUtils;
        this.utils = utils;
        this.handlers = {}; // All registered handlers.
        this.logger = logger.getInstance('CoreContentLinksDelegate');
    }
    /**
     * Get the list of possible actions to do for a URL.
     *
     * @param {string} url URL to handle.
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @param {string} [username] Username to use to filter sites.
     * @return {Promise<CoreContentLinksAction[]>}  Promise resolved with the actions.
     */
    CoreContentLinksDelegate.prototype.getActionsFor = function (url, courseId, username) {
        var _this = this;
        if (!url) {
            return Promise.resolve([]);
        }
        // Get the list of sites the URL belongs to.
        return this.sitesProvider.getSiteIdsFromUrl(url, true, username).then(function (siteIds) {
            var linkActions = [], promises = [], params = _this.urlUtils.extractUrlParams(url);
            var _loop_1 = function (name_1) {
                var handler = _this.handlers[name_1], checkAll = handler.checkAllUsers, isEnabledFn = _this.isHandlerEnabled.bind(_this, handler, url, params, courseId);
                if (!handler.handles(url)) {
                    return "continue";
                }
                // Filter the site IDs using the isEnabled function.
                promises.push(_this.utils.filterEnabledSites(siteIds, isEnabledFn, checkAll).then(function (siteIds) {
                    if (!siteIds.length) {
                        // No sites supported, no actions.
                        return;
                    }
                    return Promise.resolve(handler.getActions(siteIds, url, params, courseId)).then(function (actions) {
                        if (actions && actions.length) {
                            // Set default values if any value isn't supplied.
                            actions.forEach(function (action) {
                                action.message = action.message || 'core.view';
                                action.icon = action.icon || 'eye';
                                action.sites = action.sites || siteIds;
                            });
                            // Add them to the list.
                            linkActions.push({
                                priority: handler.priority,
                                actions: actions
                            });
                        }
                    });
                }));
            };
            for (var name_1 in _this.handlers) {
                _loop_1(name_1);
            }
            return _this.utils.allPromises(promises).catch(function () {
                // Ignore errors.
            }).then(function () {
                // Sort link actions by priority.
                return _this.sortActionsByPriority(linkActions);
            });
        });
    };
    /**
     * Get the site URL if the URL is supported by any handler.
     *
     * @param {string} url URL to handle.
     * @return {string} Site URL if the URL is supported by any handler, undefined otherwise.
     */
    CoreContentLinksDelegate.prototype.getSiteUrl = function (url) {
        if (!url) {
            return;
        }
        // Check if any handler supports this URL.
        for (var name_2 in this.handlers) {
            var handler = this.handlers[name_2], siteUrl = handler.getSiteUrl(url);
            if (siteUrl) {
                return siteUrl;
            }
        }
    };
    /**
     * Check if a handler is enabled for a certain site and URL.
     *
     * @param {CoreContentLinksHandler} handler Handler to check.
     * @param {string} url The URL to check.
     * @param {any} params The params of the URL
     * @param {number} courseId Course ID the URL belongs to (can be undefined).
     * @param {string} siteId The site ID to check.
     * @return {Promise<boolean>} Promise resolved with boolean: whether the handler is enabled.
     */
    CoreContentLinksDelegate.prototype.isHandlerEnabled = function (handler, url, params, courseId, siteId) {
        var promise;
        if (handler.featureName) {
            // Check if the feature is disabled.
            promise = this.sitesProvider.isFeatureDisabled(handler.featureName, siteId);
        }
        else {
            promise = Promise.resolve(false);
        }
        return promise.then(function (disabled) {
            if (disabled) {
                return false;
            }
            if (!handler.isEnabled) {
                // Handler doesn't implement isEnabled, assume it's enabled.
                return true;
            }
            return handler.isEnabled(siteId, url, params, courseId);
        });
    };
    /**
     * Register a handler.
     *
     * @param {CoreContentLinksHandler} handler The handler to register.
     * @return {boolean} True if registered successfully, false otherwise.
     */
    CoreContentLinksDelegate.prototype.registerHandler = function (handler) {
        if (typeof this.handlers[handler.name] !== 'undefined') {
            this.logger.log("Addon '" + handler.name + "' already registered");
            return false;
        }
        this.logger.log("Registered addon '" + handler.name + "'");
        this.handlers[handler.name] = handler;
        return true;
    };
    /**
     * Sort actions by priority.
     *
     * @param {CoreContentLinksHandlerActions[]} actions Actions to sort.
     * @return {CoreContentLinksAction[]} Sorted actions.
     */
    CoreContentLinksDelegate.prototype.sortActionsByPriority = function (actions) {
        var sorted = [];
        // Sort by priority.
        actions = actions.sort(function (a, b) {
            return a.priority >= b.priority ? 1 : -1;
        });
        // Fill result array.
        actions.forEach(function (entry) {
            sorted = sorted.concat(entry.actions);
        });
        return sorted;
    };
    CoreContentLinksDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_url__["a" /* CoreUrlUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], CoreContentLinksDelegate);
    return CoreContentLinksDelegate;
}());

//# sourceMappingURL=delegate.js.map

/***/ }),

/***/ 88:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreMainMenuDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_events__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__classes_delegate__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_sites__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_rxjs__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






/**
 * Service to interact with plugins to be shown in the main menu. Provides functions to register a plugin
 * and notify an update in the data.
 */
var CoreMainMenuDelegate = /** @class */ (function (_super) {
    __extends(CoreMainMenuDelegate, _super);
    function CoreMainMenuDelegate(loggerProvider, sitesProvider, eventsProvider) {
        var _this = _super.call(this, 'CoreMainMenuDelegate', loggerProvider, sitesProvider, eventsProvider) || this;
        _this.loggerProvider = loggerProvider;
        _this.sitesProvider = sitesProvider;
        _this.eventsProvider = eventsProvider;
        _this.handlers = {};
        _this.enabledHandlers = {};
        _this.loaded = false;
        _this.siteHandlers = new __WEBPACK_IMPORTED_MODULE_5_rxjs__["BehaviorSubject"]([]);
        _this.featurePrefix = '$mmSideMenuDelegate_';
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_1__providers_events__["a" /* CoreEventsProvider */].LOGOUT, _this.clearSiteHandlers.bind(_this));
        return _this;
    }
    /**
     * Check if handlers are loaded.
     *
     * @return {boolean} True if handlers are loaded, false otherwise.
     */
    CoreMainMenuDelegate.prototype.areHandlersLoaded = function () {
        return this.loaded;
    };
    /**
     * Clear current site handlers. Reserved for core use.
     */
    CoreMainMenuDelegate.prototype.clearSiteHandlers = function () {
        this.loaded = false;
        this.siteHandlers.next([]);
    };
    /**
     * Get the handlers for the current site.
     *
     * @return {Subject<CoreMainMenuHandlerToDisplay[]>} An observable that will receive the handlers.
     */
    CoreMainMenuDelegate.prototype.getHandlers = function () {
        return this.siteHandlers;
    };
    /**
     * Update handlers Data.
     */
    CoreMainMenuDelegate.prototype.updateData = function () {
        var handlersData = [];
        for (var name_1 in this.enabledHandlers) {
            var handler = this.enabledHandlers[name_1], data = handler.getDisplayData();
            handlersData.push({
                data: data,
                priority: handler.priority
            });
        }
        // Sort them by priority.
        handlersData.sort(function (a, b) {
            return b.priority - a.priority;
        });
        // Return only the display data.
        var displayData = handlersData.map(function (item) {
            return item.data;
        });
        this.loaded = true;
        this.siteHandlers.next(displayData);
    };
    CoreMainMenuDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_1__providers_events__["a" /* CoreEventsProvider */]])
    ], CoreMainMenuDelegate);
    return CoreMainMenuDelegate;
}(__WEBPACK_IMPORTED_MODULE_2__classes_delegate__["a" /* CoreDelegate */]));

//# sourceMappingURL=delegate.js.map

/***/ }),

/***/ 9:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreUtilsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_in_app_browser__ = __webpack_require__(130);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_clipboard__ = __webpack_require__(202);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__app__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__dom__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__events__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__ngx_translate_core__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__lang__ = __webpack_require__(101);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};










/*
 * "Utils" service with helper functions.
 */
var CoreUtilsProvider = /** @class */ (function () {
    function CoreUtilsProvider(iab, appProvider, clipboard, domUtils, logger, translate, platform, langProvider, eventsProvider) {
        this.iab = iab;
        this.appProvider = appProvider;
        this.clipboard = clipboard;
        this.domUtils = domUtils;
        this.translate = translate;
        this.platform = platform;
        this.langProvider = langProvider;
        this.eventsProvider = eventsProvider;
        this.logger = logger.getInstance('CoreUtilsProvider');
    }
    /**
     * Similar to Promise.all, but if a promise fails this function's promise won't be rejected until ALL promises have finished.
     *
     * @param {Promise<any>[]} promises Promises.
     * @return {Promise<any>} Promise resolved if all promises are resolved and rejected if at least 1 promise fails.
     */
    CoreUtilsProvider.prototype.allPromises = function (promises) {
        if (!promises || !promises.length) {
            return Promise.resolve();
        }
        return new Promise(function (resolve, reject) {
            var total = promises.length;
            var count = 0, error;
            promises.forEach(function (promise) {
                promise.catch(function (err) {
                    error = err;
                }).finally(function () {
                    count++;
                    if (count === total) {
                        // All promises have finished, reject/resolve.
                        if (error) {
                            reject(error);
                        }
                        else {
                            resolve();
                        }
                    }
                });
            });
        });
    };
    /**
     * Converts an array of objects to an object, using a property of each entry as the key.
     * E.g. [{id: 10, name: 'A'}, {id: 11, name: 'B'}] => {10: {id: 10, name: 'A'}, 11: {id: 11, name: 'B'}}
     *
     * @param {any[]} array The array to convert.
     * @param {string} propertyName The name of the property to use as the key.
     * @param {any} [result] Object where to put the properties. If not defined, a new object will be created.
     * @return {any} The object.
     */
    CoreUtilsProvider.prototype.arrayToObject = function (array, propertyName, result) {
        result = result || {};
        array.forEach(function (entry) {
            result[entry[propertyName]] = entry;
        });
        return result;
    };
    /**
     * Compare two objects. This function won't compare functions and proto properties, it's a basic compare.
     * Also, this will only check if itemA's properties are in itemB with same value. This function will still
     * return true if itemB has more properties than itemA.
     *
     * @param {any} itemA First object.
     * @param {any} itemB Second object.
     * @param {number} [maxLevels=0] Number of levels to reach if 2 objects are compared.
     * @param {number} [level=0] Current deep level (when comparing objects).
     * @param {boolean} [undefinedIsNull=true] True if undefined is equal to null. Defaults to true.
     * @return {boolean} Whether both items are equal.
     */
    CoreUtilsProvider.prototype.basicLeftCompare = function (itemA, itemB, maxLevels, level, undefinedIsNull) {
        if (maxLevels === void 0) { maxLevels = 0; }
        if (level === void 0) { level = 0; }
        if (undefinedIsNull === void 0) { undefinedIsNull = true; }
        if (typeof itemA == 'function' || typeof itemB == 'function') {
            return true; // Don't compare functions.
        }
        else if (typeof itemA == 'object' && typeof itemB == 'object') {
            if (level >= maxLevels) {
                return true; // Max deep reached.
            }
            var equal = true;
            for (var name_1 in itemA) {
                var value = itemA[name_1];
                if (name_1 == '$$hashKey') {
                    // Ignore $$hashKey property since it's a "calculated" property.
                    return;
                }
                if (!this.basicLeftCompare(value, itemB[name_1], maxLevels, level + 1)) {
                    equal = false;
                }
            }
            return equal;
        }
        else {
            if (undefinedIsNull && ((typeof itemA == 'undefined' && itemB === null) || (itemA === null && typeof itemB == 'undefined'))) {
                return true;
            }
            // We'll treat "2" and 2 as the same value.
            var floatA = parseFloat(itemA), floatB = parseFloat(itemB);
            if (!isNaN(floatA) && !isNaN(floatB)) {
                return floatA == floatB;
            }
            return itemA === itemB;
        }
    };
    /**
     * Blocks leaving a view.
     */
    CoreUtilsProvider.prototype.blockLeaveView = function () {
        // @todo
    };
    /**
     * Close the InAppBrowser window.
     *
     * @param {boolean} [closeAll] Desktop only. True to close all secondary windows, false to close only the "current" one.
     */
    CoreUtilsProvider.prototype.closeInAppBrowser = function (closeAll) {
        if (this.iabInstance) {
            this.iabInstance.close();
            if (closeAll && this.appProvider.isDesktop()) {
                __webpack_require__(212).ipcRenderer.send('closeSecondaryWindows');
            }
        }
    };
    /**
     * Clone a variable. It should be an object, array or primitive type.
     *
     * @param {any} source The variable to clone.
     * @return {any} Cloned variable.
     */
    CoreUtilsProvider.prototype.clone = function (source) {
        if (Array.isArray(source)) {
            // Clone the array and all the entries.
            var newArray = [];
            for (var i = 0; i < source.length; i++) {
                newArray[i] = this.clone(source[i]);
            }
            return newArray;
        }
        else if (typeof source == 'object' && source !== null) {
            // Clone the object and all the subproperties.
            var newObject = {};
            for (var name_2 in source) {
                newObject[name_2] = this.clone(source[name_2]);
            }
            return newObject;
        }
        else {
            // Primitive type or unknown, return it as it is.
            return source;
        }
    };
    /**
     * Copy properties from one object to another.
     *
     * @param {any} from Object to copy the properties from.
     * @param {any} to Object where to store the properties.
     * @param {boolean} [clone=true] Whether the properties should be cloned (so they are different instances).
     */
    CoreUtilsProvider.prototype.copyProperties = function (from, to, clone) {
        if (clone === void 0) { clone = true; }
        for (var name_3 in from) {
            if (clone) {
                to[name_3] = this.clone(from[name_3]);
            }
            else {
                to[name_3] = from[name_3];
            }
        }
    };
    /**
     * Copies a text to clipboard and shows a toast message.
     *
     * @param {string} text Text to be copied
     * @return {Promise<any>} Promise resolved when text is copied.
     */
    CoreUtilsProvider.prototype.copyToClipboard = function (text) {
        var _this = this;
        return this.clipboard.copy(text).then(function () {
            // Show toast using ionicLoading.
            return _this.domUtils.showToast('core.copiedtoclipboard', true);
        }).catch(function () {
            // Ignore errors.
        });
    };
    /**
     * Empties an array without losing its reference.
     *
     * @param {any[]} array Array to empty.
     */
    CoreUtilsProvider.prototype.emptyArray = function (array) {
        array.length = 0; // Empty array without losing its reference.
    };
    /**
     * Removes all properties from an object without losing its reference.
     *
     * @param {object} object Object to remove the properties.
     */
    CoreUtilsProvider.prototype.emptyObject = function (object) {
        for (var key in object) {
            if (object.hasOwnProperty(key)) {
                delete object[key];
            }
        }
    };
    /**
     * Execute promises one depending on the previous.
     *
     * @param {any[]} orderedPromisesData Data to be executed including the following values:
     *                                 - func: Function to be executed.
     *                                 - context: Context to pass to the function. This allows using "this" inside the function.
     *                                 - params: Array of data to be sent to the function.
     *                                 - blocking: Boolean. If promise should block the following.
     * @return {Promise<any>} Promise resolved when all promises are resolved.
     */
    CoreUtilsProvider.prototype.executeOrderedPromises = function (orderedPromisesData) {
        var _this = this;
        var promises = [];
        var dependency = Promise.resolve();
        var _loop_1 = function (i) {
            var data = orderedPromisesData[i];
            var promise = void 0;
            // Add the process to the dependency stack.
            promise = dependency.finally(function () {
                var prom;
                try {
                    prom = data.func.apply(data.context, data.params || []);
                }
                catch (e) {
                    _this.logger.error(e.message);
                    return;
                }
                return prom;
            });
            promises.push(promise);
            // If the new process is blocking, we set it as the dependency.
            if (data.blocking) {
                dependency = promise;
            }
        };
        // Execute all the processes in order.
        for (var i in orderedPromisesData) {
            _loop_1(i);
        }
        // Return when all promises are done.
        return this.allPromises(promises);
    };
    /**
     * Flatten an object, moving subobjects' properties to the first level using dot notation. E.g.:
     * {a: {b: 1, c: 2}, d: 3} -> {'a.b': 1, 'a.c': 2, d: 3}
     *
     * @param {object} obj Object to flatten.
     * @return {object} Flatten object.
     */
    CoreUtilsProvider.prototype.flattenObject = function (obj) {
        var toReturn = {};
        for (var name_4 in obj) {
            if (!obj.hasOwnProperty(name_4)) {
                continue;
            }
            var value = obj[name_4];
            if (typeof value == 'object' && !Array.isArray(value)) {
                var flatObject = this.flattenObject(value);
                for (var subName in flatObject) {
                    if (!flatObject.hasOwnProperty(subName)) {
                        continue;
                    }
                    toReturn[name_4 + '.' + subName] = flatObject[subName];
                }
            }
            else {
                toReturn[name_4] = value;
            }
        }
        return toReturn;
    };
    /**
     * Given an array of strings, return only the ones that match a regular expression.
     *
     * @param {string[]} array Array to filter.
     * @param {RegExp} regex RegExp to apply to each string.
     * @return {string[]} Filtered array.
     */
    CoreUtilsProvider.prototype.filterByRegexp = function (array, regex) {
        if (!array || !array.length) {
            return [];
        }
        return array.filter(function (entry) {
            var matches = entry.match(regex);
            return matches && matches.length;
        });
    };
    /**
     * Filter the list of site IDs based on a isEnabled function.
     *
     * @param {string[]} siteIds Site IDs to filter.
     * @param {Function} isEnabledFn Function to call for each site. Must return true or a promise resolved with true if enabled.
     *                    It receives a siteId param and all the params sent to this function after 'checkAll'.
     * @param {boolean} [checkAll] True if it should check all the sites, false if it should check only 1 and treat them all
     *                   depending on this result.
     * @param {any} ...args All the params sent after checkAll will be passed to isEnabledFn.
     * @return {Promise<string[]>} Promise resolved with the list of enabled sites.
     */
    CoreUtilsProvider.prototype.filterEnabledSites = function (siteIds, isEnabledFn, checkAll) {
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            args[_i - 3] = arguments[_i];
        }
        var promises = [], enabledSites = [];
        var _loop_2 = function (i) {
            var siteId = siteIds[i];
            if (checkAll || !promises.length) {
                promises.push(Promise.resolve(isEnabledFn.apply(isEnabledFn, [siteId].concat(args))).then(function (enabled) {
                    if (enabled) {
                        enabledSites.push(siteId);
                    }
                }));
            }
        };
        for (var i in siteIds) {
            _loop_2(i);
        }
        return this.allPromises(promises).catch(function () {
            // Ignore errors.
        }).then(function () {
            if (!checkAll) {
                // Checking 1 was enough, so it will either return all the sites or none.
                return enabledSites.length ? siteIds : [];
            }
            else {
                return enabledSites;
            }
        });
    };
    /**
     * Given a float, prints it nicely. Localized floats must not be used in calculations!
     * Based on Moodle's format_float.
     *
     * @param {any} float The float to print.
     * @return {string} Locale float.
     */
    CoreUtilsProvider.prototype.formatFloat = function (float) {
        if (typeof float == 'undefined') {
            return '';
        }
        var localeSeparator = this.translate.instant('core.decsep');
        // Convert float to string.
        float += '';
        return float.replace('.', localeSeparator);
    };
    /**
     * Returns a tree formatted from a plain list.
     * List has to be sorted by depth to allow this function to work correctly. Errors can be thrown if a child node is
     * processed before a parent node.
     *
     * @param {any[]} list List to format.
     * @param {string} [parentFieldName=parent] Name of the parent field to match with children.
     * @param {string} [idFieldName=id] Name of the children field to match with parent.
     * @param {number} [rootParentId=0] The id of the root.
     * @param {number} [maxDepth=5] Max Depth to convert to tree. Children found will be in the last level of depth.
     * @return {any[]} Array with the formatted tree, children will be on each node under children field.
     */
    CoreUtilsProvider.prototype.formatTree = function (list, parentFieldName, idFieldName, rootParentId, maxDepth) {
        if (parentFieldName === void 0) { parentFieldName = 'parent'; }
        if (idFieldName === void 0) { idFieldName = 'id'; }
        if (rootParentId === void 0) { rootParentId = 0; }
        if (maxDepth === void 0) { maxDepth = 5; }
        var map = {}, mapDepth = {}, tree = [];
        var parent, id;
        list.forEach(function (node, index) {
            id = node[idFieldName];
            parent = node[parentFieldName];
            node.children = [];
            // Use map to look-up the parents.
            map[id] = index;
            if (parent != rootParentId) {
                var parentNode = list[map[parent]];
                if (parentNode) {
                    if (mapDepth[parent] == maxDepth) {
                        // Reached max level of depth. Proceed with flat order. Find parent object of the current node.
                        var parentOfParent = parentNode[parentFieldName];
                        if (parentOfParent) {
                            // This element will be the child of the node that is two levels up the hierarchy
                            // (i.e. the child of node.parent.parent).
                            list[map[parentOfParent]].children.push(node);
                            // Assign depth level to the same depth as the parent (i.e. max depth level).
                            mapDepth[id] = mapDepth[parent];
                            // Change the parent to be the one that is two levels up the hierarchy.
                            node.parent = parentOfParent;
                        }
                    }
                    else {
                        parentNode.children.push(node);
                        // Increase the depth level.
                        mapDepth[id] = mapDepth[parent] + 1;
                    }
                }
            }
            else {
                tree.push(node);
                // Root elements are the first elements in the tree structure, therefore have the depth level 1.
                mapDepth[id] = 1;
            }
        });
        return tree;
    };
    /**
     * Get country name based on country code.
     *
     * @param {string} code Country code (AF, ES, US, ...).
     * @return {string} Country name. If the country is not found, return the country code.
     */
    CoreUtilsProvider.prototype.getCountryName = function (code) {
        var countryKey = 'assets.countries.' + code, countryName = this.translate.instant(countryKey);
        return countryName !== countryKey ? countryName : code;
    };
    /**
     * Get list of countries with their code and translated name.
     *
     * @return {Promise<any>} Promise resolved with the list of countries.
     */
    CoreUtilsProvider.prototype.getCountryList = function () {
        var _this = this;
        // Get the current language.
        return this.langProvider.getCurrentLanguage().then(function (lang) {
            // Get the full list of translations. Create a promise to convert the observable into a promise.
            return new Promise(function (resolve, reject) {
                var observer = _this.translate.getTranslation(lang).subscribe(function (table) {
                    resolve(table);
                    observer.unsubscribe();
                }, function (err) {
                    reject(err);
                    observer.unsubscribe();
                });
            });
        }).then(function (table) {
            var countries = {};
            for (var name_5 in table) {
                if (name_5.indexOf('assets.countries.') === 0) {
                    var code = name_5.replace('assets.countries.', '');
                    countries[code] = table[name_5];
                }
            }
            return countries;
        });
    };
    /**
     * Given a list of files, check if there are repeated names.
     *
     * @param {any[]} files List of files.
     * @return {string|boolean} String with error message if repeated, false if no repeated.
     */
    CoreUtilsProvider.prototype.hasRepeatedFilenames = function (files) {
        if (!files || !files.length) {
            return false;
        }
        var names = [];
        // Check if there are 2 files with the same name.
        for (var i = 0; i < files.length; i++) {
            var name_6 = files[i].filename || files[i].name;
            if (names.indexOf(name_6) > -1) {
                return this.translate.instant('core.filenameexist', { $a: name_6 });
            }
            else {
                names.push(name_6);
            }
        }
        return false;
    };
    /**
     * Gets the index of the first string that matches a regular expression.
     *
     * @param {string[]} array Array to search.
     * @param {RegExp} regex RegExp to apply to each string.
     * @return {number} Index of the first string that matches the RegExp. -1 if not found.
     */
    CoreUtilsProvider.prototype.indexOfRegexp = function (array, regex) {
        if (!array || !array.length) {
            return -1;
        }
        for (var i = 0; i < array.length; i++) {
            var entry = array[i], matches = entry.match(regex);
            if (matches && matches.length) {
                return i;
            }
        }
        return -1;
    };
    /**
     * Return true if the param is false (bool), 0 (number) or "0" (string).
     *
     * @param {any} value Value to check.
     * @return {boolean} Whether the value is false, 0 or "0".
     */
    CoreUtilsProvider.prototype.isFalseOrZero = function (value) {
        return typeof value != 'undefined' && (value === false || value === 'false' || parseInt(value, 10) === 0);
    };
    /**
     * Return true if the param is true (bool), 1 (number) or "1" (string).
     *
     * @param {any} value Value to check.
     * @return {boolean} Whether the value is true, 1 or "1".
     */
    CoreUtilsProvider.prototype.isTrueOrOne = function (value) {
        return typeof value != 'undefined' && (value === true || value === 'true' || parseInt(value, 10) === 1);
    };
    /**
     * Given an error returned by a WS call, check if the error is generated by the app or it has been returned by the WebSwervice.
     *
     * @param {string} error Error to check.
     * @return {boolean} Whether the error was returned by the WebService.
     */
    CoreUtilsProvider.prototype.isWebServiceError = function (error) {
        var localErrors = [
            this.translate.instant('core.wsfunctionnotavailable'),
            this.translate.instant('core.lostconnection'),
            this.translate.instant('core.userdeleted'),
            this.translate.instant('core.unexpectederror'),
            this.translate.instant('core.networkerrormsg'),
            this.translate.instant('core.serverconnection'),
            this.translate.instant('core.errorinvalidresponse'),
            this.translate.instant('core.sitemaintenance'),
            this.translate.instant('core.upgraderunning'),
            this.translate.instant('core.nopasswordchangeforced'),
            this.translate.instant('core.unicodenotsupported')
        ];
        return error && localErrors.indexOf(error) == -1;
    };
    /**
     * Merge two arrays, removing duplicate values.
     *
     * @param {any[]} array1 The first array.
     * @param {any[]} array2 The second array.
     * @param [key] Key of the property that must be unique. If not specified, the whole entry.
     * @return {any[]} Merged array.
     */
    CoreUtilsProvider.prototype.mergeArraysWithoutDuplicates = function (array1, array2, key) {
        return this.uniqueArray(array1.concat(array2), key);
    };
    /**
     * Open a file using platform specific method.
     *
     * node-webkit: Using the default application configured.
     * Android: Using the WebIntent plugin.
     * iOs: Using handleDocumentWithURL.
     *
     * @param {string} path The local path of the file to be open.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreUtilsProvider.prototype.openFile = function (path) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (_this.appProvider.isDesktop()) {
                // It's a desktop app, send an event so the file is opened.
                // Opening the file from here (renderer process) doesn't focus the opened app, that's why an event is needed.
                // Use sendSync so we can receive the result.
                if (__webpack_require__(212).ipcRenderer.sendSync('openItem', path)) {
                    resolve();
                }
                else {
                    reject(_this.translate.instant('core.erroropenfilenoapp'));
                }
            }
            else if (window.plugins) {
                // @todo
                reject('TODO');
            }
            else {
                // Changing _blank for _system may work in cordova 2.4 and onwards.
                _this.logger.log('Opening external file using window.open()');
                window.open(path, '_blank');
                resolve();
            }
        });
    };
    /**
     * Open a URL using InAppBrowser.
     * Do not use for files, refer to {@link openFile}.
     *
     * @param {string} url The URL to open.
     * @param {any} [options] Override default options passed to InAppBrowser.
     * @return {InAppBrowserObject} The opened window.
     */
    CoreUtilsProvider.prototype.openInApp = function (url, options) {
        var _this = this;
        if (!url) {
            return;
        }
        options = options || {};
        if (!options.enableViewPortScale) {
            options.enableViewPortScale = 'yes'; // Enable zoom on iOS.
        }
        if (!options.location && this.platform.is('ios') && url.indexOf('file://') === 0) {
            // The URL uses file protocol, don't show it on iOS.
            // In Android we keep it because otherwise we lose the whole toolbar.
            options.location = 'no';
        }
        // Convert the options to a string.
        var optionsArray = [];
        var optionsString;
        for (var name_7 in options) {
            optionsArray.push(name_7 + "=" + options[name_7]);
        }
        optionsString = optionsArray.join(',');
        this.iabInstance = this.iab.create(url, '_blank', options);
        if (this.appProvider.isDesktop() || this.appProvider.isMobile()) {
            // Trigger global events when a url is loaded or the window is closed. This is to make it work like in Ionic 1.
            var loadStartSubscription_1 = this.iabInstance.on('loadstart').subscribe(function (event) {
                _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_6__events__["a" /* CoreEventsProvider */].IAB_LOAD_START, event);
            });
            var exitSubscription_1 = this.iabInstance.on('exit').subscribe(function (event) {
                loadStartSubscription_1.unsubscribe();
                exitSubscription_1.unsubscribe();
                _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_6__events__["a" /* CoreEventsProvider */].IAB_EXIT, event);
            });
        }
        return this.iabInstance;
    };
    /**
     * Open a URL using a browser.
     * Do not use for files, refer to {@link openFile}.
     *
     * @param {string} url The URL to open.
     */
    CoreUtilsProvider.prototype.openInBrowser = function (url) {
        if (this.appProvider.isDesktop()) {
            // It's a desktop app, use Electron shell library to open the browser.
            var shell = __webpack_require__(212).shell;
            if (!shell.openExternal(url)) {
                // Open browser failed, open a new window in the app.
                window.open(url, '_system');
            }
        }
        else {
            window.open(url, '_system');
        }
    };
    /**
     * Open an online file using platform specific method.
     * Specially useful for audio and video since they can be streamed.
     *
     * node-webkit: Using the default application configured.
     * Android: Using the WebIntent plugin.
     * iOS: Using the window.open method (InAppBrowser)
     *      We don't use iOS quickview framework because it doesn't support streaming.
     *
     * @param {string} url The URL of the file.
     * @return {Promise<void>} Promise resolved when opened.
     */
    CoreUtilsProvider.prototype.openOnlineFile = function (url) {
        return new Promise(function (resolve, reject) {
            // @todo
            reject('TODO');
        });
    };
    /**
     * Converts an object into an array, losing the keys.
     *
     * @param {object} obj Object to convert.
     * @return {any[]} Array with the values of the object but losing the keys.
     */
    CoreUtilsProvider.prototype.objectToArray = function (obj) {
        return Object.keys(obj).map(function (key) {
            return obj[key];
        });
    };
    /**
     * Converts an object into an array of objects, where each entry is an object containing
     * the key and value of the original object.
     * For example, it can convert {size: 2} into [{name: 'size', value: 2}].
     *
     * @param {object} obj Object to convert.
     * @param {string} keyName Name of the properties where to store the keys.
     * @param {string} valueName Name of the properties where to store the values.
     * @param {boolean} [sort] True to sort keys alphabetically, false otherwise.
     * @return {any[]} Array of objects with the name & value of each property.
     */
    CoreUtilsProvider.prototype.objectToArrayOfObjects = function (obj, keyName, valueName, sort) {
        // Get the entries from an object or primitive value.
        var getEntries = function (elKey, value) {
            if (typeof value == 'object') {
                // It's an object, return at least an entry for each property.
                var keys = Object.keys(value);
                var entries_1 = [];
                keys.forEach(function (key) {
                    var newElKey = elKey ? elKey + '[' + key + ']' : key;
                    entries_1 = entries_1.concat(getEntries(newElKey, value[key]));
                });
                return entries_1;
            }
            else {
                // Not an object, return a single entry.
                var entry = {};
                entry[keyName] = elKey;
                entry[valueName] = value;
                return entry;
            }
        };
        if (!obj) {
            return [];
        }
        // "obj" will always be an object, so "entries" will always be an array.
        var entries = getEntries('', obj);
        if (sort) {
            return entries.sort(function (a, b) {
                return a.name >= b.name ? 1 : -1;
            });
        }
        return entries;
    };
    /**
     * Converts an array of objects into an object with key and value. The opposite of objectToArrayOfObjects.
     * For example, it can convert [{name: 'size', value: 2}] into {size: 2}.
     *
     * @param {object[]} objects List of objects to convert.
     * @param {string} keyName Name of the properties where the keys are stored.
     * @param {string} valueName Name of the properties where the values are stored.
     * @param [keyPrefix] Key prefix if neededs to delete it.
     * @return {object} Object.
     */
    CoreUtilsProvider.prototype.objectToKeyValueMap = function (objects, keyName, valueName, keyPrefix) {
        var prefixSubstr = keyPrefix ? keyPrefix.length : 0, mapped = {};
        objects.forEach(function (item) {
            var key = prefixSubstr > 0 ? item[keyName].substr(prefixSubstr) : item[keyName];
            mapped[key] = item[valueName];
        });
        return mapped;
    };
    /**
     * Given an observable, convert it to a Promise that will resolve with the first received value.
     *
     * @param {Observable<any>} obs The observable to convert.
     * @return {Promise<any>} Promise.
     */
    CoreUtilsProvider.prototype.observableToPromise = function (obs) {
        return new Promise(function (resolve, reject) {
            var subscription = obs.subscribe(function (data) {
                // Data received, unsubscribe.
                subscription.unsubscribe();
                resolve(data);
            }, function (error) {
                // Data received, unsubscribe.
                subscription.unsubscribe();
                reject(error);
            });
        });
    };
    /**
     * Similar to AngularJS $q.defer().
     *
     * @return {PromiseDefer} The deferred promise.
     */
    CoreUtilsProvider.prototype.promiseDefer = function () {
        var deferred = {};
        deferred.promise = new Promise(function (resolve, reject) {
            deferred.resolve = resolve;
            deferred.reject = reject;
        });
        return deferred;
    };
    /**
     * Given a promise, returns true if it's rejected or false if it's resolved.
     *
     * @param {Promise<any>} promise Promise to check
     * @return {Promise<boolean>} Promise resolved with boolean: true if the promise is rejected or false if it's resolved.
     */
    CoreUtilsProvider.prototype.promiseFails = function (promise) {
        return promise.then(function () {
            return false;
        }).catch(function () {
            return true;
        });
    };
    /**
     * Given a promise, returns true if it's resolved or false if it's rejected.
     *
     * @param {Promise<any>} promise Promise to check
     * @return {Promise<boolean>} Promise resolved with boolean: true if the promise it's resolved or false if it's rejected.
     */
    CoreUtilsProvider.prototype.promiseWorks = function (promise) {
        return promise.then(function () {
            return true;
        }).catch(function () {
            return false;
        });
    };
    /**
     * Tests to see whether two arrays or objects have the same value at a particular key.
     * Missing values are replaced by '', and the values are compared with ===.
     * Booleans and numbers are cast to string before comparing.
     *
     * @param {any} obj1 The first object or array.
     * @param {any} obj2 The second object or array.
     * @param {string} key Key to check.
     * @return {boolean} Whether the two objects/arrays have the same value (or lack of one) for a given key.
     */
    CoreUtilsProvider.prototype.sameAtKeyMissingIsBlank = function (obj1, obj2, key) {
        var value1 = typeof obj1[key] != 'undefined' ? obj1[key] : '', value2 = typeof obj2[key] != 'undefined' ? obj2[key] : '';
        if (typeof value1 == 'number' || typeof value1 == 'boolean') {
            value1 = '' + value1;
        }
        if (typeof value2 == 'number' || typeof value2 == 'boolean') {
            value2 = '' + value2;
        }
        return value1 === value2;
    };
    /**
     * Stringify an object, sorting the properties. It doesn't sort arrays, only object properties. E.g.:
     * {b: 2, a: 1} -> '{"a":1,"b":2}'
     *
     * @param {object} obj Object to stringify.
     * @return {string} Stringified object.
     */
    CoreUtilsProvider.prototype.sortAndStringify = function (obj) {
        return JSON.stringify(this.sortProperties(obj));
    };
    /**
     * Given an object, sort its properties and the properties of all the nested objects.
     *
     * @param {object} obj The object to sort. If it isn't an object, the original value will be returned.
     * @return {object} Sorted object.
     */
    CoreUtilsProvider.prototype.sortProperties = function (obj) {
        var _this = this;
        if (typeof obj == 'object' && !Array.isArray(obj)) {
            // It's an object, sort it.
            return Object.keys(obj).sort().reduce(function (accumulator, key) {
                // Always call sort with the value. If it isn't an object, the original value will be returned.
                accumulator[key] = _this.sortProperties(obj[key]);
                return accumulator;
            }, {});
        }
        else {
            return obj;
        }
    };
    /**
     * Sum the filesizes from a list of files checking if the size will be partial or totally calculated.
     *
     * @param {any[]} files List of files to sum its filesize.
     * @return {{size: number, total: boolean}} File size and a boolean to indicate if it is the total size or only partial.
     */
    CoreUtilsProvider.prototype.sumFileSizes = function (files) {
        var result = {
            size: 0,
            total: true
        };
        files.forEach(function (file) {
            if (typeof file.filesize == 'undefined') {
                // We don't have the file size, cannot calculate its total size.
                result.total = false;
            }
            else {
                result.size += file.filesize;
            }
        });
        return result;
    };
    /**
     * Converts locale specific floating point/comma number back to standard PHP float value.
     * Do NOT try to do any math operations before this conversion on any user submitted floats!
     * Based on Moodle's unformat_float function.
     *
     * @param {any} localeFloat Locale aware float representation.
     * @return {any} False if bad format, empty string if empty value or the parsed float if not.
     */
    CoreUtilsProvider.prototype.unformatFloat = function (localeFloat) {
        // Bad format on input type number.
        if (typeof localeFloat == 'undefined') {
            return false;
        }
        // Empty (but not zero).
        if (localeFloat == null) {
            return '';
        }
        // Convert float to string.
        localeFloat += '';
        localeFloat = localeFloat.trim();
        if (localeFloat == '') {
            return '';
        }
        var localeSeparator = this.translate.instant('core.decsep');
        localeFloat = localeFloat.replace(' ', ''); // No spaces - those might be used as thousand separators.
        localeFloat = localeFloat.replace(localeSeparator, '.');
        localeFloat = parseFloat(localeFloat);
        // Bad format.
        if (isNaN(localeFloat)) {
            return false;
        }
        return localeFloat;
    };
    /**
     * Return an array without duplicate values.
     *
     * @param {any[]} array The array to treat.
     * @param [key] Key of the property that must be unique. If not specified, the whole entry.
     * @return {any[]} Array without duplicate values.
     */
    CoreUtilsProvider.prototype.uniqueArray = function (array, key) {
        var filtered = [], unique = [], len = array.length;
        for (var i = 0; i < len; i++) {
            var entry = array[i], value = key ? entry[key] : entry;
            if (unique.indexOf(value) == -1) {
                unique.push(value);
                filtered.push(entry);
            }
        }
        return filtered;
    };
    CoreUtilsProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__ionic_native_in_app_browser__["a" /* InAppBrowser */], __WEBPACK_IMPORTED_MODULE_4__app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_3__ionic_native_clipboard__["a" /* Clipboard */],
            __WEBPACK_IMPORTED_MODULE_5__dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_7__logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_8__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */], __WEBPACK_IMPORTED_MODULE_9__lang__["a" /* CoreLangProvider */], __WEBPACK_IMPORTED_MODULE_6__events__["a" /* CoreEventsProvider */]])
    ], CoreUtilsProvider);
    return CoreUtilsProvider;
}());

//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 950:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSite; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ngx_translate_core__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_db__ = __webpack_require__(201);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_events__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_file__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_ws__ = __webpack_require__(114);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_dom__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_text__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_utils_time__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_utils_url__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__core_constants__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__configconstants__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_ts_md5_dist_md5__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_ts_md5_dist_md5___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_15_ts_md5_dist_md5__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
















/**
 * Class that represents a site (combination of site + user).
 * It will have all the site data and provide utility functions regarding a site.
 * To add tables to the site's database, please use CoreSitesProvider.createTablesFromSchema. This will make sure that
 * the tables are created in all the sites, not just the current one.
 */
var CoreSite = /** @class */ (function () {
    /**
     * Create a site.
     *
     * @param {Injector} injector Angular injector to prevent having to pass all the required services.
     * @param {string} id Site ID.
     * @param {string} siteUrl Site URL.
     * @param {string} [token] Site's WS token.
     * @param {any} [info] Site info.
     * @param {string} [privateToken] Private token.
     * @param {any} [config] Site public config.
     * @param {boolean} [loggedOut] Whether user is logged out.
     */
    function CoreSite(injector, id, siteUrl, token, infos, privateToken, config, loggedOut) {
        this.id = id;
        this.siteUrl = siteUrl;
        this.token = token;
        this.infos = infos;
        this.privateToken = privateToken;
        this.config = config;
        this.loggedOut = loggedOut;
        // Variables for the database.
        this.WS_CACHE_TABLE = 'wscache';
        this.tableSchema = {
            name: this.WS_CACHE_TABLE,
            columns: [
                {
                    name: 'id',
                    type: 'TEXT',
                    primaryKey: true
                },
                {
                    name: 'data',
                    type: 'TEXT'
                },
                {
                    name: 'key',
                    type: 'TEXT'
                },
                {
                    name: 'expirationTime',
                    type: 'INTEGER'
                }
            ]
        };
        this.cleanUnicode = false;
        this.lastAutoLogin = 0;
        this.moodleReleases = {
            3.1: 2016052300,
            3.2: 2016120500,
            3.3: 2017051503,
            3.4: 2017111300
        };
        // Inject the required services.
        var logger = injector.get(__WEBPACK_IMPORTED_MODULE_6__providers_logger__["a" /* CoreLoggerProvider */]);
        this.appProvider = injector.get(__WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */]);
        this.dbProvider = injector.get(__WEBPACK_IMPORTED_MODULE_3__providers_db__["a" /* CoreDbProvider */]);
        this.domUtils = injector.get(__WEBPACK_IMPORTED_MODULE_8__providers_utils_dom__["a" /* CoreDomUtilsProvider */]);
        this.eventsProvider = injector.get(__WEBPACK_IMPORTED_MODULE_4__providers_events__["a" /* CoreEventsProvider */]);
        this.fileProvider = injector.get(__WEBPACK_IMPORTED_MODULE_5__providers_file__["a" /* CoreFileProvider */]);
        this.http = injector.get(__WEBPACK_IMPORTED_MODULE_1__angular_common_http__["b" /* HttpClient */]);
        this.textUtils = injector.get(__WEBPACK_IMPORTED_MODULE_9__providers_utils_text__["a" /* CoreTextUtilsProvider */]);
        this.timeUtils = injector.get(__WEBPACK_IMPORTED_MODULE_10__providers_utils_time__["a" /* CoreTimeUtilsProvider */]);
        this.translate = injector.get(__WEBPACK_IMPORTED_MODULE_0__ngx_translate_core__["c" /* TranslateService */]);
        this.utils = injector.get(__WEBPACK_IMPORTED_MODULE_12__providers_utils_utils__["a" /* CoreUtilsProvider */]);
        this.urlUtils = injector.get(__WEBPACK_IMPORTED_MODULE_11__providers_utils_url__["a" /* CoreUrlUtilsProvider */]);
        this.wsProvider = injector.get(__WEBPACK_IMPORTED_MODULE_7__providers_ws__["a" /* CoreWSProvider */]);
        this.logger = logger.getInstance('CoreWSProvider');
        if (this.id) {
            this.initDB();
        }
    }
    /**
     * Initialize the database.
     */
    CoreSite.prototype.initDB = function () {
        this.db = this.dbProvider.getDB('Site-' + this.id);
        this.db.createTableFromSchema(this.tableSchema);
    };
    /**
     * Get site ID.
     *
     * @return {string} Site ID.
     */
    CoreSite.prototype.getId = function () {
        return this.id;
    };
    /**
     * Get site URL.
     *
     * @return {string} Site URL.
     */
    CoreSite.prototype.getURL = function () {
        return this.siteUrl;
    };
    /**
     * Get site token.
     *
     * @return {string} Site token.
     */
    CoreSite.prototype.getToken = function () {
        return this.token;
    };
    /**
     * Get site info.
     *
     * @return {any} Site info.
     */
    CoreSite.prototype.getInfo = function () {
        return this.infos;
    };
    /**
     * Get site private token.
     *
     * @return {string} Site private token.
     */
    CoreSite.prototype.getPrivateToken = function () {
        return this.privateToken;
    };
    /**
     * Get site DB.
     *
     * @return {SQLiteDB} Site DB.
     */
    CoreSite.prototype.getDb = function () {
        return this.db;
    };
    /**
     * Get site user's ID.
     *
     * @return {number} User's ID.
     */
    CoreSite.prototype.getUserId = function () {
        if (typeof this.infos != 'undefined' && typeof this.infos.userid != 'undefined') {
            return this.infos.userid;
        }
    };
    /**
     * Get site Course ID for frontpage course. If not declared it will return 1 as default.
     *
     * @return {number} Site Home ID.
     */
    CoreSite.prototype.getSiteHomeId = function () {
        return this.infos && this.infos.siteid || 1;
    };
    /**
     * Set site ID.
     *
     * @param {string} New ID.
     */
    CoreSite.prototype.setId = function (id) {
        this.id = id;
        this.initDB();
    };
    /**
     * Set site token.
     *
     * @param {string} New token.
     */
    CoreSite.prototype.setToken = function (token) {
        this.token = token;
    };
    /**
     * Set site private token.
     *
     * @param {string} privateToken New private token.
     */
    CoreSite.prototype.setPrivateToken = function (privateToken) {
        this.privateToken = privateToken;
    };
    /**
     * Check if user logged out from the site and needs to authenticate again.
     *
     * @return {boolean} Whether is logged out.
     */
    CoreSite.prototype.isLoggedOut = function () {
        return !!this.loggedOut;
    };
    /**
     * Set site info.
     *
     * @param {any} New info.
     */
    CoreSite.prototype.setInfo = function (infos) {
        this.infos = infos;
    };
    /**
     * Set site config.
     *
     * @param {any} Config.
     */
    CoreSite.prototype.setConfig = function (config) {
        this.config = config;
    };
    /**
     * Set site logged out.
     *
     * @param {boolean} loggedOut True if logged out and needs to authenticate again, false otherwise.
     */
    CoreSite.prototype.setLoggedOut = function (loggedOut) {
        this.loggedOut = !!loggedOut;
    };
    /**
     * Can the user access their private files?
     *
     * @return {boolean} Whether can access my files.
     */
    CoreSite.prototype.canAccessMyFiles = function () {
        var infos = this.getInfo();
        return infos && (typeof infos.usercanmanageownfiles === 'undefined' || infos.usercanmanageownfiles);
    };
    /**
     * Can the user download files?
     *
     * @return {boolean} Whether can download files.
     */
    CoreSite.prototype.canDownloadFiles = function () {
        var infos = this.getInfo();
        return infos && infos.downloadfiles;
    };
    /**
     * Can the user use an advanced feature?
     *
     * @param {string} feature The name of the feature.
     * @param {boolean} [whenUndefined=true] The value to return when the parameter is undefined.
     * @return {boolean} Whether can use advanced feature.
     */
    CoreSite.prototype.canUseAdvancedFeature = function (feature, whenUndefined) {
        if (whenUndefined === void 0) { whenUndefined = true; }
        var infos = this.getInfo();
        var canUse = true;
        if (typeof infos.advancedfeatures === 'undefined') {
            canUse = whenUndefined;
        }
        else {
            for (var i in infos.advancedfeatures) {
                var item = infos.advancedfeatures[i];
                if (item.name === feature && parseInt(item.value, 10) === 0) {
                    canUse = false;
                }
            }
        }
        return canUse;
    };
    /**
     * Can the user upload files?
     *
     * @return {boolean} Whether can upload files.
     */
    CoreSite.prototype.canUploadFiles = function () {
        var infos = this.getInfo();
        return infos && infos.uploadfiles;
    };
    /**
     * Fetch site info from the Moodle site.
     *
     * @return {Promise<any>} A promise to be resolved when the site info is retrieved.
     */
    CoreSite.prototype.fetchSiteInfo = function () {
        // The get_site_info WS call won't be cached.
        var preSets = {
            getFromCache: false,
            saveToCache: false
        };
        // Reset clean Unicode to check if it's supported again.
        this.cleanUnicode = false;
        return this.read('core_webservice_get_site_info', {}, preSets);
    };
    /**
     * Read some data from the Moodle site using WS. Requests are cached by default.
     *
     * @param {string} method WS method to use.
     * @param {any} data Data to send to the WS.
     * @param {CoreSiteWSPreSets} [preSets] Extra options.
     * @return {Promise<any>} Promise resolved with the response, rejected with CoreWSError if it fails.
     */
    CoreSite.prototype.read = function (method, data, preSets) {
        preSets = preSets || {};
        if (typeof preSets.getFromCache == 'undefined') {
            preSets.getFromCache = true;
        }
        if (typeof preSets.saveToCache == 'undefined') {
            preSets.saveToCache = true;
        }
        return this.request(method, data, preSets);
    };
    /**
     * Sends some data to the Moodle site using WS. Requests are NOT cached by default.
     *
     * @param {string} method  WS method to use.
     * @param {any} data Data to send to the WS.
     * @param {CoreSiteWSPreSets} [preSets] Extra options.
     * @return {Promise<any>} Promise resolved with the response, rejected with CoreWSError if it fails.
     */
    CoreSite.prototype.write = function (method, data, preSets) {
        preSets = preSets || {};
        if (typeof preSets.getFromCache == 'undefined') {
            preSets.getFromCache = false;
        }
        if (typeof preSets.saveToCache == 'undefined') {
            preSets.saveToCache = false;
        }
        if (typeof preSets.emergencyCache == 'undefined') {
            preSets.emergencyCache = false;
        }
        return this.request(method, data, preSets);
    };
    /**
     * WS request to the site.
     *
     * @param {string} method The WebService method to be called.
     * @param {any} data Arguments to pass to the method.
     * @param {CoreSiteWSPreSets} preSets Extra options.
     * @param {boolean} [retrying] True if we're retrying the call for some reason. This is to prevent infinite loops.
     * @return {Promise<any>} Promise resolved with the response, rejected with CoreWSError if it fails.
     * @description
     *
     * Sends a webservice request to the site. This method will automatically add the
     * required parameters and pass it on to the low level API in CoreWSProvider.call().
     *
     * Caching is also implemented, when enabled this method will returned a cached version of the request if the
     * data hasn't expired.
     *
     * This method is smart which means that it will try to map the method to a compatibility one if need be, usually this
     * means that it will fallback on the 'local_mobile_' prefixed function if it is available and the non-prefixed is not.
     */
    CoreSite.prototype.request = function (method, data, preSets, retrying) {
        var _this = this;
        var initialToken = this.token;
        data = data || {};
        // Check if the method is available, use a prefixed version if possible.
        // We ignore this check when we do not have the site info, as the list of functions is not loaded yet.
        if (this.getInfo() && !this.wsAvailable(method, false)) {
            var compatibilityMethod = __WEBPACK_IMPORTED_MODULE_13__core_constants__["a" /* CoreConstants */].WS_PREFIX + method;
            if (this.wsAvailable(compatibilityMethod, false)) {
                this.logger.info("Using compatibility WS method '" + compatibilityMethod + "'");
                method = compatibilityMethod;
            }
            else {
                this.logger.error("WS function '" + method + "' is not available, even in compatibility mode.");
                return Promise.reject(this.wsProvider.createFakeWSError('core.wsfunctionnotavailable', true));
            }
        }
        var wsPreSets = {
            wsToken: this.token,
            siteUrl: this.siteUrl,
            cleanUnicode: this.cleanUnicode,
            typeExpected: preSets.typeExpected,
            responseExpected: preSets.responseExpected
        };
        if (wsPreSets.cleanUnicode && this.textUtils.hasUnicodeData(data)) {
            // Data will be cleaned, notify the user.
            this.domUtils.showToast('core.unicodenotsupported', true, 3000);
        }
        else {
            // No need to clean data in this call.
            wsPreSets.cleanUnicode = false;
        }
        // Enable text filtering by default.
        data.moodlewssettingfilter = preSets.filter === false ? false : true;
        data.moodlewssettingfileurl = preSets.rewriteurls === false ? false : true;
        // Convert the values to string before starting the cache process.
        try {
            data = this.wsProvider.convertValuesToString(data, wsPreSets.cleanUnicode);
        }
        catch (e) {
            // Empty cleaned text found.
            return Promise.reject(this.wsProvider.createFakeWSError('core.unicodenotsupportedcleanerror', true));
        }
        return this.getFromCache(method, data, preSets).catch(function () {
            // Do not pass those options to the core WS factory.
            return _this.wsProvider.call(method, data, wsPreSets).then(function (response) {
                if (preSets.saveToCache) {
                    _this.saveToCache(method, data, response, preSets);
                }
                // We pass back a clone of the original object, this may prevent errors if in the callback the object is modified.
                return _this.utils.clone(response);
            }).catch(function (error) {
                if (error.errorcode == 'invalidtoken' ||
                    (error.errorcode == 'accessexception' && error.message.indexOf('Invalid token - token expired') > -1)) {
                    if (initialToken !== _this.token && !retrying) {
                        // Token has changed, retry with the new token.
                        return _this.request(method, data, preSets, true);
                    }
                    else if (_this.appProvider.isSSOAuthenticationOngoing()) {
                        // There's an SSO authentication ongoing, wait for it to finish and try again.
                        return _this.appProvider.waitForSSOAuthentication().then(function () {
                            return _this.request(method, data, preSets, true);
                        });
                    }
                    // Session expired, trigger event.
                    _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_4__providers_events__["a" /* CoreEventsProvider */].SESSION_EXPIRED, {}, _this.id);
                    // Change error message. We'll try to get data from cache.
                    error.message = _this.translate.instant('core.lostconnection');
                }
                else if (error.errorcode === 'userdeleted') {
                    // User deleted, trigger event.
                    _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_4__providers_events__["a" /* CoreEventsProvider */].USER_DELETED, { params: data }, _this.id);
                    error.message = _this.translate.instant('core.userdeleted');
                    return Promise.reject(error);
                }
                else if (error.errorcode === 'forcepasswordchangenotice') {
                    // Password Change Forced, trigger event.
                    _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_4__providers_events__["a" /* CoreEventsProvider */].PASSWORD_CHANGE_FORCED, {}, _this.id);
                    error.message = _this.translate.instant('core.forcepasswordchangenotice');
                    return Promise.reject(error);
                }
                else if (error.errorcode === 'usernotfullysetup') {
                    // User not fully setup, trigger event.
                    _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_4__providers_events__["a" /* CoreEventsProvider */].USER_NOT_FULLY_SETUP, {}, _this.id);
                    error.message = _this.translate.instant('core.usernotfullysetup');
                    return Promise.reject(error);
                }
                else if (error.errorcode === 'sitepolicynotagreed') {
                    // Site policy not agreed, trigger event.
                    _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_4__providers_events__["a" /* CoreEventsProvider */].SITE_POLICY_NOT_AGREED, {}, _this.id);
                    error.message = _this.translate.instant('core.sitepolicynotagreederror');
                    return Promise.reject(error);
                }
                else if (error.errorcode === 'dmlwriteexception' && _this.textUtils.hasUnicodeData(data)) {
                    if (!_this.cleanUnicode) {
                        // Try again cleaning unicode.
                        _this.cleanUnicode = true;
                        return _this.request(method, data, preSets);
                    }
                    // This should not happen.
                    error.message = _this.translate.instant('core.unicodenotsupported');
                    return Promise.reject(error);
                }
                else if (typeof preSets.emergencyCache !== 'undefined' && !preSets.emergencyCache) {
                    _this.logger.debug("WS call '" + method + "' failed. Emergency cache is forbidden, rejecting.");
                    return Promise.reject(error);
                }
                _this.logger.debug("WS call '" + method + "' failed. Trying to use the emergency cache.");
                preSets.omitExpires = true;
                preSets.getFromCache = true;
                return _this.getFromCache(method, data, preSets, true).catch(function () {
                    return Promise.reject(error);
                });
            });
        });
    };
    /**
     * Check if a WS is available in this site.
     *
     * @param {string} method WS name.
     * @param {boolean} [checkPrefix=true] When true also checks with the compatibility prefix.
     * @return {boolean} Whether the WS is available.
     */
    CoreSite.prototype.wsAvailable = function (method, checkPrefix) {
        if (checkPrefix === void 0) { checkPrefix = true; }
        if (typeof this.infos == 'undefined') {
            return false;
        }
        for (var i = 0; i < this.infos.functions.length; i++) {
            var func = this.infos.functions[i];
            if (func.name == method) {
                return true;
            }
        }
        // Let's try again with the compatibility prefix.
        if (checkPrefix) {
            return this.wsAvailable(__WEBPACK_IMPORTED_MODULE_13__core_constants__["a" /* CoreConstants */].WS_PREFIX + method, false);
        }
        return false;
    };
    /**
     * Get cache ID.
     *
     * @param {string} method The WebService method.
     * @param {any} data Arguments to pass to the method.
     * @return {string} Cache ID.
     */
    CoreSite.prototype.getCacheId = function (method, data) {
        return __WEBPACK_IMPORTED_MODULE_15_ts_md5_dist_md5__["Md5"].hashAsciiStr(method + ':' + this.utils.sortAndStringify(data));
    };
    /**
     * Get a WS response from cache.
     *
     * @param {string} method The WebService method to be called.
     * @param {any} data Arguments to pass to the method.
     * @param {CoreSiteWSPreSets} preSets Extra options.
     * @param {boolean} emergency Whether it's an "emergency" cache call (WS call failed).
     * @return {Promise<any>} Promise resolved with the WS response.
     */
    CoreSite.prototype.getFromCache = function (method, data, preSets, emergency) {
        var _this = this;
        var id = this.getCacheId(method, data);
        var promise;
        if (!this.db || !preSets.getFromCache) {
            return Promise.reject(null);
        }
        if (preSets.getCacheUsingCacheKey || (emergency && preSets.getEmergencyCacheUsingCacheKey)) {
            promise = this.db.getRecords(this.WS_CACHE_TABLE, { key: preSets.cacheKey }).then(function (entries) {
                if (!entries.length) {
                    // Cache key not found, get by params sent.
                    return _this.db.getRecord(_this.WS_CACHE_TABLE, { id: id });
                }
                else if (entries.length > 1) {
                    // More than one entry found. Search the one with same ID as this call.
                    for (var i = 0, len = entries.length; i < len; i++) {
                        var entry = entries[i];
                        if (entry.id == id) {
                            return entry;
                        }
                    }
                }
                return entries[0];
            });
        }
        else {
            promise = this.db.getRecord(this.WS_CACHE_TABLE, { id: id });
        }
        return promise.then(function (entry) {
            var now = Date.now();
            preSets.omitExpires = preSets.omitExpires || !_this.appProvider.isOnline();
            if (!preSets.omitExpires) {
                if (now > entry.expirationTime) {
                    _this.logger.debug('Cached element found, but it is expired');
                    return Promise.reject(null);
                }
            }
            if (typeof entry != 'undefined' && typeof entry.data != 'undefined') {
                var expires = (entry.expirationTime - now) / 1000;
                _this.logger.info("Cached element found, id: " + id + " expires in " + expires + " seconds");
                return JSON.parse(entry.data);
            }
            return Promise.reject(null);
        });
    };
    /**
     * Save a WS response to cache.
     *
     * @param {string} method The WebService method.
     * @param {any} data Arguments to pass to the method.
     * @param {any} response The WS response.
     * @param {CoreSiteWSPreSets} preSets Extra options.
     * @return {Promise<any>} Promise resolved when the response is saved.
     */
    CoreSite.prototype.saveToCache = function (method, data, response, preSets) {
        var _this = this;
        var id = this.getCacheId(method, data), entry = {
            id: id,
            data: JSON.stringify(response)
        };
        var cacheExpirationTime = __WEBPACK_IMPORTED_MODULE_14__configconstants__["a" /* CoreConfigConstants */].cache_expiration_time, promise;
        if (!this.db) {
            return Promise.reject(null);
        }
        else {
            if (preSets.uniqueCacheKey) {
                // Cache key must be unique, delete all entries with same cache key.
                promise = this.deleteFromCache(method, data, preSets, true).catch(function () {
                    // Ignore errors.
                });
            }
            else {
                promise = Promise.resolve();
            }
            return promise.then(function () {
                cacheExpirationTime = isNaN(cacheExpirationTime) ? 300000 : cacheExpirationTime;
                entry.expirationTime = new Date().getTime() + cacheExpirationTime;
                if (preSets.cacheKey) {
                    entry.key = preSets.cacheKey;
                }
                return _this.db.insertOrUpdateRecord(_this.WS_CACHE_TABLE, entry, { id: id });
            });
        }
    };
    /**
     * Delete a WS cache entry or entries.
     *
     * @param {string} method The WebService method to be called.
     * @param {any} data Arguments to pass to the method.
     * @param {CoreSiteWSPreSets} preSets Extra options.
     * @param {boolean} [allCacheKey] True to delete all entries with the cache key, false to delete only by ID.
     * @return {Promise<any>} Promise resolved when the entries are deleted.
     */
    CoreSite.prototype.deleteFromCache = function (method, data, preSets, allCacheKey) {
        var id = this.getCacheId(method, data);
        if (!this.db) {
            return Promise.reject(null);
        }
        else {
            if (allCacheKey) {
                return this.db.deleteRecords(this.WS_CACHE_TABLE, { key: preSets.cacheKey });
            }
            else {
                return this.db.deleteRecords(this.WS_CACHE_TABLE, { id: id });
            }
        }
    };
    /*
     * Uploads a file using Cordova File API.
     *
     * @param {string} filePath File path.
     * @param {CoreWSFileUploadOptions} options File upload options.
     * @param {Function} [onProgress] Function to call on progress.
     * @return {Promise<any>} Promise resolved when uploaded.
     */
    CoreSite.prototype.uploadFile = function (filePath, options, onProgress) {
        if (!options.fileArea) {
            options.fileArea = 'draft';
        }
        return this.wsProvider.uploadFile(filePath, options, {
            siteUrl: this.siteUrl,
            wsToken: this.token
        }, onProgress);
    };
    /**
     * Invalidates all the cache entries.
     *
     * @return {Promise<any>} Promise resolved when the cache entries are invalidated.
     */
    CoreSite.prototype.invalidateWsCache = function () {
        if (!this.db) {
            return Promise.reject(null);
        }
        this.logger.debug('Invalidate all the cache for site: ' + this.id);
        return this.db.updateRecords(this.WS_CACHE_TABLE, { expirationTime: 0 });
    };
    /**
     * Invalidates all the cache entries with a certain key.
     *
     * @param {string} key Key to search.
     * @return {Promise<any>} Promise resolved when the cache entries are invalidated.
     */
    CoreSite.prototype.invalidateWsCacheForKey = function (key) {
        if (!this.db) {
            return Promise.reject(null);
        }
        if (!key) {
            return Promise.resolve();
        }
        this.logger.debug('Invalidate cache for key: ' + key);
        return this.db.updateRecords(this.WS_CACHE_TABLE, { expirationTime: 0 }, { key: key });
    };
    /**
     * Invalidates all the cache entries in an array of keys.
     *
     * @param {string[]} keys Keys to search.
     * @return {Promise<any>} Promise resolved when the cache entries are invalidated.
     */
    CoreSite.prototype.invalidateMultipleWsCacheForKey = function (keys) {
        var _this = this;
        if (!this.db) {
            return Promise.reject(null);
        }
        if (!keys || !keys.length) {
            return Promise.resolve();
        }
        var promises = [];
        this.logger.debug('Invalidating multiple cache keys');
        keys.forEach(function (key) {
            promises.push(_this.invalidateWsCacheForKey(key));
        });
        return Promise.all(promises);
    };
    /**
     * Invalidates all the cache entries whose key starts with a certain value.
     *
     * @param {string} key Key to search.
     * @return {Promise}    Promise resolved when the cache entries are invalidated.
     */
    CoreSite.prototype.invalidateWsCacheForKeyStartingWith = function (key) {
        if (!this.db) {
            return Promise.reject(null);
        }
        if (!key) {
            return Promise.resolve();
        }
        this.logger.debug('Invalidate cache for key starting with: ' + key);
        var sql = 'UPDATE ' + this.WS_CACHE_TABLE + ' SET expirationTime=0 WHERE key LIKE ?';
        return this.db.execute(sql, [key + '%']);
    };
    /**
     * Generic function for adding the wstoken to Moodle urls and for pointing to the correct script.
     * Uses CoreUtilsProvider.fixPluginfileURL, passing site's token.
     *
     * @param {string} url The url to be fixed.
     * @return {string} Fixed URL.
     */
    CoreSite.prototype.fixPluginfileURL = function (url) {
        return this.urlUtils.fixPluginfileURL(url, this.token);
    };
    /**
     * Deletes site's DB.
     *
     * @return {Promise<any>} Promise to be resolved when the DB is deleted.
     */
    CoreSite.prototype.deleteDB = function () {
        return this.dbProvider.deleteDB('Site-' + this.id);
    };
    /**
     * Deletes site's folder.
     *
     * @return {Promise<any>} Promise to be resolved when the DB is deleted.
     */
    CoreSite.prototype.deleteFolder = function () {
        if (this.fileProvider.isAvailable()) {
            var siteFolder = this.fileProvider.getSiteFolder(this.id);
            return this.fileProvider.removeDir(siteFolder).catch(function () {
                // Ignore any errors, $mmFS.removeDir fails if folder doesn't exists.
            });
        }
        else {
            return Promise.resolve();
        }
    };
    /**
     * Get space usage of the site.
     *
     * @return {Promise<number>} Promise resolved with the site space usage (size).
     */
    CoreSite.prototype.getSpaceUsage = function () {
        if (this.fileProvider.isAvailable()) {
            var siteFolderPath = this.fileProvider.getSiteFolder(this.id);
            return this.fileProvider.getDirectorySize(siteFolderPath).catch(function () {
                return 0;
            });
        }
        else {
            return Promise.resolve(0);
        }
    };
    /**
     * Returns the URL to the documentation of the app, based on Moodle version and current language.
     *
     * @param {string} [page] Docs page to go to.
     * @return {Promise<string>} Promise resolved with the Moodle docs URL.
     */
    CoreSite.prototype.getDocsUrl = function (page) {
        var release = this.infos.release ? this.infos.release : undefined;
        return this.urlUtils.getDocsUrl(release, page);
    };
    /**
     * Check if the local_mobile plugin is installed in the Moodle site.
     *
     * @param {boolean} [retrying] True if we're retrying the check.
     * @return {Promise<LocalMobileResponse>} Promise resolved when the check is done.
     */
    CoreSite.prototype.checkLocalMobilePlugin = function (retrying) {
        var _this = this;
        var checkUrl = this.siteUrl + '/local/mobile/check.php', service = __WEBPACK_IMPORTED_MODULE_14__configconstants__["a" /* CoreConfigConstants */].wsextservice;
        if (!service) {
            // External service not defined.
            return Promise.resolve({ code: 0 });
        }
        var observable = this.http.post(checkUrl, { service: service }).timeout(__WEBPACK_IMPORTED_MODULE_13__core_constants__["a" /* CoreConstants */].WS_TIMEOUT);
        return this.utils.observableToPromise(observable).then(function (data) {
            if (typeof data != 'undefined' && data.errorcode === 'requirecorrectaccess') {
                if (!retrying) {
                    _this.siteUrl = _this.urlUtils.addOrRemoveWWW(_this.siteUrl);
                    return _this.checkLocalMobilePlugin(true);
                }
                else {
                    return Promise.reject(data.error);
                }
            }
            else if (typeof data == 'undefined' || typeof data.code == 'undefined') {
                // The local_mobile returned something we didn't expect. Let's assume it's not installed.
                return { code: 0, warning: 'core.login.localmobileunexpectedresponse' };
            }
            var code = parseInt(data.code, 10);
            if (data.error) {
                switch (code) {
                    case 1:
                        // Site in maintenance mode.
                        return Promise.reject(_this.translate.instant('core.login.siteinmaintenance'));
                    case 2:
                        // Web services not enabled.
                        return Promise.reject(_this.translate.instant('core.login.webservicesnotenabled'));
                    case 3:
                        // Extended service not enabled, but the official is enabled.
                        return { code: 0 };
                    case 4:
                        // Neither extended or official services enabled.
                        return Promise.reject(_this.translate.instant('core.login.mobileservicesnotenabled'));
                    default:
                        return Promise.reject(_this.translate.instant('core.unexpectederror'));
                }
            }
            else {
                return { code: code, service: service, coresupported: !!data.coresupported };
            }
        }, function () {
            return { code: 0 };
        });
    };
    /**
     * Check if local_mobile has been installed in Moodle.
     *
     * @return {boolean} Whether the App is able to use local_mobile plugin for this site.
     */
    CoreSite.prototype.checkIfAppUsesLocalMobile = function () {
        var appUsesLocalMobile = false;
        if (!this.infos || !this.infos.functions) {
            return appUsesLocalMobile;
        }
        this.infos.functions.forEach(function (func) {
            if (func.name.indexOf(__WEBPACK_IMPORTED_MODULE_13__core_constants__["a" /* CoreConstants */].WS_PREFIX) != -1) {
                appUsesLocalMobile = true;
            }
        });
        return appUsesLocalMobile;
    };
    /**
     * Check if local_mobile has been installed in Moodle but the app is not using it.
     *
     * @return {Promise<any>} Promise resolved it local_mobile was added, rejected otherwise.
     */
    CoreSite.prototype.checkIfLocalMobileInstalledAndNotUsed = function () {
        var appUsesLocalMobile = this.checkIfAppUsesLocalMobile();
        if (appUsesLocalMobile) {
            // App already uses local_mobile, it wasn't added.
            return Promise.reject(null);
        }
        return this.checkLocalMobilePlugin().then(function (data) {
            if (typeof data.service == 'undefined') {
                // The local_mobile NOT installed. Reject.
                return Promise.reject(null);
            }
            return data;
        });
    };
    /**
     * Check if a URL belongs to this site.
     *
     * @param {string} url URL to check.
     * @return {boolean} Whether the URL belongs to this site.
     */
    CoreSite.prototype.containsUrl = function (url) {
        if (!url) {
            return false;
        }
        var siteUrl = this.urlUtils.removeProtocolAndWWW(this.siteUrl);
        url = this.urlUtils.removeProtocolAndWWW(url);
        return url.indexOf(siteUrl) == 0;
    };
    /**
     * Get the public config of this site.
     *
     * @return {Promise<any>} Promise resolved with public config. Rejected with an object if error, see CoreWSProvider.callAjax.
     */
    CoreSite.prototype.getPublicConfig = function () {
        var _this = this;
        return this.wsProvider.callAjax('tool_mobile_get_public_config', {}, { siteUrl: this.siteUrl }).then(function (config) {
            // Use the wwwroot returned by the server.
            if (config.httpswwwroot) {
                _this.siteUrl = config.httpswwwroot;
            }
            return config;
        });
    };
    /**
     * Open a URL in browser using auto-login in the Moodle site if available.
     *
     * @param {string} url The URL to open.
     * @param {string} [alertMessage] If defined, an alert will be shown before opening the browser.
     * @return {Promise<any>} Promise resolved when done, rejected otherwise.
     */
    CoreSite.prototype.openInBrowserWithAutoLogin = function (url, alertMessage) {
        return this.openWithAutoLogin(false, url, undefined, alertMessage);
    };
    /**
     * Open a URL in browser using auto-login in the Moodle site if available and the URL belongs to the site.
     *
     * @param {string} url The URL to open.
     * @param {string} [alertMessage] If defined, an alert will be shown before opening the browser.
     * @return {Promise<any>} Promise resolved when done, rejected otherwise.
     */
    CoreSite.prototype.openInBrowserWithAutoLoginIfSameSite = function (url, alertMessage) {
        return this.openWithAutoLoginIfSameSite(false, url, undefined, alertMessage);
    };
    /**
     * Open a URL in inappbrowser using auto-login in the Moodle site if available.
     *
     * @param {string} url The URL to open.
     * @param {any} [options] Override default options passed to InAppBrowser.
     * @param {string} [alertMessage] If defined, an alert will be shown before opening the inappbrowser.
     * @return {Promise<InAppBrowserObject>} Promise resolved when done.
     */
    CoreSite.prototype.openInAppWithAutoLogin = function (url, options, alertMessage) {
        return this.openWithAutoLogin(true, url, options, alertMessage);
    };
    /**
     * Open a URL in inappbrowser using auto-login in the Moodle site if available and the URL belongs to the site.
     *
     * @param {string} url The URL to open.
     * @param {object} [options] Override default options passed to inappbrowser.
     * @param {string} [alertMessage] If defined, an alert will be shown before opening the inappbrowser.
     * @return {Promise<InAppBrowserObject>} Promise resolved when done.
     */
    CoreSite.prototype.openInAppWithAutoLoginIfSameSite = function (url, options, alertMessage) {
        return this.openWithAutoLoginIfSameSite(true, url, options, alertMessage);
    };
    /**
     * Open a URL in browser or InAppBrowser using auto-login in the Moodle site if available.
     *
     * @param {boolean} inApp True to open it in InAppBrowser, false to open in browser.
     * @param {string} url The URL to open.
     * @param {object} [options] Override default options passed to $cordovaInAppBrowser#open.
     * @param {string} [alertMessage] If defined, an alert will be shown before opening the browser/inappbrowser.
     * @return {Promise<InAppBrowserObject>} Promise resolved when done. Resolve param is returned only if inApp=true.
     */
    CoreSite.prototype.openWithAutoLogin = function (inApp, url, options, alertMessage) {
        var _this = this;
        // Convenience function to open the URL.
        var open = function (url) {
            return new Promise(function (resolve, reject) {
                if (modal) {
                    modal.dismiss();
                }
                if (alertMessage) {
                    var alert_1 = _this.domUtils.showAlert(_this.translate.instant('core.notice'), alertMessage, undefined, 3000);
                    alert_1.onDidDismiss(function () {
                        if (inApp) {
                            resolve(_this.utils.openInApp(url, options));
                        }
                        else {
                            resolve(_this.utils.openInBrowser(url));
                        }
                    });
                }
                else {
                    if (inApp) {
                        resolve(_this.utils.openInApp(url, options));
                    }
                    else {
                        resolve(_this.utils.openInBrowser(url));
                    }
                }
            });
        };
        if (!this.privateToken || !this.wsAvailable('tool_mobile_get_autologin_key') ||
            (this.lastAutoLogin && this.timeUtils.timestamp() - this.lastAutoLogin < __WEBPACK_IMPORTED_MODULE_13__core_constants__["a" /* CoreConstants */].SECONDS_MINUTE * 6)) {
            // No private token, WS not available or last auto-login was less than 6 minutes ago.
            // Open the final URL without auto-login.
            return Promise.resolve(open(url));
        }
        var userId = this.getUserId(), params = {
            privatetoken: this.privateToken
        }, modal = this.domUtils.showModalLoading();
        // Use write to not use cache.
        return this.write('tool_mobile_get_autologin_key', params).then(function (data) {
            if (!data.autologinurl || !data.key) {
                // Not valid data, open the final URL without auto-login.
                return open(url);
            }
            _this.lastAutoLogin = _this.timeUtils.timestamp();
            return open(data.autologinurl + '?userid=' + userId + '&key=' + data.key + '&urltogo=' + url);
        }).catch(function () {
            // Couldn't get autologin key, open the final URL without auto-login.
            return open(url);
        });
    };
    /**
     * Open a URL in browser or InAppBrowser using auto-login in the Moodle site if available and the URL belongs to the site.
     *
     * @param {boolean} inApp True to open it in InAppBrowser, false to open in browser.
     * @param {string} url The URL to open.
     * @param {object} [options] Override default options passed to inappbrowser.
     * @param {string} [alertMessage] If defined, an alert will be shown before opening the browser/inappbrowser.
     * @return {Promise<InAppBrowserObject>} Promise resolved when done. Resolve param is returned only if inApp=true.
     */
    CoreSite.prototype.openWithAutoLoginIfSameSite = function (inApp, url, options, alertMessage) {
        if (this.containsUrl(url)) {
            return this.openWithAutoLogin(inApp, url, options, alertMessage);
        }
        else {
            if (inApp) {
                this.utils.openInApp(url, options);
            }
            else {
                this.utils.openInBrowser(url);
            }
            return Promise.resolve(null);
        }
    };
    /**
     * Get the config of this site.
     * It is recommended to use getStoredConfig instead since it's faster and doesn't use network.
     *
     * @param {string} [name] Name of the setting to get. If not set or false, all settings will be returned.
     * @param {boolean} [ignoreCache] True if it should ignore cached data.
     * @return {Promise<any>} Promise resolved with site config.
     */
    CoreSite.prototype.getConfig = function (name, ignoreCache) {
        var preSets = {
            cacheKey: this.getConfigCacheKey()
        };
        if (ignoreCache) {
            preSets.getFromCache = false;
            preSets.emergencyCache = false;
        }
        return this.read('tool_mobile_get_config', {}, preSets).then(function (config) {
            if (name) {
                // Return the requested setting.
                for (var x in config.settings) {
                    if (config.settings[x].name == name) {
                        return config.settings[x].value;
                    }
                }
                return Promise.reject(null);
            }
            else {
                // Return all settings in the same array.
                var settings_1 = {};
                config.settings.forEach(function (setting) {
                    settings_1[setting.name] = setting.value;
                });
                return settings_1;
            }
        });
    };
    /**
     * Invalidates config WS call.
     *
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreSite.prototype.invalidateConfig = function () {
        return this.invalidateWsCacheForKey(this.getConfigCacheKey());
    };
    /**
     * Get cache key for getConfig WS calls.
     *
     * @return {string} Cache key.
     */
    CoreSite.prototype.getConfigCacheKey = function () {
        return 'tool_mobile_get_config';
    };
    /**
     * Get the stored config of this site.
     *
     * @param {string} [name] Name of the setting to get. If not set, all settings will be returned.
     * @return {any} Site config or a specific setting.
     */
    CoreSite.prototype.getStoredConfig = function (name) {
        if (!this.config) {
            return;
        }
        if (name) {
            return this.config[name];
        }
        else {
            return this.config;
        }
    };
    /**
     * Check if a certain feature is disabled in the site.
     *
     * @param {string} name Name of the feature to check.
     * @return {boolean} Whether it's disabled.
     */
    CoreSite.prototype.isFeatureDisabled = function (name) {
        var disabledFeatures = this.getStoredConfig('tool_mobile_disabledfeatures');
        if (!disabledFeatures) {
            return false;
        }
        var regEx = new RegExp('(,|^)' + this.textUtils.escapeForRegex(name) + '(,|$)', 'g');
        return !!disabledFeatures.match(regEx);
    };
    /**
     * Check if the site version is greater than one or several versions.
     * This function accepts a string or an array of strings. If array, the last version must be the highest.
     *
     * @param {string | string[]} versions Version or list of versions to check.
     * @return {boolean} Whether it's greater or equal, false otherwise.
     * @description
     * If a string is supplied (e.g. '3.2.1'), it will check if the site version is greater or equal than this version.
     *
     * If an array of versions is supplied, it will check if the site version is greater or equal than the last version,
     * or if it's higher or equal than any of the other releases supplied but lower than the next major release. The last
     * version of the array must be the highest version.
     * For example, if the values supplied are ['3.0.5', '3.2.3', '3.3.1'] the function will return true if the site version
     * is either:
     *     - Greater or equal than 3.3.1.
     *     - Greater or equal than 3.2.3 but lower than 3.3.
     *     - Greater or equal than 3.0.5 but lower than 3.1.
     *
     * This function only accepts versions from 2.4.0 and above. If any of the versions supplied isn't found, it will assume
     * it's the last released major version.
     */
    CoreSite.prototype.isVersionGreaterEqualThan = function (versions) {
        var siteVersion = parseInt(this.getInfo().version, 10);
        if (Array.isArray(versions)) {
            if (!versions.length) {
                return false;
            }
            for (var i = 0; i < versions.length; i++) {
                var versionNumber = this.getVersionNumber(versions[i]);
                if (i == versions.length - 1) {
                    // It's the last version, check only if site version is greater than this one.
                    return siteVersion >= versionNumber;
                }
                else {
                    // Check if site version if bigger than this number but lesser than next major.
                    if (siteVersion >= versionNumber && siteVersion < this.getNextMajorVersionNumber(versions[i])) {
                        return true;
                    }
                }
            }
        }
        else if (typeof versions == 'string') {
            // Compare with this version.
            return siteVersion >= this.getVersionNumber(versions);
        }
        return false;
    };
    /**
     * Get a version number from a release version.
     * If release version is valid but not found in the list of Moodle releases, it will use the last released major version.
     *
     * @param {string} version Release version to convert to version number.
     * @return {number} Version number, 0 if invalid.
     */
    CoreSite.prototype.getVersionNumber = function (version) {
        var data = this.getMajorAndMinor(version);
        if (!data) {
            // Invalid version.
            return 0;
        }
        if (typeof this.moodleReleases[data.major] == 'undefined') {
            // Major version not found. Use the last one.
            data.major = Object.keys(this.moodleReleases).slice(-1);
        }
        return this.moodleReleases[data.major] + data.minor;
    };
    /**
     * Given a release version, return the major and minor versions.
     *
     * @param {string} version Release version (e.g. '3.1.0').
     * @return {object} Object with major and minor. Returns false if invalid version.
     */
    CoreSite.prototype.getMajorAndMinor = function (version) {
        var match = version.match(/(\d)+(?:\.(\d)+)?(?:\.(\d)+)?/);
        if (!match || !match[1]) {
            // Invalid version.
            return false;
        }
        return {
            major: match[1] + '.' + (match[2] || '0'),
            minor: parseInt(match[3], 10) || 0
        };
    };
    /**
     * Given a release version, return the next major version number.
     *
     * @param {string} version Release version (e.g. '3.1.0').
     * @return {number} Next major version number.
     */
    CoreSite.prototype.getNextMajorVersionNumber = function (version) {
        var data = this.getMajorAndMinor(version), releases = Object.keys(this.moodleReleases);
        var position;
        if (!data) {
            // Invalid version.
            return 0;
        }
        position = releases.indexOf(data.major);
        if (position == -1 || position == releases.length - 1) {
            // Major version not found or it's the last one. Use the last one.
            return this.moodleReleases[releases[position]];
        }
        return this.moodleReleases[releases[position + 1]];
    };
    return CoreSite;
}());

//# sourceMappingURL=site.js.map

/***/ }),

/***/ 951:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFormatTextDirective; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_app__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_filepool__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_sites__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_dom__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_text__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_url__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__directives_link__ = __webpack_require__(542);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__directives_external_content__ = __webpack_require__(537);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__core_contentlinks_providers_helper__ = __webpack_require__(111);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};














/**
 * Directive to format text rendered. It renders the HTML and treats all links and media, using CoreLinkDirective
 * and CoreExternalContentDirective.
 *
 * Example usage:
 * <core-format-text [text]="myText" [component]="component" [componentId]="componentId"></core-format-text>
 *
 */
var CoreFormatTextDirective = /** @class */ (function () {
    function CoreFormatTextDirective(element, sitesProvider, domUtils, textUtils, translate, platform, utils, urlUtils, loggerProvider, filepoolProvider, appProvider, contentLinksHelper, navCtrl) {
        this.sitesProvider = sitesProvider;
        this.domUtils = domUtils;
        this.textUtils = textUtils;
        this.translate = translate;
        this.platform = platform;
        this.utils = utils;
        this.urlUtils = urlUtils;
        this.loggerProvider = loggerProvider;
        this.filepoolProvider = filepoolProvider;
        this.appProvider = appProvider;
        this.contentLinksHelper = contentLinksHelper;
        this.navCtrl = navCtrl;
        this.adaptImg = true; // Whether to adapt images to screen width.
        this.tagsToIgnore = ['AUDIO', 'VIDEO', 'BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'A'];
        this.element = element.nativeElement;
        this.element.classList.add('opacity-hide'); // Hide contents until they're treated.
        this.afterRender = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
    }
    /**
     * Detect changes on input properties.
     */
    CoreFormatTextDirective.prototype.ngOnChanges = function (changes) {
        if (changes.text) {
            this.formatAndRenderContents();
        }
    };
    /**
     * Apply CoreExternalContentDirective to a certain element.
     *
     * @param {HTMLElement} element Element to add the attributes to.
     */
    CoreFormatTextDirective.prototype.addExternalContent = function (element) {
        // Angular 2 doesn't let adding directives dynamically. Create the CoreExternalContentDirective manually.
        var extContent = new __WEBPACK_IMPORTED_MODULE_12__directives_external_content__["a" /* CoreExternalContentDirective */](element, this.loggerProvider, this.filepoolProvider, this.platform, this.sitesProvider, this.domUtils, this.urlUtils, this.appProvider);
        extContent.component = this.component;
        extContent.componentId = this.componentId;
        extContent.siteId = this.siteId;
        extContent.ngAfterViewInit();
    };
    /**
     * Add class to adapt media to a certain element.
     *
     * @param {HTMLElement} element Element to add the class to.
     */
    CoreFormatTextDirective.prototype.addMediaAdaptClass = function (element) {
        element.classList.add('core-media-adapt-width');
    };
    /**
     * Wrap an image with a container to adapt its width and, if needed, add an anchor to view it in full size.
     *
     * @param {number} elWidth Width of the directive's element.
     * @param {HTMLElement} img Image to adapt.
     */
    CoreFormatTextDirective.prototype.adaptImage = function (elWidth, img) {
        var imgWidth = this.getElementWidth(img), 
        // Element to wrap the image.
        container = document.createElement('span');
        container.classList.add('core-adapted-img-container');
        container.style.cssFloat = img.style.cssFloat; // Copy the float to correctly position the search icon.
        if (img.classList.contains('atto_image_button_right')) {
            container.classList.add('atto_image_button_right');
        }
        else if (img.classList.contains('atto_image_button_left')) {
            container.classList.add('atto_image_button_left');
        }
        this.domUtils.wrapElement(img, container);
        if (imgWidth > elWidth) {
            // The image has been adapted, add an anchor to view it in full size.
            this.addMagnifyingGlass(container, img);
        }
    };
    /**
     * Add a magnifying glass icon to view an image at full size.
     *
     * @param {HTMLElement} container The container of the image.
     * @param {HTMLElement} img The image.
     */
    CoreFormatTextDirective.prototype.addMagnifyingGlass = function (container, img) {
        var _this = this;
        var imgSrc = this.textUtils.escapeHTML(img.getAttribute('src')), label = this.textUtils.escapeHTML(this.translate.instant('core.openfullimage')), anchor = document.createElement('a');
        anchor.classList.add('core-image-viewer-icon');
        anchor.setAttribute('aria-label', label);
        // Add an ion-icon item to apply the right styles, but the ion-icon component won't be executed.
        anchor.innerHTML = '<ion-icon name="search" class="icon icon-md ion-md-search"></ion-icon>';
        anchor.addEventListener('click', function (e) {
            e.preventDefault();
            e.stopPropagation();
            _this.domUtils.viewImage(imgSrc, img.getAttribute('alt'), _this.component, _this.componentId);
        });
        container.appendChild(anchor);
    };
    /**
     * Finish the rendering, displaying the element again and calling afterRender.
     */
    CoreFormatTextDirective.prototype.finishRender = function () {
        // Show the element again.
        this.element.classList.remove('opacity-hide');
        // Emit the afterRender output.
        this.afterRender.emit();
    };
    /**
     * Format contents and render.
     */
    CoreFormatTextDirective.prototype.formatAndRenderContents = function () {
        var _this = this;
        if (!this.text) {
            this.element.innerHTML = ''; // Remove current contents.
            this.finishRender();
            return;
        }
        this.text = this.text.trim();
        this.formatContents().then(function (div) {
            // Disable media adapt to correctly calculate the height.
            _this.element.classList.add('core-disable-media-adapt');
            _this.element.innerHTML = ''; // Remove current contents.
            if (_this.maxHeight && div.innerHTML != '') {
                // Move the children to the current element to be able to calculate the height.
                // @todo: Display the element?
                _this.domUtils.moveChildren(div, _this.element);
                // Height cannot be calculated if the element is not shown while calculating.
                // Force shorten if it was previously shortened.
                // @todo: Work on calculate this height better.
                var height = _this.element.style.maxHeight ? 0 : _this.getElementHeight(_this.element);
                // If cannot calculate height, shorten always.
                if (!height || height > _this.maxHeight) {
                    var expandInFullview_1 = _this.utils.isTrueOrOne(_this.fullOnClick) || false, showMoreDiv = document.createElement('div');
                    showMoreDiv.classList.add('core-show-more');
                    showMoreDiv.innerHTML = _this.translate.instant('core.showmore');
                    _this.element.appendChild(showMoreDiv);
                    if (expandInFullview_1) {
                        _this.element.classList.add('core-expand-in-fullview');
                    }
                    _this.element.classList.add('core-text-formatted');
                    _this.element.classList.add('core-shortened');
                    _this.element.style.maxHeight = _this.maxHeight + 'px';
                    _this.element.addEventListener('click', function (e) {
                        e.preventDefault();
                        e.stopPropagation();
                        var target = e.target;
                        if (_this.tagsToIgnore.indexOf(target.tagName) === -1 || (target.tagName === 'A' &&
                            !target.getAttribute('href'))) {
                            if (!expandInFullview_1) {
                                // Change class.
                                _this.element.classList.toggle('core-shortened');
                                return;
                            }
                        }
                        // Open a new state with the contents.
                        _this.textUtils.expandText(_this.fullTitle || _this.translate.instant('core.description'), _this.text, _this.component, _this.componentId);
                    });
                }
            }
            else {
                _this.domUtils.moveChildren(div, _this.element);
            }
            _this.element.classList.remove('core-disable-media-adapt');
            _this.finishRender();
        });
    };
    /**
     * Apply formatText and set sub-directives.
     *
     * @return {Promise<HTMLElement>} Promise resolved with a div element containing the code.
     */
    CoreFormatTextDirective.prototype.formatContents = function () {
        var _this = this;
        var site;
        // Retrieve the site since it might be needed later.
        return this.sitesProvider.getSite(this.siteId).catch(function () {
            // Error getting the site. This probably means that there is no current site and no siteId was supplied.
        }).then(function (siteInstance) {
            site = siteInstance;
            // Apply format text function.
            return _this.textUtils.formatText(_this.text, _this.utils.isTrueOrOne(_this.clean), _this.utils.isTrueOrOne(_this.singleLine));
        }).then(function (formatted) {
            var div = document.createElement('div'), canTreatVimeo = site && site.isVersionGreaterEqualThan(['3.3.4', '3.4']);
            var images, anchors, audios, videos, iframes, buttons;
            div.innerHTML = formatted;
            images = Array.from(div.querySelectorAll('img'));
            anchors = Array.from(div.querySelectorAll('a'));
            audios = Array.from(div.querySelectorAll('audio'));
            videos = Array.from(div.querySelectorAll('video'));
            iframes = Array.from(div.querySelectorAll('iframe'));
            buttons = Array.from(div.querySelectorAll('.button'));
            // Walk through the content to find the links and add our directive to it.
            // Important: We need to look for links first because in 'img' we add new links without core-link.
            anchors.forEach(function (anchor) {
                // Angular 2 doesn't let adding directives dynamically. Create the CoreLinkDirective manually.
                var linkDir = new __WEBPACK_IMPORTED_MODULE_11__directives_link__["a" /* CoreLinkDirective */](anchor, _this.domUtils, _this.utils, _this.sitesProvider, _this.urlUtils, _this.contentLinksHelper, _this.navCtrl);
                linkDir.capture = true;
                linkDir.ngOnInit();
                _this.addExternalContent(anchor);
            });
            if (images && images.length > 0) {
                // If cannot calculate element's width, use a medium number to avoid false adapt image icons appearing.
                var elWidth_1 = _this.getElementWidth(_this.element) || 100;
                // Walk through the content to find images, and add our directive.
                images.forEach(function (img) {
                    _this.addMediaAdaptClass(img);
                    _this.addExternalContent(img);
                    if (_this.utils.isTrueOrOne(_this.adaptImg)) {
                        _this.adaptImage(elWidth_1, img);
                    }
                });
            }
            audios.forEach(function (audio) {
                _this.treatMedia(audio);
                if (_this.platform.is('ios')) {
                    // Set data-tap-disabled="true" to make slider work in iOS.
                    audio.setAttribute('data-tap-disabled', true);
                }
            });
            videos.forEach(function (video) {
                _this.treatVideoFilters(video);
                _this.treatMedia(video);
                // Set data-tap-disabled="true" to make controls work in Android (see MOBILE-1452).
                video.setAttribute('data-tap-disabled', true);
            });
            iframes.forEach(function (iframe) {
                _this.treatIframe(iframe, site, canTreatVimeo);
            });
            // Handle buttons with inner links.
            buttons.forEach(function (button) {
                // Check if it has a link inside.
                if (button.querySelector('a')) {
                    button.classList.add('core-button-with-inner-link');
                }
            });
            return div;
        });
    };
    /**
     * Returns the element width in pixels.
     *
     * @param {HTMLElement} element Element to get width from.
     * @return {number} The width of the element in pixels. When 0 is returned it means the element is not visible.
     */
    CoreFormatTextDirective.prototype.getElementWidth = function (element) {
        var width = this.domUtils.getElementWidth(element);
        if (!width) {
            // All elements inside are floating or inline. Change display mode to allow calculate the width.
            var parentWidth = this.domUtils.getElementWidth(element.parentNode, true, false, false, true), previousDisplay = getComputedStyle(element, null).display;
            element.style.display = 'inline-block';
            width = this.domUtils.getElementWidth(element);
            // If width is incorrectly calculated use parent width instead.
            if (parentWidth > 0 && (!width || width > parentWidth)) {
                width = parentWidth;
            }
            element.style.display = previousDisplay;
        }
        return width;
    };
    /**
     * Returns the element height in pixels.
     *
     * @param {HTMLElement} elementAng Element to get height from.
     * @return {number} The height of the element in pixels. When 0 is returned it means the element is not visible.
     */
    CoreFormatTextDirective.prototype.getElementHeight = function (element) {
        return this.domUtils.getElementHeight(element) || 0;
    };
    /**
     * Treat video filters. Currently only treating youtube video using video JS.
     *
     * @param {HTMLElement} el Video element.
     */
    CoreFormatTextDirective.prototype.treatVideoFilters = function (video) {
        // Treat Video JS Youtube video links and translate them to iframes.
        if (!video.classList.contains('video-js')) {
            return;
        }
        var data = JSON.parse(video.getAttribute('data-setup') || video.getAttribute('data-setup-lazy') || '{}'), youtubeId = data.techOrder && data.techOrder[0] && data.techOrder[0] == 'youtube' && data.sources && data.sources[0] &&
            data.sources[0].src && this.youtubeGetId(data.sources[0].src);
        if (!youtubeId) {
            return;
        }
        var iframe = document.createElement('iframe');
        iframe.id = video.id;
        iframe.src = 'https://www.youtube.com/embed/' + youtubeId;
        iframe.setAttribute('frameborder', '0');
        iframe.width = '100%';
        iframe.height = '300';
        // Replace video tag by the iframe.
        video.parentNode.replaceChild(iframe, video);
    };
    /**
     * Add media adapt class and apply CoreExternalContentDirective to the media element and its sources and tracks.
     *
     * @param {HTMLElement} element Video or audio to treat.
     */
    CoreFormatTextDirective.prototype.treatMedia = function (element) {
        var _this = this;
        this.addMediaAdaptClass(element);
        this.addExternalContent(element);
        var sources = Array.from(element.querySelectorAll('source')), tracks = Array.from(element.querySelectorAll('track'));
        sources.forEach(function (source) {
            source.setAttribute('target-src', source.getAttribute('src'));
            source.removeAttribute('src');
            _this.addExternalContent(source);
        });
        tracks.forEach(function (track) {
            _this.addExternalContent(track);
        });
    };
    /**
     * Add media adapt class and treat the iframe source.
     *
     * @param {HTMLIFrameElement} iframe Iframe to treat.
     * @param {CoreSite} site Site instance.
     * @param  {Boolean} canTreatVimeo Whether Vimeo videos can be treated in the site.
     */
    CoreFormatTextDirective.prototype.treatIframe = function (iframe, site, canTreatVimeo) {
        this.addMediaAdaptClass(iframe);
        if (iframe.src && canTreatVimeo) {
            // Check if it's a Vimeo video. If it is, use the wsplayer script instead to make restricted videos work.
            var matches = iframe.src.match(/https?:\/\/player\.vimeo\.com\/video\/([^\/]*)/);
            if (matches && matches[1]) {
                var newUrl = this.textUtils.concatenatePaths(site.getURL(), '/media/player/vimeo/wsplayer.php?video=') +
                    matches[1] + '&token=' + site.getToken();
                if (iframe.width) {
                    newUrl = newUrl + '&width=' + iframe.width;
                }
                if (iframe.height) {
                    newUrl = newUrl + '&height=' + iframe.height;
                }
                iframe.src = newUrl;
            }
        }
    };
    /**
     * Convenience function to extract YouTube Id to translate to embedded video.
     * Based on http://stackoverflow.com/questions/3452546/javascript-regex-how-to-get-youtube-video-id-from-url
     *
     * @param {string} url URL of the video.
     */
    CoreFormatTextDirective.prototype.youtubeGetId = function (url) {
        var regExp = /^.*(?:(?:youtu.be\/)|(?:v\/)|(?:\/u\/\w\/)|(?:embed\/)|(?:watch\?))\??v?=?([^#\&\?]*).*/, match = url.match(regExp);
        return (match && match[1].length == 11) ? match[1] : '';
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreFormatTextDirective.prototype, "text", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreFormatTextDirective.prototype, "siteId", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreFormatTextDirective.prototype, "component", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreFormatTextDirective.prototype, "componentId", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreFormatTextDirective.prototype, "adaptImg", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreFormatTextDirective.prototype, "clean", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreFormatTextDirective.prototype, "singleLine", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreFormatTextDirective.prototype, "maxHeight", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreFormatTextDirective.prototype, "fullOnClick", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreFormatTextDirective.prototype, "fullTitle", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreFormatTextDirective.prototype, "afterRender", void 0);
    CoreFormatTextDirective = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["s" /* Directive */])({
            selector: 'core-format-text'
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_6__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_7__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_8__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */],
            __WEBPACK_IMPORTED_MODULE_10__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_9__providers_utils_url__["a" /* CoreUrlUtilsProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_logger__["a" /* CoreLoggerProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_filepool__["a" /* CoreFilepoolProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_13__core_contentlinks_providers_helper__["a" /* CoreContentLinksHelperProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavController */]])
    ], CoreFormatTextDirective);
    return CoreFormatTextDirective;
}());

//# sourceMappingURL=format-text.js.map

/***/ }),

/***/ 952:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreKeepKeyboardDirective; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_utils_dom__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__ = __webpack_require__(9);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Directive to keep the keyboard open when clicking a certain element (usually a button).
 *
 * @description
 *
 * This directive needs to be applied to an input or textarea. The value of the directive needs to be a selector
 * to identify the element to listen for clicks (usually a button).
 *
 * When that element is clicked, the input that has this directive will keep the focus if it has it already and the keyboard
 * won't be closed.
 *
 * Example usage:
 *
 * <textarea [core-keep-keyboard]="'#mma-messages-send-message-button'"></textarea>
 * <button id="mma-messages-send-message-button">Send</button>
 *
 * Alternatively, this directive can be applied to the button. The value of the directive needs to be a selector to identify
 * the input element. In this case, you need to set [inButton]="true".
 *
 * Example usage:
 *
 * <textarea id="send-message-input"></textarea>
 * <button [core-keep-keyboard]="'#send-message-input'" [inButton]="true">Send</button>
 */
var CoreKeepKeyboardDirective = /** @class */ (function () {
    function CoreKeepKeyboardDirective(element, domUtils, utils) {
        this.domUtils = domUtils;
        this.utils = utils;
        this.lastFocusOut = 0; // Last time the input was focused out.
        this.element = element.nativeElement;
    }
    /**
     * View has been initialized.
     */
    CoreKeepKeyboardDirective.prototype.ngAfterViewInit = function () {
        var _this = this;
        // Use a setTimeout because to make sure that child components have been treated.
        setTimeout(function () {
            var inButton = _this.utils.isTrueOrOne(_this.inButton);
            var candidateEls, selectedEl;
            if (typeof _this.selector != 'string' || !_this.selector) {
                // Not a valid selector, stop.
                return;
            }
            // Get the selected element. Get the last one found.
            candidateEls = document.querySelectorAll(_this.selector);
            selectedEl = candidateEls[candidateEls.length - 1];
            if (!selectedEl) {
                // Element not found.
                return;
            }
            if (inButton) {
                // The directive is applied to the button.
                _this.button = _this.element;
                _this.input = selectedEl;
            }
            else {
                // The directive is applied to the input.
                _this.button = selectedEl;
                if (_this.element.tagName == 'ION-INPUT') {
                    // Search the inner input.
                    _this.input = _this.element.querySelector('input');
                }
                else if (_this.element.tagName == 'ION-TEXTAREA') {
                    // Search the inner textarea.
                    _this.input = _this.element.querySelector('textarea');
                }
                else {
                    _this.input = _this.element;
                }
                if (!_this.input) {
                    // Input not found, stop.
                    return;
                }
            }
            // Listen for focusout event. This is to be able to check if previous focus was on this element.
            _this.focusOutListener = _this.focusOut.bind(_this);
            _this.input.addEventListener('focusout', _this.focusOutListener);
            // Listen for clicks in the button.
            _this.clickListener = _this.buttonClicked.bind(_this);
            _this.button.addEventListener('click', _this.clickListener);
        });
    };
    /**
     * Component destroyed.
     */
    CoreKeepKeyboardDirective.prototype.ngOnDestroy = function () {
        if (this.button && this.clickListener) {
            this.button.removeEventListener('click', this.clickListener);
        }
        if (this.input && this.focusOutListener) {
            this.input.removeEventListener('focusout', this.focusOutListener);
        }
    };
    /**
     * The button we're interested in was clicked.
     */
    CoreKeepKeyboardDirective.prototype.buttonClicked = function () {
        if (document.activeElement == this.input) {
            // Directive's element is focused at the time the button is clicked. Listen for focusout to focus it again.
            this.focusAgainListener = this.focusElementAgain.bind(this);
            this.input.addEventListener('focusout', this.focusAgainListener);
        }
        else if (document.activeElement == this.button && Date.now() - this.lastFocusOut < 200) {
            // Last focused element was the directive's element, focus it again.
            setTimeout(this.focusElementAgain.bind(this), 0);
        }
    };
    /**
     * If keyboard is open, focus the input again and stop listening focusout to focus again if needed.
     */
    CoreKeepKeyboardDirective.prototype.focusElementAgain = function () {
        var _this = this;
        this.domUtils.focusElement(this.input);
        if (this.focusAgainListener) {
            // Sometimes we can receive more than 1 focus out event.
            // If we spend 1 second without receiving any, stop listening for them.
            var listener_1 = this.focusAgainListener; // Store it in a local variable, in case it changes.
            clearTimeout(this.stopFocusAgainTimeout);
            this.stopFocusAgainTimeout = setTimeout(function () {
                _this.input.removeEventListener('focusout', listener_1);
                if (listener_1 == _this.focusAgainListener) {
                    delete _this.focusAgainListener;
                }
            }, 1000);
        }
    };
    /**
     * Input was focused out, save the time it was done.
     */
    CoreKeepKeyboardDirective.prototype.focusOut = function () {
        this.lastFocusOut = Date.now();
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])('core-keep-keyboard'),
        __metadata("design:type", String)
    ], CoreKeepKeyboardDirective.prototype, "selector", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreKeepKeyboardDirective.prototype, "inButton", void 0);
    CoreKeepKeyboardDirective = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["s" /* Directive */])({
            selector: '[core-keep-keyboard]'
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_1__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], CoreKeepKeyboardDirective);
    return CoreKeepKeyboardDirective;
}());

//# sourceMappingURL=keep-keyboard.js.map

/***/ }),

/***/ 953:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreUserLinkDirective; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(7);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Directive to go to user profile on click.
 */
var CoreUserLinkDirective = /** @class */ (function () {
    function CoreUserLinkDirective(element, navCtrl) {
        this.navCtrl = navCtrl;
        // This directive can be added dynamically. In that case, the first param is the anchor HTMLElement.
        this.element = element.nativeElement || element;
    }
    /**
     * Function executed when the component is initialized.
     */
    CoreUserLinkDirective.prototype.ngOnInit = function () {
        var _this = this;
        this.element.addEventListener('click', function (event) {
            // If the event prevented default action, do nothing.
            if (!event.defaultPrevented) {
                event.preventDefault();
                event.stopPropagation();
                _this.navCtrl.push('CoreUserProfilePage', { userId: _this.userId, courseId: _this.courseId });
            }
        });
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreUserLinkDirective.prototype, "userId", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreUserLinkDirective.prototype, "courseId", void 0);
    CoreUserLinkDirective = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["s" /* Directive */])({
            selector: '[core-user-link]'
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavController */]])
    ], CoreUserLinkDirective);
    return CoreUserLinkDirective;
}());

//# sourceMappingURL=user-link.js.map

/***/ }),

/***/ 954:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreBytesToSizePipe; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_text__ = __webpack_require__(19);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Pipe to turn a number in bytes to a human readable size (e.g. 5,25 MB).
 */
var CoreBytesToSizePipe = /** @class */ (function () {
    function CoreBytesToSizePipe(logger, textUtils) {
        this.textUtils = textUtils;
        this.logger = logger.getInstance('CoreBytesToSizePipe');
    }
    /**
     * Takes a number and turns it to a human readable size.
     *
     * @param {number|string} value The bytes to convert.
     * @return {string} Readable bytes.
     */
    CoreBytesToSizePipe.prototype.transform = function (value) {
        if (typeof value == 'string') {
            // Convert the value to a number.
            var numberValue = parseInt(value, 10);
            if (isNaN(numberValue)) {
                this.logger.error('Invalid value received', value);
                return value;
            }
            value = numberValue;
        }
        return this.textUtils.bytesToSize(value);
    };
    CoreBytesToSizePipe = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["S" /* Pipe */])({
            name: 'coreBytesToSize',
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_text__["a" /* CoreTextUtilsProvider */]])
    ], CoreBytesToSizePipe);
    return CoreBytesToSizePipe;
}());

//# sourceMappingURL=bytes-to-size.js.map

/***/ }),

/***/ 955:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCreateLinksPipe; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

/**
 * Pipe to search URLs that are not inside <a> tags and add the corresponding <a> tags.
 */
var CoreCreateLinksPipe = /** @class */ (function () {
    function CoreCreateLinksPipe() {
        this.replacePattern = /(\b(https?|ftp):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])(?![^<]*>|[^<>]*<\/)/gim;
    }
    /**
     * Takes some text and adds anchor tags to all links that aren't inside anchors.
     *
     * @param {string} text Text to treat.
     * @return {string} Treated text.
     */
    CoreCreateLinksPipe.prototype.transform = function (text) {
        return text.replace(this.replacePattern, '<a href="$1">$1</a>');
    };
    CoreCreateLinksPipe = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["S" /* Pipe */])({
            name: 'coreCreateLinks',
        })
    ], CoreCreateLinksPipe);
    return CoreCreateLinksPipe;
}());

//# sourceMappingURL=create-links.js.map

/***/ }),

/***/ 956:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreDateDayOrTimePipe; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_moment__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_moment__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Filter to display a date using the day, or the time.
 *
 * This shows a short version of a date. Use this filter when you want
 * the user to visualise when the action was done relatively to today's date.
 *
 * For instance, if the action happened during this day it will display the time,
 * but when the action happened few days ago, it will display the day of the week.
 *
 * The older the date is, the more information about it will be displayed.
 *
 * This filter expects a timestamp NOT including milliseconds.
 */
var CoreDateDayOrTimePipe = /** @class */ (function () {
    function CoreDateDayOrTimePipe(logger, translate) {
        this.translate = translate;
        this.logger = logger.getInstance('CoreDateDayOrTimePipe');
    }
    /**
     * Format a timestamp.
     *
     * @param {number|string} timestamp The UNIX timestamp (without milliseconds).
     * @return {string} Formatted time.
     */
    CoreDateDayOrTimePipe.prototype.transform = function (timestamp) {
        if (typeof timestamp == 'string') {
            // Convert the value to a number.
            var numberTimestamp = parseInt(timestamp, 10);
            if (isNaN(numberTimestamp)) {
                this.logger.error('Invalid value received', timestamp);
                return timestamp;
            }
            timestamp = numberTimestamp;
        }
        return __WEBPACK_IMPORTED_MODULE_3_moment__(timestamp * 1000).calendar(null, {
            sameDay: this.translate.instant('core.dftimedate'),
            lastDay: this.translate.instant('core.dflastweekdate'),
            lastWeek: this.translate.instant('core.dflastweekdate')
        });
    };
    CoreDateDayOrTimePipe = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["S" /* Pipe */])({
            name: 'coreDateDayOrTime',
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
    ], CoreDateDayOrTimePipe);
    return CoreDateDayOrTimePipe;
}());

//# sourceMappingURL=date-day-or-time.js.map

/***/ }),

/***/ 957:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreDurationPipe; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_moment__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_moment__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Filter to turn a number of seconds to a duration. E.g. 60 -> 1 minute.
 */
var CoreDurationPipe = /** @class */ (function () {
    function CoreDurationPipe(logger) {
        this.logger = logger.getInstance('CoreBytesToSizePipe');
    }
    /**
     * Turn a number of seconds to a duration. E.g. 60 -> 1 minute.
     *
     * @param {number|string} seconds The number of seconds.
     * @return {string} Formatted duration.
     */
    CoreDurationPipe.prototype.transform = function (seconds) {
        if (typeof seconds == 'string') {
            // Convert the value to a number.
            var numberSeconds = parseInt(seconds, 10);
            if (isNaN(numberSeconds)) {
                this.logger.error('Invalid value received', seconds);
                return seconds;
            }
            seconds = numberSeconds;
        }
        return __WEBPACK_IMPORTED_MODULE_2_moment__["duration"](seconds * 1000).humanize();
    };
    CoreDurationPipe = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["S" /* Pipe */])({
            name: 'coreDuration',
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */]])
    ], CoreDurationPipe);
    return CoreDurationPipe;
}());

//# sourceMappingURL=duration.js.map

/***/ }),

/***/ 958:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFormatDatePipe; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_moment__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_moment__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Filter to format a date.
 */
var CoreFormatDatePipe = /** @class */ (function () {
    function CoreFormatDatePipe(logger, translate) {
        this.translate = translate;
        this.logger = logger.getInstance('CoreDateDayOrTimePipe');
    }
    /**
     * Format a date.
     *
     * @param {string|number} timestamp Timestamp to format (in milliseconds). If not defined, use current time.
     * @param {string} format Format to use. It should be a string code to handle i18n (e.g. core.dftimedate). If the code
     *                        doesn't have a prefix, 'core' will be used by default. E.g. 'dftimedate' -> 'core.dftimedate'.
     * @return {string} Formatted date.
     */
    CoreFormatDatePipe.prototype.transform = function (timestamp, format) {
        timestamp = timestamp || Date.now();
        if (typeof timestamp == 'string') {
            // Convert the value to a number.
            var numberTimestamp = parseInt(timestamp, 10);
            if (isNaN(numberTimestamp)) {
                this.logger.error('Invalid value received', timestamp);
                return timestamp;
            }
            timestamp = numberTimestamp;
        }
        if (format.indexOf('.') == -1) {
            format = 'core.' + format;
        }
        return __WEBPACK_IMPORTED_MODULE_3_moment__(timestamp).format(this.translate.instant(format));
    };
    CoreFormatDatePipe = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["S" /* Pipe */])({
            name: 'coreFormatDate',
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
    ], CoreFormatDatePipe);
    return CoreFormatDatePipe;
}());

//# sourceMappingURL=format-date.js.map

/***/ }),

/***/ 959:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreNoTagsPipe; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

/**
 * Pipe to remove HTML tags.
 */
var CoreNoTagsPipe = /** @class */ (function () {
    function CoreNoTagsPipe() {
    }
    /**
     * Takes a text and removes HTML tags.
     *
     * @param {string} text The text to treat.
     * @return {string} Treated text.
     */
    CoreNoTagsPipe.prototype.transform = function (text) {
        return text.replace(/(<([^>]+)>)/ig, '');
    };
    CoreNoTagsPipe = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["S" /* Pipe */])({
            name: 'coreNoTags',
        })
    ], CoreNoTagsPipe);
    return CoreNoTagsPipe;
}());

//# sourceMappingURL=no-tags.js.map

/***/ }),

/***/ 960:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSecondsToHMSPipe; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_text__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_constants__ = __webpack_require__(26);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Pipe to convert a number of seconds to Hours:Minutes:Seconds.
 *
 * This converts a number of seconds to Hours:Minutes:Seconds. If the number of seconds is negative, returns 00:00:00.
 */
var CoreSecondsToHMSPipe = /** @class */ (function () {
    function CoreSecondsToHMSPipe(logger, textUtils) {
        this.textUtils = textUtils;
        this.logger = logger.getInstance('CoreSecondsToHMSPipe');
    }
    /**
     * Convert a number of seconds to Hours:Minutes:Seconds.
     *
     * @param {number|string} seconds Number of seconds.
     * @return {string} Formatted seconds.
     */
    CoreSecondsToHMSPipe.prototype.transform = function (seconds) {
        var hours, minutes;
        if (!seconds || seconds < 0) {
            seconds = 0;
        }
        else if (typeof seconds == 'string') {
            // Convert the value to a number.
            var numberSeconds = parseInt(seconds, 10);
            if (isNaN(numberSeconds)) {
                this.logger.error('Invalid value received', seconds);
                return seconds;
            }
            seconds = numberSeconds;
        }
        // Don't allow decimals.
        seconds = Math.floor(seconds);
        hours = Math.floor(seconds / __WEBPACK_IMPORTED_MODULE_3__core_constants__["a" /* CoreConstants */].SECONDS_HOUR);
        seconds -= hours * __WEBPACK_IMPORTED_MODULE_3__core_constants__["a" /* CoreConstants */].SECONDS_HOUR;
        minutes = Math.floor(seconds / __WEBPACK_IMPORTED_MODULE_3__core_constants__["a" /* CoreConstants */].SECONDS_MINUTE);
        seconds -= minutes * __WEBPACK_IMPORTED_MODULE_3__core_constants__["a" /* CoreConstants */].SECONDS_MINUTE;
        return this.textUtils.twoDigits(hours) + ':' + this.textUtils.twoDigits(minutes) + ':' + this.textUtils.twoDigits(seconds);
    };
    CoreSecondsToHMSPipe = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["S" /* Pipe */])({
            name: 'coreSecondsToHMS',
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_text__["a" /* CoreTextUtilsProvider */]])
    ], CoreSecondsToHMSPipe);
    return CoreSecondsToHMSPipe;
}());

//# sourceMappingURL=seconds-to-hms.js.map

/***/ }),

/***/ 961:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreTimeAgoPipe; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_moment__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_moment__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Pipe to turn a UNIX timestamp to "time ago".
 */
var CoreTimeAgoPipe = /** @class */ (function () {
    function CoreTimeAgoPipe(logger) {
        this.logger = logger.getInstance('CoreTimeAgoPipe');
    }
    /**
     * Turn a UNIX timestamp to "time ago".
     *
     * @param {number|string} timestamp The UNIX timestamp (without milliseconds).
     * @return {string} Formatted time.
     */
    CoreTimeAgoPipe.prototype.transform = function (timestamp) {
        if (typeof timestamp == 'string') {
            // Convert the value to a number.
            var numberTimestamp = parseInt(timestamp, 10);
            if (isNaN(numberTimestamp)) {
                this.logger.error('Invalid value received', timestamp);
                return timestamp;
            }
            timestamp = numberTimestamp;
        }
        return __WEBPACK_IMPORTED_MODULE_2_moment__(timestamp * 1000).fromNow(true);
    };
    CoreTimeAgoPipe = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["S" /* Pipe */])({
            name: 'coreTimeAgo',
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */]])
    ], CoreTimeAgoPipe);
    return CoreTimeAgoPipe;
}());

//# sourceMappingURL=time-ago.js.map

/***/ }),

/***/ 962:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreToLocaleStringPipe; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Filter to format a timestamp to a locale string. Timestamp can be in seconds or milliseconds.
 */
var CoreToLocaleStringPipe = /** @class */ (function () {
    function CoreToLocaleStringPipe(logger) {
        this.logger = logger.getInstance('CoreToLocaleStringPipe');
    }
    /**
     * Format a timestamp to a locale string.
     *
     * @param {number|string} timestamp The timestamp (can be in seconds or milliseconds).
     * @return {string} Formatted time.
     */
    CoreToLocaleStringPipe.prototype.transform = function (timestamp) {
        if (typeof timestamp == 'string') {
            // Convert the value to a number.
            var numberTimestamp = parseInt(timestamp, 10);
            if (isNaN(numberTimestamp)) {
                this.logger.error('Invalid value received', timestamp);
                return timestamp;
            }
            timestamp = numberTimestamp;
        }
        if (timestamp < 0) {
            // Date not valid.
            return '';
        }
        if (timestamp < 100000000000) {
            // Timestamp is in seconds, convert it to milliseconds.
            timestamp = timestamp * 1000;
        }
        return new Date(timestamp).toLocaleString();
    };
    CoreToLocaleStringPipe = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["S" /* Pipe */])({
            name: 'coreToLocaleString',
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */]])
    ], CoreToLocaleStringPipe);
    return CoreToLocaleStringPipe;
}());

//# sourceMappingURL=to-locale-string.js.map

/***/ }),

/***/ 963:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreLoadingComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(10);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Component to show a loading spinner and message while data is being loaded.
 *
 * It will show a spinner with a message and hide all the content until 'dataLoaded' variable is set to true.
 * If 'message' and 'dynMessage' attributes aren't set, default message "Loading" is shown.
 * 'message' attribute accepts hardcoded strings, variables, filters, etc. E.g. message="'core.loading' | translate".
 *
 * Usage:
 * <core-loading [message]="loadingMessage" [hideUntil]="dataLoaded">
 *     <!-- CONTENT TO HIDE UNTIL LOADED -->
 * </core-loading>
 *
 * IMPORTANT: Due to how ng-content works in Angular, the content of core-loading will be executed as soon as your view
 * is loaded, even if the content hidden. So if you have the following code:
 * <core-loading [hideUntil]="dataLoaded"><my-component></my-component></core-loading>
 *
 * The component "my-component" will be initialized immediately, even if dataLoaded is false, but it will be hidden. If you want
 * your component to be initialized only if dataLoaded is true, then you should use ngIf:
 * <core-loading [hideUntil]="dataLoaded"><my-component *ngIf="dataLoaded"></my-component></core-loading>
 */
var CoreLoadingComponent = /** @class */ (function () {
    function CoreLoadingComponent(translate) {
        this.translate = translate;
    }
    /**
     * Component being initialized.
     */
    CoreLoadingComponent.prototype.ngOnInit = function () {
        if (!this.message) {
            // Default loading message.
            this.message = this.translate.instant('core.loading');
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Boolean)
    ], CoreLoadingComponent.prototype, "hideUntil", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreLoadingComponent.prototype, "message", void 0);
    CoreLoadingComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-loading',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/components/loading/loading.html"*/'<!-- @TODO: Add show hide animation -->\n<div class="core-loading-container" *ngIf="!hideUntil">\n    <span class="core-loading-spinner">\n        <ion-spinner></ion-spinner>\n        <p class="core-loading-message" *ngIf="message">{{message}}</p>\n    </span>\n</div>\n<ng-content class="core-loading-content" *ngIf="hideUntil">\n</ng-content>'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/components/loading/loading.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
    ], CoreLoadingComponent);
    return CoreLoadingComponent;
}());

//# sourceMappingURL=loading.js.map

/***/ }),

/***/ 964:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreMarkRequiredComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_text__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__ = __webpack_require__(9);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Directive to add a red asterisk for required input fields.
 *
 * @description
 * For forms with required and not required fields, it is recommended to use this directive to mark the required ones.
 *
 * This directive should be applied in the label. Example:
 *
 * <ion-label core-mark-required="{{field.required}}">{{ 'core.login.username' | translate }}</ion-label>
 */
var CoreMarkRequiredComponent = /** @class */ (function () {
    function CoreMarkRequiredComponent(element, translate, textUtils, utils) {
        this.translate = translate;
        this.textUtils = textUtils;
        this.utils = utils;
        this.coreMarkRequired = true;
        this.element = element.nativeElement;
        this.requiredLabel = this.translate.instant('core.required');
    }
    /**
     * Component being initialized.
     */
    CoreMarkRequiredComponent.prototype.ngOnInit = function () {
        this.coreMarkRequired = this.utils.isTrueOrOne(this.coreMarkRequired);
    };
    /**
     * Called after the view is initialized.
     */
    CoreMarkRequiredComponent.prototype.ngAfterViewInit = function () {
        if (this.coreMarkRequired) {
            // Add the "required" to the aria-label.
            var ariaLabel = this.element.getAttribute('aria-label') || this.textUtils.cleanTags(this.element.innerHTML, true);
            if (ariaLabel) {
                this.element.setAttribute('aria-label', ariaLabel + ' ' + this.requiredLabel);
            }
        }
        else {
            // Remove the "required" from the aria-label.
            var ariaLabel = this.element.getAttribute('aria-label');
            if (ariaLabel) {
                this.element.setAttribute('aria-label', ariaLabel.replace(' ' + this.requiredLabel, ''));
            }
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])('core-mark-required'),
        __metadata("design:type", Object)
    ], CoreMarkRequiredComponent.prototype, "coreMarkRequired", void 0);
    CoreMarkRequiredComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: '[core-mark-required]',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/components/mark-required/mark-required.html"*/'<ng-content></ng-content>\n<ion-icon *ngIf="coreMarkRequired" class="core-input-required-asterisk" name="medical" md="ios-medical" [title]="requiredLabel"></ion-icon> <!-- Use iOS icon because it\'s more narrow, so it looks better since it\'s small. -->\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/components/mark-required/mark-required.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_text__["a" /* CoreTextUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], CoreMarkRequiredComponent);
    return CoreMarkRequiredComponent;
}());

//# sourceMappingURL=mark-required.js.map

/***/ }),

/***/ 965:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreInputErrorsComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_forms__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(10);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Component to show errors if an input isn't valid.
 *
 * @description
 * The purpose of this component is to make easier and consistent the validation of forms.
 *
 * It should be applied next to the input element (ion-input, ion-select, ...). In case of ion-checkbox, it should be in another
 * item, placing it in the same item as the checkbox will cause problems.
 *
 * Please notice that the inputs need to have a FormControl to make it work. That FormControl needs to be passed to this component.
 *
 * If this component is placed in the same ion-item as a ion-label or ion-input, then it should have the attribute "item-content",
 * otherwise Ionic will remove it.
 *
 * Example usage:
 *
 * <ion-item text-wrap>
 *     <ion-label stacked core-mark-required="true">{{ 'core.login.username' | translate }}</ion-label>
 *     <ion-input type="text" name="username" formControlName="username"></ion-input>
 *     <core-input-errors item-content [control]="myForm.controls.username" [errorMessages]="usernameErrors"></core-input-errors>
 * </ion-item>
 */
var CoreInputErrorsComponent = /** @class */ (function () {
    function CoreInputErrorsComponent(translate) {
        this.translate = translate;
    }
    /**
     * Component is being initialized.
     */
    CoreInputErrorsComponent.prototype.ngOnInit = function () {
        this.initErrorMessages();
        this.errorKeys = Object.keys(this.errorMessages);
    };
    /**
     * Initialize some common errors if they aren't set.
     */
    CoreInputErrorsComponent.prototype.initErrorMessages = function () {
        this.errorMessages = this.errorMessages || {};
        this.errorMessages.required = this.errorMessages.required || this.translate.instant('core.required');
        this.errorMessages.email = this.errorMessages.email || this.translate.instant('core.login.invalidemail');
        this.errorMessages.date = this.errorMessages.date || this.translate.instant('core.login.invaliddate');
        this.errorMessages.datetime = this.errorMessages.datetime || this.translate.instant('core.login.invaliddate');
        this.errorMessages.datetimelocal = this.errorMessages.datetimelocal || this.translate.instant('core.login.invaliddate');
        this.errorMessages.time = this.errorMessages.time || this.translate.instant('core.login.invalidtime');
        this.errorMessages.url = this.errorMessages.url || this.translate.instant('core.login.invalidurl');
        // @todo: Check how to handle min/max errors once we have a test case to use. Also, review previous errors.
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])('control'),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_1__angular_forms__["b" /* FormControl */])
    ], CoreInputErrorsComponent.prototype, "formControl", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreInputErrorsComponent.prototype, "errorMessages", void 0);
    CoreInputErrorsComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-input-errors',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/components/input-errors/input-errors.html"*/'<div class="core-input-error-container" *ngIf="formControl.dirty && !formControl.valid" role="alert">\n    <ng-container *ngFor="let error of errorKeys">\n        <div *ngIf="formControl.hasError(error)" class="core-input-error">{{errorMessages[error]}}</div>\n    </ng-container>\n</div>'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/components/input-errors/input-errors.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */]])
    ], CoreInputErrorsComponent);
    return CoreInputErrorsComponent;
}());

//# sourceMappingURL=input-errors.js.map

/***/ }),

/***/ 966:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreShowPasswordComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_utils_utils__ = __webpack_require__(9);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Component to allow showing and hiding a password. The affected input MUST have a name to identify it.
 *
 * @description
 * This directive needs to surround the input with the password.
 *
 * You need to supply the name of the input.
 *
 * Example:
 *
 * <core-show-password item-content [name]="'password'">
 *     <ion-input type="password" name="password"></ion-input>
 * </core-show-password>
 */
var CoreShowPasswordComponent = /** @class */ (function () {
    function CoreShowPasswordComponent(element, utils) {
        this.utils = utils;
        this.selector = ''; // Selector to identify the input.
        this.element = element.nativeElement;
    }
    /**
     * Component being initialized.
     */
    CoreShowPasswordComponent.prototype.ngOnInit = function () {
        this.shown = this.utils.isTrueOrOne(this.initialShown);
        this.selector = 'input[name="' + this.name + '"]';
        this.setData();
    };
    /**
     * View has been initialized.
     */
    CoreShowPasswordComponent.prototype.ngAfterViewInit = function () {
        this.searchInput();
    };
    /**
     * Search the input to show/hide.
     */
    CoreShowPasswordComponent.prototype.searchInput = function () {
        // Search the input.
        this.input = this.element.querySelector(this.selector);
        if (this.input) {
            // Input found. Set the right type.
            this.input.type = this.shown ? 'text' : 'password';
            // By default, don't autocapitalize and autocorrect.
            if (!this.input.getAttribute('autocorrect')) {
                this.input.setAttribute('autocorrect', 'off');
            }
            if (!this.input.getAttribute('autocapitalize')) {
                this.input.setAttribute('autocapitalize', 'none');
            }
        }
    };
    /**
     * Set label, icon name and input type.
     */
    CoreShowPasswordComponent.prototype.setData = function () {
        this.label = this.shown ? 'core.hide' : 'core.show';
        this.iconName = this.shown ? 'eye-off' : 'eye';
        if (this.input) {
            this.input.type = this.shown ? 'text' : 'password';
        }
    };
    /**
     * Toggle show/hide password.
     */
    CoreShowPasswordComponent.prototype.toggle = function () {
        this.shown = !this.shown;
        this.setData();
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreShowPasswordComponent.prototype, "name", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreShowPasswordComponent.prototype, "initialShown", void 0);
    CoreShowPasswordComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-show-password',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/components/show-password/show-password.html"*/'<ng-content></ng-content>\n<a ion-button icon-only clear [attr.aria-label]="label | translate" (click)="toggle()" [core-keep-keyboard]="selector" [inButton]="true">\n    <ion-icon [name]="iconName"></ion-icon>\n</a>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/components/show-password/show-password.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_1__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], CoreShowPasswordComponent);
    return CoreShowPasswordComponent;
}());

//# sourceMappingURL=show-password.js.map

/***/ }),

/***/ 967:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreIframeComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_platform_browser__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_file__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_sites__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_dom__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_text__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_url__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_utils__ = __webpack_require__(9);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};










/**
 */
var CoreIframeComponent = /** @class */ (function () {
    function CoreIframeComponent(logger, fileProvider, urlUtils, textUtils, utils, domUtils, sitesProvider, platform, sanitizer) {
        this.fileProvider = fileProvider;
        this.urlUtils = urlUtils;
        this.textUtils = textUtils;
        this.utils = utils;
        this.domUtils = domUtils;
        this.sitesProvider = sitesProvider;
        this.platform = platform;
        this.sanitizer = sanitizer;
        this.tags = ['iframe', 'frame', 'object', 'embed'];
        this.IFRAME_TIMEOUT = 15000;
        this.logger = logger.getInstance('CoreIframe');
    }
    /**
     * Component being initialized.
     */
    CoreIframeComponent.prototype.ngOnInit = function () {
        var _this = this;
        var iframe = this.iframe && this.iframe.nativeElement;
        this.safeUrl = this.sanitizer.bypassSecurityTrustResourceUrl(this.src);
        this.iframeWidth = this.domUtils.formatPixelsSize(this.iframeWidth) || '100%';
        this.iframeHeight = this.domUtils.formatPixelsSize(this.iframeHeight) || '100%';
        // Show loading only with external URLs.
        this.loading = !!this.src.match(/^https?:\/\//i);
        this.treatFrame(iframe);
        if (this.loading) {
            iframe.addEventListener('load', function () {
                _this.loading = false;
            });
            iframe.addEventListener('error', function () {
                _this.loading = false;
                _this.domUtils.showErrorModal('core.errorloadingcontent', true);
            });
            setTimeout(function () {
                _this.loading = false;
            }, this.IFRAME_TIMEOUT);
        }
    };
    /**
     * Given an element, return the content window and document.
     *
     * @param {any} element Element to treat.
     * @return {{ window: Window, document: Document }} Window and Document.
     */
    CoreIframeComponent.prototype.getContentWindowAndDocument = function (element) {
        var contentWindow = element.contentWindow, contentDocument = element.contentDocument || (contentWindow && contentWindow.document);
        if (!contentWindow && contentDocument) {
            // It's probably an <object>. Try to get the window.
            contentWindow = contentDocument.defaultView;
        }
        if (!contentWindow && element.getSVGDocument) {
            // It's probably an <embed>. Try to get the window and the document.
            contentDocument = element.getSVGDocument();
            if (contentDocument && contentDocument.defaultView) {
                contentWindow = contentDocument.defaultView;
            }
            else if (element.window) {
                contentWindow = element.window;
            }
            else if (element.getWindow) {
                contentWindow = element.getWindow();
            }
        }
        return { window: contentWindow, document: contentDocument };
    };
    /**
     * Intercept window.open in a frame and its subframes, shows an error modal instead.
     * Search links (<a>) and open them in browser or InAppBrowser if needed.
     *
     * @param {any} element Element to treat.
     */
    CoreIframeComponent.prototype.treatFrame = function (element) {
        var _this = this;
        if (element) {
            var winAndDoc_1 = this.getContentWindowAndDocument(element);
            // Redefine window.open in this element and sub frames, it might have been loaded already.
            this.redefineWindowOpen(element, winAndDoc_1.window, winAndDoc_1.document);
            // Treat links.
            this.treatLinks(element, winAndDoc_1.document);
            element.addEventListener('load', function () {
                // Element loaded, redefine window.open and treat links again.
                winAndDoc_1 = _this.getContentWindowAndDocument(element);
                _this.redefineWindowOpen(element, winAndDoc_1.window, winAndDoc_1.document);
                _this.treatLinks(element, winAndDoc_1.document);
            });
        }
    };
    /**
     * Redefine the open method in the contentWindow of an element and the sub frames.
     *
     * @param {any} element Element to treat.
     * @param {Window} contentWindow The window of the element contents.
     * @param {Document} contentDocument The document of the element contents.
     */
    CoreIframeComponent.prototype.redefineWindowOpen = function (element, contentWindow, contentDocument) {
        var _this = this;
        if (contentWindow) {
            // Intercept window.open.
            contentWindow.open = function (url) {
                var scheme = _this.urlUtils.getUrlScheme(url);
                if (!scheme) {
                    // It's a relative URL, use the frame src to create the full URL.
                    var src = element.src || element.data;
                    if (src) {
                        var dirAndFile = _this.fileProvider.getFileAndDirectoryFromPath(src);
                        if (dirAndFile.directory) {
                            url = _this.textUtils.concatenatePaths(dirAndFile.directory, url);
                        }
                        else {
                            _this.logger.warn('Cannot get iframe dir path to open relative url', url, element);
                            return new Window(); // Return new Window object.
                        }
                    }
                    else {
                        _this.logger.warn('Cannot get iframe src to open relative url', url, element);
                        return new Window(); // Return new Window object.
                    }
                }
                if (url.indexOf('cdvfile://') === 0 || url.indexOf('file://') === 0) {
                    // It's a local file.
                    _this.utils.openFile(url).catch(function (error) {
                        _this.domUtils.showErrorModal(error);
                    });
                }
                else {
                    // It's an external link, we will open with browser. Check if we need to auto-login.
                    if (!_this.sitesProvider.isLoggedIn()) {
                        // Not logged in, cannot auto-login.
                        _this.utils.openInBrowser(url);
                    }
                    else {
                        _this.sitesProvider.getCurrentSite().openInBrowserWithAutoLoginIfSameSite(url);
                    }
                }
                return new Window(); // Return new Window object.
            };
        }
        if (contentDocument) {
            // Search sub frames.
            this.tags.forEach(function (tag) {
                var elements = Array.from(contentDocument.querySelectorAll(tag));
                elements.forEach(function (subElement) {
                    _this.treatFrame(subElement);
                });
            });
        }
    };
    /**
     * Search links (<a>) and open them in browser or InAppBrowser if needed.
     * Only links that haven't been treated by the iframe's Javascript will be treated.
     *
     * @param {any} element Element to treat.
     * @param {Document} contentDocument The document of the element contents.
     */
    CoreIframeComponent.prototype.treatLinks = function (element, contentDocument) {
        var _this = this;
        if (!contentDocument) {
            return;
        }
        var links = Array.from(contentDocument.querySelectorAll('a'));
        links.forEach(function (el) {
            var href = el.href;
            // Check that href is not null.
            if (href) {
                var scheme = _this.urlUtils.getUrlScheme(href);
                if (scheme && scheme == 'javascript') {
                    // Javascript links should be treated by the iframe's Javascript.
                    // There's nothing to be done with these links, so they'll be ignored.
                    return;
                }
                else if (scheme && scheme != 'file' && scheme != 'filesystem') {
                    // Scheme suggests it's an external resource, open it in browser.
                    el.addEventListener('click', function (e) {
                        // If the link's already prevented by SCORM JS then we won't open it in browser.
                        if (!e.defaultPrevented) {
                            e.preventDefault();
                            if (!_this.sitesProvider.isLoggedIn()) {
                                _this.utils.openInBrowser(href);
                            }
                            else {
                                _this.sitesProvider.getCurrentSite().openInBrowserWithAutoLoginIfSameSite(href);
                            }
                        }
                    });
                }
                else if (el.target == '_parent' || el.target == '_top' || el.target == '_blank') {
                    // Opening links with _parent, _top or _blank can break the app. We'll open it in InAppBrowser.
                    el.addEventListener('click', function (e) {
                        // If the link's already prevented by SCORM JS then we won't open it in InAppBrowser.
                        if (!e.defaultPrevented) {
                            e.preventDefault();
                            _this.utils.openFile(href).catch(function (error) {
                                _this.domUtils.showErrorModal(error);
                            });
                        }
                    });
                }
                else if (_this.platform.is('ios') && (!el.target || el.target == '_self')) {
                    // In cordova ios 4.1.0 links inside iframes stopped working. We'll manually treat them.
                    el.addEventListener('click', function (e) {
                        // If the link's already prevented by SCORM JS then we won't treat it.
                        if (!e.defaultPrevented) {
                            if (element.tagName.toLowerCase() == 'object') {
                                e.preventDefault();
                                element.attr('data', href);
                            }
                            else {
                                e.preventDefault();
                                element.attr('src', href);
                            }
                        }
                    });
                }
            }
        });
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])('iframe'),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */])
    ], CoreIframeComponent.prototype, "iframe", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreIframeComponent.prototype, "src", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreIframeComponent.prototype, "iframeWidth", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreIframeComponent.prototype, "iframeHeight", void 0);
    CoreIframeComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-iframe',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/components/iframe/iframe.html"*/'<div [class.core-loading-container]="loading">\n    <iframe #iframe [hidden]="loading" class="core-iframe" [ngStyle]="{\'width\': iframeWidth, \'height\': iframeHeight}" [src]="safeUrl"></iframe>\n    <ion-spinner *ngIf="loading"></ion-spinner>\n</div>'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/components/iframe/iframe.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_file__["a" /* CoreFileProvider */], __WEBPACK_IMPORTED_MODULE_8__providers_utils_url__["a" /* CoreUrlUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_7__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_9__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_5__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* Platform */], __WEBPACK_IMPORTED_MODULE_1__angular_platform_browser__["c" /* DomSanitizer */]])
    ], CoreIframeComponent);
    return CoreIframeComponent;
}());

//# sourceMappingURL=iframe.js.map

/***/ }),

/***/ 968:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreProgressBarComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_platform_browser__ = __webpack_require__(52);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Component to show a progress bar and its value.
 *
 * Example usage:
 * <core-progress-bar [progress]="percentage"></core-progress-bar>
 */
var CoreProgressBarComponent = /** @class */ (function () {
    function CoreProgressBarComponent(sanitizer) {
        this.sanitizer = sanitizer;
        this.textSupplied = false;
    }
    /**
     * Detect changes on input properties.
     */
    CoreProgressBarComponent.prototype.ngOnChanges = function (changes) {
        if (changes.text && typeof changes.text.currentValue != 'undefined') {
            // User provided a custom text, don't use default.
            this.textSupplied = true;
        }
        if (changes.progress) {
            // Progress has changed.
            if (typeof this.progress == 'string') {
                this.progress = parseInt(this.progress, 10);
            }
            if (this.progress < 0 || isNaN(this.progress)) {
                this.progress = -1;
            }
            if (this.progress != -1) {
                // Remove decimals.
                this.progress = Math.floor(this.progress);
                if (!this.textSupplied) {
                    this.text = String(this.progress);
                }
                this.width = this.sanitizer.bypassSecurityTrustStyle(this.progress + '%');
            }
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreProgressBarComponent.prototype, "progress", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreProgressBarComponent.prototype, "text", void 0);
    CoreProgressBarComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-progress-bar',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/components/progress-bar/progress-bar.html"*/'<div *ngIf="progress >= 0">\n    <progress max="100" [value]="progress">\n        <div class="progress-bar-fallback" role="progressbar" aria-valuemin="0" aria-valuemax="100" [attr.aria-valuenow]="progress">\n            <span [style.width]="width"></span>\n        </div>\n    </progress>\n    <span class="core-progress-text">{{ \'core.percentagenumber\' | translate: {$a: text} }}</span>\n</div>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/components/progress-bar/progress-bar.html"*/,
            changeDetection: __WEBPACK_IMPORTED_MODULE_0__angular_core__["i" /* ChangeDetectionStrategy */].OnPush
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_platform_browser__["c" /* DomSanitizer */]])
    ], CoreProgressBarComponent);
    return CoreProgressBarComponent;
}());

//# sourceMappingURL=progress-bar.js.map

/***/ }),

/***/ 969:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreEmptyBoxComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

/**
 * Component to show an empty box message. It will show an optional icon or image and a text centered on page.
 *
 * Usage:
 * <core-empty-box *ngIf="empty" icon="bell" [message]="'core.emptymessage' | translate"></core-empty-box>
 */
var CoreEmptyBoxComponent = /** @class */ (function () {
    function CoreEmptyBoxComponent() {
        // Nothing to do.
    }
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreEmptyBoxComponent.prototype, "message", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreEmptyBoxComponent.prototype, "icon", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreEmptyBoxComponent.prototype, "image", void 0);
    CoreEmptyBoxComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-empty-box',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/components/empty-box/empty-box.html"*/'<div class="core-empty-box" [class.core-empty-box-inline]="!image && !icon">\n    <div class="core-empty-box-content" padding>\n        <img *ngIf="image && !icon" [src]="image" role="presentation">\n        <ion-icon *ngIf="icon" [name]="icon"></ion-icon>\n        <p *ngIf="message" [class.padding-top]="image || icon">{{ message }}</p>\n        <ng-content></ng-content>\n    </div>\n</div>'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/components/empty-box/empty-box.html"*/
        }),
        __metadata("design:paramtypes", [])
    ], CoreEmptyBoxComponent);
    return CoreEmptyBoxComponent;
}());

//# sourceMappingURL=empty-box.js.map

/***/ }),

/***/ 970:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSearchBoxComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__ = __webpack_require__(9);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Component to display a "search box".
 *
 * @description
 * This component will display a standalone search box with its search button in order to have a better UX.
 *
 * Example usage:
 * <core-search-box (onSubmit)="search($event)" [placeholder]="'core.courses.search' | translate"
 *     [searchLabel]="'core.courses.search' | translate" autoFocus="true"></core-search-box>
 */
var CoreSearchBoxComponent = /** @class */ (function () {
    function CoreSearchBoxComponent(translate, utils) {
        this.translate = translate;
        this.utils = utils;
        this.initialValue = ''; // Initial value for search text.
        this.autocorrect = 'on'; // Enables/disable Autocorrection on search text input.
        this.spellcheck = true; // Enables/disable Spellchecker on search text input.
        this.lengthCheck = 3; // Check value length before submit. If 0, any string will be submitted.
        this.onSubmit = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
    }
    CoreSearchBoxComponent.prototype.ngOnInit = function () {
        this.searchLabel = this.searchLabel || this.translate.instant('core.search');
        this.placeholder = this.placeholder || this.translate.instant('core.search');
        this.spellcheck = this.utils.isTrueOrOne(this.spellcheck);
    };
    /**
     * Form submitted.
     *
     * @param {string} value Entered value.
     */
    CoreSearchBoxComponent.prototype.submitForm = function (value) {
        if (value.length < this.lengthCheck) {
            // The view should handle this case, but we check it here too just in case.
            return;
        }
        this.onSubmit.emit(value);
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreSearchBoxComponent.prototype, "initialValue", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreSearchBoxComponent.prototype, "searchLabel", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreSearchBoxComponent.prototype, "placeholder", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreSearchBoxComponent.prototype, "autocorrect", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreSearchBoxComponent.prototype, "spellcheck", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreSearchBoxComponent.prototype, "autoFocus", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreSearchBoxComponent.prototype, "lengthCheck", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreSearchBoxComponent.prototype, "onSubmit", void 0);
    CoreSearchBoxComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-search-box',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/components/search-box/search-box.html"*/'<ion-card>\n    <form #f="ngForm" (ngSubmit)="submitForm(f.value.search)">\n        <ion-item>\n            <ion-input type="text" name="search" ngModel [placeholder]="placeholder" [autocorrect]="autocorrect" [spellcheck]="spellcheck" [core-auto-focus]="autoFocus"></ion-input>\n            <button item-end ion-button clear icon-only type="submit" class="button-small" [attr.aria-label]="searchLabel" [disabled]="!f.value.search || (f.value.search.length < lengthCheck)">\n                <ion-icon name="search"></ion-icon>\n            </button>\n        </ion-item>\n    </form>\n</ion-card>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/components/search-box/search-box.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], CoreSearchBoxComponent);
    return CoreSearchBoxComponent;
}());

//# sourceMappingURL=search-box.js.map

/***/ }),

/***/ 971:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFileComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_events__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_file__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_filepool__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_sites__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_dom__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_mimetype__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__core_constants__ = __webpack_require__(26);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};











/**
 * Component to handle a remote file. Shows the file name, icon (depending on mimetype) and a button
 * to download/refresh it.
 */
var CoreFileComponent = /** @class */ (function () {
    function CoreFileComponent(translate, sitesProvider, utils, domUtils, filepoolProvider, fileProvider, appProvider, mimeUtils, eventsProvider) {
        this.translate = translate;
        this.sitesProvider = sitesProvider;
        this.utils = utils;
        this.domUtils = domUtils;
        this.filepoolProvider = filepoolProvider;
        this.fileProvider = fileProvider;
        this.appProvider = appProvider;
        this.mimeUtils = mimeUtils;
        this.eventsProvider = eventsProvider;
        // Use it for files that you cannot determine if they're outdated or not.
        this.canDownload = true; // Whether file can be downloaded.
        this.onDelete = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
    }
    /**
     * Component being initialized.
     */
    CoreFileComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.canDelete = this.utils.isTrueOrOne(this.canDelete);
        this.alwaysDownload = this.utils.isTrueOrOne(this.alwaysDownload);
        this.canDownload = this.utils.isTrueOrOne(this.canDownload);
        this.timemodified = this.timemodified || 0;
        this.fileUrl = this.file.fileurl || this.file.url;
        this.siteId = this.sitesProvider.getCurrentSiteId();
        this.fileSize = this.file.filesize;
        this.fileName = this.file.filename;
        if (this.file.isexternalfile) {
            this.alwaysDownload = true; // Always show the download button in external files.
        }
        this.fileIcon = this.mimeUtils.getFileIcon(this.file.filename);
        if (this.canDownload) {
            this.calculateState();
            // Update state when receiving events about this file.
            this.filepoolProvider.getFileEventNameByUrl(this.siteId, this.fileUrl).then(function (eventName) {
                _this.observer = _this.eventsProvider.on(eventName, function () {
                    _this.calculateState();
                });
            });
        }
    };
    /**
     * Convenience function to get the file state and set variables based on it.
     *
     * @return {Promise<void>} Promise resolved when state has been calculated.
     */
    CoreFileComponent.prototype.calculateState = function () {
        var _this = this;
        return this.filepoolProvider.getFileStateByUrl(this.siteId, this.fileUrl, this.timemodified).then(function (state) {
            var canDownload = _this.sitesProvider.getCurrentSite().canDownloadFiles();
            _this.isDownloaded = state === __WEBPACK_IMPORTED_MODULE_10__core_constants__["a" /* CoreConstants */].DOWNLOADED || state === __WEBPACK_IMPORTED_MODULE_10__core_constants__["a" /* CoreConstants */].OUTDATED;
            _this.isDownloading = canDownload && state === __WEBPACK_IMPORTED_MODULE_10__core_constants__["a" /* CoreConstants */].DOWNLOADING;
            _this.showDownload = canDownload && (state === __WEBPACK_IMPORTED_MODULE_10__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED || state === __WEBPACK_IMPORTED_MODULE_10__core_constants__["a" /* CoreConstants */].OUTDATED ||
                (_this.alwaysDownload && state === __WEBPACK_IMPORTED_MODULE_10__core_constants__["a" /* CoreConstants */].DOWNLOADED));
        });
    };
    /**
     * Download the file.
     *
     * @return {Promise<string>} Promise resolved when file is downloaded.
     */
    CoreFileComponent.prototype.downloadFile = function () {
        var _this = this;
        if (!this.sitesProvider.getCurrentSite().canDownloadFiles()) {
            this.domUtils.showErrorModal('core.cannotdownloadfiles', true);
            return Promise.reject(null);
        }
        this.isDownloading = true;
        return this.filepoolProvider.downloadUrl(this.siteId, this.fileUrl, false, this.component, this.componentId, this.timemodified, undefined, undefined, this.file).catch(function () {
            // Call calculateState to make sure we have the right state.
            return _this.calculateState().then(function () {
                if (_this.isDownloaded) {
                    return _this.filepoolProvider.getInternalUrlByUrl(_this.siteId, _this.fileUrl);
                }
                else {
                    return Promise.reject(null);
                }
            });
        });
    };
    /**
     * Convenience function to open a file, downloading it if needed.
     *
     * @return {Promise<string>} Promise resolved when file is opened.
     */
    CoreFileComponent.prototype.openFile = function () {
        var _this = this;
        var fixedUrl = this.sitesProvider.getCurrentSite().fixPluginfileURL(this.fileUrl);
        var promise;
        if (this.fileProvider.isAvailable()) {
            promise = Promise.resolve().then(function () {
                // The file system is available.
                var isWifi = !_this.appProvider.isNetworkAccessLimited(), isOnline = _this.appProvider.isOnline();
                if (_this.isDownloaded && !_this.showDownload) {
                    // File is downloaded, get the local file URL.
                    return _this.filepoolProvider.getUrlByUrl(_this.siteId, _this.fileUrl, _this.component, _this.componentId, _this.timemodified, false, false, _this.file);
                }
                else {
                    if (!isOnline && !_this.isDownloaded) {
                        // Not downloaded and user is offline, reject.
                        return Promise.reject(_this.translate.instant('core.networkerrormsg'));
                    }
                    var isDownloading_1 = _this.isDownloading;
                    _this.isDownloading = true; // This check could take a while, show spinner.
                    return _this.filepoolProvider.shouldDownloadBeforeOpen(fixedUrl, _this.fileSize).then(function () {
                        if (isDownloading_1) {
                            // It's already downloading, stop.
                            return;
                        }
                        // Download and then return the local URL.
                        return _this.downloadFile();
                    }, function () {
                        // Start the download if in wifi, but return the URL right away so the file is opened.
                        if (isWifi && isOnline) {
                            _this.downloadFile();
                        }
                        if (isDownloading_1 || !_this.isDownloaded || isOnline) {
                            // Not downloaded or outdated and online, return the online URL.
                            return fixedUrl;
                        }
                        else {
                            // Outdated but offline, so we return the local URL.
                            return _this.filepoolProvider.getUrlByUrl(_this.siteId, _this.fileUrl, _this.component, _this.componentId, _this.timemodified, false, false, _this.file);
                        }
                    });
                }
            });
        }
        else {
            // Use the online URL.
            promise = Promise.resolve(fixedUrl);
        }
        return promise.then(function (url) {
            if (!url) {
                return;
            }
            if (url.indexOf('http') === 0) {
                return _this.utils.openOnlineFile(url).catch(function (error) {
                    // Error opening the file, some apps don't allow opening online files.
                    if (!_this.fileProvider.isAvailable()) {
                        return Promise.reject(error);
                    }
                    else if (_this.isDownloading) {
                        return Promise.reject(_this.translate.instant('core.erroropenfiledownloading'));
                    }
                    var subPromise;
                    if (status === __WEBPACK_IMPORTED_MODULE_10__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED) {
                        // File is not downloaded, download and then return the local URL.
                        subPromise = _this.downloadFile();
                    }
                    else {
                        // File is outdated and can't be opened in online, return the local URL.
                        subPromise = _this.filepoolProvider.getInternalUrlByUrl(_this.siteId, _this.fileUrl);
                    }
                    return subPromise.then(function (url) {
                        return _this.utils.openFile(url);
                    });
                });
            }
            else {
                return _this.utils.openFile(url);
            }
        });
    };
    /**
     * Download a file and, optionally, open it afterwards.
     *
     * @param {Event} e Click event.
     * @param {boolean} openAfterDownload Whether the file should be opened after download.
     */
    CoreFileComponent.prototype.download = function (e, openAfterDownload) {
        var _this = this;
        e.preventDefault();
        e.stopPropagation();
        var promise;
        if (this.isDownloading && !openAfterDownload) {
            return;
        }
        if (!this.appProvider.isOnline() && (!openAfterDownload || (openAfterDownload && !this.isDownloaded))) {
            this.domUtils.showErrorModal('core.networkerrormsg', true);
            return;
        }
        if (openAfterDownload) {
            // File needs to be opened now.
            this.openFile().catch(function (error) {
                _this.domUtils.showErrorModalDefault(error, 'core.errordownloading', true);
            });
        }
        else {
            // File doesn't need to be opened (it's a prefetch). Show confirm modal if file size is defined and it's big.
            promise = this.fileSize ? this.domUtils.confirmDownloadSize({ size: this.fileSize, total: true }) : Promise.resolve();
            promise.then(function () {
                // User confirmed, add the file to queue.
                _this.filepoolProvider.invalidateFileByUrl(_this.siteId, _this.fileUrl).finally(function () {
                    _this.isDownloading = true;
                    _this.filepoolProvider.addToQueueByUrl(_this.siteId, _this.fileUrl, _this.component, _this.componentId, _this.timemodified, undefined, undefined, 0, _this.file).catch(function (error) {
                        _this.domUtils.showErrorModalDefault(error, 'core.errordownloading', true);
                        _this.calculateState();
                    });
                });
            });
        }
    };
    /**
     * Delete the file.
     *
     * @param {Event} e Click event.
     */
    CoreFileComponent.prototype.deleteFile = function (e) {
        e.preventDefault();
        e.stopPropagation();
        if (this.canDelete) {
            this.onDelete.emit();
        }
    };
    /**
     * Component destroyed.
     */
    CoreFileComponent.prototype.ngOnDestroy = function () {
        this.observer && this.observer.off();
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreFileComponent.prototype, "file", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreFileComponent.prototype, "component", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreFileComponent.prototype, "componentId", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreFileComponent.prototype, "timemodified", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreFileComponent.prototype, "canDelete", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreFileComponent.prototype, "alwaysDownload", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreFileComponent.prototype, "canDownload", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreFileComponent.prototype, "onDelete", void 0);
    CoreFileComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-file',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/components/file/file.html"*/'<a ion-item text-wrap class="item-media" (click)="download($event, true)" detail-none>\n    <img [src]="fileIcon" alt="" role="presentation" item-start />\n    <p>{{fileName}}</p>\n    <div class="buttons" item-end>\n        <button ion-button clear icon-only (click)="download($event)" *ngIf="!isDownloading && showDownload" [attr.aria-label]="\'core.download\' | translate" color="dark">\n            <ion-icon [name]="isDownloaded ? \'refresh\' : \'cloud-download\'"></ion-icon>\n        </button>\n        <button ion-button clear icon-only (click)="delete($event)" *ngIf="!isDownloading && canDelete" [attr.aria-label]="\'core.delete\' | translate" color="danger">\n            <ion-icon name="trash"></ion-icon>\n        </button>\n    </div>\n    <ion-spinner *ngIf="isDownloading" item-end></ion-spinner>\n</a>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/components/file/file.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_6__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_9__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_7__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_filepool__["a" /* CoreFilepoolProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_file__["a" /* CoreFileProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_8__providers_utils_mimetype__["a" /* CoreMimetypeUtilsProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_events__["a" /* CoreEventsProvider */]])
    ], CoreFileComponent);
    return CoreFileComponent;
}());

//# sourceMappingURL=file.js.map

/***/ }),

/***/ 972:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreContextMenuItemComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__context_menu__ = __webpack_require__(543);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * This directive adds a item to the Context Menu popover.
 *
 * @description
 * This directive defines and item to be added to the popover generated in CoreContextMenu.
 *
 * It is required to place this tag inside a core-context-menu tag.
 *
 * <core-context-menu>
 *     <core-context-menu-item [hidden]="showGrid" [priority]="601" [content]="'core.layoutgrid' | translate"
 *         (action)="switchGrid()" [iconAction]="'apps'"></core-context-menu-item>
 * </core-context-menu>
 */
var CoreContextMenuItemComponent = /** @class */ (function () {
    function CoreContextMenuItemComponent(ctxtMenu) {
        this.ctxtMenu = ctxtMenu;
        this.closeOnClick = true; // Whether to close the popover when the item is clicked.
        this.hasAction = false;
        this.destroyed = false;
        this.action = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
    }
    /**
     * Component being initialized.
     */
    CoreContextMenuItemComponent.prototype.ngOnInit = function () {
        // Initialize values.
        this.priority = this.priority || 1;
        this.closeOnClick = this.getBooleanValue(this.closeOnClick, true);
        this.hasAction = this.action.observers.length > 0;
        this.ariaAction = this.ariaAction || this.content;
        if (this.hasAction) {
            this.href = '';
        }
        // Navigation help if href provided.
        this.captureLink = this.href && this.captureLink ? this.captureLink : false;
        this.autoLogin = this.autoLogin || 'check';
        if (!this.destroyed) {
            this.ctxtMenu.addItem(this);
        }
    };
    /**
     * Get a boolean value from item.
     *
     * @param {any} value Value to check.
     * @param {boolean} defaultValue Value to use if undefined.
     * @return {boolean} Boolean value.
     */
    CoreContextMenuItemComponent.prototype.getBooleanValue = function (value, defaultValue) {
        if (typeof value == 'undefined') {
            return defaultValue;
        }
        return value && value !== 'false';
    };
    /**
     * Component destroyed.
     */
    CoreContextMenuItemComponent.prototype.ngOnDestroy = function () {
        this.destroyed = true;
        this.ctxtMenu.removeItem(this);
    };
    /**
     * Detect changes on input properties.
     */
    CoreContextMenuItemComponent.prototype.ngOnChanges = function (changes) {
        if (changes.hidden && !changes.hidden.firstChange) {
            this.ctxtMenu.itemsChanged();
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreContextMenuItemComponent.prototype, "content", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreContextMenuItemComponent.prototype, "iconDescription", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreContextMenuItemComponent.prototype, "iconAction", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreContextMenuItemComponent.prototype, "ariaDescription", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreContextMenuItemComponent.prototype, "ariaAction", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreContextMenuItemComponent.prototype, "href", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreContextMenuItemComponent.prototype, "captureLink", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreContextMenuItemComponent.prototype, "autoLogin", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreContextMenuItemComponent.prototype, "closeOnClick", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreContextMenuItemComponent.prototype, "priority", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreContextMenuItemComponent.prototype, "badge", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreContextMenuItemComponent.prototype, "badgeClass", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Boolean)
    ], CoreContextMenuItemComponent.prototype, "hidden", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreContextMenuItemComponent.prototype, "action", void 0);
    CoreContextMenuItemComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-context-menu-item',
            template: ''
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__context_menu__["a" /* CoreContextMenuComponent */]])
    ], CoreContextMenuItemComponent);
    return CoreContextMenuItemComponent;
}());

//# sourceMappingURL=context-menu-item.js.map

/***/ }),

/***/ 973:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreChronoComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

/**
 * This component shows a chronometer in format HH:MM:SS.
 *
 * If no startTime is provided, it will start at 00:00:00.
 * If an endTime is provided, the chrono will stop and emit an event in the onEnd output when that number of milliseconds is
 * reached. E.g. if startTime=60000 and endTime=120000, the chrono will start at 00:01:00 and end when it reaches 00:02:00.
 *
 * This component has 2 boolean inputs to control the timer: running (to start and stop it) and reset.
 *
 * Example usage:
 * <core-chrono [running]="running" [reset]="reset" [endTime]="maxTime" (onEnd)="stopCapturing()"></core-chrono>
 */
var CoreChronoComponent = /** @class */ (function () {
    function CoreChronoComponent(cdr) {
        this.cdr = cdr;
        this.startTime = 0; // Number of milliseconds to put in the chrono before starting.
        this.time = 0;
        this.onEnd = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
    }
    /**
     * Component being initialized.
     */
    CoreChronoComponent.prototype.ngOnInit = function () {
        this.time = this.startTime || 0;
    };
    /**
     * Component being initialized.
     */
    CoreChronoComponent.prototype.ngOnChanges = function (changes) {
        if (changes && changes.running) {
            if (changes.running.currentValue) {
                this.start();
            }
            else {
                this.stop();
            }
        }
        if (changes && changes.reset && changes.reset.currentValue) {
            this.resetChrono();
        }
    };
    /**
     * Reset the chrono, stopping it and setting it to startTime.
     */
    CoreChronoComponent.prototype.resetChrono = function () {
        this.stop();
        this.time = this.startTime || 0;
    };
    /**
     * Start the chrono if it isn't running.
     */
    CoreChronoComponent.prototype.start = function () {
        var _this = this;
        if (this.interval) {
            // Already setup.
            return;
        }
        var lastExecTime = Date.now();
        this.interval = setInterval(function () {
            // Increase the chrono.
            _this.time += Date.now() - lastExecTime;
            lastExecTime = Date.now();
            if (typeof _this.endTime != 'undefined' && _this.time > _this.endTime) {
                // End time reached, stop the timer and call the end function.
                _this.stop();
                _this.onEnd.emit();
            }
            // Force change detection. Angular doesn't detect these async operations.
            _this.cdr.detectChanges();
        }, 200);
    };
    /**
     * Stop the chrono, leaving the same time it has.
     */
    CoreChronoComponent.prototype.stop = function () {
        clearInterval(this.interval);
        delete this.interval;
    };
    CoreChronoComponent.prototype.ngOnDestroy = function () {
        this.stop();
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Boolean)
    ], CoreChronoComponent.prototype, "running", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreChronoComponent.prototype, "startTime", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreChronoComponent.prototype, "endTime", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Boolean)
    ], CoreChronoComponent.prototype, "reset", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreChronoComponent.prototype, "onEnd", void 0);
    CoreChronoComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-chrono',
            template: '<span>{{ time / 1000 | coreSecondsToHMS }}</span>'
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["j" /* ChangeDetectorRef */]])
    ], CoreChronoComponent);
    return CoreChronoComponent;
}());

//# sourceMappingURL=chrono.js.map

/***/ }),

/***/ 974:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreLocalFileComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_file__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_mimetype__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_text__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_moment__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_moment__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








/**
 * Component to handle a local file. Only files inside the app folder can be managed.
 *
 * Shows the file name, icon (depending on extension), size and time modified.
 * Also, if managing is enabled it will also show buttons to rename and delete the file.
 */
var CoreLocalFileComponent = /** @class */ (function () {
    function CoreLocalFileComponent(mimeUtils, utils, translate, textUtils, fileProvider, domUtils) {
        this.mimeUtils = mimeUtils;
        this.utils = utils;
        this.translate = translate;
        this.textUtils = textUtils;
        this.fileProvider = fileProvider;
        this.domUtils = domUtils;
        this.newFileName = '';
        this.onDelete = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
        this.onRename = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
        this.onClick = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
    }
    /**
     * Component being initialized.
     */
    CoreLocalFileComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.manage = this.utils.isTrueOrOne(this.manage);
        // Let's calculate the relative path for the file.
        this.relativePath = this.fileProvider.removeBasePath(this.file.toURL());
        if (!this.relativePath) {
            // Didn't find basePath, use fullPath but if the user tries to manage the file it'll probably fail.
            this.relativePath = this.file.fullPath;
        }
        this.loadFileBasicData();
        // Get the size and timemodified.
        this.fileProvider.getMetadata(this.file).then(function (metadata) {
            if (metadata.size >= 0) {
                _this.size = _this.textUtils.bytesToSize(metadata.size, 2);
            }
            _this.timemodified = __WEBPACK_IMPORTED_MODULE_7_moment__(metadata.modificationTime).format('LLL');
        });
    };
    /**
     * Load the basic data for the file.
     */
    CoreLocalFileComponent.prototype.loadFileBasicData = function () {
        this.fileName = this.file.name;
        this.fileIcon = this.mimeUtils.getFileIcon(this.file.name);
        this.fileExtension = this.mimeUtils.getFileExtension(this.file.name);
    };
    /**
     * File clicked.
     *
     * @param {Event} e Click event.
     */
    CoreLocalFileComponent.prototype.fileClicked = function (e) {
        e.preventDefault();
        e.stopPropagation();
        if (this.utils.isTrueOrOne(this.overrideClick) && this.onClick.observers.length) {
            this.onClick.emit();
        }
        else {
            this.utils.openFile(this.file.toURL());
        }
    };
    /**
     * Activate the edit mode.
     *
     * @param {Event} e Click event.
     */
    CoreLocalFileComponent.prototype.activateEdit = function (e) {
        e.preventDefault();
        e.stopPropagation();
        this.editMode = true;
        this.newFileName = this.file.name;
        // @todo For some reason core-auto-focus isn't working right. Focus the input manually.
        // $timeout(function() {
        //     $mmUtil.focusElement(element[0].querySelector('input'));
        // });
    };
    /**
     * Rename the file.
     *
     * @param {string} newName New name.
     */
    CoreLocalFileComponent.prototype.changeName = function (newName) {
        var _this = this;
        if (newName == this.file.name) {
            // Name hasn't changed, stop.
            this.editMode = false;
            return;
        }
        var modal = this.domUtils.showModalLoading(), fileAndDir = this.fileProvider.getFileAndDirectoryFromPath(this.relativePath), newPath = this.textUtils.concatenatePaths(fileAndDir.directory, newName);
        // Check if there's a file with this name.
        this.fileProvider.getFile(newPath).then(function () {
            // There's a file with this name, show error and stop.
            _this.domUtils.showErrorModal('core.errorfileexistssamename', true);
        }).catch(function () {
            // File doesn't exist, move it.
            return _this.fileProvider.moveFile(_this.relativePath, newPath).then(function (fileEntry) {
                _this.editMode = false;
                _this.file = fileEntry;
                _this.loadFileBasicData();
                _this.onRename.emit({ file: _this.file });
            }).catch(function () {
                _this.domUtils.showErrorModal('core.errorrenamefile', true);
            });
        }).finally(function () {
            modal.dismiss();
        });
    };
    /**
     * Delete the file.
     *
     * @param {Event} e Click event.
     */
    CoreLocalFileComponent.prototype.deleteFile = function (e) {
        var _this = this;
        e.preventDefault();
        e.stopPropagation();
        // Ask confirmation.
        this.domUtils.showConfirm(this.translate.instant('core.confirmdeletefile')).then(function () {
            var modal = _this.domUtils.showModalLoading();
            _this.fileProvider.removeFile(_this.relativePath).then(function () {
                _this.onDelete.emit();
            }).catch(function () {
                _this.domUtils.showErrorModal('core.errordeletefile', true);
            }).finally(function () {
                modal.dismiss();
            });
        }).catch(function () {
            // User cancelled.
        });
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreLocalFileComponent.prototype, "file", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreLocalFileComponent.prototype, "manage", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreLocalFileComponent.prototype, "overrideClick", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreLocalFileComponent.prototype, "onDelete", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreLocalFileComponent.prototype, "onRename", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreLocalFileComponent.prototype, "onClick", void 0);
    CoreLocalFileComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-local-file',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/components/local-file/local-file.html"*/'<a ion-item text-wrap class="item-media" (click)="fileClicked($event)" detail-none>\n    <img [src]="fileIcon" alt="{{fileExtension}}" role="presentation" item-start />\n\n    <!-- File name and edit button (if editable). -->\n    <p *ngIf="!editMode" class="core-text-with-icon-right">\n        {{fileName}}\n        <a ion-button icon-only clear *ngIf="manage" (click)="activateEdit($event)" [attr.aria-label]="\'core.edit\' | translate">\n            <ion-icon name="create" ios="md-create"></ion-icon>\n        </a>\n    </p>\n\n    <!-- Form to edit the file\'s name. -->\n    <form *ngIf="editMode" (ngSubmit)="changeName(newFileName)">\n        <ion-input type="text" name="filename" [(ngModel)]="newFileName" [placeholder]="\'core.filename\' | translate" autocapitalize="none" autocorrect="off" (click)="$event.stopPropagation()" [core-auto-focus]></ion-input>\n        <button type="submit" ion-button icon-only clear class="core-button-icon-small" [attr.aria-label]="\'core.save\' | translate">\n            <ion-icon name="checkmark"></ion-icon>\n        </button>\n    </form>\n\n    <!-- More data about the file. -->\n    <p *ngIf="size">{{ size }}</p>\n    <p *ngIf="timemodified">{{ timemodified }}</p>\n\n    <div class="buttons" item-end *ngIf="manage">\n        <button ion-button clear icon-only (click)="deleteFile($event)" [attr.aria-label]="\'core.delete\' | translate" color="danger">\n            <ion-icon name="trash"></ion-icon>\n        </button>\n    </div>\n</a>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/components/local-file/local-file.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_utils_mimetype__["a" /* CoreMimetypeUtilsProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_5__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_file__["a" /* CoreFileProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__["a" /* CoreDomUtilsProvider */]])
    ], CoreLocalFileComponent);
    return CoreLocalFileComponent;
}());

//# sourceMappingURL=local-file.js.map

/***/ }),

/***/ 975:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSitePickerComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_text__ = __webpack_require__(19);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Component to display a site selector. It will display a select with the list of sites. If the selected site changes,
 * an output will be emitted with the site ID.
 *
 * Example usage:
 * <core-site-picker (siteSelected)="changeSite($event)"></core-site-picker>
 */
var CoreSitePickerComponent = /** @class */ (function () {
    function CoreSitePickerComponent(translate, sitesProvider, textUtils) {
        this.translate = translate;
        this.sitesProvider = sitesProvider;
        this.textUtils = textUtils;
        this.siteSelected = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
    }
    CoreSitePickerComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.selectedSite = this.initialSite || this.sitesProvider.getCurrentSiteId();
        // Load the sites.
        this.sitesProvider.getSites().then(function (sites) {
            var promises = [];
            sites.forEach(function (site) {
                // Format the site name.
                promises.push(_this.textUtils.formatText(site.siteName, true, true).catch(function () {
                    return site.siteName;
                }).then(function (formatted) {
                    site.fullNameAndSiteName = _this.translate.instant('core.fullnameandsitename', { fullname: site.fullName, sitename: formatted });
                }));
            });
            return Promise.all(promises).then(function () {
                _this.sites = sites;
            });
        });
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreSitePickerComponent.prototype, "initialSite", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreSitePickerComponent.prototype, "siteSelected", void 0);
    CoreSitePickerComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-site-picker',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/components/site-picker/site-picker.html"*/'<ion-item>\n    <ion-label>{{ \'core.site\' | translate }}</ion-label>\n    <ion-select [(ngModel)]="selectedSite" (ngModelChange)="siteSelected.emit(selectedSite)" interface="popover">\n        <ion-option *ngFor="let site of sites" [value]="site.id">{{ site.fullNameAndSiteName }}</ion-option>\n    </ion-select>\n</ion-item>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/components/site-picker/site-picker.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_utils_text__["a" /* CoreTextUtilsProvider */]])
    ], CoreSitePickerComponent);
    return CoreSitePickerComponent;
}());

//# sourceMappingURL=site-picker.js.map

/***/ }),

/***/ 976:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreTabComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__tabs__ = __webpack_require__(545);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(7);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * A tab to use inside core-tabs. The content of this tab will be displayed when the tab is selected.
 *
 * You must provide either a title or an icon for the tab.
 *
 * The tab content MUST be surrounded by ng-template. This component uses ngTemplateOutlet instead of ng-content because the
 * latter executes all the code immediately. This means that all the tabs would be initialized as soon as your view is
 * loaded, leading to performance issues.
 *
 * Example usage:
 *
 * <core-tabs selectedIndex="1">
 *     <core-tab [title]="'core.courses.timeline' | translate" (ionSelect)="switchTab('timeline')">
 *         <ng-template> <!-- This ng-template is required. -->
 *             <!-- Tab contents. -->
 *         </ng-template>
 *     </core-tab>
 * </core-tabs>
 */
var CoreTabComponent = /** @class */ (function () {
    function CoreTabComponent(tabs, element) {
        this.tabs = tabs;
        this.enabled = true; // Whether the tab is enabled.
        this.show = true; // Whether the tab should be shown.
        this.ionSelect = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
        this.loaded = false;
        this.element = element.nativeElement;
    }
    /**
     * Component being initialized.
     */
    CoreTabComponent.prototype.ngOnInit = function () {
        this.tabs.addTab(this);
    };
    /**
     * Component destroyed.
     */
    CoreTabComponent.prototype.ngOnDestroy = function () {
        this.tabs.removeTab(this);
    };
    /**
     * Select tab.
     */
    CoreTabComponent.prototype.selectTab = function () {
        var _this = this;
        this.element.classList.add('selected');
        this.loaded = true;
        this.ionSelect.emit(this);
        // Setup tab scrolling.
        setTimeout(function () {
            if (_this.scroll) {
                _this.scroll.getScrollElement().onscroll = function (e) {
                    _this.tabs.showHideTabs(e);
                };
            }
        }, 1);
    };
    /**
     * Unselect tab.
     */
    CoreTabComponent.prototype.unselectTab = function () {
        this.element.classList.remove('selected');
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreTabComponent.prototype, "title", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreTabComponent.prototype, "icon", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreTabComponent.prototype, "badge", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreTabComponent.prototype, "badgeStyle", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreTabComponent.prototype, "enabled", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreTabComponent.prototype, "show", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreTabComponent.prototype, "id", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreTabComponent.prototype, "ionSelect", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["q" /* ContentChild */])(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_6" /* TemplateRef */]),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["_6" /* TemplateRef */])
    ], CoreTabComponent.prototype, "template", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["q" /* ContentChild */])(__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["e" /* Content */]),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["e" /* Content */])
    ], CoreTabComponent.prototype, "scroll", void 0);
    CoreTabComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-tab',
            template: '<ng-container *ngIf="loaded" [ngTemplateOutlet]="template"></ng-container>'
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__tabs__["a" /* CoreTabsComponent */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */]])
    ], CoreTabComponent);
    return CoreTabComponent;
}());

//# sourceMappingURL=tab.js.map

/***/ }),

/***/ 977:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreRichTextEditorComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_dom__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__angular_forms__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ionic_native_keyboard__ = __webpack_require__(200);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Directive to display a rich text editor if enabled.
 *
 * If enabled, this directive will show a rich text editor. Otherwise it'll show a regular textarea.
 *
 * This directive requires an OBJECT model. The text written in the editor or textarea will be stored inside
 * a "text" property in that object. This is to ensure 2-way data-binding, since using a string as a model
 * could be easily broken.
 *
 * Example:
 * <core-rich-text-editor item-content [control]="control" [placeholder]="field.name"></core-rich-text-editor>
 *
 * In the example above, the text written in the editor will be stored in newpost.text.
 */
var CoreRichTextEditorComponent = /** @class */ (function () {
    function CoreRichTextEditorComponent(domUtils, keyboard) {
        this.domUtils = domUtils;
        this.keyboard = keyboard;
        // Based on: https://github.com/judgewest2000/Ionic3RichText/
        // @todo: Resize, images, anchor button, fullscreen...
        this.placeholder = ''; // Placeholder to set in textarea.
        this.rteEnabled = false;
        this.uniqueId = "rte{Math.floor(Math.random() * 1000000)}";
        this.contentChanged = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
    }
    /**
     * Init editor
     */
    CoreRichTextEditorComponent.prototype.ngAfterContentInit = function () {
        var _this = this;
        this.domUtils.isRichTextEditorEnabled().then(function (enabled) {
            _this.rteEnabled = !!enabled;
        });
        // Setup the editor.
        this.editorElement = this.editor.nativeElement;
        this.editorElement.innerHTML = this.control.value;
        this.textarea.value = this.control.value;
        this.control.setValue(this.control.value);
        this.editorElement.onchange = this.onChange.bind(this);
        this.editorElement.onkeyup = this.onChange.bind(this);
        this.editorElement.onpaste = this.onChange.bind(this);
        this.editorElement.oninput = this.onChange.bind(this);
        // Setup button actions.
        var buttons = this.decorate.nativeElement.getElementsByTagName('button');
        var _loop_1 = function (i) {
            var button = buttons[i];
            var command = button.getAttribute('data-command');
            if (command) {
                if (command.includes('|')) {
                    var parameter_1 = command.split('|')[1];
                    command = command.split('|')[0];
                    button.addEventListener('click', function ($event) {
                        _this.buttonAction($event, command, parameter_1);
                    });
                }
                else {
                    button.addEventListener('click', function ($event) {
                        _this.buttonAction($event, command);
                    });
                }
            }
        };
        for (var i = 0; i < buttons.length; i++) {
            _loop_1(i);
        }
    };
    /**
     * On change function to sync with form data.
     *
     * @param {Event} $event The event.
     */
    CoreRichTextEditorComponent.prototype.onChange = function ($event) {
        if (this.rteEnabled) {
            if (this.isNullOrWhiteSpace(this.editorElement.innerText)) {
                this.clearText();
            }
            else {
                this.control.setValue(this.editorElement.innerHTML);
            }
        }
        else {
            if (this.isNullOrWhiteSpace(this.textarea.value)) {
                this.clearText();
            }
            else {
                this.control.setValue(this.textarea.value);
            }
        }
        this.contentChanged.emit(this.control.value);
    };
    /**
     * Toggle from rte editor to textarea syncing values.
     *
     * @param {Event} $event The event.
     */
    CoreRichTextEditorComponent.prototype.toggleEditor = function ($event) {
        var _this = this;
        $event.preventDefault();
        $event.stopPropagation();
        if (this.isNullOrWhiteSpace(this.control.value)) {
            this.clearText();
        }
        else {
            this.editorElement.innerHTML = this.control.value;
            this.textarea.value = this.control.value;
        }
        this.rteEnabled = !this.rteEnabled;
        // Set focus and cursor at the end.
        setTimeout(function () {
            if (_this.rteEnabled) {
                _this.editorElement.focus();
                var range = document.createRange();
                range.selectNodeContents(_this.editorElement);
                range.collapse(false);
                var sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(range);
            }
            else {
                _this.textarea.setFocus();
            }
            setTimeout(function () {
                _this.keyboard.show();
            }, 1);
        }, 1);
    };
    /**
     * Check if text is empty.
     * @param {string} value text
     */
    CoreRichTextEditorComponent.prototype.isNullOrWhiteSpace = function (value) {
        if (value == null || typeof value == 'undefined') {
            return true;
        }
        value = value.replace(/[\n\r]/g, '');
        value = value.split(' ').join('');
        return value.length === 0;
    };
    /**
     * Clear the text.
     */
    CoreRichTextEditorComponent.prototype.clearText = function () {
        this.editorElement.innerHTML = '<p></p>';
        this.textarea.value = '';
        this.control.setValue(null);
    };
    /**
     * Execute an action over the selected text.
     *  API docs: https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand
     *
     * @param {any} $event       Event data
     * @param {string} command   Command to execute.
     * @param {any} [parameters] Parameters of the command.
     */
    CoreRichTextEditorComponent.prototype.buttonAction = function ($event, command, parameters) {
        if (parameters === void 0) { parameters = null; }
        $event.preventDefault();
        $event.stopPropagation();
        document.execCommand(command, false, parameters);
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreRichTextEditorComponent.prototype, "placeholder", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_3__angular_forms__["b" /* FormControl */])
    ], CoreRichTextEditorComponent.prototype, "control", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreRichTextEditorComponent.prototype, "contentChanged", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])('editor'),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */])
    ], CoreRichTextEditorComponent.prototype, "editor", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])('textarea'),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["q" /* TextInput */])
    ], CoreRichTextEditorComponent.prototype, "textarea", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])('decorate'),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */])
    ], CoreRichTextEditorComponent.prototype, "decorate", void 0);
    CoreRichTextEditorComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-rich-text-editor',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/components/rich-text-editor/rich-text-editor.html"*/'<div [hidden]="!rteEnabled">\n    <div #editor contenteditable="true" class="core-rte-editor" tappable [attr.data-placeholder-text]="placeholder">\n    </div>\n\n    <!-- https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand -->\n    <div #decorate class="formatOptions">\n        <button data-command="bold"><strong>B</strong></button>\n        <button data-command="italic"><i>I</i></button>\n        <button data-command="underline"><u>U</u></button>\n        <button data-command="formatBlock|<p>">Normal</button>\n        <button data-command="formatBlock|<h1>">H1</button>\n        <button data-command="formatBlock|<h2>">H2</button>\n        <button data-command="formatBlock|<h3>">H3</button>\n        <button data-command="formatBlock|<pre>">Pre</button>\n        <button data-command="insertOrderedList">OL</button>\n        <button data-command="insertUnorderedList">UL</button>\n        <button data-command="removeFormat">Tx</button>\n        <button (click)="toggleEditor($event)">Toggle Editor</button>\n    </div>\n</div>\n\n<div [hidden]="rteEnabled">\n    <ion-textarea #textarea class="core-textarea" [placeholder]="placeholder" ngControl="control" (ionChange)="onChange($event)"></ion-textarea>\n    <div class="formatOptions">\n        <button tappable (click)="toggleEditor($event)">Toggle Editor</button>\n    </div>\n</div>\n\n\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/components/rich-text-editor/rich-text-editor.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_4__ionic_native_keyboard__["a" /* Keyboard */]])
    ], CoreRichTextEditorComponent);
    return CoreRichTextEditorComponent;
}());

//# sourceMappingURL=rich-text-editor.js.map

/***/ }),

/***/ 978:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreNavBarButtonsComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_dom__ = __webpack_require__(18);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Component to add buttons to the app's header without having to place them inside the header itself. This is meant for
 * pages that are loaded inside a sub ion-nav, so they don't have a header.
 *
 * If this component indicates a position (start/end), the buttons will only be added if the header has some buttons in that
 * position. If no start/end is specified, then the buttons will be added to the first <ion-buttons> found in the header.
 *
 * You can use the [hidden] input to hide all the inner buttons if a certain condition is met.
 *
 * Example usage:
 *
 * <core-navbar-buttons end>
 *     <button ion-button icon-only *ngIf="buttonShown" [attr.aria-label]="Do something" (click)="action()">
 *         <ion-icon name="funnel"></ion-icon>
 *     </button>
 * </core-navbar-buttons>
 */
var CoreNavBarButtonsComponent = /** @class */ (function () {
    function CoreNavBarButtonsComponent(element, domUtils) {
        this.domUtils = domUtils;
        this.BUTTON_HIDDEN_CLASS = 'core-navbar-button-hidden';
        this.element = element.nativeElement;
    }
    Object.defineProperty(CoreNavBarButtonsComponent.prototype, "hidden", {
        // If the hidden input is true, hide all buttons.
        set: function (value) {
            var _this = this;
            this._hidden = value;
            if (this._buttons) {
                this._buttons.forEach(function (button) {
                    _this.showHideButton(button);
                });
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CoreNavBarButtonsComponent.prototype, "buttons", {
        // Get all the buttons inside this directive.
        set: function (buttons) {
            var _this = this;
            this._buttons = buttons;
            buttons.forEach(function (button) {
                button.setRole('bar-button');
                _this.showHideButton(button);
            });
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Component being initialized.
     */
    CoreNavBarButtonsComponent.prototype.ngOnInit = function () {
        var header = this.searchHeader();
        if (header) {
            // Search the right buttons container (start, end or any).
            var selector = 'ion-buttons', buttonsContainer = void 0;
            if (this.element.hasAttribute('start')) {
                selector += '[start]';
            }
            else if (this.element.hasAttribute('end')) {
                selector += '[end]';
            }
            buttonsContainer = header.querySelector(selector);
            if (buttonsContainer) {
                this.domUtils.moveChildren(this.element, buttonsContainer);
            }
        }
    };
    /**
     * Search the ion-header where the buttons should be added.
     *
     * @return {HTMLElement} Header element.
     */
    CoreNavBarButtonsComponent.prototype.searchHeader = function () {
        var parentPage = this.element;
        while (parentPage) {
            if (!parentPage.parentElement) {
                // No parent, stop.
                break;
            }
            // Get the next parent page.
            parentPage = this.domUtils.closest(parentPage.parentElement, '.ion-page');
            if (parentPage) {
                // Check if the page has a header. If it doesn't, search the next parent page.
                var header = this.searchHeaderInPage(parentPage);
                if (header) {
                    return header;
                }
            }
        }
    };
    /**
     * Search ion-header inside a page. The header should be a direct child.
     *
     * @param  {HTMLElement} page Page to search in.
     * @return {HTMLElement} Header element. Undefined if not found.
     */
    CoreNavBarButtonsComponent.prototype.searchHeaderInPage = function (page) {
        for (var i = 0; i < page.children.length; i++) {
            var child = page.children[i];
            if (child.tagName == 'ION-HEADER') {
                return child;
            }
        }
    };
    /**
     * Show or hide a button.
     *
     * @param {Button} button Button to show or hide.
     */
    CoreNavBarButtonsComponent.prototype.showHideButton = function (button) {
        if (this._hidden) {
            button.getNativeElement().classList.add(this.BUTTON_HIDDEN_CLASS);
        }
        else {
            button.getNativeElement().classList.remove(this.BUTTON_HIDDEN_CLASS);
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])('hidden'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], CoreNavBarButtonsComponent.prototype, "hidden", null);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["r" /* ContentChildren */])(__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["d" /* Button */]),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["T" /* QueryList */]),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["T" /* QueryList */]])
    ], CoreNavBarButtonsComponent.prototype, "buttons", null);
    CoreNavBarButtonsComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-navbar-buttons',
            template: '<ng-content></ng-content>'
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_dom__["a" /* CoreDomUtilsProvider */]])
    ], CoreNavBarButtonsComponent);
    return CoreNavBarButtonsComponent;
}());

//# sourceMappingURL=navbar-buttons.js.map

/***/ }),

/***/ 979:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreDynamicComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Component to create another component dynamically.
 *
 * You need to pass the class of the component to this component (the class, not the name), along with the input data.
 *
 * So you should do something like:
 *
 *     import { MyComponent } from './component';
 *
 *     ...
 *
 *         this.component = MyComponent;
 *
 * And in the template:
 *
 *     <core-dynamic-component [component]="component" [data]="data">
 *         <p>Cannot render the data.</p>
 *     </core-dynamic-component>
 *
 * Please notice that the component that you pass needs to be declared in entryComponents of the module to be created dynamically.
 *
 * The contents of this component will be displayed if no component is supplied or it cannot be created. In the example above,
 * if no component is supplied then the template will show the message "Cannot render the data.".
 */
var CoreDynamicComponent = /** @class */ (function () {
    function CoreDynamicComponent(logger, factoryResolver, differs) {
        this.factoryResolver = factoryResolver;
        this.logger = logger.getInstance('CoreDynamicComponent');
        this.differ = differs.find([]).create();
    }
    Object.defineProperty(CoreDynamicComponent.prototype, "dynamicComponent", {
        // Get the container where to put the dynamic component.
        set: function (el) {
            this.container = el;
            this.createComponent();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Component being initialized.
     */
    CoreDynamicComponent.prototype.ngOnInit = function () {
        this.createComponent();
    };
    /**
     * Detect changes on input properties.
     */
    CoreDynamicComponent.prototype.ngOnChanges = function (changes) {
        if (!this.instance && changes.component) {
            this.createComponent();
        }
    };
    /**
     * Detect and act upon changes that Angular cant or wont detect on its own (objects and arrays).
     */
    CoreDynamicComponent.prototype.ngDoCheck = function () {
        if (this.instance) {
            // Check if there's any change in the data object.
            var changes = this.differ.diff(this.data);
            if (changes) {
                this.setInputData();
                if (this.instance.ngOnChanges) {
                    this.instance.ngOnChanges(this.createChangesForComponent(changes));
                }
            }
        }
    };
    /**
     * Create a component, add it to a container and set the input data.
     *
     * @return {boolean} Whether the component was successfully created.
     */
    CoreDynamicComponent.prototype.createComponent = function () {
        if (!this.component || !this.container) {
            // No component to instantiate or container doesn't exist right now.
            return false;
        }
        if (this.instance) {
            // Component already instantiated.
            return true;
        }
        try {
            // Create the component and add it to the container.
            var factory = this.factoryResolver.resolveComponentFactory(this.component), componentRef = this.container.createComponent(factory);
            this.instance = componentRef.instance;
            this.setInputData();
            return true;
        }
        catch (ex) {
            this.logger.error('Error creating component', ex);
            return false;
        }
    };
    /**
     * Set the input data for the component.
     */
    CoreDynamicComponent.prototype.setInputData = function () {
        for (var name_1 in this.data) {
            this.instance[name_1] = this.data[name_1];
        }
    };
    /**
     * Given the changes on the data input, create the changes object for the component.
     *
     * @param {any} changes Changes in the data input (detected by KeyValueDiffer).
     * @return {{[name: string]: SimpleChange}} List of changes for the component.
     */
    CoreDynamicComponent.prototype.createChangesForComponent = function (changes) {
        var newChanges = {};
        // Added items are considered first change.
        changes.forEachAddedItem(function (item) {
            newChanges[item.key] = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["_2" /* SimpleChange */](item.previousValue, item.currentValue, true);
        });
        // Changed or removed items aren't first change.
        changes.forEachChangedItem(function (item) {
            newChanges[item.key] = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["_2" /* SimpleChange */](item.previousValue, item.currentValue, false);
        });
        changes.forEachRemovedItem(function (item) {
            newChanges[item.key] = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["_2" /* SimpleChange */](item.previousValue, item.currentValue, true);
        });
        return newChanges;
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreDynamicComponent.prototype, "component", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreDynamicComponent.prototype, "data", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])('dynamicComponent', { read: __WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewContainerRef */] }),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewContainerRef */]),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewContainerRef */]])
    ], CoreDynamicComponent.prototype, "dynamicComponent", null);
    CoreDynamicComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-dynamic-component',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/components/dynamic-component/dynamic-component.html"*/'<!-- Content to display if no dynamic component. -->\n<ng-content *ngIf="!instance"></ng-content>\n\n<!-- Container of the dynamic component -->\n<ng-container #dynamicComponent></ng-container>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/components/dynamic-component/dynamic-component.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["o" /* ComponentFactoryResolver */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["F" /* KeyValueDiffers */]])
    ], CoreDynamicComponent);
    return CoreDynamicComponent;
}());

//# sourceMappingURL=dynamic-component.js.map

/***/ }),

/***/ 980:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCache; });
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * A cache to store values in memory to speed up processes.
 *
 * The data is organized by "entries" that are identified by an ID. Each entry can have multiple values stored,
 * and each value has its own timemodified.
 *
 * Values expire after a certain time.
 */
var CoreCache = /** @class */ (function () {
    function CoreCache() {
        this.cacheStore = {};
        // Nothing to do.
    }
    /**
     * Clear the cache.
     */
    CoreCache.prototype.clear = function () {
        this.cacheStore = {};
    };
    /**
     * Get all the data stored in the cache for a certain id.
     *
     * @param {any} id The ID to identify the entry.
     * @return {any} The data from the cache. Undefined if not found.
     */
    CoreCache.prototype.getEntry = function (id) {
        if (!this.cacheStore[id]) {
            this.cacheStore[id] = {};
        }
        return this.cacheStore[id];
    };
    /**
     * Get the status of a module from the "cache".
     *
     * @param {any} id The ID to identify the entry.
     * @param {string} name Name of the value to get.
     * @param {boolean} [ignoreInvalidate] Whether it should always return the cached data, even if it's expired.
     * @return {any} Cached value. Undefined if not cached or expired.
     */
    CoreCache.prototype.getValue = function (id, name, ignoreInvalidate) {
        var entry = this.getEntry(id);
        if (entry[name] && typeof entry[name].value != 'undefined') {
            var now = Date.now();
            // Invalidate after 5 minutes.
            if (ignoreInvalidate || entry[name].timemodified + 300000 >= now) {
                return entry[name].value;
            }
        }
        return undefined;
    };
    /**
     * Invalidate all the cached data for a certain entry.
     *
     * @param {any} id The ID to identify the entry.
     */
    CoreCache.prototype.invalidate = function (id) {
        var entry = this.getEntry(id);
        for (var name_1 in entry) {
            entry[name_1].timemodified = 0;
        }
    };
    /**
     * Update the status of a module in the "cache".
     *
     * @param {any} id The ID to identify the entry.
     * @param {string} name Name of the value to set.
     * @param {any} value Value to set.
     * @return {any} The set value.
     */
    CoreCache.prototype.setValue = function (id, name, value) {
        var entry = this.getEntry(id);
        entry[name] = {
            value: value,
            timemodified: Date.now()
        };
        return value;
    };
    return CoreCache;
}());

//# sourceMappingURL=cache.js.map

/***/ }),

/***/ 981:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreUserProfileFieldComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_user_profile_field_delegate__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__ = __webpack_require__(9);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Directive to render user profile field.
 */
var CoreUserProfileFieldComponent = /** @class */ (function () {
    function CoreUserProfileFieldComponent(ufDelegate, utilsProvider) {
        this.ufDelegate = ufDelegate;
        this.utilsProvider = utilsProvider;
        this.signup = false; // True if editing the field in signup. Defaults to false.
        this.edit = false; // True if editing the field. Defaults to false.
        this.data = {}; // Data to pass to the component.
    }
    /**
     * Component being initialized.
     */
    CoreUserProfileFieldComponent.prototype.ngOnInit = function () {
        this.componentClass = this.ufDelegate.getComponent(this.field, this.signup);
        this.data.field = this.field;
        this.data.edit = this.utilsProvider.isTrueOrOne(this.edit);
        if (this.edit) {
            this.data.signup = this.utilsProvider.isTrueOrOne(this.signup);
            this.data.disabled = this.utilsProvider.isTrueOrOne(this.field.locked);
            this.data.form = this.form;
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreUserProfileFieldComponent.prototype, "field", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreUserProfileFieldComponent.prototype, "signup", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreUserProfileFieldComponent.prototype, "edit", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreUserProfileFieldComponent.prototype, "form", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreUserProfileFieldComponent.prototype, "registerAuth", void 0);
    CoreUserProfileFieldComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-user-profile-field',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/core/user/components/user-profile-field/user-profile-field.html"*/'<core-dynamic-component [component]="componentClass" [data]="data"></core-dynamic-component>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/core/user/components/user-profile-field/user-profile-field.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_user_profile_field_delegate__["a" /* CoreUserProfileFieldDelegate */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], CoreUserProfileFieldComponent);
    return CoreUserProfileFieldComponent;
}());

//# sourceMappingURL=user-profile-field.js.map

/***/ })

},[647]);
//# sourceMappingURL=main.js.map