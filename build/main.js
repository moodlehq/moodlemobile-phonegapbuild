webpackJsonp([60],[
/* 0 */,
/* 1 */,
/* 2 */,
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSitesProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(104);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__events__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__sites_factory__ = __webpack_require__(581);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__utils_text__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__utils_url__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__core_constants__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__configconstants__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_ts_md5_dist_md5__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_ts_md5_dist_md5___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_ts_md5_dist_md5__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};












/*
 * Service to manage and interact with sites.
 * It allows creating tables in the databases of all sites. Each service or component should be responsible of creating
 * their own database tables. Example:
 *
 * constructor(sitesProvider: CoreSitesProvider) {
 *     this.sitesProvider.createTableFromSchema(this.tableSchema);
 *
 * This provider will automatically create the tables in the databases of all the instantiated sites, and also to the
 * databases of sites instantiated from now on.
*/
var CoreSitesProvider = /** @class */ (function () {
    function CoreSitesProvider(logger, http, sitesFactory, appProvider, translate, urlUtils, eventsProvider, textUtils) {
        this.http = http;
        this.sitesFactory = sitesFactory;
        this.appProvider = appProvider;
        this.translate = translate;
        this.urlUtils = urlUtils;
        this.eventsProvider = eventsProvider;
        this.textUtils = textUtils;
        // Variables for the database.
        this.SITES_TABLE = 'sites';
        this.CURRENT_SITE_TABLE = 'current_site';
        this.appTablesSchema = [
            {
                name: this.SITES_TABLE,
                columns: [
                    {
                        name: 'id',
                        type: 'TEXT',
                        primaryKey: true
                    },
                    {
                        name: 'siteUrl',
                        type: 'TEXT',
                        notNull: true
                    },
                    {
                        name: 'token',
                        type: 'TEXT'
                    },
                    {
                        name: 'info',
                        type: 'TEXT'
                    },
                    {
                        name: 'privateToken',
                        type: 'TEXT'
                    },
                    {
                        name: 'config',
                        type: 'TEXT'
                    },
                    {
                        name: 'loggedOut',
                        type: 'INTEGER'
                    }
                ]
            },
            {
                name: this.CURRENT_SITE_TABLE,
                columns: [
                    {
                        name: 'id',
                        type: 'INTEGER',
                        primaryKey: true
                    },
                    {
                        name: 'siteId',
                        type: 'TEXT',
                        notNull: true,
                        unique: true
                    }
                ]
            }
        ];
        // Constants to validate a site version.
        this.VALID_VERSION = 1;
        this.LEGACY_APP_VERSION = 0;
        this.INVALID_VERSION = -1;
        this.services = {};
        this.sessionRestored = false;
        this.sites = {};
        this.siteTablesSchemas = []; // Schemas for site tables. Other providers can add schemas in here.
        this.logger = logger.getInstance('CoreSitesProvider');
        this.appDB = appProvider.getDB();
        this.appDB.createTablesFromSchema(this.appTablesSchema);
    }
    /**
     * Get the demo data for a certain "name" if it is a demo site.
     *
     * @param {string} name Name of the site to check.
     * @return {any} Site data if it's a demo site, undefined otherwise.
     */
    CoreSitesProvider.prototype.getDemoSiteData = function (name) {
        var demoSites = __WEBPACK_IMPORTED_MODULE_10__configconstants__["a" /* CoreConfigConstants */].demo_sites;
        if (typeof demoSites != 'undefined' && typeof demoSites[name] != 'undefined') {
            return demoSites[name];
        }
    };
    /**
     * Check if a site is valid and if it has specifics settings for authentication (like force to log in using the browser).
     * It will test both protocols if the first one fails: http and https.
     *
     * @param {string} siteUrl URL of the site to check.
     * @param {string} [protocol=https://] Protocol to use first.
     * @return {Promise<CoreSiteCheckResponse>} A promise resolved when the site is checked.
     */
    CoreSitesProvider.prototype.checkSite = function (siteUrl, protocol) {
        var _this = this;
        if (protocol === void 0) { protocol = 'https://'; }
        // The formatURL function adds the protocol if is missing.
        siteUrl = this.urlUtils.formatURL(siteUrl);
        if (!this.urlUtils.isHttpURL(siteUrl)) {
            return Promise.reject(this.translate.instant('core.login.invalidsite'));
        }
        else if (!this.appProvider.isOnline()) {
            return Promise.reject(this.translate.instant('core.networkerrormsg'));
        }
        else {
            return this.checkSiteWithProtocol(siteUrl, protocol).catch(function (error) {
                // Do not continue checking if a critical error happened.
                if (error.critical) {
                    return Promise.reject(error.error);
                }
                // Retry with the other protocol.
                protocol = protocol == 'https://' ? 'http://' : 'https://';
                return _this.checkSiteWithProtocol(siteUrl, protocol).catch(function (secondError) {
                    // Site doesn't exist.
                    if (secondError.error) {
                        return Promise.reject(secondError.error);
                    }
                    else if (error.error) {
                        return Promise.reject(error.error);
                    }
                    return Promise.reject(_this.translate.instant('core.login.checksiteversion'));
                });
            });
        }
    };
    /**
     * Helper function to check if a site is valid and if it has specifics settings for authentication.
     *
     * @param {string} siteUrl URL of the site to check.
     * @param {string} protocol Protocol to use.
     * @return {Promise<CoreSiteCheckResponse>} A promise resolved when the site is checked.
     */
    CoreSitesProvider.prototype.checkSiteWithProtocol = function (siteUrl, protocol) {
        var _this = this;
        var publicConfig;
        // Now, replace the siteUrl with the protocol.
        siteUrl = siteUrl.replace(/^http(s)?\:\/\//i, protocol);
        return this.siteExists(siteUrl).catch(function (error) {
            // Do not continue checking if WS are not enabled.
            if (error.errorcode && error.errorcode == 'enablewsdescription') {
                return rejectWithCriticalError(error.error, error.errorcode);
            }
            // Site doesn't exist. Try to add or remove 'www'.
            var treatedUrl = _this.urlUtils.addOrRemoveWWW(siteUrl);
            return _this.siteExists(treatedUrl).then(function () {
                // Success, use this new URL as site url.
                siteUrl = treatedUrl;
            }).catch(function (secondError) {
                // Do not continue checking if WS are not enabled.
                if (secondError.errorcode && secondError.errorcode == 'enablewsdescription') {
                    return rejectWithCriticalError(secondError.error, secondError.errorcode);
                }
                error = secondError || error;
                return Promise.reject({ error: typeof error == 'object' ? error.error : error });
            });
        }).then(function () {
            // Create a temporary site to check if local_mobile is installed.
            var temporarySite = _this.sitesFactory.makeSite(undefined, siteUrl);
            return temporarySite.checkLocalMobilePlugin().then(function (data) {
                data.service = data.service || __WEBPACK_IMPORTED_MODULE_10__configconstants__["a" /* CoreConfigConstants */].wsservice;
                _this.services[siteUrl] = data.service; // No need to store it in DB.
                if (data.coreSupported ||
                    (data.code != __WEBPACK_IMPORTED_MODULE_9__core_constants__["a" /* CoreConstants */].LOGIN_SSO_CODE && data.code != __WEBPACK_IMPORTED_MODULE_9__core_constants__["a" /* CoreConstants */].LOGIN_SSO_INAPP_CODE)) {
                    // SSO using local_mobile not needed, try to get the site public config.
                    return temporarySite.getPublicConfig().then(function (config) {
                        publicConfig = config;
                        // Check that the user can authenticate.
                        if (!config.enablewebservices) {
                            return rejectWithCriticalError(_this.translate.instant('core.login.webservicesnotenabled'));
                        }
                        else if (!config.enablemobilewebservice) {
                            return rejectWithCriticalError(_this.translate.instant('core.login.mobileservicesnotenabled'));
                        }
                        else if (config.maintenanceenabled) {
                            var message = _this.translate.instant('core.sitemaintenance');
                            if (config.maintenancemessage) {
                                message += config.maintenancemessage;
                            }
                            return rejectWithCriticalError(message);
                        }
                        // Everything ok.
                        if (data.code === 0) {
                            data.code = config.typeoflogin;
                        }
                        return data;
                    }, function (error) {
                        // Error, check if not supported.
                        if (error.available === 1) {
                            // Service supported but an error happened. Return error.
                            return Promise.reject({ error: error.error });
                        }
                        return data;
                    });
                }
                return data;
            }).then(function (data) {
                siteUrl = temporarySite.getURL();
                return { siteUrl: siteUrl, code: data.code, warning: data.warning, service: data.service, config: publicConfig };
            });
        });
        // Return a rejected promise with a "critical" error.
        function rejectWithCriticalError(message, errorCode) {
            return Promise.reject({
                error: message,
                errorcode: errorCode,
                critical: true
            });
        }
    };
    /**
     * Check if a site exists.
     *
     * @param  {string} siteUrl URL of the site to check.
     * @return {Promise} A promise to be resolved if the site exists.
     */
    CoreSitesProvider.prototype.siteExists = function (siteUrl) {
        var data = {};
        if (!this.appProvider.isMobile()) {
            // Send fake parameters for CORS. This is only needed in browser.
            data.username = 'a';
            data.password = 'b';
            data.service = 'c';
        }
        var promise = this.http.post(siteUrl + '/login/token.php', data).timeout(__WEBPACK_IMPORTED_MODULE_9__core_constants__["a" /* CoreConstants */].WS_TIMEOUT).toPromise();
        return promise.catch(function (error) {
            return Promise.reject(error.message);
        }).then(function (data) {
            if (data.errorcode && (data.errorcode == 'enablewsdescription' || data.errorcode == 'requirecorrectaccess')) {
                return Promise.reject({ errorcode: data.errorcode, error: data.error });
            }
            else if (data.error && data.error == 'Web services must be enabled in Advanced features.') {
                return Promise.reject({ errorcode: 'enablewsdescription', error: data.error });
            }
            // Other errors are not being checked because invalid login will be always raised and we cannot differ them.
        });
    };
    /**
     * Gets a user token from the server.
     *
     * @param {string} siteUrl The site url.
     * @param {string} username User name.
     * @param {string} password Password.
     * @param {string} [service] Service to use. If not defined, it will be searched in memory.
     * @param {boolean} [retry] Whether we are retrying with a prefixed URL.
     * @return {Promise<CoreSiteUserTokenResponse>} A promise resolved when the token is retrieved.
     */
    CoreSitesProvider.prototype.getUserToken = function (siteUrl, username, password, service, retry) {
        var _this = this;
        if (!this.appProvider.isOnline()) {
            return Promise.reject(this.translate.instant('core.networkerrormsg'));
        }
        if (!service) {
            service = this.determineService(siteUrl);
        }
        var params = {
            username: username,
            password: password,
            service: service
        }, promise = this.http.post(siteUrl + '/login/token.php', params).timeout(__WEBPACK_IMPORTED_MODULE_9__core_constants__["a" /* CoreConstants */].WS_TIMEOUT).toPromise();
        return promise.then(function (data) {
            if (typeof data == 'undefined') {
                return Promise.reject(_this.translate.instant('core.cannotconnect'));
            }
            else {
                if (typeof data.token != 'undefined') {
                    return { token: data.token, siteUrl: siteUrl, privateToken: data.privatetoken };
                }
                else {
                    if (typeof data.error != 'undefined') {
                        // We only allow one retry (to avoid loops).
                        if (!retry && data.errorcode == 'requirecorrectaccess') {
                            siteUrl = _this.urlUtils.addOrRemoveWWW(siteUrl);
                            return _this.getUserToken(siteUrl, username, password, service, true);
                        }
                        else if (typeof data.errorcode != 'undefined') {
                            return Promise.reject({ error: data.error, errorcode: data.errorcode });
                        }
                        else {
                            return Promise.reject(data.error);
                        }
                    }
                    else {
                        return Promise.reject(_this.translate.instant('core.login.invalidaccount'));
                    }
                }
            }
        }, function () {
            return Promise.reject(_this.translate.instant('core.cannotconnect'));
        });
    };
    /**
     * Add a new site to the site list and authenticate the user in this site.
     *
     * @param {string} siteUrl The site url.
     * @param {string} token User's token.
     * @param {string} [privateToken=''] User's private token.
     * @return {Promise<any>} A promise resolved when the site is added and the user is authenticated.
     */
    CoreSitesProvider.prototype.newSite = function (siteUrl, token, privateToken) {
        var _this = this;
        if (privateToken === void 0) { privateToken = ''; }
        // Create a "candidate" site to fetch the site info.
        var candidateSite = this.sitesFactory.makeSite(undefined, siteUrl, token, undefined, privateToken);
        return candidateSite.fetchSiteInfo().then(function (info) {
            var result = _this.isValidMoodleVersion(info);
            if (result == _this.VALID_VERSION) {
                // Set site ID and info.
                var siteId_1 = _this.createSiteID(info.siteurl, info.username);
                candidateSite.setId(siteId_1);
                candidateSite.setInfo(info);
                // Try to get the site config.
                return _this.getSiteConfig(candidateSite).then(function (config) {
                    candidateSite.setConfig(config);
                    // Add site to sites list.
                    _this.addSite(siteId_1, siteUrl, token, info, privateToken, config);
                    // Turn candidate site into current site.
                    _this.currentSite = candidateSite;
                    _this.sites[siteId_1] = candidateSite;
                    // Store session.
                    _this.login(siteId_1);
                    _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_4__events__["a" /* CoreEventsProvider */].SITE_ADDED, {}, siteId_1);
                    if (_this.siteTablesSchemas.length) {
                        // Create tables in the site's database.
                        candidateSite.getDb().createTablesFromSchema(_this.siteTablesSchemas);
                    }
                    return siteId_1;
                });
            }
            else if (result == _this.LEGACY_APP_VERSION) {
                return Promise.reject(_this.translate.instant('core.login.legacymoodleversion'));
            }
            else {
                return Promise.reject(_this.translate.instant('core.login.invalidmoodleversion'));
            }
        });
    };
    /**
     * Create a site ID based on site URL and username.
     *
     * @param {string} siteUrl The site url.
     * @param {string} username Username.
     * @return {string} Site ID.
     */
    CoreSitesProvider.prototype.createSiteID = function (siteUrl, username) {
        return __WEBPACK_IMPORTED_MODULE_11_ts_md5_dist_md5__["Md5"].hashAsciiStr(siteUrl + username);
    };
    /**
     * Function for determine which service we should use (default or extended plugin).
     *
     * @param {string} siteUrl The site URL.
     * @return {string} The service shortname.
     */
    CoreSitesProvider.prototype.determineService = function (siteUrl) {
        // We need to try siteUrl in both https or http (due to loginhttps setting).
        // First http://
        siteUrl = siteUrl.replace('https://', 'http://');
        if (this.services[siteUrl]) {
            return this.services[siteUrl];
        }
        // Now https://
        siteUrl = siteUrl.replace('http://', 'https://');
        if (this.services[siteUrl]) {
            return this.services[siteUrl];
        }
        // Return default service.
        return __WEBPACK_IMPORTED_MODULE_10__configconstants__["a" /* CoreConfigConstants */].wsservice;
    };
    /**
     * Check for the minimum required version.
     *
     * @param {any} info Site info.
     * @return {number} Either VALID_VERSION, LEGACY_APP_VERSION or INVALID_VERSION.
     */
    CoreSitesProvider.prototype.isValidMoodleVersion = function (info) {
        if (!info) {
            return this.INVALID_VERSION;
        }
        var version24 = 2012120300, // Moodle 2.4 version.
        release24 = '2.4', version31 = 2016052300, release31 = '3.1';
        // Try to validate by version.
        if (info.version) {
            var version = parseInt(info.version, 10);
            if (!isNaN(version)) {
                if (version >= version31) {
                    return this.VALID_VERSION;
                }
                else if (version >= version24) {
                    return this.LEGACY_APP_VERSION;
                }
                else {
                    return this.INVALID_VERSION;
                }
            }
        }
        // We couldn't validate by version number. Let's try to validate by release number.
        if (info.release) {
            var matches = info.release.match(/^([\d|\.]*)/);
            if (matches && matches.length > 1) {
                if (matches[1] >= release31) {
                    return this.VALID_VERSION;
                }
                else if (matches[1] >= release24) {
                    return this.LEGACY_APP_VERSION;
                }
                else {
                    return this.INVALID_VERSION;
                }
            }
        }
        // Couldn't validate it.
        return this.INVALID_VERSION;
    };
    /**
     * Check if site info is valid. If it's not, return error message.
     *
     * @param {any} info Site info.
     * @return {any} True if valid, object with error message to show and its params if not valid.
     */
    CoreSitesProvider.prototype.validateSiteInfo = function (info) {
        if (!info.firstname || !info.lastname) {
            var moodleLink = "<a core-link href=\"" + info.siteurl + "\">" + info.siteurl + "</a>";
            return { error: 'core.requireduserdatamissing', params: { $a: moodleLink } };
        }
        return true;
    };
    /**
     * Saves a site in local DB.
     *
     * @param {string} id Site ID.
     * @param {string} siteUrl Site URL.
     * @param {string} token User's token in the site.
     * @param {any} info Site's info.
     * @param {string} [privateToken=''] User's private token.
     * @param {any} [config] Site config (from tool_mobile_get_config).
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreSitesProvider.prototype.addSite = function (id, siteUrl, token, info, privateToken, config) {
        if (privateToken === void 0) { privateToken = ''; }
        var entry = {
            id: id,
            siteUrl: siteUrl,
            token: token,
            info: info ? JSON.stringify(info) : info,
            privateToken: privateToken,
            config: config ? JSON.stringify(config) : config,
            loggedOut: 0
        };
        return this.appDB.insertOrUpdateRecord(this.SITES_TABLE, entry, { id: id });
    };
    /**
     * Login a user to a site from the list of sites.
     *
     * @param {string} siteId ID of the site to load.
     * @return {Promise}      Promise to be resolved when the site is loaded.
     */
    CoreSitesProvider.prototype.loadSite = function (siteId) {
        var _this = this;
        this.logger.debug("Load site " + siteId);
        return this.getSite(siteId).then(function (site) {
            _this.currentSite = site;
            _this.login(siteId);
            if (site.isLoggedOut()) {
                // Logged out, nothing else to do.
                return;
            }
            // Check if local_mobile was installed to Moodle.
            return site.checkIfLocalMobileInstalledAndNotUsed().then(function () {
                // Local mobile was added. Throw invalid session to force reconnect and create a new token.
                _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_4__events__["a" /* CoreEventsProvider */].SESSION_EXPIRED, {}, siteId);
            }, function () {
                // Update site info. We don't block the UI.
                _this.updateSiteInfo(siteId);
            });
        });
    };
    /**
     * Get current site.
     *
     * @return {CoreSite} Current site.
     */
    CoreSitesProvider.prototype.getCurrentSite = function () {
        return this.currentSite;
    };
    /**
     * Get the site home ID of the current site.
     *
     * @return {number} Current site home ID.
     */
    CoreSitesProvider.prototype.getCurrentSiteHomeId = function () {
        if (this.currentSite) {
            return this.currentSite.getSiteHomeId();
        }
        else {
            return 1;
        }
    };
    /**
     * Get current site ID.
     *
     * @return {string} Current site ID.
     */
    CoreSitesProvider.prototype.getCurrentSiteId = function () {
        if (this.currentSite) {
            return this.currentSite.getId();
        }
        else {
            return '';
        }
    };
    /**
     * Get current site User ID.
     *
     * @return {number} Current site User ID.
     */
    CoreSitesProvider.prototype.getCurrentSiteUserId = function () {
        if (this.currentSite) {
            return this.currentSite.getUserId();
        }
        else {
            return 0;
        }
    };
    /**
     * Check if the user is logged in a site.
     *
     * @return {boolean} Whether the user is logged in a site.
     */
    CoreSitesProvider.prototype.isLoggedIn = function () {
        return typeof this.currentSite != 'undefined' && typeof this.currentSite.token != 'undefined' &&
            this.currentSite.token != '';
    };
    /**
     * Delete a site from the sites list.
     *
     * @param {string} siteId ID of the site to delete.
     * @return {Promise<any>} Promise to be resolved when the site is deleted.
     */
    CoreSitesProvider.prototype.deleteSite = function (siteId) {
        var _this = this;
        this.logger.debug("Delete site " + siteId);
        if (typeof this.currentSite != 'undefined' && this.currentSite.id == siteId) {
            this.logout();
        }
        return this.getSite(siteId).then(function (site) {
            return site.deleteDB().then(function () {
                // Site DB deleted, now delete the app from the list of sites.
                delete _this.sites[siteId];
                return _this.appDB.deleteRecords(_this.SITES_TABLE, { id: siteId }).then(function () {
                    // Site deleted from sites list, now delete the folder.
                    return site.deleteFolder();
                }, function () {
                    // DB remove shouldn't fail, but we'll go ahead even if it does.
                    return site.deleteFolder();
                }).then(function () {
                    _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_4__events__["a" /* CoreEventsProvider */].SITE_DELETED, site, siteId);
                });
            });
        });
    };
    /**
     * Check if there are sites stored.
     *
     * @return {Promise<boolean>} Promise resolved with true if there are sites and false if there aren't.
     */
    CoreSitesProvider.prototype.hasSites = function () {
        return this.appDB.countRecords(this.SITES_TABLE).then(function (count) {
            return count > 0;
        });
    };
    /**
     * Returns a site object.
     *
     * @param {string} [siteId] The site ID. If not defined, current site (if available).
     * @return {Promise<CoreSite>} Promise resolved with the site.
     */
    CoreSitesProvider.prototype.getSite = function (siteId) {
        var _this = this;
        if (!siteId) {
            return this.currentSite ? Promise.resolve(this.currentSite) : Promise.reject(null);
        }
        else if (this.currentSite && this.currentSite.getId() == siteId) {
            return Promise.resolve(this.currentSite);
        }
        else if (typeof this.sites[siteId] != 'undefined') {
            return Promise.resolve(this.sites[siteId]);
        }
        else {
            // Retrieve and create the site.
            return this.appDB.getRecord(this.SITES_TABLE, { id: siteId }).then(function (data) {
                return _this.makeSiteFromSiteListEntry(data);
            });
        }
    };
    /**
     * Create a site from an entry of the sites list DB. The new site is added to the list of "cached" sites: this.sites.
     *
     * @param {any} entry Site list entry.
     * @return {CoreSite} Created site.
     */
    CoreSitesProvider.prototype.makeSiteFromSiteListEntry = function (entry) {
        var site, info = entry.info, config = entry.config;
        // Parse info and config.
        info = info ? this.textUtils.parseJSON(info) : info;
        config = config ? this.textUtils.parseJSON(config) : config;
        site = this.sitesFactory.makeSite(entry.id, entry.siteUrl, entry.token, info, entry.privateToken, config, entry.loggedOut == 1);
        this.sites[entry.id] = site;
        if (this.siteTablesSchemas.length) {
            // Create tables in the site's database.
            site.getDb().createTablesFromSchema(this.siteTablesSchemas);
        }
        return site;
    };
    /**
     * Returns if the site is the current one.
     *
     * @param {string|CoreSite} [site] Site object or siteId to be compared. If not defined, use current site.
     * @return {boolean} Whether site or siteId is the current one.
     */
    CoreSitesProvider.prototype.isCurrentSite = function (site) {
        if (!site || !this.currentSite) {
            return !!this.currentSite;
        }
        var siteId = typeof site == 'object' ? site.getId() : site;
        return this.currentSite.getId() === siteId;
    };
    /**
     * Returns the database object of a site.
     *
     * @param {string} [siteId] The site ID. If not defined, current site (if available).
     * @return {Promise<SQLiteDB>} Promise resolved with the database.
     */
    CoreSitesProvider.prototype.getSiteDb = function (siteId) {
        return this.getSite(siteId).then(function (site) {
            return site.getDb();
        });
    };
    /**
     * Returns the site home ID of a site.
     *
     * @param  {number} [siteId] The site ID. If not defined, current site (if available).
     * @return {Promise}         Promise resolved with site home ID.
     */
    CoreSitesProvider.prototype.getSiteHomeId = function (siteId) {
        return this.getSite(siteId).then(function (site) {
            return site.getSiteHomeId();
        });
    };
    /**
     * Get the list of sites stored.
     *
     * @param {String[]} [ids] IDs of the sites to get. If not defined, return all sites.
     * @return {Promise<CoreSiteBasicInfo[]>} Promise resolved when the sites are retrieved.
     */
    CoreSitesProvider.prototype.getSites = function (ids) {
        var _this = this;
        return this.appDB.getAllRecords(this.SITES_TABLE).then(function (sites) {
            var formattedSites = [];
            sites.forEach(function (site) {
                if (!ids || ids.indexOf(site.id) > -1) {
                    // Parse info.
                    var siteInfo = site.info ? _this.textUtils.parseJSON(site.info) : site.info, basicInfo = {
                        id: site.id,
                        siteUrl: site.siteUrl,
                        fullName: siteInfo && siteInfo.fullname,
                        siteName: siteInfo && siteInfo.sitename,
                        avatar: siteInfo && siteInfo.userpictureurl
                    };
                    formattedSites.push(basicInfo);
                }
            });
            return formattedSites;
        });
    };
    /**
     * Get the list of IDs of sites stored.
     *
     * @return {Promise<string[]>} Promise resolved when the sites IDs are retrieved.
     */
    CoreSitesProvider.prototype.getSitesIds = function () {
        return this.appDB.getAllRecords(this.SITES_TABLE).then(function (sites) {
            return sites.map(function (site) {
                return site.id;
            });
        });
    };
    /**
     * Login the user in a site.
     *
     * @param {string} siteid ID of the site the user is accessing.
     * @return {Promise<void>} Promise resolved when current site is stored.
     */
    CoreSitesProvider.prototype.login = function (siteId) {
        var _this = this;
        var entry = {
            id: 1,
            siteId: siteId
        };
        return this.appDB.insertOrUpdateRecord(this.CURRENT_SITE_TABLE, entry, { id: 1 }).then(function () {
            _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_4__events__["a" /* CoreEventsProvider */].LOGIN, {}, siteId);
        });
    };
    /**
     * Logout the user.
     *
     * @return {Promise<any>} Promise resolved when the user is logged out.
     */
    CoreSitesProvider.prototype.logout = function () {
        var _this = this;
        if (!this.currentSite) {
            // Already logged out.
            return Promise.resolve();
        }
        var siteId = this.currentSite.getId(), siteConfig = this.currentSite.getStoredConfig(), promises = [];
        this.currentSite = undefined;
        if (siteConfig && siteConfig.tool_mobile_forcelogout == '1') {
            promises.push(this.setSiteLoggedOut(siteId, true));
        }
        promises.push(this.appDB.deleteRecords(this.CURRENT_SITE_TABLE, { id: 1 }));
        return Promise.all(promises).finally(function () {
            _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_4__events__["a" /* CoreEventsProvider */].LOGOUT, {}, siteId);
        });
    };
    /**
     * Restores the session to the previous one so the user doesn't has to login everytime the app is started.
     *
     * @return {Promise<any>} Promise resolved if a session is restored.
     */
    CoreSitesProvider.prototype.restoreSession = function () {
        var _this = this;
        if (this.sessionRestored) {
            return Promise.reject(null);
        }
        this.sessionRestored = true;
        return this.appDB.getRecord(this.CURRENT_SITE_TABLE, { id: 1 }).then(function (currentSite) {
            var siteId = currentSite.siteId;
            _this.logger.debug("Restore session in site " + siteId);
            return _this.loadSite(siteId);
        });
    };
    /**
     * Mark or unmark a site as logged out so the user needs to authenticate again.
     *
     * @param {string} siteId ID of the site.
     * @param {boolean} loggedOut True to set the site as logged out, false otherwise.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreSitesProvider.prototype.setSiteLoggedOut = function (siteId, loggedOut) {
        var _this = this;
        return this.getSite(siteId).then(function (site) {
            var newValues = {
                token: '',
                loggedOut: loggedOut ? 1 : 0
            };
            site.setLoggedOut(loggedOut);
            return _this.appDB.updateRecords(_this.SITES_TABLE, newValues, { id: siteId });
        });
    };
    /**
     * Updates a site's token.
     *
     * @param {string} siteUrl Site's URL.
     * @param {string} username Username.
     * @param {string} token User's new token.
     * @param {string} [privateToken=''] User's private token.
     * @return {Promise<any>} A promise resolved when the site is updated.
     */
    CoreSitesProvider.prototype.updateSiteToken = function (siteUrl, username, token, privateToken) {
        if (privateToken === void 0) { privateToken = ''; }
        var siteId = this.createSiteID(siteUrl, username);
        return this.updateSiteTokenBySiteId(siteId, token, privateToken);
    };
    /**
     * Updates a site's token using siteId.
     *
     * @param {string} siteId Site Id.
     * @param {string} token User's new token.
     * @param {string} [privateToken=''] User's private token.
     * @return {Promise<any>} A promise resolved when the site is updated.
     */
    CoreSitesProvider.prototype.updateSiteTokenBySiteId = function (siteId, token, privateToken) {
        var _this = this;
        if (privateToken === void 0) { privateToken = ''; }
        return this.getSite(siteId).then(function (site) {
            var newValues = {
                token: token,
                privateToken: privateToken,
                loggedOut: 0
            };
            site.token = token;
            site.privateToken = privateToken;
            site.setLoggedOut(false); // Token updated means the user authenticated again, not logged out anymore.
            return _this.appDB.updateRecords(_this.SITES_TABLE, newValues, { id: siteId });
        });
    };
    /**
     * Updates a site's info.
     *
     * @param {string} siteid Site's ID.
     * @return {Promise<any>} A promise resolved when the site is updated.
     */
    CoreSitesProvider.prototype.updateSiteInfo = function (siteId) {
        var _this = this;
        return this.getSite(siteId).then(function (site) {
            return site.fetchSiteInfo().then(function (info) {
                site.setInfo(info);
                // Try to get the site config.
                return _this.getSiteConfig(site).catch(function () {
                    // Error getting config, keep the current one.
                }).then(function (config) {
                    var newValues = {
                        info: JSON.stringify(info),
                        loggedOut: site.isLoggedOut() ? 1 : 0
                    };
                    if (typeof config != 'undefined') {
                        site.setConfig(config);
                        newValues.config = JSON.stringify(config);
                    }
                    return _this.appDB.updateRecords(_this.SITES_TABLE, newValues, { id: siteId }).finally(function () {
                        _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_4__events__["a" /* CoreEventsProvider */].SITE_UPDATED, {}, siteId);
                    });
                });
            });
        });
    };
    /**
     * Updates a site's info.
     *
     * @param {string} siteUrl  Site's URL.
     * @param {string} username Username.
     * @return {Promise<any>} A promise to be resolved when the site is updated.
     */
    CoreSitesProvider.prototype.updateSiteInfoByUrl = function (siteUrl, username) {
        var siteId = this.createSiteID(siteUrl, username);
        return this.updateSiteInfo(siteId);
    };
    /**
     * Get the site IDs a URL belongs to.
     * Someone can have more than one account in the same site, that's why this function returns an array of IDs.
     *
     * @param {string} url URL to check.
     * @param {boolean} [prioritize] True if it should prioritize current site. If the URL belongs to current site then it won't
     *                               check any other site, it will only return current site.
     * @param {string} [username] If set, it will return only the sites where the current user has this username.
     * @return {Promise<string[]>} Promise resolved with the site IDs (array).
     */
    CoreSitesProvider.prototype.getSiteIdsFromUrl = function (url, prioritize, username) {
        var _this = this;
        // If prioritize is true, check current site first.
        if (prioritize && this.currentSite && this.currentSite.containsUrl(url)) {
            if (!username || this.currentSite.getInfo().username == username) {
                return Promise.resolve([this.currentSite.getId()]);
            }
        }
        // Check if URL has http(s) protocol.
        if (!url.match(/^https?:\/\//i)) {
            // URL doesn't have http(s) protocol. Check if it has any protocol.
            if (this.urlUtils.isAbsoluteURL(url)) {
                // It has some protocol. Return empty array.
                return Promise.resolve([]);
            }
            else {
                // No protocol, probably a relative URL. Return current site.
                if (this.currentSite) {
                    return Promise.resolve([this.currentSite.getId()]);
                }
                else {
                    return Promise.resolve([]);
                }
            }
        }
        return this.appDB.getAllRecords(this.SITES_TABLE).then(function (siteEntries) {
            var ids = [];
            siteEntries.forEach(function (site) {
                if (!_this.sites[site.id]) {
                    _this.makeSiteFromSiteListEntry(site);
                }
                if (_this.sites[site.id].containsUrl(url)) {
                    if (!username || _this.sites[site.id].getInfo().username == username) {
                        ids.push(site.id);
                    }
                }
            });
            return ids;
        }).catch(function () {
            // Shouldn't happen.
            return [];
        });
    };
    /**
     * Get the site ID stored in DB as current site.
     *
     * @return {Promise<string>} Promise resolved with the site ID.
     */
    CoreSitesProvider.prototype.getStoredCurrentSiteId = function () {
        return this.appDB.getRecord(this.CURRENT_SITE_TABLE, { id: 1 }).then(function (currentSite) {
            return currentSite.siteId;
        });
    };
    /**
     * Get the public config of a certain site.
     *
     * @param {string} siteUrl URL of the site.
     * @return {Promise<any>} Promise resolved with the public config.
     */
    CoreSitesProvider.prototype.getSitePublicConfig = function (siteUrl) {
        var temporarySite = this.sitesFactory.makeSite(undefined, siteUrl);
        return temporarySite.getPublicConfig();
    };
    /**
     * Get site config.
     *
     * @param {any} site The site to get the config.
     * @return {Promise<any>} Promise resolved with config if available.
     */
    CoreSitesProvider.prototype.getSiteConfig = function (site) {
        if (!site.wsAvailable('tool_mobile_get_config')) {
            // WS not available, cannot get config.
            return Promise.resolve();
        }
        return site.getConfig(undefined, true);
    };
    /**
     * Check if a certain feature is disabled in a site.
     *
     * @param {string} name Name of the feature to check.
     * @param {string} [siteId] The site ID. If not defined, current site (if available).
     * @return {Promise<boolean>} Promise resolved with true if disabled.
     */
    CoreSitesProvider.prototype.isFeatureDisabled = function (name, siteId) {
        return this.getSite(siteId).then(function (site) {
            return site.isFeatureDisabled(name);
        });
    };
    /**
     * Create a table in all the sites databases.
     *
     * @param {any} table Table schema.
     */
    CoreSitesProvider.prototype.createTableFromSchema = function (table) {
        this.createTablesFromSchema([table]);
    };
    /**
     * Create several tables in all the sites databases.
     *
     * @param {any[]} tables List of tables schema.
     */
    CoreSitesProvider.prototype.createTablesFromSchema = function (tables) {
        // Add the tables to the list of schemas. This list is to create all the tables in new sites.
        this.siteTablesSchemas = this.siteTablesSchemas.concat(tables);
        // Now create these tables in current sites.
        for (var id in this.sites) {
            this.sites[id].getDb().createTablesFromSchema(tables);
        }
    };
    /**
     * Check if a WS is available in the current site, if any.
     *
     * @param {string} method WS name.
     * @param {boolean} [checkPrefix=true] When true also checks with the compatibility prefix.
     * @return {boolean} Whether the WS is available.
     */
    CoreSitesProvider.prototype.wsAvailableInCurrentSite = function (method, checkPrefix) {
        if (checkPrefix === void 0) { checkPrefix = true; }
        var site = this.getCurrentSite();
        return site && site.wsAvailable(method, checkPrefix);
    };
    CoreSitesProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["b" /* HttpClient */], __WEBPACK_IMPORTED_MODULE_6__sites_factory__["a" /* CoreSitesFactoryProvider */],
            __WEBPACK_IMPORTED_MODULE_3__app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_8__utils_url__["a" /* CoreUrlUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_4__events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_7__utils_text__["a" /* CoreTextUtilsProvider */]])
    ], CoreSitesProvider);
    return CoreSitesProvider;
}());

//# sourceMappingURL=sites.js.map

/***/ }),
/* 4 */,
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreLoggerProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_moment__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_moment__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Helper service to display messages in the console.
 *
 * @description
 * This service is meant to improve log messages, adding a timestamp and a name to all log messages.
 *
 * In your class constructor, call getInstance to configure your class name:
 * this.logger = logger.getInstance('InitPage');
 *
 * Then you can call the log function you want to use in this logger instance.
 */
var CoreLoggerProvider = /** @class */ (function () {
    function CoreLoggerProvider() {
        /** Whether the logging is enabled. */
        this.enabled = true;
        // Nothing to do.
    }
    /**
     * Get a logger instance for a certain class, service or component.
     *
     * @param {string} className Name to use in the messages.
     * @return {ant} Instance.
     */
    CoreLoggerProvider.prototype.getInstance = function (className) {
        className = className || '';
        return {
            log: this.prepareLogFn(console.log.bind(console), className),
            info: this.prepareLogFn(console.info.bind(console), className),
            warn: this.prepareLogFn(console.warn.bind(console), className),
            debug: this.prepareLogFn(console.debug.bind(console), className),
            error: this.prepareLogFn(console.error.bind(console), className)
        };
    };
    /**
     * Prepare a logging function, concatenating the timestamp and class name to all messages.
     *
     * @param {Function} logFn Log function to use.
     * @param {string} className Name to use in the messages.
     * @return {Function} Prepared function.
     */
    CoreLoggerProvider.prototype.prepareLogFn = function (logFn, className) {
        var _this = this;
        // Return our own function that will call the logging function with the treated message.
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (_this.enabled) {
                var now = __WEBPACK_IMPORTED_MODULE_1_moment__().format('l LTS');
                args[0] = now + ' ' + className + ': ' + args[0]; // Prepend timestamp and className to the original message.
                logFn.apply(null, args);
            }
        };
    };
    CoreLoggerProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [])
    ], CoreLoggerProvider);
    return CoreLoggerProvider;
}());

//# sourceMappingURL=logger.js.map

/***/ }),
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreUtilsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_in_app_browser__ = __webpack_require__(152);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_clipboard__ = __webpack_require__(228);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__events__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__lang__ = __webpack_require__(96);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};










/*
 * "Utils" service with helper functions.
 */
var CoreUtilsProvider = /** @class */ (function () {
    function CoreUtilsProvider(iab, appProvider, clipboard, domUtils, logger, translate, platform, langProvider, eventsProvider) {
        this.iab = iab;
        this.appProvider = appProvider;
        this.clipboard = clipboard;
        this.domUtils = domUtils;
        this.translate = translate;
        this.platform = platform;
        this.langProvider = langProvider;
        this.eventsProvider = eventsProvider;
        this.logger = logger.getInstance('CoreUtilsProvider');
    }
    /**
     * Similar to Promise.all, but if a promise fails this function's promise won't be rejected until ALL promises have finished.
     *
     * @param {Promise<any>[]} promises Promises.
     * @return {Promise<any>} Promise resolved if all promises are resolved and rejected if at least 1 promise fails.
     */
    CoreUtilsProvider.prototype.allPromises = function (promises) {
        if (!promises || !promises.length) {
            return Promise.resolve();
        }
        return new Promise(function (resolve, reject) {
            var total = promises.length;
            var count = 0, error;
            promises.forEach(function (promise) {
                promise.catch(function (err) {
                    error = err;
                }).finally(function () {
                    count++;
                    if (count === total) {
                        // All promises have finished, reject/resolve.
                        if (error) {
                            reject(error);
                        }
                        else {
                            resolve();
                        }
                    }
                });
            });
        });
    };
    /**
     * Converts an array of objects to an object, using a property of each entry as the key.
     * E.g. [{id: 10, name: 'A'}, {id: 11, name: 'B'}] => {10: {id: 10, name: 'A'}, 11: {id: 11, name: 'B'}}
     *
     * @param {any[]} array The array to convert.
     * @param {string} propertyName The name of the property to use as the key.
     * @param {any} [result] Object where to put the properties. If not defined, a new object will be created.
     * @return {any} The object.
     */
    CoreUtilsProvider.prototype.arrayToObject = function (array, propertyName, result) {
        result = result || {};
        array.forEach(function (entry) {
            result[entry[propertyName]] = entry;
        });
        return result;
    };
    /**
     * Compare two objects. This function won't compare functions and proto properties, it's a basic compare.
     * Also, this will only check if itemA's properties are in itemB with same value. This function will still
     * return true if itemB has more properties than itemA.
     *
     * @param {any} itemA First object.
     * @param {any} itemB Second object.
     * @param {number} [maxLevels=0] Number of levels to reach if 2 objects are compared.
     * @param {number} [level=0] Current deep level (when comparing objects).
     * @param {boolean} [undefinedIsNull=true] True if undefined is equal to null. Defaults to true.
     * @return {boolean} Whether both items are equal.
     */
    CoreUtilsProvider.prototype.basicLeftCompare = function (itemA, itemB, maxLevels, level, undefinedIsNull) {
        if (maxLevels === void 0) { maxLevels = 0; }
        if (level === void 0) { level = 0; }
        if (undefinedIsNull === void 0) { undefinedIsNull = true; }
        if (typeof itemA == 'function' || typeof itemB == 'function') {
            return true; // Don't compare functions.
        }
        else if (typeof itemA == 'object' && typeof itemB == 'object') {
            if (level >= maxLevels) {
                return true; // Max deep reached.
            }
            var equal = true;
            for (var name_1 in itemA) {
                var value = itemA[name_1];
                if (name_1 == '$$hashKey') {
                    // Ignore $$hashKey property since it's a "calculated" property.
                    return;
                }
                if (!this.basicLeftCompare(value, itemB[name_1], maxLevels, level + 1)) {
                    equal = false;
                }
            }
            return equal;
        }
        else {
            if (undefinedIsNull && ((typeof itemA == 'undefined' && itemB === null) || (itemA === null && typeof itemB == 'undefined'))) {
                return true;
            }
            // We'll treat "2" and 2 as the same value.
            var floatA = parseFloat(itemA), floatB = parseFloat(itemB);
            if (!isNaN(floatA) && !isNaN(floatB)) {
                return floatA == floatB;
            }
            return itemA === itemB;
        }
    };
    /**
     * Blocks leaving a view.
     */
    CoreUtilsProvider.prototype.blockLeaveView = function () {
        // @todo
    };
    /**
     * Close the InAppBrowser window.
     *
     * @param {boolean} [closeAll] Desktop only. True to close all secondary windows, false to close only the "current" one.
     */
    CoreUtilsProvider.prototype.closeInAppBrowser = function (closeAll) {
        if (this.iabInstance) {
            this.iabInstance.close();
            if (closeAll && this.appProvider.isDesktop()) {
                __webpack_require__(238).ipcRenderer.send('closeSecondaryWindows');
            }
        }
    };
    /**
     * Clone a variable. It should be an object, array or primitive type.
     *
     * @param {any} source The variable to clone.
     * @return {any} Cloned variable.
     */
    CoreUtilsProvider.prototype.clone = function (source) {
        if (Array.isArray(source)) {
            // Clone the array and all the entries.
            var newArray = [];
            for (var i = 0; i < source.length; i++) {
                newArray[i] = this.clone(source[i]);
            }
            return newArray;
        }
        else if (typeof source == 'object' && source !== null) {
            // Clone the object and all the subproperties.
            var newObject = {};
            for (var name_2 in source) {
                newObject[name_2] = this.clone(source[name_2]);
            }
            return newObject;
        }
        else {
            // Primitive type or unknown, return it as it is.
            return source;
        }
    };
    /**
     * Copy properties from one object to another.
     *
     * @param {any} from Object to copy the properties from.
     * @param {any} to Object where to store the properties.
     * @param {boolean} [clone=true] Whether the properties should be cloned (so they are different instances).
     */
    CoreUtilsProvider.prototype.copyProperties = function (from, to, clone) {
        if (clone === void 0) { clone = true; }
        for (var name_3 in from) {
            if (clone) {
                to[name_3] = this.clone(from[name_3]);
            }
            else {
                to[name_3] = from[name_3];
            }
        }
    };
    /**
     * Copies a text to clipboard and shows a toast message.
     *
     * @param {string} text Text to be copied
     * @return {Promise<any>} Promise resolved when text is copied.
     */
    CoreUtilsProvider.prototype.copyToClipboard = function (text) {
        var _this = this;
        return this.clipboard.copy(text).then(function () {
            // Show toast using ionicLoading.
            return _this.domUtils.showToast('core.copiedtoclipboard', true);
        }).catch(function () {
            // Ignore errors.
        });
    };
    /**
     * Empties an array without losing its reference.
     *
     * @param {any[]} array Array to empty.
     */
    CoreUtilsProvider.prototype.emptyArray = function (array) {
        array.length = 0; // Empty array without losing its reference.
    };
    /**
     * Removes all properties from an object without losing its reference.
     *
     * @param {object} object Object to remove the properties.
     */
    CoreUtilsProvider.prototype.emptyObject = function (object) {
        for (var key in object) {
            if (object.hasOwnProperty(key)) {
                delete object[key];
            }
        }
    };
    /**
     * Execute promises one depending on the previous.
     *
     * @param {any[]} orderedPromisesData Data to be executed including the following values:
     *                                 - func: Function to be executed.
     *                                 - context: Context to pass to the function. This allows using "this" inside the function.
     *                                 - params: Array of data to be sent to the function.
     *                                 - blocking: Boolean. If promise should block the following.
     * @return {Promise<any>} Promise resolved when all promises are resolved.
     */
    CoreUtilsProvider.prototype.executeOrderedPromises = function (orderedPromisesData) {
        var _this = this;
        var promises = [];
        var dependency = Promise.resolve();
        var _loop_1 = function (i) {
            var data = orderedPromisesData[i];
            var promise = void 0;
            // Add the process to the dependency stack.
            promise = dependency.finally(function () {
                var prom;
                try {
                    prom = data.func.apply(data.context, data.params || []);
                }
                catch (e) {
                    _this.logger.error(e.message);
                    return;
                }
                return prom;
            });
            promises.push(promise);
            // If the new process is blocking, we set it as the dependency.
            if (data.blocking) {
                dependency = promise;
            }
        };
        // Execute all the processes in order.
        for (var i in orderedPromisesData) {
            _loop_1(i);
        }
        // Return when all promises are done.
        return this.allPromises(promises);
    };
    /**
     * Flatten an object, moving subobjects' properties to the first level using dot notation. E.g.:
     * {a: {b: 1, c: 2}, d: 3} -> {'a.b': 1, 'a.c': 2, d: 3}
     *
     * @param {object} obj Object to flatten.
     * @return {object} Flatten object.
     */
    CoreUtilsProvider.prototype.flattenObject = function (obj) {
        var toReturn = {};
        for (var name_4 in obj) {
            if (!obj.hasOwnProperty(name_4)) {
                continue;
            }
            var value = obj[name_4];
            if (typeof value == 'object' && !Array.isArray(value)) {
                var flatObject = this.flattenObject(value);
                for (var subName in flatObject) {
                    if (!flatObject.hasOwnProperty(subName)) {
                        continue;
                    }
                    toReturn[name_4 + '.' + subName] = flatObject[subName];
                }
            }
            else {
                toReturn[name_4] = value;
            }
        }
        return toReturn;
    };
    /**
     * Given an array of strings, return only the ones that match a regular expression.
     *
     * @param {string[]} array Array to filter.
     * @param {RegExp} regex RegExp to apply to each string.
     * @return {string[]} Filtered array.
     */
    CoreUtilsProvider.prototype.filterByRegexp = function (array, regex) {
        if (!array || !array.length) {
            return [];
        }
        return array.filter(function (entry) {
            var matches = entry.match(regex);
            return matches && matches.length;
        });
    };
    /**
     * Filter the list of site IDs based on a isEnabled function.
     *
     * @param {string[]} siteIds Site IDs to filter.
     * @param {Function} isEnabledFn Function to call for each site. Must return true or a promise resolved with true if enabled.
     *                    It receives a siteId param and all the params sent to this function after 'checkAll'.
     * @param {boolean} [checkAll] True if it should check all the sites, false if it should check only 1 and treat them all
     *                   depending on this result.
     * @param {any} ...args All the params sent after checkAll will be passed to isEnabledFn.
     * @return {Promise<string[]>} Promise resolved with the list of enabled sites.
     */
    CoreUtilsProvider.prototype.filterEnabledSites = function (siteIds, isEnabledFn, checkAll) {
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            args[_i - 3] = arguments[_i];
        }
        var promises = [], enabledSites = [];
        var _loop_2 = function (i) {
            var siteId = siteIds[i];
            if (checkAll || !promises.length) {
                promises.push(Promise.resolve(isEnabledFn.apply(isEnabledFn, [siteId].concat(args))).then(function (enabled) {
                    if (enabled) {
                        enabledSites.push(siteId);
                    }
                }));
            }
        };
        for (var i in siteIds) {
            _loop_2(i);
        }
        return this.allPromises(promises).catch(function () {
            // Ignore errors.
        }).then(function () {
            if (!checkAll) {
                // Checking 1 was enough, so it will either return all the sites or none.
                return enabledSites.length ? siteIds : [];
            }
            else {
                return enabledSites;
            }
        });
    };
    /**
     * Given a float, prints it nicely. Localized floats must not be used in calculations!
     * Based on Moodle's format_float.
     *
     * @param {any} float The float to print.
     * @return {string} Locale float.
     */
    CoreUtilsProvider.prototype.formatFloat = function (float) {
        if (typeof float == 'undefined') {
            return '';
        }
        var localeSeparator = this.translate.instant('core.decsep');
        // Convert float to string.
        float += '';
        return float.replace('.', localeSeparator);
    };
    /**
     * Returns a tree formatted from a plain list.
     * List has to be sorted by depth to allow this function to work correctly. Errors can be thrown if a child node is
     * processed before a parent node.
     *
     * @param {any[]} list List to format.
     * @param {string} [parentFieldName=parent] Name of the parent field to match with children.
     * @param {string} [idFieldName=id] Name of the children field to match with parent.
     * @param {number} [rootParentId=0] The id of the root.
     * @param {number} [maxDepth=5] Max Depth to convert to tree. Children found will be in the last level of depth.
     * @return {any[]} Array with the formatted tree, children will be on each node under children field.
     */
    CoreUtilsProvider.prototype.formatTree = function (list, parentFieldName, idFieldName, rootParentId, maxDepth) {
        if (parentFieldName === void 0) { parentFieldName = 'parent'; }
        if (idFieldName === void 0) { idFieldName = 'id'; }
        if (rootParentId === void 0) { rootParentId = 0; }
        if (maxDepth === void 0) { maxDepth = 5; }
        var map = {}, mapDepth = {}, tree = [];
        var parent, id;
        list.forEach(function (node, index) {
            id = node[idFieldName];
            parent = node[parentFieldName];
            node.children = [];
            // Use map to look-up the parents.
            map[id] = index;
            if (parent != rootParentId) {
                var parentNode = list[map[parent]];
                if (parentNode) {
                    if (mapDepth[parent] == maxDepth) {
                        // Reached max level of depth. Proceed with flat order. Find parent object of the current node.
                        var parentOfParent = parentNode[parentFieldName];
                        if (parentOfParent) {
                            // This element will be the child of the node that is two levels up the hierarchy
                            // (i.e. the child of node.parent.parent).
                            list[map[parentOfParent]].children.push(node);
                            // Assign depth level to the same depth as the parent (i.e. max depth level).
                            mapDepth[id] = mapDepth[parent];
                            // Change the parent to be the one that is two levels up the hierarchy.
                            node.parent = parentOfParent;
                        }
                    }
                    else {
                        parentNode.children.push(node);
                        // Increase the depth level.
                        mapDepth[id] = mapDepth[parent] + 1;
                    }
                }
            }
            else {
                tree.push(node);
                // Root elements are the first elements in the tree structure, therefore have the depth level 1.
                mapDepth[id] = 1;
            }
        });
        return tree;
    };
    /**
     * Get country name based on country code.
     *
     * @param {string} code Country code (AF, ES, US, ...).
     * @return {string} Country name. If the country is not found, return the country code.
     */
    CoreUtilsProvider.prototype.getCountryName = function (code) {
        var countryKey = 'assets.countries.' + code, countryName = this.translate.instant(countryKey);
        return countryName !== countryKey ? countryName : code;
    };
    /**
     * Get list of countries with their code and translated name.
     *
     * @return {Promise<any>} Promise resolved with the list of countries.
     */
    CoreUtilsProvider.prototype.getCountryList = function () {
        var _this = this;
        // Get the current language.
        return this.langProvider.getCurrentLanguage().then(function (lang) {
            // Get the full list of translations. Create a promise to convert the observable into a promise.
            return new Promise(function (resolve, reject) {
                var observer = _this.translate.getTranslation(lang).subscribe(function (table) {
                    resolve(table);
                    observer.unsubscribe();
                }, function (err) {
                    reject(err);
                    observer.unsubscribe();
                });
            });
        }).then(function (table) {
            var countries = {};
            for (var name_5 in table) {
                if (name_5.indexOf('assets.countries.') === 0) {
                    var code = name_5.replace('assets.countries.', '');
                    countries[code] = table[name_5];
                }
            }
            return countries;
        });
    };
    /**
     * Given a list of files, check if there are repeated names.
     *
     * @param {any[]} files List of files.
     * @return {string|boolean} String with error message if repeated, false if no repeated.
     */
    CoreUtilsProvider.prototype.hasRepeatedFilenames = function (files) {
        if (!files || !files.length) {
            return false;
        }
        var names = [];
        // Check if there are 2 files with the same name.
        for (var i = 0; i < files.length; i++) {
            var name_6 = files[i].filename || files[i].name;
            if (names.indexOf(name_6) > -1) {
                return this.translate.instant('core.filenameexist', { $a: name_6 });
            }
            else {
                names.push(name_6);
            }
        }
        return false;
    };
    /**
     * Gets the index of the first string that matches a regular expression.
     *
     * @param {string[]} array Array to search.
     * @param {RegExp} regex RegExp to apply to each string.
     * @return {number} Index of the first string that matches the RegExp. -1 if not found.
     */
    CoreUtilsProvider.prototype.indexOfRegexp = function (array, regex) {
        if (!array || !array.length) {
            return -1;
        }
        for (var i = 0; i < array.length; i++) {
            var entry = array[i], matches = entry.match(regex);
            if (matches && matches.length) {
                return i;
            }
        }
        return -1;
    };
    /**
     * Return true if the param is false (bool), 0 (number) or "0" (string).
     *
     * @param {any} value Value to check.
     * @return {boolean} Whether the value is false, 0 or "0".
     */
    CoreUtilsProvider.prototype.isFalseOrZero = function (value) {
        return typeof value != 'undefined' && (value === false || value === 'false' || parseInt(value, 10) === 0);
    };
    /**
     * Return true if the param is true (bool), 1 (number) or "1" (string).
     *
     * @param {any} value Value to check.
     * @return {boolean} Whether the value is true, 1 or "1".
     */
    CoreUtilsProvider.prototype.isTrueOrOne = function (value) {
        return typeof value != 'undefined' && (value === true || value === 'true' || parseInt(value, 10) === 1);
    };
    /**
     * Create a "fake" WS error for local errors.
     *
     * @param {string} message The message to include in the error.
     * @param {boolean} [needsTranslate] If the message needs to be translated.
     * @return {CoreWSError} Fake WS error.
     */
    CoreUtilsProvider.prototype.createFakeWSError = function (message, needsTranslate) {
        if (needsTranslate) {
            message = this.translate.instant(message);
        }
        return {
            message: message
        };
    };
    /**
     * Given an error returned by a WS call, check if the error is generated by the app or it has been returned by the WebSwervice.
     *
     * @param {any} error Error to check.
     * @return {boolean} Whether the error was returned by the WebService.
     */
    CoreUtilsProvider.prototype.isWebServiceError = function (error) {
        return typeof error.errorcode == 'undefined';
    };
    /**
     * Merge two arrays, removing duplicate values.
     *
     * @param {any[]} array1 The first array.
     * @param {any[]} array2 The second array.
     * @param [key] Key of the property that must be unique. If not specified, the whole entry.
     * @return {any[]} Merged array.
     */
    CoreUtilsProvider.prototype.mergeArraysWithoutDuplicates = function (array1, array2, key) {
        return this.uniqueArray(array1.concat(array2), key);
    };
    /**
     * Open a file using platform specific method.
     *
     * node-webkit: Using the default application configured.
     * Android: Using the WebIntent plugin.
     * iOs: Using handleDocumentWithURL.
     *
     * @param {string} path The local path of the file to be open.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreUtilsProvider.prototype.openFile = function (path) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (_this.appProvider.isDesktop()) {
                // It's a desktop app, send an event so the file is opened.
                // Opening the file from here (renderer process) doesn't focus the opened app, that's why an event is needed.
                // Use sendSync so we can receive the result.
                if (__webpack_require__(238).ipcRenderer.sendSync('openItem', path)) {
                    resolve();
                }
                else {
                    reject(_this.translate.instant('core.erroropenfilenoapp'));
                }
            }
            else if (window.plugins) {
                // @todo
                reject('TODO');
            }
            else {
                // Changing _blank for _system may work in cordova 2.4 and onwards.
                _this.logger.log('Opening external file using window.open()');
                window.open(path, '_blank');
                resolve();
            }
        });
    };
    /**
     * Open a URL using InAppBrowser.
     * Do not use for files, refer to {@link openFile}.
     *
     * @param {string} url The URL to open.
     * @param {any} [options] Override default options passed to InAppBrowser.
     * @return {InAppBrowserObject} The opened window.
     */
    CoreUtilsProvider.prototype.openInApp = function (url, options) {
        var _this = this;
        if (!url) {
            return;
        }
        options = options || {};
        if (!options.enableViewPortScale) {
            options.enableViewPortScale = 'yes'; // Enable zoom on iOS.
        }
        if (!options.location && this.platform.is('ios') && url.indexOf('file://') === 0) {
            // The URL uses file protocol, don't show it on iOS.
            // In Android we keep it because otherwise we lose the whole toolbar.
            options.location = 'no';
        }
        this.iabInstance = this.iab.create(url, '_blank', options);
        if (this.appProvider.isDesktop() || this.appProvider.isMobile()) {
            // Trigger global events when a url is loaded or the window is closed. This is to make it work like in Ionic 1.
            var loadStartSubscription_1 = this.iabInstance.on('loadstart').subscribe(function (event) {
                _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_6__events__["a" /* CoreEventsProvider */].IAB_LOAD_START, event);
            });
            var exitSubscription_1 = this.iabInstance.on('exit').subscribe(function (event) {
                loadStartSubscription_1.unsubscribe();
                exitSubscription_1.unsubscribe();
                _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_6__events__["a" /* CoreEventsProvider */].IAB_EXIT, event);
            });
        }
        return this.iabInstance;
    };
    /**
     * Open a URL using a browser.
     * Do not use for files, refer to {@link openFile}.
     *
     * @param {string} url The URL to open.
     */
    CoreUtilsProvider.prototype.openInBrowser = function (url) {
        if (this.appProvider.isDesktop()) {
            // It's a desktop app, use Electron shell library to open the browser.
            var shell = __webpack_require__(238).shell;
            if (!shell.openExternal(url)) {
                // Open browser failed, open a new window in the app.
                window.open(url, '_system');
            }
        }
        else {
            window.open(url, '_system');
        }
    };
    /**
     * Open an online file using platform specific method.
     * Specially useful for audio and video since they can be streamed.
     *
     * node-webkit: Using the default application configured.
     * Android: Using the WebIntent plugin.
     * iOS: Using the window.open method (InAppBrowser)
     *      We don't use iOS quickview framework because it doesn't support streaming.
     *
     * @param {string} url The URL of the file.
     * @return {Promise<void>} Promise resolved when opened.
     */
    CoreUtilsProvider.prototype.openOnlineFile = function (url) {
        return new Promise(function (resolve, reject) {
            // @todo
            reject('TODO');
        });
    };
    /**
     * Converts an object into an array, losing the keys.
     *
     * @param {object} obj Object to convert.
     * @return {any[]} Array with the values of the object but losing the keys.
     */
    CoreUtilsProvider.prototype.objectToArray = function (obj) {
        return Object.keys(obj).map(function (key) {
            return obj[key];
        });
    };
    /**
     * Converts an object into an array of objects, where each entry is an object containing
     * the key and value of the original object.
     * For example, it can convert {size: 2} into [{name: 'size', value: 2}].
     *
     * @param {object} obj Object to convert.
     * @param {string} keyName Name of the properties where to store the keys.
     * @param {string} valueName Name of the properties where to store the values.
     * @param {boolean} [sort] True to sort keys alphabetically, false otherwise.
     * @return {any[]} Array of objects with the name & value of each property.
     */
    CoreUtilsProvider.prototype.objectToArrayOfObjects = function (obj, keyName, valueName, sort) {
        // Get the entries from an object or primitive value.
        var getEntries = function (elKey, value) {
            if (typeof value == 'object') {
                // It's an object, return at least an entry for each property.
                var keys = Object.keys(value);
                var entries_1 = [];
                keys.forEach(function (key) {
                    var newElKey = elKey ? elKey + '[' + key + ']' : key;
                    entries_1 = entries_1.concat(getEntries(newElKey, value[key]));
                });
                return entries_1;
            }
            else {
                // Not an object, return a single entry.
                var entry = {};
                entry[keyName] = elKey;
                entry[valueName] = value;
                return entry;
            }
        };
        if (!obj) {
            return [];
        }
        // "obj" will always be an object, so "entries" will always be an array.
        var entries = getEntries('', obj);
        if (sort) {
            return entries.sort(function (a, b) {
                return a.name >= b.name ? 1 : -1;
            });
        }
        return entries;
    };
    /**
     * Converts an array of objects into an object with key and value. The opposite of objectToArrayOfObjects.
     * For example, it can convert [{name: 'size', value: 2}] into {size: 2}.
     *
     * @param {object[]} objects List of objects to convert.
     * @param {string} keyName Name of the properties where the keys are stored.
     * @param {string} valueName Name of the properties where the values are stored.
     * @param [keyPrefix] Key prefix if neededs to delete it.
     * @return {object} Object.
     */
    CoreUtilsProvider.prototype.objectToKeyValueMap = function (objects, keyName, valueName, keyPrefix) {
        if (!objects) {
            return;
        }
        var prefixSubstr = keyPrefix ? keyPrefix.length : 0, mapped = {};
        objects.forEach(function (item) {
            var key = prefixSubstr > 0 ? item[keyName].substr(prefixSubstr) : item[keyName];
            mapped[key] = item[valueName];
        });
        return mapped;
    };
    /**
     * Similar to AngularJS $q.defer().
     *
     * @return {PromiseDefer} The deferred promise.
     */
    CoreUtilsProvider.prototype.promiseDefer = function () {
        var deferred = {};
        deferred.promise = new Promise(function (resolve, reject) {
            deferred.resolve = resolve;
            deferred.reject = reject;
        });
        return deferred;
    };
    /**
     * Given a promise, returns true if it's rejected or false if it's resolved.
     *
     * @param {Promise<any>} promise Promise to check
     * @return {Promise<boolean>} Promise resolved with boolean: true if the promise is rejected or false if it's resolved.
     */
    CoreUtilsProvider.prototype.promiseFails = function (promise) {
        return promise.then(function () {
            return false;
        }).catch(function () {
            return true;
        });
    };
    /**
     * Given a promise, returns true if it's resolved or false if it's rejected.
     *
     * @param {Promise<any>} promise Promise to check
     * @return {Promise<boolean>} Promise resolved with boolean: true if the promise it's resolved or false if it's rejected.
     */
    CoreUtilsProvider.prototype.promiseWorks = function (promise) {
        return promise.then(function () {
            return true;
        }).catch(function () {
            return false;
        });
    };
    /**
     * Tests to see whether two arrays or objects have the same value at a particular key.
     * Missing values are replaced by '', and the values are compared with ===.
     * Booleans and numbers are cast to string before comparing.
     *
     * @param {any} obj1 The first object or array.
     * @param {any} obj2 The second object or array.
     * @param {string} key Key to check.
     * @return {boolean} Whether the two objects/arrays have the same value (or lack of one) for a given key.
     */
    CoreUtilsProvider.prototype.sameAtKeyMissingIsBlank = function (obj1, obj2, key) {
        var value1 = typeof obj1[key] != 'undefined' ? obj1[key] : '', value2 = typeof obj2[key] != 'undefined' ? obj2[key] : '';
        if (typeof value1 == 'number' || typeof value1 == 'boolean') {
            value1 = '' + value1;
        }
        if (typeof value2 == 'number' || typeof value2 == 'boolean') {
            value2 = '' + value2;
        }
        return value1 === value2;
    };
    /**
     * Stringify an object, sorting the properties. It doesn't sort arrays, only object properties. E.g.:
     * {b: 2, a: 1} -> '{"a":1,"b":2}'
     *
     * @param {object} obj Object to stringify.
     * @return {string} Stringified object.
     */
    CoreUtilsProvider.prototype.sortAndStringify = function (obj) {
        return JSON.stringify(this.sortProperties(obj));
    };
    /**
     * Given an object, sort its properties and the properties of all the nested objects.
     *
     * @param {object} obj The object to sort. If it isn't an object, the original value will be returned.
     * @return {object} Sorted object.
     */
    CoreUtilsProvider.prototype.sortProperties = function (obj) {
        var _this = this;
        if (typeof obj == 'object' && !Array.isArray(obj)) {
            // It's an object, sort it.
            return Object.keys(obj).sort().reduce(function (accumulator, key) {
                // Always call sort with the value. If it isn't an object, the original value will be returned.
                accumulator[key] = _this.sortProperties(obj[key]);
                return accumulator;
            }, {});
        }
        else {
            return obj;
        }
    };
    /**
     * Sum the filesizes from a list of files checking if the size will be partial or totally calculated.
     *
     * @param {any[]} files List of files to sum its filesize.
     * @return {{size: number, total: boolean}} File size and a boolean to indicate if it is the total size or only partial.
     */
    CoreUtilsProvider.prototype.sumFileSizes = function (files) {
        var result = {
            size: 0,
            total: true
        };
        files.forEach(function (file) {
            if (typeof file.filesize == 'undefined') {
                // We don't have the file size, cannot calculate its total size.
                result.total = false;
            }
            else {
                result.size += file.filesize;
            }
        });
        return result;
    };
    /**
     * Converts locale specific floating point/comma number back to standard PHP float value.
     * Do NOT try to do any math operations before this conversion on any user submitted floats!
     * Based on Moodle's unformat_float function.
     *
     * @param {any} localeFloat Locale aware float representation.
     * @return {any} False if bad format, empty string if empty value or the parsed float if not.
     */
    CoreUtilsProvider.prototype.unformatFloat = function (localeFloat) {
        // Bad format on input type number.
        if (typeof localeFloat == 'undefined') {
            return false;
        }
        // Empty (but not zero).
        if (localeFloat == null) {
            return '';
        }
        // Convert float to string.
        localeFloat += '';
        localeFloat = localeFloat.trim();
        if (localeFloat == '') {
            return '';
        }
        var localeSeparator = this.translate.instant('core.decsep');
        localeFloat = localeFloat.replace(' ', ''); // No spaces - those might be used as thousand separators.
        localeFloat = localeFloat.replace(localeSeparator, '.');
        localeFloat = parseFloat(localeFloat);
        // Bad format.
        if (isNaN(localeFloat)) {
            return false;
        }
        return localeFloat;
    };
    /**
     * Return an array without duplicate values.
     *
     * @param {any[]} array The array to treat.
     * @param [key] Key of the property that must be unique. If not specified, the whole entry.
     * @return {any[]} Array without duplicate values.
     */
    CoreUtilsProvider.prototype.uniqueArray = function (array, key) {
        var filtered = [], unique = [], len = array.length;
        for (var i = 0; i < len; i++) {
            var entry = array[i], value = key ? entry[key] : entry;
            if (unique.indexOf(value) == -1) {
                unique.push(value);
                filtered.push(entry);
            }
        }
        return filtered;
    };
    CoreUtilsProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__ionic_native_in_app_browser__["a" /* InAppBrowser */], __WEBPACK_IMPORTED_MODULE_4__app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_3__ionic_native_clipboard__["a" /* Clipboard */],
            __WEBPACK_IMPORTED_MODULE_5__dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_7__logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_8__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */], __WEBPACK_IMPORTED_MODULE_9__lang__["a" /* CoreLangProvider */], __WEBPACK_IMPORTED_MODULE_6__events__["a" /* CoreEventsProvider */]])
    ], CoreUtilsProvider);
    return CoreUtilsProvider;
}());

//# sourceMappingURL=utils.js.map

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreDomUtilsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__text__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__config__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__url__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_constants__ = __webpack_require__(22);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








/*
 * "Utils" service with helper functions for UI, DOM elements and HTML code.
 */
var CoreDomUtilsProvider = /** @class */ (function () {
    function CoreDomUtilsProvider(translate, loadingCtrl, toastCtrl, alertCtrl, textUtils, appProvider, platform, configProvider, urlUtils, modalCtrl) {
        this.translate = translate;
        this.loadingCtrl = loadingCtrl;
        this.toastCtrl = toastCtrl;
        this.alertCtrl = alertCtrl;
        this.textUtils = textUtils;
        this.appProvider = appProvider;
        this.platform = platform;
        this.configProvider = configProvider;
        this.urlUtils = urlUtils;
        this.modalCtrl = modalCtrl;
        // List of input types that support keyboard.
        this.INPUT_SUPPORT_KEYBOARD = ['date', 'datetime', 'datetime-local', 'email', 'month', 'number', 'password',
            'search', 'tel', 'text', 'time', 'url', 'week'];
        this.INSTANCE_ID_ATTR_NAME = 'core-instance-id';
        this.element = document.createElement('div'); // Fake element to use in some functions, to prevent creating it each time.
        this.instances = {}; // Store component/directive instances by id.
        this.lastInstanceId = 0;
    }
    /**
     * Wraps a message with core-format-text if the message contains HTML tags.
     * @todo Finish the adaptation
     *
     * @param {string} message Message to wrap.
     * @return {string} Result message.
     */
    CoreDomUtilsProvider.prototype.addFormatTextIfNeeded = function (message) {
        // @todo
        if (this.textUtils.hasHTMLTags(message)) {
            return '<core-format-text watch="true">' + message + '</core-format-text>';
        }
        return message;
    };
    /**
     * Equivalent to element.closest(). If the browser doesn't support element.closest, it will
     * traverse the parents to achieve the same functionality.
     * Returns the closest ancestor of the current element (or the current element itself) which matches the selector.
     *
     * @param {HTMLElement} element DOM Element.
     * @param {string} selector Selector to search.
     * @return {Element} Closest ancestor.
     */
    CoreDomUtilsProvider.prototype.closest = function (element, selector) {
        var _this = this;
        // Try to use closest if the browser supports it.
        if (typeof element.closest == 'function') {
            return element.closest(selector);
        }
        if (!this.matchesFn) {
            // Find the matches function supported by the browser.
            ['matches', 'webkitMatchesSelector', 'mozMatchesSelector', 'msMatchesSelector', 'oMatchesSelector'].some(function (fn) {
                if (typeof document.body[fn] == 'function') {
                    _this.matchesFn = fn;
                    return true;
                }
                return false;
            });
            if (!this.matchesFn) {
                return;
            }
        }
        // Traverse parents.
        while (element) {
            if (element[this.matchesFn](selector)) {
                return element;
            }
            element = element.parentElement;
        }
    };
    /**
     * If the download size is higher than a certain threshold shows a confirm dialog.
     *
     * @param {any} size Object containing size to download and a boolean to indicate if its totally or partialy calculated.
     * @param {string} [message] Code of the message to show. Default: 'core.course.confirmdownload'.
     * @param {string} [unknownMessage] ID of the message to show if size is unknown.
     * @param {number} [wifiThreshold] Threshold to show confirm in WiFi connection. Default: CoreWifiDownloadThreshold.
     * @param {number} [limitedThreshold] Threshold to show confirm in limited connection. Default: CoreDownloadThreshold.
     * @param {boolean} [alwaysConfirm] True to show a confirm even if the size isn't high, false otherwise.
     * @return {Promise<void>} Promise resolved when the user confirms or if no confirm needed.
     */
    CoreDomUtilsProvider.prototype.confirmDownloadSize = function (size, message, unknownMessage, wifiThreshold, limitedThreshold, alwaysConfirm) {
        wifiThreshold = typeof wifiThreshold == 'undefined' ? __WEBPACK_IMPORTED_MODULE_7__core_constants__["a" /* CoreConstants */].WIFI_DOWNLOAD_THRESHOLD : wifiThreshold;
        limitedThreshold = typeof limitedThreshold == 'undefined' ? __WEBPACK_IMPORTED_MODULE_7__core_constants__["a" /* CoreConstants */].DOWNLOAD_THRESHOLD : limitedThreshold;
        if (size.size < 0 || (size.size == 0 && !size.total)) {
            // Seems size was unable to be calculated. Show a warning.
            unknownMessage = unknownMessage || 'core.course.confirmdownloadunknownsize';
            return this.showConfirm(this.translate.instant(unknownMessage));
        }
        else if (!size.total) {
            // Filesize is only partial.
            var readableSize = this.textUtils.bytesToSize(size.size, 2);
            return this.showConfirm(this.translate.instant('core.course.confirmpartialdownloadsize', { size: readableSize }));
        }
        else if (size.size >= wifiThreshold || (this.appProvider.isNetworkAccessLimited() && size.size >= limitedThreshold)) {
            message = message || 'core.course.confirmdownload';
            var readableSize = this.textUtils.bytesToSize(size.size, 2);
            return this.showConfirm(this.translate.instant(message, { size: readableSize }));
        }
        else if (alwaysConfirm) {
            return this.showConfirm(this.translate.instant('core.areyousure'));
        }
        return Promise.resolve();
    };
    /**
     * Extract the downloadable URLs from an HTML code.
     *
     * @param {string} html HTML code.
     * @return {string[]} List of file urls.
     */
    CoreDomUtilsProvider.prototype.extractDownloadableFilesFromHtml = function (html) {
        var urls = [];
        var elements;
        this.element.innerHTML = html;
        elements = this.element.querySelectorAll('a, img, audio, video, source, track');
        for (var i = 0; i < elements.length; i++) {
            var element = elements[i];
            var url = element.tagName === 'A' ? element.href : element.src;
            if (url && this.urlUtils.isDownloadableUrl(url) && urls.indexOf(url) == -1) {
                urls.push(url);
            }
            // Treat video poster.
            if (element.tagName == 'VIDEO' && element.getAttribute('poster')) {
                url = element.getAttribute('poster');
                if (url && this.urlUtils.isDownloadableUrl(url) && urls.indexOf(url) == -1) {
                    urls.push(url);
                }
            }
        }
        return urls;
    };
    /**
     * Extract the downloadable URLs from an HTML code and returns them in fake file objects.
     *
     * @param {string} html HTML code.
     * @return {any[]} List of fake file objects with file URLs.
     */
    CoreDomUtilsProvider.prototype.extractDownloadableFilesFromHtmlAsFakeFileObjects = function (html) {
        var urls = this.extractDownloadableFilesFromHtml(html);
        // Convert them to fake file objects.
        return urls.map(function (url) {
            return {
                fileurl: url
            };
        });
    };
    /**
     * Search all the URLs in a CSS file content.
     *
     * @param {string} code CSS code.
     * @return {string[]} List of URLs.
     */
    CoreDomUtilsProvider.prototype.extractUrlsFromCSS = function (code) {
        // First of all, search all the url(...) occurrences that don't include "data:".
        var urls = [], matches = code.match(/url\(\s*["']?(?!data:)([^)]+)\)/igm);
        if (!matches) {
            return urls;
        }
        // Extract the URL form each match.
        matches.forEach(function (match) {
            var submatches = match.match(/url\(\s*['"]?([^'"]*)['"]?\s*\)/im);
            if (submatches && submatches[1]) {
                urls.push(submatches[1]);
            }
        });
        return urls;
    };
    /**
     * Focus an element and open keyboard.
     *
     * @param {HTMLElement} el HTML element to focus.
     */
    CoreDomUtilsProvider.prototype.focusElement = function (el) {
        if (el && el.focus) {
            el.focus();
            if (this.platform.is('android') && this.supportsInputKeyboard(el)) {
                // On some Android versions the keyboard doesn't open automatically.
                this.appProvider.openKeyboard();
            }
        }
    };
    /**
     * Formats a size to be used as width/height of an element.
     * If the size is already valid (like '500px' or '50%') it won't be modified.
     * Returned size will have a format like '500px'.
     *
     * @param {any} size Size to format.
     * @return {string} Formatted size. If size is not valid, returns an empty string.
     */
    CoreDomUtilsProvider.prototype.formatPixelsSize = function (size) {
        if (typeof size == 'string' && (size.indexOf('px') > -1 || size.indexOf('%') > -1)) {
            // It seems to be a valid size.
            return size;
        }
        size = parseInt(size, 10);
        if (!isNaN(size)) {
            return size + 'px';
        }
        return '';
    };
    /**
     * Returns the contents of a certain selection in a DOM element.
     *
     * @param {HTMLElement} element DOM element to search in.
     * @param {string} selector Selector to search.
     * @return {string} Selection contents. Undefined if not found.
     */
    CoreDomUtilsProvider.prototype.getContentsOfElement = function (element, selector) {
        if (element) {
            var selected = element.querySelector(selector);
            if (selected) {
                return selected.innerHTML;
            }
        }
    };
    /**
     * Get the data from a form. It will only collect elements that have a name.
     *
     * @param {HTMLFormElement} form The form to get the data from.
     * @return {any} Object with the data. The keys are the names of the inputs.
     */
    CoreDomUtilsProvider.prototype.getDataFromForm = function (form) {
        if (!form || !form.elements) {
            return {};
        }
        var data = {};
        for (var i = 0; i < form.elements.length; i++) {
            var element = form.elements[i], name_1 = element.name || '';
            // Ignore submit inputs.
            if (!name_1 || element.type == 'submit' || element.tagName == 'BUTTON') {
                return;
            }
            // Get the value.
            if (element.type == 'checkbox') {
                data[name_1] = !!element.checked;
            }
            else if (element.type == 'radio') {
                if (element.checked) {
                    data[name_1] = element.value;
                }
            }
            else {
                data[name_1] = element.value;
            }
        }
        return data;
    };
    /**
     * Returns height of an element.
     *
     * @param {any} element DOM element to measure.
     * @param {boolean} [usePadding] Whether to use padding to calculate the measure.
     * @param {boolean} [useMargin] Whether to use margin to calculate the measure.
     * @param {boolean} [useBorder] Whether to use borders to calculate the measure.
     * @param {boolean} [innerMeasure] If inner measure is needed: padding, margin or borders will be substracted.
     * @return {number} Height in pixels.
     */
    CoreDomUtilsProvider.prototype.getElementHeight = function (element, usePadding, useMargin, useBorder, innerMeasure) {
        return this.getElementMeasure(element, false, usePadding, useMargin, useBorder, innerMeasure);
    };
    /**
     * Returns height or width of an element.
     *
     * @param {any} element DOM element to measure.
     * @param {boolean} [getWidth] Whether to get width or height.
     * @param {boolean} [usePadding] Whether to use padding to calculate the measure.
     * @param {boolean} [useMargin] Whether to use margin to calculate the measure.
     * @param {boolean} [useBorder] Whether to use borders to calculate the measure.
     * @param {boolean} [innerMeasure] If inner measure is needed: padding, margin or borders will be substracted.
     * @return {number} Measure in pixels.
     */
    CoreDomUtilsProvider.prototype.getElementMeasure = function (element, getWidth, usePadding, useMargin, useBorder, innerMeasure) {
        var offsetMeasure = getWidth ? 'offsetWidth' : 'offsetHeight', measureName = getWidth ? 'width' : 'height', clientMeasure = getWidth ? 'clientWidth' : 'clientHeight', priorSide = getWidth ? 'Left' : 'Top', afterSide = getWidth ? 'Right' : 'Bottom';
        var measure = element[offsetMeasure] || element[measureName] || element[clientMeasure] || 0;
        // Measure not correctly taken.
        if (measure <= 0) {
            var style = getComputedStyle(element);
            if (style && style.display == '') {
                element.style.display = 'inline-block';
                measure = element[offsetMeasure] || element[measureName] || element[clientMeasure] || 0;
                element.style.display = '';
            }
        }
        if (usePadding || useMargin || useBorder) {
            var computedStyle = getComputedStyle(element);
            var surround = 0;
            if (usePadding) {
                surround += parseInt(computedStyle['padding' + priorSide], 10) + parseInt(computedStyle['padding' + afterSide], 10);
            }
            if (useMargin) {
                surround += parseInt(computedStyle['margin' + priorSide], 10) + parseInt(computedStyle['margin' + afterSide], 10);
            }
            if (useBorder) {
                surround += parseInt(computedStyle['border' + priorSide], 10) + parseInt(computedStyle['border' + afterSide], 10);
            }
            if (innerMeasure) {
                measure = measure > surround ? measure - surround : 0;
            }
            else {
                measure += surround;
            }
        }
        return measure;
    };
    /**
     * Returns width of an element.
     *
     * @param {any} element DOM element to measure.
     * @param {boolean} [usePadding] Whether to use padding to calculate the measure.
     * @param {boolean} [useMargin] Whether to use margin to calculate the measure.
     * @param {boolean} [useBorder] Whether to use borders to calculate the measure.
     * @param {boolean} [innerMeasure] If inner measure is needed: padding, margin or borders will be substracted.
     * @return {number} Width in pixels.
     */
    CoreDomUtilsProvider.prototype.getElementWidth = function (element, usePadding, useMargin, useBorder, innerMeasure) {
        return this.getElementMeasure(element, true, usePadding, useMargin, useBorder, innerMeasure);
    };
    /**
     * Retrieve the position of a element relative to another element.
     *
     * @param {HTMLElement} container Element to search in.
     * @param {string} [selector] Selector to find the element to gets the position.
     * @param {string} [positionParentClass] Parent Class where to stop calculating the position. Default scroll-content.
     * @return {number[]} positionLeft, positionTop of the element relative to.
     */
    CoreDomUtilsProvider.prototype.getElementXY = function (container, selector, positionParentClass) {
        var element = (selector ? container.querySelector(selector) : container), offsetElement, positionTop = 0, positionLeft = 0;
        if (!positionParentClass) {
            positionParentClass = 'scroll-content';
        }
        if (!element) {
            return null;
        }
        while (element) {
            positionLeft += (element.offsetLeft - element.scrollLeft + element.clientLeft);
            positionTop += (element.offsetTop - element.scrollTop + element.clientTop);
            offsetElement = element.offsetParent;
            element = element.parentElement;
            // Every parent class has to be checked but the position has to be got form offsetParent.
            while (offsetElement != element && element) {
                // If positionParentClass element is reached, stop adding tops.
                if (element.className.indexOf(positionParentClass) != -1) {
                    element = null;
                }
                else {
                    element = element.parentElement;
                }
            }
            // Finally, check again.
            if (element && element.className.indexOf(positionParentClass) != -1) {
                element = null;
            }
        }
        return [positionLeft, positionTop];
    };
    /**
     * Given an error message, return a suitable error title.
     *
     * @param {string} message The error message.
     * @return {string} Title.
     */
    CoreDomUtilsProvider.prototype.getErrorTitle = function (message) {
        if (message == this.translate.instant('core.networkerrormsg') ||
            message == this.translate.instant('core.fileuploader.errormustbeonlinetoupload')) {
            return '<span class="core-icon-with-badge"><i class="icon ion-wifi"></i>\
                <i class="icon ion-alert-circled core-icon-badge"></i></span>';
        }
        return this.textUtils.decodeHTML(this.translate.instant('core.error'));
    };
    /**
     * Retrieve component/directive instance.
     * Please use this function only if you cannot retrieve the instance using parent/child methods: ViewChild (or similar)
     * or Angular's injection.
     *
     * @param {Element} element The root element of the component/directive.
     * @return {any} The instance, undefined if not found.
     */
    CoreDomUtilsProvider.prototype.getInstanceByElement = function (element) {
        var id = element.getAttribute(this.INSTANCE_ID_ATTR_NAME);
        return this.instances[id];
    };
    /**
     * Check if an element is outside of screen (viewport).
     *
     * @param {HTMLElement} scrollEl The element that must be scrolled.
     * @param {HTMLElement} element DOM element to check.
     * @return {boolean} Whether the element is outside of the viewport.
     */
    CoreDomUtilsProvider.prototype.isElementOutsideOfScreen = function (scrollEl, element) {
        var elementRect = element.getBoundingClientRect();
        var elementMidPoint, scrollElRect, scrollTopPos = 0;
        if (!elementRect) {
            return false;
        }
        elementMidPoint = Math.round((elementRect.bottom + elementRect.top) / 2);
        scrollElRect = scrollEl.getBoundingClientRect();
        scrollTopPos = (scrollElRect && scrollElRect.top) || 0;
        return elementMidPoint > window.innerHeight || elementMidPoint < scrollTopPos;
    };
    /**
     * Check if rich text editor is enabled.
     *
     * @return {Promise<boolean>} Promise resolved with boolean: true if enabled, false otherwise.
     */
    CoreDomUtilsProvider.prototype.isRichTextEditorEnabled = function () {
        if (this.isRichTextEditorSupported()) {
            return this.configProvider.get(__WEBPACK_IMPORTED_MODULE_7__core_constants__["a" /* CoreConstants */].SETTINGS_RICH_TEXT_EDITOR, true);
        }
        return Promise.resolve(false);
    };
    /**
     * Check if rich text editor is supported in the platform.
     *
     * @return {boolean} Whether it's supported.
     */
    CoreDomUtilsProvider.prototype.isRichTextEditorSupported = function () {
        // Disabled just for iOS.
        return !this.platform.is('ios');
    };
    /**
     * Move children from one HTMLElement to another.
     *
     * @param {HTMLElement} oldParent The old parent.
     * @param {HTMLElement} newParent The new parent.
     * @return {Node[]} List of moved children.
     */
    CoreDomUtilsProvider.prototype.moveChildren = function (oldParent, newParent) {
        var movedChildren = [];
        while (oldParent.childNodes.length > 0) {
            var child = oldParent.childNodes[0];
            movedChildren.push(child);
            newParent.appendChild(child);
        }
        return movedChildren;
    };
    /**
     * Search and remove a certain element from inside another element.
     *
     * @param {HTMLElement} element DOM element to search in.
     * @param {string} selector Selector to search.
     */
    CoreDomUtilsProvider.prototype.removeElement = function (element, selector) {
        if (element) {
            var selected = element.querySelector(selector);
            if (selected) {
                selected.remove();
            }
        }
    };
    /**
     * Search and remove a certain element from an HTML code.
     *
     * @param {string} html HTML code to change.
     * @param {string} selector Selector to search.
     * @param {boolean} [removeAll] True if it should remove all matches found, false if it should only remove the first one.
     * @return {string} HTML without the element.
     */
    CoreDomUtilsProvider.prototype.removeElementFromHtml = function (html, selector, removeAll) {
        var selected;
        this.element.innerHTML = html;
        if (removeAll) {
            selected = this.element.querySelectorAll(selector);
            for (var i = 0; i < selected.length; i++) {
                selected[i].remove();
            }
        }
        else {
            selected = this.element.querySelector(selector);
            if (selected) {
                selected.remove();
            }
        }
        return this.element.innerHTML;
    };
    /**
     * Remove a component/directive instance using the DOM Element.
     *
     * @param {Element} element The root element of the component/directive.
     */
    CoreDomUtilsProvider.prototype.removeInstanceByElement = function (element) {
        var id = element.getAttribute(this.INSTANCE_ID_ATTR_NAME);
        delete this.instances[id];
    };
    /**
     * Remove a component/directive instance using the ID.
     *
     * @param {string} id The ID to remove.
     */
    CoreDomUtilsProvider.prototype.removeInstanceById = function (id) {
        delete this.instances[id];
    };
    /**
     * Search for certain classes in an element contents and replace them with the specified new values.
     *
     * @param {HTMLElement} element DOM element.
     * @param {any} map Mapping of the classes to replace. Keys must be the value to replace, values must be
     *            the new class name. Example: {'correct': 'core-question-answer-correct'}.
     */
    CoreDomUtilsProvider.prototype.replaceClassesInElement = function (element, map) {
        for (var key in map) {
            var foundElements = element.querySelectorAll('.' + key);
            for (var i = 0; i < foundElements.length; i++) {
                var foundElement = foundElements[i];
                foundElement.className = foundElement.className.replace(key, map[key]);
            }
        }
    };
    /**
     * Given an HTML, search all links and media and tries to restore original sources using the paths object.
     *
     * @param {string} html HTML code.
     * @param {object} paths Object linking URLs in the html code with the real URLs to use.
     * @param {Function} [anchorFn] Function to call with each anchor. Optional.
     * @return {string} Treated HTML code.
     */
    CoreDomUtilsProvider.prototype.restoreSourcesInHtml = function (html, paths, anchorFn) {
        var _this = this;
        var media, anchors;
        this.element.innerHTML = html;
        // Treat elements with src (img, audio, video, ...).
        media = this.element.querySelectorAll('img, video, audio, source, track');
        media.forEach(function (media) {
            var newSrc = paths[_this.textUtils.decodeURIComponent(media.getAttribute('src'))];
            if (typeof newSrc != 'undefined') {
                media.setAttribute('src', newSrc);
            }
            // Treat video posters.
            if (media.tagName == 'VIDEO' && media.getAttribute('poster')) {
                newSrc = paths[_this.textUtils.decodeURIComponent(media.getAttribute('poster'))];
                if (typeof newSrc !== 'undefined') {
                    media.setAttribute('poster', newSrc);
                }
            }
        });
        // Now treat links.
        anchors = this.element.querySelectorAll('a');
        anchors.forEach(function (anchor) {
            var href = _this.textUtils.decodeURIComponent(anchor.getAttribute('href')), newUrl = paths[href];
            if (typeof newUrl != 'undefined') {
                anchor.setAttribute('href', newUrl);
                if (typeof anchorFn == 'function') {
                    anchorFn(anchor, href);
                }
            }
        });
        return this.element.innerHTML;
    };
    /**
     * Scroll to a certain element.
     *
     * @param {Content} content The content that must be scrolled.
     * @param {HTMLElement} element The element to scroll to.
     * @param {string} [scrollParentClass] Parent class where to stop calculating the position. Default scroll-content.
     * @return {boolean} True if the element is found, false otherwise.
     */
    CoreDomUtilsProvider.prototype.scrollToElement = function (content, element, scrollParentClass) {
        var position = this.getElementXY(element, undefined, scrollParentClass);
        if (!position) {
            return false;
        }
        content.scrollTo(position[0], position[1]);
        return true;
    };
    /**
     * Scroll to a certain element using a selector to find it.
     *
     * @param {Content} content The content that must be scrolled.
     * @param {string} selector Selector to find the element to scroll to.
     * @param {string} [scrollParentClass] Parent class where to stop calculating the position. Default scroll-content.
     * @return {boolean} True if the element is found, false otherwise.
     */
    CoreDomUtilsProvider.prototype.scrollToElementBySelector = function (content, selector, scrollParentClass) {
        var position = this.getElementXY(content.getScrollElement(), selector, scrollParentClass);
        if (!position) {
            return false;
        }
        content.scrollTo(position[0], position[1]);
        return true;
    };
    /**
     * Search for an input with error (core-input-error directive) and scrolls to it if found.
     *
     * @param {Content} content The content that must be scrolled.
     * @param [scrollParentClass] Parent class where to stop calculating the position. Default scroll-content.
     * @return {boolean} True if the element is found, false otherwise.
     */
    CoreDomUtilsProvider.prototype.scrollToInputError = function (content, scrollParentClass) {
        if (!content) {
            return false;
        }
        return this.scrollToElementBySelector(content, '.core-input-error', scrollParentClass);
    };
    /**
     * Show an alert modal with a button to close it.
     *
     * @param {string} title Title to show.
     * @param {string} message Message to show.
     * @param {string} [buttonText] Text of the button.
     * @param {number} [autocloseTime] Number of milliseconds to wait to close the modal. If not defined, modal won't be closed.
     * @return {Alert} The alert modal.
     */
    CoreDomUtilsProvider.prototype.showAlert = function (title, message, buttonText, autocloseTime) {
        var alert = this.alertCtrl.create({
            title: title,
            message: this.addFormatTextIfNeeded(message),
            buttons: [buttonText || this.translate.instant('core.ok')]
        });
        alert.present();
        if (autocloseTime > 0) {
            setTimeout(function () {
                alert.dismiss();
            }, autocloseTime);
        }
        return alert;
    };
    /**
     * Show an alert modal with a button to close it, translating the values supplied.
     *
     * @param {string} title Title to show.
     * @param {string} message Message to show.
     * @param {string} [buttonText] Text of the button.
     * @param {number} [autocloseTime] Number of milliseconds to wait to close the modal. If not defined, modal won't be closed.
     * @return {Alert} The alert modal.
     */
    CoreDomUtilsProvider.prototype.showAlertTranslated = function (title, message, buttonText, autocloseTime) {
        title = title ? this.translate.instant(title) : title;
        message = message ? this.translate.instant(message) : message;
        buttonText = buttonText ? this.translate.instant(buttonText) : buttonText;
        return this.showAlert(title, message, buttonText, autocloseTime);
    };
    /**
     * Show a confirm modal.
     *
     * @param {string} message Message to show in the modal body.
     * @param {string} [title] Title of the modal.
     * @param {string} [okText] Text of the OK button.
     * @param {string} [cancelText] Text of the Cancel button.
     * @param {any} [options] More options. See https://ionicframework.com/docs/api/components/alert/AlertController/
     * @return {Promise<void>} Promise resolved if the user confirms and rejected if he cancels.
     */
    CoreDomUtilsProvider.prototype.showConfirm = function (message, title, okText, cancelText, options) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            options = options || {};
            options.message = _this.addFormatTextIfNeeded(message); // Add format-text to handle links.
            options.title = title;
            if (!title) {
                options.cssClass = 'core-nohead';
            }
            options.buttons = [
                {
                    text: cancelText || _this.translate.instant('core.cancel'),
                    role: 'cancel',
                    handler: function () {
                        reject();
                    }
                },
                {
                    text: okText || _this.translate.instant('core.ok'),
                    handler: function () {
                        resolve();
                    }
                }
            ];
            _this.alertCtrl.create(options).present();
        });
    };
    /**
     * Show an alert modal with an error message.
     *
     * @param {any} error Message to show.
     * @param {boolean} [needsTranslate] Whether the error needs to be translated.
     * @param {number} [autocloseTime] Number of milliseconds to wait to close the modal. If not defined, modal won't be closed.
     * @return {Alert} The alert modal.
     */
    CoreDomUtilsProvider.prototype.showErrorModal = function (error, needsTranslate, autocloseTime) {
        if (typeof error == 'object') {
            // We received an object instead of a string. Search for common properties.
            if (typeof error.content != 'undefined') {
                error = error.content;
            }
            else if (typeof error.body != 'undefined') {
                error = error.body;
            }
            else if (typeof error.message != 'undefined') {
                error = error.message;
            }
            else if (typeof error.error != 'undefined') {
                error = error.error;
            }
            else {
                // No common properties found, just stringify it.
                error = JSON.stringify(error);
            }
            // Try to remove tokens from the contents.
            var matches = error.match(/token"?[=|:]"?(\w*)/, '');
            if (matches && matches[1]) {
                error = error.replace(new RegExp(matches[1], 'g'), 'secret');
            }
        }
        var message = this.textUtils.decodeHTML(needsTranslate ? this.translate.instant(error) : error);
        return this.showAlert(this.getErrorTitle(message), message, undefined, autocloseTime);
    };
    /**
     * Show an alert modal with an error message. It uses a default message if error is not a string.
     *
     * @param {any} error Message to show.
     * @param {any} [defaultError] Message to show if the error is not a string.
     * @param {boolean} [needsTranslate] Whether the error needs to be translated.
     * @param {number} [autocloseTime] Number of milliseconds to wait to close the modal. If not defined, modal won't be closed.
     * @return {Alert} The alert modal.
     */
    CoreDomUtilsProvider.prototype.showErrorModalDefault = function (error, defaultError, needsTranslate, autocloseTime) {
        if (error != __WEBPACK_IMPORTED_MODULE_7__core_constants__["a" /* CoreConstants */].DONT_SHOW_ERROR) {
            if (error && typeof error != 'string') {
                error = error.message || error.error;
            }
            error = typeof error == 'string' ? error : defaultError;
            return this.showErrorModal(error, needsTranslate, autocloseTime);
        }
    };
    /**
     * Show an alert modal with the first warning error message. It uses a default message if error is not a string.
     *
     * @param {any} warnings Warnings returned.
     * @param {any} [defaultError] Message to show if the error is not a string.
     * @param {boolean} [needsTranslate] Whether the error needs to be translated.
     * @param {number} [autocloseTime] Number of milliseconds to wait to close the modal. If not defined, modal won't be closed.
     * @return {Alert} The alert modal.
     */
    CoreDomUtilsProvider.prototype.showErrorModalFirstWarning = function (warnings, defaultError, needsTranslate, autocloseTime) {
        var error = warnings && warnings.length && warnings[0].message;
        return this.showErrorModalDefault(error, defaultError, needsTranslate, autocloseTime);
    };
    /**
     * Displays a loading modal window.
     *
     * @param {string} [text] The text of the modal window. Default: core.loading.
     * @param {boolean} [needsTranslate] Whether the 'text' needs to be translated.
     * @return {Loading} Loading modal instance.
     * @description
     * Usage:
     *     let modal = domUtils.showModalLoading(myText);
     *     ...
     *     modal.dismiss();
     */
    CoreDomUtilsProvider.prototype.showModalLoading = function (text, needsTranslate) {
        if (!text) {
            text = this.translate.instant('core.loading');
        }
        else if (needsTranslate) {
            text = this.translate.instant(text);
        }
        var loader = this.loadingCtrl.create({
            content: text
        });
        loader.present();
        return loader;
    };
    /**
     * Show a prompt modal to input some data.
     *
     * @param {string} message Modal message.
     * @param {string} [title] Modal title.
     * @param {string} [placeholder] Placeholder of the input element. By default, "Password".
     * @param {string} [type] Type of the input element. By default, password.
     * @return {Promise<any>} Promise resolved with the input data if the user clicks OK, rejected if cancels.
     */
    CoreDomUtilsProvider.prototype.showPrompt = function (message, title, placeholder, type) {
        var _this = this;
        if (type === void 0) { type = 'password'; }
        return new Promise(function (resolve, reject) {
            _this.alertCtrl.create({
                message: _this.addFormatTextIfNeeded(message),
                title: title,
                inputs: [
                    {
                        name: 'promptinput',
                        placeholder: placeholder || _this.translate.instant('core.login.password'),
                        type: type
                    }
                ],
                buttons: [
                    {
                        text: _this.translate.instant('core.cancel'),
                        role: 'cancel',
                        handler: function () {
                            reject();
                        }
                    },
                    {
                        text: _this.translate.instant('core.ok'),
                        handler: function (data) {
                            resolve(data.promptinput);
                        }
                    }
                ]
            }).present();
        });
    };
    /**
     * Displays an autodimissable toast modal window.
     *
     * @param {string} text The text of the toast.
     * @param {boolean} [needsTranslate] Whether the 'text' needs to be translated.
     * @param {number} [duration=2000] Duration in ms of the dimissable toast.
     * @param {string} [cssClass=""] Class to add to the toast.
     * @return {Toast} Toast instance.
     */
    CoreDomUtilsProvider.prototype.showToast = function (text, needsTranslate, duration, cssClass) {
        if (duration === void 0) { duration = 2000; }
        if (cssClass === void 0) { cssClass = ''; }
        if (needsTranslate) {
            text = this.translate.instant(text);
        }
        var loader = this.toastCtrl.create({
            message: text,
            duration: duration,
            position: 'bottom',
            cssClass: cssClass,
            dismissOnPageChange: true
        });
        loader.present();
        return loader;
    };
    /**
     * Stores a component/directive instance.
     *
     * @param {Element} element The root element of the component/directive.
     * @param {any} instance The instance to store.
     * @return {string} ID to identify the instance.
     */
    CoreDomUtilsProvider.prototype.storeInstanceByElement = function (element, instance) {
        var id = String(this.lastInstanceId++);
        element.setAttribute(this.INSTANCE_ID_ATTR_NAME, id);
        this.instances[id] = instance;
        return id;
    };
    /**
     * Check if an element supports input via keyboard.
     *
     * @param {any} el HTML element to check.
     * @return {boolean} Whether it supports input using keyboard.
     */
    CoreDomUtilsProvider.prototype.supportsInputKeyboard = function (el) {
        return el && !el.disabled && (el.tagName.toLowerCase() == 'textarea' ||
            (el.tagName.toLowerCase() == 'input' && this.INPUT_SUPPORT_KEYBOARD.indexOf(el.type) != -1));
    };
    /**
     * Converts HTML formatted text to DOM element.
     * @param  {string}      text HTML text.
     * @return {HTMLCollection}      Same text converted to HTMLCollection.
     */
    CoreDomUtilsProvider.prototype.toDom = function (text) {
        var element = document.createElement('div');
        element.innerHTML = text;
        return element.children;
    };
    /**
     * View an image in a new page or modal.
     *
     * @param {string} image URL of the image.
     * @param {string} title Title of the page or modal.
     * @param {string} [component] Component to link the image to if needed.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     */
    CoreDomUtilsProvider.prototype.viewImage = function (image, title, component, componentId) {
        if (image) {
            var params = {
                title: title,
                image: image,
                component: component,
                componentId: componentId
            }, modal = this.modalCtrl.create('CoreViewerImagePage', params);
            modal.present();
        }
    };
    /**
     * Wrap an HTMLElement with another element.
     *
     * @param {HTMLElement} el The element to wrap.
     * @param {HTMLElement} wrapper Wrapper.
     */
    CoreDomUtilsProvider.prototype.wrapElement = function (el, wrapper) {
        // Insert the wrapper before the element.
        el.parentNode.insertBefore(wrapper, el);
        // Now move the element into the wrapper.
        wrapper.appendChild(el);
    };
    CoreDomUtilsProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["i" /* LoadingController */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["r" /* ToastController */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["b" /* AlertController */], __WEBPACK_IMPORTED_MODULE_3__text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_4__app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */], __WEBPACK_IMPORTED_MODULE_5__config__["a" /* CoreConfigProvider */], __WEBPACK_IMPORTED_MODULE_6__url__["a" /* CoreUrlUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["j" /* ModalController */]])
    ], CoreDomUtilsProvider);
    return CoreDomUtilsProvider;
}());

//# sourceMappingURL=dom.js.map

/***/ }),
/* 11 */,
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreAppProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_keyboard__ = __webpack_require__(226);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_network__ = __webpack_require__(103);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__db__ = __webpack_require__(227);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__logger__ = __webpack_require__(5);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






/**
 * Factory to provide some global functionalities, like access to the global app database.
 * @description
 * Each service or component should be responsible of creating their own database tables. Example:
 *
 * constructor(appProvider: CoreAppProvider) {
 *     this.appDB = appProvider.getDB();
 *     this.appDB.createTableFromSchema(this.tableSchema);
 * }
 */
var CoreAppProvider = /** @class */ (function () {
    function CoreAppProvider(dbProvider, platform, keyboard, appCtrl, network, logger) {
        var _this = this;
        this.platform = platform;
        this.keyboard = keyboard;
        this.appCtrl = appCtrl;
        this.network = network;
        this.DBNAME = 'MoodleMobile';
        this.isKeyboardShown = false;
        this.logger = logger.getInstance('CoreAppProvider');
        this.db = dbProvider.getDB(this.DBNAME);
        this.keyboard.onKeyboardShow().subscribe(function (data) {
            _this.isKeyboardShown = true;
        });
        this.keyboard.onKeyboardHide().subscribe(function (data) {
            _this.isKeyboardShown = false;
        });
    }
    /**
     * Check if the browser supports mediaDevices.getUserMedia.
     *
     * @return {boolean} Whether the function is supported.
     */
    CoreAppProvider.prototype.canGetUserMedia = function () {
        return !!(navigator && navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
    };
    /**
     * Check if the browser supports MediaRecorder.
     *
     * @return {boolean} Whether the function is supported.
     */
    CoreAppProvider.prototype.canRecordMedia = function () {
        return !!window.MediaRecorder;
    };
    /**
     * Closes the keyboard.
     */
    CoreAppProvider.prototype.closeKeyboard = function () {
        if (this.isMobile()) {
            this.keyboard.close();
        }
    };
    /**
     * Get the application global database.
     *
     * @return {SQLiteDB} App's DB.
     */
    CoreAppProvider.prototype.getDB = function () {
        return this.db;
    };
    /**
     * Get the app's root NavController.
     *
     * @return {NavController} Root NavController.
     */
    CoreAppProvider.prototype.getRootNavController = function () {
        // Function getRootNav is deprecated. Get the first root nav, there should always be one.
        return this.appCtrl.getRootNavs()[0];
    };
    /**
     * Checks if the app is running in a desktop environment (not browser).
     *
     * @return {boolean} Whether the app is running in a desktop environment (not browser).
     */
    CoreAppProvider.prototype.isDesktop = function () {
        var process = window.process;
        return !!(process && process.versions && typeof process.versions.electron != 'undefined');
    };
    /**
     * Check if the keyboard is visible.
     *
     * @return {boolean} Whether keyboard is visible.
     */
    CoreAppProvider.prototype.isKeyboardVisible = function () {
        return this.isKeyboardShown;
    };
    /**
     * Check if the app is running in a Linux environment.
     *
     * @return {boolean} Whether it's running in a Linux environment.
     */
    CoreAppProvider.prototype.isLinux = function () {
        if (!this.isDesktop()) {
            return false;
        }
        try {
            return __webpack_require__(151).platform().indexOf('linux') === 0;
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Check if the app is running in a Mac OS environment.
     *
     * @return {boolean} Whether it's running in a Mac OS environment.
     */
    CoreAppProvider.prototype.isMac = function () {
        if (!this.isDesktop()) {
            return false;
        }
        try {
            return __webpack_require__(151).platform().indexOf('darwin') === 0;
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Checks if the app is running in a mobile or tablet device (Cordova).
     *
     * @return {boolean} Whether the app is running in a mobile or tablet device.
     */
    CoreAppProvider.prototype.isMobile = function () {
        return this.platform.is('cordova');
    };
    /**
     * Checks if the current window is wider than a mobile.
     *
     * @return {boolean} Whether the app the current window is wider than a mobile.
     */
    CoreAppProvider.prototype.isWide = function () {
        return this.platform.width() > 768;
    };
    /**
     * Returns whether we are online.
     *
     * @return {boolean} Whether the app is online.
     */
    CoreAppProvider.prototype.isOnline = function () {
        var online = this.network.type !== null && this.network.type != Connection.NONE && this.network.type != Connection.UNKNOWN;
        // Double check we are not online because we cannot rely 100% in Cordova APIs. Also, check it in browser.
        if (!online && navigator.onLine) {
            online = true;
        }
        return online;
    };
    /**
     * Check if device uses a limited connection.
     *
     * @return {boolean} Whether the device uses a limited connection.
     */
    CoreAppProvider.prototype.isNetworkAccessLimited = function () {
        var type = this.network.type;
        if (type === null) {
            // Plugin not defined, probably in browser.
            return false;
        }
        var limited = [Connection.CELL_2G, Connection.CELL_3G, Connection.CELL_4G, Connection.CELL];
        return limited.indexOf(type) > -1;
    };
    /**
     * Check if the app is running in a Windows environment.
     *
     * @return {boolean} Whether it's running in a Windows environment.
     */
    CoreAppProvider.prototype.isWindows = function () {
        if (!this.isDesktop()) {
            return false;
        }
        try {
            return __webpack_require__(151).platform().indexOf('win') === 0;
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Open the keyboard.
     */
    CoreAppProvider.prototype.openKeyboard = function () {
        // Open keyboard is not supported in desktop and in iOS.
        if (this.isMobile() && !this.platform.is('ios')) {
            this.keyboard.show();
        }
    };
    /**
     * Start an SSO authentication process.
     * Please notice that this function should be called when the app receives the new token from the browser,
     * NOT when the browser is opened.
     */
    CoreAppProvider.prototype.startSSOAuthentication = function () {
        var _this = this;
        var cancelTimeout, resolvePromise;
        this.ssoAuthenticationPromise = new Promise(function (resolve, reject) {
            resolvePromise = resolve;
            // Resolve it automatically after 10 seconds (it should never take that long).
            cancelTimeout = setTimeout(function () {
                _this.finishSSOAuthentication();
            }, 10000);
        });
        // Store the resolve function in the promise itself.
        this.ssoAuthenticationPromise.resolve = resolvePromise;
        // If the promise is resolved because finishSSOAuthentication is called, stop the cancel promise.
        this.ssoAuthenticationPromise.then(function () {
            clearTimeout(cancelTimeout);
        });
    };
    /**
     * Finish an SSO authentication process.
     */
    CoreAppProvider.prototype.finishSSOAuthentication = function () {
        if (this.ssoAuthenticationPromise) {
            this.ssoAuthenticationPromise.resolve && this.ssoAuthenticationPromise.resolve();
            this.ssoAuthenticationPromise = undefined;
        }
    };
    /**
     * Check if there's an ongoing SSO authentication process.
     *
     * @return {boolean} Whether there's a SSO authentication ongoing.
     */
    CoreAppProvider.prototype.isSSOAuthenticationOngoing = function () {
        return !!this.ssoAuthenticationPromise;
    };
    /**
     * Returns a promise that will be resolved once SSO authentication finishes.
     *
     * @return {Promise<any>} Promise resolved once SSO authentication finishes.
     */
    CoreAppProvider.prototype.waitForSSOAuthentication = function () {
        return this.ssoAuthenticationPromise || Promise.resolve();
    };
    /**
     * Retrieve redirect data.
     *
     * @return {CoreRedirectData} Object with siteid, state, params and timemodified.
     */
    CoreAppProvider.prototype.getRedirect = function () {
        if (localStorage && localStorage.getItem) {
            try {
                var data = {
                    siteId: localStorage.getItem('mmCoreRedirectSiteId'),
                    page: localStorage.getItem('mmCoreRedirectState'),
                    params: localStorage.getItem('mmCoreRedirectParams'),
                    timemodified: parseInt(localStorage.getItem('mmCoreRedirectTime'), 10)
                };
                if (data.params) {
                    data.params = JSON.parse(data.params);
                }
                return data;
            }
            catch (ex) {
                this.logger.error('Error loading redirect data:', ex);
            }
        }
        return {};
    };
    /**
     * Store redirect params.
     *
     * @param {string} siteId Site ID.
     * @param {string} page Page to go.
     * @param {any} params Page params.
     */
    CoreAppProvider.prototype.storeRedirect = function (siteId, page, params) {
        if (localStorage && localStorage.setItem) {
            try {
                localStorage.setItem('mmCoreRedirectSiteId', siteId);
                localStorage.setItem('mmCoreRedirectState', page);
                localStorage.setItem('mmCoreRedirectParams', JSON.stringify(params));
                localStorage.setItem('mmCoreRedirectTime', String(Date.now()));
            }
            catch (ex) {
                // Ignore errors.
            }
        }
    };
    CoreAppProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__db__["a" /* CoreDbProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */], __WEBPACK_IMPORTED_MODULE_2__ionic_native_keyboard__["a" /* Keyboard */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["c" /* App */],
            __WEBPACK_IMPORTED_MODULE_3__ionic_native_network__["a" /* Network */], __WEBPACK_IMPORTED_MODULE_5__logger__["a" /* CoreLoggerProvider */]])
    ], CoreAppProvider);
    return CoreAppProvider;
}());

//# sourceMappingURL=app.js.map

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreTextUtilsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lang__ = __webpack_require__(96);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/*
 * "Utils" service with helper functions for text.
*/
var CoreTextUtilsProvider = /** @class */ (function () {
    function CoreTextUtilsProvider(translate, langProvider, modalCtrl) {
        this.translate = translate;
        this.langProvider = langProvider;
        this.modalCtrl = modalCtrl;
        this.element = document.createElement('div'); // Fake element to use in some functions, to prevent creating it each time.
    }
    /**
     * Given a list of sentences, build a message with all of them wrapped in <p>.
     *
     * @param {string[]} messages Messages to show.
     * @return {string} Message with all the messages.
     */
    CoreTextUtilsProvider.prototype.buildMessage = function (messages) {
        var result = '';
        messages.forEach(function (message) {
            if (message) {
                result += "<p>" + message + "</p>";
            }
        });
        return result;
    };
    /**
     * Convert size in bytes into human readable format
     *
     * @param {number} bytes Number of bytes to convert.
     * @param {number} [precision=2] Number of digits after the decimal separator.
     * @return {string} Size in human readable format.
     */
    CoreTextUtilsProvider.prototype.bytesToSize = function (bytes, precision) {
        if (precision === void 0) { precision = 2; }
        if (typeof bytes == 'undefined' || bytes < 0) {
            return this.translate.instant('core.notapplicable');
        }
        if (precision < 0) {
            precision = 2;
        }
        var keys = ['core.sizeb', 'core.sizekb', 'core.sizemb', 'core.sizegb', 'core.sizetb'], units = this.translate.instant(keys);
        var pos = 0;
        if (bytes >= 1024) {
            while (bytes >= 1024) {
                pos++;
                bytes = bytes / 1024;
            }
            // Round to "precision" decimals if needed.
            bytes = Number(Math.round(parseFloat(bytes + 'e+' + precision)) + 'e-' + precision);
        }
        return this.translate.instant('core.humanreadablesize', { size: bytes, unit: units[keys[pos]] });
    };
    /**
     * Clean HTML tags.
     *
     * @param {string} text The text to be cleaned.
     * @param {boolean} [singleLine] True if new lines should be removed (all the text in a single line).
     * @return {string} Clean text.
     */
    CoreTextUtilsProvider.prototype.cleanTags = function (text, singleLine) {
        if (!text) {
            return '';
        }
        // First, we use a regexpr.
        text = text.replace(/(<([^>]+)>)/ig, '');
        // Then, we rely on the browser. We need to wrap the text to be sure is HTML.
        this.element.innerHTML = text;
        text = this.element.textContent;
        // Recover or remove new lines.
        text = this.replaceNewLines(text, singleLine ? ' ' : '<br>');
        return text;
    };
    /**
     * Concatenate two paths, adding a slash between them if needed.
     *
     * @param {string} leftPath Left path.
     * @param {string} rightPath Right path.
     * @return {string} Concatenated path.
     */
    CoreTextUtilsProvider.prototype.concatenatePaths = function (leftPath, rightPath) {
        if (!leftPath) {
            return rightPath;
        }
        else if (!rightPath) {
            return leftPath;
        }
        var lastCharLeft = leftPath.slice(-1), firstCharRight = rightPath.charAt(0);
        if (lastCharLeft === '/' && firstCharRight === '/') {
            return leftPath + rightPath.substr(1);
        }
        else if (lastCharLeft !== '/' && firstCharRight !== '/') {
            return leftPath + '/' + rightPath;
        }
        else {
            return leftPath + rightPath;
        }
    };
    /**
     * Count words in a text.
     *
     * @param {string} text Text to count.
     * @return {number} Number of words.
     */
    CoreTextUtilsProvider.prototype.countWords = function (text) {
        // Clean HTML scripts and tags.
        text = text.replace(/<script[^>]*>([\S\s]*?)<\/script>/gmi, '');
        text = text.replace(/<\/?(?!\!)[^>]*>/gi, '');
        // Decode HTML entities.
        text = this.decodeHTMLEntities(text);
        // Replace underscores (which are classed as word characters) with spaces.
        text = text.replace(/_/gi, ' ');
        // This RegEx will detect any word change including Unicode chars. Some languages without spaces won't be counted fine.
        return text.match(/\S+/gi).length;
    };
    /**
     * Decode an escaped HTML text. This implementation is based on PHP's htmlspecialchars_decode.
     *
     * @param {string|number} text Text to decode.
     * @return {string} Decoded text.
     */
    CoreTextUtilsProvider.prototype.decodeHTML = function (text) {
        if (typeof text == 'undefined' || text === null || (typeof text == 'number' && isNaN(text))) {
            return '';
        }
        else if (typeof text != 'string') {
            return '' + text;
        }
        return text
            .replace(/&amp;/g, '&')
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&quot;/g, '"')
            .replace(/&#039;/g, '')
            .replace(/&nbsp;/g, ' ');
    };
    /**
     * Decode HTML entities in a text. Equivalent to PHP html_entity_decode.
     *
     * @param {string} text Text to decode.
     * @return {string} Decoded text.
     */
    CoreTextUtilsProvider.prototype.decodeHTMLEntities = function (text) {
        if (text) {
            this.element.innerHTML = text;
            text = this.element.textContent;
            this.element.textContent = '';
        }
        return text;
    };
    /**
     * Same as Javascript's decodeURI, but if an exception is thrown it will return the original URI.
     *
     * @param {string} uri URI to decode.
     * @return {string} Decoded URI, or original URI if an exception is thrown.
     */
    CoreTextUtilsProvider.prototype.decodeURI = function (uri) {
        try {
            return decodeURI(uri);
        }
        catch (ex) {
            // Error, use the original URI.
        }
        return uri;
    };
    /**
     * Same as Javascript's decodeURIComponent, but if an exception is thrown it will return the original URI.
     *
     * @param {string} uri URI to decode.
     * @return {string} Decoded URI, or original URI if an exception is thrown.
     */
    CoreTextUtilsProvider.prototype.decodeURIComponent = function (uri) {
        try {
            return decodeURIComponent(uri);
        }
        catch (ex) {
            // Error, use the original URI.
        }
        return uri;
    };
    /**
     * Escapes some characters in a string to be used as a regular expression.
     *
     * @param {string} text Text to escape.
     * @return {string} Escaped text.
     */
    CoreTextUtilsProvider.prototype.escapeForRegex = function (text) {
        if (!text) {
            return '';
        }
        return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
    };
    /**
     * Escape an HTML text. This implementation is based on PHP's htmlspecialchars.
     *
     * @param {string|number} text Text to escape.
     * @return {string} Escaped text.
     */
    CoreTextUtilsProvider.prototype.escapeHTML = function (text) {
        if (typeof text == 'undefined' || text === null || (typeof text == 'number' && isNaN(text))) {
            return '';
        }
        else if (typeof text != 'string') {
            return '' + text;
        }
        return text
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');
    };
    /**
     * Shows a text on a new page.
     *
     * @param {string} title Title of the new state.
     * @param {string} text Content of the text to be expanded.
     * @param {string} [component] Component to link the embedded files to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     */
    CoreTextUtilsProvider.prototype.expandText = function (title, text, component, componentId) {
        if (text.length > 0) {
            var params = {
                title: title,
                content: text,
                component: component,
                componentId: componentId
            };
            // Open a modal with the contents.
            params.isModal = true;
            var modal = this.modalCtrl.create('CoreViewerTextPage', params);
            modal.present();
        }
    };
    /**
     * Formats a text, in HTML replacing new lines by correct html new lines.
     *
     * @param {string} text Text to format.
     * @return {string} Formatted text.
     */
    CoreTextUtilsProvider.prototype.formatHtmlLines = function (text) {
        var hasHTMLTags = this.hasHTMLTags(text);
        if (text.indexOf('<p>') == -1) {
            // Wrap the text in <p> tags.
            text = '<p>' + text + '</p>';
        }
        if (!hasHTMLTags) {
            // The text doesn't have HTML, replace new lines for <br>.
            return this.replaceNewLines(text, '<br>');
        }
        return text;
    };
    /**
     * Formats a text, treating multilang tags and cleaning HTML if needed.
     *
     * @param {string} text Text to format.
     * @param {boolean} [clean] Whether HTML tags should be removed.
     * @param {boolean} [singleLine] Whether new lines should be removed. Only valid if clean is true.
     * @param {number} [shortenLength] Number of characters to shorten the text.
     * @return {Promise<string>} Promise resolved with the formatted text.
     */
    CoreTextUtilsProvider.prototype.formatText = function (text, clean, singleLine, shortenLength) {
        var _this = this;
        return this.treatMultilangTags(text).then(function (formatted) {
            if (clean) {
                formatted = _this.cleanTags(formatted, singleLine);
            }
            if (shortenLength > 0) {
                formatted = _this.shortenText(formatted, shortenLength);
            }
            return formatted;
        });
    };
    /**
     * Get the pluginfile URL to replace @@PLUGINFILE@@ wildcards.
     *
     * @param {any[]} files Files to extract the URL from. They need to have the URL in a 'url' or 'fileurl' attribute.
     * @return {string} Pluginfile URL, undefined if no files found.
     */
    CoreTextUtilsProvider.prototype.getTextPluginfileUrl = function (files) {
        if (files && files.length) {
            var fileURL = files[0].url || files[0].fileurl;
            // Remove text after last slash (encoded or not).
            return fileURL.substr(0, Math.max(fileURL.lastIndexOf('/'), fileURL.lastIndexOf('%2F')));
        }
        return undefined;
    };
    /**
     * Check if a text contains HTML tags.
     *
     * @param {string} text Text to check.
     * @return {boolean} Whether it has HTML tags.
     */
    CoreTextUtilsProvider.prototype.hasHTMLTags = function (text) {
        return /<[a-z][\s\S]*>/i.test(text);
    };
    /**
     * Check if a text contains Unicode long chars.
     * Using as threshold Hex value D800
     *
     * @param {string} text Text to check.
     * @return {boolean} True if has Unicode chars, false otherwise.
     */
    CoreTextUtilsProvider.prototype.hasUnicode = function (text) {
        for (var x = 0; x < text.length; x++) {
            if (text.charCodeAt(x) > 55295) {
                return true;
            }
        }
        return false;
    };
    /**
     * Check if an object has any long Unicode char.
     *
     * @param {object} data Object to be checked.
     * @return {boolean} If the data has any long Unicode char on it.
     */
    CoreTextUtilsProvider.prototype.hasUnicodeData = function (data) {
        for (var el in data) {
            if (typeof data[el] == 'object') {
                if (this.hasUnicodeData(data[el])) {
                    return true;
                }
            }
            else if (typeof data[el] == 'string' && this.hasUnicode(data[el])) {
                return true;
            }
        }
        return false;
    };
    /**
     * Same as Javascript's JSON.parse, but it will handle errors.
     *
     * @param {string} json JSON text.
     * @param {any} [defaultValue] Default value t oreturn if the parse fails. Defaults to the original value.
     * @param {Function} [logErrorFn] An error to call with the exception to log the error. If not supplied, no error.
     * @return {any} JSON parsed as object or what it gets.
     */
    CoreTextUtilsProvider.prototype.parseJSON = function (json, defaultValue, logErrorFn) {
        try {
            return JSON.parse(json);
        }
        catch (ex) {
            // Error, log the error if needed.
            if (logErrorFn) {
                logErrorFn(ex);
            }
        }
        // Error parsing, return the default value or the original value.
        return typeof defaultValue != 'undefined' ? defaultValue : json;
    };
    /**
     * Replace all characters that cause problems with files in Android and iOS.
     *
     * @param {string} text Text to treat.
     * @return {string} Treated text.
     */
    CoreTextUtilsProvider.prototype.removeSpecialCharactersForFiles = function (text) {
        return text.replace(/[#:\/\?\\]+/g, '_');
    };
    /**
     * Replace all the new lines on a certain text.
     *
     * @param {string} text The text to be treated.
     * @param {string} newValue Text to use instead of new lines.
     * @return {string} Treated text.
     */
    CoreTextUtilsProvider.prototype.replaceNewLines = function (text, newValue) {
        return text.replace(/(?:\r\n|\r|\n)/g, newValue);
    };
    /**
     * Replace @@PLUGINFILE@@ wildcards with the real URL in a text.
     *
     * @param {string} Text to treat.
     * @param {any[]} files Files to extract the pluginfile URL from. They need to have the URL in a url or fileurl attribute.
     * @return {string} Treated text.
     */
    CoreTextUtilsProvider.prototype.replacePluginfileUrls = function (text, files) {
        if (text) {
            var fileURL = this.getTextPluginfileUrl(files);
            if (fileURL) {
                return text.replace(/@@PLUGINFILE@@/g, fileURL);
            }
        }
        return text;
    };
    /**
     * Replace pluginfile URLs with @@PLUGINFILE@@ wildcards.
     *
     * @param {string} text Text to treat.
     * @param {any[]} files Files to extract the pluginfile URL from. They need to have the URL in a url or fileurl attribute.
     * @return {string} Treated text.
     */
    CoreTextUtilsProvider.prototype.restorePluginfileUrls = function (text, files) {
        if (text) {
            var fileURL = this.getTextPluginfileUrl(files);
            if (fileURL) {
                return text.replace(new RegExp(this.escapeForRegex(fileURL), 'g'), '@@PLUGINFILE@@');
            }
        }
        return text;
    };
    /**
     * Rounds a number to use a certain amout of decimals or less.
     * Difference between this function and float's toFixed:
     * 7.toFixed(2) -> 7.00
     * roundToDecimals(7, 2) -> 7
     *
     * @param {number} num Number to round.
     * @param {number} [decimals=2] Number of decimals. By default, 2.
     * @return {number} Rounded number.
     */
    CoreTextUtilsProvider.prototype.roundToDecimals = function (num, decimals) {
        if (decimals === void 0) { decimals = 2; }
        var multiplier = Math.pow(10, decimals);
        return Math.round(num * multiplier) / multiplier;
    };
    /**
     * Add quotes to HTML characters.
     *
     * Returns text with HTML characters (like "<", ">", etc.) properly quoted.
     * Based on Moodle's s() function.
     *
     * @param {string} text Text to treat.
     * @return {string} Treated text.
     */
    CoreTextUtilsProvider.prototype.s = function (text) {
        if (!text) {
            return '';
        }
        return this.escapeHTML(text).replace(/&amp;#(\d+|x[0-9a-f]+);/i, '&#$1;');
    };
    /**
     * Shortens a text to length and adds an ellipsis.
     *
     * @param {string} text The text to be shortened.
     * @param {number} length The desired length.
     * @return {string} Shortened text.
     */
    CoreTextUtilsProvider.prototype.shortenText = function (text, length) {
        if (text.length > length) {
            text = text.substr(0, length);
            // Now, truncate at the last word boundary (if exists).
            var lastWordPos = text.lastIndexOf(' ');
            if (lastWordPos > 0) {
                text = text.substr(0, lastWordPos);
            }
            text += '&hellip;';
        }
        return text;
    };
    /**
     * Strip Unicode long char of a given text.
     * Using as threshold Hex value D800
     *
     * @param {string} text Text to check.
     * @return {string} Without the Unicode chars.
     */
    CoreTextUtilsProvider.prototype.stripUnicode = function (text) {
        var stripped = '';
        for (var x = 0; x < text.length; x++) {
            if (text.charCodeAt(x) <= 55295) {
                stripped += text.charAt(x);
            }
        }
        return stripped;
    };
    /**
     * Treat the multilang tags from a HTML code, leaving only the current language.
     *
     * @param {string} text The text to be treated.
     * @return {Promise<string>} Promise resolved with the formatted text.
     */
    CoreTextUtilsProvider.prototype.treatMultilangTags = function (text) {
        if (!text) {
            return Promise.resolve('');
        }
        return this.langProvider.getCurrentLanguage().then(function (language) {
            // Match the current language.
            var anyLangRegEx = /<(?:lang|span)[^>]+lang="[a-zA-Z0-9_-]+"[^>]*>(.*?)<\/(?:lang|span)>/g;
            var currentLangRegEx = new RegExp('<(?:lang|span)[^>]+lang="' + language + '"[^>]*>(.*?)<\/(?:lang|span)>', 'g');
            if (!text.match(currentLangRegEx)) {
                // Current lang not found. Try to find the first language.
                var matches = text.match(anyLangRegEx);
                if (matches && matches[0]) {
                    language = matches[0].match(/lang="([a-zA-Z0-9_-]+)"/)[1];
                    currentLangRegEx = new RegExp('<(?:lang|span)[^>]+lang="' + language + '"[^>]*>(.*?)<\/(?:lang|span)>', 'g');
                }
                else {
                    // No multi-lang tag found, stop.
                    return text;
                }
            }
            // Extract contents of current language.
            text = text.replace(currentLangRegEx, '$1');
            // Delete the rest of languages
            text = text.replace(anyLangRegEx, '');
            return text;
        });
    };
    /**
     * If a number has only 1 digit, add a leading zero to it.
     *
     * @param {string|number} num Number to convert.
     * @return {string} Number with leading zeros.
     */
    CoreTextUtilsProvider.prototype.twoDigits = function (num) {
        if (num < 10) {
            return '0' + num;
        }
        else {
            return '' + num; // Convert to string for coherence.
        }
    };
    /**
     * Make a string's first character uppercase.
     *
     * @param {string} text Text to treat.
     * @return {string} Treated text.
     */
    CoreTextUtilsProvider.prototype.ucFirst = function (text) {
        return text.charAt(0).toUpperCase() + text.slice(1);
    };
    CoreTextUtilsProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_3__lang__["a" /* CoreLangProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["j" /* ModalController */]])
    ], CoreTextUtilsProvider);
    return CoreTextUtilsProvider;
}());

//# sourceMappingURL=text.js.map

/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_events__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_time__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__constants__ = __webpack_require__(22);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








/**
 * Service that provides some features regarding a course.
 */
var CoreCourseProvider = /** @class */ (function () {
    function CoreCourseProvider(logger, sitesProvider, eventsProvider, utils, timeUtils, translate) {
        this.sitesProvider = sitesProvider;
        this.eventsProvider = eventsProvider;
        this.utils = utils;
        this.timeUtils = timeUtils;
        this.translate = translate;
        this.ROOT_CACHE_KEY = 'mmCourse:';
        // Variables for database.
        this.COURSE_STATUS_TABLE = 'course_status';
        this.courseStatusTableSchema = {
            name: this.COURSE_STATUS_TABLE,
            columns: [
                {
                    name: 'id',
                    type: 'INTEGER',
                    primaryKey: true
                },
                {
                    name: 'status',
                    type: 'TEXT',
                    notNull: true
                },
                {
                    name: 'previous',
                    type: 'TEXT'
                },
                {
                    name: 'updated',
                    type: 'INTEGER'
                },
                {
                    name: 'downloadTime',
                    type: 'INTEGER'
                },
                {
                    name: 'previousDownloadTime',
                    type: 'INTEGER'
                }
            ]
        };
        this.CORE_MODULES = [
            'assign', 'assignment', 'book', 'chat', 'choice', 'data', 'database', 'date', 'external-tool',
            'feedback', 'file', 'folder', 'forum', 'glossary', 'ims', 'imscp', 'label', 'lesson', 'lti', 'page', 'quiz',
            'resource', 'scorm', 'survey', 'url', 'wiki', 'workshop'
        ];
        this.logger = logger.getInstance('CoreCourseProvider');
        this.sitesProvider.createTableFromSchema(this.courseStatusTableSchema);
    }
    /**
     * Check if module completion could have changed. If it could have, trigger event. This function must be used,
     * for example, after calling a "module_view" WS since it can change the module completion.
     *
     * @param {number} courseId Course ID.
     * @param {any} completion Completion status of the module.
     */
    CoreCourseProvider.prototype.checkModuleCompletion = function (courseId, completion) {
        var _this = this;
        if (completion && completion.tracking === 2 && completion.state === 0) {
            this.invalidateSections(courseId).finally(function () {
                _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */].COMPLETION_MODULE_VIEWED, { courseId: courseId });
            });
        }
    };
    /**
     * Clear all courses status in a site.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<void>} Promise resolved when all status are cleared.
     */
    CoreCourseProvider.prototype.clearAllCoursesStatus = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            _this.logger.debug('Clear all course status for site ' + site.id);
            return site.getDb().deleteRecords(_this.COURSE_STATUS_TABLE).then(function () {
                _this.triggerCourseStatusChanged(-1, __WEBPACK_IMPORTED_MODULE_7__constants__["a" /* CoreConstants */].NOT_DOWNLOADED, site.id);
            });
        });
    };
    /**
     * Get completion status of all the activities in a course for a certain user.
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined, current user.
     * @return {Promise<any>} Promise resolved with the completion statuses: object where the key is module ID.
     */
    CoreCourseProvider.prototype.getActivitiesCompletionStatus = function (courseId, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            _this.logger.debug("Getting completion status for user " + userId + " in course " + courseId);
            var params = {
                courseid: courseId,
                userid: userId
            }, preSets = {
                cacheKey: _this.getActivitiesCompletionCacheKey(courseId, userId)
            };
            return site.read('core_completion_get_activities_completion_status', params, preSets).then(function (data) {
                if (data && data.statuses) {
                    return _this.utils.arrayToObject(data.statuses, 'cmid');
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get cache key for activities completion WS calls.
     *
     * @param {number} courseId Course ID.
     * @param {number} userId User ID.
     * @return {string} Cache key.
     */
    CoreCourseProvider.prototype.getActivitiesCompletionCacheKey = function (courseId, userId) {
        return this.ROOT_CACHE_KEY + 'activitiescompletion:' + courseId + ':' + userId;
    };
    /**
     * Get the data stored for a course.
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the data.
     */
    CoreCourseProvider.prototype.getCourseStatusData = function (courseId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getRecord(_this.COURSE_STATUS_TABLE, { id: courseId }).then(function (entry) {
                if (!entry) {
                    return Promise.reject(null);
                }
                return entry;
            });
        });
    };
    /**
     * Get a course status.
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<string>} Promise resolved with the status.
     */
    CoreCourseProvider.prototype.getCourseStatus = function (courseId, siteId) {
        return this.getCourseStatusData(courseId, siteId).then(function (entry) {
            return entry.status || __WEBPACK_IMPORTED_MODULE_7__constants__["a" /* CoreConstants */].NOT_DOWNLOADED;
        }).catch(function () {
            return __WEBPACK_IMPORTED_MODULE_7__constants__["a" /* CoreConstants */].NOT_DOWNLOADED;
        });
    };
    /**
     * Get a module from Moodle.
     *
     * @param {number} moduleId The module ID.
     * @param {number} [courseId] The course ID. Recommended to speed up the process and minimize data usage.
     * @param {number} [sectionId] The section ID.
     * @param {boolean} [preferCache] True if shouldn't call WS if data is cached, false otherwise.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the module.
     */
    CoreCourseProvider.prototype.getModule = function (moduleId, courseId, sectionId, preferCache, ignoreCache, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var promise;
        if (!courseId) {
            // No courseId passed, try to retrieve it.
            promise = this.getModuleBasicInfo(moduleId, siteId).then(function (module) {
                return module.course;
            });
        }
        else {
            promise = Promise.resolve(courseId);
        }
        return promise.then(function (cid) {
            courseId = cid;
            // Get the site.
            return _this.sitesProvider.getSite(siteId);
        }).then(function (site) {
            // We have courseId, we can use core_course_get_contents for compatibility.
            _this.logger.debug("Getting module " + moduleId + " in course " + courseId);
            var params = {
                courseid: courseId,
                options: [
                    {
                        name: 'cmid',
                        value: moduleId
                    }
                ]
            }, preSets = {
                cacheKey: _this.getModuleCacheKey(moduleId),
                omitExpires: preferCache
            };
            if (!preferCache && ignoreCache) {
                preSets.getFromCache = 0;
                preSets.emergencyCache = 0;
            }
            if (sectionId) {
                params.options.push({
                    name: 'sectionid',
                    value: sectionId
                });
            }
            return site.read('core_course_get_contents', params, preSets).catch(function () {
                // Error getting the module. Try to get all contents (without filtering by module).
                return _this.getSections(courseId, false, false, preSets, siteId);
            }).then(function (sections) {
                for (var i = 0; i < sections.length; i++) {
                    var section = sections[i];
                    for (var j = 0; j < section.modules.length; j++) {
                        var module_1 = section.modules[j];
                        if (module_1.id == moduleId) {
                            module_1.course = courseId;
                            return module_1;
                        }
                    }
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Gets a module basic info by module ID.
     *
     * @param {number} moduleId Module ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the module's info.
     */
    CoreCourseProvider.prototype.getModuleBasicInfo = function (moduleId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                cmid: moduleId
            }, preSets = {
                cacheKey: _this.getModuleCacheKey(moduleId)
            };
            return site.read('core_course_get_course_module', params, preSets).then(function (response) {
                if (response.warnings && response.warnings.length) {
                    return Promise.reject(response.warnings[0]);
                }
                else if (response.cm) {
                    return response.cm;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Gets a module basic grade info by module ID.
     *
     * @param {number} moduleId Module ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the module's grade info.
     */
    CoreCourseProvider.prototype.getModuleBasicGradeInfo = function (moduleId, siteId) {
        return this.getModuleBasicInfo(moduleId, siteId).then(function (info) {
            var grade = {
                advancedgrading: info.advancedgrading || false,
                grade: info.grade || false,
                gradecat: info.gradecat || false,
                gradepass: info.gradepass || false,
                outcomes: info.outcomes || false,
                scale: info.scale || false
            };
            if (grade.grade !== false || grade.advancedgrading !== false || grade.outcomes !== false) {
                return grade;
            }
            return false;
        });
    };
    /**
     * Gets a module basic info by instance.
     *
     * @param {number} id Instance ID.
     * @param {string} module Name of the module. E.g. 'glossary'.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the module's info.
     */
    CoreCourseProvider.prototype.getModuleBasicInfoByInstance = function (id, module, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                instance: id,
                module: module
            }, preSets = {
                cacheKey: _this.getModuleBasicInfoByInstanceCacheKey(id, module)
            };
            return site.read('core_course_get_course_module_by_instance', params, preSets).then(function (response) {
                if (response.warnings && response.warnings.length) {
                    return Promise.reject(response.warnings[0]);
                }
                else if (response.cm) {
                    return response.cm;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get cache key for get module by instance WS calls.
     *
     * @param {number} id Instance ID.
     * @param {string} module Name of the module. E.g. 'glossary'.
     * @return {string} Cache key.
     */
    CoreCourseProvider.prototype.getModuleBasicInfoByInstanceCacheKey = function (id, module) {
        return this.ROOT_CACHE_KEY + 'moduleByInstance:' + module + ':' + id;
    };
    /**
     * Get cache key for module WS calls.
     *
     * @param {number} moduleId Module ID.
     * @return {string} Cache key.
     */
    CoreCourseProvider.prototype.getModuleCacheKey = function (moduleId) {
        return this.ROOT_CACHE_KEY + 'module:' + moduleId;
    };
    /**
     * Returns the source to a module icon.
     *
     * @param {string} moduleName The module name.
     * @return {string} The IMG src.
     */
    CoreCourseProvider.prototype.getModuleIconSrc = function (moduleName) {
        if (this.CORE_MODULES.indexOf(moduleName) < 0) {
            moduleName = 'external-tool';
        }
        return 'assets/img/mod/' + moduleName + '.svg';
    };
    /**
     * Get the section ID a module belongs to.
     *
     * @param {number} moduleId The module ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<number>} Promise resolved with the section ID.
     */
    CoreCourseProvider.prototype.getModuleSectionId = function (moduleId, siteId) {
        // Try to get the section using getModuleBasicInfo.
        return this.getModuleBasicInfo(moduleId, siteId).then(function (module) {
            return module.section;
        });
    };
    /**
     * Return a specific section.
     *
     * @param {number} courseId The course ID.
     * @param {number} sectionId The section ID.
     * @param {boolean} [excludeModules] Do not return modules, return only the sections structure.
     * @param {boolean} [excludeContents] Do not return module contents (i.e: files inside a resource).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the section.
     */
    CoreCourseProvider.prototype.getSection = function (courseId, sectionId, excludeModules, excludeContents, siteId) {
        if (sectionId < 0) {
            return Promise.reject('Invalid section ID');
        }
        return this.getSections(courseId, excludeModules, excludeContents, undefined, siteId).then(function (sections) {
            for (var i = 0; i < sections.length; i++) {
                if (sections[i].id == sectionId) {
                    return sections[i];
                }
            }
            return Promise.reject('Unkown section');
        });
    };
    /**
     * Get the course sections.
     *
     * @param {number} courseId The course ID.
     * @param {boolean} [excludeModules] Do not return modules, return only the sections structure.
     * @param {boolean} [excludeContents] Do not return module contents (i.e: files inside a resource).
     * @param {CoreSiteWSPreSets} [preSets] Presets to use.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise}                The reject contains the error message, else contains the sections.
     */
    CoreCourseProvider.prototype.getSections = function (courseId, excludeModules, excludeContents, preSets, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            preSets = preSets || {};
            preSets.cacheKey = _this.getSectionsCacheKey(courseId);
            preSets.getCacheUsingCacheKey = true; // This is to make sure users don't lose offline access when updating.
            var params = {
                courseid: courseId,
                options: [
                    {
                        name: 'excludemodules',
                        value: excludeModules ? 1 : 0
                    },
                    {
                        name: 'excludecontents',
                        value: excludeContents ? 1 : 0
                    }
                ]
            };
            return site.read('core_course_get_contents', params, preSets).then(function (sections) {
                var siteHomeId = site.getSiteHomeId();
                var showSections = true;
                if (courseId == siteHomeId) {
                    showSections = site.getStoredConfig('numsections');
                }
                if (typeof showSections != 'undefined' && !showSections && sections.length > 0) {
                    // Get only the last section (Main menu block section).
                    sections.pop();
                }
                return sections;
            });
        });
    };
    /**
     * Get cache key for section WS call.
     *
     * @param {number} courseId Course ID.
     * @return {string} Cache key.
     */
    CoreCourseProvider.prototype.getSectionsCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'sections:' + courseId;
    };
    /**
     * Given a list of sections, returns the list of modules in the sections.
     *
     * @param {any[]} sections Sections.
     * @return {any[]} Modules.
     */
    CoreCourseProvider.prototype.getSectionsModules = function (sections) {
        if (!sections || !sections.length) {
            return [];
        }
        var modules = [];
        sections.forEach(function (section) {
            if (section.modules) {
                modules = modules.concat(section.modules);
            }
        });
        return modules;
    };
    /**
     * Invalidates module WS call.
     *
     * @param {number} moduleId Module ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCourseProvider.prototype.invalidateModule = function (moduleId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getModuleCacheKey(moduleId));
        });
    };
    /**
     * Invalidates module WS call.
     *
     * @param {number} id Instance ID.
     * @param {string} module Name of the module. E.g. 'glossary'.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCourseProvider.prototype.invalidateModuleByInstance = function (id, module, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getModuleBasicInfoByInstanceCacheKey(id, module));
        });
    };
    /**
     * Invalidates sections WS call.
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined, current user.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCourseProvider.prototype.invalidateSections = function (courseId, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var promises = [], siteHomeId = site.getSiteHomeId();
            userId = userId || site.getUserId();
            promises.push(site.invalidateWsCacheForKey(_this.getSectionsCacheKey(courseId)));
            promises.push(site.invalidateWsCacheForKey(_this.getActivitiesCompletionCacheKey(courseId, userId)));
            if (courseId == siteHomeId) {
                promises.push(site.invalidateConfig());
            }
            return Promise.all(promises);
        });
    };
    /**
     * Load module contents into module.contents if they aren't loaded already.
     *
     * @param {any} module Module to load the contents.
     * @param {number} [courseId] The course ID. Recommended to speed up the process and minimize data usage.
     * @param {number} [sectionId] The section ID.
     * @param {boolean} [preferCache] True if shouldn't call WS if data is cached, false otherwise.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<void>} Promise resolved when loaded.
     */
    CoreCourseProvider.prototype.loadModuleContents = function (module, courseId, sectionId, preferCache, ignoreCache, siteId) {
        if (!ignoreCache && module.contents && module.contents.length) {
            // Already loaded.
            return Promise.resolve();
        }
        return this.getModule(module.id, courseId, sectionId, preferCache, ignoreCache, siteId).then(function (mod) {
            module.contents = mod.contents;
        });
    };
    /**
     * Report a course and section as being viewed.
     *
     * @param {number} courseId  Course ID.
     * @param {number} [sectionNumber] Section number.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<void>} Promise resolved when the WS call is successful.
     */
    CoreCourseProvider.prototype.logView = function (courseId, sectionNumber, siteId) {
        var params = {
            courseid: courseId
        };
        if (typeof sectionNumber != 'undefined') {
            params.sectionnumber = sectionNumber;
        }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.write('core_course_view_course', params).then(function (response) {
                if (!response.status) {
                    return Promise.reject(null);
                }
            });
        });
    };
    /**
     * Change the course status, setting it to the previous status.
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<string>} Promise resolved when the status is changed. Resolve param: new status.
     */
    CoreCourseProvider.prototype.setCoursePreviousStatus = function (courseId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        this.logger.debug("Set previous status for course " + courseId + " in site " + siteId);
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var db = site.getDb(), newData = {};
            // Get current stored data.
            return _this.getCourseStatusData(courseId, siteId).then(function (entry) {
                _this.logger.debug("Set previous status '" + entry.status + "' for course " + courseId);
                newData.status = entry.previous || __WEBPACK_IMPORTED_MODULE_7__constants__["a" /* CoreConstants */].NOT_DOWNLOADED;
                newData.updated = Date.now();
                if (entry.status == __WEBPACK_IMPORTED_MODULE_7__constants__["a" /* CoreConstants */].DOWNLOADING) {
                    // Going back from downloading to previous status, restore previous download time.
                    newData.downloadTime = entry.previousDownloadTime;
                }
                return db.updateRecords(_this.COURSE_STATUS_TABLE, newData, { id: courseId }).then(function () {
                    // Success updating, trigger event.
                    _this.triggerCourseStatusChanged(courseId, newData.status, siteId);
                    return newData.status;
                });
            });
        });
    };
    /**
     * Store course status.
     *
     * @param {number} courseId Course ID.
     * @param {string} status New course status.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<void>} Promise resolved when the status is stored.
     */
    CoreCourseProvider.prototype.setCourseStatus = function (courseId, status, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        this.logger.debug("Set status '" + status + "' for course " + courseId + " in site " + siteId);
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var downloadTime, previousDownloadTime;
            if (status == __WEBPACK_IMPORTED_MODULE_7__constants__["a" /* CoreConstants */].DOWNLOADING) {
                // Set download time if course is now downloading.
                downloadTime = _this.timeUtils.timestamp();
            }
            // Search current status to set it as previous status.
            return _this.getCourseStatusData(courseId, siteId).then(function (entry) {
                if (typeof downloadTime == 'undefined') {
                    // Keep previous download time.
                    downloadTime = entry.downloadTime;
                    previousDownloadTime = entry.previousDownloadTime;
                }
                else {
                    // The downloadTime will be updated, store current time as previous.
                    previousDownloadTime = entry.downloadTime;
                }
                return entry.status;
            }).catch(function () {
                // No previous status.
            }).then(function (previousStatus) {
                if (previousStatus != status) {
                    // Status has changed, update it.
                    var data = {
                        id: courseId,
                        status: status,
                        previous: previousStatus,
                        updated: new Date().getTime(),
                        downloadTime: downloadTime,
                        previousDownloadTime: previousDownloadTime
                    };
                    return site.getDb().insertOrUpdateRecord(_this.COURSE_STATUS_TABLE, data, { id: courseId });
                }
            }).then(function () {
                // Success inserting, trigger event.
                _this.triggerCourseStatusChanged(courseId, status, siteId);
            });
        });
    };
    /**
     * Translate a module name to current language.
     *
     * @param {string} moduleName The module name.
     * @return {string} Translated name.
     */
    CoreCourseProvider.prototype.translateModuleName = function (moduleName) {
        if (this.CORE_MODULES.indexOf(moduleName) < 0) {
            moduleName = 'external-tool';
        }
        var langKey = 'core.mod_' + moduleName, translated = this.translate.instant(langKey);
        return translated !== langKey ? translated : moduleName;
    };
    /**
     * Trigger COURSE_STATUS_CHANGED with the right data.
     *
     * @param {number} courseId Course ID.
     * @param {string} status New course status.
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    CoreCourseProvider.prototype.triggerCourseStatusChanged = function (courseId, status, siteId) {
        this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */].COURSE_STATUS_CHANGED, {
            courseId: courseId,
            status: status
        }, siteId);
    };
    CoreCourseProvider.ALL_SECTIONS_ID = -1;
    CoreCourseProvider.ACCESS_GUEST = 'courses_access_guest';
    CoreCourseProvider.ACCESS_DEFAULT = 'courses_access_default';
    CoreCourseProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */],
            __WEBPACK_IMPORTED_MODULE_6__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_utils_time__["a" /* CoreTimeUtilsProvider */], __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
    ], CoreCourseProvider);
    return CoreCourseProvider;
}());

//# sourceMappingURL=course.js.map

/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreEventsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_rxjs__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger__ = __webpack_require__(5);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/*
 * Service to send and listen to events.
 */
var CoreEventsProvider = /** @class */ (function () {
    function CoreEventsProvider(logger) {
        this.observables = {};
        this.uniqueEvents = {};
        this.logger = logger.getInstance('CoreEventsProvider');
    }
    /**
     * Listen for a certain event. To stop listening to the event:
     * let observer = eventsProvider.on('something', myCallBack);
     * ...
     * observer.off();
     *
     * @param {string} eventName Name of the event to listen to.
     * @param {Function} callBack Function to call when the event is triggered.
     * @param {string} [siteId] Site where to trigger the event. Undefined won't check the site.
     * @return {CoreEventObserver} Observer to stop listening.
     */
    CoreEventsProvider.prototype.on = function (eventName, callBack, siteId) {
        var _this = this;
        // If it's a unique event and has been triggered already, call the callBack.
        // We don't need to create an observer because the event won't be triggered again.
        if (this.uniqueEvents[eventName]) {
            callBack(this.uniqueEvents[eventName].data);
            // Return a fake observer to prevent errors.
            return {
                off: function () {
                    // Nothing to do.
                }
            };
        }
        this.logger.debug("New observer listening to event '" + eventName + "'");
        if (typeof this.observables[eventName] == 'undefined') {
            // No observable for this event, create a new one.
            this.observables[eventName] = new __WEBPACK_IMPORTED_MODULE_1_rxjs__["Subject"]();
        }
        var subscription = this.observables[eventName].subscribe(function (value) {
            if (!siteId || value.siteId == siteId) {
                callBack(value);
            }
        });
        // Create and return a CoreEventObserver.
        return {
            off: function () {
                _this.logger.debug("Stop listening to event '" + eventName + "'");
                subscription.unsubscribe();
            }
        };
    };
    /**
     * Triggers an event, notifying all the observers.
     *
     * @param {string} event Name of the event to trigger.
     * @param {any} [data] Data to pass to the observers.
     * @param {string} [siteId] Site where to trigger the event. Undefined means no Site.
     */
    CoreEventsProvider.prototype.trigger = function (eventName, data, siteId) {
        this.logger.debug("Event '" + eventName + "' triggered.");
        if (this.observables[eventName]) {
            if (siteId) {
                if (!data) {
                    data = {};
                }
                data.siteId = siteId;
            }
            this.observables[eventName].next(data);
        }
    };
    /**
     * Triggers a unique event, notifying all the observers. If the event has already been triggered, don't do anything.
     *
     * @param {string} event Name of the event to trigger.
     * @param {any} data Data to pass to the observers.
     * @param {string} [siteId] Site where to trigger the event. Undefined means no Site.
     */
    CoreEventsProvider.prototype.triggerUnique = function (eventName, data, siteId) {
        if (this.uniqueEvents[eventName]) {
            this.logger.debug("Unique event '" + eventName + "' ignored because it was already triggered.");
        }
        else {
            this.logger.debug("Unique event '" + eventName + "' triggered.");
            if (siteId) {
                if (!data) {
                    data = {};
                }
                data.siteId = siteId;
            }
            // Store the data so it can be passed to observers that register from now on.
            this.uniqueEvents[eventName] = {
                data: data
            };
            // Now pass the data to observers.
            if (this.observables[eventName]) {
                this.observables[eventName].next(data);
            }
        }
    };
    CoreEventsProvider.SESSION_EXPIRED = 'session_expired';
    CoreEventsProvider.PASSWORD_CHANGE_FORCED = 'password_change_forced';
    CoreEventsProvider.USER_NOT_FULLY_SETUP = 'user_not_fully_setup';
    CoreEventsProvider.SITE_POLICY_NOT_AGREED = 'site_policy_not_agreed';
    CoreEventsProvider.LOGIN = 'login';
    CoreEventsProvider.LOGOUT = 'logout';
    CoreEventsProvider.LANGUAGE_CHANGED = 'language_changed';
    CoreEventsProvider.NOTIFICATION_SOUND_CHANGED = 'notification_sound_changed';
    CoreEventsProvider.SITE_ADDED = 'site_added';
    CoreEventsProvider.SITE_UPDATED = 'site_updated';
    CoreEventsProvider.SITE_DELETED = 'site_deleted';
    CoreEventsProvider.COMPLETION_MODULE_VIEWED = 'completion_module_viewed';
    CoreEventsProvider.USER_DELETED = 'user_deleted';
    CoreEventsProvider.PACKAGE_STATUS_CHANGED = 'package_status_changed';
    CoreEventsProvider.COURSE_STATUS_CHANGED = 'course_status_changed';
    CoreEventsProvider.SECTION_STATUS_CHANGED = 'section_status_changed';
    CoreEventsProvider.SITE_PLUGINS_LOADED = 'site_plugins_loaded';
    CoreEventsProvider.LOGIN_SITE_CHECKED = 'login_site_checked';
    CoreEventsProvider.LOGIN_SITE_UNCHECKED = 'login_site_unchecked';
    CoreEventsProvider.IAB_LOAD_START = 'inappbrowser_load_start';
    CoreEventsProvider.IAB_EXIT = 'inappbrowser_exit';
    CoreEventsProvider.APP_LAUNCHED_URL = 'app_launched_url'; // App opened with a certain URL (custom URL scheme).
    CoreEventsProvider.FILE_SHARED = 'file_shared';
    CoreEventsProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger__["a" /* CoreLoggerProvider */]])
    ], CoreEventsProvider);
    return CoreEventsProvider;
}());

//# sourceMappingURL=events.js.map

/***/ }),
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreConstants; });
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * Static class to contain all the core constants.
 */
var CoreConstants = /** @class */ (function () {
    function CoreConstants() {
    }
    CoreConstants.SECONDS_YEAR = 31536000;
    CoreConstants.SECONDS_WEEK = 604800;
    CoreConstants.SECONDS_DAY = 86400;
    CoreConstants.SECONDS_HOUR = 3600;
    CoreConstants.SECONDS_MINUTE = 60;
    CoreConstants.WIFI_DOWNLOAD_THRESHOLD = 104857600; // 100MB.
    CoreConstants.DOWNLOAD_THRESHOLD = 10485760; // 10MB.
    CoreConstants.DONT_SHOW_ERROR = 'CoreDontShowError';
    CoreConstants.NO_SITE_ID = 'NoSite';
    // Settings constants.
    CoreConstants.SETTINGS_RICH_TEXT_EDITOR = 'CoreSettingsRichTextEditor';
    CoreConstants.SETTINGS_NOTIFICATION_SOUND = 'CoreSettingsNotificationSound';
    CoreConstants.SETTINGS_SYNC_ONLY_ON_WIFI = 'CoreSettingsSyncOnlyOnWifi';
    // WS constants.
    CoreConstants.WS_TIMEOUT = 30000;
    CoreConstants.WS_PREFIX = 'local_mobile_';
    // Login constants.
    CoreConstants.LOGIN_SSO_CODE = 2; // SSO in browser window is required.
    CoreConstants.LOGIN_SSO_INAPP_CODE = 3; // SSO in embedded browser is required.
    CoreConstants.LOGIN_LAUNCH_DATA = 'CoreLoginLaunchData';
    // Download status constants.
    CoreConstants.DOWNLOADED = 'downloaded';
    CoreConstants.DOWNLOADING = 'downloading';
    CoreConstants.NOT_DOWNLOADED = 'notdownloaded';
    CoreConstants.OUTDATED = 'outdated';
    CoreConstants.NOT_DOWNLOADABLE = 'notdownloadable';
    return CoreConstants;
}());

//# sourceMappingURL=constants.js.map

/***/ }),
/* 23 */,
/* 24 */,
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFileProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_file__ = __webpack_require__(128);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_mimetype__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_text__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ionic_native_zip__ = __webpack_require__(239);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








/**
 * Factory to interact with the file system.
 */
var CoreFileProvider = /** @class */ (function () {
    function CoreFileProvider(logger, platform, file, appProvider, textUtils, zip, mimeUtils) {
        this.platform = platform;
        this.file = file;
        this.appProvider = appProvider;
        this.textUtils = textUtils;
        this.zip = zip;
        this.mimeUtils = mimeUtils;
        this.initialized = false;
        this.basePath = '';
        this.isHTMLAPI = false;
        this.logger = logger.getInstance('CoreFileProvider');
    }
    CoreFileProvider_1 = CoreFileProvider;
    /**
     * Sets basePath to use with HTML API. Reserved for core use.
     *
     * @param {string} path Base path to use.
     */
    CoreFileProvider.prototype.setHTMLBasePath = function (path) {
        this.isHTMLAPI = true;
        this.basePath = path;
    };
    /**
     * Checks if we're using HTML API.
     *
     * @return {boolean} True if uses HTML API, false otherwise.
     */
    CoreFileProvider.prototype.usesHTMLAPI = function () {
        return this.isHTMLAPI;
    };
    /**
     * Initialize basePath based on the OS if it's not initialized already.
     *
     * @return {Promise<void>} Promise to be resolved when the initialization is finished.
     */
    CoreFileProvider.prototype.init = function () {
        var _this = this;
        if (this.initialized) {
            return Promise.resolve();
        }
        return this.platform.ready().then(function () {
            if (_this.platform.is('android')) {
                _this.basePath = _this.file.externalApplicationStorageDirectory;
            }
            else if (_this.platform.is('ios')) {
                _this.basePath = _this.file.documentsDirectory;
            }
            else if (!_this.isAvailable() || _this.basePath === '') {
                _this.logger.error('Error getting device OS.');
                return Promise.reject(null);
            }
            _this.initialized = true;
            _this.logger.debug('FS initialized: ' + _this.basePath);
        });
    };
    /**
     * Check if the plugin is available.
     *
     * @return {boolean} Whether the plugin is available.
     */
    CoreFileProvider.prototype.isAvailable = function () {
        return typeof window.resolveLocalFileSystemURL !== 'undefined';
    };
    /**
     * Get a file.
     *
     * @param {string} path Relative path to the file.
     * @return {Promise<FileEntry>} Promise resolved when the file is retrieved.
     */
    CoreFileProvider.prototype.getFile = function (path) {
        var _this = this;
        return this.init().then(function () {
            _this.logger.debug('Get file: ' + path);
            return _this.file.resolveLocalFilesystemUrl(_this.addBasePathIfNeeded(path));
        }).then(function (entry) {
            return entry;
        });
    };
    /**
     * Get a directory.
     *
     * @param {string} path Relative path to the directory.
     * @return {Promise<DirectoryEntry>} Promise resolved when the directory is retrieved.
     */
    CoreFileProvider.prototype.getDir = function (path) {
        var _this = this;
        return this.init().then(function () {
            _this.logger.debug('Get directory: ' + path);
            return _this.file.resolveDirectoryUrl(_this.addBasePathIfNeeded(path));
        });
    };
    /**
     * Get site folder path.
     *
     * @param {string} siteId Site ID.
     * @return {string} Site folder path.
     */
    CoreFileProvider.prototype.getSiteFolder = function (siteId) {
        return CoreFileProvider_1.SITESFOLDER + '/' + siteId;
    };
    /**
     * Create a directory or a file.
     *
     * @param {boolean} isDirectory True if a directory should be created, false if it should create a file.
     * @param {string} path Relative path to the dir/file.
     * @param {boolean} [failIfExists] True if it should fail if the dir/file exists, false otherwise.
     * @param {string} [base] Base path to create the dir/file in. If not set, use basePath.
     * @return {Promise<any>} Promise to be resolved when the dir/file is created.
     */
    CoreFileProvider.prototype.create = function (isDirectory, path, failIfExists, base) {
        var _this = this;
        return this.init().then(function () {
            // Remove basePath if it's in the path.
            path = _this.removeStartingSlash(path.replace(_this.basePath, ''));
            base = base || _this.basePath;
            if (path.indexOf('/') == -1) {
                if (isDirectory) {
                    _this.logger.debug('Create dir ' + path + ' in ' + base);
                    return _this.file.createDir(base, path, !failIfExists);
                }
                else {
                    _this.logger.debug('Create file ' + path + ' in ' + base);
                    return _this.file.createFile(base, path, !failIfExists);
                }
            }
            else {
                // The file plugin doesn't allow creating more than 1 level at a time (e.g. tmp/folder).
                // We need to create them 1 by 1.
                var firstDir_1 = path.substr(0, path.indexOf('/')), restOfPath_1 = path.substr(path.indexOf('/') + 1);
                _this.logger.debug('Create dir ' + firstDir_1 + ' in ' + base);
                return _this.file.createDir(base, firstDir_1, true).then(function (newDirEntry) {
                    return _this.create(isDirectory, restOfPath_1, failIfExists, newDirEntry.toURL());
                }).catch(function (error) {
                    _this.logger.error('Error creating directory ' + firstDir_1 + ' in ' + base);
                    return Promise.reject(error);
                });
            }
        });
    };
    /**
     * Create a directory.
     *
     * @param {string} path Relative path to the directory.
     * @param {boolean} [failIfExists] True if it should fail if the directory exists, false otherwise.
     * @return {Promise<DirectoryEntry>} Promise to be resolved when the directory is created.
     */
    CoreFileProvider.prototype.createDir = function (path, failIfExists) {
        return this.create(true, path, failIfExists);
    };
    /**
     * Create a file.
     *
     * @param {string} path Relative path to the file.
     * @param {boolean} [failIfExists] True if it should fail if the file exists, false otherwise..
     * @return {Promise<FileEntry>} Promise to be resolved when the file is created.
     */
    CoreFileProvider.prototype.createFile = function (path, failIfExists) {
        return this.create(false, path, failIfExists);
    };
    /**
     * Removes a directory and all its contents.
     *
     * @param {string} path Relative path to the directory.
     * @return {Promise<any>} Promise to be resolved when the directory is deleted.
     */
    CoreFileProvider.prototype.removeDir = function (path) {
        var _this = this;
        return this.init().then(function () {
            // Remove basePath if it's in the path.
            path = _this.removeStartingSlash(path.replace(_this.basePath, ''));
            _this.logger.debug('Remove directory: ' + path);
            return _this.file.removeRecursively(_this.basePath, path);
        });
    };
    /**
     * Removes a file and all its contents.
     *
     * @param {string} path Relative path to the file.
     * @return {Promise<any>} Promise to be resolved when the file is deleted.
     */
    CoreFileProvider.prototype.removeFile = function (path) {
        var _this = this;
        return this.init().then(function () {
            // Remove basePath if it's in the path.
            path = _this.removeStartingSlash(path.replace(_this.basePath, ''));
            _this.logger.debug('Remove file: ' + path);
            return _this.file.removeFile(_this.basePath, path);
        });
    };
    /**
     * Removes a file given its FileEntry.
     *
     * @param {FileEntry} fileEntry File Entry.
     * @return {Promise<any>} Promise resolved when the file is deleted.
     */
    CoreFileProvider.prototype.removeFileByFileEntry = function (fileEntry) {
        return new Promise(function (resolve, reject) {
            fileEntry.remove(resolve, reject);
        });
    };
    /**
     * Retrieve the contents of a directory (not subdirectories).
     *
     * @param {string} path Relative path to the directory.
     * @return {Promise<any>} Promise to be resolved when the contents are retrieved.
     */
    CoreFileProvider.prototype.getDirectoryContents = function (path) {
        var _this = this;
        return this.init().then(function () {
            // Remove basePath if it's in the path.
            path = _this.removeStartingSlash(path.replace(_this.basePath, ''));
            _this.logger.debug('Get contents of dir: ' + path);
            return _this.file.listDir(_this.basePath, path);
        });
    };
    /**
     * Calculate the size of a directory or a file.
     *
     * @param {any} entry Directory or file.
     * @return {Promise<number>} Promise to be resolved when the size is calculated.
     */
    CoreFileProvider.prototype.getSize = function (entry) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (entry.isDirectory) {
                var directoryReader = entry.createReader();
                directoryReader.readEntries(function (entries) {
                    var promises = [];
                    for (var i = 0; i < entries.length; i++) {
                        promises.push(_this.getSize(entries[i]));
                    }
                    Promise.all(promises).then(function (sizes) {
                        var directorySize = 0;
                        for (var i = 0; i < sizes.length; i++) {
                            var fileSize = parseInt(sizes[i]);
                            if (isNaN(fileSize)) {
                                reject();
                                return;
                            }
                            directorySize += fileSize;
                        }
                        resolve(directorySize);
                    }, reject);
                }, reject);
            }
            else if (entry.isFile) {
                entry.file(function (file) {
                    resolve(file.size);
                }, reject);
            }
        });
    };
    /**
     * Calculate the size of a directory.
     *
     * @param {string} path Relative path to the directory.
     * @return {Promise<number>} Promise to be resolved when the size is calculated.
     */
    CoreFileProvider.prototype.getDirectorySize = function (path) {
        var _this = this;
        // Remove basePath if it's in the path.
        path = this.removeStartingSlash(path.replace(this.basePath, ''));
        this.logger.debug('Get size of dir: ' + path);
        return this.getDir(path).then(function (dirEntry) {
            return _this.getSize(dirEntry);
        });
    };
    /**
     * Calculate the size of a file.
     *
     * @param {string} path Relative path to the file.
     * @return {Promise<number>} Promise to be resolved when the size is calculated.
     */
    CoreFileProvider.prototype.getFileSize = function (path) {
        var _this = this;
        // Remove basePath if it's in the path.
        path = this.removeStartingSlash(path.replace(this.basePath, ''));
        this.logger.debug('Get size of file: ' + path);
        return this.getFile(path).then(function (fileEntry) {
            return _this.getSize(fileEntry);
        });
    };
    /**
     * Get file object from a FileEntry.
     *
     * @param {FileEntry} path Relative path to the file.
     * @return {Promise<any>} Promise to be resolved when the file is retrieved.
     */
    CoreFileProvider.prototype.getFileObjectFromFileEntry = function (entry) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.logger.debug('Get file object of: ' + entry.fullPath);
            entry.file(resolve, reject);
        });
    };
    /**
     * Calculate the free space in the disk.
     *
     * @return {Promise<number>} Promise resolved with the estimated free space in bytes.
     */
    CoreFileProvider.prototype.calculateFreeSpace = function () {
        return this.file.getFreeDiskSpace().then(function (size) {
            return size; // GetFreeDiskSpace returns KB.
        });
    };
    /**
     * Normalize a filename that usually comes URL encoded.
     *
     * @param {string} filename The file name.
     * @return {string} The file name normalized.
     */
    CoreFileProvider.prototype.normalizeFileName = function (filename) {
        filename = this.textUtils.decodeURIComponent(filename);
        return filename;
    };
    /**
     * Read a file from local file system.
     *
     * @param {string} path Relative path to the file.
     * @param {number} [format=FORMATTEXT] Format to read the file. Must be one of:
     *                                  FORMATTEXT
     *                                  FORMATDATAURL
     *                                  FORMATBINARYSTRING
     *                                  FORMATARRAYBUFFER
     * @return {Promise<any>} Promise to be resolved when the file is read.
     */
    CoreFileProvider.prototype.readFile = function (path, format) {
        if (format === void 0) { format = CoreFileProvider_1.FORMATTEXT; }
        // Remove basePath if it's in the path.
        path = this.removeStartingSlash(path.replace(this.basePath, ''));
        this.logger.debug('Read file ' + path + ' with format ' + format);
        switch (format) {
            case CoreFileProvider_1.FORMATDATAURL:
                return this.file.readAsDataURL(this.basePath, path);
            case CoreFileProvider_1.FORMATBINARYSTRING:
                return this.file.readAsBinaryString(this.basePath, path);
            case CoreFileProvider_1.FORMATARRAYBUFFER:
                return this.file.readAsArrayBuffer(this.basePath, path);
            default:
                return this.file.readAsText(this.basePath, path);
        }
    };
    /**
     * Read file contents from a file data object.
     *
     * @param {any} fileData File's data.
     * @param {number} [format=FORMATTEXT] Format to read the file. Must be one of:
     *                                  FORMATTEXT
     *                                  FORMATDATAURL
     *                                  FORMATBINARYSTRING
     *                                  FORMATARRAYBUFFER
     * @return {Promise<any>} Promise to be resolved when the file is read.
     */
    CoreFileProvider.prototype.readFileData = function (fileData, format) {
        if (format === void 0) { format = CoreFileProvider_1.FORMATTEXT; }
        format = format || CoreFileProvider_1.FORMATTEXT;
        this.logger.debug('Read file from file data with format ' + format);
        return new Promise(function (resolve, reject) {
            var reader = new FileReader();
            reader.onloadend = function (evt) {
                var target = evt.target; // Convert to <any> to be able to use non-standard properties.
                if (target.result !== undefined || target.result !== null) {
                    resolve(target.result);
                }
                else if (target.error !== undefined || target.error !== null) {
                    reject(target.error);
                }
                else {
                    reject({ code: null, message: 'READER_ONLOADEND_ERR' });
                }
            };
            switch (format) {
                case CoreFileProvider_1.FORMATDATAURL:
                    reader.readAsDataURL(fileData);
                    break;
                case CoreFileProvider_1.FORMATBINARYSTRING:
                    reader.readAsBinaryString(fileData);
                    break;
                case CoreFileProvider_1.FORMATARRAYBUFFER:
                    reader.readAsArrayBuffer(fileData);
                    break;
                default:
                    reader.readAsText(fileData);
            }
        });
    };
    /**
     * Writes some data in a file.
     *
     * @param {string} path Relative path to the file.
     * @param {any} data Data to write.
     * @return {Promise<any>} Promise to be resolved when the file is written.
     */
    CoreFileProvider.prototype.writeFile = function (path, data) {
        var _this = this;
        return this.init().then(function () {
            // Remove basePath if it's in the path.
            path = _this.removeStartingSlash(path.replace(_this.basePath, ''));
            _this.logger.debug('Write file: ' + path);
            // Create file (and parent folders) to prevent errors.
            return _this.createFile(path).then(function (fileEntry) {
                if (_this.isHTMLAPI && !_this.appProvider.isDesktop() &&
                    (typeof data == 'string' || data.toString() == '[object ArrayBuffer]')) {
                    // We need to write Blobs.
                    var type = _this.mimeUtils.getMimeType(_this.mimeUtils.getFileExtension(path));
                    data = new Blob([data], { type: type || 'text/plain' });
                }
                return _this.file.writeFile(_this.basePath, path, data, { replace: true }).then(function () {
                    return fileEntry;
                });
            });
        });
    };
    /**
     * Gets a file that might be outside the app's folder.
     *
     * @param {string} fullPath Absolute path to the file.
     * @return {Promise<FileEntry>} Promise to be resolved when the file is retrieved.
     */
    CoreFileProvider.prototype.getExternalFile = function (fullPath) {
        return this.file.resolveLocalFilesystemUrl(fullPath).then(function (entry) {
            return entry;
        });
    };
    /**
     * Removes a file that might be outside the app's folder.
     *
     * @param {string} fullPath Absolute path to the file.
     * @return {Promise<any>} Promise to be resolved when the file is removed.
     */
    CoreFileProvider.prototype.removeExternalFile = function (fullPath) {
        var directory = fullPath.substring(0, fullPath.lastIndexOf('/')), filename = fullPath.substr(fullPath.lastIndexOf('/') + 1);
        return this.file.removeFile(directory, filename);
    };
    /**
     * Get the base path where the application files are stored.
     *
     * @return {Promise<string>} Promise to be resolved when the base path is retrieved.
     */
    CoreFileProvider.prototype.getBasePath = function () {
        var _this = this;
        return this.init().then(function () {
            if (_this.basePath.slice(-1) == '/') {
                return _this.basePath;
            }
            else {
                return _this.basePath + '/';
            }
        });
    };
    /**
     * Get the base path where the application files are stored in the format to be used for downloads.
     * iOS: Internal URL (cdvfile://).
     * Others: basePath (file://)
     *
     * @return {Promise<string>} Promise to be resolved when the base path is retrieved.
     */
    CoreFileProvider.prototype.getBasePathToDownload = function () {
        var _this = this;
        return this.init().then(function () {
            if (_this.platform.is('ios')) {
                // In iOS we want the internal URL (cdvfile://localhost/persistent/...).
                return _this.file.resolveDirectoryUrl(_this.basePath).then(function (dirEntry) {
                    return dirEntry.toInternalURL();
                });
            }
            else {
                // In the other platforms we use the basePath as it is (file://...).
                return _this.basePath;
            }
        });
    };
    /**
     * Get the base path where the application files are stored. Returns the value instantly, without waiting for it to be ready.
     *
     * @return {string} Base path. If the service hasn't been initialized it will return an invalid value.
     */
    CoreFileProvider.prototype.getBasePathInstant = function () {
        if (!this.basePath) {
            return this.basePath;
        }
        else if (this.basePath.slice(-1) == '/') {
            return this.basePath;
        }
        else {
            return this.basePath + '/';
        }
    };
    /**
     * Move a file.
     *
     * @param {string} [originalPath] Path to the file to move.
     * @param {string} [newPath] New path of the file.
     * @return {Promise<any>} Promise resolved when the entry is moved.
     */
    CoreFileProvider.prototype.moveFile = function (originalPath, newPath) {
        var _this = this;
        return this.init().then(function () {
            // Remove basePath if it's in the paths.
            originalPath = _this.removeStartingSlash(originalPath.replace(_this.basePath, ''));
            newPath = _this.removeStartingSlash(newPath.replace(_this.basePath, ''));
            if (_this.isHTMLAPI) {
                // In Cordova API we need to calculate the longest matching path to make it work.
                // The function this.file.moveFile('a/', 'b/c.ext', 'a/', 'b/d.ext') doesn't work.
                // The function this.file.moveFile('a/b/', 'c.ext', 'a/b/', 'd.ext') works.
                var dirsA = originalPath.split('/'), dirsB = newPath.split('/');
                var commonPath = _this.basePath;
                for (var i = 0; i < dirsA.length; i++) {
                    var dir = dirsA[i];
                    if (dirsB[i] === dir) {
                        // Found a common folder, add it to common path and remove it from each specific path.
                        dir = dir + '/';
                        commonPath = _this.textUtils.concatenatePaths(commonPath, dir);
                        originalPath = originalPath.replace(dir, '');
                        newPath = newPath.replace(dir, '');
                    }
                    else {
                        // Folder doesn't match, stop searching.
                        break;
                    }
                }
                return _this.file.moveFile(commonPath, originalPath, commonPath, newPath);
            }
            else {
                return _this.file.moveFile(_this.basePath, originalPath, _this.basePath, newPath);
            }
        });
    };
    /**
     * Copy a file.
     *
     * @param {string} from Path to the file to move.
     * @param {string} to New path of the file.
     * @return {Promise<any>} Promise resolved when the entry is copied.
     */
    CoreFileProvider.prototype.copyFile = function (from, to) {
        var _this = this;
        var fromFileAndDir, toFileAndDir;
        return this.init().then(function () {
            // Paths cannot start with "/". Remove basePath if present.
            from = _this.removeStartingSlash(from.replace(_this.basePath, ''));
            to = _this.removeStartingSlash(to.replace(_this.basePath, ''));
            fromFileAndDir = _this.getFileAndDirectoryFromPath(from);
            toFileAndDir = _this.getFileAndDirectoryFromPath(to);
            if (toFileAndDir.directory) {
                // Create the target directory if it doesn't exist.
                return _this.createDir(toFileAndDir.directory);
            }
        }).then(function () {
            if (_this.isHTMLAPI) {
                // In HTML API, the file name cannot include a directory, otherwise it fails.
                var fromDir = _this.textUtils.concatenatePaths(_this.basePath, fromFileAndDir.directory), toDir = _this.textUtils.concatenatePaths(_this.basePath, toFileAndDir.directory);
                return _this.file.copyFile(fromDir, fromFileAndDir.name, toDir, toFileAndDir.name);
            }
            else {
                return _this.file.copyFile(_this.basePath, from, _this.basePath, to);
            }
        });
    };
    /**
     * Extract the file name and directory from a given path.
     *
     * @param {string} path Path to be extracted.
     * @return {any} Plain object containing the file name and directory.
     * @description
     * file.pdf         -> directory: '', name: 'file.pdf'
     * /file.pdf        -> directory: '', name: 'file.pdf'
     * path/file.pdf    -> directory: 'path', name: 'file.pdf'
     * path/            -> directory: 'path', name: ''
     * path             -> directory: '', name: 'path'
     */
    CoreFileProvider.prototype.getFileAndDirectoryFromPath = function (path) {
        var file = {
            directory: '',
            name: ''
        };
        file.directory = path.substring(0, path.lastIndexOf('/'));
        file.name = path.substr(path.lastIndexOf('/') + 1);
        return file;
    };
    /**
     * Get the internal URL of a file.
     *
     * @param {FileEntry} fileEntry File Entry.
     * @return {string} Internal URL.
     */
    CoreFileProvider.prototype.getInternalURL = function (fileEntry) {
        if (!fileEntry.toInternalURL) {
            // File doesn't implement toInternalURL, use toURL.
            return fileEntry.toURL();
        }
        return fileEntry.toInternalURL();
    };
    /**
     * Adds the basePath to a path if it doesn't have it already.
     *
     * @param {string} path Path to treat.
     * @return {string} Path with basePath added.
     */
    CoreFileProvider.prototype.addBasePathIfNeeded = function (path) {
        if (path.indexOf(this.basePath) > -1) {
            return path;
        }
        else {
            return this.textUtils.concatenatePaths(this.basePath, path);
        }
    };
    /**
     * Remove the base path from a path. If basePath isn't found, return false.
     *
     * @param {string} path Path to treat.
     * @return {string} Path without basePath if basePath was found, undefined otherwise.
     */
    CoreFileProvider.prototype.removeBasePath = function (path) {
        if (path.indexOf(this.basePath) > -1) {
            return path.replace(this.basePath, '');
        }
    };
    /**
     * Unzips a file.
     *
     * @param {string} path Path to the ZIP file.
     * @param {string} [destFolder] Path to the destination folder. If not defined, a new folder will be created with the
     *                     same location and name as the ZIP file (without extension).
     * @param {Function} [onProgress] Function to call on progress.
     * @return {Promise<any>} Promise resolved when the file is unzipped.
     */
    CoreFileProvider.prototype.unzipFile = function (path, destFolder, onProgress) {
        var _this = this;
        // Get the source file.
        return this.getFile(path).then(function (fileEntry) {
            // If destFolder is not set, use same location as ZIP file. We need to use absolute paths (including basePath).
            destFolder = _this.addBasePathIfNeeded(destFolder || _this.mimeUtils.removeExtension(path));
            return _this.zip.unzip(fileEntry.toURL(), destFolder, onProgress);
        });
    };
    /**
     * Search a string or regexp in a file contents and replace it. The result is saved in the same file.
     *
     * @param {string} path Path to the file.
     * @param {string|RegExp} search Value to search.
     * @param {string} newValue New value.
     * @return {Promise<any>} Promise resolved in success.
     */
    CoreFileProvider.prototype.replaceInFile = function (path, search, newValue) {
        var _this = this;
        return this.readFile(path).then(function (content) {
            if (typeof content == 'undefined' || content === null || !content.replace) {
                return Promise.reject(null);
            }
            if (content.match(search)) {
                content = content.replace(search, newValue);
                return _this.writeFile(path, content);
            }
        });
    };
    /**
     * Get a file/dir metadata given the file's entry.
     *
     * @param {Entry} fileEntry FileEntry retrieved from getFile or similar.
     * @return {Promise<any>} Promise resolved with metadata.
     */
    CoreFileProvider.prototype.getMetadata = function (fileEntry) {
        if (!fileEntry || !fileEntry.getMetadata) {
            return Promise.reject(null);
        }
        return new Promise(function (resolve, reject) {
            fileEntry.getMetadata(resolve, reject);
        });
    };
    /**
     * Get a file/dir metadata given the path.
     *
     * @param {string} path Path to the file/dir.
     * @param {boolean} [isDir] True if directory, false if file.
     * @return {Promise<any>} Promise resolved with metadata.
     */
    CoreFileProvider.prototype.getMetadataFromPath = function (path, isDir) {
        var _this = this;
        var promise;
        if (isDir) {
            promise = this.getDir(path);
        }
        else {
            promise = this.getFile(path);
        }
        return promise.then(function (entry) {
            return _this.getMetadata(entry);
        });
    };
    /**
     * Remove the starting slash of a path if it's there. E.g. '/sites/filepool' -> 'sites/filepool'.
     *
     * @param {string} path Path.
     * @return {string} Path without a slash in the first position.
     */
    CoreFileProvider.prototype.removeStartingSlash = function (path) {
        if (path[0] == '/') {
            return path.substr(1);
        }
        return path;
    };
    /**
     * Convenience function to copy or move an external file.
     *
     * @param {string} from Absolute path to the file to copy/move.
     * @param {string} to Relative new path of the file (inside the app folder).
     * @param {boolean} copy True to copy, false to move.
     * @return {Promise<any>} Promise resolved when the entry is copied/moved.
     */
    CoreFileProvider.prototype.copyOrMoveExternalFile = function (from, to, copy) {
        var _this = this;
        // Get the file to copy/move.
        return this.getExternalFile(from).then(function (fileEntry) {
            // Create the destination dir if it doesn't exist.
            var dirAndFile = _this.getFileAndDirectoryFromPath(to);
            return _this.createDir(dirAndFile.directory).then(function (dirEntry) {
                // Now copy/move the file.
                return new Promise(function (resolve, reject) {
                    if (copy) {
                        fileEntry.copyTo(dirEntry, dirAndFile.name, resolve, reject);
                    }
                    else {
                        fileEntry.moveTo(dirEntry, dirAndFile.name, resolve, reject);
                    }
                });
            });
        });
    };
    /**
     * Copy a file from outside of the app folder to somewhere inside the app folder.
     *
     * @param {string} from Absolute path to the file to copy.
     * @param {string} to Relative new path of the file (inside the app folder).
     * @return {Promise<any>} Promise resolved when the entry is copied.
     */
    CoreFileProvider.prototype.copyExternalFile = function (from, to) {
        return this.copyOrMoveExternalFile(from, to, true);
    };
    /**
     * Move a file from outside of the app folder to somewhere inside the app folder.
     *
     * @param {string} from Absolute path to the file to move.
     * @param {string} to Relative new path of the file (inside the app folder).
     * @return {Promise<any>} Promise resolved when the entry is moved.
     */
    CoreFileProvider.prototype.moveExternalFile = function (from, to) {
        return this.copyOrMoveExternalFile(from, to, false);
    };
    /**
     * Get a unique file name inside a folder, adding numbers to the file name if needed.
     *
     * @param {string} dirPath Path to the destination folder.
     * @param {string} fileName File name that wants to be used.
     * @param {string} [defaultExt] Default extension to use if no extension found in the file.
     * @return {Promise<string>} Promise resolved with the unique file name.
     */
    CoreFileProvider.prototype.getUniqueNameInFolder = function (dirPath, fileName, defaultExt) {
        var _this = this;
        // Get existing files in the folder.
        return this.getDirectoryContents(dirPath).then(function (entries) {
            var files = {};
            var num = 1, fileNameWithoutExtension = _this.mimeUtils.removeExtension(fileName), extension = _this.mimeUtils.getFileExtension(fileName) || defaultExt, newName;
            // Clean the file name.
            fileNameWithoutExtension = _this.textUtils.removeSpecialCharactersForFiles(_this.textUtils.decodeURIComponent(fileNameWithoutExtension));
            // Index the files by name.
            entries.forEach(function (entry) {
                files[entry.name] = entry;
            });
            // Format extension.
            if (extension) {
                extension = '.' + extension;
            }
            else {
                extension = '';
            }
            newName = fileNameWithoutExtension + extension;
            if (typeof files[newName] == 'undefined') {
                // No file with the same name.
                return newName;
            }
            else {
                // Repeated name. Add a number until we find a free name.
                do {
                    newName = fileNameWithoutExtension + '(' + num + ')' + extension;
                    num++;
                } while (typeof files[newName] != 'undefined');
                // Ask the user what he wants to do.
                return newName;
            }
        }).catch(function () {
            // Folder doesn't exist, name is unique. Clean it and return it.
            return _this.textUtils.removeSpecialCharactersForFiles(_this.textUtils.decodeURIComponent(fileName));
        });
    };
    /**
     * Remove app temporary folder.
     *
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreFileProvider.prototype.clearTmpFolder = function () {
        return this.removeDir(CoreFileProvider_1.TMPFOLDER);
    };
    /**
     * Given a folder path and a list of used files, remove all the files of the folder that aren't on the list of used files.
     *
     * @param {string} dirPath Folder path.
     * @param {any[]} files List of used files.
     * @return {Promise<any>} Promise resolved when done, rejected if failure.
     */
    CoreFileProvider.prototype.removeUnusedFiles = function (dirPath, files) {
        var _this = this;
        // Get the directory contents.
        return this.getDirectoryContents(dirPath).then(function (contents) {
            if (!contents.length) {
                return;
            }
            var filesMap = {}, promises = [];
            // Index the received files by fullPath and ignore the invalid ones.
            files.forEach(function (file) {
                if (file.fullPath) {
                    filesMap[file.fullPath] = file;
                }
            });
            // Check which of the content files aren't used anymore and delete them.
            contents.forEach(function (file) {
                if (!filesMap[file.fullPath]) {
                    // File isn't used, delete it.
                    promises.push(_this.removeFileByFileEntry(file));
                }
            });
            return Promise.all(promises);
        }).catch(function () {
            // Ignore errors, maybe it doesn't exist.
        });
    };
    /**
     * Check if a file is inside the app's folder.
     *
     * @param {string} path The absolute path of the file to check.
     * @return {boolean} Whether the file is in the app's folder.
     */
    CoreFileProvider.prototype.isFileInAppFolder = function (path) {
        return path.indexOf(this.basePath) != -1;
    };
    // Formats to read a file.
    CoreFileProvider.FORMATTEXT = 0;
    CoreFileProvider.FORMATDATAURL = 1;
    CoreFileProvider.FORMATBINARYSTRING = 2;
    CoreFileProvider.FORMATARRAYBUFFER = 3;
    // Folders.
    CoreFileProvider.SITESFOLDER = 'sites';
    CoreFileProvider.TMPFOLDER = 'tmp';
    CoreFileProvider = CoreFileProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */], __WEBPACK_IMPORTED_MODULE_2__ionic_native_file__["a" /* File */], __WEBPACK_IMPORTED_MODULE_3__app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_6__utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_7__ionic_native_zip__["a" /* Zip */], __WEBPACK_IMPORTED_MODULE_5__utils_mimetype__["a" /* CoreMimetypeUtilsProvider */]])
    ], CoreFileProvider);
    return CoreFileProvider;
    var CoreFileProvider_1;
}());

//# sourceMappingURL=file.js.map

/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreComponentsModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__directives_directives_module__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__pipes_pipes_module__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__loading_loading__ = __webpack_require__(1051);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__mark_required_mark_required__ = __webpack_require__(1052);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__input_errors_input_errors__ = __webpack_require__(1053);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__show_password_show_password__ = __webpack_require__(1054);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__split_view_split_view__ = __webpack_require__(178);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__iframe_iframe__ = __webpack_require__(1055);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__progress_bar_progress_bar__ = __webpack_require__(1056);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__empty_box_empty_box__ = __webpack_require__(1057);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__search_box_search_box__ = __webpack_require__(1058);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__file_file__ = __webpack_require__(1059);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__context_menu_context_menu__ = __webpack_require__(586);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__context_menu_context_menu_item__ = __webpack_require__(1060);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__context_menu_context_menu_popover__ = __webpack_require__(587);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__course_picker_menu_course_picker_menu_popover__ = __webpack_require__(721);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__chrono_chrono__ = __webpack_require__(1061);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__local_file_local_file__ = __webpack_require__(1062);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__site_picker_site_picker__ = __webpack_require__(1063);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__tabs_tabs__ = __webpack_require__(588);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__tabs_tab__ = __webpack_require__(1064);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__rich_text_editor_rich_text_editor__ = __webpack_require__(1065);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__navbar_buttons_navbar_buttons__ = __webpack_require__(1066);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__dynamic_component_dynamic_component__ = __webpack_require__(241);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__send_message_form_send_message_form__ = __webpack_require__(1067);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};




























var CoreComponentsModule = /** @class */ (function () {
    function CoreComponentsModule() {
    }
    CoreComponentsModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_5__loading_loading__["a" /* CoreLoadingComponent */],
                __WEBPACK_IMPORTED_MODULE_6__mark_required_mark_required__["a" /* CoreMarkRequiredComponent */],
                __WEBPACK_IMPORTED_MODULE_7__input_errors_input_errors__["a" /* CoreInputErrorsComponent */],
                __WEBPACK_IMPORTED_MODULE_8__show_password_show_password__["a" /* CoreShowPasswordComponent */],
                __WEBPACK_IMPORTED_MODULE_9__split_view_split_view__["a" /* CoreSplitViewComponent */],
                __WEBPACK_IMPORTED_MODULE_10__iframe_iframe__["a" /* CoreIframeComponent */],
                __WEBPACK_IMPORTED_MODULE_11__progress_bar_progress_bar__["a" /* CoreProgressBarComponent */],
                __WEBPACK_IMPORTED_MODULE_12__empty_box_empty_box__["a" /* CoreEmptyBoxComponent */],
                __WEBPACK_IMPORTED_MODULE_13__search_box_search_box__["a" /* CoreSearchBoxComponent */],
                __WEBPACK_IMPORTED_MODULE_14__file_file__["a" /* CoreFileComponent */],
                __WEBPACK_IMPORTED_MODULE_15__context_menu_context_menu__["a" /* CoreContextMenuComponent */],
                __WEBPACK_IMPORTED_MODULE_16__context_menu_context_menu_item__["a" /* CoreContextMenuItemComponent */],
                __WEBPACK_IMPORTED_MODULE_17__context_menu_context_menu_popover__["a" /* CoreContextMenuPopoverComponent */],
                __WEBPACK_IMPORTED_MODULE_18__course_picker_menu_course_picker_menu_popover__["a" /* CoreCoursePickerMenuPopoverComponent */],
                __WEBPACK_IMPORTED_MODULE_19__chrono_chrono__["a" /* CoreChronoComponent */],
                __WEBPACK_IMPORTED_MODULE_20__local_file_local_file__["a" /* CoreLocalFileComponent */],
                __WEBPACK_IMPORTED_MODULE_21__site_picker_site_picker__["a" /* CoreSitePickerComponent */],
                __WEBPACK_IMPORTED_MODULE_22__tabs_tabs__["a" /* CoreTabsComponent */],
                __WEBPACK_IMPORTED_MODULE_23__tabs_tab__["a" /* CoreTabComponent */],
                __WEBPACK_IMPORTED_MODULE_24__rich_text_editor_rich_text_editor__["a" /* CoreRichTextEditorComponent */],
                __WEBPACK_IMPORTED_MODULE_25__navbar_buttons_navbar_buttons__["a" /* CoreNavBarButtonsComponent */],
                __WEBPACK_IMPORTED_MODULE_26__dynamic_component_dynamic_component__["a" /* CoreDynamicComponent */],
                __WEBPACK_IMPORTED_MODULE_27__send_message_form_send_message_form__["a" /* CoreSendMessageFormComponent */]
            ],
            entryComponents: [
                __WEBPACK_IMPORTED_MODULE_17__context_menu_context_menu_popover__["a" /* CoreContextMenuPopoverComponent */],
                __WEBPACK_IMPORTED_MODULE_18__course_picker_menu_course_picker_menu_popover__["a" /* CoreCoursePickerMenuPopoverComponent */]
            ],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["g" /* IonicModule */],
                __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["b" /* TranslateModule */].forChild(),
                __WEBPACK_IMPORTED_MODULE_3__directives_directives_module__["a" /* CoreDirectivesModule */],
                __WEBPACK_IMPORTED_MODULE_4__pipes_pipes_module__["a" /* CorePipesModule */]
            ],
            exports: [
                __WEBPACK_IMPORTED_MODULE_5__loading_loading__["a" /* CoreLoadingComponent */],
                __WEBPACK_IMPORTED_MODULE_6__mark_required_mark_required__["a" /* CoreMarkRequiredComponent */],
                __WEBPACK_IMPORTED_MODULE_7__input_errors_input_errors__["a" /* CoreInputErrorsComponent */],
                __WEBPACK_IMPORTED_MODULE_8__show_password_show_password__["a" /* CoreShowPasswordComponent */],
                __WEBPACK_IMPORTED_MODULE_9__split_view_split_view__["a" /* CoreSplitViewComponent */],
                __WEBPACK_IMPORTED_MODULE_10__iframe_iframe__["a" /* CoreIframeComponent */],
                __WEBPACK_IMPORTED_MODULE_11__progress_bar_progress_bar__["a" /* CoreProgressBarComponent */],
                __WEBPACK_IMPORTED_MODULE_12__empty_box_empty_box__["a" /* CoreEmptyBoxComponent */],
                __WEBPACK_IMPORTED_MODULE_13__search_box_search_box__["a" /* CoreSearchBoxComponent */],
                __WEBPACK_IMPORTED_MODULE_14__file_file__["a" /* CoreFileComponent */],
                __WEBPACK_IMPORTED_MODULE_15__context_menu_context_menu__["a" /* CoreContextMenuComponent */],
                __WEBPACK_IMPORTED_MODULE_16__context_menu_context_menu_item__["a" /* CoreContextMenuItemComponent */],
                __WEBPACK_IMPORTED_MODULE_19__chrono_chrono__["a" /* CoreChronoComponent */],
                __WEBPACK_IMPORTED_MODULE_20__local_file_local_file__["a" /* CoreLocalFileComponent */],
                __WEBPACK_IMPORTED_MODULE_21__site_picker_site_picker__["a" /* CoreSitePickerComponent */],
                __WEBPACK_IMPORTED_MODULE_22__tabs_tabs__["a" /* CoreTabsComponent */],
                __WEBPACK_IMPORTED_MODULE_23__tabs_tab__["a" /* CoreTabComponent */],
                __WEBPACK_IMPORTED_MODULE_24__rich_text_editor_rich_text_editor__["a" /* CoreRichTextEditorComponent */],
                __WEBPACK_IMPORTED_MODULE_25__navbar_buttons_navbar_buttons__["a" /* CoreNavBarButtonsComponent */],
                __WEBPACK_IMPORTED_MODULE_26__dynamic_component_dynamic_component__["a" /* CoreDynamicComponent */],
                __WEBPACK_IMPORTED_MODULE_27__send_message_form_send_message_form__["a" /* CoreSendMessageFormComponent */]
            ]
        })
    ], CoreComponentsModule);
    return CoreComponentsModule;
}());

//# sourceMappingURL=components.module.js.map

/***/ }),
/* 27 */,
/* 28 */,
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_events__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_file__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_filepool__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_file_helper__ = __webpack_require__(160);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_text__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_utils_time__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__options_delegate__ = __webpack_require__(100);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__core_sitehome_providers_sitehome__ = __webpack_require__(138);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__course__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__module_delegate__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__module_prefetch_delegate__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__core_login_providers_helper__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__core_constants__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_moment__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_19_moment__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




















/**
 * Helper to gather some common course functions.
 */
var CoreCourseHelperProvider = /** @class */ (function () {
    function CoreCourseHelperProvider(courseProvider, domUtils, moduleDelegate, prefetchDelegate, filepoolProvider, sitesProvider, textUtils, timeUtils, utils, translate, loginHelper, courseOptionsDelegate, siteHomeProvider, eventsProvider, fileHelper, appProvider, fileProvider, injector) {
        this.courseProvider = courseProvider;
        this.domUtils = domUtils;
        this.moduleDelegate = moduleDelegate;
        this.prefetchDelegate = prefetchDelegate;
        this.filepoolProvider = filepoolProvider;
        this.sitesProvider = sitesProvider;
        this.textUtils = textUtils;
        this.timeUtils = timeUtils;
        this.utils = utils;
        this.translate = translate;
        this.loginHelper = loginHelper;
        this.courseOptionsDelegate = courseOptionsDelegate;
        this.siteHomeProvider = siteHomeProvider;
        this.eventsProvider = eventsProvider;
        this.fileHelper = fileHelper;
        this.appProvider = appProvider;
        this.fileProvider = fileProvider;
        this.injector = injector;
        this.courseDwnPromises = {};
    }
    /**
     * This function treats every module on the sections provided to load the handler data, treat completion
     * and navigate to a module page if required. It also returns if sections has content.
     *
     * @param {any[]} sections List of sections to treat modules.
     * @param {number} courseId Course ID of the modules.
     * @param {any[]} [completionStatus] List of completion status.
     * @return {boolean} Whether the sections have content.
     */
    CoreCourseHelperProvider.prototype.addHandlerDataForModules = function (sections, courseId, completionStatus) {
        var _this = this;
        var hasContent = false;
        sections.forEach(function (section) {
            if (!section || !_this.sectionHasContent(section) || !section.modules) {
                return;
            }
            hasContent = true;
            section.modules.forEach(function (module) {
                module.handlerData = _this.moduleDelegate.getModuleDataFor(module.modname, module, courseId, section.id);
                if (completionStatus && typeof completionStatus[module.id] != 'undefined') {
                    // Check if activity has completions and if it's marked.
                    module.completionstatus = completionStatus[module.id];
                    module.completionstatus.courseId = courseId;
                }
            });
        });
        return hasContent;
    };
    /**
     * Calculate the status of a section.
     *
     * @param {any} section Section to calculate its status. It can't be "All sections".
     * @param {number} courseId Course ID the section belongs to.
     * @param {boolean} [refresh] True if it shouldn't use module status cache (slower).
     * @return {Promise<any>} Promise resolved when the status is calculated.
     */
    CoreCourseHelperProvider.prototype.calculateSectionStatus = function (section, courseId, refresh) {
        var _this = this;
        if (section.id == __WEBPACK_IMPORTED_MODULE_14__course__["a" /* CoreCourseProvider */].ALL_SECTIONS_ID) {
            return Promise.reject(null);
        }
        // Get the status of this section.
        return this.prefetchDelegate.getModulesStatus(section.modules, courseId, section.id, refresh).then(function (result) {
            // Check if it's being downloaded.
            var downloadId = _this.getSectionDownloadId(section);
            if (_this.prefetchDelegate.isBeingDownloaded(downloadId)) {
                result.status = __WEBPACK_IMPORTED_MODULE_18__core_constants__["a" /* CoreConstants */].DOWNLOADING;
            }
            // Set this section data.
            section.showDownload = result.status === __WEBPACK_IMPORTED_MODULE_18__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED;
            section.showRefresh = result.status === __WEBPACK_IMPORTED_MODULE_18__core_constants__["a" /* CoreConstants */].OUTDATED;
            if (result.status !== __WEBPACK_IMPORTED_MODULE_18__core_constants__["a" /* CoreConstants */].DOWNLOADING || !_this.prefetchDelegate.isBeingDownloaded(section.id)) {
                section.isDownloading = false;
                section.total = 0;
            }
            else {
                // Section is being downloaded.
                section.isDownloading = true;
                _this.prefetchDelegate.setOnProgress(downloadId, function (data) {
                    section.count = data.count;
                    section.total = data.total;
                });
            }
            return result;
        });
    };
    /**
     * Calculate the status of a list of sections, setting attributes to determine the icons/data to be shown.
     *
     * @param {any[]} sections Sections to calculate their status.
     * @param {number} courseId Course ID the sections belong to.
     * @param {boolean} [refresh] True if it shouldn't use module status cache (slower).
     * @return {Promise<void>} Promise resolved when the states are calculated.
     */
    CoreCourseHelperProvider.prototype.calculateSectionsStatus = function (sections, courseId, refresh) {
        var _this = this;
        var promises = [];
        var allSectionsSection, allSectionsStatus;
        sections.forEach(function (section) {
            if (section.id === __WEBPACK_IMPORTED_MODULE_14__course__["a" /* CoreCourseProvider */].ALL_SECTIONS_ID) {
                // "All sections" section status is calculated using the status of the rest of sections.
                allSectionsSection = section;
                section.isCalculating = true;
            }
            else {
                section.isCalculating = true;
                promises.push(_this.calculateSectionStatus(section, courseId, refresh).then(function (result) {
                    // Calculate "All sections" status.
                    allSectionsStatus = _this.filepoolProvider.determinePackagesStatus(allSectionsStatus, result.status);
                }).finally(function () {
                    section.isCalculating = false;
                }));
            }
        });
        return Promise.all(promises).then(function () {
            if (allSectionsSection) {
                // Set "All sections" data.
                allSectionsSection.showDownload = allSectionsStatus === __WEBPACK_IMPORTED_MODULE_18__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED;
                allSectionsSection.showRefresh = allSectionsStatus === __WEBPACK_IMPORTED_MODULE_18__core_constants__["a" /* CoreConstants */].OUTDATED;
                allSectionsSection.isDownloading = allSectionsStatus === __WEBPACK_IMPORTED_MODULE_18__core_constants__["a" /* CoreConstants */].DOWNLOADING;
            }
        }).finally(function () {
            if (allSectionsSection) {
                allSectionsSection.isCalculating = false;
            }
        });
    };
    /**
     * Show a confirm and prefetch a course. It will retrieve the sections and the course options if not provided.
     * This function will set the icon to "spinner" when starting and it will also set it back to the initial icon if the
     * user cancels. All the other updates of the icon should be made when CoreEventsProvider.COURSE_STATUS_CHANGED is received.
     *
     * @param {any} iconData An object where to store the course icon. It will be stored with the name "prefetchCourseIcon".
     * @param {any} course Course to prefetch.
     * @param {any[]} [sections] List of course sections.
     * @param {CoreCourseOptionsHandlerToDisplay[]} courseHandlers List of course handlers.
     * @return {Promise<boolean>} Promise resolved with true when the download finishes, resolved with false if user doesn't
     *                            confirm, rejected if an error occurs.
     */
    CoreCourseHelperProvider.prototype.confirmAndPrefetchCourse = function (iconData, course, sections, courseHandlers) {
        var _this = this;
        var initialIcon = iconData.prefetchCourseIcon, siteId = this.sitesProvider.getCurrentSiteId();
        var promise;
        iconData.prefetchCourseIcon = 'spinner';
        // Get the sections first if needed.
        if (sections) {
            promise = Promise.resolve(sections);
        }
        else {
            promise = this.courseProvider.getSections(course.id, false, true);
        }
        return promise.then(function (sections) {
            // Confirm the download.
            return _this.confirmDownloadSizeSection(course.id, undefined, sections, true).then(function () {
                // User confirmed, get the course handlers if needed.
                if (courseHandlers) {
                    promise = Promise.resolve(courseHandlers);
                }
                else {
                    promise = _this.courseOptionsDelegate.getHandlersToDisplay(_this.injector, course);
                }
                return promise.then(function (handlers) {
                    // Now we have all the data, download the course.
                    return _this.prefetchCourse(course, sections, handlers, siteId);
                }).then(function () {
                    // Download successful.
                    return true;
                });
            }, function (error) {
                // User cancelled or there was an error calculating the size.
                iconData.prefetchCourseIcon = initialIcon;
                if (error) {
                    return Promise.reject(error);
                }
                return false;
            });
        });
    };
    /**
     * Confirm and prefetches a list of courses.
     *
     * @param {any[]} courses List of courses to download.
     * @param {Function} [onProgress] Function to call everytime a course is downloaded.
     * @return {Promise<boolean>} Resolved with true when downloaded, resolved with false if user cancels, rejected if error.
     */
    CoreCourseHelperProvider.prototype.confirmAndPrefetchCourses = function (courses, onProgress) {
        var _this = this;
        var siteId = this.sitesProvider.getCurrentSiteId();
        // Confirm the download without checking size because it could take a while.
        return this.domUtils.showConfirm(this.translate.instant('core.areyousure')).then(function () {
            var promises = [], total = courses.length;
            var count = 0;
            courses.forEach(function (course) {
                var subPromises = [];
                var sections, handlers, success = true;
                // Get the sections and the handlers.
                subPromises.push(_this.courseProvider.getSections(course.id, false, true).then(function (courseSections) {
                    sections = courseSections;
                }));
                subPromises.push(_this.courseOptionsDelegate.getHandlersToDisplay(_this.injector, course).then(function (cHandlers) {
                    handlers = cHandlers;
                }));
                promises.push(Promise.all(subPromises).then(function () {
                    return _this.prefetchCourse(course, sections, handlers, siteId);
                }).catch(function (error) {
                    success = false;
                    return Promise.reject(error);
                }).finally(function () {
                    // Course downloaded or failed, notify the progress.
                    count++;
                    if (onProgress) {
                        onProgress({ count: count, total: total, courseId: course.id, success: success });
                    }
                }));
            });
            if (onProgress) {
                // Notify the start of the download.
                onProgress({ count: 0, total: total, success: true });
            }
            return _this.utils.allPromises(promises).then(function () {
                return true;
            });
        }, function () {
            // User cancelled.
            return false;
        });
    };
    /**
     * Show confirmation dialog and then remove a module files.
     *
     * @param {any} module Module to remove the files.
     * @param {number} courseId Course ID the module belongs to.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseHelperProvider.prototype.confirmAndRemoveFiles = function (module, courseId) {
        var _this = this;
        return this.domUtils.showConfirm(this.translate.instant('core.course.confirmdeletemodulefiles')).then(function () {
            return _this.prefetchDelegate.removeModuleFiles(module, courseId);
        }).catch(function (error) {
            if (error) {
                _this.domUtils.showErrorModal(error);
            }
        });
    };
    /**
     * Calculate the size to download a section and show a confirm modal if needed.
     *
     * @param {number} courseId Course ID the section belongs to.
     * @param {any} [section] Section. If not provided, all sections.
     * @param {any[]} [sections] List of sections. Used when downloading all the sections.
     * @param {boolean} [alwaysConfirm] True to show a confirm even if the size isn't high, false otherwise.
     * @return {Promise<any>} Promise resolved if the user confirms or there's no need to confirm.
     */
    CoreCourseHelperProvider.prototype.confirmDownloadSizeSection = function (courseId, section, sections, alwaysConfirm) {
        var _this = this;
        var sizePromise;
        // Calculate the size of the download.
        if (section && section.id != __WEBPACK_IMPORTED_MODULE_14__course__["a" /* CoreCourseProvider */].ALL_SECTIONS_ID) {
            sizePromise = this.prefetchDelegate.getDownloadSize(section.modules, courseId);
        }
        else {
            var promises_1 = [], results_1 = {
                size: 0,
                total: true
            };
            sections.forEach(function (s) {
                if (s.id != __WEBPACK_IMPORTED_MODULE_14__course__["a" /* CoreCourseProvider */].ALL_SECTIONS_ID) {
                    promises_1.push(_this.prefetchDelegate.getDownloadSize(s.modules, courseId).then(function (sectionSize) {
                        results_1.total = results_1.total && sectionSize.total;
                        results_1.size += sectionSize.size;
                    }));
                }
            });
            sizePromise = Promise.all(promises_1).then(function () {
                return results_1;
            });
        }
        return sizePromise.then(function (size) {
            // Show confirm modal if needed.
            return _this.domUtils.confirmDownloadSize(size, undefined, undefined, undefined, undefined, alwaysConfirm);
        });
    };
    /**
     * Helper function to prefetch a module, showing a confirmation modal if the size is big.
     * This function is meant to be called from a context menu option. It will also modify some data like the prefetch icon.
     *
     * @param {any} instance The component instance that has the context menu. It should have prefetchStatusIcon and isDestroyed.
     * @param {any} module Module to be prefetched
     * @param {number} courseId Course ID the module belongs to.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseHelperProvider.prototype.contextMenuPrefetch = function (instance, module, courseId) {
        var _this = this;
        var initialIcon = instance.prefetchStatusIcon;
        var cancelled = false;
        instance.prefetchStatusIcon = 'spinner'; // Show spinner since this operation might take a while.
        // We need to call getDownloadSize, the package might have been updated.
        return this.prefetchDelegate.getModuleDownloadSize(module, courseId, true).then(function (size) {
            return _this.domUtils.confirmDownloadSize(size).catch(function () {
                // User hasn't confirmed, stop.
                cancelled = true;
                return Promise.reject(null);
            }).then(function () {
                return _this.prefetchDelegate.prefetchModule(module, courseId, true);
            });
        }).catch(function (error) {
            instance.prefetchStatusIcon = initialIcon;
            if (!instance.isDestroyed && !cancelled) {
                _this.domUtils.showErrorModalDefault(error, 'core.errordownloading', true);
            }
        });
    };
    /**
     * Determine the status of a list of courses.
     *
     * @param {any[]} courses Courses
     * @return {Promise<string>} Promise resolved with the status.
     */
    CoreCourseHelperProvider.prototype.determineCoursesStatus = function (courses) {
        var _this = this;
        // Get the status of each course.
        var promises = [], siteId = this.sitesProvider.getCurrentSiteId();
        courses.forEach(function (course) {
            promises.push(_this.courseProvider.getCourseStatus(course.id, siteId));
        });
        return Promise.all(promises).then(function (statuses) {
            // Now determine the status of the whole list.
            var status = statuses[0];
            for (var i = 1; i < statuses.length; i++) {
                status = _this.filepoolProvider.determinePackagesStatus(status, statuses[i]);
            }
            return status;
        });
    };
    /**
     * Convenience function to open a module main file, downloading the package if needed.
     * This is meant for modules like mod_resource.
     *
     * @param {any} module The module to download.
     * @param {number} courseId The course ID of the module.
     * @param {string} [component] The component to link the files to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {any[]} [files] List of files of the module. If not provided, use module.contents.
     * @param {string} [siteId] The site ID. If not defined, current site.
     * @return {Promise<any>} Resolved on success.
     */
    CoreCourseHelperProvider.prototype.downloadModuleAndOpenFile = function (module, courseId, component, componentId, files, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var promise;
        if (files) {
            promise = Promise.resolve(files);
        }
        else {
            promise = this.courseProvider.loadModuleContents(module, courseId).then(function () {
                files = module.contents;
            });
        }
        // Make sure that module contents are loaded.
        return promise.then(function () {
            if (!files || !files.length) {
                return Promise.reject(null);
            }
            return _this.sitesProvider.getSite(siteId);
        }).then(function (site) {
            var mainFile = files[0], fileUrl = _this.fileHelper.getFileUrl(mainFile);
            // Check if the file should be opened in browser.
            if (_this.fileHelper.shouldOpenInBrowser(mainFile)) {
                if (_this.appProvider.isOnline()) {
                    // Open in browser.
                    var fixedUrl = site.fixPluginfileURL(fileUrl).replace('&offline=1', '');
                    // Remove forcedownload when followed by another param.
                    fixedUrl = fixedUrl.replace(/forcedownload=\d+&/, '');
                    // Remove forcedownload when not followed by any param.
                    fixedUrl = fixedUrl.replace(/[\?|\&]forcedownload=\d+/, '');
                    _this.utils.openInBrowser(fixedUrl);
                    if (_this.fileProvider.isAvailable()) {
                        // Download the file if needed (file outdated or not downloaded).
                        // Download will be in background, don't return the promise.
                        _this.downloadModule(module, courseId, component, componentId, files, siteId);
                    }
                    return;
                }
                else {
                    // Not online, get the offline file. It will fail if not found.
                    return _this.filepoolProvider.getInternalUrlByUrl(siteId, fileUrl).then(function (path) {
                        return _this.utils.openFile(path);
                    }).catch(function (error) {
                        return Promise.reject(_this.translate.instant('core.networkerrormsg'));
                    });
                }
            }
            // File shouldn't be opened in browser. Download the module if it needs to be downloaded.
            return _this.downloadModuleWithMainFileIfNeeded(module, courseId, component, componentId, files, siteId)
                .then(function (result) {
                if (result.path.indexOf('http') === 0) {
                    return _this.utils.openOnlineFile(result.path).catch(function (error) {
                        // Error opening the file, some apps don't allow opening online files.
                        if (!_this.fileProvider.isAvailable()) {
                            return Promise.reject(error);
                        }
                        else if (result.status === __WEBPACK_IMPORTED_MODULE_18__core_constants__["a" /* CoreConstants */].DOWNLOADING) {
                            return Promise.reject(_this.translate.instant('core.erroropenfiledownloading'));
                        }
                        var promise;
                        if (result.status === __WEBPACK_IMPORTED_MODULE_18__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED) {
                            // Not downloaded, download it now and return the local file.
                            promise = _this.downloadModule(module, courseId, component, componentId, files, siteId).then(function () {
                                return _this.filepoolProvider.getInternalUrlByUrl(siteId, fileUrl);
                            });
                        }
                        else {
                            // File is outdated or stale and can't be opened in online, return the local URL.
                            promise = _this.filepoolProvider.getInternalUrlByUrl(siteId, fileUrl);
                        }
                        return promise.then(function (path) {
                            return _this.utils.openFile(path);
                        });
                    });
                }
                else {
                    return _this.utils.openFile(result.path);
                }
            });
        });
    };
    /**
     * Convenience function to download a module that has a main file and return the local file's path and other info.
     * This is meant for modules like mod_resource.
     *
     * @param {any} module The module to download.
     * @param {number} courseId The course ID of the module.
     * @param {string} [component] The component to link the files to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {any[]} [files] List of files of the module. If not provided, use module.contents.
     * @param {string} [siteId] The site ID. If not defined, current site.
     * @return {Promise<{fixedUrl: string, path: string, status: string}>} Promise resolved when done.
     */
    CoreCourseHelperProvider.prototype.downloadModuleWithMainFileIfNeeded = function (module, courseId, component, componentId, files, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (!files || !files.length) {
            // Module not valid, stop.
            return Promise.reject(null);
        }
        var mainFile = files[0], fileUrl = this.fileHelper.getFileUrl(mainFile), timemodified = this.fileHelper.getFileTimemodified(mainFile), result = {
            fixedUrl: undefined,
            path: undefined,
            status: undefined
        };
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var fixedUrl = site.fixPluginfileURL(fileUrl);
            result.fixedUrl = fixedUrl;
            if (_this.fileProvider.isAvailable()) {
                // The file system is available.
                return _this.filepoolProvider.getPackageStatus(siteId, component, componentId).then(function (status) {
                    result.status = status;
                    var isWifi = !_this.appProvider.isNetworkAccessLimited(), isOnline = _this.appProvider.isOnline();
                    if (status === __WEBPACK_IMPORTED_MODULE_18__core_constants__["a" /* CoreConstants */].DOWNLOADED) {
                        // Get the local file URL.
                        return _this.filepoolProvider.getInternalUrlByUrl(siteId, fileUrl);
                    }
                    else if (status === __WEBPACK_IMPORTED_MODULE_18__core_constants__["a" /* CoreConstants */].DOWNLOADING && !_this.appProvider.isDesktop()) {
                        // Return the online URL.
                        return fixedUrl;
                    }
                    else {
                        if (!isOnline && status === __WEBPACK_IMPORTED_MODULE_18__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED) {
                            // Not downloaded and we're offline, reject.
                            return Promise.reject(_this.translate.instant('core.networkerrormsg'));
                        }
                        return _this.filepoolProvider.shouldDownloadBeforeOpen(fixedUrl, mainFile.filesize).then(function () {
                            // Download and then return the local URL.
                            return _this.downloadModule(module, courseId, component, componentId, files, siteId).then(function () {
                                return _this.filepoolProvider.getInternalUrlByUrl(siteId, fileUrl);
                            });
                        }, function () {
                            // Start the download if in wifi, but return the URL right away so the file is opened.
                            if (isWifi && isOnline) {
                                _this.downloadModule(module, courseId, component, componentId, files, siteId);
                            }
                            if (!_this.fileHelper.isStateDownloaded(status) || isOnline) {
                                // Not downloaded or online, return the online URL.
                                return fixedUrl;
                            }
                            else {
                                // Outdated but offline, so we return the local URL. Use getUrlByUrl so it's added to the queue.
                                return _this.filepoolProvider.getUrlByUrl(siteId, fileUrl, component, componentId, timemodified, false, false, mainFile);
                            }
                        });
                    }
                }).then(function (path) {
                    result.path = path;
                    return result;
                });
            }
            else {
                // We use the live URL.
                result.path = fixedUrl;
                return result;
            }
        });
    };
    /**
     * Convenience function to download a module.
     *
     * @param {any} module The module to download.
     * @param {number} courseId The course ID of the module.
     * @param {string} [component] The component to link the files to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {any[]} [files] List of files of the module. If not provided, use module.contents.
     * @param {string} [siteId] The site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseHelperProvider.prototype.downloadModule = function (module, courseId, component, componentId, files, siteId) {
        var prefetchHandler = this.prefetchDelegate.getPrefetchHandlerFor(module);
        if (prefetchHandler) {
            // Use the prefetch handler to download the module.
            if (prefetchHandler.download) {
                return prefetchHandler.download(module, courseId);
            }
            else {
                return prefetchHandler.prefetch(module, courseId, true);
            }
        }
        // There's no prefetch handler for the module, just download the files.
        files = files || module.contents;
        return this.filepoolProvider.downloadOrPrefetchFiles(siteId, files, false, false, component, componentId);
    };
    /**
     * Fill the Context Menu for a certain module.
     *
     * @param {any} instance The component instance that has the context menu.
     * @param {any} module Module to be prefetched
     * @param {number} courseId Course ID the module belongs to.
     * @param {boolean} [invalidateCache] Invalidates the cache first.
     * @param {string} [component] Component of the module.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseHelperProvider.prototype.fillContextMenu = function (instance, module, courseId, invalidateCache, component) {
        var _this = this;
        return this.getModulePrefetchInfo(module, courseId, invalidateCache, component).then(function (moduleInfo) {
            instance.size = moduleInfo.size > 0 ? moduleInfo.sizeReadable : 0;
            instance.prefetchStatusIcon = moduleInfo.statusIcon;
            if (moduleInfo.status != __WEBPACK_IMPORTED_MODULE_18__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADABLE) {
                // Module is downloadable, get the text to display to prefetch.
                if (moduleInfo.downloadTime > 0) {
                    instance.prefetchText = _this.translate.instant('core.lastdownloaded') + ': ' + moduleInfo.downloadTimeReadable;
                }
                else {
                    // Module not downloaded, show a default text.
                    instance.prefetchText = _this.translate.instant('core.download');
                }
            }
            if (typeof instance.statusObserver == 'undefined' && component) {
                instance.statusObserver = _this.eventsProvider.on(__WEBPACK_IMPORTED_MODULE_3__providers_events__["a" /* CoreEventsProvider */].PACKAGE_STATUS_CHANGED, function (data) {
                    if (data.componentId == module.id && data.component == component) {
                        _this.fillContextMenu(instance, module, courseId, false, component);
                    }
                }, _this.sitesProvider.getCurrentSiteId());
            }
        });
    };
    /**
     * Get a course download promise (if any).
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Download promise, undefined if not found.
     */
    CoreCourseHelperProvider.prototype.getCourseDownloadPromise = function (courseId, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.courseDwnPromises[siteId] && this.courseDwnPromises[siteId][courseId];
    };
    /**
     * Get a course status icon.
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<string>} Promise resolved with the icon name.
     */
    CoreCourseHelperProvider.prototype.getCourseStatusIcon = function (courseId, siteId) {
        var _this = this;
        return this.courseProvider.getCourseStatus(courseId, siteId).then(function (status) {
            return _this.getCourseStatusIconFromStatus(status);
        });
    };
    /**
     * Get a course status icon from status.
     *
     * @module mm.core.course
     * @ngdoc method
     * @name $mmCourseHelper#getCourseStatusIconFromStatus
     * @param {String} status Course status.
     * @return {String}       Icon name.
     */
    CoreCourseHelperProvider.prototype.getCourseStatusIconFromStatus = function (status) {
        if (status == __WEBPACK_IMPORTED_MODULE_18__core_constants__["a" /* CoreConstants */].DOWNLOADED) {
            // Always show refresh icon, we cannot knew if there's anything new in course options.
            return 'refresh';
        }
        else if (status == __WEBPACK_IMPORTED_MODULE_18__core_constants__["a" /* CoreConstants */].DOWNLOADING) {
            return 'spinner';
        }
        else {
            return 'cloud-download';
        }
    };
    /**
     * Get the course ID from a module instance ID, showing an error message if it can't be retrieved.
     *
     * @param {number} id Instance ID.
     * @param {string} module Name of the module. E.g. 'glossary'.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<number>} Promise resolved with the module's course ID.
     */
    CoreCourseHelperProvider.prototype.getModuleCourseIdByInstance = function (id, module, siteId) {
        var _this = this;
        return this.courseProvider.getModuleBasicInfoByInstance(id, module, siteId).then(function (cm) {
            return cm.course;
        }).catch(function (error) {
            _this.domUtils.showErrorModalDefault(error, 'core.course.errorgetmodule', true);
            return Promise.reject(null);
        });
    };
    /**
     * Get prefetch info for a module.
     *
     * @param {any} module Module to get the info from.
     * @param {number} courseId Course ID the section belongs to.
     * @param {boolean} [invalidateCache] Invalidates the cache first.
     * @param {string} [component] Component of the module.
     * @return {Promise<CoreCourseModulePrefetchInfo>} Promise resolved with the info.
     */
    CoreCourseHelperProvider.prototype.getModulePrefetchInfo = function (module, courseId, invalidateCache, component) {
        var _this = this;
        var moduleInfo = {}, siteId = this.sitesProvider.getCurrentSiteId(), promises = [];
        if (invalidateCache) {
            this.prefetchDelegate.invalidateModuleStatusCache(module);
        }
        promises.push(this.prefetchDelegate.getModuleDownloadedSize(module, courseId).then(function (moduleSize) {
            moduleInfo.size = moduleSize;
            moduleInfo.sizeReadable = _this.textUtils.bytesToSize(moduleSize, 2);
        }));
        // @todo: Decide what to display instead of timemodified. Last check_updates?
        promises.push(this.prefetchDelegate.getModuleStatus(module, courseId).then(function (moduleStatus) {
            moduleInfo.status = moduleStatus;
            switch (moduleStatus) {
                case __WEBPACK_IMPORTED_MODULE_18__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED:
                    moduleInfo.statusIcon = 'cloud-download';
                    break;
                case __WEBPACK_IMPORTED_MODULE_18__core_constants__["a" /* CoreConstants */].DOWNLOADING:
                    moduleInfo.statusIcon = 'spinner';
                    break;
                case __WEBPACK_IMPORTED_MODULE_18__core_constants__["a" /* CoreConstants */].OUTDATED:
                    moduleInfo.statusIcon = 'refresh';
                    break;
                case __WEBPACK_IMPORTED_MODULE_18__core_constants__["a" /* CoreConstants */].DOWNLOADED:
                    if (!_this.prefetchDelegate.canCheckUpdates()) {
                        moduleInfo.statusIcon = 'refresh';
                        break;
                    }
                default:
                    moduleInfo.statusIcon = '';
                    break;
            }
        }));
        // Get the time it was downloaded (if it was downloaded).
        promises.push(this.filepoolProvider.getPackageData(siteId, component, module.id).then(function (data) {
            if (data && data.downloadTime && (data.status == __WEBPACK_IMPORTED_MODULE_18__core_constants__["a" /* CoreConstants */].OUTDATED || data.status == __WEBPACK_IMPORTED_MODULE_18__core_constants__["a" /* CoreConstants */].DOWNLOADED)) {
                var now = _this.timeUtils.timestamp();
                moduleInfo.downloadTime = data.downloadTime;
                if (now - data.downloadTime < 7 * 86400) {
                    moduleInfo.downloadTimeReadable = __WEBPACK_IMPORTED_MODULE_19_moment__(data.downloadTime * 1000).fromNow();
                }
                else {
                    moduleInfo.downloadTimeReadable = __WEBPACK_IMPORTED_MODULE_19_moment__(data.downloadTime * 1000).calendar();
                }
            }
        }).catch(function () {
            // Not downloaded.
            moduleInfo.downloadTime = 0;
        }));
        return Promise.all(promises).then(function () {
            return moduleInfo;
        });
    };
    /**
     * Get the download ID of a section. It's used to interact with CoreCourseModulePrefetchDelegate.
     *
     * @param {any} section Section.
     * @return {string} Section download ID.
     */
    CoreCourseHelperProvider.prototype.getSectionDownloadId = function (section) {
        return 'Section-' + section.id;
    };
    /**
     * Navigate to a module.
     *
     * @param {number} moduleId Module's ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [courseId] Course ID. If not defined we'll try to retrieve it from the site.
     * @param {number} [sectionId] Section the module belongs to. If not defined we'll try to retrieve it from the site.
     * @return {Promise<void>} Promise resolved when done.
     */
    CoreCourseHelperProvider.prototype.navigateToModule = function (moduleId, siteId, courseId, sectionId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var modal = this.domUtils.showModalLoading();
        var promise, site;
        if (courseId && sectionId) {
            // No need to retrieve more data.
            promise = Promise.resolve();
        }
        else if (!courseId) {
            // We don't have courseId.
            promise = this.courseProvider.getModuleBasicInfo(moduleId, siteId).then(function (module) {
                courseId = module.course;
                sectionId = module.section;
            });
        }
        else {
            // We don't have sectionId but we have courseId.
            promise = this.courseProvider.getModuleSectionId(moduleId, siteId).then(function (id) {
                sectionId = id;
            });
        }
        return promise.then(function () {
            // Get the site.
            return _this.sitesProvider.getSite(siteId);
        }).then(function (s) {
            site = s;
            // Get the module.
            return _this.courseProvider.getModule(moduleId, courseId, sectionId, false, false, siteId);
        }).then(function (module) {
            var params = {
                course: { id: courseId },
                module: module,
                sectionId: sectionId
            };
            module.handlerData = _this.moduleDelegate.getModuleDataFor(module.modname, module, courseId, sectionId);
            if (courseId == site.getSiteHomeId()) {
                // Check if site home is available.
                return _this.siteHomeProvider.isAvailable().then(function () {
                    _this.loginHelper.redirect('CoreSiteHomeIndexPage', params, siteId);
                });
            }
            else {
                _this.loginHelper.redirect('CoreCourseSectionPage', params, siteId);
            }
        }).catch(function (error) {
            _this.domUtils.showErrorModalDefault(error, 'core.course.errorgetmodule', true);
        }).finally(function () {
            modal.dismiss();
        });
    };
    /**
     * Open a module.
     *
     * @param {NavController} navCtrl The NavController to use.
     * @param {any} module The module to open.
     * @param {number} courseId The course ID of the module.
     * @param {number} [sectionId] The section ID of the module.
     * @param {boolean} True if module can be opened, false otherwise.
     */
    CoreCourseHelperProvider.prototype.openModule = function (navCtrl, module, courseId, sectionId) {
        if (!module.handlerData) {
            module.handlerData = this.moduleDelegate.getModuleDataFor(module.modname, module, courseId, sectionId);
        }
        if (module.handlerData && module.handlerData.action) {
            module.handlerData.action(new Event('click'), navCtrl, module, courseId, { animate: false });
            return true;
        }
        return false;
    };
    /**
     * Prefetch all the activities in a course and also the course addons.
     *
     * @param {any} course The course to prefetch.
     * @param {any[]} sections List of course sections.
     * @param {CoreCourseOptionsHandlerToDisplay[]} courseHandlers List of course options handlers.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise}                Promise resolved when the download finishes.
     */
    CoreCourseHelperProvider.prototype.prefetchCourse = function (course, sections, courseHandlers, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (this.courseDwnPromises[siteId] && this.courseDwnPromises[siteId][course.id]) {
            // There's already a download ongoing for this course, return the promise.
            return this.courseDwnPromises[siteId][course.id];
        }
        else if (!this.courseDwnPromises[siteId]) {
            this.courseDwnPromises[siteId] = {};
        }
        // First of all, mark the course as being downloaded.
        this.courseDwnPromises[siteId][course.id] = this.courseProvider.setCourseStatus(course.id, __WEBPACK_IMPORTED_MODULE_18__core_constants__["a" /* CoreConstants */].DOWNLOADING, siteId).then(function () {
            var promises = [];
            var allSectionsSection = sections[0];
            // Prefetch all the sections. If the first section is "All sections", use it. Otherwise, use a fake "All sections".
            if (sections[0].id != __WEBPACK_IMPORTED_MODULE_14__course__["a" /* CoreCourseProvider */].ALL_SECTIONS_ID) {
                allSectionsSection = { id: __WEBPACK_IMPORTED_MODULE_14__course__["a" /* CoreCourseProvider */].ALL_SECTIONS_ID };
            }
            promises.push(_this.prefetchSection(allSectionsSection, course.id, sections));
            // Prefetch course options.
            courseHandlers.forEach(function (handler) {
                if (handler.prefetch) {
                    promises.push(handler.prefetch(course));
                }
            });
            return _this.utils.allPromises(promises);
        }).then(function () {
            // Download success, mark the course as downloaded.
            return _this.courseProvider.setCourseStatus(course.id, __WEBPACK_IMPORTED_MODULE_18__core_constants__["a" /* CoreConstants */].DOWNLOADED, siteId);
        }).catch(function (error) {
            // Error, restore previous status.
            return _this.courseProvider.setCoursePreviousStatus(course.id, siteId).then(function () {
                return Promise.reject(error);
            });
        }).finally(function () {
            delete _this.courseDwnPromises[siteId][course.id];
        });
        return this.courseDwnPromises[siteId][course.id];
    };
    /**
     * Helper function to prefetch a module, showing a confirmation modal if the size is big
     * and invalidating contents if refreshing.
     *
     * @param {handler} handler Prefetch handler to use. Must implement 'prefetch' and 'invalidateContent'.
     * @param {any} module Module to download.
     * @param {any} size Object containing size to download (in bytes) and a boolean to indicate if its totally calculated.
     * @param {number} courseId Course ID of the module.
     * @param {boolean} [refresh] True if refreshing, false otherwise.
     * @return {Promise<any>} Promise resolved when downloaded.
     */
    CoreCourseHelperProvider.prototype.prefetchModule = function (handler, module, size, courseId, refresh) {
        // Show confirmation if needed.
        return this.domUtils.confirmDownloadSize(size).then(function () {
            // Invalidate content if refreshing and download the data.
            var promise = refresh ? handler.invalidateContent(module.id, courseId) : Promise.resolve();
            return promise.catch(function () {
                // Ignore errors.
            }).then(function () {
                return handler.prefetch(module, courseId, true);
            });
        });
    };
    /**
     * Prefetch one section or all the sections.
     * If the section is "All sections" it will prefetch all the sections.
     *
     * @param {any} section Section.
     * @param {number} courseId Course ID the section belongs to.
     * @param {any[]} [sections] List of sections. Used when downloading all the sections.
     * @return {Promise<any>} Promise resolved when the prefetch is finished.
     */
    CoreCourseHelperProvider.prototype.prefetchSection = function (section, courseId, sections) {
        var _this = this;
        if (section.id != __WEBPACK_IMPORTED_MODULE_14__course__["a" /* CoreCourseProvider */].ALL_SECTIONS_ID) {
            // Download only this section.
            return this.prefetchSingleSectionIfNeeded(section, courseId).then(function () {
                // Calculate the status of the section that finished.
                return _this.calculateSectionStatus(section, courseId);
            });
        }
        else {
            // Download all the sections except "All sections".
            var promises_2 = [];
            var allSectionsStatus_1;
            section.isDownloading = true;
            sections.forEach(function (section) {
                if (section.id != __WEBPACK_IMPORTED_MODULE_14__course__["a" /* CoreCourseProvider */].ALL_SECTIONS_ID) {
                    promises_2.push(_this.prefetchSingleSectionIfNeeded(section, courseId).then(function () {
                        // Calculate the status of the section that finished.
                        return _this.calculateSectionStatus(section, courseId).then(function (result) {
                            // Calculate "All sections" status.
                            allSectionsStatus_1 = _this.filepoolProvider.determinePackagesStatus(allSectionsStatus_1, result.status);
                        });
                    }));
                }
            });
            return this.utils.allPromises(promises_2).then(function () {
                // Set "All sections" data.
                section.showDownload = allSectionsStatus_1 === __WEBPACK_IMPORTED_MODULE_18__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED;
                section.showRefresh = allSectionsStatus_1 === __WEBPACK_IMPORTED_MODULE_18__core_constants__["a" /* CoreConstants */].OUTDATED;
                section.isDownloading = allSectionsStatus_1 === __WEBPACK_IMPORTED_MODULE_18__core_constants__["a" /* CoreConstants */].DOWNLOADING;
            }).finally(function () {
                section.isDownloading = false;
            });
        }
    };
    /**
     * Prefetch a certain section if it needs to be prefetched.
     * If the section is "All sections" it will be ignored.
     *
     * @param {any} section Section to prefetch.
     * @param {number} courseId Course ID the section belongs to.
     * @return {Promise<any>} Promise resolved when the section is prefetched.
     */
    CoreCourseHelperProvider.prototype.prefetchSingleSectionIfNeeded = function (section, courseId) {
        var _this = this;
        if (section.id == __WEBPACK_IMPORTED_MODULE_14__course__["a" /* CoreCourseProvider */].ALL_SECTIONS_ID) {
            return Promise.resolve();
        }
        section.isDownloading = true;
        // Validate the section needs to be downloaded and calculate amount of modules that need to be downloaded.
        return this.prefetchDelegate.getModulesStatus(section.modules, courseId, section.id).then(function (result) {
            if (result.status == __WEBPACK_IMPORTED_MODULE_18__core_constants__["a" /* CoreConstants */].DOWNLOADED || result.status == __WEBPACK_IMPORTED_MODULE_18__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADABLE) {
                // Section is downloaded or not downloadable, nothing to do.
                return;
            }
            return _this.prefetchSingleSection(section, result, courseId);
        }, function (error) {
            section.isDownloading = false;
            return Promise.reject(error);
        });
    };
    /**
     * Start or restore the prefetch of a section.
     * If the section is "All sections" it will be ignored.
     *
     * @param {any} section Section to download.
     * @param {any} result Result of CoreCourseModulePrefetchDelegate.getModulesStatus for this section.
     * @param {number} courseId Course ID the section belongs to.
     * @return {Promise<any>} Promise resolved when the section has been prefetched.
     */
    CoreCourseHelperProvider.prototype.prefetchSingleSection = function (section, result, courseId) {
        if (section.id == __WEBPACK_IMPORTED_MODULE_14__course__["a" /* CoreCourseProvider */].ALL_SECTIONS_ID) {
            return Promise.resolve();
        }
        if (section.total > 0) {
            // Already being downloaded.
            return Promise.resolve();
        }
        // We only download modules with status notdownloaded, downloading or outdated.
        var modules = result[__WEBPACK_IMPORTED_MODULE_18__core_constants__["a" /* CoreConstants */].OUTDATED].concat(result[__WEBPACK_IMPORTED_MODULE_18__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED])
            .concat(result[__WEBPACK_IMPORTED_MODULE_18__core_constants__["a" /* CoreConstants */].DOWNLOADING]), downloadId = this.getSectionDownloadId(section);
        section.isDownloading = true;
        // Prefetch all modules to prevent incoeherences in download count and to download stale data not marked as outdated.
        return this.prefetchDelegate.prefetchModules(downloadId, modules, courseId, function (data) {
            section.count = data.count;
            section.total = data.total;
        });
    };
    /**
     * Check if a section has content.
     *
     * @param {any} section Section to check.
     * @return {boolean} Whether the section has content.
     */
    CoreCourseHelperProvider.prototype.sectionHasContent = function (section) {
        if (section.id == __WEBPACK_IMPORTED_MODULE_14__course__["a" /* CoreCourseProvider */].ALL_SECTIONS_ID || section.hiddenbynumsections) {
            return false;
        }
        return (typeof section.availabilityinfo != 'undefined' && section.availabilityinfo != '') ||
            section.summary != '' || (section.modules && section.modules.length > 0);
    };
    CoreCourseHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_14__course__["a" /* CoreCourseProvider */], __WEBPACK_IMPORTED_MODULE_8__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_15__module_delegate__["a" /* CoreCourseModuleDelegate */], __WEBPACK_IMPORTED_MODULE_16__module_prefetch_delegate__["a" /* CoreCourseModulePrefetchDelegate */],
            __WEBPACK_IMPORTED_MODULE_5__providers_filepool__["a" /* CoreFilepoolProvider */], __WEBPACK_IMPORTED_MODULE_7__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_9__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_10__providers_utils_time__["a" /* CoreTimeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_11__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_17__core_login_providers_helper__["a" /* CoreLoginHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_12__options_delegate__["a" /* CoreCourseOptionsDelegate */], __WEBPACK_IMPORTED_MODULE_13__core_sitehome_providers_sitehome__["a" /* CoreSiteHomeProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_file_helper__["a" /* CoreFileHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_file__["a" /* CoreFileProvider */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["C" /* Injector */]])
    ], CoreCourseHelperProvider);
    return CoreCourseHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),
/* 30 */,
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCoursesProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(3);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Service that provides some features regarding lists of courses and categories.
 */
var CoreCoursesProvider = /** @class */ (function () {
    function CoreCoursesProvider(logger, sitesProvider) {
        this.sitesProvider = sitesProvider;
        this.ROOT_CACHE_KEY = 'mmCourses:';
        this.logger = logger.getInstance('CoreCoursesProvider');
    }
    CoreCoursesProvider_1 = CoreCoursesProvider;
    /**
     * Get categories. They can be filtered by id.
     *
     * @param {number} categoryId Category ID to get.
     * @param {boolean} [addSubcategories] If it should add subcategories to the list.
     * @param {string} [siteId] Site to get the courses from. If not defined, use current site.
     * @return {Promise<any[]>} Promise resolved with the categories.
     */
    CoreCoursesProvider.prototype.getCategories = function (categoryId, addSubcategories, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            // Get parent when id is the root category.
            var criteriaKey = categoryId == 0 ? 'parent' : 'id', data = {
                criteria: [
                    { key: criteriaKey, value: categoryId }
                ],
                addsubcategories: addSubcategories ? 1 : 0
            }, preSets = {
                cacheKey: _this.getCategoriesCacheKey(categoryId, addSubcategories)
            };
            return site.read('core_course_get_categories', data, preSets);
        });
    };
    /**
     * Get cache key for get categories methods WS call.
     *
     * @param {number} categoryId Category ID to get.
     * @param {boolean} [addSubcategories] If add subcategories to the list.
     * @return {string} Cache key.
     */
    CoreCoursesProvider.prototype.getCategoriesCacheKey = function (categoryId, addSubcategories) {
        return this.ROOT_CACHE_KEY + 'categories:' + categoryId + ':' + !!addSubcategories;
    };
    /**
     * Given a list of course IDs to get course admin and nav options, return the list of courseIds to use.
     *
     * @param {number[]} courseIds Course IDs.
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise}            Promise resolved with the list of course IDs.
     */
    CoreCoursesProvider.prototype.getCourseIdsForAdminAndNavOptions = function (courseIds, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var siteHomeId = site.getSiteHomeId();
            if (courseIds.length == 1) {
                // Only 1 course, check if it belongs to the user courses. If so, use all user courses.
                return _this.getUserCourses(true, siteId).then(function (courses) {
                    var courseId = courseIds[0];
                    var useAllCourses = false;
                    if (courseId == siteHomeId) {
                        // It's site home, use all courses.
                        useAllCourses = true;
                    }
                    else {
                        for (var i = 0; i < courses.length; i++) {
                            if (courses[i].id == courseId) {
                                useAllCourses = true;
                                break;
                            }
                        }
                    }
                    if (useAllCourses) {
                        // User is enrolled, retrieve all the courses.
                        courseIds = courses.map(function (course) {
                            return course.id;
                        });
                        // Always add the site home ID.
                        courseIds.push(siteHomeId);
                    }
                    return courseIds;
                }).catch(function () {
                    // Ignore errors.
                    return courseIds;
                });
            }
            else {
                return courseIds;
            }
        });
    };
    /**
     * Check if My Courses is disabled in a certain site.
     *
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<boolean>} Promise resolved with true if disabled, rejected or resolved with false otherwise.
     */
    CoreCoursesProvider.prototype.isMyCoursesDisabled = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.isMyCoursesDisabledInSite(site);
        });
    };
    /**
     * Check if My Courses is disabled in a certain site.
     *
     * @param {CoreSite} [site] Site. If not defined, use current site.
     * @return {boolean} Whether it's disabled.
     */
    CoreCoursesProvider.prototype.isMyCoursesDisabledInSite = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.isFeatureDisabled('$mmSideMenuDelegate_mmCourses');
    };
    /**
     * Check if Search Courses is disabled in a certain site.
     *
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<boolean>} Promise resolved with true if disabled, rejected or resolved with false otherwise.
     */
    CoreCoursesProvider.prototype.isSearchCoursesDisabled = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.isSearchCoursesDisabledInSite(site);
        });
    };
    /**
     * Check if Search Courses is disabled in a certain site.
     *
     * @param {CoreSite} [site] Site. If not defined, use current site.
     * @return {boolean} Whether it's disabled.
     */
    CoreCoursesProvider.prototype.isSearchCoursesDisabledInSite = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.isFeatureDisabled('$mmCoursesDelegate_search');
    };
    /**
     * Get course.
     *
     * @param {number} id ID of the course to get.
     * @param {string} [siteId] Site to get the courses from. If not defined, use current site.
     * @return {Promise<any>} Promise resolved with the course.
     */
    CoreCoursesProvider.prototype.getCourse = function (id, siteId) {
        return this.getCourses([id], siteId).then(function (courses) {
            if (courses && courses.length > 0) {
                return courses[0];
            }
            return Promise.reject(null);
        });
    };
    /**
     * Get the enrolment methods from a course.
     *
     * @param {number} id ID of the course.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any[]} Promise resolved with the methods.
     */
    CoreCoursesProvider.prototype.getCourseEnrolmentMethods = function (id, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                courseid: id
            }, preSets = {
                cacheKey: _this.getCourseEnrolmentMethodsCacheKey(id)
            };
            return site.read('core_enrol_get_course_enrolment_methods', params, preSets);
        });
    };
    /**
     * Get cache key for get course enrolment methods WS call.
     *
     * @param {number} id Course ID.
     * @return {string} Cache key.
     */
    CoreCoursesProvider.prototype.getCourseEnrolmentMethodsCacheKey = function (id) {
        return this.ROOT_CACHE_KEY + 'enrolmentmethods:' + id;
    };
    /**
     * Get info from a course guest enrolment method.
     *
     * @param {number} instanceId Guest instance ID.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the info is retrieved.
     */
    CoreCoursesProvider.prototype.getCourseGuestEnrolmentInfo = function (instanceId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                instanceid: instanceId
            }, preSets = {
                cacheKey: _this.getCourseGuestEnrolmentInfoCacheKey(instanceId)
            };
            return site.read('enrol_guest_get_instance_info', params, preSets).then(function (response) {
                return response.instanceinfo;
            });
        });
    };
    /**
     * Get cache key for get course guest enrolment methods WS call.
     *
     * @param {number} instanceId Guest instance ID.
     * @return {string} Cache key.
     */
    CoreCoursesProvider.prototype.getCourseGuestEnrolmentInfoCacheKey = function (instanceId) {
        return this.ROOT_CACHE_KEY + 'guestinfo:' + instanceId;
    };
    /**
     * Get courses.
     * Warning: if the user doesn't have permissions to view some of the courses passed the WS call will fail.
     * The user must be able to view ALL the courses passed.
     *
     * @param {number[]} ids List of IDs of the courses to get.
     * @param {string} [siteId] Site to get the courses from. If not defined, use current site.
     * @return {Promise<any[]>}  Promise resolved with the courses.
     */
    CoreCoursesProvider.prototype.getCourses = function (ids, siteId) {
        var _this = this;
        if (!Array.isArray(ids)) {
            return Promise.reject(null);
        }
        else if (ids.length === 0) {
            return Promise.resolve([]);
        }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var data = {
                options: {
                    ids: ids
                }
            }, preSets = {
                cacheKey: _this.getCoursesCacheKey(ids)
            };
            return site.read('core_course_get_courses', data, preSets);
        });
    };
    /**
     * Get cache key for get courses WS call.
     *
     * @param {number[]} ids Courses IDs.
     * @return {string} Cache key.
     */
    CoreCoursesProvider.prototype.getCoursesCacheKey = function (ids) {
        return this.ROOT_CACHE_KEY + 'course:' + JSON.stringify(ids);
    };
    /**
     * Get courses. They can be filtered by field.
     *
     * @param {string} [field] The field to search. Can be left empty for all courses or:
     *                             id: course id.
     *                             ids: comma separated course ids.
     *                             shortname: course short name.
     *                             idnumber: course id number.
     *                             category: category id the course belongs to.
     * @param {any} [value] The value to match.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any[]>} Promise resolved with the courses.
     */
    CoreCoursesProvider.prototype.getCoursesByField = function (field, value, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var data = {
                field: field || '',
                value: field ? value : ''
            }, preSets = {
                cacheKey: _this.getCoursesByFieldCacheKey(field, value)
            };
            return site.read('core_course_get_courses_by_field', data, preSets).then(function (courses) {
                if (courses.courses) {
                    // Courses will be sorted using sortorder if avalaible.
                    return courses.courses.sort(function (a, b) {
                        if (typeof a.sortorder == 'undefined' && typeof b.sortorder == 'undefined') {
                            return b.id - a.id;
                        }
                        if (typeof a.sortorder == 'undefined') {
                            return 1;
                        }
                        if (typeof b.sortorder == 'undefined') {
                            return -1;
                        }
                        return a.sortorder - b.sortorder;
                    });
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get cache key for get courses WS call.
     *
     * @param {string} [field] The field to search.
     * @param {any} [value] The value to match.
     * @return {string} Cache key.
     */
    CoreCoursesProvider.prototype.getCoursesByFieldCacheKey = function (field, value) {
        field = field || '';
        value = field ? value : '';
        return this.ROOT_CACHE_KEY + 'coursesbyfield:' + field + ':' + value;
    };
    /**
     * Check if get courses by field WS is available.
     *
     * @return {boolean} Whether get courses by field is available.
     */
    CoreCoursesProvider.prototype.isGetCoursesByFieldAvailable = function () {
        return this.sitesProvider.wsAvailableInCurrentSite('core_course_get_courses_by_field');
    };
    /**
     * Get the navigation and administration options for the given courses.
     *
     * @param {number[]} courseIds IDs of courses to get.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<{navOptions: any, admOptions: any}>} Promise resolved with the options for each course.
     */
    CoreCoursesProvider.prototype.getCoursesAdminAndNavOptions = function (courseIds, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Get the list of courseIds to use based on the param.
        return this.getCourseIdsForAdminAndNavOptions(courseIds, siteId).then(function (courseIds) {
            var promises = [];
            var navOptions, admOptions;
            // Get user navigation and administration options.
            promises.push(_this.getUserNavigationOptions(courseIds, siteId).catch(function () {
                // Couldn't get it, return empty options.
                return {};
            }).then(function (options) {
                navOptions = options;
            }));
            promises.push(_this.getUserAdministrationOptions(courseIds, siteId).catch(function () {
                // Couldn't get it, return empty options.
                return {};
            }).then(function (options) {
                admOptions = options;
            }));
            return Promise.all(promises).then(function () {
                return { navOptions: navOptions, admOptions: admOptions };
            });
        });
    };
    /**
     * Get the common part of the cache keys for user administration options WS calls.
     *
     * @return {string} Cache key.
     */
    CoreCoursesProvider.prototype.getUserAdministrationOptionsCommonCacheKey = function () {
        return this.ROOT_CACHE_KEY + 'administrationOptions:';
    };
    /**
     * Get cache key for get user administration options WS call.
     *
     * @param {number[]} courseIds IDs of courses to get.
     * @return {string} Cache key.
     */
    CoreCoursesProvider.prototype.getUserAdministrationOptionsCacheKey = function (courseIds) {
        return this.getUserAdministrationOptionsCommonCacheKey() + courseIds.join(',');
    };
    /**
     * Get user administration options for a set of courses.
     *
     * @param {number[]} courseIds IDs of courses to get.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with administration options for each course.
     */
    CoreCoursesProvider.prototype.getUserAdministrationOptions = function (courseIds, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                courseids: courseIds
            }, preSets = {
                cacheKey: _this.getUserAdministrationOptionsCacheKey(courseIds)
            };
            return site.read('core_course_get_user_administration_options', params, preSets).then(function (response) {
                // Format returned data.
                return _this.formatUserAdminOrNavOptions(response.courses);
            });
        });
    };
    /**
     * Get the common part of the cache keys for user navigation options WS calls.
     *
     * @param {number[]} courseIds IDs of courses to get.
     * @return {string} Cache key.
     */
    CoreCoursesProvider.prototype.getUserNavigationOptionsCommonCacheKey = function () {
        return this.ROOT_CACHE_KEY + 'navigationOptions:';
    };
    /**
     * Get cache key for get user navigation options WS call.
     *
     * @return {string} Cache key.
     */
    CoreCoursesProvider.prototype.getUserNavigationOptionsCacheKey = function (courseIds) {
        return this.getUserNavigationOptionsCommonCacheKey() + courseIds.join(',');
    };
    /**
     * Get user navigation options for a set of courses.
     *
     * @param {number[]} courseIds IDs of courses to get.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with navigation options for each course.
     */
    CoreCoursesProvider.prototype.getUserNavigationOptions = function (courseIds, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                courseids: courseIds
            }, preSets = {
                cacheKey: _this.getUserNavigationOptionsCacheKey(courseIds)
            };
            return site.read('core_course_get_user_navigation_options', params, preSets).then(function (response) {
                // Format returned data.
                return _this.formatUserAdminOrNavOptions(response.courses);
            });
        });
    };
    /**
     * Format user navigation or administration options.
     *
     * @param {any[]} courses Navigation or administration options for each course.
     * @return {any} Formatted options.
     */
    CoreCoursesProvider.prototype.formatUserAdminOrNavOptions = function (courses) {
        var result = {};
        courses.forEach(function (course) {
            var options = {};
            if (course.options) {
                course.options.forEach(function (option) {
                    options[option.name] = option.available;
                });
            }
            result[course.id] = options;
        });
        return result;
    };
    /**
     * Get a course the user is enrolled in. This function relies on getUserCourses.
     * preferCache=true will try to speed up the response, but the data returned might not be updated.
     *
     * @param {number} id ID of the course to get.
     * @param {boolean} [preferCache] True if shouldn't call WS if data is cached, false otherwise.
     * @param {string} [siteId] Site to get the courses from. If not defined, use current site.
     * @return {Promise<any>} Promise resolved with the course.
     */
    CoreCoursesProvider.prototype.getUserCourse = function (id, preferCache, siteId) {
        if (!id) {
            return Promise.reject(null);
        }
        return this.getUserCourses(preferCache, siteId).then(function (courses) {
            var course;
            for (var i in courses) {
                if (courses[i].id == id) {
                    course = courses[i];
                    break;
                }
            }
            return course ? course : Promise.reject(null);
        });
    };
    /**
     * Get user courses.
     *
     * @param {boolean} [preferCache] True if shouldn't call WS if data is cached, false otherwise.
     * @param {string} [siteId] Site to get the courses from. If not defined, use current site.
     * @return {Promise<any[]>} Promise resolved with the courses.
     */
    CoreCoursesProvider.prototype.getUserCourses = function (preferCache, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var userId = site.getUserId(), data = {
                userid: userId
            }, preSets = {
                cacheKey: _this.getUserCoursesCacheKey(),
                omitExpires: !!preferCache
            };
            return site.read('core_enrol_get_users_courses', data, preSets);
        });
    };
    /**
     * Get cache key for get user courses WS call.
     *
     * @return {string} Cache key.
     */
    CoreCoursesProvider.prototype.getUserCoursesCacheKey = function () {
        return this.ROOT_CACHE_KEY + 'usercourses';
    };
    /**
     * Invalidates get categories WS call.
     *
     * @param {number} categoryId Category ID to get.
     * @param {boolean} [addSubcategories] If it should add subcategories to the list.
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesProvider.prototype.invalidateCategories = function (categoryId, addSubcategories, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getCategoriesCacheKey(categoryId, addSubcategories));
        });
    };
    /**
     * Invalidates get course WS call.
     *
     * @param {number} id Course ID.
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesProvider.prototype.invalidateCourse = function (id, siteId) {
        return this.invalidateCourses([id], siteId);
    };
    /**
     * Invalidates get course enrolment methods WS call.
     *
     * @param {number} id Course ID.
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesProvider.prototype.invalidateCourseEnrolmentMethods = function (id, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getCourseEnrolmentMethodsCacheKey(id));
        });
    };
    /**
     * Invalidates get course guest enrolment info WS call.
     *
     * @param {number} instanceId Guest instance ID.
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesProvider.prototype.invalidateCourseGuestEnrolmentInfo = function (instanceId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getCourseGuestEnrolmentInfoCacheKey(instanceId));
        });
    };
    /**
     * Invalidates the navigation and administration options for the given courses.
     *
     * @param {number[]} courseIds IDs of courses to get.
     * @param {string} [siteId] Site ID to invalidate. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesProvider.prototype.invalidateCoursesAdminAndNavOptions = function (courseIds, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.getCourseIdsForAdminAndNavOptions(courseIds, siteId).then(function (ids) {
            var promises = [];
            promises.push(_this.invalidateUserAdministrationOptionsForCourses(ids, siteId));
            promises.push(_this.invalidateUserNavigationOptionsForCourses(ids, siteId));
            return Promise.all(promises);
        });
    };
    /**
     * Invalidates get courses WS call.
     *
     * @param {number[]} ids Courses IDs.
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesProvider.prototype.invalidateCourses = function (ids, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getCoursesCacheKey(ids));
        });
    };
    /**
     * Invalidates get courses by field WS call.
     *
     * @param {string} [field] See getCoursesByField for info.
     * @param {any} [value] The value to match.
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesProvider.prototype.invalidateCoursesByField = function (field, value, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getCoursesByFieldCacheKey(field, value));
        });
    };
    /**
     * Invalidates all user administration options.
     *
     * @param {string} [siteId] Site ID to invalidate. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesProvider.prototype.invalidateUserAdministrationOptions = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getUserAdministrationOptionsCommonCacheKey());
        });
    };
    /**
     * Invalidates user administration options for certain courses.
     *
     * @param {number[]} courseIds IDs of courses.
     * @param {string} [siteId] Site ID to invalidate. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesProvider.prototype.invalidateUserAdministrationOptionsForCourses = function (courseIds, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getUserAdministrationOptionsCacheKey(courseIds));
        });
    };
    /**
     * Invalidates get user courses WS call.
     *
     * @param {string} [siteId] Site ID to invalidate. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesProvider.prototype.invalidateUserCourses = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getUserCoursesCacheKey());
        });
    };
    /**
     * Invalidates all user navigation options.
     *
     * @param {string} [siteId] Site ID to invalidate. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesProvider.prototype.invalidateUserNavigationOptions = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getUserNavigationOptionsCommonCacheKey());
        });
    };
    /**
     * Invalidates user navigation options for certain courses.
     *
     * @param {number[]} courseIds IDs of courses.
     * @param {string} [siteId] Site ID to invalidate. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesProvider.prototype.invalidateUserNavigationOptionsForCourses = function (courseIds, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getUserNavigationOptionsCacheKey(courseIds));
        });
    };
    /**
     * Check if WS to retrieve guest enrolment data is available.
     *
     * @return {boolean} Whether guest WS is available.
     */
    CoreCoursesProvider.prototype.isGuestWSAvailable = function () {
        var currentSite = this.sitesProvider.getCurrentSite();
        return currentSite && currentSite.wsAvailable('enrol_guest_get_instance_info');
    };
    /**
     * Search courses.
     *
     * @param {string} text Text to search.
     * @param {number} [page=0] Page to get.
     * @param {number} [perPage] Number of courses per page. Defaults to CoreCoursesProvider.SEARCH_PER_PAGE.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<{total: number, courses: any[]}>} Promise resolved with the courses and the total of matches.
     */
    CoreCoursesProvider.prototype.search = function (text, page, perPage, siteId) {
        if (page === void 0) { page = 0; }
        perPage = perPage || CoreCoursesProvider_1.SEARCH_PER_PAGE;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                criterianame: 'search',
                criteriavalue: text,
                page: page,
                perpage: perPage
            }, preSets = {
                getFromCache: false
            };
            return site.read('core_course_search_courses', params, preSets).then(function (response) {
                return { total: response.total, courses: response.courses };
            });
        });
    };
    /**
     * Self enrol current user in a certain course.
     *
     * @param {number} courseId Course ID.
     * @param {string} [password] Password to use.
     * @param {number} [instanceId] Enrol instance ID.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any>} Promise resolved if the user is enrolled. If the password is invalid, the promise is rejected
     *                        with an object with code = CoreCoursesProvider.ENROL_INVALID_KEY.
     */
    CoreCoursesProvider.prototype.selfEnrol = function (courseId, password, instanceId, siteId) {
        if (password === void 0) { password = ''; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                courseid: courseId,
                password: password
            };
            if (instanceId) {
                params.instanceid = instanceId;
            }
            return site.write('enrol_self_enrol_user', params).then(function (response) {
                if (response) {
                    if (response.status) {
                        return true;
                    }
                    else if (response.warnings && response.warnings.length) {
                        var message_1;
                        response.warnings.forEach(function (warning) {
                            // Invalid password warnings.
                            if (warning.warningcode == '2' || warning.warningcode == '3' || warning.warningcode == '4') {
                                message_1 = warning.message;
                            }
                        });
                        if (message_1) {
                            return Promise.reject({ code: CoreCoursesProvider_1.ENROL_INVALID_KEY, message: message_1 });
                        }
                        else {
                            return Promise.reject(response.warnings[0]);
                        }
                    }
                }
                return Promise.reject(null);
            });
        });
    };
    CoreCoursesProvider.SEARCH_PER_PAGE = 20;
    CoreCoursesProvider.ENROL_INVALID_KEY = 'CoreCoursesEnrolInvalidKey';
    CoreCoursesProvider.EVENT_MY_COURSES_UPDATED = 'courses_my_courses_updated';
    CoreCoursesProvider.EVENT_MY_COURSES_REFRESHED = 'courses_my_courses_refreshed';
    CoreCoursesProvider = CoreCoursesProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */]])
    ], CoreCoursesProvider);
    return CoreCoursesProvider;
    var CoreCoursesProvider_1;
}());

//# sourceMappingURL=courses.js.map

/***/ }),
/* 32 */,
/* 33 */,
/* 34 */,
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFilepoolProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_network__ = __webpack_require__(103);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__events__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__file__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__init__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__plugin_file_delegate__ = __webpack_require__(129);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__ws__ = __webpack_require__(137);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__utils_mimetype__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__utils_text__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__utils_time__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__utils_url__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__core_constants__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_ts_md5_dist_md5__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_ts_md5_dist_md5___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_16_ts_md5_dist_md5__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

















/*
 * Factory for handling downloading files and retrieve downloaded files.
 *
 * @description
 * This factory is responsible for handling downloading files.
 *
 * The two main goals of this is to keep the content available offline, and improve the user experience by caching
 * the content locally.
 */
var CoreFilepoolProvider = /** @class */ (function () {
    function CoreFilepoolProvider(logger, appProvider, fileProvider, sitesProvider, wsProvider, textUtils, utils, mimeUtils, urlUtils, timeUtils, eventsProvider, initDelegate, network, pluginFileDelegate) {
        var _this = this;
        this.appProvider = appProvider;
        this.fileProvider = fileProvider;
        this.sitesProvider = sitesProvider;
        this.wsProvider = wsProvider;
        this.textUtils = textUtils;
        this.utils = utils;
        this.mimeUtils = mimeUtils;
        this.urlUtils = urlUtils;
        this.timeUtils = timeUtils;
        this.eventsProvider = eventsProvider;
        this.pluginFileDelegate = pluginFileDelegate;
        // Constants.
        this.QUEUE_PROCESS_INTERVAL = 0;
        this.FOLDER = 'filepool';
        this.WIFI_DOWNLOAD_THRESHOLD = 20971520; // 20MB.
        this.DOWNLOAD_THRESHOLD = 2097152; // 2MB.
        this.QUEUE_RUNNING = 'mmFilepool:QUEUE_RUNNING';
        this.QUEUE_PAUSED = 'mmFilepool:QUEUE_PAUSED';
        this.ERR_QUEUE_IS_EMPTY = 'mmFilepoolError:ERR_QUEUE_IS_EMPTY';
        this.ERR_FS_OR_NETWORK_UNAVAILABLE = 'mmFilepoolError:ERR_FS_OR_NETWORK_UNAVAILABLE';
        this.ERR_QUEUE_ON_PAUSE = 'mmFilepoolError:ERR_QUEUE_ON_PAUSE';
        // Variables for database.
        this.QUEUE_TABLE = 'filepool_files_queue'; // Queue of files to download.
        this.FILES_TABLE = 'filepool_files'; // Downloaded files.
        this.LINKS_TABLE = 'filepool_files_links'; // Links between downloaded files and components.
        this.PACKAGES_TABLE = 'filepool_packages'; // Downloaded packages (sets of files).
        this.appTablesSchema = [
            {
                name: this.QUEUE_TABLE,
                columns: [
                    {
                        name: 'siteId',
                        type: 'TEXT'
                    },
                    {
                        name: 'fileId',
                        type: 'TEXT'
                    },
                    {
                        name: 'added',
                        type: 'INTEGER'
                    },
                    {
                        name: 'priority',
                        type: 'INTEGER'
                    },
                    {
                        name: 'url',
                        type: 'TEXT'
                    },
                    {
                        name: 'revision',
                        type: 'INTEGER'
                    },
                    {
                        name: 'timemodified',
                        type: 'INTEGER'
                    },
                    {
                        name: 'isexternalfile',
                        type: 'INTEGER'
                    },
                    {
                        name: 'repositorytype',
                        type: 'TEXT'
                    },
                    {
                        name: 'path',
                        type: 'TEXT'
                    },
                    {
                        name: 'links',
                        type: 'TEXT'
                    }
                ],
                primaryKeys: ['siteId', 'fileId']
            }
        ];
        this.sitesTablesSchema = [
            {
                name: this.FILES_TABLE,
                columns: [
                    {
                        name: 'fileId',
                        type: 'TEXT',
                        primaryKey: true
                    },
                    {
                        name: 'url',
                        type: 'TEXT',
                        notNull: true
                    },
                    {
                        name: 'revision',
                        type: 'INTEGER'
                    },
                    {
                        name: 'timemodified',
                        type: 'INTEGER'
                    },
                    {
                        name: 'stale',
                        type: 'INTEGER'
                    },
                    {
                        name: 'downloadTime',
                        type: 'INTEGER'
                    },
                    {
                        name: 'isexternalfile',
                        type: 'INTEGER'
                    },
                    {
                        name: 'repositorytype',
                        type: 'TEXT'
                    },
                    {
                        name: 'path',
                        type: 'TEXT'
                    },
                    {
                        name: 'extension',
                        type: 'TEXT'
                    }
                ]
            },
            {
                name: this.LINKS_TABLE,
                columns: [
                    {
                        name: 'fileId',
                        type: 'TEXT'
                    },
                    {
                        name: 'component',
                        type: 'TEXT'
                    },
                    {
                        name: 'componentId',
                        type: 'TEXT'
                    }
                ],
                primaryKeys: ['fileId', 'component', 'componentId']
            },
            {
                name: this.PACKAGES_TABLE,
                columns: [
                    {
                        name: 'id',
                        type: 'TEXT',
                        primaryKey: true
                    },
                    {
                        name: 'component',
                        type: 'TEXT'
                    },
                    {
                        name: 'componentId',
                        type: 'TEXT'
                    },
                    {
                        name: 'status',
                        type: 'TEXT'
                    },
                    {
                        name: 'previous',
                        type: 'TEXT'
                    },
                    {
                        name: 'updated',
                        type: 'INTEGER'
                    },
                    {
                        name: 'downloadTime',
                        type: 'INTEGER'
                    },
                    {
                        name: 'previousDownloadTime',
                        type: 'INTEGER'
                    },
                    {
                        name: 'extra',
                        type: 'TEXT'
                    }
                ]
            },
        ];
        this.tokenRegex = new RegExp('(\\?|&)token=([A-Za-z0-9]+)');
        this.urlAttributes = [
            this.tokenRegex,
            new RegExp('(\\?|&)forcedownload=[0-1]'),
            new RegExp('(\\?|&)preview=[A-Za-z0-9]+'),
            new RegExp('(\\?|&)offline=[0-1]', 'g')
        ];
        this.queueDeferreds = {}; // To handle file downloads using the queue.
        this.sizeCache = {}; // A "cache" to store file sizes to prevent performing too many HEAD requests.
        // Variables to prevent downloading packages/files twice at the same time.
        this.packagesPromises = {};
        this.filePromises = {};
        this.logger = logger.getInstance('CoreFilepoolProvider');
        this.appDB = this.appProvider.getDB();
        this.appDB.createTablesFromSchema(this.appTablesSchema);
        this.sitesProvider.createTablesFromSchema(this.sitesTablesSchema);
        initDelegate.ready().then(function () {
            // Waiting for the app to be ready to start processing the queue.
            _this.checkQueueProcessing();
            // Start queue when device goes online.
            network.onConnect().subscribe(function () {
                _this.checkQueueProcessing();
            });
        });
    }
    /**
     * Link a file with a component.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @param {string} component The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<any>} Promise resolved on success.
     */
    CoreFilepoolProvider.prototype.addFileLink = function (siteId, fileId, component, componentId) {
        var _this = this;
        if (!component) {
            return Promise.reject(null);
        }
        componentId = this.fixComponentId(componentId);
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            var newEntry = {
                fileId: fileId,
                component: component,
                componentId: componentId || ''
            };
            return db.insertOrUpdateRecord(_this.LINKS_TABLE, newEntry, { fileId: fileId });
        });
    };
    /**
     * Link a file with a component by URL.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The file Url.
     * @param {string} component The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<any>} Promise resolved on success.
     * @description
     * Use this method to create a link between a URL and a component. You usually do not need to call this manually since
     * downloading a file automatically does this. Note that this method does not check if the file exists in the pool.
     */
    CoreFilepoolProvider.prototype.addFileLinkByUrl = function (siteId, fileUrl, component, componentId) {
        var _this = this;
        return this.fixPluginfileURL(siteId, fileUrl).then(function (fileUrl) {
            var fileId = _this.getFileIdByUrl(fileUrl);
            return _this.addFileLink(siteId, fileId, component, componentId);
        });
    };
    /**
     * Link a file with several components.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @param {any[]} links Array of objects containing the component and optionally componentId.
     * @return {Promise<any>} Promise resolved on success.
     */
    CoreFilepoolProvider.prototype.addFileLinks = function (siteId, fileId, links) {
        var _this = this;
        var promises = [];
        links.forEach(function (link) {
            promises.push(_this.addFileLink(siteId, fileId, link.component, link.componentId));
        });
        return Promise.all(promises);
    };
    /**
     * Add files to queue using a URL.
     *
     * @param {string} siteId The site ID.
     * @param {any[]} files Array of files to add.
     * @param {string} [component] The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component (optional).
     * @return {Promise<any>} Resolved on success.
     */
    CoreFilepoolProvider.prototype.addFilesToQueue = function (siteId, files, component, componentId) {
        return this.downloadOrPrefetchFiles(siteId, files, true, false, component, componentId);
    };
    /**
     * Add a file to the pool.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @param {any} data Additional information to store about the file (timemodified, url, ...). See FILES_TABLE schema.
     * @return {Promise<any>} Promise resolved on success.
     */
    CoreFilepoolProvider.prototype.addFileToPool = function (siteId, fileId, data) {
        var _this = this;
        var values = Object.assign({}, data);
        values.fileId = fileId;
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            return db.insertOrUpdateRecord(_this.FILES_TABLE, values, { fileId: fileId });
        });
    };
    /**
     * Add a file to the queue.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @param {string} url The absolute URL to the file.
     * @param {number} priority The priority this file should get in the queue (range 0-999).
     * @param {number} revision The revision of the file.
     * @param {number} timemodified The time this file was modified. Can be used to check file state.
     * @param {string} [filePath] Filepath to download the file to. If not defined, download to the filepool folder.
     * @param {any} options Extra options (isexternalfile, repositorytype).
     * @param {any} [link] The link to add for the file.
     * @return {Promise<any>} Promise resolved when the file is downloaded.
     */
    CoreFilepoolProvider.prototype.addToQueue = function (siteId, fileId, url, priority, revision, timemodified, filePath, onProgress, options, link) {
        var _this = this;
        if (options === void 0) { options = {}; }
        this.logger.debug("Adding " + fileId + " to the queue");
        return this.appDB.insertRecord(this.QUEUE_TABLE, {
            siteId: siteId,
            fileId: fileId,
            url: url,
            priority: priority,
            revision: revision,
            timemodified: timemodified,
            path: filePath,
            isexternalfile: options.isexternalfile ? 1 : 0,
            repositorytype: options.repositorytype,
            links: JSON.stringify(link ? [link] : []),
            added: Date.now()
        }).then(function () {
            // Check if the queue is running.
            _this.checkQueueProcessing();
            _this.notifyFileDownloading(siteId, fileId);
            return _this.getQueuePromise(siteId, fileId, true, onProgress);
        });
    };
    /**
     * Add an entry to queue using a URL.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The absolute URL to the file.
     * @param {string} [component] The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component (optional).
     * @param {number} [timemodified=0] The time this file was modified. Can be used to check file state.
     * @param {string} [filePath] Filepath to download the file to. If not defined, download to the filepool folder.
     * @param {Function} [onProgress] Function to call on progress.
     * @param {number} [priority=0] The priority this file should get in the queue (range 0-999).
     * @param {any} [options] Extra options (isexternalfile, repositorytype).
     * @return {Promise} Resolved on success.
     */
    CoreFilepoolProvider.prototype.addToQueueByUrl = function (siteId, fileUrl, component, componentId, timemodified, filePath, onProgress, priority, options) {
        var _this = this;
        if (timemodified === void 0) { timemodified = 0; }
        if (priority === void 0) { priority = 0; }
        if (options === void 0) { options = {}; }
        var fileId, link, revision, queueDeferred;
        if (!this.fileProvider.isAvailable()) {
            return Promise.reject(null);
        }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            if (!site.canDownloadFiles()) {
                return Promise.reject(null);
            }
            return _this.fixPluginfileURL(siteId, fileUrl).then(function (fileUrl) {
                var primaryKey = { siteId: siteId, fileId: fileId };
                revision = _this.getRevisionFromUrl(fileUrl);
                fileId = _this.getFileIdByUrl(fileUrl);
                // Set up the component.
                if (typeof component != 'undefined') {
                    link = {
                        component: component,
                        componentId: _this.fixComponentId(componentId)
                    };
                }
                // Retrieve the queue deferred now if it exists.
                // This is to prevent errors if file is removed from queue while we're checking if the file is in queue.
                queueDeferred = _this.getQueueDeferred(siteId, fileId, false, onProgress);
                return _this.hasFileInQueue(siteId, fileId).then(function (entry) {
                    var newData = {};
                    var foundLink = false;
                    if (entry) {
                        // We already have the file in queue, we update the priority and links.
                        if (entry.priority < priority) {
                            newData.priority = priority;
                        }
                        if (revision && entry.revision !== revision) {
                            newData.revision = revision;
                        }
                        if (timemodified && entry.timemodified !== timemodified) {
                            newData.timemodified = timemodified;
                        }
                        if (filePath && entry.path !== filePath) {
                            newData.path = filePath;
                        }
                        if (entry.isexternalfile !== options.isexternalfile) {
                            newData.isexternalfile = options.isexternalfile;
                        }
                        if (entry.repositorytype !== options.repositorytype) {
                            newData.repositorytype = options.repositorytype;
                        }
                        if (link) {
                            // We need to add the new link if it does not exist yet.
                            if (entry.links && entry.links.length) {
                                for (var i in entry.links) {
                                    var fileLink = entry.links[i];
                                    if (fileLink.component == link.component && fileLink.componentId == link.componentId) {
                                        foundLink = true;
                                        break;
                                    }
                                }
                            }
                            if (!foundLink) {
                                newData.links = entry.links || [];
                                newData.links.push(link);
                                newData.links = JSON.stringify(entry.links);
                            }
                        }
                        if (Object.keys(newData).length) {
                            // Update only when required.
                            _this.logger.debug("Updating file " + fileId + " which is already in queue");
                            return _this.appDB.updateRecords(_this.QUEUE_TABLE, newData, primaryKey).then(function () {
                                return _this.getQueuePromise(siteId, fileId, true, onProgress);
                            });
                        }
                        _this.logger.debug("File " + fileId + " already in queue and does not require update");
                        if (queueDeferred) {
                            // If we were able to retrieve the queue deferred before, we use that one.
                            return queueDeferred.promise;
                        }
                        else {
                            // Create a new deferred and return its promise.
                            return _this.getQueuePromise(siteId, fileId, true, onProgress);
                        }
                    }
                    else {
                        return _this.addToQueue(siteId, fileId, fileUrl, priority, revision, timemodified, filePath, onProgress, options, link);
                    }
                }, function () {
                    // Unsure why we could not get the record, let's add to the queue anyway.
                    return _this.addToQueue(siteId, fileId, fileUrl, priority, revision, timemodified, filePath, onProgress, options, link);
                });
            });
        });
    };
    /**
     * Adds a file to the queue if the size is allowed to be downloaded.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The absolute URL to the file.
     * @param {string} component The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {number} [timemodified=0] The time this file was modified.
     * @param {boolean} [checkSize=true] True if we shouldn't download files if their size is big, false otherwise.
     * @param {boolean} [downloadUnknown] True to download file in WiFi if their size is unknown, false otherwise.
     *                                    Ignored if checkSize=false.
     * @param {any} [options] Extra options (isexternalfile, repositorytype).
     * @return {Promise<any>} Promise resolved when the file is downloaded.
     */
    CoreFilepoolProvider.prototype.addToQueueIfNeeded = function (siteId, fileUrl, component, componentId, timemodified, checkSize, downloadUnknown, options) {
        var _this = this;
        if (timemodified === void 0) { timemodified = 0; }
        if (checkSize === void 0) { checkSize = true; }
        if (options === void 0) { options = {}; }
        var promise;
        if (checkSize) {
            if (typeof this.sizeCache[fileUrl] != 'undefined') {
                promise = Promise.resolve(this.sizeCache[fileUrl]);
            }
            else {
                if (!this.appProvider.isOnline()) {
                    // Cannot check size in offline, stop.
                    return Promise.reject(null);
                }
                promise = this.wsProvider.getRemoteFileSize(fileUrl);
            }
            // Calculate the size of the file.
            return promise.then(function (size) {
                var isWifi = !_this.appProvider.isNetworkAccessLimited(), sizeUnknown = size <= 0;
                if (!sizeUnknown) {
                    // Store the size in the cache.
                    _this.sizeCache[fileUrl] = size;
                }
                // Check if the file should be downloaded.
                if (sizeUnknown) {
                    if (downloadUnknown && isWifi) {
                        return _this.addToQueueByUrl(siteId, fileUrl, component, componentId, timemodified, undefined, undefined, 0, options);
                    }
                }
                else if (size <= _this.DOWNLOAD_THRESHOLD || (isWifi && size <= _this.WIFI_DOWNLOAD_THRESHOLD)) {
                    return _this.addToQueueByUrl(siteId, fileUrl, component, componentId, timemodified, undefined, undefined, 0, options);
                }
            });
        }
        else {
            // No need to check size, just add it to the queue.
            return this.addToQueueByUrl(siteId, fileUrl, component, componentId, timemodified, undefined, undefined, 0, options);
        }
    };
    /**
     * Check the queue processing.
     *
     * @description
     * In mose cases, this will enable the queue processing if it was paused.
     * Though, this will disable the queue if we are missing network or if the file system
     * is not accessible. Also, this will have no effect if the queue is already running.
     */
    CoreFilepoolProvider.prototype.checkQueueProcessing = function () {
        if (!this.fileProvider.isAvailable() || !this.appProvider.isOnline()) {
            this.queueState = this.QUEUE_PAUSED;
            return;
        }
        else if (this.queueState === this.QUEUE_RUNNING) {
            return;
        }
        this.queueState = this.QUEUE_RUNNING;
        this.processQueue();
    };
    /**
     * Clear all packages status in a site.
     *
     * @param {string} siteId Site ID.
     * @return {Promise<any>} Promise resolved when all status are cleared.
     */
    CoreFilepoolProvider.prototype.clearAllPackagesStatus = function (siteId) {
        var _this = this;
        this.logger.debug('Clear all packages status for site ' + siteId);
        return this.sitesProvider.getSite(siteId).then(function (site) {
            // Get all the packages to be able to "notify" the change in the status.
            return site.getDb().getAllRecords(_this.PACKAGES_TABLE).then(function (entries) {
                // Delete all the entries.
                return site.getDb().deleteRecords(_this.PACKAGES_TABLE).then(function () {
                    entries.forEach(function (entry) {
                        // Trigger module status changed, setting it as not downloaded.
                        _this.triggerPackageStatusChanged(siteId, __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED, entry.component, entry.componentId);
                    });
                });
            });
        });
    };
    /**
     * Clears the filepool. Use it only when all the files from a site are deleted.
     *
     * @param  {string} siteId ID of the site to clear.
     * @return {Promise<any>} Promise resolved when the filepool is cleared.
     */
    CoreFilepoolProvider.prototype.clearFilepool = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            return db.deleteRecords(_this.FILES_TABLE);
        });
    };
    /**
     * Returns whether a component has files in the pool.
     *
     * @param {string} siteId The site ID.
     * @param {string} component The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<void>} Resolved means yes, rejected means no.
     */
    CoreFilepoolProvider.prototype.componentHasFiles = function (siteId, component, componentId) {
        var _this = this;
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            var conditions = {
                component: component,
                componentId: componentId || ''
            };
            return db.countRecords(_this.LINKS_TABLE, conditions).then(function (count) {
                if (count <= 0) {
                    return Promise.reject(null);
                }
            });
        });
    };
    /**
     * Given the current status of a list of packages and the status of one of the packages,
     * determine the new status for the list of packages. The status of a list of packages is:
     *     - CoreConstants.NOT_DOWNLOADABLE if there are no downloadable packages.
     *     - CoreConstants.NOT_DOWNLOADED if at least 1 package has status CoreConstants.NOT_DOWNLOADED.
     *     - CoreConstants.DOWNLOADED if ALL the downloadable packages have status CoreConstants.DOWNLOADED.
     *     - CoreConstants.DOWNLOADING if ALL the downloadable packages have status CoreConstants.DOWNLOADING or
     *                                     CoreConstants.DOWNLOADED, with at least 1 package with CoreConstants.DOWNLOADING.
     *     - CoreConstants.OUTDATED if ALL the downloadable packages have status CoreConstants.OUTDATED or CoreConstants.DOWNLOADED
     *                                     or CoreConstants.DOWNLOADING, with at least 1 package with CoreConstants.OUTDATED.
     *
     * @param {string} current Current status of the list of packages.
     * @param {string} packagestatus Status of one of the packages.
     * @return {string} New status for the list of packages;
     */
    CoreFilepoolProvider.prototype.determinePackagesStatus = function (current, packageStatus) {
        if (!current) {
            current = __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADABLE;
        }
        if (packageStatus === __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED) {
            // If 1 package is not downloaded the status of the whole list will always be not downloaded.
            return __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED;
        }
        else if (packageStatus === __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].DOWNLOADED && current === __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADABLE) {
            // If all packages are downloaded or not downloadable with at least 1 downloaded, status will be downloaded.
            return __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].DOWNLOADED;
        }
        else if (packageStatus === __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].DOWNLOADING &&
            (current === __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADABLE || current === __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].DOWNLOADED)) {
            // If all packages are downloading/downloaded/notdownloadable with at least 1 downloading, status will be downloading.
            return __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].DOWNLOADING;
        }
        else if (packageStatus === __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].OUTDATED && current !== __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED) {
            // If there are no packages notdownloaded and there is at least 1 outdated, status will be outdated.
            return __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].OUTDATED;
        }
        // Status remains the same.
        return current;
    };
    /**
     * Downloads a URL and update or add it to the pool.
     *
     * This uses the file system, you should always make sure that it is accessible before calling this method.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The file URL.
     * @param {any} [options] Extra options (revision, timemodified, isexternalfile, repositorytype).
     * @param {string} [filePath] Filepath to download the file to. If defined, no extension will be added.
     * @param {Function} [onProgress] Function to call on progress.
     * @param {CoreFilepoolFileEntry} [poolFileObject] When set, the object will be updated, a new entry will not be created.
     * @return {Promise<any>} Resolved with internal URL on success, rejected otherwise.
     */
    CoreFilepoolProvider.prototype.downloadForPoolByUrl = function (siteId, fileUrl, options, filePath, onProgress, poolFileObject) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var fileId = this.getFileIdByUrl(fileUrl), extension = this.mimeUtils.guessExtensionFromUrl(fileUrl), addExtension = typeof filePath == 'undefined', pathPromise = filePath ? filePath : this.getFilePath(siteId, fileId, extension);
        return Promise.resolve(pathPromise).then(function (filePath) {
            if (poolFileObject && poolFileObject.fileId !== fileId) {
                _this.logger.error('Invalid object to update passed');
                return Promise.reject(null);
            }
            var downloadId = _this.getFileDownloadId(fileUrl, filePath);
            if (_this.filePromises[siteId] && _this.filePromises[siteId][downloadId]) {
                // There's already a download ongoing for this file in this location, return the promise.
                return _this.filePromises[siteId][downloadId];
            }
            else if (!_this.filePromises[siteId]) {
                _this.filePromises[siteId] = {};
            }
            _this.filePromises[siteId][downloadId] = _this.sitesProvider.getSite(siteId).then(function (site) {
                if (!site.canDownloadFiles()) {
                    return Promise.reject(null);
                }
                return _this.wsProvider.downloadFile(fileUrl, filePath, addExtension, onProgress).then(function (fileEntry) {
                    var data = poolFileObject || {};
                    data.downloadTime = Date.now();
                    data.stale = 0;
                    data.url = fileUrl;
                    data.revision = options.revision;
                    data.timemodified = options.timemodified;
                    data.isexternalfile = options.isexternalfile ? 1 : 0;
                    data.repositorytype = options.repositorytype;
                    data.path = fileEntry.path;
                    data.extension = fileEntry.extension;
                    return _this.addFileToPool(siteId, fileId, data).then(function () {
                        return fileEntry.toURL();
                    });
                });
            }).finally(function () {
                // Download finished, delete the promise.
                delete _this.filePromises[siteId][downloadId];
            });
            return _this.filePromises[siteId][downloadId];
        });
    };
    /**
     * Download or prefetch several files into the filepool folder.
     *
     * @param {string} siteId The site ID.
     * @param {any[]} files Array of files to download.
     * @param {boolean} prefetch True if should prefetch the contents (queue), false if they should be downloaded right now.
     * @param {boolean} [ignoreStale] True if 'stale' should be ignored. Only if prefetch=false.
     * @param {string} [component] The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {string} [dirPath] Name of the directory where to store the files (inside filepool dir). If not defined, store
     *                           the files directly inside the filepool folder.
     * @return {Promise<any>} Resolved on success.
     */
    CoreFilepoolProvider.prototype.downloadOrPrefetchFiles = function (siteId, files, prefetch, ignoreStale, component, componentId, dirPath) {
        var _this = this;
        var promises = [];
        // Download files.
        files.forEach(function (file) {
            var url = file.url || file.fileurl, timemodified = file.timemodified, options = {
                isexternalfile: file.isexternalfile,
                repositorytype: file.repositorytype
            };
            var path;
            if (dirPath) {
                // Calculate the path to the file.
                path = file.filename;
                if (file.filepath !== '/') {
                    path = file.filepath.substr(1) + path;
                }
                path = _this.textUtils.concatenatePaths(dirPath, path);
            }
            if (prefetch) {
                promises.push(_this.addToQueueByUrl(siteId, url, component, componentId, timemodified, path, undefined, 0, options));
            }
            else {
                promises.push(_this.downloadUrl(siteId, url, ignoreStale, component, componentId, timemodified, path, undefined, options));
            }
        });
        return this.utils.allPromises(promises);
    };
    /**
     * Downloads or prefetches a list of files as a "package".
     *
     * @param {string} siteId The site ID.
     * @param {any[]} fileList List of files to download.
     * @param {boolean} [prefetch] True if should prefetch the contents (queue), false if they should be downloaded right now.
     * @param {string} [component] The component to link the file to.
     * @param {string|number} [componentId]  An ID to use in conjunction with the component.
     * @param {string} [extra] Extra data to store for the package.
     * @param {string} [dirPath] Name of the directory where to store the files (inside filepool dir). If not defined, store
     *                           the files directly inside the filepool folder.
     * @param {Function} [onProgress] Function to call on progress.
     * @return {Promise<any>} Promise resolved when the package is downloaded.
     */
    CoreFilepoolProvider.prototype.downloadOrPrefetchPackage = function (siteId, fileList, prefetch, component, componentId, extra, dirPath, onProgress) {
        var _this = this;
        var packageId = this.getPackageId(component, componentId);
        var promise;
        if (this.packagesPromises[siteId] && this.packagesPromises[siteId][packageId]) {
            // There's already a download ongoing for this package, return the promise.
            return this.packagesPromises[siteId][packageId];
        }
        else if (!this.packagesPromises[siteId]) {
            this.packagesPromises[siteId] = {};
        }
        // Set package as downloading.
        promise = this.storePackageStatus(siteId, __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].DOWNLOADING, component, componentId).then(function () {
            var promises = [];
            var packageLoaded = 0;
            fileList.forEach(function (file) {
                var fileUrl = file.url || file.fileurl, options = {
                    isexternalfile: file.isexternalfile,
                    repositorytype: file.repositorytype
                };
                var path, promise, fileLoaded = 0, onFileProgress;
                if (onProgress) {
                    // There's a onProgress event, create a function to receive file download progress events.
                    onFileProgress = function (progress) {
                        if (progress && progress.loaded) {
                            // Add the new size loaded to the package loaded.
                            packageLoaded = packageLoaded + (progress.loaded - fileLoaded);
                            fileLoaded = progress.loaded;
                            onProgress({
                                packageDownload: true,
                                loaded: packageLoaded,
                                fileProgress: progress
                            });
                        }
                    };
                }
                if (dirPath) {
                    // Calculate the path to the file.
                    path = file.filename;
                    if (file.filepath !== '/') {
                        path = file.filepath.substr(1) + path;
                    }
                    path = _this.textUtils.concatenatePaths(dirPath, path);
                }
                if (prefetch) {
                    promise = _this.addToQueueByUrl(siteId, fileUrl, component, componentId, file.timemodified, path, undefined, 0, options);
                }
                else {
                    promise = _this.downloadUrl(siteId, fileUrl, false, component, componentId, file.timemodified, onFileProgress, path, options);
                }
                // Using undefined for success & fail will pass the success/failure to the parent promise.
                promises.push(promise);
            });
            return Promise.all(promises).then(function () {
                // Success prefetching, store package as downloaded.
                return _this.storePackageStatus(siteId, __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].DOWNLOADED, component, componentId, extra);
            }).catch(function () {
                // Error downloading, go back to previous status and reject the promise.
                return _this.setPackagePreviousStatus(siteId, component, componentId).then(function () {
                    return Promise.reject(null);
                });
            });
        }).finally(function () {
            // Download finished, delete the promise.
            delete _this.packagesPromises[siteId][packageId];
        });
        this.packagesPromises[siteId][packageId] = promise;
        return promise;
    };
    /**
     * Downloads a list of files.
     *
     * @param {string} siteId The site ID.
     * @param {any[]} fileList List of files to download.
     * @param {string} component The component to link the file to.
     * @param {string|number} [componentId] An ID to identify the download.
     * @param {string} [extra] Extra data to store for the package.
     * @param {string} [dirPath] Name of the directory where to store the files (inside filepool dir). If not defined, store
     *                           the files directly inside the filepool folder.
     * @param {Function} [onProgress] Function to call on progress.
     * @return {Promise<any>}  Promise resolved when all files are downloaded.
     */
    CoreFilepoolProvider.prototype.downloadPackage = function (siteId, fileList, component, componentId, extra, dirPath, onProgress) {
        return this.downloadOrPrefetchPackage(siteId, fileList, false, component, componentId, extra, dirPath, onProgress);
    };
    /**
     * Downloads a file on the spot.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The file URL.
     * @param {boolean} [ignoreStale] Whether 'stale' should be ignored.
     * @param {string} [component] The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {number} [timemodified=0] The time this file was modified. Can be used to check file state.
     * @param {string} [filePath] Filepath to download the file to. If not defined, download to the filepool folder.
     * @param {any} [options] Extra options (isexternalfile, repositorytype).
     * @return {Promise<any>} Resolved with internal URL on success, rejected otherwise.
     * @description
     * Downloads a file on the spot.
     *
     * This will also take care of adding the file to the pool if it's missing. However, please note that this will
     * not force a file to be re-downloaded if it is already part of the pool. You should mark a file as stale using
     * invalidateFileByUrl to trigger a download.
     */
    CoreFilepoolProvider.prototype.downloadUrl = function (siteId, fileUrl, ignoreStale, component, componentId, timemodified, onProgress, filePath, options) {
        var _this = this;
        if (timemodified === void 0) { timemodified = 0; }
        if (options === void 0) { options = {}; }
        var fileId, promise;
        if (this.fileProvider.isAvailable()) {
            return this.fixPluginfileURL(siteId, fileUrl).then(function (fixedUrl) {
                fileUrl = fixedUrl;
                options = Object.assign({}, options); // Create a copy to prevent modifying the original object.
                options.timemodified = timemodified || 0;
                options.revision = _this.getRevisionFromUrl(fileUrl);
                fileId = _this.getFileIdByUrl(fileUrl);
                return _this.hasFileInPool(siteId, fileId).then(function (fileObject) {
                    if (typeof fileObject === 'undefined') {
                        // We do not have the file, download and add to pool.
                        _this.notifyFileDownloading(siteId, fileId);
                        return _this.downloadForPoolByUrl(siteId, fileUrl, options, filePath, onProgress);
                    }
                    else if (_this.isFileOutdated(fileObject, options.revision, options.timemodified) &&
                        _this.appProvider.isOnline() && !ignoreStale) {
                        // The file is outdated, force the download and update it.
                        _this.notifyFileDownloading(siteId, fileId);
                        return _this.downloadForPoolByUrl(siteId, fileUrl, options, filePath, onProgress, fileObject);
                    }
                    // Everything is fine, return the file on disk.
                    if (filePath) {
                        promise = _this.getInternalUrlByPath(filePath);
                    }
                    else {
                        promise = _this.getInternalUrlById(siteId, fileId);
                    }
                    return promise.then(function (response) {
                        return response;
                    }, function () {
                        // The file was not found in the pool, weird.
                        _this.notifyFileDownloading(siteId, fileId);
                        return _this.downloadForPoolByUrl(siteId, fileUrl, options, filePath, onProgress, fileObject);
                    });
                }, function () {
                    // The file is not in the pool just yet.
                    _this.notifyFileDownloading(siteId, fileId);
                    return _this.downloadForPoolByUrl(siteId, fileUrl, options, filePath, onProgress);
                }).then(function (response) {
                    if (typeof component != 'undefined') {
                        _this.addFileLink(siteId, fileId, component, componentId).catch(function () {
                            // Ignore errors.
                        });
                    }
                    _this.notifyFileDownloaded(siteId, fileId);
                    return response;
                }, function (err) {
                    _this.notifyFileDownloadError(siteId, fileId);
                    return Promise.reject(err);
                });
            });
        }
        else {
            return Promise.reject(null);
        }
    };
    /**
     * Fill Missing Extension In the File Object if needed.
     * This is to migrate from old versions.
     *
     * @param {CoreFilepoolFileEntry} fileObject File object to be migrated.
     * @param {string} siteId SiteID to get migrated.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreFilepoolProvider.prototype.fillExtensionInFile = function (entry, siteId) {
        var _this = this;
        if (typeof entry.extension != 'undefined') {
            // Already filled.
            return Promise.resolve();
        }
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            var extension = _this.mimeUtils.getFileExtension(entry.path);
            if (!extension) {
                // Files does not have extension. Invalidate file (stale = true).
                // Minor problem: file will remain in the filesystem once downloaded again.
                _this.logger.debug('Staled file with no extension ' + entry.fileId);
                return db.updateRecords(_this.FILES_TABLE, { stale: 1 }, { fileId: entry.fileId });
            }
            // File has extension. Save extension, and add extension to path.
            var fileId = entry.fileId;
            entry.fileId = _this.mimeUtils.removeExtension(fileId);
            entry.extension = extension;
            return db.updateRecords(_this.FILES_TABLE, entry, { fileId: fileId }).then(function () {
                if (entry.fileId == fileId) {
                    // File ID hasn't changed, we're done.
                    _this.logger.debug('Removed extesion ' + extension + ' from file ' + entry.fileId);
                    return;
                }
                // Now update the links.
                return db.updateRecords(_this.LINKS_TABLE, { fileId: entry.fileId }, { fileId: fileId });
            });
        });
    };
    /**
     * Fill Missing Extension In Files, used to migrate from previous file handling.
     * Reserved for core use, please do not call.
     *
     * @param {string} siteId SiteID to get migrated
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreFilepoolProvider.prototype.fillMissingExtensionInFiles = function (siteId) {
        var _this = this;
        this.logger.debug('Fill missing extensions in files of ' + siteId);
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            return db.getAllRecords(_this.FILES_TABLE).then(function (entries) {
                var promises = [];
                entries.forEach(function (entry) {
                    promises.push(_this.fillExtensionInFile(entry, siteId));
                });
                return Promise.all(promises);
            });
        });
    };
    /**
     * Fix a component ID to always be a Number if possible.
     *
     * @param {string|number} componentId The component ID.
     * @return {string|number} The normalised component ID. -1 when undefined was passed.
     */
    CoreFilepoolProvider.prototype.fixComponentId = function (componentId) {
        if (typeof componentId == 'number') {
            return componentId;
        }
        // Try to convert it to a number.
        var id = parseInt(componentId, 10);
        if (isNaN(id)) {
            // Not a number.
            if (typeof componentId == 'undefined' || componentId === null) {
                return -1;
            }
            else {
                return componentId;
            }
        }
        return id;
    };
    /**
     * Add the wstoken url and points to the correct script.
     *
     * @param {string} siteId  The site ID.
     * @param {string} fileUrl The file URL.
     * @return {Promise}       Resolved with fixed URL on success, rejected otherwise.
     */
    CoreFilepoolProvider.prototype.fixPluginfileURL = function (siteId, fileUrl) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.fixPluginfileURL(fileUrl);
        });
    };
    /**
     * Convenience function to get component files.
     *
     * @param {SQLiteDB} db Site's DB.
     * @param {string} component The component to get.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<any[]>} Promise resolved with the files.
     */
    CoreFilepoolProvider.prototype.getComponentFiles = function (db, component, componentId) {
        var conditions = {
            component: component,
            componentId: componentId || ''
        };
        return db.getRecords(this.LINKS_TABLE, conditions);
    };
    /**
     * Returns the local URL of a directory.
     *
     * @param {string} siteId  The site ID.
     * @param {string} fileUrl The file URL.
     * @return {Promise}       Resolved with the URL. Rejected otherwise.
     */
    CoreFilepoolProvider.prototype.getDirectoryUrlByUrl = function (siteId, fileUrl) {
        var _this = this;
        if (this.fileProvider.isAvailable()) {
            return this.fixPluginfileURL(siteId, fileUrl).then(function (fileUrl) {
                var fileId = _this.getFileIdByUrl(fileUrl), filePath = _this.getFilePath(siteId, fileId, ''); // No extension, the function will return a string.
                return _this.fileProvider.getDir(filePath).then(function (dirEntry) {
                    return dirEntry.toURL();
                });
            });
        }
        return Promise.reject(null);
    };
    /**
     * Get the ID of a file download. Used to keep track of filePromises.
     *
     * @param {string} fileUrl  The file URL.
     * @param {string} filePath The file destination path.
     * @return {string}         File download ID.
     */
    CoreFilepoolProvider.prototype.getFileDownloadId = function (fileUrl, filePath) {
        return __WEBPACK_IMPORTED_MODULE_16_ts_md5_dist_md5__["Md5"].hashAsciiStr(fileUrl + '###' + filePath);
    };
    /**
     * Get the name of the event used to notify download events (CoreEventsProvider).
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @return {string} Event name.
     */
    CoreFilepoolProvider.prototype.getFileEventName = function (siteId, fileId) {
        return 'mmFilepoolFile:' + siteId + ':' + fileId;
    };
    /**
     * Get the name of the event used to notify download events (CoreEventsProvider).
     *
     * @param {string} siteId  The site ID.
     * @param {string} fileUrl The absolute URL to the file.
     * @return {Promise}       Promise resolved with event name.
     */
    CoreFilepoolProvider.prototype.getFileEventNameByUrl = function (siteId, fileUrl) {
        var _this = this;
        return this.fixPluginfileURL(siteId, fileUrl).then(function (fileUrl) {
            var fileId = _this.getFileIdByUrl(fileUrl);
            return _this.getFileEventName(siteId, fileId);
        });
    };
    /**
     * Creates a unique ID based on a URL.
     *
     * This has a minimal handling of pluginfiles in order to generate a clean file ID which will not change if
     * pointing to the same pluginfile URL even if the token or extra attributes have changed.
     *
     * @param {string} fileUrl The absolute URL to the file.
     * @return {string} The file ID.
     */
    CoreFilepoolProvider.prototype.getFileIdByUrl = function (fileUrl) {
        var url = this.removeRevisionFromUrl(fileUrl), filename;
        // Decode URL.
        url = this.textUtils.decodeHTML(this.textUtils.decodeURIComponent(url));
        if (url.indexOf('/webservice/pluginfile') !== -1) {
            // Remove attributes that do not matter.
            this.urlAttributes.forEach(function (regex) {
                url = url.replace(regex, '');
            });
        }
        // Try to guess the filename the target file should have.
        // We want to keep the original file name so people can easily identify the files after the download.
        filename = this.guessFilenameFromUrl(url);
        return filename + '_' + __WEBPACK_IMPORTED_MODULE_16_ts_md5_dist_md5__["Md5"].hashAsciiStr('url:' + url);
    };
    /**
     * Get the links of a file.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @return {Promise<any[]>} Promise resolved with the links.
     */
    CoreFilepoolProvider.prototype.getFileLinks = function (siteId, fileId) {
        var _this = this;
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            return db.getRecords(_this.LINKS_TABLE, { fileId: fileId });
        });
    };
    /**
     * Get the path to a file. This does not check if the file exists or not.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @param {string} [extension] Previously calculated extension. Empty to not add any. Undefined to calculate it.
     * @return {string|Promise<string>} The path to the file relative to storage root.
     */
    CoreFilepoolProvider.prototype.getFilePath = function (siteId, fileId, extension) {
        var path = this.getFilepoolFolderPath(siteId) + '/' + fileId;
        if (typeof extension == 'undefined') {
            // We need the extension to be able to open files properly.
            return this.hasFileInPool(siteId, fileId).then(function (entry) {
                if (entry.extension) {
                    path += '.' + entry.extension;
                }
                return path;
            }).catch(function () {
                // If file not found, use the path without extension.
                return path;
            });
        }
        else {
            if (extension) {
                path += '.' + extension;
            }
            return path;
        }
    };
    /**
     * Get the path to a file from its URL. This does not check if the file exists or not.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The file URL.
     * @return {Promise<string>} Promise resolved with the path to the file relative to storage root.
     */
    CoreFilepoolProvider.prototype.getFilePathByUrl = function (siteId, fileUrl) {
        var _this = this;
        return this.fixPluginfileURL(siteId, fileUrl).then(function (fileUrl) {
            var fileId = _this.getFileIdByUrl(fileUrl);
            return _this.getFilePath(siteId, fileId);
        });
    };
    /**
     * Get site Filepool Folder Path
     *
     * @param {string} siteId The site ID.
     * @return {string} The root path to the filepool of the site.
     */
    CoreFilepoolProvider.prototype.getFilepoolFolderPath = function (siteId) {
        return this.fileProvider.getSiteFolder(siteId) + '/' + this.FOLDER;
    };
    /**
     * Get all the matching files from a component. Returns objects containing properties like path, extension and url.
     *
     * @param {string} siteId The site ID.
     * @param {string} component The component to get.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<any[]>} Promise resolved with the files on success.
     */
    CoreFilepoolProvider.prototype.getFilesByComponent = function (siteId, component, componentId) {
        var _this = this;
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            return _this.getComponentFiles(db, component, componentId).then(function (items) {
                var promises = [], files = [];
                items.forEach(function (item) {
                    promises.push(db.getRecord(_this.FILES_TABLE, { fileId: item.fileId }).then(function (fileEntry) {
                        if (!fileEntry) {
                            return;
                        }
                        files.push({
                            url: fileEntry.url,
                            path: fileEntry.path,
                            extension: fileEntry.extension,
                            revision: fileEntry.revision,
                            timemodified: fileEntry.timemodified
                        });
                    }).catch(function () {
                        // File not found, ignore error.
                    }));
                });
                return Promise.all(promises).then(function () {
                    return files;
                });
            });
        });
    };
    /**
     * Get the size of all the files from a component.
     *
     * @param {string} siteId The site ID.
     * @param {string} component    The component to get.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<number>} Promise resolved with the size on success.
     */
    CoreFilepoolProvider.prototype.getFilesSizeByComponent = function (siteId, component, componentId) {
        var _this = this;
        return this.getFilesByComponent(siteId, component, componentId).then(function (files) {
            var promises = [];
            var size = 0;
            files.forEach(function (file) {
                promises.push(_this.fileProvider.getFileSize(file.path).then(function (fs) {
                    size += fs;
                }).catch(function () {
                    // Ignore failures, maybe some file was deleted.
                }));
            });
            return Promise.all(promises).then(function () {
                return size;
            });
        });
    };
    /**
     * Returns the file state: mmCoreDownloaded, mmCoreDownloading, mmCoreNotDownloaded or mmCoreOutdated.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl File URL.
     * @param {number} [timemodified=0] The time this file was modified.
     * @param {string} [filePath] Filepath to download the file to. If defined, no extension will be added.
     * @return {Promise<string>} Promise resolved with the file state.
     */
    CoreFilepoolProvider.prototype.getFileStateByUrl = function (siteId, fileUrl, timemodified, filePath) {
        var _this = this;
        if (timemodified === void 0) { timemodified = 0; }
        var fileId, revision;
        return this.fixPluginfileURL(siteId, fileUrl).then(function (fixedUrl) {
            fileUrl = fixedUrl;
            revision = _this.getRevisionFromUrl(fileUrl);
            fileId = _this.getFileIdByUrl(fileUrl);
            // Check if the file is in queue (waiting to be downloaded).
            return _this.hasFileInQueue(siteId, fileId).then(function () {
                return __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].DOWNLOADING;
            }).catch(function () {
                // Check if the file is being downloaded right now.
                var extension = _this.mimeUtils.guessExtensionFromUrl(fileUrl), path = filePath ? filePath : _this.getFilePath(siteId, fileId, extension);
                return Promise.resolve(path).then(function (filePath) {
                    var downloadId = _this.getFileDownloadId(fileUrl, filePath);
                    if (_this.filePromises[siteId] && _this.filePromises[siteId][downloadId]) {
                        return __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].DOWNLOADING;
                    }
                    // File is not being downloaded. Check if it's downloaded and if it's outdated.
                    return _this.hasFileInPool(siteId, fileId).then(function (entry) {
                        if (_this.isFileOutdated(entry, revision, timemodified)) {
                            return __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].OUTDATED;
                        }
                        else {
                            return __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].DOWNLOADED;
                        }
                    }).catch(function () {
                        return __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED;
                    });
                });
            });
        });
    };
    /**
     * Returns an absolute URL to access the file URL.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The absolute URL to the file.
     * @param {string} [mode=url] The type of URL to return. Accepts 'url' or 'src'.
     * @param {string} component The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {number} [timemodified=0] The time this file was modified.
     * @param {boolean} [checkSize=true] True if we shouldn't download files if their size is big, false otherwise.
     * @param {boolean} [downloadUnknown] True to download file in WiFi if their size is unknown, false otherwise.
     *                                    Ignored if checkSize=false.
     * @param {any} [options] Extra options (isexternalfile, repositorytype).
     * @return {Promise<string>} Resolved with the URL to use.
     * @description
     * This will return a URL pointing to the content of the requested URL.
     *
     * This handles the queue and validity of the file. If there is a local file and it's valid, return the local URL.
     * If the file isn't downloaded or it's outdated, return the online URL and add it to the queue to be downloaded later.
     */
    CoreFilepoolProvider.prototype.getFileUrlByUrl = function (siteId, fileUrl, component, componentId, mode, timemodified, checkSize, downloadUnknown, options) {
        var _this = this;
        if (mode === void 0) { mode = 'url'; }
        if (timemodified === void 0) { timemodified = 0; }
        if (checkSize === void 0) { checkSize = true; }
        if (options === void 0) { options = {}; }
        var fileId, revision;
        var addToQueue = function (fileUrl) {
            // Add the file to queue if needed and ignore errors.
            _this.addToQueueIfNeeded(siteId, fileUrl, component, componentId, timemodified, checkSize, downloadUnknown, options).catch(function () {
                // Ignore errors.
            });
        };
        return this.fixPluginfileURL(siteId, fileUrl).then(function (fixedUrl) {
            fileUrl = fixedUrl;
            revision = _this.getRevisionFromUrl(fileUrl);
            fileId = _this.getFileIdByUrl(fileUrl);
            return _this.hasFileInPool(siteId, fileId).then(function (entry) {
                var response;
                if (typeof entry === 'undefined') {
                    // We do not have the file, add it to the queue, and return real URL.
                    addToQueue(fileUrl);
                    response = fileUrl;
                }
                else if (_this.isFileOutdated(entry, revision, timemodified) && _this.appProvider.isOnline()) {
                    // The file is outdated, we add to the queue and return real URL.
                    addToQueue(fileUrl);
                    response = fileUrl;
                }
                else {
                    // We found the file entry, now look for the file on disk.
                    if (mode === 'src') {
                        response = _this.getInternalSrcById(siteId, fileId);
                    }
                    else {
                        response = _this.getInternalUrlById(siteId, fileId);
                    }
                    response = response.then(function (internalUrl) {
                        // The file is on disk.
                        return internalUrl;
                    }).catch(function () {
                        // We could not retrieve the file, delete the entries associated with that ID.
                        _this.logger.debug('File ' + fileId + ' not found on disk');
                        _this.removeFileById(siteId, fileId);
                        addToQueue(fileUrl);
                        if (_this.appProvider.isOnline()) {
                            // We still have a chance to serve the right content.
                            return fileUrl;
                        }
                        return Promise.reject(null);
                    });
                }
                return response;
            }, function () {
                // We do not have the file in store yet. Add to queue and return the fixed URL.
                addToQueue(fileUrl);
                return fileUrl;
            });
        });
    };
    /**
     * Returns the internal SRC of a file.
     *
     * The returned URL from this method is typically used with IMG tags.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @return {Promise<string>} Resolved with the internal URL. Rejected otherwise.
     */
    CoreFilepoolProvider.prototype.getInternalSrcById = function (siteId, fileId) {
        var _this = this;
        if (this.fileProvider.isAvailable()) {
            return Promise.resolve(this.getFilePath(siteId, fileId)).then(function (path) {
                return _this.fileProvider.getFile(path).then(function (fileEntry) {
                    // We use toInternalURL so images are loaded in iOS8 using img HTML tags.
                    return _this.fileProvider.getInternalURL(fileEntry);
                });
            });
        }
        return Promise.reject(null);
    };
    /**
     * Returns the local URL of a file.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @return {Promise<string>} Resolved with the URL. Rejected otherwise.
     */
    CoreFilepoolProvider.prototype.getInternalUrlById = function (siteId, fileId) {
        var _this = this;
        if (this.fileProvider.isAvailable()) {
            return Promise.resolve(this.getFilePath(siteId, fileId)).then(function (path) {
                return _this.fileProvider.getFile(path).then(function (fileEntry) {
                    return fileEntry.toURL();
                });
            });
        }
        return Promise.reject(null);
    };
    /**
     * Returns the local URL of a file.
     *
     * @param {string} filePath The file path.
     * @return {Promise<string>} Resolved with the URL.
     */
    CoreFilepoolProvider.prototype.getInternalUrlByPath = function (filePath) {
        if (this.fileProvider.isAvailable()) {
            return this.fileProvider.getFile(filePath).then(function (fileEntry) {
                return fileEntry.toURL();
            });
        }
        return Promise.reject(null);
    };
    /**
     * Returns the local URL of a file.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The file URL.
     * @return {Promise<string>} Resolved with the URL. Rejected otherwise.
     */
    CoreFilepoolProvider.prototype.getInternalUrlByUrl = function (siteId, fileUrl) {
        var _this = this;
        if (this.fileProvider.isAvailable()) {
            return this.fixPluginfileURL(siteId, fileUrl).then(function (fileUrl) {
                var fileId = _this.getFileIdByUrl(fileUrl);
                return _this.getInternalUrlById(siteId, fileId);
            });
        }
        return Promise.reject(null);
    };
    /**
     * Get the data stored for a package.
     *
     * @param {string} siteId Site ID.
     * @param {string} component Package's component.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<CoreFilepoolPackageEntry>} Promise resolved with the data.
     */
    CoreFilepoolProvider.prototype.getPackageData = function (siteId, component, componentId) {
        var _this = this;
        componentId = this.fixComponentId(componentId);
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var packageId = _this.getPackageId(component, componentId);
            return site.getDb().getRecord(_this.PACKAGES_TABLE, { id: packageId });
        });
    };
    /**
     * Creates the name for a package directory (hash).
     *
     * @param {string} url An URL to identify the package.
     * @return {string} The directory name.
     */
    CoreFilepoolProvider.prototype.getPackageDirNameByUrl = function (url) {
        var candidate, extension = '';
        url = this.removeRevisionFromUrl(url);
        if (url.indexOf('/webservice/pluginfile') !== -1) {
            // Remove attributes that do not matter.
            this.urlAttributes.forEach(function (regex) {
                url = url.replace(regex, '');
            });
            // Guess the extension of the URL. This is for backwards compatibility.
            candidate = this.mimeUtils.guessExtensionFromUrl(url);
            if (candidate && candidate !== 'php') {
                extension = '.' + candidate;
            }
        }
        return __WEBPACK_IMPORTED_MODULE_16_ts_md5_dist_md5__["Md5"].hashAsciiStr('url:' + url) + extension;
    };
    /**
     * Get the path to a directory to store a package files. This does not check if the file exists or not.
     *
     * @param {string} siteId The site ID.
     * @param {string} url An URL to identify the package.
     * @return {Promise<string>} Promise resolved with the path of the package.
     */
    CoreFilepoolProvider.prototype.getPackageDirPathByUrl = function (siteId, url) {
        var _this = this;
        return this.fixPluginfileURL(siteId, url).then(function (fixedUrl) {
            var dirName = _this.getPackageDirNameByUrl(fixedUrl);
            return _this.getFilePath(siteId, dirName, '');
        });
    };
    /**
     * Returns the local URL of a package directory.
     *
     * @param {string} siteId The site ID.
     * @param {string} url An URL to identify the package.
     * @return {Promise<string>} Resolved with the URL.
     */
    CoreFilepoolProvider.prototype.getPackageDirUrlByUrl = function (siteId, url) {
        var _this = this;
        if (this.fileProvider.isAvailable()) {
            return this.fixPluginfileURL(siteId, url).then(function (fixedUrl) {
                var dirName = _this.getPackageDirNameByUrl(fixedUrl), dirPath = _this.getFilePath(siteId, dirName, ''); // No extension, the function will return a string.
                return _this.fileProvider.getDir(dirPath).then(function (dirEntry) {
                    return dirEntry.toURL();
                });
            });
        }
        return Promise.reject(null);
    };
    /**
     * Get a download promise. If the promise is not set, return undefined.
     *
     * @param {string} siteId Site ID.
     * @param {string} component The component of the package.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<any>} Download promise or undefined.
     */
    CoreFilepoolProvider.prototype.getPackageDownloadPromise = function (siteId, component, componentId) {
        var packageId = this.getPackageId(component, componentId);
        if (this.packagesPromises[siteId] && this.packagesPromises[siteId][packageId]) {
            return this.packagesPromises[siteId][packageId];
        }
    };
    /**
     * Get a package extra data.
     *
     * @param {string} siteId Site ID.
     * @param {string} component Package's component.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<string>} Promise resolved with the extra data.
     */
    CoreFilepoolProvider.prototype.getPackageExtra = function (siteId, component, componentId) {
        return this.getPackageData(siteId, component, componentId).then(function (entry) {
            return entry.extra;
        });
    };
    /**
     * Get the ID of a package.
     *
     * @param {string} component Package's component.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {string} Package ID.
     */
    CoreFilepoolProvider.prototype.getPackageId = function (component, componentId) {
        return __WEBPACK_IMPORTED_MODULE_16_ts_md5_dist_md5__["Md5"].hashAsciiStr(component + '#' + this.fixComponentId(componentId));
    };
    /**
     * Get a package previous status.
     *
     * @param {string} siteId Site ID.
     * @param {string} component Package's component.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<string>} Promise resolved with the status.
     */
    CoreFilepoolProvider.prototype.getPackagePreviousStatus = function (siteId, component, componentId) {
        return this.getPackageData(siteId, component, componentId).then(function (entry) {
            return entry.previous || __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED;
        }).catch(function () {
            return __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED;
        });
    };
    /**
     * Get a package status.
     *
     * @param {string} siteId Site ID.
     * @param {string} component Package's component.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<string>} Promise resolved with the status.
     */
    CoreFilepoolProvider.prototype.getPackageStatus = function (siteId, component, componentId) {
        return this.getPackageData(siteId, component, componentId).then(function (entry) {
            return entry.status || __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED;
        }).catch(function () {
            return __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED;
        });
    };
    /**
     * Return the array of arguments of the pluginfile url.
     *
     * @param {string} url URL to get the args.
     * @return {string[]} The args found, undefined if not a pluginfile.
     */
    CoreFilepoolProvider.prototype.getPluginFileArgs = function (url) {
        if (!this.urlUtils.isPluginFileUrl(url)) {
            // Not pluginfile, return.
            return;
        }
        var relativePath = url.substr(url.indexOf('/pluginfile.php') + 16), args = relativePath.split('/');
        if (args.length < 3) {
            // To be a plugin file it should have at least contextId, Component and Filearea.
            return;
        }
        return args;
    };
    /**
     * Get the deferred object for a file in the queue.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @param {boolean} [create=true] True if it should create a new deferred if it doesn't exist.
     * @param {Function} [onProgress] Function to call on progress.
     * @return {any} Deferred.
     */
    CoreFilepoolProvider.prototype.getQueueDeferred = function (siteId, fileId, create, onProgress) {
        if (create === void 0) { create = true; }
        if (!this.queueDeferreds[siteId]) {
            if (!create) {
                return;
            }
            this.queueDeferreds[siteId] = {};
        }
        if (!this.queueDeferreds[siteId][fileId]) {
            if (!create) {
                return;
            }
            this.queueDeferreds[siteId][fileId] = this.utils.promiseDefer();
        }
        if (onProgress) {
            this.queueDeferreds[siteId][fileId].onProgress = onProgress;
        }
        return this.queueDeferreds[siteId][fileId];
    };
    /**
     * Get the on progress for a file in the queue.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @return {Function} On progress function, undefined if not found.
     */
    CoreFilepoolProvider.prototype.getQueueOnProgress = function (siteId, fileId) {
        var deferred = this.getQueueDeferred(siteId, fileId, false);
        if (deferred) {
            return deferred.onProgress;
        }
    };
    /**
     * Get the promise for a file in the queue.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @param {boolean} [create=true] True if it should create a new promise if it doesn't exist.
     * @param {Function} [onProgress] Function to call on progress.
     * @return {Promise<any>} Promise.
     */
    CoreFilepoolProvider.prototype.getQueuePromise = function (siteId, fileId, create, onProgress) {
        if (create === void 0) { create = true; }
        return this.getQueueDeferred(siteId, fileId, create, onProgress).promise;
    };
    /**
     * Get a revision number from a list of files (highest revision).
     *
     * @param {any[]} files Package files.
     * @return {number} Highest revision.
     */
    CoreFilepoolProvider.prototype.getRevisionFromFileList = function (files) {
        var _this = this;
        var revision = 0;
        files.forEach(function (file) {
            if (file.url || file.fileurl) {
                var r = _this.getRevisionFromUrl(file.url || file.fileurl);
                if (r > revision) {
                    revision = r;
                }
            }
        });
        return revision;
    };
    /**
     * Get the revision number from a file URL.
     *
     * @param {string} url URL to get the revision number.
     * @return {number} Revision number.
     */
    CoreFilepoolProvider.prototype.getRevisionFromUrl = function (url) {
        var args = this.getPluginFileArgs(url);
        if (!args) {
            // Not a pluginfile, no revision will be found.
            return 0;
        }
        var revisionRegex = this.pluginFileDelegate.getComponentRevisionRegExp(args);
        if (!revisionRegex) {
            return 0;
        }
        var matches = url.match(revisionRegex);
        if (matches && typeof matches[1] != 'undefined') {
            return parseInt(matches[1], 10);
        }
        return 0;
    };
    /**
     * Returns an absolute URL to use in IMG tags.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The absolute URL to the file.
     * @param {string} [mode=url] The type of URL to return. Accepts 'url' or 'src'.
     * @param {string} component The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {number} [timemodified=0] The time this file was modified.
     * @param {boolean} [checkSize=true] True if we shouldn't download files if their size is big, false otherwise.
     * @param {boolean} [downloadUnknown] True to download file in WiFi if their size is unknown, false otherwise.
     *                                    Ignored if checkSize=false.
     * @param {any} [options] Extra options (isexternalfile, repositorytype).
     * @return {Promise<string>} Resolved with the URL to use.
     * @description
     * This will return a URL pointing to the content of the requested URL.
     * The URL returned is compatible to use with IMG tags.
     */
    CoreFilepoolProvider.prototype.getSrcByUrl = function (siteId, fileUrl, component, componentId, timemodified, checkSize, downloadUnknown, options) {
        if (timemodified === void 0) { timemodified = 0; }
        if (checkSize === void 0) { checkSize = true; }
        if (options === void 0) { options = {}; }
        return this.getFileUrlByUrl(siteId, fileUrl, component, componentId, 'src', timemodified, checkSize, downloadUnknown, options);
    };
    /**
     * Get time modified from a list of files.
     *
     * @param {any[]} files List of files.
     * @return {number} Time modified.
     */
    CoreFilepoolProvider.prototype.getTimemodifiedFromFileList = function (files) {
        var timemodified = 0;
        files.forEach(function (file) {
            if (file.timemodified > timemodified) {
                timemodified = file.timemodified;
            }
        });
        return timemodified;
    };
    /**
     * Returns an absolute URL to access the file.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The absolute URL to the file.
     * @param {string} [mode=url] The type of URL to return. Accepts 'url' or 'src'.
     * @param {string} component The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {number} [timemodified=0] The time this file was modified.
     * @param {boolean} [checkSize=true] True if we shouldn't download files if their size is big, false otherwise.
     * @param {boolean} [downloadUnknown] True to download file in WiFi if their size is unknown, false otherwise.
     *                                    Ignored if checkSize=false.
     * @param {any} [options] Extra options (isexternalfile, repositorytype).
     * @return {Promise<string>} Resolved with the URL to use.
     * @description
     * This will return a URL pointing to the content of the requested URL.
     * The URL returned is compatible to use with a local browser.
     */
    CoreFilepoolProvider.prototype.getUrlByUrl = function (siteId, fileUrl, component, componentId, timemodified, checkSize, downloadUnknown, options) {
        if (timemodified === void 0) { timemodified = 0; }
        if (checkSize === void 0) { checkSize = true; }
        if (options === void 0) { options = {}; }
        return this.getFileUrlByUrl(siteId, fileUrl, component, componentId, 'url', timemodified, checkSize, downloadUnknown, options);
    };
    /**
     * Guess the filename of a file from its URL. This is very weak and unreliable.
     *
     * @param {string} fileUrl The file URL.
     * @return {string}        The filename treated so it doesn't have any special character.
     */
    CoreFilepoolProvider.prototype.guessFilenameFromUrl = function (fileUrl) {
        var filename = '';
        if (fileUrl.indexOf('/webservice/pluginfile') !== -1) {
            // It's a pluginfile URL. Search for the 'file' param to extract the name.
            var params = this.urlUtils.extractUrlParams(fileUrl);
            if (params.file) {
                filename = params.file.substr(params.file.lastIndexOf('/') + 1);
            }
            else {
                // 'file' param not found. Extract what's after the last '/' without params.
                filename = this.urlUtils.getLastFileWithoutParams(fileUrl);
            }
        }
        else if (this.urlUtils.isGravatarUrl(fileUrl)) {
            // Extract gravatar ID.
            filename = 'gravatar_' + this.urlUtils.getLastFileWithoutParams(fileUrl);
        }
        else if (this.urlUtils.isThemeImageUrl(fileUrl)) {
            // Extract user ID.
            var matches = fileUrl.match(/\/core\/([^\/]*)\//);
            if (matches && matches[1]) {
                filename = matches[1];
            }
            // Attach a constant and the image type.
            filename = 'default_' + filename + '_' + this.urlUtils.getLastFileWithoutParams(fileUrl);
        }
        else {
            // Another URL. Just get what's after the last /.
            filename = this.urlUtils.getLastFileWithoutParams(fileUrl);
        }
        // Remove the extension from the filename.
        filename = this.mimeUtils.removeExtension(filename);
        return this.textUtils.removeSpecialCharactersForFiles(filename);
    };
    /**
     * Check if the file is already in the pool. This does not check if the file is on the disk.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The file URL.
     * @return {Promise<CoreFilepoolFileEntry>} Resolved with file object from DB on success, rejected otherwise.
     */
    CoreFilepoolProvider.prototype.hasFileInPool = function (siteId, fileId) {
        var _this = this;
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            return db.getRecord(_this.FILES_TABLE, { fileId: fileId }).then(function (entry) {
                if (typeof entry === 'undefined') {
                    return Promise.reject(null);
                }
                return entry;
            });
        });
    };
    /**
     * Check if the file is in the queue.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The file URL.
     * @return {Promise} Resolved with file object from DB on success, rejected otherwise.
     */
    CoreFilepoolProvider.prototype.hasFileInQueue = function (siteId, fileId) {
        var _this = this;
        return this.appDB.getRecord(this.QUEUE_TABLE, { siteId: siteId, fileId: fileId }).then(function (entry) {
            if (typeof entry === 'undefined') {
                return Promise.reject(null);
            }
            // Convert the links to an object.
            entry.links = _this.textUtils.parseJSON(entry.links, []);
            return entry;
        });
    };
    /**
     * Invalidate all the files in a site.
     *
     * @param {string} siteId The site ID.
     * @param {boolean} [onlyUnknown=true] True to only invalidate files from external repos or without revision/timemodified.
     *                                     It is advised to set it to true to reduce the performance and data usage of the app.
     * @return {Promise<any>} Resolved on success.
     */
    CoreFilepoolProvider.prototype.invalidateAllFiles = function (siteId, onlyUnknown) {
        var _this = this;
        if (onlyUnknown === void 0) { onlyUnknown = true; }
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            var where, whereParams;
            if (onlyUnknown) {
                where = 'isexternalfile = ? OR (revision < ? AND timemodified = ?)';
                whereParams = [0, 1, 0];
            }
            return db.updateRecordsWhere(_this.FILES_TABLE, { stale: 1 }, where, whereParams);
        });
    };
    /**
     * Invalidate a file by URL.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The file URL.
     * @return {Promise<any>} Resolved on success.
     * @description
     * Invalidates a file by marking it stale. It will not be added to the queue automatically, but the next time this file
     * is requested it will be added to the queue.
     * You can manully call addToQueueByUrl to add this file to the queue immediately.
     * Please note that, if a file is stale, the user will be presented the stale file if there is no network access.
     */
    CoreFilepoolProvider.prototype.invalidateFileByUrl = function (siteId, fileUrl) {
        var _this = this;
        return this.fixPluginfileURL(siteId, fileUrl).then(function (fileUrl) {
            var fileId = _this.getFileIdByUrl(fileUrl);
            return _this.sitesProvider.getSiteDb(siteId).then(function (db) {
                return db.updateRecords(_this.FILES_TABLE, { stale: 1 }, { fileId: fileId });
            });
        });
    };
    /**
     * Invalidate all the matching files from a component.
     *
     * @param {string} siteId The site ID.
     * @param {string} component The component to invalidate.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {boolean} [onlyUnknown=true] True to only invalidate files from external repos or without revision/timemodified.
     *                                     It is advised to set it to true to reduce the performance and data usage of the app.
     * @return {Promise<any>} Resolved when done.
     */
    CoreFilepoolProvider.prototype.invalidateFilesByComponent = function (siteId, component, componentId, onlyUnknown) {
        var _this = this;
        if (onlyUnknown === void 0) { onlyUnknown = true; }
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            return _this.getComponentFiles(db, component, componentId).then(function (items) {
                var fileIds = items.map(function (item) {
                    return item.fileId;
                }), whereAndParams = db.getInOrEqual(fileIds);
                whereAndParams[0] = 'fileId ' + whereAndParams[0];
                if (onlyUnknown) {
                    whereAndParams[0] += ' AND (isexternalfile = ? OR (revision < ? AND timemodified = ?))';
                    whereAndParams[1] = whereAndParams[1].concat([0, 1, 0]);
                }
                return db.updateRecordsWhere(_this.FILES_TABLE, { stale: 1 }, whereAndParams[0], whereAndParams[1]);
            });
        });
    };
    /**
     * Check if a file is downloading.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl File URL.
     * @param {Promise<any>} Promise resolved if file is downloading, rejected otherwise.
     */
    CoreFilepoolProvider.prototype.isFileDownloadingByUrl = function (siteId, fileUrl) {
        var _this = this;
        return this.fixPluginfileURL(siteId, fileUrl).then(function (fileUrl) {
            var fileId = _this.getFileIdByUrl(fileUrl);
            return _this.hasFileInQueue(siteId, fileId);
        });
    };
    /**
     * Check if a file is outdated.
     *
     * @param {CoreFilepoolFileEntry} entry Filepool entry.
     * @param {number} [revision]  File revision number.
     * @param {number} [timemodified] The time this file was modified.
     * @param {boolean} Whether the file is outdated.
     */
    CoreFilepoolProvider.prototype.isFileOutdated = function (entry, revision, timemodified) {
        return !!entry.stale || revision > entry.revision || timemodified > entry.timemodified;
    };
    /**
     * Check if cannot determine if a file has been updated.
     *
     * @param {CoreFilepoolFileEntry} entry Filepool entry.
     * @return {boolean} Whether it cannot determine updates.
     */
    CoreFilepoolProvider.prototype.isFileUpdateUnknown = function (entry) {
        return !!entry.isexternalfile || (entry.revision < 1 && !entry.timemodified);
    };
    /**
     * Notify a file has been deleted.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     */
    CoreFilepoolProvider.prototype.notifyFileDeleted = function (siteId, fileId) {
        this.eventsProvider.trigger(this.getFileEventName(siteId, fileId), { action: 'deleted' });
    };
    /**
     * Notify a file has been downloaded.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     */
    CoreFilepoolProvider.prototype.notifyFileDownloaded = function (siteId, fileId) {
        this.eventsProvider.trigger(this.getFileEventName(siteId, fileId), { action: 'download', success: true });
    };
    /**
     * Notify error occurred while downloading a file.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     */
    CoreFilepoolProvider.prototype.notifyFileDownloadError = function (siteId, fileId) {
        this.eventsProvider.trigger(this.getFileEventName(siteId, fileId), { action: 'download', success: false });
    };
    /**
     * Notify a file starts being downloaded or added to queue.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     */
    CoreFilepoolProvider.prototype.notifyFileDownloading = function (siteId, fileId) {
        this.eventsProvider.trigger(this.getFileEventName(siteId, fileId), { action: 'downloading' });
    };
    /**
     * Notify a file has been outdated.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     */
    CoreFilepoolProvider.prototype.notifyFileOutdated = function (siteId, fileId) {
        this.eventsProvider.trigger(this.getFileEventName(siteId, fileId), { action: 'outdated' });
    };
    /**
     * Prefetches a list of files.
     *
     * @param {string} siteId The site ID.
     * @param {any[]} fileList List of files to download.
     * @param {string} component The component to link the file to.
     * @param {string|number} [componentId] An ID to identify the download.
     * @param {string} [extra] Extra data to store for the package.
     * @param {string} [dirPath] Name of the directory where to store the files (inside filepool dir). If not defined, store
     *                           the files directly inside the filepool folder.
     * @param {Function} [onProgress] Function to call on progress.
     * @return {Promise<any>}  Promise resolved when all files are downloaded.
     */
    CoreFilepoolProvider.prototype.prefetchPackage = function (siteId, fileList, component, componentId, extra, dirPath, onProgress) {
        return this.downloadOrPrefetchPackage(siteId, fileList, true, component, componentId, extra, dirPath, onProgress);
    };
    /**
     * Process the queue.
     *
     * @description
     * This loops over itself to keep on processing the queue in the background.
     * The queue process is site agnostic.
     */
    CoreFilepoolProvider.prototype.processQueue = function () {
        var _this = this;
        var promise;
        if (this.queueState !== this.QUEUE_RUNNING) {
            // Silently ignore, the queue is on pause.
            promise = Promise.reject(this.ERR_QUEUE_ON_PAUSE);
        }
        else if (!this.fileProvider.isAvailable() || !this.appProvider.isOnline()) {
            promise = Promise.reject(this.ERR_FS_OR_NETWORK_UNAVAILABLE);
        }
        else {
            promise = this.processImportantQueueItem();
        }
        promise.then(function () {
            // All good, we schedule next execution.
            setTimeout(function () {
                _this.processQueue();
            }, _this.QUEUE_PROCESS_INTERVAL);
        }, function (error) {
            // We had an error, in which case we pause the processing.
            if (error === _this.ERR_FS_OR_NETWORK_UNAVAILABLE) {
                _this.logger.debug('Filesysem or network unavailable, pausing queue processing.');
            }
            else if (error === _this.ERR_QUEUE_IS_EMPTY) {
                _this.logger.debug('Queue is empty, pausing queue processing.');
            }
            _this.queueState = _this.QUEUE_PAUSED;
        });
    };
    /**
     * Process the most important queue item.
     *
     * @return {Promise} Resolved on success. Rejected on failure.
     */
    CoreFilepoolProvider.prototype.processImportantQueueItem = function () {
        var _this = this;
        return this.appDB.getRecords(this.QUEUE_TABLE, undefined, 'priority DESC, added ASC', undefined, 0, 1).then(function (items) {
            var item = items.pop();
            if (!item) {
                return Promise.reject(_this.ERR_QUEUE_IS_EMPTY);
            }
            // Convert the links to an object.
            item.links = _this.textUtils.parseJSON(item.links, []);
            return _this.processQueueItem(item);
        }, function () {
            return Promise.reject(_this.ERR_QUEUE_IS_EMPTY);
        });
    };
    /**
     * Process a queue item.
     *
     * @param {CoreFilepoolQueueEntry} item The object from the queue store.
     * @return {Promise<any>} Resolved on success. Rejected on failure.
     */
    CoreFilepoolProvider.prototype.processQueueItem = function (item) {
        var _this = this;
        // Cast optional fields to undefined instead of null.
        var siteId = item.siteId, fileId = item.fileId, fileUrl = item.url, options = {
            revision: item.revision || undefined,
            timemodified: item.timemodified || undefined,
            isexternalfile: item.isexternalfile || undefined,
            repositorytype: item.repositorytype || undefined
        }, filePath = item.path || undefined, links = item.links || [];
        this.logger.debug('Processing queue item: ' + siteId + ', ' + fileId);
        // Check if the file is already in pool.
        return this.hasFileInPool(siteId, fileId).catch(function () {
            // File not in pool.
        }).then(function (entry) {
            if (entry && !_this.isFileOutdated(entry, options.revision, options.timemodified)) {
                // We have the file, it is not stale, we can update links and remove from queue.
                _this.logger.debug('Queued file already in store, ignoring...');
                _this.addFileLinks(siteId, fileId, links).catch(function () {
                    // Ignore errors.
                });
                _this.removeFromQueue(siteId, fileId).catch(function () {
                    // Ignore errors.
                }).finally(function () {
                    _this.treatQueueDeferred(siteId, fileId, true);
                });
                _this.notifyFileDownloaded(siteId, fileId);
                return;
            }
            // The file does not exist, or is stale, ... download it.
            var onProgress = _this.getQueueOnProgress(siteId, fileId);
            return _this.downloadForPoolByUrl(siteId, fileUrl, options, filePath, onProgress, entry).then(function () {
                // Success, we add links and remove from queue.
                _this.addFileLinks(siteId, fileId, links).catch(function () {
                    // Ignore errors.
                });
                _this.treatQueueDeferred(siteId, fileId, true);
                _this.notifyFileDownloaded(siteId, fileId);
                // Wait for the item to be removed from queue before resolving the promise.
                // If the item could not be removed from queue we still resolve the promise.
                return _this.removeFromQueue(siteId, fileId).catch(function () {
                    // Ignore errors.
                });
            }, function (errorObject) {
                // Whoops, we have an error...
                var dropFromQueue = false;
                if (errorObject && errorObject.source === fileUrl) {
                    // This is most likely a FileTransfer error.
                    if (errorObject.code === 1) {
                        // The file was not found, most likely a 404, we remove from queue.
                        dropFromQueue = true;
                    }
                    else if (errorObject.code === 2) {
                        // The URL is invalid, we drop the file from the queue.
                        dropFromQueue = true;
                    }
                    else if (errorObject.code === 3) {
                        // If there was an HTTP status, then let's remove from the queue.
                        dropFromQueue = true;
                    }
                    else if (errorObject.code === 4) {
                        // The transfer was aborted, we will keep the file in queue.
                    }
                    else if (errorObject.code === 5) {
                        // We have the latest version of the file, HTTP 304 status.
                        dropFromQueue = true;
                    }
                    else {
                        // Unknown error, let's remove the file from the queue to avoi locking down the queue.
                        dropFromQueue = true;
                    }
                }
                else {
                    dropFromQueue = true;
                }
                if (dropFromQueue) {
                    _this.logger.debug('Item dropped from queue due to error: ' + fileUrl, errorObject);
                    return _this.removeFromQueue(siteId, fileId).catch(function () {
                        // Consider this as a silent error, never reject the promise here.
                    }).then(function () {
                        _this.treatQueueDeferred(siteId, fileId, false);
                        _this.notifyFileDownloadError(siteId, fileId);
                    });
                }
                else {
                    // We considered the file as legit but did not get it, failure.
                    _this.treatQueueDeferred(siteId, fileId, false);
                    _this.notifyFileDownloadError(siteId, fileId);
                    return Promise.reject(errorObject);
                }
            });
        });
    };
    /**
     * Remove a file from the queue.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @return {Promise<any>} Resolved on success. Rejected on failure. It is advised to silently ignore failures.
     */
    CoreFilepoolProvider.prototype.removeFromQueue = function (siteId, fileId) {
        return this.appDB.deleteRecords(this.QUEUE_TABLE, { siteId: siteId, fileId: fileId });
    };
    /**
     * Remove a file from the pool.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @return {Promise<any>} Resolved on success.
     */
    CoreFilepoolProvider.prototype.removeFileById = function (siteId, fileId) {
        var _this = this;
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            // Get the path to the file first since it relies on the file object stored in the pool.
            return Promise.resolve(_this.getFilePath(siteId, fileId)).then(function (path) {
                var promises = [];
                // Remove entry from filepool store.
                promises.push(db.deleteRecords(_this.FILES_TABLE, { fileId: fileId }));
                // Remove links.
                promises.push(db.deleteRecords(_this.LINKS_TABLE, { fileId: fileId }));
                // Remove the file.
                if (_this.fileProvider.isAvailable()) {
                    promises.push(_this.fileProvider.removeFile(path).catch(function (error) {
                        if (error && error.code == 1) {
                            // Not found, ignore error since maybe it was deleted already.
                        }
                        else {
                            return Promise.reject(error);
                        }
                    }));
                }
                return Promise.all(promises).then(function () {
                    _this.notifyFileDeleted(siteId, fileId);
                });
            });
        });
    };
    /**
     * Delete all the matching files from a component.
     *
     * @param {string} siteId The site ID.
     * @param {string} component The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<any>} Resolved on success.
     */
    CoreFilepoolProvider.prototype.removeFilesByComponent = function (siteId, component, componentId) {
        var _this = this;
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            return _this.getComponentFiles(db, component, componentId);
        }).then(function (items) {
            return Promise.all(items.map(function (item) {
                return _this.removeFileById(siteId, item.fileId);
            }));
        });
    };
    /**
     * Remove a file from the pool.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileUrl The file URL.
     * @return {Promise<any>} Resolved on success, rejected on failure.
     */
    CoreFilepoolProvider.prototype.removeFileByUrl = function (siteId, fileUrl) {
        var _this = this;
        return this.fixPluginfileURL(siteId, fileUrl).then(function (fileUrl) {
            var fileId = _this.getFileIdByUrl(fileUrl);
            return _this.removeFileById(siteId, fileId);
        });
    };
    /**
     * Removes the revision number from a file URL.
     *
     * @param {string} url URL to remove the revision number.
     * @return {string} URL without revision number.
     * @description
     * The revision is used to know if a file has changed. We remove it from the URL to prevent storing a file per revision.
     */
    CoreFilepoolProvider.prototype.removeRevisionFromUrl = function (url) {
        var args = this.getPluginFileArgs(url);
        if (!args) {
            // Not a pluginfile, no revision will be found.
            return url;
        }
        return this.pluginFileDelegate.removeRevisionFromUrl(url, args);
    };
    /**
     * Change the package status, setting it to the previous status.
     *
     * @param {string} siteId Site ID.
     * @param {string} component Package's component.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<string>} Promise resolved when the status is changed. Resolve param: new status.
     */
    CoreFilepoolProvider.prototype.setPackagePreviousStatus = function (siteId, component, componentId) {
        var _this = this;
        componentId = this.fixComponentId(componentId);
        this.logger.debug("Set previous status for package " + component + " " + componentId);
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var packageId = _this.getPackageId(component, componentId);
            // Get current stored data, we'll only update 'status' and 'updated' fields.
            return site.getDb().getRecord(_this.PACKAGES_TABLE, { id: packageId }).then(function (entry) {
                var newData = {};
                if (entry.status == __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].DOWNLOADING) {
                    // Going back from downloading to previous status, restore previous download time.
                    newData.downloadTime = entry.previousDownloadTime;
                }
                newData.status = entry.previous || __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].DOWNLOADED;
                newData.updated = Date.now();
                _this.logger.debug("Set previous status '" + entry.status + "' for package " + component + " " + componentId);
                return site.getDb().updateRecords(_this.PACKAGES_TABLE, newData, { id: packageId }).then(function () {
                    // Success updating, trigger event.
                    _this.triggerPackageStatusChanged(site.id, newData.status, component, componentId);
                    return newData.status;
                });
            });
        });
    };
    /**
     * Convenience function to check if a file should be downloaded before opening it.
     *
     * @param {string} url File online URL.
     * @param {number} size File size.
     * @return {Promise}     Promise resolved if should download before open, rejected otherwise.
     * @description
     * Convenience function to check if a file should be downloaded before opening it.
     *
     * The default behaviour in the app is to download first and then open the local file in the following cases:
     *     - The file is small (less than DOWNLOAD_THRESHOLD).
     *     - The file cannot be streamed.
     * If the file is big and can be streamed, the promise returned by this function will be rejected.
     */
    CoreFilepoolProvider.prototype.shouldDownloadBeforeOpen = function (url, size) {
        if (size >= 0 && size <= this.DOWNLOAD_THRESHOLD) {
            // The file is small, download it.
            return Promise.resolve();
        }
        if (this.appProvider.isDesktop()) {
            // In desktop always download first.
            return Promise.resolve();
        }
        return this.mimeUtils.getMimeTypeFromUrl(url).then(function (mimetype) {
            // If the file is streaming (audio or video) we reject.
            if (mimetype.indexOf('video') != -1 || mimetype.indexOf('audio') != -1) {
                return Promise.reject(null);
            }
        });
    };
    /**
     * Store package status.
     *
     * @param {string} siteId Site ID.
     * @param {string} status New package status.
     * @param {string} component Package's component.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {string} [extra] Extra data to store for the package. If you want to store more than 1 value, use JSON.stringify.
     * @return {Promise<any>} Promise resolved when status is stored.
     */
    CoreFilepoolProvider.prototype.storePackageStatus = function (siteId, status, component, componentId, extra) {
        var _this = this;
        this.logger.debug("Set status '" + status + "' for package " + component + " " + componentId);
        componentId = this.fixComponentId(componentId);
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var packageId = _this.getPackageId(component, componentId);
            var downloadTime, previousDownloadTime;
            if (status == __WEBPACK_IMPORTED_MODULE_15__core_constants__["a" /* CoreConstants */].DOWNLOADING) {
                // Set download time if package is now downloading.
                downloadTime = _this.timeUtils.timestamp();
            }
            // Search current status to set it as previous status.
            return site.getDb().getRecord(_this.PACKAGES_TABLE, { id: packageId }).then(function (entry) {
                if (typeof extra == 'undefined' || extra === null) {
                    extra = entry.extra;
                }
                if (typeof downloadTime == 'undefined') {
                    // Keep previous download time.
                    downloadTime = entry.downloadTime;
                    previousDownloadTime = entry.previousDownloadTime;
                }
                else {
                    // The downloadTime will be updated, store current time as previous.
                    previousDownloadTime = entry.downloadTime;
                }
                return entry.status;
            }).catch(function () {
                // No previous status.
            }).then(function (previousStatus) {
                var packageEntry = {
                    id: packageId,
                    component: component,
                    componentId: componentId,
                    status: status,
                    previous: previousStatus,
                    updated: Date.now(),
                    downloadTime: downloadTime,
                    previousDownloadTime: previousDownloadTime,
                    extra: extra
                };
                var promise;
                if (previousStatus === status) {
                    // The package already has this status, no need to change it.
                    promise = Promise.resolve();
                }
                else {
                    promise = site.getDb().insertOrUpdateRecord(_this.PACKAGES_TABLE, packageEntry, { id: packageId });
                }
                return promise.then(function () {
                    // Success inserting, trigger event.
                    _this.triggerPackageStatusChanged(siteId, status, component, componentId);
                });
            });
        });
    };
    /**
     * Remove extension from fileId in queue, used to migrate from previous file handling.
     *
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreFilepoolProvider.prototype.treatExtensionInQueue = function () {
        var _this = this;
        this.logger.debug('Treat extensions in queue');
        return this.appDB.getAllRecords(this.QUEUE_TABLE).then(function (entries) {
            var promises = [];
            entries.forEach(function (entry) {
                // For files in the queue, we only need to remove the extension from the fileId.
                // After downloading, additional info will be added.
                var fileId = entry.fileId;
                entry.fileId = _this.mimeUtils.removeExtension(fileId);
                if (fileId == entry.fileId) {
                    return;
                }
                promises.push(_this.appDB.updateRecords(_this.QUEUE_TABLE, { fileId: entry.fileId }, { fileId: fileId }));
            });
            return Promise.all(promises);
        });
    };
    /**
     * Resolves or rejects a queue deferred and removes it from the list.
     *
     * @param {string} siteId The site ID.
     * @param {string} fileId The file ID.
     * @param {boolean} resolve True if promise should be resolved, false if it should be rejected.
     */
    CoreFilepoolProvider.prototype.treatQueueDeferred = function (siteId, fileId, resolve) {
        if (this.queueDeferreds[siteId] && this.queueDeferreds[siteId][fileId]) {
            if (resolve) {
                this.queueDeferreds[siteId][fileId].resolve();
            }
            else {
                this.queueDeferreds[siteId][fileId].reject();
            }
            delete this.queueDeferreds[siteId][fileId];
        }
    };
    /**
     * Trigger mmCoreEventPackageStatusChanged with the right data.
     *
     * @param {string} siteId Site ID.
     * @param {string} status New package status.
     * @param {string} component  Package's component.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     */
    CoreFilepoolProvider.prototype.triggerPackageStatusChanged = function (siteId, status, component, componentId) {
        var data = {
            component: component,
            componentId: this.fixComponentId(componentId),
            status: status
        };
        this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_3__events__["a" /* CoreEventsProvider */].PACKAGE_STATUS_CHANGED, data, siteId);
    };
    /**
     * Update the download time of a package. This doesn't modify the previous download time.
     * This function should be used if a package generates some new data during a download. Calling this function
     * right after generating the data in the download will prevent detecting this data as an update.
     *
     * @param {string} siteId Site ID.
     * @param {string} component Package's component.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @return {Promise<any>} Promise resolved when status is stored.
     */
    CoreFilepoolProvider.prototype.updatePackageDownloadTime = function (siteId, component, componentId) {
        var _this = this;
        componentId = this.fixComponentId(componentId);
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var packageId = _this.getPackageId(component, componentId);
            return site.getDb().updateRecords(_this.PACKAGES_TABLE, { downloadTime: _this.timeUtils.timestamp() }, { id: packageId });
        });
    };
    CoreFilepoolProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_4__file__["a" /* CoreFileProvider */],
            __WEBPACK_IMPORTED_MODULE_8__sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_9__ws__["a" /* CoreWSProvider */], __WEBPACK_IMPORTED_MODULE_11__utils_text__["a" /* CoreTextUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_14__utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_10__utils_mimetype__["a" /* CoreMimetypeUtilsProvider */], __WEBPACK_IMPORTED_MODULE_13__utils_url__["a" /* CoreUrlUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_12__utils_time__["a" /* CoreTimeUtilsProvider */], __WEBPACK_IMPORTED_MODULE_3__events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_5__init__["a" /* CoreInitDelegate */],
            __WEBPACK_IMPORTED_MODULE_1__ionic_native_network__["a" /* Network */], __WEBPACK_IMPORTED_MODULE_7__plugin_file_delegate__["a" /* CorePluginFileDelegate */]])
    ], CoreFilepoolProvider);
    return CoreFilepoolProvider;
}());

//# sourceMappingURL=filepool.js.map

/***/ }),
/* 36 */,
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreDirectivesModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__auto_focus__ = __webpack_require__(762);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__download_file__ = __webpack_require__(1034);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__external_content__ = __webpack_require__(583);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__format_text__ = __webpack_require__(1036);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__link__ = __webpack_require__(584);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__keep_keyboard__ = __webpack_require__(1037);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__user_link__ = __webpack_require__(1038);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__auto_rows__ = __webpack_require__(1039);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__long_press__ = __webpack_require__(1040);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};










var CoreDirectivesModule = /** @class */ (function () {
    function CoreDirectivesModule() {
    }
    CoreDirectivesModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_1__auto_focus__["a" /* CoreAutoFocusDirective */],
                __WEBPACK_IMPORTED_MODULE_2__download_file__["a" /* CoreDownloadFileDirective */],
                __WEBPACK_IMPORTED_MODULE_3__external_content__["a" /* CoreExternalContentDirective */],
                __WEBPACK_IMPORTED_MODULE_4__format_text__["a" /* CoreFormatTextDirective */],
                __WEBPACK_IMPORTED_MODULE_6__keep_keyboard__["a" /* CoreKeepKeyboardDirective */],
                __WEBPACK_IMPORTED_MODULE_5__link__["a" /* CoreLinkDirective */],
                __WEBPACK_IMPORTED_MODULE_7__user_link__["a" /* CoreUserLinkDirective */],
                __WEBPACK_IMPORTED_MODULE_8__auto_rows__["a" /* CoreAutoRowsDirective */],
                __WEBPACK_IMPORTED_MODULE_9__long_press__["a" /* CoreLongPressDirective */]
            ],
            imports: [],
            exports: [
                __WEBPACK_IMPORTED_MODULE_1__auto_focus__["a" /* CoreAutoFocusDirective */],
                __WEBPACK_IMPORTED_MODULE_2__download_file__["a" /* CoreDownloadFileDirective */],
                __WEBPACK_IMPORTED_MODULE_3__external_content__["a" /* CoreExternalContentDirective */],
                __WEBPACK_IMPORTED_MODULE_4__format_text__["a" /* CoreFormatTextDirective */],
                __WEBPACK_IMPORTED_MODULE_6__keep_keyboard__["a" /* CoreKeepKeyboardDirective */],
                __WEBPACK_IMPORTED_MODULE_5__link__["a" /* CoreLinkDirective */],
                __WEBPACK_IMPORTED_MODULE_7__user_link__["a" /* CoreUserLinkDirective */],
                __WEBPACK_IMPORTED_MODULE_8__auto_rows__["a" /* CoreAutoRowsDirective */],
                __WEBPACK_IMPORTED_MODULE_9__long_press__["a" /* CoreLongPressDirective */]
            ]
        })
    ], CoreDirectivesModule);
    return CoreDirectivesModule;
}());

//# sourceMappingURL=directives.module.js.map

/***/ }),
/* 41 */,
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreUrlUtilsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lang__ = __webpack_require__(96);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/*
 * "Utils" service with helper functions for URLs.
 */
var CoreUrlUtilsProvider = /** @class */ (function () {
    function CoreUrlUtilsProvider(langProvider) {
        this.langProvider = langProvider;
    }
    /**
     * Add or remove 'www' from a URL. The url needs to have http or https protocol.
     *
     * @param {string} url URL to modify.
     * @return {string} Modified URL.
     */
    CoreUrlUtilsProvider.prototype.addOrRemoveWWW = function (url) {
        if (url) {
            if (url.match(/http(s)?:\/\/www\./)) {
                // Already has www. Remove it.
                url = url.replace('www.', '');
            }
            else {
                url = url.replace('https://', 'https://www.');
                url = url.replace('http://', 'http://www.');
            }
        }
        return url;
    };
    /**
     * Extracts the parameters from a URL and stores them in an object.
     *
     * @param {string} url URL to treat.
     * @return {any} Object with the params.
     */
    CoreUrlUtilsProvider.prototype.extractUrlParams = function (url) {
        var regex = /[?&]+([^=&]+)=?([^&]*)?/gi, params = {};
        url.replace(regex, function (match, key, value) {
            params[key] = typeof value != 'undefined' ? value : '';
            return match;
        });
        return params;
    };
    /**
     * Generic function for adding the wstoken to Moodle urls and for pointing to the correct script.
     * For download remote files from Moodle we need to use the special /webservice/pluginfile passing
     * the ws token as a get parameter.
     *
     * @param {string} url The url to be fixed.
     * @param {string} token Token to use.
     * @return {string} Fixed URL.
     */
    CoreUrlUtilsProvider.prototype.fixPluginfileURL = function (url, token) {
        if (!url || !token) {
            return '';
        }
        // First check if we need to fix this url or is already fixed.
        if (url.indexOf('token=') != -1) {
            return url;
        }
        // Check if is a valid URL (contains the pluginfile endpoint).
        if (!this.isPluginFileUrl(url)) {
            return url;
        }
        // In which way the server is serving the files? Are we using slash parameters?
        if (url.indexOf('?file=') != -1 || url.indexOf('?forcedownload=') != -1 || url.indexOf('?rev=') != -1) {
            url += '&';
        }
        else {
            url += '?';
        }
        // Always send offline=1 (for external repositories). It shouldn't cause problems for local files or old Moodles.
        url += 'token=' + token + '&offline=1';
        // Some webservices returns directly the correct download url, others not.
        if (url.indexOf('/webservice/pluginfile') == -1) {
            url = url.replace('/pluginfile', '/webservice/pluginfile');
        }
        return url;
    };
    /**
     * Formats a URL, trim, lowercase, etc...
     *
     * @param {string} url The url to be formatted.
     * @return {string} Fromatted url.
     */
    CoreUrlUtilsProvider.prototype.formatURL = function (url) {
        url = url.trim();
        // Check if the URL starts by http or https.
        if (!/^http(s)?\:\/\/.*/i.test(url)) {
            // Test first allways https.
            url = 'https://' + url;
        }
        // http allways in lowercase.
        url = url.replace(/^http/i, 'http');
        url = url.replace(/^https/i, 'https');
        // Replace last slash.
        url = url.replace(/\/$/, '');
        return url;
    };
    /**
     * Returns the URL to the documentation of the app, based on Moodle version and current language.
     *
     * @param {string} [release] Moodle release.
     * @param {string} [page=Mobile_app] Docs page to go to.
     * @return {Promise<string>} Promise resolved with the Moodle docs URL.
     */
    CoreUrlUtilsProvider.prototype.getDocsUrl = function (release, page) {
        if (page === void 0) { page = 'Mobile_app'; }
        var docsUrl = 'https://docs.moodle.org/en/' + page;
        if (typeof release != 'undefined') {
            var version = release.substr(0, 3).replace('.', '');
            // Check is a valid number.
            if (parseInt(version) >= 24) {
                // Append release number.
                docsUrl = docsUrl.replace('https://docs.moodle.org/', 'https://docs.moodle.org/' + version + '/');
            }
        }
        return this.langProvider.getCurrentLanguage().then(function (lang) {
            return docsUrl.replace('/en/', '/' + lang + '/');
        }).catch(function () {
            return docsUrl;
        });
    };
    /**
     * Given a URL, returns what's after the last '/' without params.
     * Example:
     * http://mysite.com/a/course.html?id=1 -> course.html
     *
     * @param {string} url URL to treat.
     * @return {string} Last file without params.
     */
    CoreUrlUtilsProvider.prototype.getLastFileWithoutParams = function (url) {
        var filename = url.substr(url.lastIndexOf('/') + 1);
        if (filename.indexOf('?') != -1) {
            filename = filename.substr(0, filename.indexOf('?'));
        }
        return filename;
    };
    /**
     * Get the protocol from a URL.
     * E.g. http://www.google.com returns 'http'.
     *
     * @param {string} url URL to treat.
     * @return {string} Protocol, undefined if no protocol found.
     */
    CoreUrlUtilsProvider.prototype.getUrlProtocol = function (url) {
        if (!url) {
            return;
        }
        var matches = url.match(/^([^\/:\.\?]*):\/\//);
        if (matches && matches[1]) {
            return matches[1];
        }
    };
    /**
     * Get the scheme from a URL. Please notice that, if a URL has protocol, it will return the protocol.
     * E.g. javascript:doSomething() returns 'javascript'.
     *
     * @param {string} url URL to treat.
     * @return {string} Scheme, undefined if no scheme found.
     */
    CoreUrlUtilsProvider.prototype.getUrlScheme = function (url) {
        if (!url) {
            return;
        }
        var matches = url.match(/^([a-z][a-z0-9+\-.]*):/);
        if (matches && matches[1]) {
            return matches[1];
        }
    };
    /*
     * Gets a username from a URL like: user@mysite.com.
     *
     * @param {string} url URL to treat.
     * @return {string} Username. Undefined if no username found.
     */
    CoreUrlUtilsProvider.prototype.getUsernameFromUrl = function (url) {
        if (url.indexOf('@') > -1) {
            // Get URL without protocol.
            var withoutProtocol = url.replace(/.*?:\/\//, ''), matches = withoutProtocol.match(/[^@]*/);
            // Make sure that @ is at the start of the URL, not in a param at the end.
            if (matches && matches.length && !matches[0].match(/[\/|?]/)) {
                return matches[0];
            }
        }
    };
    /**
     * Returns if a URL has any protocol (not a relative URL).
     *
     * @param {string} url The url to test against the pattern.
     * @return {boolean} Whether the url is absolute.
     */
    CoreUrlUtilsProvider.prototype.isAbsoluteURL = function (url) {
        return /^[^:]{2,}:\/\//i.test(url) || /^(tel:|mailto:|geo:)/.test(url);
    };
    /**
     * Returns if a URL is downloadable: plugin file OR theme/image.php OR gravatar.
     *
     * @param {string} url The URL to test.
     * @return {boolean} Whether the URL is downloadable.
     */
    CoreUrlUtilsProvider.prototype.isDownloadableUrl = function (url) {
        return this.isPluginFileUrl(url) || this.isThemeImageUrl(url) || this.isGravatarUrl(url);
    };
    /**
     * Returns if a URL is a gravatar URL.
     *
     * @param {string} url The URL to test.
     * @return {boolean} Whether the URL is a gravatar URL.
     */
    CoreUrlUtilsProvider.prototype.isGravatarUrl = function (url) {
        return url && url.indexOf('gravatar.com/avatar') !== -1;
    };
    /**
     * Check if a URL uses http or https protocol.
     *
     * @param {string} url The url to test.
     * @return {boolean} Whether the url uses http or https protocol.
     */
    CoreUrlUtilsProvider.prototype.isHttpURL = function (url) {
        return /^https?\:\/\/.+/i.test(url);
    };
    /**
     * Returns if a URL is a pluginfile URL.
     *
     * @param {string} url The URL to test.
     * @return {boolean} Whether the URL is a pluginfile URL.
     */
    CoreUrlUtilsProvider.prototype.isPluginFileUrl = function (url) {
        return url && url.indexOf('/pluginfile.php') !== -1;
    };
    /**
     * Returns if a URL is a theme image URL.
     *
     * @param {string} url The URL to test.
     * @return {boolean} Whether the URL is a theme image URL.
     */
    CoreUrlUtilsProvider.prototype.isThemeImageUrl = function (url) {
        return url && url.indexOf('/theme/image.php') !== -1;
    };
    /**
     * Remove protocol and www from a URL.
     *
     * @param {string} url URL to treat.
     * @return {string} Treated URL.
     */
    CoreUrlUtilsProvider.prototype.removeProtocolAndWWW = function (url) {
        // Remove protocol.
        url = url.replace(/.*?:\/\//g, '');
        // Remove www.
        url = url.replace(/^www./, '');
        return url;
    };
    /**
     * Remove the parameters from a URL, returning the URL without them.
     *
     * @param {string} url URL to treat.
     * @return {string} URL without params.
     */
    CoreUrlUtilsProvider.prototype.removeUrlParams = function (url) {
        var matches = url.match(/^[^\?]+/);
        return matches && matches[0];
    };
    CoreUrlUtilsProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__lang__["a" /* CoreLangProvider */]])
    ], CoreUrlUtilsProvider);
    return CoreUrlUtilsProvider;
}());

//# sourceMappingURL=url.js.map

/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreContentLinksHandlerBase; });
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * Base handler to be registered in CoreContentLinksHandler. It is useful to minimize the amount of
 * functions that handlers need to implement.
 *
 * It allows you to specify a "pattern" (RegExp) that will be used to check if the handler handles a URL and to get its site URL.
 */
var CoreContentLinksHandlerBase = /** @class */ (function () {
    function CoreContentLinksHandlerBase() {
        /**
         * A name to identify the handler.
         * @type {string}
         */
        this.name = 'CoreContentLinksHandlerBase';
        /**
         * Handler's priority. The highest priority is treated first.
         * @type {number}
         */
        this.priority = 0;
        /**
         * Whether the isEnabled function should be called for all the users in a site. It should be true only if the isEnabled call
         * can return different values for different users in same site.
         * @type {boolean}
         */
        this.checkAllUsers = false;
        /**
         * Name of the feature this handler is related to.
         * It will be used to check if the feature is disabled (@see CoreSite.isFeatureDisabled).
         * @type {string}
         */
        this.featureName = '';
        // Nothing to do.
    }
    /**
     * Get the list of actions for a link (url).
     *
     * @param {string[]} siteIds List of sites the URL belongs to.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {CoreContentLinksAction[]|Promise<CoreContentLinksAction[]>} List of (or promise resolved with list of) actions.
     */
    CoreContentLinksHandlerBase.prototype.getActions = function (siteIds, url, params, courseId) {
        return [];
    };
    /**
     * Check if a URL is handled by this handler.
     *
     * @param {string} url The URL to check.
     * @return {boolean} Whether the URL is handled by this handler
     */
    CoreContentLinksHandlerBase.prototype.handles = function (url) {
        return this.pattern && url.search(this.pattern) >= 0;
    };
    /**
     * If the URL is handled by this handler, return the site URL.
     *
     * @param {string} url The URL to check.
     * @return {string} Site URL if it is handled, undefined otherwise.
     */
    CoreContentLinksHandlerBase.prototype.getSiteUrl = function (url) {
        if (this.pattern) {
            var position = url.search(this.pattern);
            if (position > -1) {
                return url.substr(0, position);
            }
        }
    };
    /**
     * Check if the handler is enabled for a certain site (site + user) and a URL.
     * If not defined, defaults to true.
     *
     * @param {string} siteId The site ID.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {boolean|Promise<boolean>} Whether the handler is enabled for the URL and site.
     */
    CoreContentLinksHandlerBase.prototype.isEnabled = function (siteId, url, params, courseId) {
        return true;
    };
    return CoreContentLinksHandlerBase;
}());

//# sourceMappingURL=base-handler.js.map

/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreMimetypeUtilsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(104);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__text__ = __webpack_require__(13);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/*
 * "Utils" service with helper functions for mimetypes and extensions.
 */
var CoreMimetypeUtilsProvider = /** @class */ (function () {
    function CoreMimetypeUtilsProvider(http, logger, translate, textUtils) {
        var _this = this;
        this.translate = translate;
        this.textUtils = textUtils;
        this.extToMime = {}; // Object to map extensions -> mimetypes.
        this.mimeToExt = {}; // Object to map mimetypes -> extensions.
        this.groupsMimeInfo = {}; // Object to hold extensions and mimetypes that belong to a certain "group" (audio, video, ...).
        this.extensionRegex = /^[a-z0-9]+$/;
        this.wsProvider = {}; // @todo
        this.logger = logger.getInstance('CoreMimetypeUtilsProvider');
        http.get('assets/exttomime.json').subscribe(function (result) {
            _this.extToMime = result;
        }, function (err) {
            // Error, shouldn't happen.
        });
        http.get('assets/mimetoext.json').subscribe(function (result) {
            _this.mimeToExt = result;
        }, function (err) {
            // Error, shouldn't happen.
        });
    }
    /**
     * Check if a file extension can be embedded without using iframes.
     *
     * @param {string} extension Extension.
     * @return {boolean} Whether it can be embedded.
     */
    CoreMimetypeUtilsProvider.prototype.canBeEmbedded = function (extension) {
        return this.isExtensionInGroup(extension, ['web_image', 'web_video', 'web_audio']);
    };
    /**
     * Clean a extension, removing the dot, hash, extra params...
     *
     * @param {string} extension Extension to clean.
     * @return {string} Clean extension.
     */
    CoreMimetypeUtilsProvider.prototype.cleanExtension = function (extension) {
        if (!extension) {
            return extension;
        }
        // If the extension has parameters, remove them.
        var position = extension.indexOf('?');
        if (position > -1) {
            extension = extension.substr(0, position);
        }
        // Remove hash in extension if there's any (added by filepool).
        extension = extension.replace(/_.{32}$/, '');
        // Remove dot from the extension if found.
        if (extension && extension[0] == '.') {
            extension = extension.substr(1);
        }
        return extension;
    };
    /**
     * Fill the mimetypes and extensions info for a certain group.
     *
     * @param {string} group Group name.
     */
    CoreMimetypeUtilsProvider.prototype.fillGroupMimeInfo = function (group) {
        var mimetypes = {}, // Use an object to prevent duplicates.
        extensions = []; // Extensions are unique.
        for (var extension in this.extToMime) {
            var data = this.extToMime[extension];
            if (data.type && data.groups && data.groups.indexOf(group) != -1) {
                // This extension has the group, add it to the list.
                mimetypes[data.type] = true;
                extensions.push(extension);
            }
        }
        this.groupsMimeInfo[group] = {
            mimetypes: Object.keys(mimetypes),
            extensions: extensions
        };
    };
    /**
     * Get the extension of a mimetype. Returns undefined if not found.
     *
     * @param {string} mimetype Mimetype.
     * @param {string} [url] URL of the file. It will be used if there's more than one possible extension.
     * @return {string} Extension.
     */
    CoreMimetypeUtilsProvider.prototype.getExtension = function (mimetype, url) {
        mimetype = mimetype || '';
        mimetype = mimetype.split(';')[0]; // Remove codecs from the mimetype if any.
        if (mimetype == 'application/x-forcedownload' || mimetype == 'application/forcedownload') {
            // Couldn't get the right mimetype, try to guess it.
            return this.guessExtensionFromUrl(url);
        }
        var extensions = this.mimeToExt[mimetype];
        if (extensions && extensions.length) {
            if (extensions.length > 1 && url) {
                // There's more than one possible extension. Check if the URL has extension.
                var candidate = this.guessExtensionFromUrl(url);
                if (extensions.indexOf(candidate) != -1) {
                    return candidate;
                }
            }
            return extensions[0];
        }
    };
    /**
     * Get the "type" (string) of an extension, something like "image", "video" or "audio".
     *
     * @param {string} extension Extension.
     * @return {string} Type of the extension.
     */
    CoreMimetypeUtilsProvider.prototype.getExtensionType = function (extension) {
        extension = this.cleanExtension(extension);
        if (this.extToMime[extension] && this.extToMime[extension].string) {
            return this.extToMime[extension].string;
        }
    };
    /**
     * Get all the possible extensions of a mimetype. Returns empty array if not found.
     *
     * @param {string} mimetype Mimetype.
     * @return {string[]} Extensions.
     */
    CoreMimetypeUtilsProvider.prototype.getExtensions = function (mimetype) {
        mimetype = mimetype || '';
        mimetype = mimetype.split(';')[0]; // Remove codecs from the mimetype if any.
        return this.mimeToExt[mimetype] || [];
    };
    /**
     * Get a file icon URL based on its file name.
     *
     * @param {string} The name of the file.
     * @return {string} The path to a file icon.
     */
    CoreMimetypeUtilsProvider.prototype.getFileIcon = function (filename) {
        var ext = this.getFileExtension(filename);
        var icon = 'unknown';
        if (ext && this.extToMime[ext]) {
            if (this.extToMime[ext].icon) {
                icon = this.extToMime[ext].icon;
            }
            else {
                var type = this.extToMime[ext].type.split('/')[0];
                if (type == 'video' || type == 'text' || type == 'image' || type == 'document' || type == 'audio') {
                    icon = type;
                }
            }
        }
        return 'assets/img/files/' + icon + '-64.png';
    };
    /**
     * Get the folder icon URL.
     *
     * @return {string} The path to a folder icon.
     */
    CoreMimetypeUtilsProvider.prototype.getFolderIcon = function () {
        return 'assets/img/files/folder-64.png';
    };
    /**
     * Get the mimetype of a file given its URL. It'll try to guess it using the URL, if that fails then it'll
     * perform a HEAD request to get it. It's done in this order because pluginfile.php can return wrong mimetypes.
     *
     * @param {string} url The URL of the file.
     * @return {Promise<string>} Promise resolved with the mimetype.
     */
    CoreMimetypeUtilsProvider.prototype.getMimeTypeFromUrl = function (url) {
        // First check if it can be guessed from the URL.
        var extension = this.guessExtensionFromUrl(url), mimetype = this.getMimeType(extension);
        if (mimetype) {
            return Promise.resolve(mimetype);
        }
        // Can't be guessed, get the remote mimetype.
        return this.wsProvider.getRemoteFileMimeType(url).then(function (mimetype) {
            return mimetype || '';
        });
    };
    /**
     * Guess the extension of a file from its URL.
     * This is very weak and unreliable.
     *
     * @param {string} fileUrl The file URL.
     * @return {string} The lowercased extension without the dot, or undefined.
     */
    CoreMimetypeUtilsProvider.prototype.guessExtensionFromUrl = function (fileUrl) {
        var split = fileUrl.split('.');
        var candidate, extension, position;
        if (split.length > 1) {
            candidate = split.pop().toLowerCase();
            // Remove params if any.
            position = candidate.indexOf('?');
            if (position > -1) {
                candidate = candidate.substr(0, position);
            }
            if (this.extensionRegex.test(candidate)) {
                extension = candidate;
            }
        }
        // Check extension corresponds to a mimetype to know if it's valid.
        if (extension && typeof this.getMimeType(extension) == 'undefined') {
            this.logger.warn('Guess file extension: Not valid extension ' + extension);
            return;
        }
        return extension;
    };
    /**
     * Returns the file extension of a file.
     * When the file does not have an extension, it returns undefined.
     *
     * @param {string} filename The file name.
     * @return {string} The lowercased extension, or undefined.
     */
    CoreMimetypeUtilsProvider.prototype.getFileExtension = function (filename) {
        var dot = filename.lastIndexOf('.');
        var ext;
        if (dot > -1) {
            ext = filename.substr(dot + 1).toLowerCase();
            ext = this.cleanExtension(ext);
            // Check extension corresponds to a mimetype to know if it's valid.
            if (typeof this.getMimeType(ext) == 'undefined') {
                this.logger.warn('Get file extension: Not valid extension ' + ext);
                return;
            }
        }
        return ext;
    };
    /**
     * Get the mimetype/extension info belonging to a certain group.
     *
     * @param {string} group Group name.
     * @param {string} [field] The field to get. If not supplied, all the info will be returned.
     * @return {any} Info for the group.
     */
    CoreMimetypeUtilsProvider.prototype.getGroupMimeInfo = function (group, field) {
        if (typeof this.groupsMimeInfo[group] == 'undefined') {
            this.fillGroupMimeInfo(group);
        }
        if (field) {
            return this.groupsMimeInfo[group][field];
        }
        return this.groupsMimeInfo[group];
    };
    /**
     * Get the mimetype of an extension. Returns undefined if not found.
     *
     * @param {string} extension Extension.
     * @return {string} Mimetype.
     */
    CoreMimetypeUtilsProvider.prototype.getMimeType = function (extension) {
        extension = this.cleanExtension(extension);
        if (this.extToMime[extension] && this.extToMime[extension].type) {
            return this.extToMime[extension].type;
        }
    };
    /**
     * Obtains descriptions for file types (e.g. 'Microsoft Word document') from the language file.
     * Based on Moodle's get_mimetype_description.
     *
     * @param {any} obj Instance of FileEntry OR object with 'filename' and 'mimetype' OR string with mimetype.
     * @param {boolean} [capitalise] If true, capitalises first character of result.
     * @return {string} Type description.
     */
    CoreMimetypeUtilsProvider.prototype.getMimetypeDescription = function (obj, capitalise) {
        var langPrefix = 'assets.mimetypes.';
        var filename = '', mimetype = '', extension = '';
        if (typeof obj == 'object' && typeof obj.file == 'function') {
            // It's a FileEntry. Don't use the file function because it's asynchronous and the type isn't reliable.
            filename = obj.name;
        }
        else if (typeof obj == 'object') {
            filename = obj.filename || '';
            mimetype = obj.mimetype || '';
        }
        else {
            mimetype = obj;
        }
        if (filename) {
            extension = this.getFileExtension(filename);
            if (!mimetype) {
                // Try to calculate the mimetype using the extension.
                mimetype = this.getMimeType(extension);
            }
        }
        if (!mimetype) {
            // Don't have the mimetype, stop.
            return '';
        }
        if (!extension) {
            extension = this.getExtension(mimetype);
        }
        var mimetypeStr = this.getMimetypeType(mimetype) || '', chunks = mimetype.split('/'), attr = {
            mimetype: mimetype,
            ext: extension || '',
            mimetype1: chunks[0],
            mimetype2: chunks[1] || '',
        }, translateParams = {};
        for (var key in attr) {
            var value = attr[key];
            translateParams[key] = value;
            translateParams[key.toUpperCase()] = value.toUpperCase();
            translateParams[this.textUtils.ucFirst(key)] = this.textUtils.ucFirst(value);
        }
        // MIME types may include + symbol but this is not permitted in string ids.
        var safeMimetype = mimetype.replace(/\+/g, '_'), safeMimetypeStr = mimetypeStr.replace(/\+/g, '_'), safeMimetypeTrns = this.translate.instant(langPrefix + safeMimetype, { $a: translateParams }), safeMimetypeStrTrns = this.translate.instant(langPrefix + safeMimetypeStr, { $a: translateParams }), defaultTrns = this.translate.instant(langPrefix + 'default', { $a: translateParams });
        var result = mimetype;
        if (safeMimetypeTrns != langPrefix + safeMimetype) {
            result = safeMimetypeTrns;
        }
        else if (safeMimetypeStrTrns != langPrefix + safeMimetypeStr) {
            result = safeMimetypeStrTrns;
        }
        else if (defaultTrns != langPrefix + 'default') {
            result = defaultTrns;
        }
        if (capitalise) {
            result = this.textUtils.ucFirst(result);
        }
        return result;
    };
    /**
     * Get the "type" (string) of a mimetype, something like "image", "video" or "audio".
     *
     * @param {string} mimetype Mimetype.
     * @return {string} Type of the mimetype.
     */
    CoreMimetypeUtilsProvider.prototype.getMimetypeType = function (mimetype) {
        mimetype = mimetype.split(';')[0]; // Remove codecs from the mimetype if any.
        var extensions = this.mimeToExt[mimetype];
        if (!extensions) {
            return;
        }
        for (var i = 0; i < extensions.length; i++) {
            var extension = extensions[i];
            if (this.extToMime[extension] && this.extToMime[extension].string) {
                return this.extToMime[extension].string;
            }
        }
    };
    /**
     * Given a group name, return the translated name.
     *
     * @param {string} name Group name.
     * @return {string} Translated name.
     */
    CoreMimetypeUtilsProvider.prototype.getTranslatedGroupName = function (name) {
        var key = 'assets.mimetypes.group:' + name, translated = this.translate.instant(key);
        return translated != key ? translated : name;
    };
    /**
     * Check if an extension belongs to at least one of the groups.
     * Similar to Moodle's file_mimetype_in_typegroup, but using the extension instead of mimetype.
     *
     * @param {string} extension Extension.
     * @param {string[]} groups List of groups to check.
     * @return {boolean} Whether the extension belongs to any of the groups.
     */
    CoreMimetypeUtilsProvider.prototype.isExtensionInGroup = function (extension, groups) {
        extension = this.cleanExtension(extension);
        if (groups && groups.length && this.extToMime[extension] && this.extToMime[extension].groups) {
            for (var i = 0; i < this.extToMime[extension].groups.length; i++) {
                var group = this.extToMime[extension].groups[i];
                if (groups.indexOf(group) != -1) {
                    return true;
                }
            }
        }
        return false;
    };
    /**
     * Remove the extension from a path (if any).
     *
     * @param {string} path Path.
     * @return {string} Path without extension.
     */
    CoreMimetypeUtilsProvider.prototype.removeExtension = function (path) {
        var position = path.lastIndexOf('.');
        var extension;
        if (position > -1) {
            // Check extension corresponds to a mimetype to know if it's valid.
            extension = path.substr(position + 1);
            if (typeof this.getMimeType(extension) != 'undefined') {
                return path.substr(0, position); // Remove extension.
            }
        }
        return path;
    };
    CoreMimetypeUtilsProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_common_http__["b" /* HttpClient */], __WEBPACK_IMPORTED_MODULE_2__logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_4__text__["a" /* CoreTextUtilsProvider */]])
    ], CoreMimetypeUtilsProvider);
    return CoreMimetypeUtilsProvider;
}());

//# sourceMappingURL=mimetype.js.map

/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreContentLinksHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_events__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_init__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_text__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_url__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__core_login_providers_helper__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__delegate__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__core_constants__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__configconstants__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__core_siteplugins_providers_siteplugins__ = __webpack_require__(49);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};















/**
 * Service that provides some features regarding content links.
 */
var CoreContentLinksHelperProvider = /** @class */ (function () {
    function CoreContentLinksHelperProvider(logger, sitesProvider, loginHelper, contentLinksDelegate, appProvider, domUtils, urlUtils, translate, initDelegate, eventsProvider, textUtils, sitePluginsProvider) {
        this.sitesProvider = sitesProvider;
        this.loginHelper = loginHelper;
        this.contentLinksDelegate = contentLinksDelegate;
        this.appProvider = appProvider;
        this.domUtils = domUtils;
        this.urlUtils = urlUtils;
        this.translate = translate;
        this.initDelegate = initDelegate;
        this.textUtils = textUtils;
        this.sitePluginsProvider = sitePluginsProvider;
        this.logger = logger.getInstance('CoreContentLinksHelperProvider');
        // Listen for app launched URLs. If we receive one, check if it's a content link.
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_3__providers_events__["a" /* CoreEventsProvider */].APP_LAUNCHED_URL, this.handleCustomUrl.bind(this));
    }
    /**
     * Get the first valid action in a list of actions.
     *
     * @param {CoreContentLinksAction[]} actions List of actions.
     * @return {CoreContentLinksAction} First valid action. Returns undefined if no valid action found.
     */
    CoreContentLinksHelperProvider.prototype.getFirstValidAction = function (actions) {
        if (actions) {
            for (var i = 0; i < actions.length; i++) {
                var action = actions[i];
                if (action && action.sites && action.sites.length) {
                    return action;
                }
            }
        }
    };
    /**
     * Goes to a certain page in a certain site. If the site is current site it will perform a regular navigation,
     * otherwise it will 'redirect' to the other site.
     *
     * @param {NavController} navCtrl The NavController instance to use.
     * @param {string} pageName Name of the page to go.
     * @param {any} [pageParams] Params to send to the page.
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    CoreContentLinksHelperProvider.prototype.goInSite = function (navCtrl, pageName, pageParams, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (navCtrl && siteId == this.sitesProvider.getCurrentSiteId()) {
            navCtrl.push(pageName, pageParams);
        }
        else {
            this.loginHelper.redirect(pageName, pageParams, siteId);
        }
    };
    /**
     * Go to the page to choose a site.
     *
     * @param {string} url URL to treat.
     */
    CoreContentLinksHelperProvider.prototype.goToChooseSite = function (url) {
        this.appProvider.getRootNavController().setRoot('CoreContentLinksChooseSitePage', { url: url });
    };
    /**
     * Handle a URL received by Custom URL Scheme.
     *
     * @param {string} url URL to handle.
     * @return {boolean} True if the URL should be handled by this component, false otherwise.
     */
    CoreContentLinksHelperProvider.prototype.handleCustomUrl = function (url) {
        var _this = this;
        var contentLinksScheme = __WEBPACK_IMPORTED_MODULE_13__configconstants__["a" /* CoreConfigConstants */].customurlscheme + '://link';
        if (url.indexOf(contentLinksScheme) == -1) {
            return false;
        }
        var modal = this.domUtils.showModalLoading();
        var username;
        url = this.textUtils.decodeURIComponent(url);
        // App opened using custom URL scheme.
        this.logger.debug('Treating custom URL scheme: ' + url);
        // Delete the scheme from the URL.
        url = url.replace(contentLinksScheme + '=', '');
        // Detect if there's a user specified.
        username = this.urlUtils.getUsernameFromUrl(url);
        if (username) {
            url = url.replace(username + '@', ''); // Remove the username from the URL.
        }
        // Wait for the app to be ready.
        this.initDelegate.ready().then(function () {
            // Check if the site is stored.
            return _this.sitesProvider.getSiteIdsFromUrl(url, false, username);
        }).then(function (siteIds) {
            if (siteIds.length) {
                modal.dismiss(); // Dismiss modal so it doesn't collide with confirms.
                return _this.handleLink(url, username).then(function (treated) {
                    if (!treated) {
                        _this.domUtils.showErrorModal('core.contentlinks.errornoactions', true);
                    }
                });
            }
            else {
                // Get the site URL.
                var siteUrl = _this.contentLinksDelegate.getSiteUrl(url);
                if (!siteUrl) {
                    _this.domUtils.showErrorModal('core.login.invalidsite', true);
                    return;
                }
                // Check that site exists.
                return _this.sitesProvider.checkSite(siteUrl).then(function (result) {
                    // Site exists. We'll allow to add it.
                    var ssoNeeded = _this.loginHelper.isSSOLoginNeeded(result.code), pageName = 'CoreLoginCredentialsPage', pageParams = {
                        siteUrl: result.siteUrl,
                        username: username,
                        urlToOpen: url,
                        siteConfig: result.config
                    };
                    var promise, hasSitePluginsLoaded = false;
                    modal.dismiss(); // Dismiss modal so it doesn't collide with confirms.
                    if (!_this.sitesProvider.isLoggedIn()) {
                        // Not logged in, no need to confirm. If SSO the confirm will be shown later.
                        promise = Promise.resolve();
                    }
                    else {
                        // Ask the user before changing site.
                        var confirmMsg = _this.translate.instant('core.contentlinks.confirmurlothersite');
                        promise = _this.domUtils.showConfirm(confirmMsg).then(function () {
                            if (!ssoNeeded) {
                                hasSitePluginsLoaded = _this.sitePluginsProvider.hasSitePluginsLoaded;
                                if (hasSitePluginsLoaded) {
                                    // Store the redirect since logout will restart the app.
                                    _this.appProvider.storeRedirect(__WEBPACK_IMPORTED_MODULE_12__core_constants__["a" /* CoreConstants */].NO_SITE_ID, pageName, pageParams);
                                }
                                return _this.sitesProvider.logout().catch(function () {
                                    // Ignore errors (shouldn't happen).
                                });
                            }
                        });
                    }
                    return promise.then(function () {
                        if (ssoNeeded) {
                            _this.loginHelper.confirmAndOpenBrowserForSSOLogin(result.siteUrl, result.code, result.service, result.config && result.config.launchurl);
                        }
                        else if (!hasSitePluginsLoaded) {
                            _this.appProvider.getRootNavController().setRoot(pageName, pageParams);
                        }
                    });
                }).catch(function (error) {
                    if (error) {
                        _this.domUtils.showErrorModal(error);
                    }
                });
            }
        }).finally(function () {
            modal.dismiss();
        });
        return true;
    };
    /**
     * Handle a link.
     *
     * @param {string} url URL to handle.
     * @param {string} [username] Username related with the URL. E.g. in 'http://myuser@m.com', url would be 'http://m.com' and
     *                            the username 'myuser'. Don't use it if you don't want to filter by username.
     * @param {NavController} [navCtrl] Nav Controller to use to navigate.
     * @return {Promise<boolean>} Promise resolved with a boolean: true if URL was treated, false otherwise.
     */
    CoreContentLinksHelperProvider.prototype.handleLink = function (url, username, navCtrl) {
        var _this = this;
        // Check if the link should be treated by some component/addon.
        return this.contentLinksDelegate.getActionsFor(url, undefined, username).then(function (actions) {
            var action = _this.getFirstValidAction(actions);
            if (action) {
                if (!_this.sitesProvider.isLoggedIn()) {
                    // No current site. Perform the action if only 1 site found, choose the site otherwise.
                    if (action.sites.length == 1) {
                        action.action(action.sites[0], navCtrl);
                    }
                    else {
                        _this.goToChooseSite(url);
                    }
                }
                else if (action.sites.length == 1 && action.sites[0] == _this.sitesProvider.getCurrentSiteId()) {
                    // Current site.
                    action.action(action.sites[0], navCtrl);
                }
                else {
                    // Not current site or more than one site. Ask for confirmation.
                    _this.domUtils.showConfirm(_this.translate.instant('core.contentlinks.confirmurlothersite')).then(function () {
                        if (action.sites.length == 1) {
                            action.action(action.sites[0], navCtrl);
                        }
                        else {
                            _this.goToChooseSite(url);
                        }
                    });
                }
                return true;
            }
            return false;
        }).catch(function () {
            return false;
        });
    };
    CoreContentLinksHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_10__core_login_providers_helper__["a" /* CoreLoginHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_11__delegate__["a" /* CoreContentLinksDelegate */], __WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_7__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_9__providers_utils_url__["a" /* CoreUrlUtilsProvider */], __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_4__providers_init__["a" /* CoreInitDelegate */], __WEBPACK_IMPORTED_MODULE_3__providers_events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_8__providers_utils_text__["a" /* CoreTextUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_14__core_siteplugins_providers_siteplugins__["a" /* CoreSitePluginsProvider */]])
    ], CoreContentLinksHelperProvider);
    return CoreContentLinksHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreContentLinksDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_url__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__ = __webpack_require__(9);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Delegate to register handlers to handle links.
 */
var CoreContentLinksDelegate = /** @class */ (function () {
    function CoreContentLinksDelegate(logger, sitesProvider, urlUtils, utils) {
        this.sitesProvider = sitesProvider;
        this.urlUtils = urlUtils;
        this.utils = utils;
        this.handlers = {}; // All registered handlers.
        this.logger = logger.getInstance('CoreContentLinksDelegate');
    }
    /**
     * Get the list of possible actions to do for a URL.
     *
     * @param {string} url URL to handle.
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @param {string} [username] Username to use to filter sites.
     * @return {Promise<CoreContentLinksAction[]>}  Promise resolved with the actions.
     */
    CoreContentLinksDelegate.prototype.getActionsFor = function (url, courseId, username) {
        var _this = this;
        if (!url) {
            return Promise.resolve([]);
        }
        // Get the list of sites the URL belongs to.
        return this.sitesProvider.getSiteIdsFromUrl(url, true, username).then(function (siteIds) {
            var linkActions = [], promises = [], params = _this.urlUtils.extractUrlParams(url);
            var _loop_1 = function (name_1) {
                var handler = _this.handlers[name_1], checkAll = handler.checkAllUsers, isEnabledFn = _this.isHandlerEnabled.bind(_this, handler, url, params, courseId);
                if (!handler.handles(url)) {
                    return "continue";
                }
                // Filter the site IDs using the isEnabled function.
                promises.push(_this.utils.filterEnabledSites(siteIds, isEnabledFn, checkAll).then(function (siteIds) {
                    if (!siteIds.length) {
                        // No sites supported, no actions.
                        return;
                    }
                    return Promise.resolve(handler.getActions(siteIds, url, params, courseId)).then(function (actions) {
                        if (actions && actions.length) {
                            // Set default values if any value isn't supplied.
                            actions.forEach(function (action) {
                                action.message = action.message || 'core.view';
                                action.icon = action.icon || 'eye';
                                action.sites = action.sites || siteIds;
                            });
                            // Add them to the list.
                            linkActions.push({
                                priority: handler.priority,
                                actions: actions
                            });
                        }
                    });
                }));
            };
            for (var name_1 in _this.handlers) {
                _loop_1(name_1);
            }
            return _this.utils.allPromises(promises).catch(function () {
                // Ignore errors.
            }).then(function () {
                // Sort link actions by priority.
                return _this.sortActionsByPriority(linkActions);
            });
        });
    };
    /**
     * Get the site URL if the URL is supported by any handler.
     *
     * @param {string} url URL to handle.
     * @return {string} Site URL if the URL is supported by any handler, undefined otherwise.
     */
    CoreContentLinksDelegate.prototype.getSiteUrl = function (url) {
        if (!url) {
            return;
        }
        // Check if any handler supports this URL.
        for (var name_2 in this.handlers) {
            var handler = this.handlers[name_2], siteUrl = handler.getSiteUrl(url);
            if (siteUrl) {
                return siteUrl;
            }
        }
    };
    /**
     * Check if a handler is enabled for a certain site and URL.
     *
     * @param {CoreContentLinksHandler} handler Handler to check.
     * @param {string} url The URL to check.
     * @param {any} params The params of the URL
     * @param {number} courseId Course ID the URL belongs to (can be undefined).
     * @param {string} siteId The site ID to check.
     * @return {Promise<boolean>} Promise resolved with boolean: whether the handler is enabled.
     */
    CoreContentLinksDelegate.prototype.isHandlerEnabled = function (handler, url, params, courseId, siteId) {
        var promise;
        if (handler.featureName) {
            // Check if the feature is disabled.
            promise = this.sitesProvider.isFeatureDisabled(handler.featureName, siteId);
        }
        else {
            promise = Promise.resolve(false);
        }
        return promise.then(function (disabled) {
            if (disabled) {
                return false;
            }
            if (!handler.isEnabled) {
                // Handler doesn't implement isEnabled, assume it's enabled.
                return true;
            }
            return handler.isEnabled(siteId, url, params, courseId);
        });
    };
    /**
     * Register a handler.
     *
     * @param {CoreContentLinksHandler} handler The handler to register.
     * @return {boolean} True if registered successfully, false otherwise.
     */
    CoreContentLinksDelegate.prototype.registerHandler = function (handler) {
        if (typeof this.handlers[handler.name] !== 'undefined') {
            this.logger.log("Addon '" + handler.name + "' already registered");
            return false;
        }
        this.logger.log("Registered addon '" + handler.name + "'");
        this.handlers[handler.name] = handler;
        return true;
    };
    /**
     * Sort actions by priority.
     *
     * @param {CoreContentLinksHandlerActions[]} actions Actions to sort.
     * @return {CoreContentLinksAction[]} Sorted actions.
     */
    CoreContentLinksDelegate.prototype.sortActionsByPriority = function (actions) {
        var sorted = [];
        // Sort by priority.
        actions = actions.sort(function (a, b) {
            return a.priority <= b.priority ? 1 : -1;
        });
        // Fill result array.
        actions.forEach(function (entry) {
            sorted = sorted.concat(entry.actions);
        });
        return sorted;
    };
    CoreContentLinksDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_url__["a" /* CoreUrlUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], CoreContentLinksDelegate);
    return CoreContentLinksDelegate;
}());

//# sourceMappingURL=delegate.js.map

/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreUserDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__classes_delegate__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_courses_providers_courses__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_events__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_rxjs__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_rxjs__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};







/**
 * Service to interact with plugins to be shown in user profile. Provides functions to register a plugin
 * and notify an update in the data.
 */
var CoreUserDelegate = /** @class */ (function (_super) {
    __extends(CoreUserDelegate, _super);
    function CoreUserDelegate(loggerProvider, sitesProvider, coursesProvider, eventsProvider) {
        var _this = _super.call(this, 'CoreUserDelegate', loggerProvider, sitesProvider, eventsProvider) || this;
        _this.loggerProvider = loggerProvider;
        _this.sitesProvider = sitesProvider;
        _this.coursesProvider = coursesProvider;
        _this.eventsProvider = eventsProvider;
        _this.handlers = {};
        _this.enabledHandlers = {};
        _this.observableHandlers = new __WEBPACK_IMPORTED_MODULE_6_rxjs__["BehaviorSubject"]([]);
        _this.userHandlers = [];
        _this.featurePrefix = '$mmUserDelegate_';
        _this.loaded = false;
        eventsProvider.on(CoreUserDelegate_1.UPDATE_HANDLER_EVENT, function (data) {
            if (data && data.handler) {
                var handler = _this.userHandlers.find(function (userHandler) {
                    return userHandler.name == data.handler;
                });
                if (handler) {
                    for (var x in data.data) {
                        handler.data[x] = data.data[x];
                    }
                    _this.observableHandlers.next(_this.userHandlers);
                }
            }
        });
        return _this;
    }
    CoreUserDelegate_1 = CoreUserDelegate;
    /**
     * Check if handlers are loaded.
     *
     * @return {boolean} True if handlers are loaded, false otherwise.
     */
    CoreUserDelegate.prototype.areHandlersLoaded = function () {
        return this.loaded;
    };
    /**
     * Clear current user handlers.
     */
    CoreUserDelegate.prototype.clearUserHandlers = function () {
        this.loaded = false;
        this.userHandlers = [];
        this.observableHandlers.next(this.userHandlers);
    };
    /**
     * Get the profile handlers for a user.
     *
     * @param {any} user The user object.
     * @param {number} courseId The course ID.
     * @return {Subject<CoreUserProfileHandlerToDisplay[]>} Resolved with the handlers.
     */
    CoreUserDelegate.prototype.getProfileHandlersFor = function (user, courseId) {
        var _this = this;
        var promises = [];
        this.userHandlers = [];
        // Retrieve course options forcing cache.
        this.coursesProvider.getUserCourses(true).then(function (courses) {
            var courseIds = courses.map(function (course) {
                return course.id;
            });
            return _this.coursesProvider.getCoursesAdminAndNavOptions(courseIds).then(function (options) {
                // For backwards compatibility we don't modify the courseId.
                var courseIdForOptions = courseId || _this.sitesProvider.getCurrentSiteHomeId(), navOptions = options.navOptions[courseIdForOptions], admOptions = options.admOptions[courseIdForOptions];
                var _loop_1 = function (name_1) {
                    // Checks if the handler is enabled for the user.
                    var handler = _this.handlers[name_1], isEnabledForUser = handler.isEnabledForUser(user, courseId, navOptions, admOptions), promise = Promise.resolve(isEnabledForUser).then(function (enabled) {
                        if (enabled) {
                            _this.userHandlers.push({
                                name: name_1,
                                data: handler.getDisplayData(user, courseId),
                                priority: handler.priority,
                                type: handler.type || CoreUserDelegate_1.TYPE_NEW_PAGE
                            });
                        }
                        else {
                            return Promise.reject(null);
                        }
                    }).catch(function () {
                        // Nothing to do here, it is not enabled for this user.
                    });
                    promises.push(promise);
                };
                for (var name_1 in _this.enabledHandlers) {
                    _loop_1(name_1);
                }
                return Promise.all(promises).then(function () {
                    // Sort them by priority.
                    _this.userHandlers.sort(function (a, b) {
                        return b.priority - a.priority;
                    });
                    _this.loaded = true;
                    _this.observableHandlers.next(_this.userHandlers);
                });
            });
        }).catch(function () {
            // Never fails.
            _this.loaded = true;
            _this.observableHandlers.next(_this.userHandlers);
        });
        return this.observableHandlers;
    };
    /**
     * User profile handler type for communication.
     * @type {string}
     */
    CoreUserDelegate.TYPE_COMMUNICATION = 'communication';
    /**
     * User profile handler type for new page.
     * @type {string}
     */
    CoreUserDelegate.TYPE_NEW_PAGE = 'newpage';
    /**
     * User profile handler type for actions.
     * @type {string}
     */
    CoreUserDelegate.TYPE_ACTION = 'action';
    /**
     * Update handler information event.
     * @type {string}
     */
    CoreUserDelegate.UPDATE_HANDLER_EVENT = 'CoreUserDelegate_update_handler_event';
    CoreUserDelegate = CoreUserDelegate_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_2__core_courses_providers_courses__["a" /* CoreCoursesProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_events__["a" /* CoreEventsProvider */]])
    ], CoreUserDelegate);
    return CoreUserDelegate;
    var CoreUserDelegate_1;
}(__WEBPACK_IMPORTED_MODULE_1__classes_delegate__["a" /* CoreDelegate */]));

//# sourceMappingURL=user-delegate.js.map

/***/ }),
/* 48 */,
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSitePluginsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_filepool__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_lang__ = __webpack_require__(96);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__configconstants__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__core_courses_providers_courses__ = __webpack_require__(31);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};










/**
 * Service to provide functionalities regarding site plugins.
 */
var CoreSitePluginsProvider = /** @class */ (function () {
    function CoreSitePluginsProvider(logger, sitesProvider, utils, langProvider, appProvider, platform, filepoolProvider, coursesProvider) {
        this.sitesProvider = sitesProvider;
        this.utils = utils;
        this.langProvider = langProvider;
        this.appProvider = appProvider;
        this.platform = platform;
        this.filepoolProvider = filepoolProvider;
        this.coursesProvider = coursesProvider;
        this.ROOT_CACHE_KEY = 'CoreSitePlugins:';
        this.sitePlugins = {}; // Site plugins registered.
        this.hasSitePluginsLoaded = false;
        this.logger = logger.getInstance('CoreUserProvider');
    }
    /**
     * Add some params that will always be sent for get content.
     *
     * @param {any} args Original params.
     * @param {CoreSite} [site] Site. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the new params.
     */
    CoreSitePluginsProvider.prototype.addDefaultArgs = function (args, site) {
        var _this = this;
        args = args || {};
        site = site || this.sitesProvider.getCurrentSite();
        return this.langProvider.getCurrentLanguage().then(function (lang) {
            // Clone the object so the original one isn't modified.
            var argsToSend = _this.utils.clone(args);
            argsToSend.userid = args.userid || site.getUserId();
            argsToSend.appid = __WEBPACK_IMPORTED_MODULE_8__configconstants__["a" /* CoreConfigConstants */].app_id;
            argsToSend.appversioncode = __WEBPACK_IMPORTED_MODULE_8__configconstants__["a" /* CoreConfigConstants */].versioncode;
            argsToSend.appversionname = __WEBPACK_IMPORTED_MODULE_8__configconstants__["a" /* CoreConfigConstants */].versionname;
            argsToSend.applang = lang;
            argsToSend.appcustomurlscheme = __WEBPACK_IMPORTED_MODULE_8__configconstants__["a" /* CoreConfigConstants */].customurlscheme;
            argsToSend.appisdesktop = _this.appProvider.isDesktop();
            argsToSend.appismobile = _this.appProvider.isMobile();
            argsToSend.appiswide = _this.appProvider.isWide();
            if (argsToSend.appisdevice) {
                if (_this.platform.is('ios')) {
                    argsToSend.appplatform = 'ios';
                }
                else {
                    argsToSend.appplatform = 'android';
                }
            }
            else if (argsToSend.appisdesktop) {
                if (_this.appProvider.isMac()) {
                    argsToSend.appplatform = 'mac';
                }
                else if (_this.appProvider.isLinux()) {
                    argsToSend.appplatform = 'linux';
                }
                else {
                    argsToSend.appplatform = 'windows';
                }
            }
            else {
                argsToSend.appplatform = 'browser';
            }
            return argsToSend;
        });
    };
    /**
     * Call a WS for a site plugin.
     *
     * @param {string} method WS method to use.
     * @param {any} data Data to send to the WS.
     * @param {CoreSiteWSPreSets} [preSets] Extra options.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the response.
     */
    CoreSitePluginsProvider.prototype.callWS = function (method, data, preSets, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            preSets = preSets || {};
            preSets.cacheKey = preSets.cacheKey || _this.getCallWSCacheKey(method, data);
            return site.read(method, data, preSets);
        });
    };
    /**
     * Given the result of a bootstrap get_content and, optionally, the result of another get_content,
     * build an object with the data to pass to the JS of the get_content.
     *
     * @param {any} bootstrapResult Result of the bootstrap WS call.
     * @param {any} [contentResult] Result of the content WS call (if any).
     * @return {any} An object with the data to pass to the JS.
     */
    CoreSitePluginsProvider.prototype.createDataForJS = function (bootstrapResult, contentResult) {
        // First of all, add the data returned by the bootstrap JS (if any).
        var data = this.utils.clone(bootstrapResult.jsResult || {});
        if (typeof data == 'boolean') {
            data = {};
        }
        // Now add some data returned by the bootstrap WS call.
        data.BOOTSTRAP_TEMPLATES = this.utils.objectToKeyValueMap(bootstrapResult.templates, 'id', 'html');
        data.BOOTSTRAP_OTHERDATA = bootstrapResult.otherdata;
        if (contentResult) {
            // Now add the data returned by the content WS call.
            data.CONTENT_TEMPLATES = this.utils.objectToKeyValueMap(contentResult.templates, 'id', 'html');
            data.CONTENT_OTHERDATA = contentResult.otherdata;
        }
        return data;
    };
    /**
     * Get cache key for a WS call.
     *
     * @param {string} method Name of the method.
     * @param {any} data Data to identify the WS call.
     * @return {string} Cache key.
     */
    CoreSitePluginsProvider.prototype.getCallWSCacheKey = function (method, data) {
        return this.getCallWSCommonCacheKey(method) + ':' + this.utils.sortAndStringify(data);
    };
    /**
     * Get common cache key for a WS call.
     *
     * @param {string} method Name of the method.
     * @return {string} Cache key.
     */
    CoreSitePluginsProvider.prototype.getCallWSCommonCacheKey = function (method) {
        return this.ROOT_CACHE_KEY + 'ws:' + method;
    };
    /**
     * Get a certain content for a site plugin.
     *
     * @param {string} component Component where the class is. E.g. mod_assign.
     * @param {string} method Method to execute in the class.
     * @param {any} args The params for the method.
     * @param {CoreSiteWSPreSets} [preSets] Extra options.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved with the result.
     */
    CoreSitePluginsProvider.prototype.getContent = function (component, method, args, preSets, siteId) {
        var _this = this;
        this.logger.debug("Get content for component '" + component + "' and method '" + method + "'");
        return this.sitesProvider.getSite(siteId).then(function (site) {
            // Add some params that will always be sent.
            return _this.addDefaultArgs(args, site).then(function (argsToSend) {
                // Now call the WS.
                var data = {
                    component: component,
                    method: method,
                    args: _this.utils.objectToArrayOfObjects(argsToSend, 'name', 'value', true)
                };
                preSets = preSets || {};
                preSets.cacheKey = _this.getContentCacheKey(component, method, args);
                return _this.sitesProvider.getCurrentSite().read('tool_mobile_get_content', data, preSets);
            }).then(function (result) {
                if (result.otherdata) {
                    result.otherdata = _this.utils.objectToKeyValueMap(result.otherdata, 'name', 'value');
                }
                else {
                    result.otherdata = {};
                }
                return result;
            });
        });
    };
    /**
     * Get cache key for get content WS calls.
     *
     * @param {string} component Component where the class is. E.g. mod_assign.
     * @param {string} method Method to execute in the class.
     * @param {any} args The params for the method.
     * @return {string} Cache key.
     */
    CoreSitePluginsProvider.prototype.getContentCacheKey = function (component, method, args) {
        return this.ROOT_CACHE_KEY + 'content:' + component + ':' + method + ':' + this.utils.sortAndStringify(args);
    };
    /**
     * Get the value of a WS param for prefetch.
     *
     * @param {string} component The component of the handler.
     * @param {string} paramName Name of the param as defined by the handler.
     * @param {number} [courseId] Course ID (if prefetching a course).
     * @param {any} [module] The module object returned by WS (if prefetching a module).
     * @return {any} The value.
     */
    CoreSitePluginsProvider.prototype.getDownloadParam = function (component, paramName, courseId, module) {
        switch (paramName) {
            case 'courseids':
                // The WS needs the list of course IDs. Create the list.
                return [courseId];
            case component + 'id':
                // The WS needs the instance id.
                return module && module.instance;
            default:
        }
    };
    /**
     * Get the unique name of a handler (plugin + handler).
     *
     * @param {any} plugin Data of the plugin.
     * @param {string} handlerName Name of the handler inside the plugin.
     * @return {string} Unique name.
     */
    CoreSitePluginsProvider.prototype.getHandlerUniqueName = function (plugin, handlerName) {
        return plugin.addon + '_' + handlerName;
    };
    /**
     * Get a site plugin handler.
     *
     * @param {string} name Unique name of the handler.
     * @return {CoreSitePluginsHandler} Handler.
     */
    CoreSitePluginsProvider.prototype.getSitePluginHandler = function (name) {
        return this.sitePlugins[name];
    };
    /**
     * Invalidate all WS call to a certain method.
     *
     * @param {string} method WS method to use.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreSitePluginsProvider.prototype.invalidateAllCallWSForMethod = function (method, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getCallWSCommonCacheKey(method));
        });
    };
    /**
     * Invalidate a WS call.
     *
     * @param {string} method WS method to use.
     * @param {any} data Data to send to the WS.
     * @param {CoreSiteWSPreSets} [preSets] Extra options.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreSitePluginsProvider.prototype.invalidateCallWS = function (method, data, preSets, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(preSets.cacheKey || _this.getCallWSCacheKey(method, data));
        });
    };
    /**
     * Invalidate a page content.
     *
     * @param {string} component Component where the class is. E.g. mod_assign.
     * @param {string} method Method to execute in the class.
     * @param {any} args The params for the method.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreSitePluginsProvider.prototype.invalidateContent = function (component, callback, args, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getContentCacheKey(component, callback, args));
        });
    };
    /**
     * Check if the get content WS is available.
     *
     * @param {CoreSite} site The site to check. If not defined, current site.
     */
    CoreSitePluginsProvider.prototype.isGetContentAvailable = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.wsAvailable('tool_mobile_get_content');
    };
    /**
     * Check if a handler is enabled for a certain course.
     *
     * @param {number} courseId Course ID to check.
     * @param {boolean} [restrictEnrolled] If true or undefined, handler is only enabled for courses the user is enrolled in.
     * @param {any} [restrict] Users and courses the handler is restricted to.
     * @return {boolean | Promise<boolean>} Whether the handler is enabled.
     */
    CoreSitePluginsProvider.prototype.isHandlerEnabledForCourse = function (courseId, restrictEnrolled, restrict) {
        if (restrict && restrict.courses && restrict.courses.indexOf(courseId) == -1) {
            // Course is not in the list of restricted courses.
            return false;
        }
        if (restrictEnrolled || typeof restrictEnrolled == 'undefined') {
            // Only enabled for courses the user is enrolled to. Check if the user is enrolled in the course.
            return this.coursesProvider.getUserCourse(courseId, true).then(function () {
                return true;
            }).catch(function () {
                return false;
            });
        }
        return true;
    };
    /**
     * Check if a handler is enabled for a certain user.
     *
     * @param {number} userId User ID to check.
     * @param {boolean} [restrictCurrent] Whether handler is only enabled for current user.
     * @param {any} [restrict] Users and courses the handler is restricted to.
     * @return {boolean} Whether the handler is enabled.
     */
    CoreSitePluginsProvider.prototype.isHandlerEnabledForUser = function (userId, restrictCurrent, restrict) {
        if (restrictCurrent && userId != this.sitesProvider.getCurrentSite().getUserId()) {
            // Only enabled for current user.
            return false;
        }
        if (restrict && restrict.users && restrict.users.indexOf(userId) == -1) {
            // User is not in the list of restricted users.
            return false;
        }
        return true;
    };
    /**
     * Load other data into args as determined by useOtherData list.
     * If useOtherData is undefined, it won't add any data.
     * If useOtherData is defined but empty (null, false or empty string) it will copy all the data from otherData to args.
     * If useOtherData is an array, it will only copy the properties whose names are in the array.
     *
     * @param {any} args The current args.
     * @param {any} otherData All the other data.
     * @param {any[]} useOtherData Names of the attributes to include.
     * @return {any} New args.
     */
    CoreSitePluginsProvider.prototype.loadOtherDataInArgs = function (args, otherData, useOtherData) {
        if (!args) {
            args = {};
        }
        else {
            args = this.utils.clone(args);
        }
        otherData = otherData || {};
        if (typeof useOtherData == 'undefined') {
            // No need to add other data, return args as they are.
            return args;
        }
        else if (!useOtherData) {
            // Use other data is defined but empty. Add all the data to args.
            for (var name_1 in otherData) {
                args[name_1] = otherData[name_1];
            }
        }
        else {
            for (var i in useOtherData) {
                var name_2 = useOtherData[i];
                args[name_2] = otherData[name_2];
            }
        }
        return args;
    };
    /**
     * Prefetch offline functions for a site plugin handler.
     *
     * @param {string} component The component of the handler.
     * @param {any} args Params to send to the get_content calls.
     * @param {any} handlerSchema The handler schema.
     * @param {number} [courseId] Course ID (if prefetching a course).
     * @param {any} [module] The module object returned by WS (if prefetching a module).
     * @param {boolean} [prefetch] True to prefetch, false to download right away.
     * @param {string} [dirPath] Path of the directory where to store all the content files.
     * @param {CoreSite} [site] Site. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreSitePluginsProvider.prototype.prefetchFunctions = function (component, args, handlerSchema, courseId, module, prefetch, dirPath, site) {
        var _this = this;
        site = site || this.sitesProvider.getCurrentSite();
        var promises = [];
        for (var method in handlerSchema.offlinefunctions) {
            if (site.wsAvailable(method)) {
                // The method is a WS.
                var paramsList = handlerSchema.offlinefunctions[method], cacheKey = this.getCallWSCacheKey(method, args);
                var params = {};
                if (!paramsList.length) {
                    // No params defined, send the default ones.
                    params = args;
                }
                else {
                    for (var i in paramsList) {
                        var paramName = paramsList[i];
                        if (typeof args[paramName] != 'undefined') {
                            params[paramName] = args[paramName];
                        }
                        else {
                            // The param is not one of the default ones. Try to calculate the param to use.
                            var value = this.getDownloadParam(component, paramName, courseId, module);
                            if (typeof value != 'undefined') {
                                params[paramName] = value;
                            }
                        }
                    }
                }
                promises.push(this.callWS(method, params, { cacheKey: cacheKey }));
            }
            else {
                // It's a method to get content.
                promises.push(this.getContent(component, method, args).then(function (result) {
                    var subPromises = [];
                    // Prefetch the files in the content.
                    if (result.files && result.files.length) {
                        subPromises.push(_this.filepoolProvider.downloadOrPrefetchFiles(site.id, result.files, prefetch, false, component, module.id, dirPath));
                    }
                    return Promise.all(subPromises);
                }));
            }
        }
        return Promise.all(promises);
    };
    /**
     * Store a site plugin handler.
     *
     * @param {string} name A unique name to identify the handler.
     * @param {CoreSitePluginsHandler} handler Handler to set.
     */
    CoreSitePluginsProvider.prototype.setSitePluginHandler = function (name, handler) {
        this.sitePlugins[name] = handler;
    };
    CoreSitePluginsProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_7__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_lang__["a" /* CoreLangProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */],
            __WEBPACK_IMPORTED_MODULE_3__providers_filepool__["a" /* CoreFilepoolProvider */], __WEBPACK_IMPORTED_MODULE_9__core_courses_providers_courses__["a" /* CoreCoursesProvider */]])
    ], CoreSitePluginsProvider);
    return CoreSitePluginsProvider;
}());

//# sourceMappingURL=siteplugins.js.map

/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreConfigConstants; });
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// tslint:disable: variable-name
var CoreConfigConstants = /** @class */ (function () {
    function CoreConfigConstants() {
    }
    CoreConfigConstants.app_id = 'com.moodle.moodlemobile';
    CoreConfigConstants.appname = 'Moodle Mobile';
    CoreConfigConstants.desktopappname = 'Moodle Desktop';
    CoreConfigConstants.versioncode = 3000;
    CoreConfigConstants.versionname = '3.3.5';
    CoreConfigConstants.cache_expiration_time = 300000;
    CoreConfigConstants.default_lang = 'en';
    CoreConfigConstants.languages = {
        'ar': '',
        'bg': '',
        'ca': 'Catal',
        'cs': 'etina',
        'da': 'Dansk',
        'de': 'Deutsch',
        'de-du': 'Deutsch - Du',
        'el': '',
        'en': 'English',
        'es': 'Espaol',
        'es-mx': 'Espaol - Mxico',
        'eu': 'Euskara',
        'fa': '',
        'fr': 'Franais',
        'he': '',
        'hu': 'magyar',
        'it': 'Italiano',
        'lt': 'Lietuvi',
        'ja': '',
        'nl': 'Nederlands',
        'pl': 'Polski',
        'pt-br': 'Portugus - Brasil',
        'pt': 'Portugus - Portugal',
        'ro': 'Romn',
        'ru': '',
        'sr-cr': '',
        'sr-lt': 'Srpski',
        'sv': 'Svenska',
        'tr': 'Trke',
        'uk': '',
        'zh-cn': '',
        'zh-tw': ''
    };
    CoreConfigConstants.wsservice = 'moodle_mobile_app';
    CoreConfigConstants.wsextservice = 'local_mobile';
    CoreConfigConstants.demo_sites = {
        student: {
            url: 'http://school.demo.moodle.net',
            username: 'student',
            password: 'moodle'
        },
        teacher: {
            url: 'http://school.demo.moodle.net',
            username: 'teacher',
            password: 'moodle'
        }
    };
    CoreConfigConstants.gcmpn = '694767596569';
    CoreConfigConstants.customurlscheme = 'moodlemobile';
    CoreConfigConstants.siteurl = '';
    CoreConfigConstants.multisitesdisplay = '';
    CoreConfigConstants.skipssoconfirmation = false;
    CoreConfigConstants.forcedefaultlanguage = false;
    CoreConfigConstants.privacypolicy = 'https://moodle.org/mod/page/view.php?id=8148';
    return CoreConfigConstants;
}());

//# sourceMappingURL=configconstants.js.map

/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreLoginHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_config__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_events__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_init__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_ws__ = __webpack_require__(137);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_utils_text__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_utils_url__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__core_siteplugins_providers_siteplugins__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__configconstants__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__core_constants__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_ts_md5_dist_md5__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_ts_md5_dist_md5___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_17_ts_md5_dist_md5__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


















/**
 * Helper provider that provides some common features regarding authentication.
 */
var CoreLoginHelperProvider = /** @class */ (function () {
    function CoreLoginHelperProvider(logger, sitesProvider, domUtils, wsProvider, translate, textUtils, eventsProvider, appProvider, utils, urlUtils, configProvider, platform, initDelegate, sitePluginsProvider) {
        this.sitesProvider = sitesProvider;
        this.domUtils = domUtils;
        this.wsProvider = wsProvider;
        this.translate = translate;
        this.textUtils = textUtils;
        this.eventsProvider = eventsProvider;
        this.appProvider = appProvider;
        this.utils = utils;
        this.urlUtils = urlUtils;
        this.configProvider = configProvider;
        this.platform = platform;
        this.initDelegate = initDelegate;
        this.sitePluginsProvider = sitePluginsProvider;
        this.isSSOConfirmShown = false;
        this.isOpenEditAlertShown = false;
        this.waitingForBrowser = false;
        this.logger = logger.getInstance('CoreLoginHelper');
    }
    /**
     * Accept site policy.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved if success, rejected if failure.
     */
    CoreLoginHelperProvider.prototype.acceptSitePolicy = function (siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.write('core_user_agree_site_policy', {}).then(function (result) {
                if (!result.status) {
                    // Error.
                    if (result.warnings && result.warnings.length) {
                        // Check if there is a warning 'alreadyagreed'.
                        for (var i in result.warnings) {
                            var warning = result.warnings[i];
                            if (warning.warningcode == 'alreadyagreed') {
                                // Policy already agreed, treat it as a success.
                                return;
                            }
                        }
                        // Another warning, reject.
                        return Promise.reject(result.warnings[0]);
                    }
                    else {
                        return Promise.reject(null);
                    }
                }
            });
        });
    };
    /**
     * Function to handle URL received by Custom URL Scheme. If it's a SSO login, perform authentication.
     *
     * @param {string} url URL received.
     * @return {boolean} True if it's a SSO URL, false otherwise.
     */
    CoreLoginHelperProvider.prototype.appLaunchedByURL = function (url) {
        var _this = this;
        var ssoScheme = __WEBPACK_IMPORTED_MODULE_15__configconstants__["a" /* CoreConfigConstants */].customurlscheme + '://token=';
        if (url.indexOf(ssoScheme) == -1) {
            return false;
        }
        if (this.appProvider.isSSOAuthenticationOngoing()) {
            // Authentication ongoing, probably duplicated request.
            return true;
        }
        if (this.appProvider.isDesktop()) {
            // In desktop, make sure InAppBrowser is closed.
            this.utils.closeInAppBrowser(true);
        }
        // App opened using custom URL scheme. Probably an SSO authentication.
        this.appProvider.startSSOAuthentication();
        this.logger.debug('App launched by URL with an SSO');
        // Delete the sso scheme from the URL.
        url = url.replace(ssoScheme, '');
        // Some platforms like Windows add a slash at the end. Remove it.
        // Some sites add a # at the end of the URL. If it's there, remove it.
        url = url.replace(/\/?#?\/?$/, '');
        // Decode from base64.
        try {
            url = atob(url);
        }
        catch (err) {
            // Error decoding the parameter.
            this.logger.error('Error decoding parameter received for login SSO');
            return false;
        }
        var modal = this.domUtils.showModalLoading('core.login.authenticating', true);
        var siteData;
        // Wait for app to be ready.
        this.initDelegate.ready().then(function () {
            return _this.validateBrowserSSOLogin(url);
        }).then(function (data) {
            siteData = data;
            return _this.handleSSOLoginAuthentication(siteData.siteUrl, siteData.token, siteData.privateToken);
        }).then(function () {
            if (siteData.pageName) {
                // State defined, go to that state instead of site initial page.
                _this.appProvider.getRootNavController().push(siteData.pageName, siteData.pageParams);
            }
            else {
                _this.goToSiteInitialPage();
            }
        }).catch(function (errorMessage) {
            if (typeof errorMessage == 'string' && errorMessage != '') {
                _this.domUtils.showErrorModal(errorMessage);
            }
        }).finally(function () {
            modal.dismiss();
            _this.appProvider.finishSSOAuthentication();
        });
        return true;
    };
    /**
     * Check if a site allows requesting a password reset through the app.
     *
     * @param {string} siteUrl URL of the site.
     * @return {Promise<any>} Promise resolved with boolean: whether can be done through the app.
     */
    CoreLoginHelperProvider.prototype.canRequestPasswordReset = function (siteUrl) {
        return this.requestPasswordReset(siteUrl).then(function () {
            return true;
        }).catch(function (error) {
            return error.available == 1 || error.errorcode != 'invalidrecord';
        });
    };
    /**
     * Function called when an SSO InAppBrowser is closed or the app is resumed. Check if user needs to be logged out.
     */
    CoreLoginHelperProvider.prototype.checkLogout = function () {
        var navCtrl = this.appProvider.getRootNavController();
        if (!this.appProvider.isSSOAuthenticationOngoing() && this.sitesProvider.isLoggedIn() &&
            this.sitesProvider.getCurrentSite().isLoggedOut() && navCtrl.getActive().name == 'CoreLoginReconnectPage') {
            // User must reauthenticate but he closed the InAppBrowser without doing so, logout him.
            this.sitesProvider.logout();
        }
    };
    /**
     * Show a confirm modal if needed and open a browser to perform SSO login.
     *
     * @param  {string} siteurl     URL of the site where the SSO login will be performed.
     * @param  {number} typeOfLogin CoreConstants.LOGIN_SSO_CODE or CoreConstants.LOGIN_SSO_INAPP_CODE.
     * @param  {string} [service]   The service to use. If not defined, external service will be used.
     * @param  {string} [launchUrl] The URL to open for SSO. If not defined, local_mobile launch URL will be used.
     * @return {Void}
     */
    CoreLoginHelperProvider.prototype.confirmAndOpenBrowserForSSOLogin = function (siteUrl, typeOfLogin, service, launchUrl) {
        var _this = this;
        // Show confirm only if it's needed. Treat "false" (string) as false to prevent typing errors.
        var showConfirmation = this.shouldShowSSOConfirm(typeOfLogin);
        var promise;
        if (showConfirmation) {
            promise = this.domUtils.showConfirm(this.translate.instant('core.login.logininsiterequired'));
        }
        else {
            promise = Promise.resolve();
        }
        promise.then(function () {
            _this.openBrowserForSSOLogin(siteUrl, typeOfLogin, service, launchUrl);
        }, function () {
            // User cancelled, ignore.
        });
    };
    /**
     * Format profile fields, filtering the ones that shouldn't be shown on signup and classifying them in categories.
     *
     * @param {any[]} profileFields Profile fields to format.
     * @return {any} Categories with the fields to show in each one.
     */
    CoreLoginHelperProvider.prototype.formatProfileFieldsForSignup = function (profileFields) {
        if (!profileFields) {
            return [];
        }
        var categories = {};
        profileFields.forEach(function (field) {
            if (!field.signup) {
                // Not a signup field, ignore it.
                return;
            }
            if (!categories[field.categoryid]) {
                categories[field.categoryid] = {
                    id: field.categoryid,
                    name: field.categoryname,
                    fields: []
                };
            }
            categories[field.categoryid].fields.push(field);
        });
        return Object.keys(categories).map(function (index) {
            return categories[index];
        });
    };
    /**
     * Builds an object with error messages for some common errors.
     * Please notice that this function doesn't support all possible error types.
     *
     * @param {string} [requiredMsg] Code of the string for required error.
     * @param {string} [emailMsg] Code of the string for invalid email error.
     * @param {string} [patternMsg] Code of the string for pattern not match error.
     * @param {string} [urlMsg] Code of the string for invalid url error.
     * @param {string} [minlengthMsg] Code of the string for "too short" error.
     * @param {string} [maxlengthMsg] Code of the string for "too long" error.
     * @param {string} [minMsg] Code of the string for min value error.
     * @param {string} [maxMsg] Code of the string for max value error.
     * @return {any} Object with the errors.
     */
    CoreLoginHelperProvider.prototype.getErrorMessages = function (requiredMsg, emailMsg, patternMsg, urlMsg, minlengthMsg, maxlengthMsg, minMsg, maxMsg) {
        var errors = {};
        if (requiredMsg) {
            errors.required = errors.requiredTrue = this.translate.instant(requiredMsg);
        }
        if (emailMsg) {
            errors.email = this.translate.instant(emailMsg);
        }
        if (patternMsg) {
            errors.pattern = this.translate.instant(patternMsg);
        }
        if (urlMsg) {
            errors.url = this.translate.instant(urlMsg);
        }
        if (minlengthMsg) {
            errors.minlength = this.translate.instant(minlengthMsg);
        }
        if (maxlengthMsg) {
            errors.maxlength = this.translate.instant(maxlengthMsg);
        }
        if (minMsg) {
            errors.min = this.translate.instant(minMsg);
        }
        if (maxMsg) {
            errors.max = this.translate.instant(maxMsg);
        }
        return errors;
    };
    /**
     * Get the site policy.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<string>} Promise resolved with the site policy.
     */
    CoreLoginHelperProvider.prototype.getSitePolicy = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            // Check if it's stored in the site config.
            var sitePolicy = site.getStoredConfig('sitepolicy');
            if (typeof sitePolicy != 'undefined') {
                return sitePolicy ? sitePolicy : Promise.reject(null);
            }
            // Not in the config, try to get it using auth_email_get_signup_settings.
            return _this.wsProvider.callAjax('auth_email_get_signup_settings', {}, { siteUrl: site.getURL() }).then(function (settings) {
                return settings.sitepolicy ? settings.sitepolicy : Promise.reject(null);
            });
        });
    };
    /**
     * Get fixed site or sites.
     *
     * @return {string|any[]} Fixed site or list of fixed sites.
     */
    CoreLoginHelperProvider.prototype.getFixedSites = function () {
        return __WEBPACK_IMPORTED_MODULE_15__configconstants__["a" /* CoreConfigConstants */].siteurl;
    };
    /**
     * Get the valid identity providers from a site config.
     *
     * @param {any} siteConfig Site's public config.
     * @return {any[]} Valid identity providers.
     */
    CoreLoginHelperProvider.prototype.getValidIdentityProviders = function (siteConfig) {
        var validProviders = [], httpUrl = this.textUtils.concatenatePaths(siteConfig.wwwroot, 'auth/oauth2/'), httpsUrl = this.textUtils.concatenatePaths(siteConfig.httpswwwroot, 'auth/oauth2/');
        if (siteConfig.identityproviders && siteConfig.identityproviders.length) {
            siteConfig.identityproviders.forEach(function (provider) {
                if (provider.url && (provider.url.indexOf(httpsUrl) != -1 || provider.url.indexOf(httpUrl) != -1)) {
                    validProviders.push(provider);
                }
            });
        }
        return validProviders;
    };
    /**
     * Go to the page to add a new site.
     * If a fixed URL is configured, go to credentials instead.
     *
     * @param {boolean} [setRoot] True to set the new page as root, false to add it to the stack.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreLoginHelperProvider.prototype.goToAddSite = function (setRoot) {
        var pageName, params;
        if (this.isFixedUrlSet()) {
            // Fixed URL is set, go to credentials page.
            var url = typeof __WEBPACK_IMPORTED_MODULE_15__configconstants__["a" /* CoreConfigConstants */].siteurl == 'string' ?
                __WEBPACK_IMPORTED_MODULE_15__configconstants__["a" /* CoreConfigConstants */].siteurl : __WEBPACK_IMPORTED_MODULE_15__configconstants__["a" /* CoreConfigConstants */].siteurl[0].url;
            pageName = 'CoreLoginCredentialsPage';
            params = { siteUrl: url };
        }
        else {
            pageName = 'CoreLoginSitePage';
        }
        if (setRoot) {
            return this.appProvider.getRootNavController().setRoot(pageName, params, { animate: false });
        }
        else {
            return this.appProvider.getRootNavController().push(pageName, params);
        }
    };
    /**
     * Go to the initial page of a site depending on 'userhomepage' setting.
     *
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreLoginHelperProvider.prototype.goToSiteInitialPage = function () {
        return this.appProvider.getRootNavController().setRoot('CoreMainMenuPage');
    };
    /**
     * Convenient helper to handle authentication in the app using a token received by SSO login. If it's a new account,
     * the site is stored and the user is authenticated. If the account already exists, update its token.
     *
     * @param {string} siteUrl Site's URL.
     * @param {string} token User's token.
     * @param {string} [privateToken] User's private token.
     * @return {Promise<any>} Promise resolved when the user is authenticated with the token.
     */
    CoreLoginHelperProvider.prototype.handleSSOLoginAuthentication = function (siteUrl, token, privateToken) {
        var _this = this;
        if (this.sitesProvider.isLoggedIn()) {
            // User logged in, he is reconnecting. Retrieve username.
            var info_1 = this.sitesProvider.getCurrentSite().getInfo();
            if (typeof info_1 != 'undefined' && typeof info_1.username != 'undefined') {
                return this.sitesProvider.updateSiteToken(info_1.siteurl, info_1.username, token, privateToken).then(function () {
                    _this.sitesProvider.updateSiteInfoByUrl(info_1.siteurl, info_1.username);
                }).catch(function () {
                    // Error updating token, return proper error message.
                    return Promise.reject(_this.translate.instant('core.login.errorupdatesite'));
                });
            }
            return Promise.reject(this.translate.instant('core.login.errorupdatesite'));
        }
        else {
            return this.sitesProvider.newSite(siteUrl, token, privateToken);
        }
    };
    /**
     * Check if the app is configured to use several fixed URLs.
     *
     * @return {boolean} Whether there are several fixed URLs.
     */
    CoreLoginHelperProvider.prototype.hasSeveralFixedSites = function () {
        return __WEBPACK_IMPORTED_MODULE_15__configconstants__["a" /* CoreConfigConstants */].siteurl && Array.isArray(__WEBPACK_IMPORTED_MODULE_15__configconstants__["a" /* CoreConfigConstants */].siteurl) &&
            __WEBPACK_IMPORTED_MODULE_15__configconstants__["a" /* CoreConfigConstants */].siteurl.length > 1;
    };
    /**
     * Function called when a page starts loading in any InAppBrowser window.
     *
     * @param {string} url Loaded url.
     */
    CoreLoginHelperProvider.prototype.inAppBrowserLoadStart = function (url) {
        // URLs with a custom scheme can be prefixed with "http://" or "https://", we need to remove this.
        url = url.replace(/^https?:\/\//, '');
        if (this.appLaunchedByURL(url)) {
            // Close the browser if it's a valid SSO URL.
            this.utils.closeInAppBrowser(false);
        }
        else if (this.platform.is('android')) {
            // Check if the URL has a custom URL scheme. In Android they need to be opened manually.
            var urlScheme = this.urlUtils.getUrlProtocol(url);
            if (urlScheme && urlScheme !== 'file' && urlScheme !== 'cdvfile') {
                // Open in browser should launch the right app if found and do nothing if not found.
                this.utils.openInBrowser(url);
                // At this point the InAppBrowser is showing a "Webpage not available" error message.
                // Try to navigate to last loaded URL so this error message isn't found.
                if (this.lastInAppUrl) {
                    this.utils.openInApp(this.lastInAppUrl);
                }
                else {
                    // No last URL loaded, close the InAppBrowser.
                    this.utils.closeInAppBrowser(false);
                }
            }
            else {
                this.lastInAppUrl = url;
            }
        }
    };
    /**
     * Given a site public config, check if email signup is disabled.
     *
     * @param {any} config Site public config.
     * @return {boolean} Whether email signup is disabled.
     */
    CoreLoginHelperProvider.prototype.isEmailSignupDisabled = function (config) {
        var disabledFeatures = config && config.tool_mobile_disabledfeatures;
        if (!disabledFeatures) {
            return false;
        }
        var regEx = new RegExp('(,|^)\\$mmLoginEmailSignup(,|$)', 'g');
        return !!disabledFeatures.match(regEx);
    };
    /**
     * Check if the app is configured to use a fixed URL (only 1).
     *
     * @return {boolean} Whether there is 1 fixed URL.
     */
    CoreLoginHelperProvider.prototype.isFixedUrlSet = function () {
        if (Array.isArray(__WEBPACK_IMPORTED_MODULE_15__configconstants__["a" /* CoreConfigConstants */].siteurl)) {
            return __WEBPACK_IMPORTED_MODULE_15__configconstants__["a" /* CoreConfigConstants */].siteurl.length == 1;
        }
        return !!__WEBPACK_IMPORTED_MODULE_15__configconstants__["a" /* CoreConfigConstants */].siteurl;
    };
    /**
     * Check if current site is logged out, triggering mmCoreEventSessionExpired if it is.
     *
     * @param {string} [pageName] Name of the page to go once authenticated if logged out. If not defined, site initial page.
     * @param {any} [params] Params of the page to go once authenticated if logged out.
     * @return {boolean} True if user is logged out, false otherwise.
     */
    CoreLoginHelperProvider.prototype.isSiteLoggedOut = function (pageName, params) {
        var site = this.sitesProvider.getCurrentSite();
        if (!site) {
            return false;
        }
        if (site.isLoggedOut()) {
            this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_5__providers_events__["a" /* CoreEventsProvider */].SESSION_EXPIRED, {
                pageName: pageName,
                params: params
            }, site.getId());
            return true;
        }
        return false;
    };
    /**
     * Check if SSO login should use an embedded browser.
     *
     * @param {number} code Code to check.
     * @return {boolean} True if embedded browser, false othwerise.
     */
    CoreLoginHelperProvider.prototype.isSSOEmbeddedBrowser = function (code) {
        if (this.appProvider.isLinux()) {
            // In Linux desktop apps, always use embedded browser.
            return true;
        }
        return code == __WEBPACK_IMPORTED_MODULE_16__core_constants__["a" /* CoreConstants */].LOGIN_SSO_INAPP_CODE;
    };
    /**
     * Check if SSO login is needed based on code returned by the WS.
     *
     * @param {number} code Code to check.
     * @return {boolean} True if SSO login is needed, false othwerise.
     */
    CoreLoginHelperProvider.prototype.isSSOLoginNeeded = function (code) {
        return code == __WEBPACK_IMPORTED_MODULE_16__core_constants__["a" /* CoreConstants */].LOGIN_SSO_CODE || code == __WEBPACK_IMPORTED_MODULE_16__core_constants__["a" /* CoreConstants */].LOGIN_SSO_INAPP_CODE;
    };
    /**
     * Load a site and load a certain page in that site.
     *
     * @param {string} page Name of the page to load.
     * @param {any} params Params to pass to the page.
     * @param {string} siteId Site to load.
     */
    CoreLoginHelperProvider.prototype.loadSiteAndPage = function (page, params, siteId) {
        var _this = this;
        if (siteId == __WEBPACK_IMPORTED_MODULE_16__core_constants__["a" /* CoreConstants */].NO_SITE_ID) {
            // Page doesn't belong to a site, just load the page.
            this.appProvider.getRootNavController().setRoot(page, params);
        }
        else {
            var modal_1 = this.domUtils.showModalLoading();
            this.sitesProvider.loadSite(siteId).then(function () {
                if (!_this.isSiteLoggedOut(page, params)) {
                    _this.loadPageInMainMenu(page, params);
                }
            }).catch(function () {
                // Site doesn't exist.
                _this.appProvider.getRootNavController().setRoot('CoreLoginSitesPage');
            }).finally(function () {
                modal_1.dismiss();
            });
        }
    };
    /**
     * Load a certain page in the main menu page.
     *
     * @param {string} page Name of the page to load.
     * @param {any} params Params to pass to the page.
     */
    CoreLoginHelperProvider.prototype.loadPageInMainMenu = function (page, params) {
        this.appProvider.getRootNavController().setRoot('CoreMainMenuPage', { redirectPage: page, redirectParams: params });
    };
    /**
     * Open a browser to perform OAuth login (Google, Facebook, Microsoft).
     *
     * @param {string} siteUrl URL of the site where the login will be performed.
     * @param {any} provider The identity provider.
     * @param {string} [launchUrl] The URL to open for SSO. If not defined, tool/mobile launch URL will be used.
     * @param {string} [pageName] Name of the page to go once authenticated. If not defined, site initial page.
     * @param {any} [pageParams] Params of the state to go once authenticated.
     * @return {boolean} True if success, false if error.
     */
    CoreLoginHelperProvider.prototype.openBrowserForOAuthLogin = function (siteUrl, provider, launchUrl, pageName, pageParams) {
        launchUrl = launchUrl || siteUrl + '/admin/tool/mobile/launch.php';
        if (!provider || !provider.url) {
            return false;
        }
        var service = this.sitesProvider.determineService(siteUrl), params = this.urlUtils.extractUrlParams(provider.url);
        var loginUrl = this.prepareForSSOLogin(siteUrl, service, launchUrl, pageName, pageParams);
        if (!params.id) {
            return false;
        }
        loginUrl += '&oauthsso=' + params.id;
        if (this.appProvider.isLinux()) {
            // In Linux desktop apps, always use embedded browser.
            this.utils.openInApp(loginUrl);
        }
        else {
            // Always open it in browser because the user might have the session stored in there.
            this.utils.openInBrowser(loginUrl);
            if (navigator.app) {
                navigator.app.exitApp();
            }
        }
        return true;
    };
    /**
     * Open a browser to perform SSO login.
     *
     * @param {string} siteurl URL of the site where the SSO login will be performed.
     * @param {number} typeOfLogin CoreConstants.LOGIN_SSO_CODE or CoreConstants.LOGIN_SSO_INAPP_CODE.
     * @param {string} [service] The service to use. If not defined, external service will be used.
     * @param {string} [launchUrl] The URL to open for SSO. If not defined, local_mobile launch URL will be used.
     * @param {string} [pageName] Name of the page to go once authenticated. If not defined, site initial page.
     * @param {any} [pageParams] Params of the state to go once authenticated.
     */
    CoreLoginHelperProvider.prototype.openBrowserForSSOLogin = function (siteUrl, typeOfLogin, service, launchUrl, pageName, pageParams) {
        var loginUrl = this.prepareForSSOLogin(siteUrl, service, launchUrl, pageName, pageParams);
        if (this.isSSOEmbeddedBrowser(typeOfLogin)) {
            var options = {
                clearsessioncache: 'yes',
                closebuttoncaption: this.translate.instant('core.login.cancel'),
            };
            this.utils.openInApp(loginUrl, options);
        }
        else {
            this.utils.openInBrowser(loginUrl);
            if (navigator.app) {
                navigator.app.exitApp();
            }
        }
    };
    /**
     * Convenient helper to open change password page.
     *
     * @param {string} siteUrl Site URL to construct change password URL.
     * @param {string} error Error message.
     */
    CoreLoginHelperProvider.prototype.openChangePassword = function (siteUrl, error) {
        var _this = this;
        var alert = this.domUtils.showAlert(this.translate.instant('core.notice'), error, undefined, 3000);
        alert.onDidDismiss(function () {
            _this.utils.openInApp(siteUrl + '/login/change_password.php');
        });
    };
    /**
     * Open forgotten password in inappbrowser.
     *
     * @param {string} siteUrl URL of the site.
     */
    CoreLoginHelperProvider.prototype.openForgottenPassword = function (siteUrl) {
        this.utils.openInApp(siteUrl + '/login/forgot_password.php');
    };
    /*
     * Function to open in app browser to change password or complete user profile.
     *
     * @param {string} siteId The site ID.
     * @param {string} path The relative path of the URL to open.
     * @param {string} alertMessage The key of the message to display before opening the in app browser.
     * @param {boolean} [invalidateCache] Whether to invalidate site's cache (e.g. when the user is forced to change password).
     */
    CoreLoginHelperProvider.prototype.openInAppForEdit = function (siteId, path, alertMessage, invalidateCache) {
        var _this = this;
        if (!siteId || siteId !== this.sitesProvider.getCurrentSiteId()) {
            // Site that triggered the event is not current site, nothing to do.
            return;
        }
        var currentSite = this.sitesProvider.getCurrentSite(), siteUrl = currentSite && currentSite.getURL();
        if (!currentSite || !siteUrl) {
            return;
        }
        if (!this.isOpenEditAlertShown && !this.waitingForBrowser) {
            this.isOpenEditAlertShown = true;
            if (invalidateCache) {
                currentSite.invalidateWsCache();
            }
            // Open change password.
            alertMessage = this.translate.instant(alertMessage) + '<br>' + this.translate.instant('core.redirectingtosite');
            currentSite.openInAppWithAutoLogin(siteUrl + path, undefined, alertMessage).then(function () {
                _this.waitingForBrowser = true;
            }).finally(function () {
                _this.isOpenEditAlertShown = false;
            });
        }
    };
    /**
     * Prepare the app to perform SSO login.
     *
     * @param {string} siteUrl URL of the site where the SSO login will be performed.
     * @param {string} [service] The service to use. If not defined, external service will be used.
     * @param {string} [launchUrl] The URL to open for SSO. If not defined, local_mobile launch URL will be used.
     * @param {string} [pageName] Name of the page to go once authenticated. If not defined, site initial page.
     * @param {any} [pageParams] Params of the state to go once authenticated.
     */
    CoreLoginHelperProvider.prototype.prepareForSSOLogin = function (siteUrl, service, launchUrl, pageName, pageParams) {
        service = service || __WEBPACK_IMPORTED_MODULE_15__configconstants__["a" /* CoreConfigConstants */].wsextservice;
        launchUrl = launchUrl || siteUrl + '/local/mobile/launch.php';
        var passport = Math.random() * 1000;
        var loginUrl = launchUrl + '?service=' + service;
        loginUrl += '&passport=' + passport;
        loginUrl += '&urlscheme=' + __WEBPACK_IMPORTED_MODULE_15__configconstants__["a" /* CoreConfigConstants */].customurlscheme;
        // Store the siteurl and passport in $mmConfig for persistence.
        // We are "configuring" the app to wait for an SSO. $mmConfig shouldn't be used as a temporary storage.
        this.configProvider.set(__WEBPACK_IMPORTED_MODULE_16__core_constants__["a" /* CoreConstants */].LOGIN_LAUNCH_DATA, JSON.stringify({
            siteUrl: siteUrl,
            passport: passport,
            pageName: pageName || '',
            pageParams: pageParams || {}
        }));
        return loginUrl;
    };
    /**
     * Redirect to a new page, setting it as the root page and loading the right site if needed.
     *
     * @param {string} page Name of the page to load.
     * @param {any} params Params to pass to the page.
     * @param {string} [siteId] Site to load. If not defined, current site.
     */
    CoreLoginHelperProvider.prototype.redirect = function (page, params, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (this.sitesProvider.isLoggedIn()) {
            if (siteId && siteId != this.sitesProvider.getCurrentSiteId()) {
                // Target page belongs to a different site. Change site.
                if (this.sitePluginsProvider.hasSitePluginsLoaded) {
                    // The site has site plugins so the app will be restarted. Store the data and logout.
                    this.appProvider.storeRedirect(siteId, page, params);
                    this.sitesProvider.logout();
                }
                else {
                    this.sitesProvider.logout().then(function () {
                        _this.loadSiteAndPage(page, params, siteId);
                    });
                }
            }
            else {
                this.loadPageInMainMenu(page, params);
            }
        }
        else {
            if (siteId) {
                this.loadSiteAndPage(page, params, siteId);
            }
            else {
                this.appProvider.getRootNavController().setRoot('CoreLoginSitesPage');
            }
        }
    };
    /**
     * Request a password reset.
     *
     * @param {string} siteUrl URL of the site.
     * @param {string} [username] Username to search.
     * @param {string} [email] Email to search.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreLoginHelperProvider.prototype.requestPasswordReset = function (siteUrl, username, email) {
        var params = {};
        if (username) {
            params.username = username;
        }
        if (email) {
            params.email = email;
        }
        return this.wsProvider.callAjax('core_auth_request_password_reset', params, { siteUrl: siteUrl });
    };
    /**
     * Function that should be called when the session expires. Reserved for core use.
     *
     * @param {any} data Data received by the SESSION_EXPIRED event.
     */
    CoreLoginHelperProvider.prototype.sessionExpired = function (data) {
        var _this = this;
        var siteId = data && data.siteId, currentSite = this.sitesProvider.getCurrentSite(), siteUrl = currentSite && currentSite.getURL();
        var promise;
        if (!currentSite || !siteUrl) {
            return;
        }
        if (siteId && siteId !== currentSite.getId()) {
            return; // Site that triggered the event is not current site.
        }
        // Check authentication method.
        this.sitesProvider.checkSite(siteUrl).then(function (result) {
            if (result.warning) {
                _this.domUtils.showErrorModal(result.warning, true, 4000);
            }
            if (_this.isSSOLoginNeeded(result.code)) {
                // SSO. User needs to authenticate in a browser. Check if we need to display a message.
                if (!_this.appProvider.isSSOAuthenticationOngoing() && !_this.isSSOConfirmShown && !_this.waitingForBrowser) {
                    _this.isSSOConfirmShown = true;
                    if (_this.shouldShowSSOConfirm(result.code)) {
                        promise = _this.domUtils.showConfirm(_this.translate.instant('core.login.' +
                            (currentSite.isLoggedOut() ? 'loggedoutssodescription' : 'reconnectssodescription')));
                    }
                    else {
                        promise = Promise.resolve();
                    }
                    promise.then(function () {
                        _this.waitingForBrowser = true;
                        _this.openBrowserForSSOLogin(result.siteUrl, result.code, result.service, result.config && result.config.launchurl, data.pageName, data.params);
                    }).catch(function () {
                        // User cancelled, logout him.
                        _this.sitesProvider.logout();
                    }).finally(function () {
                        _this.isSSOConfirmShown = false;
                    });
                }
            }
            else {
                var info = currentSite.getInfo();
                if (typeof info != 'undefined' && typeof info.username != 'undefined') {
                    _this.appProvider.getRootNavController().setRoot('CoreLoginReconnectPage', {
                        infoSiteUrl: info.siteurl,
                        siteUrl: result.siteUrl,
                        siteId: siteId,
                        pageName: data.pageName,
                        pageParams: data.params,
                        siteConfig: result.config
                    });
                }
            }
        }).catch(function (error) {
            // Error checking site.
            if (currentSite.isLoggedOut()) {
                // Site is logged out, show error and logout the user.
                _this.domUtils.showErrorModalDefault(error, 'core.networkerrormsg', true);
                _this.sitesProvider.logout();
            }
        });
    };
    /**
     * Check if a confirm should be shown to open a SSO authentication.
     *
     * @param {number} typeOfLogin CoreConstants.LOGIN_SSO_CODE or CoreConstants.LOGIN_SSO_INAPP_CODE.
     * @return {boolean} True if confirm modal should be shown, false otherwise.
     */
    CoreLoginHelperProvider.prototype.shouldShowSSOConfirm = function (typeOfLogin) {
        return !this.isSSOEmbeddedBrowser(typeOfLogin) &&
            (!__WEBPACK_IMPORTED_MODULE_15__configconstants__["a" /* CoreConfigConstants */].skipssoconfirmation || String(__WEBPACK_IMPORTED_MODULE_15__configconstants__["a" /* CoreConfigConstants */].skipssoconfirmation) === 'false');
    };
    /**
     * Function called when site policy is not agreed. Reserved for core use.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    CoreLoginHelperProvider.prototype.sitePolicyNotAgreed = function (siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (!siteId || siteId != this.sitesProvider.getCurrentSiteId()) {
            // Only current site allowed.
            return;
        }
        if (!this.sitesProvider.wsAvailableInCurrentSite('core_user_agree_site_policy')) {
            // WS not available, stop.
            return;
        }
        this.appProvider.getRootNavController().setRoot('CoreLoginSitePolicyPage', { siteId: siteId });
    };
    /**
     * Convenient helper to handle get User Token error. It redirects to change password page if forcepassword is set.
     *
     * @param {string} siteUrl Site URL to construct change password URL.
     * @param {any} error Error object containing errorcode and error message.
     */
    CoreLoginHelperProvider.prototype.treatUserTokenError = function (siteUrl, error) {
        if (typeof error == 'string') {
            this.domUtils.showErrorModal(error);
        }
        else if (error.errorcode == 'forcepasswordchangenotice') {
            this.openChangePassword(siteUrl, error.error);
        }
        else {
            this.domUtils.showErrorModal(error.error);
        }
    };
    /**
     * Convenient helper to validate a browser SSO login.
     *
     * @param {string} url URL received, to be validated.
     * @return {Promise<CoreLoginSSOData>} Promise resolved on success.
     */
    CoreLoginHelperProvider.prototype.validateBrowserSSOLogin = function (url) {
        var _this = this;
        // Split signature:::token
        var params = url.split(':::');
        return this.configProvider.get(__WEBPACK_IMPORTED_MODULE_16__core_constants__["a" /* CoreConstants */].LOGIN_LAUNCH_DATA).then(function (data) {
            data = _this.textUtils.parseJSON(data, null);
            if (data === null) {
                return Promise.reject(null);
            }
            var passport = data.passport;
            var launchSiteURL = data.siteUrl;
            // Reset temporary values.
            _this.configProvider.delete(__WEBPACK_IMPORTED_MODULE_16__core_constants__["a" /* CoreConstants */].LOGIN_LAUNCH_DATA);
            // Validate the signature.
            // We need to check both http and https.
            var signature = __WEBPACK_IMPORTED_MODULE_17_ts_md5_dist_md5__["Md5"].hashAsciiStr(launchSiteURL + passport);
            if (signature != params[0]) {
                if (launchSiteURL.indexOf('https://') != -1) {
                    launchSiteURL = launchSiteURL.replace('https://', 'http://');
                }
                else {
                    launchSiteURL = launchSiteURL.replace('http://', 'https://');
                }
                signature = __WEBPACK_IMPORTED_MODULE_17_ts_md5_dist_md5__["Md5"].hashAsciiStr(launchSiteURL + passport);
            }
            if (signature == params[0]) {
                _this.logger.debug('Signature validated');
                return {
                    siteUrl: launchSiteURL,
                    token: params[1],
                    privateToken: params[2],
                    pageName: data.pageName,
                    pageParams: data.pageParams
                };
            }
            else {
                _this.logger.debug('Invalid signature in the URL request yours: ' + params[0] + ' mine: '
                    + signature + ' for passport ' + passport);
                return Promise.reject(_this.translate.instant('core.unexpectederror'));
            }
        });
    };
    CoreLoginHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_7__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_8__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_10__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_9__providers_ws__["a" /* CoreWSProvider */], __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_11__providers_utils_text__["a" /* CoreTextUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_5__providers_events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_13__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_12__providers_utils_url__["a" /* CoreUrlUtilsProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_config__["a" /* CoreConfigProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */],
            __WEBPACK_IMPORTED_MODULE_6__providers_init__["a" /* CoreInitDelegate */], __WEBPACK_IMPORTED_MODULE_14__core_siteplugins_providers_siteplugins__["a" /* CoreSitePluginsProvider */]])
    ], CoreLoginHelperProvider);
    return CoreLoginHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreTimeUtilsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_moment__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_constants__ = __webpack_require__(22);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/*
 * "Utils" service with helper functions for date and time.
*/
var CoreTimeUtilsProvider = /** @class */ (function () {
    function CoreTimeUtilsProvider(translate) {
        this.translate = translate;
    }
    /**
     * Returns hours, minutes and seconds in a human readable format
     *
     * @param {number} seconds A number of seconds
     * @return {string} Seconds in a human readable format.
     */
    CoreTimeUtilsProvider.prototype.formatTime = function (seconds) {
        var totalSecs, years, days, hours, mins, secs, remainder;
        totalSecs = Math.abs(seconds);
        years = Math.floor(totalSecs / __WEBPACK_IMPORTED_MODULE_3__core_constants__["a" /* CoreConstants */].SECONDS_YEAR);
        remainder = totalSecs - (years * __WEBPACK_IMPORTED_MODULE_3__core_constants__["a" /* CoreConstants */].SECONDS_YEAR);
        days = Math.floor(remainder / __WEBPACK_IMPORTED_MODULE_3__core_constants__["a" /* CoreConstants */].SECONDS_DAY);
        remainder = totalSecs - (days * __WEBPACK_IMPORTED_MODULE_3__core_constants__["a" /* CoreConstants */].SECONDS_DAY);
        hours = Math.floor(remainder / __WEBPACK_IMPORTED_MODULE_3__core_constants__["a" /* CoreConstants */].SECONDS_HOUR);
        remainder = remainder - (hours * __WEBPACK_IMPORTED_MODULE_3__core_constants__["a" /* CoreConstants */].SECONDS_HOUR);
        mins = Math.floor(remainder / __WEBPACK_IMPORTED_MODULE_3__core_constants__["a" /* CoreConstants */].SECONDS_MINUTE);
        secs = remainder - (mins * __WEBPACK_IMPORTED_MODULE_3__core_constants__["a" /* CoreConstants */].SECONDS_MINUTE);
        var ss = this.translate.instant('core.' + (secs == 1 ? 'sec' : 'secs')), sm = this.translate.instant('core.' + (mins == 1 ? 'min' : 'mins')), sh = this.translate.instant('core.' + (hours == 1 ? 'hour' : 'hours')), sd = this.translate.instant('core.' + (days == 1 ? 'day' : 'days')), sy = this.translate.instant('core.' + (years == 1 ? 'year' : 'years'));
        var oyears = '', odays = '', ohours = '', omins = '', osecs = '';
        if (years) {
            oyears = years + ' ' + sy;
        }
        if (days) {
            odays = days + ' ' + sd;
        }
        if (hours) {
            ohours = hours + ' ' + sh;
        }
        if (mins) {
            omins = mins + ' ' + sm;
        }
        if (secs) {
            osecs = secs + ' ' + ss;
        }
        if (years) {
            return oyears + ' ' + odays;
        }
        if (days) {
            return odays + ' ' + ohours;
        }
        if (hours) {
            return ohours + ' ' + omins;
        }
        if (mins) {
            return omins + ' ' + osecs;
        }
        if (secs) {
            return osecs;
        }
        return this.translate.instant('core.now');
    };
    /**
     * Returns hours, minutes and seconds in a human readable format.
     *
     * @param {number} duration Duration in seconds
     * @param {number} [precision] Number of elements to have in precission. 0 or undefined to full precission.
     * @return {string} Duration in a human readable format.
     */
    CoreTimeUtilsProvider.prototype.formatDuration = function (duration, precision) {
        precision = precision || 5;
        var eventDuration = __WEBPACK_IMPORTED_MODULE_2_moment__["duration"](duration, 'seconds');
        var durationString = '';
        if (precision && eventDuration.years() > 0) {
            durationString += ' ' + __WEBPACK_IMPORTED_MODULE_2_moment__["duration"](eventDuration.years(), 'years').humanize();
            precision--;
        }
        if (precision && eventDuration.months() > 0) {
            durationString += ' ' + __WEBPACK_IMPORTED_MODULE_2_moment__["duration"](eventDuration.months(), 'months').humanize();
            precision--;
        }
        if (precision && eventDuration.days() > 0) {
            durationString += ' ' + __WEBPACK_IMPORTED_MODULE_2_moment__["duration"](eventDuration.days(), 'days').humanize();
            precision--;
        }
        if (precision && eventDuration.hours() > 0) {
            durationString += ' ' + __WEBPACK_IMPORTED_MODULE_2_moment__["duration"](eventDuration.hours(), 'hours').humanize();
            precision--;
        }
        if (precision && eventDuration.minutes() > 0) {
            durationString += ' ' + __WEBPACK_IMPORTED_MODULE_2_moment__["duration"](eventDuration.minutes(), 'minutes').humanize();
            precision--;
        }
        return durationString.trim();
    };
    /**
     * Return the current timestamp in a "readable" format: YYYYMMDDHHmmSS.
     *
     * @return {string} The readable timestamp.
     */
    CoreTimeUtilsProvider.prototype.readableTimestamp = function () {
        return __WEBPACK_IMPORTED_MODULE_2_moment__(Date.now()).format('YYYYMMDDHHmmSS');
    };
    /**
     * Return the current timestamp (UNIX format, seconds).
     *
     * @return {number} The current timestamp in seconds.
     */
    CoreTimeUtilsProvider.prototype.timestamp = function () {
        return Math.round(Date.now() / 1000);
    };
    /**
     * Return the localized ISO format (i.e DDMMYY) from the localized moment format. Useful for translations.
     *
     * @param {any} localizedFormat Format to use.
     * @return {string} Localized ISO format
     */
    CoreTimeUtilsProvider.prototype.getLocalizedDateFormat = function (localizedFormat) {
        return __WEBPACK_IMPORTED_MODULE_2_moment__["localeData"]().longDateFormat(localizedFormat);
    };
    CoreTimeUtilsProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
    ], CoreTimeUtilsProvider);
    return CoreTimeUtilsProvider;
}());

//# sourceMappingURL=time.js.map

/***/ }),
/* 53 */,
/* 54 */,
/* 55 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseModulePrefetchDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_events__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_file__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_filepool__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_time__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__course__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__classes_cache__ = __webpack_require__(593);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__constants__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_ts_md5_dist_md5__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_ts_md5_dist_md5___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_ts_md5_dist_md5__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_rxjs__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12_rxjs__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__classes_delegate__ = __webpack_require__(69);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};














/**
 * Delegate to register module prefetch handlers.
 */
var CoreCourseModulePrefetchDelegate = /** @class */ (function (_super) {
    __extends(CoreCourseModulePrefetchDelegate, _super);
    function CoreCourseModulePrefetchDelegate(loggerProvider, sitesProvider, utils, courseProvider, filepoolProvider, timeUtils, fileProvider, eventsProvider) {
        var _this = _super.call(this, 'CoreCourseModulePrefetchDelegate', loggerProvider, sitesProvider, eventsProvider) || this;
        _this.sitesProvider = sitesProvider;
        _this.utils = utils;
        _this.courseProvider = courseProvider;
        _this.filepoolProvider = filepoolProvider;
        _this.timeUtils = timeUtils;
        _this.fileProvider = fileProvider;
        _this.eventsProvider = eventsProvider;
        // Variables for database.
        _this.CHECK_UPDATES_TIMES_TABLE = 'check_updates_times';
        _this.checkUpdatesTableSchema = {
            name: _this.CHECK_UPDATES_TIMES_TABLE,
            columns: [
                {
                    name: 'courseId',
                    type: 'INTEGER',
                    primaryKey: true
                },
                {
                    name: 'time',
                    type: 'INTEGER',
                    notNull: true
                }
            ]
        };
        _this.ROOT_CACHE_KEY = 'mmCourse:';
        _this.statusCache = new __WEBPACK_IMPORTED_MODULE_9__classes_cache__["a" /* CoreCache */]();
        // Promises for check updates, to prevent performing the same request twice at the same time.
        _this.courseUpdatesPromises = {};
        // Promises and observables for prefetching, to prevent downloading same section twice at the same time and notify progress.
        _this.prefetchData = {};
        _this.sitesProvider.createTableFromSchema(_this.checkUpdatesTableSchema);
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_1__providers_events__["a" /* CoreEventsProvider */].LOGOUT, _this.clearStatusCache.bind(_this));
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_1__providers_events__["a" /* CoreEventsProvider */].PACKAGE_STATUS_CHANGED, function (data) {
            _this.updateStatusCache(data.status, data.component, data.componentId);
        }, _this.sitesProvider.getCurrentSiteId());
        return _this;
    }
    /**
     * Check if current site can check updates using core_course_check_updates.
     *
     * @return {boolean} True if can check updates, false otherwise.
     */
    CoreCourseModulePrefetchDelegate.prototype.canCheckUpdates = function () {
        return this.sitesProvider.wsAvailableInCurrentSite('core_course_check_updates');
    };
    /**
     * Check if a certain module can use core_course_check_updates.
     *
     * @param {any} module Module.
     * @param {number} courseId Course ID the module belongs to.
     * @return {Promise<boolean>} Promise resolved with boolean: whether the module can use check updates WS.
     */
    CoreCourseModulePrefetchDelegate.prototype.canModuleUseCheckUpdates = function (module, courseId) {
        var handler = this.getPrefetchHandlerFor(module);
        if (!handler) {
            // Module not supported, cannot use check updates.
            return Promise.resolve(false);
        }
        if (handler.canUseCheckUpdates) {
            return Promise.resolve(handler.canUseCheckUpdates(module, courseId));
        }
        // By default, modules can use check updates.
        return Promise.resolve(true);
    };
    /**
     * Clear the status cache.
     */
    CoreCourseModulePrefetchDelegate.prototype.clearStatusCache = function () {
        this.statusCache.clear();
    };
    /**
     * Creates the list of modules to check for get course updates.
     *
     * @param {any[]} modules List of modules.
     * @param {number} courseId Course ID the modules belong to.
     * @return {Promise<{toCheck: any[], cannotUse: any[]}>} Promise resolved with the lists.
     */
    CoreCourseModulePrefetchDelegate.prototype.createToCheckList = function (modules, courseId) {
        var _this = this;
        var result = {
            toCheck: [],
            cannotUse: []
        }, promises = [];
        modules.forEach(function (module) {
            promises.push(_this.getModuleStatusAndDownloadTime(module, courseId).then(function (data) {
                if (data.status == __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].DOWNLOADED) {
                    // Module is downloaded and not outdated. Check if it can check updates.
                    return _this.canModuleUseCheckUpdates(module, courseId).then(function (canUse) {
                        if (canUse) {
                            // Can use check updates, add it to the tocheck list.
                            result.toCheck.push({
                                contextlevel: 'module',
                                id: module.id,
                                since: data.downloadTime || 0
                            });
                        }
                        else {
                            // Cannot use check updates, add it to the cannotUse array.
                            result.cannotUse.push(module);
                        }
                    });
                }
            }).catch(function () {
                // Ignore errors.
            }));
        });
        return Promise.all(promises).then(function () {
            // Sort toCheck list.
            result.toCheck.sort(function (a, b) {
                return a.id >= b.id ? 1 : -1;
            });
            return result;
        });
    };
    /**
     * Determines a module status based on current status, restoring downloads if needed.
     *
     * @param {any} module Module.
     * @param {string} status Current status.
     * @param {boolean} [canCheck] True if updates can be checked using core_course_check_updates.
     * @return {string} Module status.
     */
    CoreCourseModulePrefetchDelegate.prototype.determineModuleStatus = function (module, status, canCheck) {
        var handler = this.getPrefetchHandlerFor(module), siteId = this.sitesProvider.getCurrentSiteId();
        if (handler) {
            if (status == __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].DOWNLOADING) {
                // Check if the download is being handled.
                if (!this.filepoolProvider.getPackageDownloadPromise(siteId, handler.component, module.id)) {
                    // Not handled, the app was probably restarted or something weird happened.
                    // Re-start download (files already on queue or already downloaded will be skipped).
                    handler.prefetch(module);
                }
            }
            else if (handler.determineStatus) {
                // The handler implements a determineStatus function. Apply it.
                return handler.determineStatus(module, status, canCheck);
            }
        }
        return status;
    };
    /**
     * Check for updates in a course.
     *
     * @param {any[]} modules List of modules.
     * @param {number} courseId  Course ID the modules belong to.
     * @return {Promise<any>} Promise resolved with the updates. If a module is set to false, it means updates cannot be
     *                        checked for that module in the current site.
     */
    CoreCourseModulePrefetchDelegate.prototype.getCourseUpdates = function (modules, courseId) {
        var _this = this;
        if (!this.canCheckUpdates()) {
            return Promise.reject(null);
        }
        // Check if there's already a getCourseUpdates in progress.
        var id = __WEBPACK_IMPORTED_MODULE_11_ts_md5_dist_md5__["Md5"].hashAsciiStr(courseId + '#' + JSON.stringify(modules)), siteId = this.sitesProvider.getCurrentSiteId();
        if (this.courseUpdatesPromises[siteId] && this.courseUpdatesPromises[siteId][id]) {
            // There's already a get updates ongoing, return the promise.
            return this.courseUpdatesPromises[siteId][id];
        }
        else if (!this.courseUpdatesPromises[siteId]) {
            this.courseUpdatesPromises[siteId] = {};
        }
        this.courseUpdatesPromises[siteId][id] = this.createToCheckList(modules, courseId).then(function (data) {
            var result = {};
            // Mark as false the modules that cannot use check updates WS.
            data.cannotUse.forEach(function (module) {
                result[module.id] = false;
            });
            if (!data.toCheck.length) {
                // Nothing to check, no need to call the WS.
                return result;
            }
            // Get the site, maybe the user changed site.
            return _this.sitesProvider.getSite(siteId).then(function (site) {
                var params = {
                    courseid: courseId,
                    tocheck: data.toCheck
                }, preSets = {
                    cacheKey: _this.getCourseUpdatesCacheKey(courseId),
                    emergencyCache: false,
                    uniqueCacheKey: true
                };
                return site.read('core_course_check_updates', params, preSets).then(function (response) {
                    if (!response || typeof response.instances == 'undefined') {
                        return Promise.reject(null);
                    }
                    // Store the last execution of the check updates call.
                    var entry = {
                        courseId: courseId,
                        time: _this.timeUtils.timestamp()
                    };
                    site.getDb().insertOrUpdateRecord(_this.CHECK_UPDATES_TIMES_TABLE, entry, { courseId: courseId });
                    return _this.treatCheckUpdatesResult(data.toCheck, response, result);
                }).catch(function (error) {
                    // Cannot get updates.
                    // Get cached entries but discard modules with a download time higher than the last execution of check updates.
                    return site.getDb().getRecord(_this.CHECK_UPDATES_TIMES_TABLE, { courseId: courseId }).then(function (entry) {
                        preSets.getCacheUsingCacheKey = true;
                        preSets.omitExpires = true;
                        return site.read('core_course_check_updates', params, preSets).then(function (response) {
                            if (!response || typeof response.instances == 'undefined') {
                                return Promise.reject(error);
                            }
                            return _this.treatCheckUpdatesResult(data.toCheck, response, result, entry.time);
                        });
                    }, function () {
                        // No previous executions, return result as it is.
                        return result;
                    });
                });
            });
        }).finally(function () {
            // Get updates finished, delete the promise.
            delete _this.courseUpdatesPromises[siteId][id];
        });
        return this.courseUpdatesPromises[siteId][id];
    };
    /**
     * Check for updates in a course.
     *
     * @param {number} courseId Course ID the modules belong to.
     * @return {Promise<any>} Promise resolved with the updates.
     */
    CoreCourseModulePrefetchDelegate.prototype.getCourseUpdatesByCourseId = function (courseId) {
        var _this = this;
        if (!this.canCheckUpdates()) {
            return Promise.reject(null);
        }
        // Get course sections and all their modules.
        return this.courseProvider.getSections(courseId, false, true, { omitExpires: true }).then(function (sections) {
            return _this.getCourseUpdates(_this.courseProvider.getSectionsModules(sections), courseId);
        });
    };
    /**
     * Get cache key for course updates WS calls.
     *
     * @param {number} courseId Course ID.
     * @return {string} Cache key.
     */
    CoreCourseModulePrefetchDelegate.prototype.getCourseUpdatesCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'courseUpdates:' + courseId;
    };
    /**
     * Get modules download size. Only treat the modules with status not downloaded or outdated.
     *
     * @param {any[]} modules List of modules.
     * @param {number} courseId Course ID the modules belong to.
     * @return {Promise<{size: number, total: boolean}>} Promise resolved with the size and a boolean indicating if it was able
     *                                                   to calculate the total size.
     */
    CoreCourseModulePrefetchDelegate.prototype.getDownloadSize = function (modules, courseId) {
        var _this = this;
        // Get the status of each module.
        return this.getModulesStatus(modules, courseId).then(function (data) {
            var downloadableModules = data[__WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].NOT_DOWNLOADED].concat(data[__WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].OUTDATED]), promises = [], result = {
                size: 0,
                total: true
            };
            downloadableModules.forEach(function (module) {
                promises.push(_this.getModuleDownloadSize(module, courseId).then(function (size) {
                    result.total = result.total && size.total;
                    result.size += size.size;
                }));
            });
            return Promise.all(promises).then(function () {
                return result;
            });
        });
    };
    /**
     * Get the download size of a module.
     *
     * @param {any} module Module to get size.
     * @param {Number} courseId Course ID the module belongs to.
     * @param {boolean} [single] True if we're downloading a single module, false if we're downloading a whole section.
     * @return {Promise<{size: number, total: boolean}>} Promise resolved with the size and a boolean indicating if it was able
     *                                                   to calculate the total size.
     */
    CoreCourseModulePrefetchDelegate.prototype.getModuleDownloadSize = function (module, courseId, single) {
        var _this = this;
        var handler = this.getPrefetchHandlerFor(module);
        var downloadSize, packageId;
        // Check if the module has a prefetch handler.
        if (handler) {
            return this.isModuleDownloadable(module, courseId).then(function (downloadable) {
                if (!downloadable) {
                    return { size: 0, total: true };
                }
                packageId = _this.filepoolProvider.getPackageId(handler.component, module.id);
                downloadSize = _this.statusCache.getValue(packageId, 'downloadSize');
                if (typeof downloadSize != 'undefined') {
                    return downloadSize;
                }
                return Promise.resolve(handler.getDownloadSize(module, courseId, single)).then(function (size) {
                    return _this.statusCache.setValue(packageId, 'downloadSize', size);
                }).catch(function (error) {
                    var cachedSize = _this.statusCache.getValue(packageId, 'downloadSize', true);
                    if (cachedSize) {
                        return cachedSize;
                    }
                    return Promise.reject(error);
                });
            });
        }
        return Promise.resolve({ size: 0, total: false });
    };
    /**
     * Get the download size of a module.
     *
     * @param {any} module Module to get size.
     * @param {number} courseId Course ID the module belongs to.
     * @return {Promise<number>} Promise resolved with the size.
     */
    CoreCourseModulePrefetchDelegate.prototype.getModuleDownloadedSize = function (module, courseId) {
        var _this = this;
        var handler = this.getPrefetchHandlerFor(module);
        var downloadedSize, packageId, promise;
        // Check if the module has a prefetch handler.
        if (handler) {
            return this.isModuleDownloadable(module, courseId).then(function (downloadable) {
                if (!downloadable) {
                    return 0;
                }
                packageId = _this.filepoolProvider.getPackageId(handler.component, module.id);
                downloadedSize = _this.statusCache.getValue(packageId, 'downloadedSize');
                if (typeof downloadedSize != 'undefined') {
                    return downloadedSize;
                }
                if (handler.getDownloadedSize) {
                    // Handler implements a method to calculate the downloaded size, use it.
                    promise = Promise.resolve(handler.getDownloadedSize(module, courseId));
                }
                else {
                    // Handler doesn't implement it, get the module files and check if they're downloaded.
                    promise = _this.getModuleFiles(module, courseId).then(function (files) {
                        var siteId = _this.sitesProvider.getCurrentSiteId(), promises = [];
                        var size = 0;
                        // Retrieve file size if it's downloaded.
                        files.forEach(function (file) {
                            var fileUrl = file.url || file.fileurl;
                            promises.push(_this.filepoolProvider.getFilePathByUrl(siteId, fileUrl).then(function (path) {
                                return _this.fileProvider.getFileSize(path).catch(function () {
                                    // Error getting size. Check if the file is being downloaded.
                                    return _this.filepoolProvider.isFileDownloadingByUrl(siteId, fileUrl).then(function () {
                                        // If downloading, count as downloaded.
                                        return file.filesize;
                                    }).catch(function () {
                                        // Not downloading and not found in disk.
                                        return 0;
                                    });
                                }).then(function (fs) {
                                    size += fs;
                                });
                            }));
                        });
                        return Promise.all(promises).then(function () {
                            return size;
                        });
                    });
                }
                return promise.then(function (size) {
                    return _this.statusCache.setValue(packageId, 'downloadedSize', size);
                }).catch(function () {
                    return _this.statusCache.getValue(packageId, 'downloadedSize', true);
                });
            });
        }
        return Promise.resolve(0);
    };
    /**
     * Get module files.
     *
     * @param {any} module Module to get the files.
     * @param {number} courseId Course ID the module belongs to.
     * @return {Promise<any[]>} Promise resolved with the list of files.
     */
    CoreCourseModulePrefetchDelegate.prototype.getModuleFiles = function (module, courseId) {
        var handler = this.getPrefetchHandlerFor(module);
        if (handler.getFiles) {
            // The handler defines a function to get files, use it.
            return Promise.resolve(handler.getFiles(module, courseId));
        }
        else if (handler.loadContents) {
            // The handler defines a function to load contents, use it before returning module contents.
            return handler.loadContents(module, courseId).then(function () {
                return module.contents;
            });
        }
        else {
            return Promise.resolve(module.contents || []);
        }
    };
    /**
     * Get the module status.
     *
     * @param {any} module Module.
     * @param {number} courseId Course ID the module belongs to.
     * @param {any} [updates] Result of getCourseUpdates for all modules in the course. If not provided, it will be
     *                        calculated (slower). If it's false it means the site doesn't support check updates.
     * @param {boolean} [refresh] True if it should ignore the cache.
     * @param {number} [sectionId] ID of the section the module belongs to.
     * @return {Promise<string>} Promise resolved with the status.
     */
    CoreCourseModulePrefetchDelegate.prototype.getModuleStatus = function (module, courseId, updates, refresh, sectionId) {
        var _this = this;
        var handler = this.getPrefetchHandlerFor(module), siteId = this.sitesProvider.getCurrentSiteId(), canCheck = this.canCheckUpdates();
        if (handler) {
            // Check if the status is cached.
            var component_1 = handler.component, packageId_1 = this.filepoolProvider.getPackageId(component_1, module.id);
            var status_1 = this.statusCache.getValue(packageId_1, 'status'), updateStatus_1 = true, promise_1;
            if (!refresh && typeof status_1 != 'undefined') {
                this.storeCourseAndSection(packageId_1, courseId, sectionId);
                return Promise.resolve(this.determineModuleStatus(module, status_1, canCheck));
            }
            // Check if the module is downloadable.
            return this.isModuleDownloadable(module, courseId).then(function (downloadable) {
                if (!downloadable) {
                    return __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].NOT_DOWNLOADABLE;
                }
                // Get the saved package status.
                return _this.filepoolProvider.getPackageStatus(siteId, component_1, module.id).then(function (currentStatus) {
                    status_1 = handler.determineStatus ? handler.determineStatus(module, currentStatus, canCheck) : currentStatus;
                    if (status_1 != __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].DOWNLOADED) {
                        return status_1;
                    }
                    // Module is downloaded. Determine if there are updated in the module to show them outdated.
                    if (typeof updates == 'undefined') {
                        // We don't have course updates, calculate them.
                        promise_1 = _this.getCourseUpdatesByCourseId(courseId);
                    }
                    else if (updates === false) {
                        // Cannot check updates.
                        return Promise.resolve();
                    }
                    else {
                        promise_1 = Promise.resolve(updates);
                    }
                    return promise_1.then(function (updates) {
                        if (!updates || updates[module.id] === false) {
                            // Cannot check updates, always show outdated.
                            return __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].OUTDATED;
                        }
                        // Check if the module has any update.
                        return _this.moduleHasUpdates(module, courseId, updates).then(function (hasUpdates) {
                            if (!hasUpdates) {
                                // No updates, keep current status.
                                return status_1;
                            }
                            // Has updates, mark the module as outdated.
                            status_1 = __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].OUTDATED;
                            return _this.filepoolProvider.storePackageStatus(siteId, status_1, component_1, module.id).catch(function () {
                                // Ignore errors.
                            }).then(function () {
                                return status_1;
                            });
                        }).catch(function () {
                            // Error checking if module has updates.
                            var status = _this.statusCache.getValue(packageId_1, 'status', true);
                            return _this.determineModuleStatus(module, status, canCheck);
                        });
                    }, function () {
                        // Error getting updates, show the stored status.
                        updateStatus_1 = false;
                        _this.storeCourseAndSection(packageId_1, courseId, sectionId);
                        return currentStatus;
                    });
                });
            }).then(function (status) {
                if (updateStatus_1) {
                    _this.updateStatusCache(status, component_1, module.id, courseId, sectionId);
                }
                return _this.determineModuleStatus(module, status, canCheck);
            });
        }
        // No handler found, module not downloadable.
        return Promise.resolve(__WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].NOT_DOWNLOADABLE);
    };
    /**
     * Get the status of a list of modules, along with the lists of modules for each status.
     * @see {@link CoreFilepoolProvider.determinePackagesStatus}
     *
     * @param {any[]} modules List of modules to prefetch.
     * @param {number} courseId Course ID the modules belong to.
     * @param {number} [sectionId] ID of the section the modules belong to.
     * @param {boolean} [refresh] True if it should always check the DB (slower).
     * @return {Promise<any>} Promise resolved with an object with the following properties:
     *                                - status (string) Status of the module.
     *                                - total (number) Number of modules.
     *                                - CoreConstants.NOT_DOWNLOADED (any[]) Modules with state NOT_DOWNLOADED.
     *                                - CoreConstants.DOWNLOADED (any[]) Modules with state DOWNLOADED.
     *                                - CoreConstants.DOWNLOADING (any[]) Modules with state DOWNLOADING.
     *                                - CoreConstants.OUTDATED (any[]) Modules with state OUTDATED.
     */
    CoreCourseModulePrefetchDelegate.prototype.getModulesStatus = function (modules, courseId, sectionId, refresh) {
        var _this = this;
        var promises = [], result = {
            total: 0
        };
        var status = __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].NOT_DOWNLOADABLE;
        // Init result.
        result[__WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].NOT_DOWNLOADED] = [];
        result[__WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].DOWNLOADED] = [];
        result[__WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].DOWNLOADING] = [];
        result[__WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].OUTDATED] = [];
        // Check updates in course. Don't use getCourseUpdates because the list of modules might not be the whole course list.
        return this.getCourseUpdatesByCourseId(courseId).catch(function () {
            // Cannot get updates.
            return false;
        }).then(function (updates) {
            modules.forEach(function (module) {
                // Check if the module has a prefetch handler.
                var handler = _this.getPrefetchHandlerFor(module);
                if (handler) {
                    var packageId_2 = _this.filepoolProvider.getPackageId(handler.component, module.id);
                    promises.push(_this.getModuleStatus(module, courseId, updates, refresh).then(function (modStatus) {
                        if (modStatus != __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].NOT_DOWNLOADABLE) {
                            status = _this.filepoolProvider.determinePackagesStatus(status, modStatus);
                            result[modStatus].push(module);
                            result.total++;
                        }
                    }).catch(function (error) {
                        var cacheStatus = _this.statusCache.getValue(packageId_2, 'status', true);
                        if (typeof cacheStatus == 'undefined') {
                            return Promise.reject(error);
                        }
                        if (cacheStatus != __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].NOT_DOWNLOADABLE) {
                            cacheStatus = _this.filepoolProvider.determinePackagesStatus(status, cacheStatus);
                            result[cacheStatus].push(module);
                            result.total++;
                        }
                    }));
                }
            });
            return Promise.all(promises).then(function () {
                result.status = status;
                return result;
            });
        });
    };
    /**
     * Get a module status and download time. It will only return the download time if the module is downloaded and not outdated.
     *
     * @param {any} module Module.
     * @param {number} courseId Course ID the module belongs to.
     * @return {Promise<{status: string, downloadTime?: number}>} Promise resolved with the data.
     */
    CoreCourseModulePrefetchDelegate.prototype.getModuleStatusAndDownloadTime = function (module, courseId) {
        var _this = this;
        var handler = this.getPrefetchHandlerFor(module), siteId = this.sitesProvider.getCurrentSiteId();
        if (handler) {
            // Get the status from the cache.
            var packageId = this.filepoolProvider.getPackageId(handler.component, module.id), status_2 = this.statusCache.getValue(packageId, 'status');
            if (typeof status_2 != 'undefined' && status_2 != __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].DOWNLOADED) {
                // Status is different than downloaded, just return the status.
                return Promise.resolve({
                    status: status_2
                });
            }
            // Check if the module is downloadable.
            return this.isModuleDownloadable(module, courseId).then(function (downloadable) {
                if (!downloadable) {
                    return {
                        status: __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].NOT_DOWNLOADABLE
                    };
                }
                // Get the stored data to get the status and downloadTime.
                return _this.filepoolProvider.getPackageData(siteId, handler.component, module.id).then(function (data) {
                    return {
                        status: data.status,
                        downloadTime: data.downloadTime || 0
                    };
                });
            });
        }
        // No handler found, module not downloadable.
        return Promise.resolve({
            status: __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].NOT_DOWNLOADABLE
        });
    };
    /**
     * Get a prefetch handler.
     *
     * @param {any} module The module to work on.
     * @return {CoreCourseModulePrefetchHandler} Prefetch handler.
     */
    CoreCourseModulePrefetchDelegate.prototype.getPrefetchHandlerFor = function (module) {
        return this.getHandler(module.modname, true);
    };
    /**
     * Invalidate check updates WS call.
     *
     * @param {number} courseId Course ID.
     * @return {Promise<any>} Promise resolved when data is invalidated.
     */
    CoreCourseModulePrefetchDelegate.prototype.invalidateCourseUpdates = function (courseId) {
        return this.sitesProvider.getCurrentSite().invalidateWsCacheForKey(this.getCourseUpdatesCacheKey(courseId));
    };
    /**
     * Invalidate a list of modules in a course. This should only invalidate WS calls, not downloaded files.
     *
     * @param {any[]} modules List of modules.
     * @param {number} courseId Course ID.
     * @return {Promise<any>} Promise resolved when modules are invalidated.
     */
    CoreCourseModulePrefetchDelegate.prototype.invalidateModules = function (modules, courseId) {
        var _this = this;
        var promises = [];
        modules.forEach(function (module) {
            var handler = _this.getPrefetchHandlerFor(module);
            if (handler) {
                if (handler.invalidateModule) {
                    promises.push(handler.invalidateModule(module, courseId).catch(function () {
                        // Ignore errors.
                    }));
                }
                // Invalidate cache.
                _this.invalidateModuleStatusCache(module);
            }
        });
        promises.push(this.invalidateCourseUpdates(courseId));
        return Promise.all(promises);
    };
    /**
     * Invalidates the cache for a given module.
     *
     * @param {any} module Module to be invalidated.
     */
    CoreCourseModulePrefetchDelegate.prototype.invalidateModuleStatusCache = function (module) {
        var handler = this.getPrefetchHandlerFor(module);
        if (handler) {
            this.statusCache.invalidate(this.filepoolProvider.getPackageId(handler.component, module.id));
        }
    };
    /**
     * Check if a list of modules is being downloaded.
     *
     * @param {string} id An ID to identify the download.
     * @return {boolean} True if it's being downloaded, false otherwise.
     */
    CoreCourseModulePrefetchDelegate.prototype.isBeingDownloaded = function (id) {
        var siteId = this.sitesProvider.getCurrentSiteId();
        return !!(this.prefetchData[siteId] && this.prefetchData[siteId][id]);
    };
    /**
     * Check if a module is downloadable.
     *
     * @param {any} module Module.
     * @param {Number} courseId Course ID the module belongs to.
     * @return {Promise<boolean>} Promise resolved with true if downloadable, false otherwise.
     */
    CoreCourseModulePrefetchDelegate.prototype.isModuleDownloadable = function (module, courseId) {
        var _this = this;
        var handler = this.getPrefetchHandlerFor(module);
        if (handler) {
            if (typeof handler.isDownloadable == 'function') {
                var packageId_3 = this.filepoolProvider.getPackageId(handler.component, module.id), downloadable = this.statusCache.getValue(packageId_3, 'downloadable');
                if (typeof downloadable != 'undefined') {
                    return Promise.resolve(downloadable);
                }
                else {
                    return Promise.resolve(handler.isDownloadable(module, courseId)).then(function (downloadable) {
                        return _this.statusCache.setValue(packageId_3, 'downloadable', downloadable);
                    }).catch(function () {
                        // Something went wrong, assume it's not downloadable.
                        return false;
                    });
                }
            }
            else {
                // Function not defined, assume it's not downloadable.
                return Promise.resolve(true);
            }
        }
        else {
            // No handler for module, so it's not downloadable.
            return Promise.resolve(false);
        }
    };
    /**
     * Check if a module has updates based on the result of getCourseUpdates.
     *
     * @param {any} module Module.
     * @param {number} courseId Course ID the module belongs to.
     * @param {any} updates Result of getCourseUpdates.
     * @return {Promise<boolean>} Promise resolved with boolean: whether the module has updates.
     */
    CoreCourseModulePrefetchDelegate.prototype.moduleHasUpdates = function (module, courseId, updates) {
        var handler = this.getPrefetchHandlerFor(module), moduleUpdates = updates[module.id];
        if (handler && handler.hasUpdates) {
            // Handler implements its own function to check the updates, use it.
            return Promise.resolve(handler.hasUpdates(module, courseId, moduleUpdates));
        }
        else if (!moduleUpdates || !moduleUpdates.updates || !moduleUpdates.updates.length) {
            // Module doesn't have any update.
            return Promise.resolve(false);
        }
        else if (handler && handler.updatesNames && handler.updatesNames.test) {
            // Check the update names defined by the handler.
            for (var i = 0, len = moduleUpdates.updates.length; i < len; i++) {
                if (handler.updatesNames.test(moduleUpdates.updates[i].name)) {
                    return Promise.resolve(true);
                }
            }
            return Promise.resolve(false);
        }
        // Handler doesn't define hasUpdates or updatesNames and there is at least 1 update. Assume it has updates.
        return Promise.resolve(true);
    };
    /**
     * Prefetch a module.
     *
     * @param {any} module Module to prefetch.
     * @param {number} courseId Course ID the module belongs to.
     * @param {boolean} [single] True if we're downloading a single module, false if we're downloading a whole section.
     * @return {Promise<any>} Promise resolved when finished.
     */
    CoreCourseModulePrefetchDelegate.prototype.prefetchModule = function (module, courseId, single) {
        var handler = this.getPrefetchHandlerFor(module);
        // Check if the module has a prefetch handler.
        if (handler) {
            return handler.prefetch(module, courseId, single);
        }
        return Promise.resolve();
    };
    /**
     * Prefetches a list of modules using their prefetch handlers.
     * If a prefetch already exists for this site and id, returns the current promise.
     *
     * @param {string} id An ID to identify the download. It can be used to retrieve the download promise.
     * @param {any[]} modules List of modules to prefetch.
     * @param {number} courseId Course ID the modules belong to.
     * @param {CoreCourseModulesProgressFunction} [onProgress] Function to call everytime a module is downloaded.
     * @return {Promise<any>} Promise resolved when all modules have been prefetched.
     */
    CoreCourseModulePrefetchDelegate.prototype.prefetchModules = function (id, modules, courseId, onProgress) {
        var _this = this;
        var siteId = this.sitesProvider.getCurrentSiteId(), currentData = this.prefetchData[siteId] && this.prefetchData[siteId][id];
        if (currentData) {
            // There's a prefetch ongoing, return the current promise.
            if (onProgress) {
                currentData.subscriptions.push(currentData.observable.subscribe(onProgress));
            }
            return currentData.promise;
        }
        var count = 0;
        var promises = [], total = modules.length, moduleIds = modules.map(function (module) {
            return module.id;
        }), prefetchData = {
            observable: new __WEBPACK_IMPORTED_MODULE_12_rxjs__["BehaviorSubject"]({ count: count, total: total }),
            promise: undefined,
            subscriptions: []
        };
        if (onProgress) {
            prefetchData.observable.subscribe(onProgress);
        }
        modules.forEach(function (module) {
            // Check if the module has a prefetch handler.
            var handler = _this.getPrefetchHandlerFor(module);
            if (handler) {
                promises.push(_this.isModuleDownloadable(module, courseId).then(function (downloadable) {
                    if (!downloadable) {
                        return;
                    }
                    return handler.prefetch(module, courseId).then(function () {
                        var index = moduleIds.indexOf(id);
                        if (index > -1) {
                            // It's one of the modules we were expecting to download.
                            moduleIds.splice(index, 1);
                            count++;
                            prefetchData.observable.next({ count: count, total: total });
                        }
                    });
                }));
            }
        });
        // Set the promise.
        prefetchData.promise = Promise.all(promises).finally(function () {
            // Unsubscribe all observers.
            prefetchData.subscriptions.forEach(function (subscription) {
                subscription.unsubscribe();
            });
            delete _this.prefetchData[siteId][id];
        });
        // Store the prefetch data in the list.
        if (!this.prefetchData[siteId]) {
            this.prefetchData[siteId] = {};
        }
        this.prefetchData[siteId][id] = prefetchData;
        return prefetchData.promise;
    };
    /**
     * Remove module Files from handler.
     *
     * @param {any} module Module to remove the files.
     * @param {number} courseId Course ID the module belongs to.
     * @return {Promise<void>} Promise resolved when done.
     */
    CoreCourseModulePrefetchDelegate.prototype.removeModuleFiles = function (module, courseId) {
        var _this = this;
        var handler = this.getPrefetchHandlerFor(module), siteId = this.sitesProvider.getCurrentSiteId();
        var promise;
        if (handler && handler.removeFiles) {
            // Handler implements a method to remove the files, use it.
            promise = handler.removeFiles(module, courseId);
        }
        else {
            // No method to remove files, use get files to try to remove the files.
            promise = this.getModuleFiles(module, courseId).then(function (files) {
                var promises = [];
                files.forEach(function (file) {
                    promises.push(_this.filepoolProvider.removeFileByUrl(siteId, file.url || file.fileurl).catch(function () {
                        // Ignore errors.
                    }));
                });
                return Promise.all(promises);
            });
        }
        return promise.then(function () {
            if (handler) {
                // Update status of the module.
                var packageId = _this.filepoolProvider.getPackageId(handler.component, module.id);
                _this.statusCache.setValue(packageId, 'downloadedSize', 0);
                return _this.filepoolProvider.storePackageStatus(siteId, __WEBPACK_IMPORTED_MODULE_10__constants__["a" /* CoreConstants */].NOT_DOWNLOADED, handler.component, module.id);
            }
        });
    };
    /**
     * Set an on progress function for the download of a list of modules.
     *
     * @param {string} id An ID to identify the download.
     * @param {CoreCourseModulesProgressFunction} onProgress Function to call everytime a module is downloaded.
     */
    CoreCourseModulePrefetchDelegate.prototype.setOnProgress = function (id, onProgress) {
        var siteId = this.sitesProvider.getCurrentSiteId(), currentData = this.prefetchData[siteId] && this.prefetchData[siteId][id];
        if (currentData) {
            // There's a prefetch ongoing, return the current promise.
            currentData.subscriptions.push(currentData.observable.subscribe(onProgress));
        }
    };
    /**
     * If courseId or sectionId is set, save them in the cache.
     *
     * @param {string} packageId The package ID.
     * @param {number} [courseId] Course ID.
     * @param {number} [sectionId] Section ID.
     */
    CoreCourseModulePrefetchDelegate.prototype.storeCourseAndSection = function (packageId, courseId, sectionId) {
        if (courseId) {
            this.statusCache.setValue(packageId, 'courseId', courseId);
        }
        if (sectionId && sectionId > 0) {
            this.statusCache.setValue(packageId, 'sectionId', sectionId);
        }
    };
    /**
     * Treat the result of the check updates WS call.
     *
     * @param {any[]} toCheckList List of modules to check (from createToCheckList).
     * @param {any} response WS call response.
     * @param {any} result Object where to store the result.
     * @param {number} [previousTime] Time of the previous check updates execution. If set, modules downloaded
     *                                after this time will be ignored.
     * @return {any} Result.
     */
    CoreCourseModulePrefetchDelegate.prototype.treatCheckUpdatesResult = function (toCheckList, response, result, previousTime) {
        // Format the response to index it by module ID.
        this.utils.arrayToObject(response.instances, 'id', result);
        // Treat warnings, adding the not supported modules.
        response.warnings.forEach(function (warning) {
            if (warning.warningcode == 'missingcallback') {
                result[warning.itemid] = false;
            }
        });
        if (previousTime) {
            // Remove from the list the modules downloaded after previousTime.
            toCheckList.forEach(function (entry) {
                if (result[entry.id] && entry.since > previousTime) {
                    delete result[entry.id];
                }
            });
        }
        return result;
    };
    /**
     * Update the status of a module in the "cache".
     *
     * @param {string} status New status.
     * @param {string} component Package's component.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {number} [courseId] Course ID of the module.
     * @param {number} [sectionId] Section ID of the module.
     */
    CoreCourseModulePrefetchDelegate.prototype.updateStatusCache = function (status, component, componentId, courseId, sectionId) {
        var packageId = this.filepoolProvider.getPackageId(component, componentId), cachedStatus = this.statusCache.getValue(packageId, 'status', true);
        var notify;
        // If the status has changed, notify that the section has changed.
        notify = typeof cachedStatus != 'undefined' && cachedStatus !== status;
        // If courseId/sectionId is set, store it.
        this.storeCourseAndSection(packageId, courseId, sectionId);
        if (notify) {
            if (!courseId) {
                courseId = this.statusCache.getValue(packageId, 'courseId', true);
            }
            if (!sectionId) {
                sectionId = this.statusCache.getValue(packageId, 'sectionId', true);
            }
            // Invalidate and set again.
            this.statusCache.invalidate(packageId);
            this.statusCache.setValue(packageId, 'status', status);
            if (sectionId) {
                this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_1__providers_events__["a" /* CoreEventsProvider */].SECTION_STATUS_CHANGED, {
                    sectionId: sectionId,
                    courseId: courseId
                }, this.sitesProvider.getCurrentSiteId());
            }
        }
        else {
            this.statusCache.setValue(packageId, 'status', status);
        }
    };
    CoreCourseModulePrefetchDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_7__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_8__course__["a" /* CoreCourseProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_filepool__["a" /* CoreFilepoolProvider */],
            __WEBPACK_IMPORTED_MODULE_6__providers_utils_time__["a" /* CoreTimeUtilsProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_file__["a" /* CoreFileProvider */],
            __WEBPACK_IMPORTED_MODULE_1__providers_events__["a" /* CoreEventsProvider */]])
    ], CoreCourseModulePrefetchDelegate);
    return CoreCourseModulePrefetchDelegate;
}(__WEBPACK_IMPORTED_MODULE_13__classes_delegate__["a" /* CoreDelegate */]));

//# sourceMappingURL=module-prefetch-delegate.js.map

/***/ }),
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */,
/* 60 */,
/* 61 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseModuleDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_events__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__course__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__classes_delegate__ = __webpack_require__(69);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






/**
 * Delegate to register module handlers.
 */
var CoreCourseModuleDelegate = /** @class */ (function (_super) {
    __extends(CoreCourseModuleDelegate, _super);
    function CoreCourseModuleDelegate(loggerProvider, sitesProvider, eventsProvider, courseProvider) {
        var _this = _super.call(this, 'CoreCourseModuleDelegate', loggerProvider, sitesProvider, eventsProvider) || this;
        _this.sitesProvider = sitesProvider;
        _this.courseProvider = courseProvider;
        _this.handlers = {}; // All registered handlers.
        _this.enabledHandlers = {}; // Handlers enabled for the current site.
        _this.featurePrefix = '$mmCourseDelegate_';
        return _this;
    }
    /**
     * Get the component to render the module.
     *
     * @param {Injector} injector Injector.
     * @param {any} course The course object.
     * @param {any} module The module object.
     * @return {Promise<any>} Promise resolved with component to use, undefined if not found.
     */
    CoreCourseModuleDelegate.prototype.getMainComponent = function (injector, course, module) {
        var _this = this;
        var handler = this.enabledHandlers[module.modname];
        if (handler && handler.getMainComponent) {
            return Promise.resolve(handler.getMainComponent(injector, course, module)).catch(function (err) {
                _this.logger.error('Error getting main component', err);
            });
        }
    };
    /**
     * Get the data required to display the module in the course contents view.
     *
     * @param {string} modname The name of the module type.
     * @param {any} module The module object.
     * @param {number} courseId The course ID.
     * @param {number} sectionId The section ID.
     * @return {CoreCourseModuleHandlerData} Data to render the module.
     */
    CoreCourseModuleDelegate.prototype.getModuleDataFor = function (modname, module, courseId, sectionId) {
        var _this = this;
        if (typeof this.enabledHandlers[modname] != 'undefined') {
            return this.enabledHandlers[modname].getData(module, courseId, sectionId);
        }
        // Return the default data.
        var defaultData = {
            icon: this.courseProvider.getModuleIconSrc(module.modname),
            title: module.name,
            class: 'core-course-default-handler core-course-module-' + module.modname + '-handler',
            action: function (event, navCtrl, module, courseId, options) {
                event.preventDefault();
                event.stopPropagation();
                navCtrl.push('CoreCourseUnsupportedModulePage', { module: module }, options);
            }
        };
        if (module.url) {
            defaultData.buttons = [{
                    icon: 'open',
                    label: 'core.openinbrowser',
                    action: function (e) {
                        e.preventDefault();
                        e.stopPropagation();
                        _this.sitesProvider.getCurrentSite().openInBrowserWithAutoLoginIfSameSite(module.url);
                    }
                }];
        }
        return defaultData;
    };
    /**
     * Check if a certain module type is disabled in a site.
     *
     * @param {string} modname The name of the module type.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with boolean: whether module is disabled.
     */
    CoreCourseModuleDelegate.prototype.isModuleDisabled = function (modname, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.isModuleDisabledInSite(modname, site);
        });
    };
    /**
     * Check if a certain module type is disabled in a site.
     *
     * @param {string} modname The name of the module type.
     * @param {CoreSite} [site] Site. If not defined, use current site.
     * @return {boolean} Whether module is disabled.
     */
    CoreCourseModuleDelegate.prototype.isModuleDisabledInSite = function (modname, site) {
        if (typeof this.handlers[modname] != 'undefined') {
            site = site || this.sitesProvider.getCurrentSite();
            return this.isFeatureDisabled(this.handlers[modname], site);
        }
        return false;
    };
    CoreCourseModuleDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_1__providers_events__["a" /* CoreEventsProvider */],
            __WEBPACK_IMPORTED_MODULE_4__course__["a" /* CoreCourseProvider */]])
    ], CoreCourseModuleDelegate);
    return CoreCourseModuleDelegate;
}(__WEBPACK_IMPORTED_MODULE_5__classes_delegate__["a" /* CoreDelegate */]));

//# sourceMappingURL=module-delegate.js.map

/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreUserProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__ = __webpack_require__(9);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Service to provide user functionalities.
 */
var CoreUserProvider = /** @class */ (function () {
    function CoreUserProvider(logger, sitesProvider, utils) {
        this.sitesProvider = sitesProvider;
        this.utils = utils;
        this.ROOT_CACHE_KEY = 'mmUser:';
        // Variables for database.
        this.USERS_TABLE = 'users';
        this.tablesSchema = [
            {
                name: this.USERS_TABLE,
                columns: [
                    {
                        name: 'id',
                        type: 'INTEGER',
                        primaryKey: true
                    },
                    {
                        name: 'fullname',
                        type: 'TEXT'
                    },
                    {
                        name: 'profileimageurl',
                        type: 'TEXT'
                    }
                ]
            }
        ];
        this.logger = logger.getInstance('CoreUserProvider');
        this.sitesProvider.createTablesFromSchema(this.tablesSchema);
    }
    CoreUserProvider_1 = CoreUserProvider;
    /**
     * Change the given user profile picture.
     *
     * @param  {number} draftItemId New picture draft item id.
     * @param  {number} userId      User ID.
     * @return {Promise<string>}       Promise resolve with the new profileimageurl
     */
    CoreUserProvider.prototype.changeProfilePicture = function (draftItemId, userId) {
        var data = {
            draftitemid: draftItemId,
            delete: 0,
            userid: userId
        };
        return this.sitesProvider.getCurrentSite().write('core_user_update_picture', data).then(function (result) {
            if (!result.success) {
                return Promise.reject(null);
            }
            return result.profileimageurl;
        });
    };
    /**
     * Store user basic information in local DB to be retrieved if the WS call fails.
     *
     * @param  {number} userId  User ID.
     * @param {string} [siteId] ID of the site. If not defined, use current site.
     * @return {Promise<any>}   Promise resolve when the user is deleted.
     */
    CoreUserProvider.prototype.deleteStoredUser = function (userId, siteId) {
        var _this = this;
        if (isNaN(userId)) {
            return Promise.reject(null);
        }
        var promises = [];
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Invalidate WS calls.
        promises.push(this.invalidateUserCache(userId, siteId));
        promises.push(this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().deleteRecords(_this.USERS_TABLE, { id: userId });
        }));
        return Promise.all(promises);
    };
    /**
     * Get participants for a certain course.
     *
     * @param  {number} courseId    ID of the course.
     * @param  {number} limitFrom   Position of the first participant to get.
     * @param  {number} limitNumber Number of participants to get.
     * @param  {string} [siteId]    Site Id. If not defined, use current site.
     * @return {Promise<any>}       Promise to be resolved when the participants are retrieved.
     */
    CoreUserProvider.prototype.getParticipants = function (courseId, limitFrom, limitNumber, siteId) {
        var _this = this;
        if (limitFrom === void 0) { limitFrom = 0; }
        if (limitNumber === void 0) { limitNumber = CoreUserProvider_1.PARTICIPANTS_LIST_LIMIT; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            _this.logger.debug("Get participants for course '" + courseId + "' starting at '" + limitFrom + "'");
            var data = {
                courseid: courseId,
                options: [
                    {
                        name: 'limitfrom',
                        value: limitFrom
                    },
                    {
                        name: 'limitnumber',
                        value: limitNumber
                    },
                    {
                        name: 'sortby',
                        value: 'siteorder'
                    }
                ]
            }, preSets = {
                cacheKey: _this.getParticipantsListCacheKey(courseId)
            };
            return site.read('core_enrol_get_enrolled_users', data, preSets).then(function (users) {
                var canLoadMore = users.length >= limitNumber;
                _this.storeUsers(users, siteId);
                return { participants: users, canLoadMore: canLoadMore };
            });
        });
    };
    /**
     * Get cache key for participant list WS calls.
     *
     * @param  {number} courseId Course ID.
     * @return {string}          Cache key.
     */
    CoreUserProvider.prototype.getParticipantsListCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'list:' + courseId;
    };
    /**
     * Get user profile. The type of profile retrieved depends on the params.
     *
     * @param  {number} userId      User's ID.
     * @param  {number} [courseId]  Course ID to get course profile, undefined or 0 to get site profile.
     * @param  {boolean} [forceLocal] True to retrieve the user data from local DB, false to retrieve it from WS.
     * @param {string} [siteId] ID of the site. If not defined, use current site.
     * @return {Promise<any>}            Promise resolved with the user data.
     */
    CoreUserProvider.prototype.getProfile = function (userId, courseId, forceLocal, siteId) {
        var _this = this;
        if (forceLocal === void 0) { forceLocal = false; }
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (forceLocal) {
            return this.getUserFromLocalDb(userId, siteId).catch(function () {
                return _this.getUserFromWS(userId, courseId, siteId);
            });
        }
        return this.getUserFromWS(userId, courseId, siteId).catch(function () {
            return _this.getUserFromLocalDb(userId, siteId);
        });
    };
    /**
     * Get cache key for a user WS call.
     *
     * @param  {number} userId User ID.
     * @return {string}        Cache key.
     */
    CoreUserProvider.prototype.getUserCacheKey = function (userId) {
        return this.ROOT_CACHE_KEY + 'data:' + userId;
    };
    /**
     * Get user basic information from local DB.
     *
     * @param {number} userId User ID.
     * @param {string} [siteId] ID of the site. If not defined, use current site.
     * @return {Promise<any>}   Promise resolve when the user is retrieved.
     */
    CoreUserProvider.prototype.getUserFromLocalDb = function (userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getRecord(_this.USERS_TABLE, { id: userId });
        });
    };
    /**
     * Get user profile from WS.
     *
     * @param {number} userId         User ID.
     * @param {number} [courseId] Course ID to get course profile, undefined or 0 to get site profile.
     * @param {string} [siteId] ID of the site. If not defined, use current site.
     * @return {Promise<any>}           Promise resolve when the user is retrieved.
     */
    CoreUserProvider.prototype.getUserFromWS = function (userId, courseId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var presets = {
                cacheKey: _this.getUserCacheKey(userId)
            };
            var wsName, data;
            // Determine WS and data to use.
            if (courseId && courseId != site.getSiteHomeId()) {
                _this.logger.debug("Get participant with ID '" + userId + "' in course '" + courseId);
                wsName = 'core_user_get_course_user_profiles';
                data = {
                    userlist: [
                        {
                            userid: userId,
                            courseid: courseId
                        }
                    ]
                };
            }
            else {
                _this.logger.debug("Get user with ID '" + userId + "'");
                wsName = 'core_user_get_users_by_field';
                data = {
                    'field': 'id',
                    'values[0]': userId
                };
            }
            return site.read(wsName, data, presets).then(function (users) {
                if (users.length == 0) {
                    return Promise.reject('Cannot retrieve user info.');
                }
                var user = users.shift();
                if (user.country) {
                    user.country = _this.utils.getCountryName(user.country);
                }
                _this.storeUser(user.id, user.fullname, user.profileimageurl);
                return user;
            });
        });
    };
    /**
     * Invalidates user WS calls.
     *
     * @param {number} userId User ID.
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<any>}       Promise resolved when the data is invalidated.
     */
    CoreUserProvider.prototype.invalidateUserCache = function (userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getUserCacheKey(userId));
        });
    };
    /**
     * Invalidates participant list for a certain course.
     *
     * @param  {number} courseId Course ID.
     * @param  {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<any>}         Promise resolved when the list is invalidated.
     */
    CoreUserProvider.prototype.invalidateParticipantsList = function (courseId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getParticipantsListCacheKey(courseId));
        });
    };
    /**
     * Check if course participants is disabled in a certain site.
     *
     * @param  {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<boolean>}     Promise resolved with true if disabled, rejected or resolved with false otherwise.
     */
    CoreUserProvider.prototype.isParticipantsDisabled = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.isParticipantsDisabledInSite(site);
        });
    };
    /**
     * Check if course participants is disabled in a certain site.
     *
     * @param {CoreSite} [site] Site. If not defined, use current site.
     * @return {boolean} Whether it's disabled.
     */
    CoreUserProvider.prototype.isParticipantsDisabledInSite = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.isFeatureDisabled('$mmCoursesDelegate_mmaParticipants');
    };
    /**
     * Returns whether or not participants is enabled for a certain course.
     *
     * @param {number} courseId Course ID.
     * @param  {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<any>}    Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    CoreUserProvider.prototype.isPluginEnabledForCourse = function (courseId, siteId) {
        if (!courseId) {
            return Promise.reject(null);
        }
        // Retrieving one participant will fail if browsing users is disabled by capabilities.
        return this.utils.promiseWorks(this.getParticipants(courseId, 0, 1, siteId));
    };
    /**
     * Check if update profile picture is disabled in a certain site.
     *
     * @param  {CoreSite} [site] Site. If not defined, use current site.
     * @return {boolean}       True if disabled, false otherwise.
     */
    CoreUserProvider.prototype.isUpdatePictureDisabledInSite = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.isFeatureDisabled('$mmUserDelegate_picture');
    };
    /**
     * Log User Profile View in Moodle.
     * @param  {number}       userId   User ID.
     * @param  {number}       [courseId] Course ID.
     * @return {Promise<any>}          Promise resolved when done.
     */
    CoreUserProvider.prototype.logView = function (userId, courseId) {
        var params = {
            userid: userId
        };
        if (courseId) {
            params['courseid'] = courseId;
        }
        return this.sitesProvider.getCurrentSite().write('core_user_view_user_profile', params);
    };
    /**
     * Log Participants list view in Moodle.
     * @param  {number}       courseId Course ID.
     * @return {Promise<any>}          Promise resolved when done.
     */
    CoreUserProvider.prototype.logParticipantsView = function (courseId) {
        return this.sitesProvider.getCurrentSite().write('core_user_view_user_list', {
            courseid: courseId
        });
    };
    /**
     * Store user basic information in local DB to be retrieved if the WS call fails.
     *
     * @param {number} userId   User ID.
     * @param {string} fullname User full name.
     * @param {string} avatar   User avatar URL.
     * @param  {string} [siteId] ID of the site. If not defined, use current site.
     * @return {Promise<any>}         Promise resolve when the user is stored.
     */
    CoreUserProvider.prototype.storeUser = function (userId, fullname, avatar, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var userRecord = {
                id: userId,
                fullname: fullname,
                profileimageurl: avatar
            };
            return site.getDb().insertOrUpdateRecord(_this.USERS_TABLE, userRecord, { id: userId });
        });
    };
    /**
     * Store users basic information in local DB.
     *
     * @param  {any[]} users     Users to store. Fields stored: id, fullname, profileimageurl.
     * @param  {string} [siteId] ID of the site. If not defined, use current site.
     * @return {Promise<any>}        Promise resolve when the user is stored.
     */
    CoreUserProvider.prototype.storeUsers = function (users, siteId) {
        var _this = this;
        var promises = [];
        users.forEach(function (user) {
            if (typeof user.id != 'undefined' && !isNaN(parseInt(user.id, 10))) {
                promises.push(_this.storeUser(parseInt(user.id, 10), user.fullname, user.profileimageurl, siteId));
            }
        });
        return Promise.all(promises);
    };
    /**
     * Update a preference for a user.
     *
     * @param  {string} name     Preference name.
     * @param  {any} value       Preference new value.
     * @param  {number} [userId] User ID. If not defined, site's current user.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved if success.
     */
    CoreUserProvider.prototype.updateUserPreference = function (name, value, userId, siteId) {
        var preferences = [
            {
                type: name,
                value: value
            }
        ];
        return this.updateUserPreferences(preferences, undefined, userId, siteId);
    };
    /**
     * Update some preferences for a user.
     *
     * @param  {any} preferences                List of preferences.
     * @param  {boolean} [disableNotifications] Whether to disable all notifications. Undefined to not update this value.
     * @param  {number} [userId]                User ID. If not defined, site's current user.
     * @param  {string} [siteId]                Site ID. If not defined, current site.
     * @return {Promise<any>}                   Promise resolved if success.
     */
    CoreUserProvider.prototype.updateUserPreferences = function (preferences, disableNotifications, userId, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            var data = {
                userid: userId,
                preferences: preferences
            }, preSets = {
                responseExpected: false
            };
            if (typeof disableNotifications != 'undefined') {
                data['emailstop'] = disableNotifications ? 1 : 0;
            }
            return site.write('core_user_update_user_preferences', data, preSets);
        });
    };
    CoreUserProvider.PARTICIPANTS_LIST_LIMIT = 50; // Max of participants to retrieve in each WS call.
    CoreUserProvider.PROFILE_REFRESHED = 'CoreUserProfileRefreshed';
    CoreUserProvider.PROFILE_PICTURE_UPDATED = 'CoreUserProfilePictureUpdated';
    CoreUserProvider = CoreUserProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], CoreUserProvider);
    return CoreUserProvider;
    var CoreUserProvider_1;
}());

//# sourceMappingURL=user.js.map

/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreInitDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_utils__ = __webpack_require__(9);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/*
 * Provider for initialisation mechanisms.
 */
var CoreInitDelegate = /** @class */ (function () {
    function CoreInitDelegate(logger, platform, utils) {
        this.utils = utils;
        this.initProcesses = {};
        this.logger = logger.getInstance('CoreInitDelegate');
    }
    CoreInitDelegate_1 = CoreInitDelegate;
    /**
     * Executes the registered init processes.
     *
     * Reserved for core use, do not call directly.
     */
    CoreInitDelegate.prototype.executeInitProcesses = function () {
        var _this = this;
        var ordered = [];
        if (typeof this.readiness == 'undefined') {
            this.initReadiness();
        }
        // Re-ordering by priority.
        for (var name_1 in this.initProcesses) {
            ordered.push(this.initProcesses[name_1]);
        }
        ordered.sort(function (a, b) {
            return b.priority - a.priority;
        });
        ordered = ordered.map(function (data) {
            return {
                context: _this,
                func: _this.prepareProcess,
                params: [data],
                blocking: !!data.blocking
            };
        });
        // Execute all the processes in order to solve dependencies.
        this.utils.executeOrderedPromises(ordered).finally(this.readiness.resolve);
    };
    /**
     * Init the readiness promise.
     */
    CoreInitDelegate.prototype.initReadiness = function () {
        var _this = this;
        this.readiness = this.utils.promiseDefer();
        this.readiness.promise.then(function () { return _this.readiness.resolved = true; });
    };
    /**
     * Instantly returns if the app is ready.
     *
     * To be notified when the app is ready, refer to {@link $mmApp#ready}.
     *
     * @return {boolean} Whether it's ready.
     */
    CoreInitDelegate.prototype.isReady = function () {
        return this.readiness.resolved;
    };
    /**
     * Convenience function to return a function that executes the process.
     *
     * @param {CoreInitHandler} data The data of the process.
     * @return {Promise<any>} Promise of the process.
     */
    CoreInitDelegate.prototype.prepareProcess = function (data) {
        var promise;
        this.logger.debug("Executing init process '" + data.name + "'");
        try {
            promise = data.load();
        }
        catch (e) {
            this.logger.error('Error while calling the init process \'' + data.name + '\'. ' + e);
            return;
        }
        return promise;
    };
    /**
     * Notifies when the app is ready. This returns a promise that is resolved when the app is initialised.
     *
     * @return {Promise<any>} Resolved when the app is initialised. Never rejected.
     */
    CoreInitDelegate.prototype.ready = function () {
        if (typeof this.readiness === 'undefined') {
            // Prevent race conditions if this is called before executeInitProcesses.
            this.initReadiness();
        }
        return this.readiness.promise;
    };
    /**
     * Registers an initialisation process.
     *
     * @description
     * Init processes can be used to add initialisation logic to the app. Anything that should block the user interface while
     * some processes are done should be an init process. It is recommended to use a priority lower than MAX_RECOMMENDED_PRIORITY
     * to make sure that your process does not happen before some essential other core processes.
     *
     * An init process should never change state or prompt user interaction.
     *
     * This delegate cannot be used by site plugins.
     *
     * @param {CoreInitHandler} instance The instance of the handler.
     */
    CoreInitDelegate.prototype.registerProcess = function (handler) {
        if (typeof handler.priority == 'undefined') {
            handler.priority = CoreInitDelegate_1.DEFAULT_PRIORITY;
        }
        if (typeof this.initProcesses[handler.name] != 'undefined') {
            this.logger.log("Process '" + handler.name + "' already registered.");
            return;
        }
        this.logger.log("Registering process '" + handler.name + "'.");
        this.initProcesses[handler.name] = handler;
    };
    CoreInitDelegate.DEFAULT_PRIORITY = 100; // Default priority for init processes.
    CoreInitDelegate.MAX_RECOMMENDED_PRIORITY = 600;
    CoreInitDelegate = CoreInitDelegate_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */], __WEBPACK_IMPORTED_MODULE_3__utils_utils__["a" /* CoreUtilsProvider */]])
    ], CoreInitDelegate);
    return CoreInitDelegate;
    var CoreInitDelegate_1;
}());

//# sourceMappingURL=init.js.map

/***/ }),
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */,
/* 68 */,
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_events__ = __webpack_require__(15);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Superclass to help creating delegates
 */
var CoreDelegate = /** @class */ (function () {
    /**
     * Constructor of the Delegate.
     *
     * @param {string} delegateName Delegate name used for logging purposes.
     * @param {CoreLoggerProvider}   loggerProvider CoreLoggerProvider instance, cannot be directly injected.
     * @param {CoreSitesProvider}    sitesProvider  CoreSitesProvider instance, cannot be directly injected.
     * @param {CoreEventsProvider}   [eventsProvider]  CoreEventsProvider instance, cannot be directly injected.
     *                                                  If not set, no events will be fired.
     */
    function CoreDelegate(delegateName, loggerProvider, sitesProvider, eventsProvider) {
        this.loggerProvider = loggerProvider;
        this.sitesProvider = sitesProvider;
        this.eventsProvider = eventsProvider;
        /**
         * List of registered handlers.
         * @type {any}
         */
        this.handlers = {};
        /**
         * List of registered handlers enabled for the current site.
         * @type {any}
         */
        this.enabledHandlers = {};
        this.logger = this.loggerProvider.getInstance(delegateName);
        if (eventsProvider) {
            // Update handlers on this cases.
            eventsProvider.on(__WEBPACK_IMPORTED_MODULE_3__providers_events__["a" /* CoreEventsProvider */].LOGIN, this.updateHandlers.bind(this));
            eventsProvider.on(__WEBPACK_IMPORTED_MODULE_3__providers_events__["a" /* CoreEventsProvider */].SITE_UPDATED, this.updateHandlers.bind(this));
            eventsProvider.on(__WEBPACK_IMPORTED_MODULE_3__providers_events__["a" /* CoreEventsProvider */].SITE_PLUGINS_LOADED, this.updateHandlers.bind(this));
        }
    }
    /**
     * Execute a certain function in a enabled handler.
     * If the handler isn't found or function isn't defined, call the same function in the default handler.
     *
     * @param {string} handlerName The handler name.
     * @param {string} fnName Name of the function to execute.
     * @param {any[]} params Parameters to pass to the function.
     * @return {any} Function returned value or default value.
     */
    CoreDelegate.prototype.executeFunctionOnEnabled = function (handlerName, fnName, params) {
        return this.execute(this.enabledHandlers[handlerName], fnName, params);
    };
    /**
     * Execute a certain function in a handler.
     * If the handler isn't found or function isn't defined, call the same function in the default handler.
     *
     * @param {string} handlerName The handler name.
     * @param {string} fnName Name of the function to execute.
     * @param {any[]} params Parameters to pass to the function.
     * @return {any} Function returned value or default value.
     */
    CoreDelegate.prototype.executeFunction = function (handlerName, fnName, params) {
        return this.execute(this.handlers[handlerName], fnName, params);
    };
    /**
     * Execute a certain function in a handler.
     * If the handler isn't found or function isn't defined, call the same function in the default handler.
     *
     * @param {any} handler The handler.
     * @param {string} fnName Name of the function to execute.
     * @param {any[]} params Parameters to pass to the function.
     * @return {any} Function returned value or default value.
     */
    CoreDelegate.prototype.execute = function (handler, fnName, params) {
        if (handler && handler[fnName]) {
            return handler[fnName].apply(handler, params);
        }
        else if (this.defaultHandler && this.defaultHandler[fnName]) {
            return this.defaultHandler[fnName].apply(this.defaultHandler, params);
        }
    };
    /**
     * Get a handler.
     *
     * @param  {string} handlerName The handler name.
     * @param  {boolean} [enabled]  Only enabled, or any.
     * @return {CoreDelegateHandler} Handler.
     */
    CoreDelegate.prototype.getHandler = function (handlerName, enabled) {
        if (enabled === void 0) { enabled = false; }
        return enabled ? this.enabledHandlers[handlerName] : this.handlers[handlerName];
    };
    /**
     * Check if a handler name has a registered handler (not necessarily enabled).
     *
     * @param {string} name The handler name.
     * @param  {boolean} [enabled]  Only enabled, or any.
     * @return {boolean} If the handler is registered or not.
     */
    CoreDelegate.prototype.hasHandler = function (name, enabled) {
        if (enabled === void 0) { enabled = false; }
        return enabled ? typeof this.enabledHandlers[name] !== 'undefined' : typeof this.handlers[name] !== 'undefined';
    };
    /**
     * Check if a time belongs to the last update handlers call.
     * This is to handle the cases where updateHandlers don't finish in the same order as they're called.
     *
     * @param {number} time Time to check.
     * @return {boolean} Whether it's the last call.
     */
    CoreDelegate.prototype.isLastUpdateCall = function (time) {
        if (!this.lastUpdateHandlersStart) {
            return true;
        }
        return time == this.lastUpdateHandlersStart;
    };
    /**
     * Register a handler.
     *
     * @param {CoreDelegateHandler} handler The handler delegate object to register.
     * @return {boolean} True when registered, false if already registered.
     */
    CoreDelegate.prototype.registerHandler = function (handler) {
        if (typeof this.handlers[handler.name] !== 'undefined') {
            this.logger.log("Addon '" + handler.name + "' already registered");
            return false;
        }
        this.logger.log("Registered addon '" + handler.name + "'");
        this.handlers[handler.name] = handler;
        return true;
    };
    /**
     * Update the handler for the current site.
     *
     * @param {CoreDelegateHandler} handler The handler to check.
     * @param {number} time Time this update process started.
     * @return {Promise<void>} Resolved when done.
     */
    CoreDelegate.prototype.updateHandler = function (handler, time) {
        var _this = this;
        var siteId = this.sitesProvider.getCurrentSiteId(), currentSite = this.sitesProvider.getCurrentSite();
        var promise;
        if (!this.sitesProvider.isLoggedIn()) {
            promise = Promise.reject(null);
        }
        else if (this.isFeatureDisabled(handler, currentSite)) {
            promise = Promise.resolve(false);
        }
        else {
            promise = Promise.resolve(handler.isEnabled());
        }
        // Checks if the handler is enabled.
        return promise.catch(function () {
            return false;
        }).then(function (enabled) {
            // Verify that this call is the last one that was started.
            // Check that site hasn't changed since the check started.
            if (_this.isLastUpdateCall(time) && _this.sitesProvider.getCurrentSiteId() === siteId) {
                if (enabled) {
                    _this.enabledHandlers[handler.name] = handler;
                }
                else {
                    delete _this.enabledHandlers[handler.name];
                }
            }
        });
    };
    /**
     * Check if feature is enabled or disabled in the site, depending on the feature prefix and the handler name.
     *
     * @param  {CoreDelegateHandler} handler Handler to check.
     * @param  {any}                 site    Site to check.
     * @return {boolean}                     Whether is enabled or disabled in site.
     */
    CoreDelegate.prototype.isFeatureDisabled = function (handler, site) {
        return typeof this.featurePrefix != 'undefined' && site.isFeatureDisabled(this.featurePrefix + handler.name);
    };
    /**
     * Update the handlers for the current site.
     *
     * @return {Promise<void>} Resolved when done.
     */
    CoreDelegate.prototype.updateHandlers = function () {
        var _this = this;
        var promises = [], now = Date.now();
        this.logger.debug('Updating handlers for current site.');
        this.lastUpdateHandlersStart = now;
        // Loop over all the handlers.
        for (var name_1 in this.handlers) {
            promises.push(this.updateHandler(this.handlers[name_1], now));
        }
        return Promise.all(promises).then(function () {
            return true;
        }, function () {
            // Never reject.
            return true;
        }).then(function () {
            // Verify that this call is the last one that was started.
            if (_this.isLastUpdateCall(now)) {
                _this.updateData();
            }
        });
    };
    /**
     * Update handlers Data.
     * Override this function to update handlers data.
     */
    CoreDelegate.prototype.updateData = function () {
        // To be overridden.
    };
    CoreDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [String, __WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_events__["a" /* CoreEventsProvider */]])
    ], CoreDelegate);
    return CoreDelegate;
}());

//# sourceMappingURL=delegate.js.map

/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonMessagesProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_user_providers_user__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__messages_offline__ = __webpack_require__(245);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_time__ = __webpack_require__(52);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








/**
 * Service to handle messages.
 */
var AddonMessagesProvider = /** @class */ (function () {
    function AddonMessagesProvider(logger, sitesProvider, appProvider, userProvider, messagesOffline, utils, timeUtils) {
        this.sitesProvider = sitesProvider;
        this.appProvider = appProvider;
        this.userProvider = userProvider;
        this.messagesOffline = messagesOffline;
        this.utils = utils;
        this.timeUtils = timeUtils;
        this.ROOT_CACHE_KEY = 'mmaMessages:';
        this.LIMIT_MESSAGES = 50;
        this.LIMIT_SEARCH_MESSAGES = 50;
        this.logger = logger.getInstance('AddonMessagesProvider');
    }
    /**
     * Add a contact.
     *
     * @param {number} userId  User ID of the person to add.
     * @param {string} [siteId]  Site ID. If not defined, use current site.
     * @return {Promise<any>}  Resolved when done.
     */
    AddonMessagesProvider.prototype.addContact = function (userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                userids: [userId]
            };
            return site.write('core_message_create_contacts', params).then(function () {
                return _this.invalidateAllContactsCache(site.getUserId(), site.getId());
            });
        });
    };
    /**
     * Block a contact.
     *
     * @param {number} userId User ID of the person to block.
     * @param {string} [siteId]  Site ID. If not defined, use current site.
     * @return {Promise<any>} Resolved when done.
     */
    AddonMessagesProvider.prototype.blockContact = function (userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                userids: [userId]
            };
            return site.write('core_message_block_contacts', params).then(function () {
                return _this.invalidateAllContactsCache(site.getUserId(), site.getId());
            });
        });
    };
    /**
     * Delete a message (online or offline).
     *
     * @param {any} message    Message to delete.
     * @return {Promise<any>}  Promise resolved when the message has been deleted.
     */
    AddonMessagesProvider.prototype.deleteMessage = function (message) {
        if (message.id) {
            // Message has ID, it means it has been sent to the server.
            return this.deleteMessageOnline(message.id, message.read);
        }
        // It's an offline message.
        return this.messagesOffline.deleteMessage(message.touserid, message.smallmessage, message.timecreated);
    };
    /**
     * Delete a message from the server.
     *
     * @param {number} id       Message ID.
     * @param {number} read     1 if message is read, 0 otherwise.
     * @param {number} [userId] User we want to delete the message for. If not defined, use current user.
     * @return {Promise<any>}   Promise resolved when the message has been deleted.
     */
    AddonMessagesProvider.prototype.deleteMessageOnline = function (id, read, userId) {
        var _this = this;
        userId = userId || this.sitesProvider.getCurrentSiteUserId();
        var params = {
            messageid: id,
            userid: userId,
            read: read
        };
        return this.sitesProvider.getCurrentSite().write('core_message_delete_message', params).then(function () {
            return _this.invalidateDiscussionCache(userId);
        });
    };
    /**
     * Get the cache key for blocked contacts.
     *
     * @param {number} userId The user who's contacts we're looking for.
     * @return {string} Cache key.
     */
    AddonMessagesProvider.prototype.getCacheKeyForBlockedContacts = function (userId) {
        return this.ROOT_CACHE_KEY + 'blockedContacts:' + userId;
    };
    /**
     * Get the cache key for contacts.
     *
     * @return {string} Cache key.
     */
    AddonMessagesProvider.prototype.getCacheKeyForContacts = function () {
        return this.ROOT_CACHE_KEY + 'contacts';
    };
    /**
     * Get the cache key for a discussion.
     *
     * @param {number} userId The other person with whom the current user is having the discussion.
     * @return {string} Cache key.
     */
    AddonMessagesProvider.prototype.getCacheKeyForDiscussion = function (userId) {
        return this.ROOT_CACHE_KEY + 'discussion:' + userId;
    };
    /**
     * Get the cache key for the message count.
     *
     * @param {number} userId  User ID.
     * @return {string} Cache key.
     */
    AddonMessagesProvider.prototype.getCacheKeyForMessageCount = function (userId) {
        return this.ROOT_CACHE_KEY + 'count:' + userId;
    };
    /**
     * Get the cache key for the list of discussions.
     *
     * @return {string} Cache key.
     */
    AddonMessagesProvider.prototype.getCacheKeyForDiscussions = function () {
        return this.ROOT_CACHE_KEY + 'discussions';
    };
    /**
     * Get all the contacts of the current user.
     *
     * @param  {string} [siteId]  Site ID. If not defined, use current site.
     * @return {Promise<any>} Resolved with the WS data.
     */
    AddonMessagesProvider.prototype.getAllContacts = function (siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.getContacts(siteId).then(function (contacts) {
            return _this.getBlockedContacts(siteId).then(function (blocked) {
                contacts.blocked = blocked.users;
                _this.storeUsersFromAllContacts(contacts);
                return contacts;
            }).catch(function () {
                // The WS for blocked contacts might fail, but we still want the contacts.
                contacts.blocked = [];
                _this.storeUsersFromAllContacts(contacts);
                return contacts;
            });
        });
    };
    /**
     * Get all the blocked contacts of the current user.
     *
     * @param  {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any>} Resolved with the WS data.
     */
    AddonMessagesProvider.prototype.getBlockedContacts = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var userId = site.getUserId(), params = {
                userid: userId
            }, preSets = {
                cacheKey: _this.getCacheKeyForBlockedContacts(userId)
            };
            return site.read('core_message_get_blocked_users', params, preSets);
        });
    };
    /**
     * Get the contacts of the current user.
     *
     * This excludes the blocked users.
     *
     * @param  {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any>} Resolved with the WS data.
     */
    AddonMessagesProvider.prototype.getContacts = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var preSets = {
                cacheKey: _this.getCacheKeyForContacts()
            };
            return site.read('core_message_get_contacts', undefined, preSets).then(function (contacts) {
                // Filter contacts with negative ID, they are notifications.
                var validContacts = {};
                var _loop_1 = function (typeName) {
                    if (!validContacts[typeName]) {
                        validContacts[typeName] = [];
                    }
                    contacts[typeName].forEach(function (contact) {
                        if (contact.id > 0) {
                            validContacts[typeName].push(contact);
                        }
                    });
                };
                for (var typeName in contacts) {
                    _loop_1(typeName);
                }
                return validContacts;
            });
        });
    };
    /**
     * Return the current user's discussion with another user.
     *
     * @param  {number} userId               The ID of the other user.
     * @param  {boolean} excludePending      True to exclude messages pending to be sent.
     * @param  {number} [lfReceivedUnread=0] Number of unread received messages already fetched, so fetch will be done from this.
     * @param  {number} [lfReceivedRead=0]   Number of read received messages already fetched, so fetch will be done from this.
     * @param  {number} [lfSentUnread=0]     Number of unread sent messages already fetched, so fetch will be done from this.
     * @param  {number} [lfSentRead=0]       Number of read sent messages already fetched, so fetch will be done from this.
     * @param  {boolean} [toDisplay=true]    True if messages will be displayed to the user, either in view or in a notification.
     * @param  {string} [siteId]             Site ID. If not defined, use current site.
     * @return {Promise<any>}                     Promise resolved with messages and a boolean telling if can load more messages.
     */
    AddonMessagesProvider.prototype.getDiscussion = function (userId, excludePending, lfReceivedUnread, lfReceivedRead, lfSentUnread, lfSentRead, toDisplay, siteId) {
        var _this = this;
        if (lfReceivedUnread === void 0) { lfReceivedUnread = 0; }
        if (lfReceivedRead === void 0) { lfReceivedRead = 0; }
        if (lfSentUnread === void 0) { lfSentUnread = 0; }
        if (lfSentRead === void 0) { lfSentRead = 0; }
        if (toDisplay === void 0) { toDisplay = true; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var result = {}, preSets = {
                cacheKey: _this.getCacheKeyForDiscussion(userId)
            }, params = {
                useridto: site.getUserId(),
                useridfrom: userId,
                limitnum: _this.LIMIT_MESSAGES
            };
            var hasReceived, hasSent;
            if (lfReceivedUnread > 0 || lfReceivedRead > 0 || lfSentUnread > 0 || lfSentRead > 0) {
                // Do not use cache when retrieving older messages.
                // This is to prevent storing too much data and to prevent inconsistencies between "pages" loaded.
                preSets['getFromCache'] = false;
                preSets['saveToCache'] = false;
                preSets['emergencyCache'] = false;
            }
            // Get message received by current user.
            return _this.getRecentMessages(params, preSets, lfReceivedUnread, lfReceivedRead, toDisplay, site.getId())
                .then(function (response) {
                result['messages'] = response;
                params.useridto = userId;
                params.useridfrom = site.getUserId();
                hasReceived = response.length > 0;
                // Get message sent by current user.
                return _this.getRecentMessages(params, preSets, lfSentUnread, lfSentRead, toDisplay, siteId);
            }).then(function (response) {
                result['messages'] = result['messages'].concat(response);
                hasSent = response.length > 0;
                if (result['messages'].length > _this.LIMIT_MESSAGES) {
                    // Sort messages and get the more recent ones.
                    result['canLoadMore'] = true;
                    result['messages'] = _this.sortMessages(result['messages']);
                    result['messages'] = result['messages'].slice(-_this.LIMIT_MESSAGES);
                }
                else {
                    result['canLoadMore'] = result['messages'].length == _this.LIMIT_MESSAGES && (!hasReceived || !hasSent);
                }
                if (excludePending) {
                    // No need to get offline messages, return the ones we have.
                    return result;
                }
                // Get offline messages.
                return _this.messagesOffline.getMessages(userId).then(function (offlineMessages) {
                    // Mark offline messages as pending.
                    offlineMessages.forEach(function (message) {
                        message.pending = true;
                        message.text = message.smallmessage;
                    });
                    result['messages'] = result['messages'].concat(offlineMessages);
                    return result;
                });
            });
        });
    };
    /**
     * Get the discussions of the current user.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Resolved with an object where the keys are the user ID of the other user.
     */
    AddonMessagesProvider.prototype.getDiscussions = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var discussions = {}, currentUserId = site.getUserId(), params = {
                useridto: currentUserId,
                useridfrom: 0,
                limitnum: _this.LIMIT_MESSAGES
            }, preSets = {
                cacheKey: _this.getCacheKeyForDiscussions()
            };
            /**
             * Convenience function to treat a recent message, adding it to discussions list if needed.
             */
            var treatRecentMessage = function (message, userId, userFullname) {
                if (typeof discussions[userId] === 'undefined') {
                    discussions[userId] = {
                        fullname: userFullname,
                        profileimageurl: ''
                    };
                    if (!message.timeread && !message.pending && message.useridfrom != currentUserId) {
                        discussions[userId].unread = true;
                    }
                }
                // Extract the most recent message. Pending messages are considered more recent than messages already sent.
                var discMessage = discussions[userId].message;
                if (typeof discMessage === 'undefined' || (!discMessage.pending && message.pending) ||
                    (discMessage.pending == message.pending && (discMessage.timecreated < message.timecreated ||
                        (discMessage.timecreated == message.timecreated && discMessage.id < message.id)))) {
                    discussions[userId].message = {
                        id: message.id,
                        user: userId,
                        message: message.text,
                        timecreated: message.timecreated,
                        pending: !!message.pending
                    };
                }
            };
            // Get recent messages sent to current user.
            return _this.getRecentMessages(params, preSets, undefined, undefined, undefined, site.getId()).then(function (messages) {
                // Extract the discussions by filtering same senders.
                messages.forEach(function (message) {
                    treatRecentMessage(message, message.useridfrom, message.userfromfullname);
                });
                // Now get the last messages sent by the current user.
                params.useridfrom = params.useridto;
                params.useridto = 0;
                return _this.getRecentMessages(params, preSets);
            }).then(function (messages) {
                // Extract the discussions by filtering same senders.
                messages.forEach(function (message) {
                    treatRecentMessage(message, message.useridto, message.usertofullname);
                });
                // Now get unsent messages.
                return _this.messagesOffline.getAllMessages(site.getId());
            }).then(function (offlineMessages) {
                offlineMessages.forEach(function (message) {
                    message.pending = true;
                    message.text = message.smallmessage;
                    treatRecentMessage(message, message.touserid, '');
                });
                return _this.getDiscussionsUserImg(discussions, site.getId()).then(function (discussions) {
                    _this.storeUsersFromDiscussions(discussions);
                    return discussions;
                });
            });
        });
    };
    /**
     * Get user images for all the discussions that don't have one already.
     *
     * @param {any} discussions List of discussions.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}             Promise always resolved. Resolve param is the formatted discussions.
     */
    AddonMessagesProvider.prototype.getDiscussionsUserImg = function (discussions, siteId) {
        var promises = [];
        var _loop_2 = function (userId) {
            if (!discussions[userId].profileimageurl) {
                // We don't have the user image. Try to retrieve it.
                promises.push(this_1.userProvider.getProfile(discussions[userId].message.user, 0, true, siteId).then(function (user) {
                    discussions[userId].profileimageurl = user.profileimageurl;
                }).catch(function () {
                    // Error getting profile, resolve promise without adding any extra data.
                }));
            }
        };
        var this_1 = this;
        for (var userId in discussions) {
            _loop_2(userId);
        }
        return Promise.all(promises).then(function () {
            return discussions;
        });
    };
    /**
     * Get the cache key for the get message preferences call.
     *
     * @return {string} Cache key.
     */
    AddonMessagesProvider.prototype.getMessagePreferencesCacheKey = function () {
        return this.ROOT_CACHE_KEY + 'messagePreferences';
    };
    /**
     * Get message preferences.
     *
     * @param  {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any>}         Promise resolved with the message preferences.
     */
    AddonMessagesProvider.prototype.getMessagePreferences = function (siteId) {
        var _this = this;
        this.logger.debug('Get message preferences');
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var preSets = {
                cacheKey: _this.getMessagePreferencesCacheKey()
            };
            return site.read('core_message_get_user_message_preferences', {}, preSets).then(function (data) {
                if (data.preferences) {
                    data.preferences.blocknoncontacts = !!data.blocknoncontacts;
                    return data.preferences;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get messages according to the params.
     *
     * @param  {any} params            Parameters to pass to the WS.
     * @param  {any} preSets           Set of presets for the WS.
     * @param  {boolean} [toDisplay=true] True if messages will be displayed to the user, either in view or in a notification.
     * @param  {string} [siteId]          Site ID. If not defined, use current site.
     * @return {Promise<any>}
     */
    AddonMessagesProvider.prototype.getMessages = function (params, preSets, toDisplay, siteId) {
        var _this = this;
        if (toDisplay === void 0) { toDisplay = true; }
        params['type'] = 'conversations';
        params['newestfirst'] = 1;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var userId = site.getUserId();
            return site.read('core_message_get_messages', params, preSets).then(function (response) {
                response.messages.forEach(function (message) {
                    message.read = params.read == 0 ? 0 : 1;
                    // Convert times to milliseconds.
                    message.timecreated = message.timecreated ? message.timecreated * 1000 : 0;
                    message.timeread = message.timeread ? message.timeread * 1000 : 0;
                });
                if (toDisplay && _this.appProvider.isDesktop() && !params.read && params.useridto == userId &&
                    params.limitfrom === 0) {
                    // Store the last unread received messages. Don't block the user for this.
                    _this.storeLastReceivedMessageIfNeeded(params.useridfrom, response.messages[0], site.getId());
                }
                return response;
            });
        });
    };
    /**
     * Get the most recent messages.
     *
     * @param  {any} params              Parameters to pass to the WS.
     * @param  {any} preSets             Set of presets for the WS.
     * @param  {number} [limitFromUnread=0] Number of read messages already fetched, so fetch will be done from this number.
     * @param  {number} [limitFromRead=0]   Number of unread messages already fetched, so fetch will be done from this number.
     * @param  {boolean} [toDisplay=true]   True if messages will be displayed to the user, either in view or in a notification.
     * @param  {string} [siteId]            Site ID. If not defined, use current site.
     * @return {Promise<any>}
     */
    AddonMessagesProvider.prototype.getRecentMessages = function (params, preSets, limitFromUnread, limitFromRead, toDisplay, siteId) {
        var _this = this;
        if (limitFromUnread === void 0) { limitFromUnread = 0; }
        if (limitFromRead === void 0) { limitFromRead = 0; }
        if (toDisplay === void 0) { toDisplay = true; }
        limitFromUnread = limitFromUnread || 0;
        limitFromRead = limitFromRead || 0;
        params['read'] = 0;
        params['limitfrom'] = limitFromUnread;
        return this.getMessages(params, preSets, toDisplay, siteId).then(function (response) {
            var messages = response.messages;
            if (messages) {
                if (messages.length >= params.limitnum) {
                    return messages;
                }
                // We need to fetch more messages.
                params.limitnum = params.limitnum - messages.length;
                params.read = 1;
                params.limitfrom = limitFromRead;
                return _this.getMessages(params, preSets, toDisplay, siteId).then(function (response) {
                    if (response.messages) {
                        messages = messages.concat(response.messages);
                    }
                    return messages;
                }).catch(function () {
                    return messages;
                });
            }
            else {
                return Promise.reject(null);
            }
        });
    };
    /**
     * Get unread conversations count. Do not cache calls.
     *
     * @param  {number} [userId] The user id who received the message. If not defined, use current user.
     * @param  {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any>}    Promise resolved with the message unread count.
     */
    AddonMessagesProvider.prototype.getUnreadConversationsCount = function (userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            // @since 3.2
            if (site.wsAvailable('core_message_get_unread_conversations_count')) {
                var params_1 = {
                    useridto: userId
                }, preSets = {
                    cacheKey: _this.getCacheKeyForMessageCount(userId),
                    getFromCache: false,
                    emergencyCache: true,
                    saveToCache: true,
                    typeExpected: 'number'
                };
                return site.read('core_message_get_unread_conversations_count', params_1, preSets).catch(function () {
                    // Return no messages if the call fails.
                    return 0;
                });
            }
            // Fallback call.
            var params = {
                read: 0,
                limitfrom: 0,
                limitnum: _this.LIMIT_MESSAGES + 1,
                useridto: userId,
                useridfrom: 0,
            };
            return _this.getMessages(params, undefined, false, siteId).then(function (response) {
                // Count the discussions by filtering same senders.
                var discussions = {};
                response.messages.forEach(function (message) {
                    discussions[message.useridto] = 1;
                });
                var count = Object.keys(discussions).length;
                // Add + sign if there are more than the limit reachable.
                return (count > _this.LIMIT_MESSAGES) ? count + '+' : count;
            }).catch(function () {
                // Return no messages if the call fails.
                return 0;
            });
        });
    };
    /**
     * Get the latest unread received messages.
     *
     * @param  {boolean} [toDisplay=true] True if messages will be displayed to the user, either in view or in a notification.
     * @param  {boolean} [forceCache]     True if it should return cached data. Has priority over ignoreCache.
     * @param  {boolean} [ignoreCache]    True if it should ignore cached data (it will always fail in offline or server down).
     * @param  {string} [siteId]          Site ID. If not defined, use current site.
     * @return {Promise<any>}                  Promise resolved with the message unread count.
     */
    AddonMessagesProvider.prototype.getUnreadReceivedMessages = function (toDisplay, forceCache, ignoreCache, siteId) {
        var _this = this;
        if (toDisplay === void 0) { toDisplay = true; }
        if (forceCache === void 0) { forceCache = false; }
        if (ignoreCache === void 0) { ignoreCache = false; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                read: 0,
                limitfrom: 0,
                limitnum: _this.LIMIT_MESSAGES,
                useridto: site.getUserId(),
                useridfrom: 0
            }, preSets = {};
            if (forceCache) {
                preSets['omitExpires'] = true;
            }
            else if (ignoreCache) {
                preSets['getFromCache'] = false;
                preSets['emergencyCache'] = false;
            }
            return _this.getMessages(params, preSets, toDisplay, siteId);
        });
    };
    /**
     * Invalidate all contacts cache.
     *
     * @param {number} userId    The user ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Resolved when done.
     */
    AddonMessagesProvider.prototype.invalidateAllContactsCache = function (userId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.invalidateContactsCache(siteId).then(function () {
            return _this.invalidateBlockedContactsCache(userId, siteId);
        });
    };
    /**
     * Invalidate blocked contacts cache.
     *
     * @param {number} userId    The user ID.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}
     */
    AddonMessagesProvider.prototype.invalidateBlockedContactsCache = function (userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getCacheKeyForBlockedContacts(userId));
        });
    };
    /**
     * Invalidate contacts cache.
     *
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Resolved when done.
     */
    AddonMessagesProvider.prototype.invalidateContactsCache = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getCacheKeyForContacts());
        });
    };
    /**
     * Invalidate discussion cache.
     *
     * @param {number} userId    The user ID with whom the current user is having the discussion.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Resolved when done.
     */
    AddonMessagesProvider.prototype.invalidateDiscussionCache = function (userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getCacheKeyForDiscussion(userId));
        });
    };
    /**
     * Invalidate discussions cache.
     *
     * Note that {@link this.getDiscussions} uses the contacts, so we need to invalidate contacts too.
     *
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Resolved when done.
     */
    AddonMessagesProvider.prototype.invalidateDiscussionsCache = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var promises = [];
            promises.push(site.invalidateWsCacheForKey(_this.getCacheKeyForDiscussions()));
            promises.push(_this.invalidateContactsCache(site.getId()));
            return Promise.all(promises);
        });
    };
    /**
     * Invalidate get message preferences.
     *
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}         Promise resolved when data is invalidated.
     */
    AddonMessagesProvider.prototype.invalidateMessagePreferences = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getMessagePreferencesCacheKey());
        });
    };
    /**
     * Checks if the a user is blocked by the current user.
     *
     * @param {number} userId The user ID to check against.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<boolean>} Resolved with boolean, rejected when we do not know.
     */
    AddonMessagesProvider.prototype.isBlocked = function (userId, siteId) {
        return this.getBlockedContacts(siteId).then(function (blockedContacts) {
            if (!blockedContacts.users || blockedContacts.users.length < 1) {
                return false;
            }
            return blockedContacts.users.some(function (user) {
                return userId == user.id;
            });
        });
    };
    /**
     * Checks if the a user is a contact of the current user.
     *
     * @param {number} userId The user ID to check against.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<boolean>} Resolved with boolean, rejected when we do not know.
     */
    AddonMessagesProvider.prototype.isContact = function (userId, siteId) {
        return this.getContacts(siteId).then(function (contacts) {
            return ['online', 'offline'].some(function (type) {
                if (contacts[type] && contacts[type].length > 0) {
                    return contacts[type].some(function (user) {
                        return userId == user.id;
                    });
                }
                return false;
            });
        });
    };
    /**
     * Returns whether or not we can mark all messages as read.
     *
     * @return {boolean} If related WS is avalaible on current site.
     * @since  3.2
     */
    AddonMessagesProvider.prototype.isMarkAllMessagesReadEnabled = function () {
        return this.sitesProvider.wsAvailableInCurrentSite('core_message_mark_all_messages_as_read');
    };
    /**
     * Returns whether or not we can count unread messages.
     *
     * @return {boolean} True if enabled, false otherwise.
     * @since  3.2
     */
    AddonMessagesProvider.prototype.isMessageCountEnabled = function () {
        return this.sitesProvider.wsAvailableInCurrentSite('core_message_get_unread_conversations_count');
    };
    /**
     * Returns whether or not the message preferences are enabled for the current site.
     *
     * @return {boolean} True if enabled, false otherwise.
     * @since  3.2
     */
    AddonMessagesProvider.prototype.isMessagePreferencesEnabled = function () {
        return this.sitesProvider.wsAvailableInCurrentSite('core_message_get_user_message_preferences');
    };
    /**
     * Returns whether or not messaging is enabled for a certain site.
     *
     * This could call a WS so do not abuse this method.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}   Resolved when enabled, otherwise rejected.
     */
    AddonMessagesProvider.prototype.isMessagingEnabledForSite = function (siteId) {
        return this.isPluginEnabled(siteId).then(function (enabled) {
            if (!enabled) {
                return Promise.reject(null);
            }
        });
    };
    /**
     * Returns whether or not the plugin is enabled in a certain site.
     *
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved with true if enabled, rejected or resolved with false otherwise.
     */
    AddonMessagesProvider.prototype.isPluginEnabled = function (siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.canUseAdvancedFeature('messaging');
        });
    };
    /**
     * Returns whether or not we can search messages.
     *
     * @return {boolean}
     * @since  3.2
     */
    AddonMessagesProvider.prototype.isSearchMessagesEnabled = function () {
        return this.sitesProvider.wsAvailableInCurrentSite('core_message_data_for_messagearea_search_messages');
    };
    /**
     * Mark message as read.
     *
     * @param   {number}  messageId   ID of message to mark as read
     * @returns {Promise<any>} Promise resolved with boolean marking success or not.
     */
    AddonMessagesProvider.prototype.markMessageRead = function (messageId) {
        var params = {
            messageid: messageId,
            timeread: this.timeUtils.timestamp()
        };
        return this.sitesProvider.getCurrentSite().write('core_message_mark_message_read', params);
    };
    /**
     * Mark all messages of a discussion as read.
     *
     * @param   {number}  userIdFrom  User Id for the sender.
     * @returns {Promise<any>} Promise resolved with boolean marking success or not.
     */
    AddonMessagesProvider.prototype.markAllMessagesRead = function (userIdFrom) {
        var params = {
            useridto: this.sitesProvider.getCurrentSiteUserId(),
            useridfrom: userIdFrom
        }, preSets = {
            typeExpected: 'boolean'
        };
        return this.sitesProvider.getCurrentSite().write('core_message_mark_all_messages_as_read', params, preSets);
    };
    /**
     * Remove a contact.
     *
     * @param {number} userId User ID of the person to remove.
     * @param {string} [siteId]  Site ID. If not defined, use current site.
     * @return {Promise<any>}  Resolved when done.
     */
    AddonMessagesProvider.prototype.removeContact = function (userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                userids: [userId]
            }, preSets = {
                responseExpected: false
            };
            return site.write('core_message_delete_contacts', params, preSets).then(function () {
                return _this.invalidateContactsCache(site.getId());
            });
        });
    };
    /**
     * Search for contacts.
     *
     * By default this only returns the first 100 contacts, but note that the WS can return thousands
     * of results which would take a while to process. The limit here is just a convenience to
     * prevent viewed to crash because too many DOM elements are created.
     *
     * @param {string} query The query string.
     * @param {number} [limit=100] The number of results to return, 0 for none.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}
     */
    AddonMessagesProvider.prototype.searchContacts = function (query, limit, siteId) {
        var _this = this;
        if (limit === void 0) { limit = 100; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var data = {
                searchtext: query,
                onlymycourses: 0
            }, preSets = {
                getFromCache: false // Always try to get updated data. If it fails, it will get it from cache.
            };
            return site.read('core_message_search_contacts', data, preSets).then(function (contacts) {
                if (limit && contacts.length > limit) {
                    contacts = contacts.splice(0, limit);
                }
                _this.userProvider.storeUsers(contacts);
                return contacts;
            });
        });
    };
    /**
     * Search for all the messges with a specific text.
     *
     * @param  {string} query        The query string
     * @param  {number} [userId]     The user ID. If not defined, current user.
     * @param  {number} [from=0]     Position of the first result to get. Defaults to 0.
     * @param  {number} [limit]      Number of results to get. Defaults to LIMIT_SEARCH_MESSAGES.
     * @param  {string} [siteId]     Site ID. If not defined, current site.
     * @return {Promise<any>}              Promise resolved with the results.
     */
    AddonMessagesProvider.prototype.searchMessages = function (query, userId, from, limit, siteId) {
        if (from === void 0) { from = 0; }
        if (limit === void 0) { limit = this.LIMIT_SEARCH_MESSAGES; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var param = {
                userid: userId || site.getUserId(),
                search: query,
                limitfrom: from,
                limitnum: limit
            }, preSets = {
                getFromCache: false // Always try to get updated data. If it fails, it will get it from cache.
            };
            return site.read('core_message_data_for_messagearea_search_messages', param, preSets).then(function (searchResults) {
                return searchResults.contacts;
            });
        });
    };
    /**
     * Send a message to someone.
     *
     * @param {number} userIdTo  User ID to send the message to.
     * @param {string} message   The message to send
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}       Promise resolved with:
     *                                 - sent (Boolean) True if message was sent to server, false if stored in device.
     *                                 - message (Object) If sent=false, contains the stored message.
     */
    AddonMessagesProvider.prototype.sendMessage = function (toUserId, message, siteId) {
        var _this = this;
        // Convenience function to store a message to be synchronized later.
        var storeOffline = function () {
            return _this.messagesOffline.saveMessage(toUserId, message, siteId).then(function (entry) {
                return {
                    sent: false,
                    message: entry
                };
            });
        };
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (!this.appProvider.isOnline()) {
            // App is offline, store the message.
            return storeOffline();
        }
        // Check if this conversation already has offline messages.
        // If so, store this message since they need to be sent in order.
        return this.messagesOffline.hasMessages(toUserId, siteId).catch(function () {
            // Error, it's safer to assume it has messages.
            return true;
        }).then(function (hasStoredMessages) {
            if (hasStoredMessages) {
                return storeOffline();
            }
            // Online and no messages stored. Send it to server.
            return _this.sendMessageOnline(toUserId, message).then(function () {
                return { sent: true };
            }).catch(function (error) {
                if (_this.utils.isWebServiceError(error)) {
                    // It's a WebService error, the user cannot send the message so don't store it.
                    return Promise.reject(error);
                }
                // Error sending message, store it to retry later.
                return storeOffline();
            });
        });
    };
    /**
     * Send a message to someone. It will fail if offline or cannot connect.
     *
     * @param {number} toUserId  User ID to send the message to.
     * @param {string} message   The message to send
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved if success, rejected if failure.
     */
    AddonMessagesProvider.prototype.sendMessageOnline = function (toUserId, message, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var messages = [
            {
                touserid: toUserId,
                text: message,
                textformat: 1
            }
        ];
        return this.sendMessagesOnline(messages, siteId).then(function (response) {
            if (response && response[0] && response[0].msgid === -1) {
                // There was an error, and it should be translated already.
                return _this.utils.createFakeWSError(response[0].errormessage);
            }
            return _this.invalidateDiscussionCache(toUserId, siteId).catch(function () {
                // Ignore errors.
            });
        });
    };
    /**
     * Send some messages. It will fail if offline or cannot connect.
     * IMPORTANT: Sending several messages at once for the same discussions can cause problems with display order,
     * since messages with same timecreated aren't ordered by ID.
     *
     * @param  {any} messages Messages to send. Each message must contain touserid, text and textformat.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved if success, rejected if failure. Promise resolved doesn't mean that messages
     *                           have been sent, the resolve param can contain errors for messages not sent.
     */
    AddonMessagesProvider.prototype.sendMessagesOnline = function (messages, siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var data = {
                messages: messages
            };
            return site.write('core_message_send_instant_messages', data);
        });
    };
    /**
     * Helper method to sort messages by time.
     *
     * @param {any} messages Array of messages containing the key 'timecreated'.
     * @return {any} Messages sorted with most recent last.
     */
    AddonMessagesProvider.prototype.sortMessages = function (messages) {
        return messages.sort(function (a, b) {
            // Pending messages last.
            if (a.pending && !b.pending) {
                return 1;
            }
            else if (!a.pending && b.pending) {
                return -1;
            }
            var timecreatedA = parseInt(a.timecreated, 10), timecreatedB = parseInt(b.timecreated, 10);
            if (timecreatedA == timecreatedB && a.id) {
                // Same time, sort by ID.
                return a.id >= b.id ? 1 : -1;
            }
            return timecreatedA >= timecreatedB ? 1 : -1;
        });
    };
    /**
     * Store the last received message if it's newer than the last stored.
     * @todo
     *
     * @param  {number} userIdFrom ID of the useridfrom retrieved, 0 for all users.
     * @param  {any} message       Last message received.
     * @param  {string} [siteId]   Site ID. If not defined, current site.
     * @return {Promise<any>}      Promise resolved when done.
     */
    AddonMessagesProvider.prototype.storeLastReceivedMessageIfNeeded = function (userIdFrom, message, siteId) {
        /*let component = mmaMessagesPushSimulationComponent;

        // Get the last received message.
        return $mmEmulatorHelper.getLastReceivedNotification(component, siteId).then((lastMessage) => {
            if (userIdFrom > 0 && (!message || !lastMessage)) {
                // Seeing a single discussion. No received message or cannot know if it really is the last received message. Stop.
                return;
            }

            if (message && lastMessage && message.timecreated <= lastMessage.timecreated) {
                // The message isn't newer than the stored message, don't store it.
                return;
            }

            return $mmEmulatorHelper.storeLastReceivedNotification(component, message, siteId);
        });*/
        return Promise.resolve();
    };
    /**
     * Store user data from contacts in local DB.
     *
     * @param {any} contactTypes List of contacts grouped in types.
     */
    AddonMessagesProvider.prototype.storeUsersFromAllContacts = function (contactTypes) {
        for (var x in contactTypes) {
            this.userProvider.storeUsers(contactTypes[x]);
        }
    };
    /**
     * Store user data from discussions in local DB.
     *
     * @param {any} discussions List of discussions.
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    AddonMessagesProvider.prototype.storeUsersFromDiscussions = function (discussions, siteId) {
        var users = [];
        for (var userId in discussions) {
            users.push({
                id: userId,
                fullname: discussions[userId].fullname,
                profileimageurl: discussions[userId].profileimageurl
            });
        }
        this.userProvider.storeUsers(users, siteId);
    };
    /**
     * Unblock a user.
     *
     * @param {number} userId User ID of the person to unblock.
     * @param {string} [siteId]  Site ID. If not defined, use current site.
     * @return {Promise<any>}  Resolved when done.
     */
    AddonMessagesProvider.prototype.unblockContact = function (userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                userids: [userId]
            }, preSets = {
                responseExpected: false
            };
            return site.write('core_message_unblock_contacts', params, preSets).then(function () {
                return _this.invalidateAllContactsCache(site.getUserId(), site.getId());
            });
        });
    };
    AddonMessagesProvider.NEW_MESSAGE_EVENT = 'addon_messages_new_message_event';
    AddonMessagesProvider.READ_CHANGED_EVENT = 'addon_messages_read_changed_event';
    AddonMessagesProvider.READ_CRON_EVENT = 'addon_messages_read_cron_event';
    AddonMessagesProvider.SPLIT_VIEW_LOAD_EVENT = 'addon_messages_split_view_load_event';
    AddonMessagesProvider.POLL_INTERVAL = 10000;
    AddonMessagesProvider.PUSH_SIMULATION_COMPONENT = 'AddonMessagesPushSimulation';
    AddonMessagesProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_4__core_user_providers_user__["a" /* CoreUserProvider */], __WEBPACK_IMPORTED_MODULE_5__messages_offline__["a" /* AddonMessagesOfflineProvider */],
            __WEBPACK_IMPORTED_MODULE_6__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_7__providers_utils_time__["a" /* CoreTimeUtilsProvider */]])
    ], AddonMessagesProvider);
    return AddonMessagesProvider;
}());

//# sourceMappingURL=messages.js.map

/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreMainMenuDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_events__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__classes_delegate__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_rxjs__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






/**
 * Service to interact with plugins to be shown in the main menu. Provides functions to register a plugin
 * and notify an update in the data.
 */
var CoreMainMenuDelegate = /** @class */ (function (_super) {
    __extends(CoreMainMenuDelegate, _super);
    function CoreMainMenuDelegate(loggerProvider, sitesProvider, eventsProvider) {
        var _this = _super.call(this, 'CoreMainMenuDelegate', loggerProvider, sitesProvider, eventsProvider) || this;
        _this.loggerProvider = loggerProvider;
        _this.sitesProvider = sitesProvider;
        _this.eventsProvider = eventsProvider;
        _this.handlers = {};
        _this.enabledHandlers = {};
        _this.loaded = false;
        _this.siteHandlers = new __WEBPACK_IMPORTED_MODULE_5_rxjs__["BehaviorSubject"]([]);
        _this.featurePrefix = '$mmSideMenuDelegate_';
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_1__providers_events__["a" /* CoreEventsProvider */].LOGOUT, _this.clearSiteHandlers.bind(_this));
        return _this;
    }
    /**
     * Check if handlers are loaded.
     *
     * @return {boolean} True if handlers are loaded, false otherwise.
     */
    CoreMainMenuDelegate.prototype.areHandlersLoaded = function () {
        return this.loaded;
    };
    /**
     * Clear current site handlers. Reserved for core use.
     */
    CoreMainMenuDelegate.prototype.clearSiteHandlers = function () {
        this.loaded = false;
        this.siteHandlers.next([]);
    };
    /**
     * Get the handlers for the current site.
     *
     * @return {Subject<CoreMainMenuHandlerToDisplay[]>} An observable that will receive the handlers.
     */
    CoreMainMenuDelegate.prototype.getHandlers = function () {
        return this.siteHandlers;
    };
    /**
     * Update handlers Data.
     */
    CoreMainMenuDelegate.prototype.updateData = function () {
        var handlersData = [];
        for (var name_1 in this.enabledHandlers) {
            var handler = this.enabledHandlers[name_1], data = handler.getDisplayData();
            handlersData.push({
                name: name_1,
                data: data,
                priority: handler.priority
            });
        }
        // Sort them by priority.
        handlersData.sort(function (a, b) {
            return b.priority - a.priority;
        });
        // Return only the display data.
        var displayData = handlersData.map(function (item) {
            item.data.name = item.name;
            return item.data;
        });
        this.loaded = true;
        this.siteHandlers.next(displayData);
    };
    CoreMainMenuDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_1__providers_events__["a" /* CoreEventsProvider */]])
    ], CoreMainMenuDelegate);
    return CoreMainMenuDelegate;
}(__WEBPACK_IMPORTED_MODULE_2__classes_delegate__["a" /* CoreDelegate */]));

//# sourceMappingURL=delegate.js.map

/***/ }),
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreConfigProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__app__ = __webpack_require__(12);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Factory to provide access to dynamic and permanent config and settings.
 * It should not be abused into a temporary storage.
 */
var CoreConfigProvider = /** @class */ (function () {
    function CoreConfigProvider(appProvider) {
        this.TABLE_NAME = 'core_config';
        this.tableSchema = {
            name: this.TABLE_NAME,
            columns: [
                {
                    name: 'name',
                    type: 'TEXT',
                    unique: true,
                    notNull: true
                },
                {
                    name: 'value'
                }
            ]
        };
        this.appDB = appProvider.getDB();
        this.appDB.createTableFromSchema(this.tableSchema);
    }
    /**
     * Deletes an app setting.
     *
     * @param {string} name The config name.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreConfigProvider.prototype.delete = function (name) {
        return this.appDB.deleteRecords(this.TABLE_NAME, { name: name });
    };
    /**
     * Get an app setting.
     *
     * @param {string} name The config name.
     * @param {any} [defaultValue] Default value to use if the entry is not found.
     * @return {Promise<any>} Resolves upon success along with the config data. Reject on failure.
     */
    CoreConfigProvider.prototype.get = function (name, defaultValue) {
        return this.appDB.getRecord(this.TABLE_NAME, { name: name }).then(function (entry) {
            return entry.value;
        }).catch(function (error) {
            if (typeof defaultValue != 'undefined') {
                return defaultValue;
            }
            return Promise.reject(error);
        });
    };
    /**
     * Set an app setting.
     *
     * @param {string} name The config name.
     * @param {boolean|number|string} value The config value. Can only store primitive values, not objects.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreConfigProvider.prototype.set = function (name, value) {
        return this.appDB.insertOrUpdateRecord(this.TABLE_NAME, { name: name, value: value }, { name: name });
    };
    CoreConfigProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__app__["a" /* CoreAppProvider */]])
    ], CoreConfigProvider);
    return CoreConfigProvider;
}());

//# sourceMappingURL=config.js.map

/***/ }),
/* 76 */,
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreLocalNotificationsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_local_notifications__ = __webpack_require__(161);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__config__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__utils_text__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__core_constants__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_rxjs__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_rxjs__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};











/*
 * Generated class for the LocalNotificationsProvider provider.
 *
 * See https://angular.io/guide/dependency-injection for more info on providers
 * and Angular DI.
 *
 * @todo We might have to translate the old component name to the new one.
 *       Otherwise the unique ID of local notifications could change.
*/
var CoreLocalNotificationsProvider = /** @class */ (function () {
    function CoreLocalNotificationsProvider(logger, localNotifications, platform, appProvider, utils, configProvider, domUtils, textUtils) {
        this.localNotifications = localNotifications;
        this.platform = platform;
        this.appProvider = appProvider;
        this.utils = utils;
        this.configProvider = configProvider;
        this.domUtils = domUtils;
        this.textUtils = textUtils;
        // Variables for the database.
        this.SITES_TABLE = 'notification_sites'; // Store to asigne unique codes to each site.
        this.COMPONENTS_TABLE = 'notification_components'; // Store to asigne unique codes to each component.
        this.TRIGGERED_TABLE = 'notifications_triggered'; // Store to prevent re-triggering notifications.
        this.tablesSchema = [
            {
                name: this.SITES_TABLE,
                columns: [
                    {
                        name: 'id',
                        type: 'TEXT',
                        primaryKey: true
                    },
                    {
                        name: 'code',
                        type: 'INTEGER',
                        notNull: true
                    }
                ]
            },
            {
                name: this.COMPONENTS_TABLE,
                columns: [
                    {
                        name: 'id',
                        type: 'TEXT',
                        primaryKey: true
                    },
                    {
                        name: 'code',
                        type: 'INTEGER',
                        notNull: true
                    }
                ]
            },
            {
                name: this.TRIGGERED_TABLE,
                columns: [
                    {
                        name: 'id',
                        type: 'INTEGER',
                        primaryKey: true
                    },
                    {
                        name: 'at',
                        type: 'INTEGER',
                        notNull: true
                    }
                ]
            }
        ];
        this.codes = {};
        this.codeRequestsQueue = {};
        this.observables = {};
        this.logger = logger.getInstance('CoreLocalNotificationsProvider');
        this.appDB = appProvider.getDB();
        this.appDB.createTablesFromSchema(this.tablesSchema);
    }
    /**
     * Cancel a local notification.
     *
     * @param {number} id Notification id.
     * @param {string} component Component of the notification.
     * @param {string} siteId Site ID.
     * @return {Promise<any>} Promise resolved when the notification is cancelled.
     */
    CoreLocalNotificationsProvider.prototype.cancel = function (id, component, siteId) {
        var _this = this;
        return this.getUniqueNotificationId(id, component, siteId).then(function (uniqueId) {
            return _this.localNotifications.cancel(uniqueId);
        });
    };
    /**
     * Cancel all the scheduled notifications belonging to a certain site.
     *
     * @param {string} siteId Site ID.
     * @return {Promise<any>} Promise resolved when the notifications are cancelled.
     */
    CoreLocalNotificationsProvider.prototype.cancelSiteNotifications = function (siteId) {
        var _this = this;
        if (!this.isAvailable()) {
            return Promise.resolve();
        }
        else if (!siteId) {
            return Promise.reject(null);
        }
        return this.localNotifications.getAllScheduled().then(function (scheduled) {
            var ids = [];
            scheduled.forEach(function (notif) {
                if (typeof notif.data == 'string') {
                    notif.data = _this.textUtils.parseJSON(notif.data);
                }
                if (typeof notif.data == 'object' && notif.data.siteId === siteId) {
                    ids.push(notif.id);
                }
            });
            return _this.localNotifications.cancel(ids);
        });
    };
    /**
     * Get a code to create unique notifications. If there's no code assigned, create a new one.
     *
     * @param {string} table Table to search in local DB.
     * @param {string} id ID of the element to get its code.
     * @return {Promise<number>} Promise resolved when the code is retrieved.
     */
    CoreLocalNotificationsProvider.prototype.getCode = function (table, id) {
        var _this = this;
        var key = table + '#' + id;
        // Check if the code is already in memory.
        if (typeof this.codes[key] != 'undefined') {
            return Promise.resolve(this.codes[key]);
        }
        // Check if we already have a code stored for that ID.
        return this.appDB.getRecord(table, { id: id }).then(function (entry) {
            _this.codes[key] = entry.code;
            return entry.code;
        }).catch(function () {
            // No code stored for that ID. Create a new code for it.
            return _this.appDB.getRecords(table, undefined, 'code DESC').then(function (entries) {
                var newCode = 0;
                if (entries.length > 0) {
                    newCode = entries[0].code + 1;
                }
                return _this.appDB.insertRecord(table, { id: id, code: newCode }).then(function () {
                    _this.codes[key] = newCode;
                    return newCode;
                });
            });
        });
    };
    /**
     * Get a notification component code to be used.
     * If it's the first time this component is used to send notifications, create a new code for it.
     *
     * @param {string} component Component name.
     * @return {Promise<number>} Promise resolved when the component code is retrieved.
     */
    CoreLocalNotificationsProvider.prototype.getComponentCode = function (component) {
        return this.requestCode(this.COMPONENTS_TABLE, component);
    };
    /**
     * Get a site code to be used.
     * If it's the first time this site is used to send notifications, create a new code for it.
     *
     * @param {string} siteId Site ID.
     * @return {Promise<number>} Promise resolved when the site code is retrieved.
     */
    CoreLocalNotificationsProvider.prototype.getSiteCode = function (siteId) {
        return this.requestCode(this.SITES_TABLE, siteId);
    };
    /**
     * Create a unique notification ID, trying to prevent collisions. Generated ID must be a Number (Android).
     * The generated ID shouldn't be higher than 2147483647 or it's going to cause problems in Android.
     * This function will prevent collisions and keep the number under Android limit if:
     *     -User has used less than 21 sites.
     *     -There are less than 11 components.
     *     -The notificationId passed as parameter is lower than 10000000.
     *
     * @param {number} notificationId Notification ID.
     * @param {string} component Component triggering the notification.
     * @param {string} siteId Site ID.
     * @return {Promise<number>} Promise resolved when the notification ID is generated.
     */
    CoreLocalNotificationsProvider.prototype.getUniqueNotificationId = function (notificationId, component, siteId) {
        var _this = this;
        if (!siteId || !component) {
            return Promise.reject(null);
        }
        return this.getSiteCode(siteId).then(function (siteCode) {
            return _this.getComponentCode(component).then(function (componentCode) {
                // We use the % operation to keep the number under Android's limit.
                return (siteCode * 100000000 + componentCode * 10000000 + notificationId) % 2147483647;
            });
        });
    };
    /**
     * Returns whether local notifications plugin is installed.
     *
     * @return {boolean} Whether local notifications plugin is installed.
     */
    CoreLocalNotificationsProvider.prototype.isAvailable = function () {
        var win = window;
        return this.appProvider.isDesktop() || !!(win.plugin && win.plugin.notification && win.plugin.notification.local);
    };
    /**
     * Check if a notification has been triggered with the same trigger time.
     *
     * @param {CoreILocalNotification} notification Notification to check.
     * @return {Promise<any>} Promise resolved with a boolean indicating if promise is triggered (true) or not.
     */
    CoreLocalNotificationsProvider.prototype.isTriggered = function (notification) {
        return this.appDB.getRecord(this.TRIGGERED_TABLE, { id: notification.id }).then(function (stored) {
            return stored.at === notification.at.getTime() / 1000;
        }).catch(function () {
            return false;
        });
    };
    /**
     * Notify notification click to observers. Only the observers with the same component as the notification will be notified.
     *
     * @param {any} data Data received by the notification.
     */
    CoreLocalNotificationsProvider.prototype.notifyClick = function (data) {
        var component = data.component;
        if (component) {
            if (this.observables[component]) {
                this.observables[component].next(data);
            }
        }
    };
    /**
     * Process the next request in queue.
     */
    CoreLocalNotificationsProvider.prototype.processNextRequest = function () {
        var _this = this;
        var nextKey = Object.keys(this.codeRequestsQueue)[0];
        var request, promise;
        if (typeof nextKey == 'undefined') {
            // No more requests in queue, stop.
            return;
        }
        request = this.codeRequestsQueue[nextKey];
        // Check if request is valid.
        if (typeof request == 'object' && typeof request.table != 'undefined' && typeof request.id != 'undefined') {
            // Get the code and resolve/reject all the promises of this request.
            promise = this.getCode(request.table, request.id).then(function (code) {
                request.promises.forEach(function (p) {
                    p.resolve(code);
                });
            }).catch(function (error) {
                request.promises.forEach(function (p) {
                    p.reject(error);
                });
            });
        }
        else {
            promise = Promise.resolve();
        }
        // Once this item is treated, remove it and process next.
        promise.finally(function () {
            delete _this.codeRequestsQueue[nextKey];
            _this.processNextRequest();
        });
    };
    /**
     * Register an observer to be notified when a notification belonging to a certain component is clicked.
     *
     * @param {string} component Component to listen notifications for.
     * @param {Function} callback Function to call with the data received by the notification.
     * @return {any} Object with an "off" property to stop listening for clicks.
     */
    CoreLocalNotificationsProvider.prototype.registerClick = function (component, callback) {
        var _this = this;
        this.logger.debug("Register observer '" + component + "' for notification click.");
        if (typeof this.observables[component] == 'undefined') {
            // No observable for this component, create a new one.
            this.observables[component] = new __WEBPACK_IMPORTED_MODULE_10_rxjs__["Subject"]();
        }
        this.observables[component].subscribe(callback);
        return {
            off: function () {
                _this.observables[component].unsubscribe(callback);
            }
        };
    };
    /**
     * Remove a notification from triggered store.
     *
     * @param {number} id Notification ID.
     * @return {Promise<any>} Promise resolved when it is removed.
     */
    CoreLocalNotificationsProvider.prototype.removeTriggered = function (id) {
        return this.appDB.deleteRecords(this.TRIGGERED_TABLE, { id: id });
    };
    /**
     * Request a unique code. The request will be added to the queue and the queue is going to be started if it's paused.
     *
     * @param {string} table Table to search in local DB.
     * @param {string} id ID of the element to get its code.
     * @return {Promise}      Promise resolved when the code is retrieved.
     */
    CoreLocalNotificationsProvider.prototype.requestCode = function (table, id) {
        var deferred = this.utils.promiseDefer(), key = table + '#' + id, isQueueEmpty = Object.keys(this.codeRequestsQueue).length == 0;
        if (typeof this.codeRequestsQueue[key] != 'undefined') {
            // There's already a pending request for this store and ID, add the promise to it.
            this.codeRequestsQueue[key].promises.push(deferred);
        }
        else {
            // Add a pending request to the queue.
            this.codeRequestsQueue[key] = {
                table: table,
                id: id,
                promises: [deferred]
            };
        }
        if (isQueueEmpty) {
            this.processNextRequest();
        }
        return deferred.promise;
    };
    /**
     * Reschedule all notifications that are already scheduled.
     *
     * @return {Promise<any>} Promise resolved when all notifications have been rescheduled.
     */
    CoreLocalNotificationsProvider.prototype.rescheduleAll = function () {
        var _this = this;
        // Get all the scheduled notifications.
        return this.localNotifications.getAllScheduled().then(function (notifications) {
            var promises = [];
            notifications.forEach(function (notification) {
                // Convert some properties to the needed types.
                notification.at = new Date(notification.at * 1000);
                notification.data = notification.data ? _this.textUtils.parseJSON(notification.data, {}) : {};
                promises.push(_this.scheduleNotification(notification));
            });
            return Promise.all(promises);
        });
    };
    /**
     * Schedule a local notification.
     *
     * @param {CoreILocalNotification} notification Notification to schedule. Its ID should be lower than 10000000 and it should
     *                                              be unique inside its component and site.
     * @param {string} component Component triggering the notification. It is used to generate unique IDs.
     * @param {string} siteId Site ID.
     * @return {Promise<any>} Promise resolved when the notification is scheduled.
     */
    CoreLocalNotificationsProvider.prototype.schedule = function (notification, component, siteId) {
        var _this = this;
        return this.getUniqueNotificationId(notification.id, component, siteId).then(function (uniqueId) {
            notification.id = uniqueId;
            notification.data = notification.data || {};
            notification.data.component = component;
            notification.data.siteId = siteId;
            if (_this.platform.is('android')) {
                notification.icon = notification.icon || 'res://icon';
                notification.smallIcon = notification.smallIcon || 'res://icon';
                notification.led = notification.led || 'FF9900';
                notification.ledOnTime = notification.ledOnTime || 1000;
                notification.ledOffTime = notification.ledOffTime || 1000;
            }
            return _this.scheduleNotification(notification);
        });
    };
    /**
     * Helper function to schedule a notification object if it hasn't been triggered already.
     *
     * @param {CoreILocalNotification} notification Notification to schedule.
     * @return {Promise<any>} Promise resolved when scheduled.
     */
    CoreLocalNotificationsProvider.prototype.scheduleNotification = function (notification) {
        var _this = this;
        // Check if the notification has been triggered already.
        return this.isTriggered(notification).then(function (triggered) {
            if (!triggered) {
                // Check if sound is enabled for notifications.
                return _this.configProvider.get(__WEBPACK_IMPORTED_MODULE_9__core_constants__["a" /* CoreConstants */].SETTINGS_NOTIFICATION_SOUND, true).then(function (soundEnabled) {
                    if (!soundEnabled) {
                        notification.sound = null;
                    }
                    else {
                        delete notification.sound; // Use default value.
                    }
                    // Remove from triggered, since the notification could be in there with a different time.
                    _this.removeTriggered(notification.id);
                    _this.localNotifications.schedule(notification);
                });
            }
        });
    };
    /**
     * Show an in app notification popover.
     *
     * @param {CoreILocalNotification} notification Notification.
     */
    CoreLocalNotificationsProvider.prototype.showNotificationPopover = function (notification) {
        // @todo Improve it. For now, show Toast.
        if (!notification || !notification.title || !notification.text) {
            // Invalid data.
            return;
        }
        this.domUtils.showToast(notification.text, false, 4000);
    };
    /**
     * Function to call when a notification is triggered. Stores the notification so it's not scheduled again unless the
     * time is changed.
     *
     * @param {CoreILocalNotification} notification Triggered notification.
     * @return {Promise<any>} Promise resolved when stored, rejected otherwise.
     */
    CoreLocalNotificationsProvider.prototype.trigger = function (notification) {
        if (this.platform.is('ios') && this.platform.version().num >= 10) {
            // In iOS10 show in app notification.
            this.showNotificationPopover(notification);
        }
        var entry = {
            id: notification.id,
            at: parseInt(notification.at, 10)
        };
        return this.appDB.insertOrUpdateRecord(this.TRIGGERED_TABLE, entry, { id: notification.id });
    };
    CoreLocalNotificationsProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__ionic_native_local_notifications__["a" /* LocalNotifications */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */],
            __WEBPACK_IMPORTED_MODULE_3__app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_8__utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_4__config__["a" /* CoreConfigProvider */],
            __WEBPACK_IMPORTED_MODULE_6__utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_7__utils_text__["a" /* CoreTextUtilsProvider */]])
    ], CoreLocalNotificationsProvider);
    return CoreLocalNotificationsProvider;
}());

//# sourceMappingURL=local-notifications.js.map

/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreGradesProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_courses_providers_courses__ = __webpack_require__(31);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Service to provide grade functionalities.
 */
var CoreGradesProvider = /** @class */ (function () {
    function CoreGradesProvider(logger, sitesProvider, coursesProvider) {
        this.sitesProvider = sitesProvider;
        this.coursesProvider = coursesProvider;
        this.ROOT_CACHE_KEY = 'mmGrades:';
        this.logger = logger.getInstance('CoreGradesProvider');
    }
    /**
     * Get cache key for grade table data WS calls.
     *
     * @param {number} courseId ID of the course to get the grades from.
     * @param {number} userId   ID of the user to get the grades from.
     * @return {string}         Cache key.
     */
    CoreGradesProvider.prototype.getCourseGradesCacheKey = function (courseId, userId) {
        return this.getCourseGradesPrefixCacheKey(courseId) + userId;
    };
    /**
     * Get cache key for grade items data WS calls.
     *
     * @param {number} courseId     ID of the course to get the grades from.
     * @param {number} userId       ID of the user to get the grades from.
     * @param {number} [groupId]    ID of the group to get the grades from. Default: 0.
     * @return {string}         Cache key.
     */
    CoreGradesProvider.prototype.getCourseGradesItemsCacheKey = function (courseId, userId, groupId) {
        groupId = groupId || 0;
        return this.getCourseGradesPrefixCacheKey(courseId) + userId + ':' + groupId;
    };
    /**
     * Get prefix cache key for grade table data WS calls.
     *
     * @param {number} courseId ID of the course to get the grades from.
     * @return {string}         Cache key.
     */
    CoreGradesProvider.prototype.getCourseGradesPrefixCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'items:' + courseId + ':';
    };
    /**
     * Get cache key for courses grade WS calls.
     *
     * @return {string}   Cache key.
     */
    CoreGradesProvider.prototype.getCoursesGradesCacheKey = function () {
        return this.ROOT_CACHE_KEY + 'coursesgrades';
    };
    /**
     * Get the grade items for a certain module. Keep in mind that may have more than one item to include outcomes and scales.
     * Fallback function only used if 'gradereport_user_get_grade_items' WS is not avalaible Moodle < 3.2.
     *
     * @param  {number}  courseId             ID of the course to get the grades from.
     * @param  {number}  [userId]             ID of the user to get the grades from. If not defined use site's current user.
     * @param  {number}  [groupId]            ID of the group to get the grades from. Not used for old gradebook table.
     * @param  {string}  [siteId]             Site ID. If not defined, current site.
     * @param  {boolean} [ignoreCache=false]  True if it should ignore cached data (it will always fail in offline or server down).
     * @return {Promise<any>}                Promise to be resolved when the grades are retrieved.
     */
    CoreGradesProvider.prototype.getGradeItems = function (courseId, userId, groupId, siteId, ignoreCache) {
        var _this = this;
        if (ignoreCache === void 0) { ignoreCache = false; }
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return _this.isGradeItemsAvalaible(siteId).then(function (enabled) {
                if (enabled) {
                    return _this.getCourseGradesItems(courseId, userId, groupId, siteId, ignoreCache).catch(function () {
                        // FallBack while solving MDL-57255.
                        return _this.getCourseGradesTable(courseId, userId, siteId, ignoreCache);
                    });
                }
                else {
                    return _this.getCourseGradesTable(courseId, userId, siteId, ignoreCache);
                }
            });
        });
    };
    /**
     * Get the grade items for a certain course.
     *
     * @param  {number}  courseId             ID of the course to get the grades from.
     * @param  {number}  [userId]             ID of the user to get the grades from.
     * @param  {number}  [groupId]            ID of the group to get the grades from. Default 0.
     * @param  {string}  [siteId]             Site ID. If not defined, current site.
     * @param  {boolean} [ignoreCache=false]  True if it should ignore cached data (it will always fail in offline or server down).
     * @return {Promise<any>}                      Promise to be resolved when the grades table is retrieved.
     */
    CoreGradesProvider.prototype.getCourseGradesItems = function (courseId, userId, groupId, siteId, ignoreCache) {
        var _this = this;
        if (ignoreCache === void 0) { ignoreCache = false; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            groupId = groupId || 0;
            _this.logger.debug("Get grades for course '" + courseId + "' and user '" + userId + "'");
            var data = {
                courseid: courseId,
                userid: userId,
                groupid: groupId
            }, preSets = {
                cacheKey: _this.getCourseGradesItemsCacheKey(courseId, userId, groupId)
            };
            if (ignoreCache) {
                preSets['getFromCache'] = 0;
                preSets['emergencyCache'] = 0;
            }
            return site.read('gradereport_user_get_grade_items', data, preSets).then(function (grades) {
                if (grades && grades.usergrades && grades.usergrades[0]) {
                    return grades.usergrades[0].gradeitems;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get the grades for a certain course.
     *
     * @param  {number}  courseId             ID of the course to get the grades from.
     * @param  {number}  [userId]             ID of the user to get the grades from.
     * @param  {string}  [siteId]             Site ID. If not defined, current site.
     * @param  {boolean} [ignoreCache=false]  True if it should ignore cached data (it will always fail in offline or server down).
     * @return {Promise<any>}                      Promise to be resolved when the grades table is retrieved.
     */
    CoreGradesProvider.prototype.getCourseGradesTable = function (courseId, userId, siteId, ignoreCache) {
        var _this = this;
        if (ignoreCache === void 0) { ignoreCache = false; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            _this.logger.debug("Get grades for course '" + courseId + "' and user '" + userId + "'");
            var data = {
                courseid: courseId,
                userid: userId
            }, preSets = {
                cacheKey: _this.getCourseGradesCacheKey(courseId, userId)
            };
            if (ignoreCache) {
                preSets['getFromCache'] = 0;
                preSets['emergencyCache'] = 0;
            }
            return site.read('gradereport_user_get_grades_table', data, preSets).then(function (table) {
                if (table && table.tables && table.tables[0]) {
                    return table.tables[0];
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get the grades for a certain course.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}   Promise to be resolved when the grades are retrieved.
     */
    CoreGradesProvider.prototype.getCoursesGrades = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            _this.logger.debug('Get course grades');
            var preSets = {
                cacheKey: _this.getCoursesGradesCacheKey()
            };
            return site.read('gradereport_overview_get_course_grades', undefined, preSets).then(function (data) {
                if (data && data.grades) {
                    return data.grades;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Invalidates grade table data WS calls.
     *
     * @param {number} courseId Course ID.
     * @param {number} [userId]   User ID.
     * @param {string} [siteId]   Site id (empty for current site).
     * @return {Promise<any>}        Promise resolved when the data is invalidated.
     */
    CoreGradesProvider.prototype.invalidateCourseGradesData = function (courseId, userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(_this.getCourseGradesCacheKey(courseId, userId));
        });
    };
    /**
     * Invalidates courses grade data WS calls.
     *
     * @param {string} [siteId]   Site id (empty for current site).
     * @return {Promise<any>}     Promise resolved when the data is invalidated.
     */
    CoreGradesProvider.prototype.invalidateCoursesGradesData = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getCoursesGradesCacheKey());
        });
    };
    /**
     * Invalidates courses grade items data WS calls.
     *
     * @param {number} courseId     ID of the course to get the grades from.
     * @param {number} userId       ID of the user to get the grades from.
     * @param {number} [groupId]    ID of the group to get the grades from. Default: 0.
     * @param {string} [siteId]     Site id (empty for current site).
     * @return {Promise<any>}     Promise resolved when the data is invalidated.
     */
    CoreGradesProvider.prototype.invalidateCourseGradesItemsData = function (courseId, userId, groupId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getCourseGradesItemsCacheKey(courseId, userId, groupId));
        });
    };
    /**
     * Returns whether or not the plugin is enabled for a certain site.
     *
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>}  Resolve with true if plugin is enabled, false otherwise.
     * @since  Moodle 3.2
     */
    CoreGradesProvider.prototype.isCourseGradesEnabled = function (siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            if (!site.wsAvailable('gradereport_overview_get_course_grades')) {
                return false;
            }
            // Now check that the configurable mygradesurl is pointing to the gradereport_overview plugin.
            var url = site.getStoredConfig('mygradesurl') || '';
            return url.indexOf('/grade/report/overview/') !== -1;
        });
    };
    /**
     * Returns whether or not the grade addon is enabled for a certain course.
     *
     * @param {number} courseId  Course ID.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promisee<boolean>} Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    CoreGradesProvider.prototype.isPluginEnabledForCourse = function (courseId, siteId) {
        if (!courseId) {
            return Promise.reject(null);
        }
        return this.coursesProvider.getUserCourse(courseId, true, siteId).then(function (course) {
            return !(course && typeof course.showgrades != 'undefined' && course.showgrades == 0);
        });
    };
    /**
     * Returns whether or not WS Grade Items is avalaible.
     *
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>}         True if ws is avalaible, false otherwise.
     * @since  Moodle 3.2
     */
    CoreGradesProvider.prototype.isGradeItemsAvalaible = function (siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.wsAvailable('gradereport_user_get_grade_items');
        });
    };
    /**
     * Log Course grades view in Moodle.
     *
     * @param  {number}  courseId Course ID.
     * @param  {number}  userId   User ID.
     * @return {Promise<any>}     Promise resolved when done.
     */
    CoreGradesProvider.prototype.logCourseGradesView = function (courseId, userId) {
        userId = userId || this.sitesProvider.getCurrentSiteUserId();
        return this.sitesProvider.getCurrentSite().write('gradereport_user_view_grade_report', {
            courseid: courseId,
            userid: userId
        });
    };
    /**
     * Log Courses grades view in Moodle.
     *
     * @param  {number}  [courseId] Course ID. If not defined, site Home ID.
     * @return {Promise<any>}     Promise resolved when done.
     */
    CoreGradesProvider.prototype.logCoursesGradesView = function (courseId) {
        if (!courseId) {
            courseId = this.sitesProvider.getCurrentSiteHomeId();
        }
        return this.sitesProvider.getCurrentSite().write('gradereport_overview_view_grade_report', {
            courseid: courseId
        });
    };
    CoreGradesProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_3__core_courses_providers_courses__["a" /* CoreCoursesProvider */]])
    ], CoreGradesProvider);
    return CoreGradesProvider;
}());

//# sourceMappingURL=grades.js.map

/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseFormatDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_events__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__course__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__default_format__ = __webpack_require__(594);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__classes_delegate__ = __webpack_require__(69);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};







/**
 * Service to interact with course formats. Provides the functions to register and interact with the addons.
 */
var CoreCourseFormatDelegate = /** @class */ (function (_super) {
    __extends(CoreCourseFormatDelegate, _super);
    function CoreCourseFormatDelegate(loggerProvider, sitesProvider, eventsProvider, defaultHandler) {
        var _this = _super.call(this, 'CoreCoursesCourseFormatDelegate', loggerProvider, sitesProvider, eventsProvider) || this;
        _this.sitesProvider = sitesProvider;
        _this.defaultHandler = defaultHandler;
        _this.handlers = {}; // All registered handlers.
        _this.enabledHandlers = {}; // Handlers enabled for the current site.
        _this.featurePrefix = 'CoreCourseFormatHandler_';
        return _this;
    }
    /**
     * Whether it allows seeing all sections at the same time. Defaults to true.
     *
     * @param {any} course The course to check.
     * @return {boolean} Whether it allows seeing all sections at the same time.
     */
    CoreCourseFormatDelegate.prototype.canViewAllSections = function (course) {
        return this.executeFunction(course.format, 'canViewAllSections', [course]);
    };
    /**
     * Whether the option to enable section/module download should be displayed. Defaults to true.
     *
     * @param {any} course The course to check.
     * @return {boolean} Whether the option to enable section/module download should be displayed
     */
    CoreCourseFormatDelegate.prototype.displayEnableDownload = function (course) {
        return this.executeFunction(course.format, 'displayEnableDownload', [course]);
    };
    /**
     * Whether the default section selector should be displayed. Defaults to true.
     *
     * @param {any} course The course to check.
     * @return {boolean} Whether the section selector should be displayed.
     */
    CoreCourseFormatDelegate.prototype.displaySectionSelector = function (course) {
        return this.executeFunction(course.format, 'displaySectionSelector', [course]);
    };
    /**
     * Execute a certain function in a course format handler.
     * If the handler isn't found or function isn't defined, call the same function in the default handler.
     *
     * @param {string} format The format name.
     * @param {string} fnName Name of the function to execute.
     * @param {any[]} params Parameters to pass to the function.
     * @return {any} Function returned value or default value.
     */
    CoreCourseFormatDelegate.prototype.executeFunction = function (format, fnName, params) {
        var handler = this.enabledHandlers[format];
        if (handler && handler[fnName]) {
            return handler[fnName].apply(handler, params);
        }
        else if (this.defaultHandler[fnName]) {
            return this.defaultHandler[fnName].apply(this.defaultHandler, params);
        }
    };
    /**
     * Get the component to use to display all sections in a course.
     *
     * @param {Injector} injector Injector.
     * @param {any} course The course to render.
     * @return {Promise<any>} Promise resolved with component to use, undefined if not found.
     */
    CoreCourseFormatDelegate.prototype.getAllSectionsComponent = function (injector, course) {
        var _this = this;
        return Promise.resolve(this.executeFunction(course.format, 'getAllSectionsComponent', [injector, course])).catch(function (e) {
            _this.logger.error('Error getting all sections component', e);
        });
    };
    /**
     * Get the component to use to display a course format.
     *
     * @param {Injector} injector Injector.
     * @param {any} course The course to render.
     * @return {Promise<any>} Promise resolved with component to use, undefined if not found.
     */
    CoreCourseFormatDelegate.prototype.getCourseFormatComponent = function (injector, course) {
        var _this = this;
        return Promise.resolve(this.executeFunction(course.format, 'getCourseFormatComponent', [injector, course])).catch(function (e) {
            _this.logger.error('Error getting course format component', e);
        });
    };
    /**
     * Get the component to use to display the course summary in the default course format.
     *
     * @param {Injector} injector Injector.
     * @param {any} course The course to render.
     * @return {Promise<any>} Promise resolved with component to use, undefined if not found.
     */
    CoreCourseFormatDelegate.prototype.getCourseSummaryComponent = function (injector, course) {
        var _this = this;
        return Promise.resolve(this.executeFunction(course.format, 'getCourseSummaryComponent', [injector, course])).catch(function (e) {
            _this.logger.error('Error getting course summary component', e);
        });
    };
    /**
     * Given a course, return the title to use in the course page.
     *
     * @param {any} course The course to get the title.
     * @param {any[]} [sections] List of sections.
     * @return {string} Course title.
     */
    CoreCourseFormatDelegate.prototype.getCourseTitle = function (course, sections) {
        return this.executeFunction(course.format, 'getCourseTitle', [course, sections]);
    };
    /**
     * Given a course and a list of sections, return the current section that should be displayed first.
     *
     * @param {any} course The course to get the title.
     * @param {any[]} sections List of sections.
     * @return {Promise<any>} Promise resolved with current section.
     */
    CoreCourseFormatDelegate.prototype.getCurrentSection = function (course, sections) {
        // Convert the result to a Promise if it isn't.
        return Promise.resolve(this.executeFunction(course.format, 'getCurrentSection', [course, sections])).catch(function () {
            // This function should never fail. Just return the first section.
            if (sections[0].id != __WEBPACK_IMPORTED_MODULE_4__course__["a" /* CoreCourseProvider */].ALL_SECTIONS_ID) {
                return sections[0];
            }
            return sections[1];
        });
    };
    /**
     * Get the component to use to display the section selector inside the default course format.
     *
     * @param {Injector} injector Injector.
     * @param {any} course The course to render.
     * @return {Promise<any>} Promise resolved with component to use, undefined if not found.
     */
    CoreCourseFormatDelegate.prototype.getSectionSelectorComponent = function (injector, course) {
        var _this = this;
        return Promise.resolve(this.executeFunction(course.format, 'getSectionSelectorComponent', [injector, course]))
            .catch(function (e) {
            _this.logger.error('Error getting section selector component', e);
        });
    };
    /**
     * Get the component to use to display a single section. This component will only be used if the user is viewing
     * a single section. If all the sections are displayed at once then it won't be used.
     *
     * @param {Injector} injector Injector.
     * @param {any} course The course to render.
     * @return {Promise<any>} Promise resolved with component to use, undefined if not found.
     */
    CoreCourseFormatDelegate.prototype.getSingleSectionComponent = function (injector, course) {
        var _this = this;
        return Promise.resolve(this.executeFunction(course.format, 'getSingleSectionComponent', [injector, course])).catch(function (e) {
            _this.logger.error('Error getting single section component', e);
        });
    };
    /**
     * Invalidate the data required to load the course format.
     *
     * @param {any} course The course to get the title.
     * @param {any[]} sections List of sections.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCourseFormatDelegate.prototype.invalidateData = function (course, sections) {
        return this.executeFunction(course.format, 'invalidateData', [course, sections]);
    };
    /**
     * Open a course.
     *
     * @param {NavController} navCtrl The NavController instance to use.
     * @param {any} course The course to open. It should contain a "format" attribute.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseFormatDelegate.prototype.openCourse = function (navCtrl, course) {
        if (this.enabledHandlers[course.format] && this.enabledHandlers[course.format].openCourse) {
            return this.enabledHandlers[course.format].openCourse(navCtrl, course);
        }
        return navCtrl.push('CoreCourseSectionPage', { course: course });
    };
    CoreCourseFormatDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_1__providers_events__["a" /* CoreEventsProvider */],
            __WEBPACK_IMPORTED_MODULE_5__default_format__["a" /* CoreCourseFormatDefaultHandler */]])
    ], CoreCourseFormatDelegate);
    return CoreCourseFormatDelegate;
}(__WEBPACK_IMPORTED_MODULE_6__classes_delegate__["a" /* CoreDelegate */]));

//# sourceMappingURL=format-delegate.js.map

/***/ }),
/* 80 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreUserProfileFieldDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__classes_delegate__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_events__ = __webpack_require__(15);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Service to interact with user profile fields. Provides functions to register a plugin.
 */
var CoreUserProfileFieldDelegate = /** @class */ (function (_super) {
    __extends(CoreUserProfileFieldDelegate, _super);
    function CoreUserProfileFieldDelegate(loggerProvider, sitesProvider, eventsProvider) {
        var _this = _super.call(this, 'CoreUserProfileFieldDelegate', loggerProvider, sitesProvider, eventsProvider) || this;
        _this.loggerProvider = loggerProvider;
        _this.sitesProvider = sitesProvider;
        _this.eventsProvider = eventsProvider;
        _this.handlers = {};
        _this.enabledHandlers = {};
        return _this;
    }
    /**
     * Get the component to use to display an user field.
     *
     * @param {Injector} injector Injector.
     * @param  {any} field      User field to get the directive for.
     * @param  {boolean} signup         True if user is in signup page.
     * @return {Promise<any>} Promise resolved with component to use, undefined if not found.
     */
    CoreUserProfileFieldDelegate.prototype.getComponent = function (injector, field, signup) {
        var _this = this;
        var type = field.type || field.datatype;
        var result;
        if (signup) {
            result = this.executeFunction(type, 'getComponent', [injector]);
        }
        else {
            result = this.executeFunctionOnEnabled(type, 'getComponent', [injector]);
        }
        return Promise.resolve(result).catch(function (err) {
            _this.logger.error('Error getting component for field', type, err);
        });
    };
    /**
     * Get the data to send for a certain field based on the input data.
     *
     * @param  {any}     field          User field to get the data for.
     * @param  {boolean} signup         True if user is in signup page.
     * @param  {string}  registerAuth   Register auth method. E.g. 'email'.
     * @param  {any}     formValues     Form values.
     * @return {Promise<any>}           Data to send for the field.
     */
    CoreUserProfileFieldDelegate.prototype.getDataForField = function (field, signup, registerAuth, formValues) {
        var type = field.type || field.datatype, handler = this.getHandler(type, !signup);
        if (handler) {
            var name_1 = 'profile_field_' + field.shortname;
            if (handler.getData) {
                return Promise.resolve(handler.getData(field, signup, registerAuth, formValues));
            }
            else if (field.shortname && typeof formValues[name_1] != 'undefined') {
                // Handler doesn't implement the function, but the form has data for the field.
                return Promise.resolve({
                    type: type,
                    name: name_1,
                    value: formValues[name_1]
                });
            }
        }
        return Promise.reject(null);
    };
    /**
     * Get the data to send for a list of fields based on the input data.
     *
     * @param  {any[]}   fields           User fields to get the data for.
     * @param  {boolean} [signup]       True if user is in signup page.
     * @param  {string}  [registerAuth] Register auth method. E.g. 'email'.
     * @param  {any}     formValues     Form values.
     * @return {Promise<any>}           Data to send.
     */
    CoreUserProfileFieldDelegate.prototype.getDataForFields = function (fields, signup, registerAuth, formValues) {
        var _this = this;
        if (signup === void 0) { signup = false; }
        if (registerAuth === void 0) { registerAuth = ''; }
        var result = [], promises = [];
        fields.forEach(function (field) {
            promises.push(_this.getDataForField(field, signup, registerAuth, formValues).then(function (data) {
                if (data) {
                    result.push(data);
                }
            }).catch(function () {
                // Ignore errors.
            }));
        });
        return Promise.all(promises).then(function () {
            return result;
        });
    };
    CoreUserProfileFieldDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_events__["a" /* CoreEventsProvider */]])
    ], CoreUserProfileFieldDelegate);
    return CoreUserProfileFieldDelegate;
}(__WEBPACK_IMPORTED_MODULE_1__classes_delegate__["a" /* CoreDelegate */]));

//# sourceMappingURL=user-profile-field-delegate.js.map

/***/ }),
/* 81 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSitePluginsPluginContentComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_siteplugins__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_rxjs__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Component to render a site plugin content.
 */
var CoreSitePluginsPluginContentComponent = /** @class */ (function () {
    function CoreSitePluginsPluginContentComponent(domUtils, sitePluginsProvider) {
        this.domUtils = domUtils;
        this.sitePluginsProvider = sitePluginsProvider;
        this.onContentLoaded = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
        this.onLoadingContent = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
        this.invalidateObservable = new __WEBPACK_IMPORTED_MODULE_3_rxjs__["Subject"]();
    }
    /**
     * Component being initialized.
     */
    CoreSitePluginsPluginContentComponent.prototype.ngOnInit = function () {
        this.fetchContent();
    };
    /**
     * Fetches the content to render.
     *
     * @param {boolean} [refresh] Whether the user is refreshing.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreSitePluginsPluginContentComponent.prototype.fetchContent = function (refresh) {
        var _this = this;
        this.onLoadingContent.emit(refresh);
        return this.sitePluginsProvider.getContent(this.component, this.method, this.args).then(function (result) {
            _this.content = result.templates.length ? result.templates[0].html : ''; // Load first template.
            _this.javascript = result.javascript;
            _this.otherData = result.otherdata;
            _this.jsData = _this.sitePluginsProvider.createDataForJS(_this.bootstrapResult, result);
            _this.onContentLoaded.emit(refresh);
        }).catch(function (error) {
            _this.domUtils.showErrorModalDefault(error, 'core.errorloadingcontent', true);
        }).finally(function () {
            _this.dataLoaded = true;
        });
    };
    /**
     * Refresh the data.
     *
     * @param {boolean} [showSpinner] Whether to show spinner while refreshing.
     */
    CoreSitePluginsPluginContentComponent.prototype.refreshData = function (showSpinner) {
        var _this = this;
        if (showSpinner) {
            this.dataLoaded = false;
        }
        this.invalidateObservable.next(); // Notify observers.
        return this.sitePluginsProvider.invalidateContent(this.component, this.method, this.args).finally(function () {
            return _this.fetchContent(true);
        });
    };
    /**
     * Update the content, usually with a different method or params.
     *
     * @param {string} component New component.
     * @param {string} method New method.
     * @param {any} args New params.
     */
    CoreSitePluginsPluginContentComponent.prototype.updateContent = function (component, method, args) {
        this.component = component;
        this.method = method;
        this.args = args;
        this.dataLoaded = false;
        this.fetchContent();
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreSitePluginsPluginContentComponent.prototype, "component", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreSitePluginsPluginContentComponent.prototype, "method", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreSitePluginsPluginContentComponent.prototype, "args", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreSitePluginsPluginContentComponent.prototype, "bootstrapResult", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreSitePluginsPluginContentComponent.prototype, "onContentLoaded", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreSitePluginsPluginContentComponent.prototype, "onLoadingContent", void 0);
    CoreSitePluginsPluginContentComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-site-plugins-plugin-content',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/core/siteplugins/components/plugin-content/plugin-content.html"*/'<core-loading [hideUntil]="dataLoaded">\n    <core-compile-html [text]="content" [javascript]="javascript" [jsData]="jsData"></core-compile-html>\n</core-loading>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/core/siteplugins/components/plugin-content/plugin-content.html"*/,
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_siteplugins__["a" /* CoreSitePluginsProvider */]])
    ], CoreSitePluginsPluginContentComponent);
    return CoreSitePluginsPluginContentComponent;
}());

//# sourceMappingURL=plugin-content.js.map

/***/ }),
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CorePipesModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__bytes_to_size__ = __webpack_require__(1042);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__create_links__ = __webpack_require__(1043);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__date_day_or_time__ = __webpack_require__(1044);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__duration__ = __webpack_require__(1045);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__format_date__ = __webpack_require__(1046);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__no_tags__ = __webpack_require__(1047);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__seconds_to_hms__ = __webpack_require__(1048);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__time_ago__ = __webpack_require__(1049);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__to_locale_string__ = __webpack_require__(1050);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};










var CorePipesModule = /** @class */ (function () {
    function CorePipesModule() {
    }
    CorePipesModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_1__bytes_to_size__["a" /* CoreBytesToSizePipe */],
                __WEBPACK_IMPORTED_MODULE_2__create_links__["a" /* CoreCreateLinksPipe */],
                __WEBPACK_IMPORTED_MODULE_3__date_day_or_time__["a" /* CoreDateDayOrTimePipe */],
                __WEBPACK_IMPORTED_MODULE_4__duration__["a" /* CoreDurationPipe */],
                __WEBPACK_IMPORTED_MODULE_5__format_date__["a" /* CoreFormatDatePipe */],
                __WEBPACK_IMPORTED_MODULE_6__no_tags__["a" /* CoreNoTagsPipe */],
                __WEBPACK_IMPORTED_MODULE_7__seconds_to_hms__["a" /* CoreSecondsToHMSPipe */],
                __WEBPACK_IMPORTED_MODULE_8__time_ago__["a" /* CoreTimeAgoPipe */],
                __WEBPACK_IMPORTED_MODULE_9__to_locale_string__["a" /* CoreToLocaleStringPipe */]
            ],
            imports: [],
            exports: [
                __WEBPACK_IMPORTED_MODULE_1__bytes_to_size__["a" /* CoreBytesToSizePipe */],
                __WEBPACK_IMPORTED_MODULE_2__create_links__["a" /* CoreCreateLinksPipe */],
                __WEBPACK_IMPORTED_MODULE_3__date_day_or_time__["a" /* CoreDateDayOrTimePipe */],
                __WEBPACK_IMPORTED_MODULE_4__duration__["a" /* CoreDurationPipe */],
                __WEBPACK_IMPORTED_MODULE_5__format_date__["a" /* CoreFormatDatePipe */],
                __WEBPACK_IMPORTED_MODULE_6__no_tags__["a" /* CoreNoTagsPipe */],
                __WEBPACK_IMPORTED_MODULE_7__seconds_to_hms__["a" /* CoreSecondsToHMSPipe */],
                __WEBPACK_IMPORTED_MODULE_8__time_ago__["a" /* CoreTimeAgoPipe */],
                __WEBPACK_IMPORTED_MODULE_9__to_locale_string__["a" /* CoreToLocaleStringPipe */]
            ]
        })
    ], CorePipesModule);
    return CorePipesModule;
}());

//# sourceMappingURL=pipes.module.js.map

/***/ }),
/* 91 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseComponentsModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__components_components_module__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__directives_directives_module__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__format_format__ = __webpack_require__(725);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__module_module__ = __webpack_require__(1068);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__module_completion_module_completion__ = __webpack_require__(1069);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__module_description_module_description__ = __webpack_require__(1070);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__unsupported_module_unsupported_module__ = __webpack_require__(246);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};











var CoreCourseComponentsModule = /** @class */ (function () {
    function CoreCourseComponentsModule() {
    }
    CoreCourseComponentsModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_6__format_format__["a" /* CoreCourseFormatComponent */],
                __WEBPACK_IMPORTED_MODULE_7__module_module__["a" /* CoreCourseModuleComponent */],
                __WEBPACK_IMPORTED_MODULE_8__module_completion_module_completion__["a" /* CoreCourseModuleCompletionComponent */],
                __WEBPACK_IMPORTED_MODULE_9__module_description_module_description__["a" /* CoreCourseModuleDescriptionComponent */],
                __WEBPACK_IMPORTED_MODULE_10__unsupported_module_unsupported_module__["a" /* CoreCourseUnsupportedModuleComponent */]
            ],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1__angular_common__["b" /* CommonModule */],
                __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["g" /* IonicModule */],
                __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["b" /* TranslateModule */].forChild(),
                __WEBPACK_IMPORTED_MODULE_4__components_components_module__["a" /* CoreComponentsModule */],
                __WEBPACK_IMPORTED_MODULE_5__directives_directives_module__["a" /* CoreDirectivesModule */]
            ],
            providers: [],
            exports: [
                __WEBPACK_IMPORTED_MODULE_6__format_format__["a" /* CoreCourseFormatComponent */],
                __WEBPACK_IMPORTED_MODULE_7__module_module__["a" /* CoreCourseModuleComponent */],
                __WEBPACK_IMPORTED_MODULE_8__module_completion_module_completion__["a" /* CoreCourseModuleCompletionComponent */],
                __WEBPACK_IMPORTED_MODULE_9__module_description_module_description__["a" /* CoreCourseModuleDescriptionComponent */],
                __WEBPACK_IMPORTED_MODULE_10__unsupported_module_unsupported_module__["a" /* CoreCourseUnsupportedModuleComponent */]
            ],
            entryComponents: [
                __WEBPACK_IMPORTED_MODULE_10__unsupported_module_unsupported_module__["a" /* CoreCourseUnsupportedModuleComponent */]
            ]
        })
    ], CoreCourseComponentsModule);
    return CoreCourseComponentsModule;
}());

//# sourceMappingURL=components.module.js.map

/***/ }),
/* 92 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFileUploaderHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_media_capture__ = __webpack_require__(242);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_camera__ = __webpack_require__(243);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_file__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_text__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__fileuploader__ = __webpack_require__(162);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__delegate__ = __webpack_require__(244);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};













/**
 * Helper service to upload files.
 */
var CoreFileUploaderHelperProvider = /** @class */ (function () {
    function CoreFileUploaderHelperProvider(logger, appProvider, translate, fileUploaderProvider, domUtils, textUtils, fileProvider, utils, actionSheetCtrl, uploaderDelegate, mediaCapture, camera, platform) {
        this.appProvider = appProvider;
        this.translate = translate;
        this.fileUploaderProvider = fileUploaderProvider;
        this.domUtils = domUtils;
        this.textUtils = textUtils;
        this.fileProvider = fileProvider;
        this.utils = utils;
        this.actionSheetCtrl = actionSheetCtrl;
        this.uploaderDelegate = uploaderDelegate;
        this.mediaCapture = mediaCapture;
        this.camera = camera;
        this.platform = platform;
        this.logger = logger.getInstance('CoreFileUploaderProvider');
    }
    /**
     * Show a confirmation modal to the user if the size of the file is bigger than the allowed threshold.
     *
     * @param {number} size File size.
     * @param {boolean} [alwaysConfirm] True to show a confirm even if the size isn't high.
     * @param {boolean} [allowOffline] True to allow uploading in offline.
     * @param {number} [wifiThreshold] Threshold for WiFi connection. Default: CoreFileUploaderProvider.WIFI_SIZE_WARNING.
     * @param {number} [limitedThreshold] Threshold for limited connection. Default: CoreFileUploaderProvider.LIMITED_SIZE_WARNING.
     * @return {Promise<void>} Promise resolved when the user confirms or if there's no need to show a modal.
     */
    CoreFileUploaderHelperProvider.prototype.confirmUploadFile = function (size, alwaysConfirm, allowOffline, wifiThreshold, limitedThreshold) {
        if (size == 0) {
            return Promise.resolve();
        }
        if (!allowOffline && !this.appProvider.isOnline()) {
            return Promise.reject(this.translate.instant('core.fileuploader.errormustbeonlinetoupload'));
        }
        wifiThreshold = typeof wifiThreshold == 'undefined' ? __WEBPACK_IMPORTED_MODULE_11__fileuploader__["a" /* CoreFileUploaderProvider */].WIFI_SIZE_WARNING : wifiThreshold;
        limitedThreshold = typeof limitedThreshold == 'undefined' ?
            __WEBPACK_IMPORTED_MODULE_11__fileuploader__["a" /* CoreFileUploaderProvider */].LIMITED_SIZE_WARNING : limitedThreshold;
        if (size < 0) {
            return this.domUtils.showConfirm(this.translate.instant('core.fileuploader.confirmuploadunknownsize'));
        }
        else if (size >= wifiThreshold || (this.appProvider.isNetworkAccessLimited() && size >= limitedThreshold)) {
            var readableSize = this.textUtils.bytesToSize(size, 2);
            return this.domUtils.showConfirm(this.translate.instant('core.fileuploader.confirmuploadfile', { size: readableSize }));
        }
        else if (alwaysConfirm) {
            return this.domUtils.showConfirm(this.translate.instant('core.areyousure'));
        }
        else {
            return Promise.resolve();
        }
    };
    /**
     * Create a temporary copy of a file and upload it.
     *
     * @param {any} file File to copy and upload.
     * @param {boolean} [upload] True if the file should be uploaded, false to return the copy of the file.
     * @param {string} [name] Name to use when uploading the file. If not defined, use the file's name.
     * @return {Promise<any>} Promise resolved when the file is uploaded.
     */
    CoreFileUploaderHelperProvider.prototype.copyAndUploadFile = function (file, upload, name) {
        var _this = this;
        name = name || file.name;
        var modal = this.domUtils.showModalLoading('core.fileuploader.readingfile', true);
        var fileData;
        // We have the data of the file to be uploaded, but not its URL (needed). Create a copy of the file to upload it.
        return this.fileProvider.readFileData(file, __WEBPACK_IMPORTED_MODULE_6__providers_file__["a" /* CoreFileProvider */].FORMATARRAYBUFFER).then(function (data) {
            fileData = data;
            // Get unique name for the copy.
            return _this.fileProvider.getUniqueNameInFolder(__WEBPACK_IMPORTED_MODULE_6__providers_file__["a" /* CoreFileProvider */].TMPFOLDER, name);
        }).then(function (newName) {
            var filePath = _this.textUtils.concatenatePaths(__WEBPACK_IMPORTED_MODULE_6__providers_file__["a" /* CoreFileProvider */].TMPFOLDER, newName);
            return _this.fileProvider.writeFile(filePath, fileData);
        }).catch(function (error) {
            _this.logger.error('Error reading file to upload.', error);
            modal.dismiss();
            return Promise.reject(_this.translate.instant('core.fileuploader.errorreadingfile'));
        }).then(function (fileEntry) {
            modal.dismiss();
            if (upload) {
                // Pass true to delete the copy after the upload.
                return _this.uploadGenericFile(fileEntry.toURL(), name, file.type, true);
            }
            else {
                return fileEntry;
            }
        });
    };
    /**
     * Copy or move a file to the app temporary folder.
     *
     * @param {string} path  Path of the file.
     * @param {boolean} shouldDelete True if original file should be deleted (move), false otherwise (copy).
     * @param {number} [maxSize] Max size of the file. If not defined or -1, no max size.
     * @param {string} [defaultExt] Defaut extension to use if the file doesn't have any.
     * @return {Promise<any>} Promise resolved with the copied file.
     */
    CoreFileUploaderHelperProvider.prototype.copyToTmpFolder = function (path, shouldDelete, maxSize, defaultExt) {
        var _this = this;
        var fileName = this.fileProvider.getFileAndDirectoryFromPath(path).name, promise, fileTooLarge;
        // Check that size isn't too large.
        if (typeof maxSize != 'undefined' && maxSize != -1) {
            promise = this.fileProvider.getExternalFile(path).then(function (fileEntry) {
                return _this.fileProvider.getFileObjectFromFileEntry(fileEntry).then(function (file) {
                    if (file.size > maxSize) {
                        fileTooLarge = file;
                    }
                });
            }).catch(function () {
                // Ignore failures.
            });
        }
        else {
            promise = Promise.resolve();
        }
        return promise.then(function () {
            if (fileTooLarge) {
                return _this.errorMaxBytes(maxSize, fileTooLarge.name);
            }
            // File isn't too large.
            // Picking an image from album in Android adds a timestamp at the end of the file. Delete it.
            fileName = fileName.replace(/(\.[^\.]*)\?[^\.]*$/, '$1');
            // Get a unique name in the folder to prevent overriding another file.
            return _this.fileProvider.getUniqueNameInFolder(__WEBPACK_IMPORTED_MODULE_6__providers_file__["a" /* CoreFileProvider */].TMPFOLDER, fileName, defaultExt);
        }).then(function (newName) {
            // Now move or copy the file.
            var destPath = _this.textUtils.concatenatePaths(__WEBPACK_IMPORTED_MODULE_6__providers_file__["a" /* CoreFileProvider */].TMPFOLDER, newName);
            if (shouldDelete) {
                return _this.fileProvider.moveExternalFile(path, destPath);
            }
            else {
                return _this.fileProvider.copyExternalFile(path, destPath);
            }
        });
    };
    /**
     * Function called when trying to upload a file bigger than max size. Shows an error.
     *
     * @param {number} maxSize Max size (bytes).
     * @param {string} fileName Name of the file.
     * @return {Promise<any>} Rejected promise.
     */
    CoreFileUploaderHelperProvider.prototype.errorMaxBytes = function (maxSize, fileName) {
        var errorMessage = this.translate.instant('core.fileuploader.maxbytesfile', {
            $a: {
                file: fileName,
                size: this.textUtils.bytesToSize(maxSize, 2)
            }
        });
        this.domUtils.showErrorModal(errorMessage);
        return Promise.reject(null);
    };
    /**
     * Function called when the file picker is closed.
     */
    CoreFileUploaderHelperProvider.prototype.filePickerClosed = function () {
        if (this.filePickerDeferred) {
            this.filePickerDeferred.reject();
            this.filePickerDeferred = undefined;
        }
        // Close the action sheet if it's opened.
        if (this.actionSheet) {
            this.actionSheet.dismiss();
        }
    };
    /**
     * Function to call once a file is uploaded using the file picker.
     *
     * @param {any} result Result of the upload process.
     */
    CoreFileUploaderHelperProvider.prototype.fileUploaded = function (result) {
        if (this.filePickerDeferred) {
            this.filePickerDeferred.resolve(result);
            this.filePickerDeferred = undefined;
        }
        // Close the action sheet if it's opened.
        if (this.actionSheet) {
            this.actionSheet.dismiss();
        }
    };
    /**
     * Open the "file picker" to select and upload a file.
     *
     * @param {number} [maxSize] Max size of the file to upload. If not defined or -1, no max size.
     * @param {string} [title] File picker title.
     * @param {string[]} [mimetypes] List of supported mimetypes. If undefined, all mimetypes supported.
     * @return {Promise<any>} Promise resolved when a file is uploaded, rejected if file picker is closed without a file uploaded.
     *                        The resolve value is the response of the upload request.
     */
    CoreFileUploaderHelperProvider.prototype.selectAndUploadFile = function (maxSize, title, mimetypes) {
        return this.selectFileWithPicker(maxSize, false, title, mimetypes, true);
    };
    /**
     * Open the "file picker" to select a file without uploading it.
     *
     * @param {number} [maxSize] Max size of the file. If not defined or -1, no max size.
     * @param {boolean} [allowOffline] True to allow selecting in offline, false to require connection.
     * @param {string} [title] File picker title.
     * @param {string[]} [mimetypes] List of supported mimetypes. If undefined, all mimetypes supported.
     * @return {Promise<any>} Promise resolved when a file is selected, rejected if file picker is closed without selecting a file.
     *                        The resolve value is the FileEntry of a copy of the picked file, so it can be deleted afterwards.
     */
    CoreFileUploaderHelperProvider.prototype.selectFile = function (maxSize, allowOffline, title, mimetypes) {
        return this.selectFileWithPicker(maxSize, allowOffline, title, mimetypes, false);
    };
    /**
     * Open the "file picker" to select a file and maybe uploading it.
     *
     * @param {number} [maxSize] Max size of the file. If not defined or -1, no max size.
     * @param {boolean} [allowOffline] True to allow selecting in offline, false to require connection.
     * @param {string} [title] File picker title.
     * @param {string[]} [mimetypes] List of supported mimetypes. If undefined, all mimetypes supported.
     * @param {boolean} [upload] Whether the file should be uploaded.
     * @return {Promise<any>} Promise resolved when a file is selected/uploaded, rejected if file picker is closed.
     */
    CoreFileUploaderHelperProvider.prototype.selectFileWithPicker = function (maxSize, allowOffline, title, mimetypes, upload) {
        var _this = this;
        // Create the cancel button and get the handlers to upload the file.
        var buttons = [{
                text: this.translate.instant('core.cancel'),
                role: 'cancel',
                handler: function () {
                    // User cancelled the action sheet.
                    _this.filePickerClosed();
                }
            }], handlers = this.uploaderDelegate.getHandlers(mimetypes);
        this.filePickerDeferred = this.utils.promiseDefer();
        // Sort the handlers by priority.
        handlers.sort(function (a, b) {
            return a.priority <= b.priority ? 1 : -1;
        });
        // Create a button for each handler.
        handlers.forEach(function (handler) {
            buttons.push({
                text: _this.translate.instant(handler.title),
                icon: handler.icon,
                cssClass: handler.class,
                handler: function () {
                    if (!handler.action) {
                        // Nothing to do.
                        return false;
                    }
                    if (!allowOffline && !_this.appProvider.isOnline()) {
                        // Not allowed, show error.
                        _this.domUtils.showErrorModal('core.fileuploader.errormustbeonlinetoupload', true);
                        return false;
                    }
                    handler.action(maxSize, upload, allowOffline, handler.mimetypes).then(function (data) {
                        if (data.treated) {
                            // The handler already treated the file. Return the result.
                            return data.result;
                        }
                        else {
                            // The handler didn't treat the file, we need to do it.
                            if (data.fileEntry) {
                                // The handler provided us a fileEntry, use it.
                                return _this.uploadFileEntry(data.fileEntry, data.delete, maxSize, upload, allowOffline);
                            }
                            else if (data.path) {
                                // The handler provided a path. First treat it like it's a relative path.
                                return _this.fileProvider.getFile(data.path).catch(function () {
                                    // File not found, it's probably an absolute path.
                                    return _this.fileProvider.getExternalFile(data.path);
                                }).then(function (fileEntry) {
                                    // File found, treat it.
                                    return _this.uploadFileEntry(fileEntry, data.delete, maxSize, upload, allowOffline);
                                });
                            }
                            // Nothing received, fail.
                            return Promise.reject('No file received');
                        }
                    }).then(function (result) {
                        // Success uploading or picking, return the result.
                        _this.fileUploaded(result);
                    }).catch(function (error) {
                        if (error) {
                            _this.domUtils.showErrorModal(error);
                        }
                    });
                    // Do not close the action sheet, it will be closed if success.
                    return false;
                }
            });
        });
        this.actionSheet = this.actionSheetCtrl.create({
            title: title ? title : this.translate.instant('core.fileuploader.' + (upload ? 'uploadafile' : 'selectafile')),
            buttons: buttons
        });
        this.actionSheet.present();
        // Call afterRender for each button.
        setTimeout(function () {
            handlers.forEach(function (handler) {
                if (handler.afterRender) {
                    handler.afterRender(maxSize, upload, allowOffline, handler.mimetypes);
                }
            });
        }, 500);
        return this.filePickerDeferred.promise;
    };
    /**
     * Convenience function to upload a file on a certain site, showing a confirm if needed.
     *
     * @param {any} fileEntry FileEntry of the file to upload.
     * @param {boolean} [deleteAfterUpload] Whether the file should be deleted after upload.
     * @param {string} [siteId] Id of the site to upload the file to. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the file is uploaded.
     */
    CoreFileUploaderHelperProvider.prototype.showConfirmAndUploadInSite = function (fileEntry, deleteAfterUpload, siteId) {
        var _this = this;
        return this.fileProvider.getFileObjectFromFileEntry(fileEntry).then(function (file) {
            return _this.confirmUploadFile(file.size).then(function () {
                return _this.uploadGenericFile(fileEntry.toURL(), file.name, file.type, deleteAfterUpload, siteId).then(function () {
                    _this.domUtils.showToast('core.fileuploader.fileuploaded', true, undefined, 'core-toast-success');
                });
            }).catch(function (err) {
                if (err) {
                    _this.domUtils.showErrorModal(err);
                }
                return Promise.reject(null);
            });
        }, function () {
            _this.domUtils.showErrorModal('core.fileuploader.errorreadingfile', true);
            return Promise.reject(null);
        });
    };
    /**
     * Treat a capture audio/video error.
     *
     * @param {any} error Error returned by the Cordova plugin. Can be a string or an object.
     * @param {string} defaultMessage Key of the default message to show.
     * @return {Promise<any>} Rejected promise. If it doesn't have an error message it means it was cancelled.
     */
    CoreFileUploaderHelperProvider.prototype.treatCaptureError = function (error, defaultMessage) {
        // Cancelled or error. If cancelled, error is an object with code = 3.
        if (error) {
            if (typeof error === 'string') {
                this.logger.error('Error while recording audio/video: ' + error);
                if (error.indexOf('No Activity found') > -1) {
                    // User doesn't have an app to do this.
                    return Promise.reject(this.translate.instant('core.fileuploader.errornoapp'));
                }
                else {
                    return Promise.reject(this.translate.instant(defaultMessage));
                }
            }
            else {
                if (error.code != 3) {
                    // Error, not cancelled.
                    this.logger.error('Error while recording audio/video', error);
                    return Promise.reject(this.translate.instant(defaultMessage));
                }
                else {
                    this.logger.debug('Cancelled');
                }
            }
        }
        return Promise.reject(null);
    };
    /**
     * Treat a capture image or browse album error.
     *
     * @param {string} error Error returned by the Cordova plugin.
     * @param {string} defaultMessage Key of the default message to show.
     * @return {Promise<any>} Rejected promise. If it doesn't have an error message it means it was cancelled.
     */
    CoreFileUploaderHelperProvider.prototype.treatImageError = function (error, defaultMessage) {
        // Cancelled or error.
        if (error) {
            if (typeof error == 'string') {
                if (error.toLowerCase().indexOf('error') > -1 || error.toLowerCase().indexOf('unable') > -1) {
                    this.logger.error('Error getting image: ' + error);
                    return Promise.reject(error);
                }
                else {
                    // User cancelled.
                    this.logger.debug('Cancelled');
                }
            }
            else {
                return Promise.reject(this.translate.instant(defaultMessage));
            }
        }
        return Promise.reject(null);
    };
    /**
     * Convenient helper for the user to record and upload a video.
     *
     * @param {boolean} isAudio True if uploading an audio, false if it's a video.
     * @param {number} maxSize Max size of the upload. -1 for no max size.
     * @param {boolean} [upload] True if the file should be uploaded, false to return the picked file.
     * @param {string[]} [mimetypes] List of supported mimetypes. If undefined, all mimetypes supported.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreFileUploaderHelperProvider.prototype.uploadAudioOrVideo = function (isAudio, maxSize, upload, mimetypes) {
        var _this = this;
        this.logger.debug('Trying to record a video file');
        var options = { limit: 1, mimetypes: mimetypes }, promise = isAudio ? this.mediaCapture.captureAudio(options) : this.mediaCapture.captureVideo(options);
        // The mimetypes param is only for desktop apps, the Cordova plugin doesn't support it.
        return promise.then(function (medias) {
            // We used limit 1, we only want 1 media.
            var media = medias[0], path = media.fullPath, error = _this.fileUploaderProvider.isInvalidMimetype(mimetypes, path); // Verify that the mimetype is supported.
            if (error) {
                return Promise.reject(error);
            }
            if (upload) {
                return _this.uploadFile(path, maxSize, true, _this.fileUploaderProvider.getMediaUploadOptions(media));
            }
            else {
                // Copy or move the file to our temporary folder.
                return _this.copyToTmpFolder(path, true, maxSize);
            }
        }, function (error) {
            var defaultError = isAudio ? 'core.fileuploader.errorcapturingaudio' : 'core.fileuploader.errorcapturingvideo';
            return _this.treatCaptureError(error, defaultError);
        });
    };
    /**
     * Uploads a file of any type.
     * This function will not check the size of the file, please check it before calling this function.
     *
     * @param {string} uri File URI.
     * @param {string} name File name.
     * @param {string} type File type.
     * @param {boolean} [deleteAfterUpload] Whether the file should be deleted after upload.
     * @param {string} [siteId] Id of the site to upload the file to. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the file is uploaded.
     */
    CoreFileUploaderHelperProvider.prototype.uploadGenericFile = function (uri, name, type, deleteAfterUpload, siteId) {
        var options = this.fileUploaderProvider.getFileUploadOptions(uri, name, type, deleteAfterUpload);
        return this.uploadFile(uri, -1, false, options, siteId);
    };
    /**
     * Convenient helper for the user to upload an image, either from the album or taking it with the camera.
     *
     * @param {boolean} fromAlbum True if the image should be selected from album, false if it should be taken with camera.
     * @param {number} maxSize Max size of the upload. -1 for no max size.
     * @param {boolean} [upload] True if the file should be uploaded, false to return the picked file.
     * @param {string[]} [mimetypes] List of supported mimetypes. If undefined, all mimetypes supported.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreFileUploaderHelperProvider.prototype.uploadImage = function (fromAlbum, maxSize, upload, mimetypes) {
        var _this = this;
        this.logger.debug('Trying to capture an image with camera');
        var options = {
            quality: 50,
            destinationType: this.camera.DestinationType.FILE_URI,
            correctOrientation: true
        };
        if (fromAlbum) {
            var imageSupported = !mimetypes || this.utils.indexOfRegexp(mimetypes, /^image\//) > -1, videoSupported = !mimetypes || this.utils.indexOfRegexp(mimetypes, /^video\//) > -1;
            options.sourceType = this.camera.PictureSourceType.PHOTOLIBRARY;
            options.popoverOptions = {
                x: 10,
                y: 10,
                width: this.platform.width() - 200,
                height: this.platform.height() - 200,
                arrowDir: this.camera.PopoverArrowDirection.ARROW_ANY
            };
            // Determine the mediaType based on the mimetypes.
            if (imageSupported && !videoSupported) {
                options.mediaType = this.camera.MediaType.PICTURE;
            }
            else if (!imageSupported && videoSupported) {
                options.mediaType = this.camera.MediaType.VIDEO;
            }
            else if (this.platform.is('ios')) {
                // Only get all media in iOS because in Android using this option allows uploading any kind of file.
                options.mediaType = this.camera.MediaType.ALLMEDIA;
            }
        }
        else if (mimetypes) {
            if (mimetypes.indexOf('image/jpeg') > -1) {
                options.encodingType = this.camera.EncodingType.JPEG;
            }
            else if (mimetypes.indexOf('image/png') > -1) {
                options.encodingType = this.camera.EncodingType.PNG;
            }
        }
        return this.camera.getPicture(options).then(function (path) {
            var error = _this.fileUploaderProvider.isInvalidMimetype(mimetypes, path); // Verify that the mimetype is supported.
            if (error) {
                return Promise.reject(error);
            }
            if (upload) {
                return _this.uploadFile(path, maxSize, true, _this.fileUploaderProvider.getCameraUploadOptions(path, fromAlbum));
            }
            else {
                // Copy or move the file to our temporary folder.
                return _this.copyToTmpFolder(path, !fromAlbum, maxSize, 'jpg');
            }
        }, function (error) {
            var defaultError = fromAlbum ? 'core.fileuploader.errorgettingimagealbum' : 'core.fileuploader.errorcapturingimage';
            return _this.treatImageError(error, defaultError);
        });
    };
    /**
     * Upload a file given the file entry.
     *
     * @param {any} fileEntry The file entry.
     * @param {boolean} deleteAfter True if the file should be deleted once treated.
     * @param {number} [maxSize] Max size of the file. If not defined or -1, no max size.
     * @param {boolean} [upload] True if the file should be uploaded, false to return the picked file.
     * @param {boolean} [allowOffline] True to allow selecting in offline, false to require connection.
     * @param {string} [name] Name to use when uploading the file. If not defined, use the file's name.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreFileUploaderHelperProvider.prototype.uploadFileEntry = function (fileEntry, deleteAfter, maxSize, upload, allowOffline, name) {
        var _this = this;
        return this.fileProvider.getFileObjectFromFileEntry(fileEntry).then(function (file) {
            return _this.uploadFileObject(file, maxSize, upload, allowOffline, name).then(function (result) {
                if (deleteAfter) {
                    // We have uploaded and deleted a copy of the file. Now delete the original one.
                    _this.fileProvider.removeFileByFileEntry(fileEntry);
                }
                return result;
            });
        });
    };
    /**
     * Upload a file given the file object.
     *
     * @param {any} file The file object.
     * @param {number} [maxSize] Max size of the file. If not defined or -1, no max size.
     * @param {boolean} [upload] True if the file should be uploaded, false to return the picked file.
     * @param {boolean} [allowOffline] True to allow selecting in offline, false to require connection.
     * @param {string} [name] Name to use when uploading the file. If not defined, use the file's name.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreFileUploaderHelperProvider.prototype.uploadFileObject = function (file, maxSize, upload, allowOffline, name) {
        var _this = this;
        if (maxSize != -1 && file.size > maxSize) {
            return this.errorMaxBytes(maxSize, file.name);
        }
        return this.confirmUploadFile(file.size, false, allowOffline).then(function () {
            // We have the data of the file to be uploaded, but not its URL (needed). Create a copy of the file to upload it.
            return _this.copyAndUploadFile(file, upload, name);
        });
    };
    /**
     * Convenience function to upload a file, allowing to retry if it fails.
     *
     * @param {string} path Absolute path of the file to upload.
     * @param {number} maxSize Max size of the upload. -1 for no max size.
     * @param {boolean} checkSize True to check size.
     * @param {CoreFileUploaderOptions} Options.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved if the file is uploaded, rejected otherwise.
     */
    CoreFileUploaderHelperProvider.prototype.uploadFile = function (path, maxSize, checkSize, options, siteId) {
        var _this = this;
        var errorStr = this.translate.instant('core.error'), retryStr = this.translate.instant('core.retry'), uploadingStr = this.translate.instant('core.fileuploader.uploading'), errorUploading = function (error) {
            // Allow the user to retry.
            return _this.domUtils.showConfirm(error, errorStr, retryStr).then(function () {
                // Try again.
                return _this.uploadFile(path, maxSize, checkSize, options, siteId);
            }, function () {
                // User cancelled. Delete the file if needed.
                if (options.deleteAfterUpload) {
                    _this.fileProvider.removeExternalFile(path);
                }
                return Promise.reject(null);
            });
        };
        var promise, file;
        if (!this.appProvider.isOnline()) {
            return errorUploading(this.translate.instant('core.fileuploader.errormustbeonlinetoupload'));
        }
        if (checkSize) {
            // Check that file size is the right one.
            promise = this.fileProvider.getExternalFile(path).then(function (fileEntry) {
                return _this.fileProvider.getFileObjectFromFileEntry(fileEntry).then(function (f) {
                    file = f;
                    return file.size;
                });
            }).catch(function () {
                // Ignore failures.
            });
        }
        else {
            promise = Promise.resolve(0);
        }
        return promise.then(function (size) {
            if (maxSize != -1 && size > maxSize) {
                return _this.errorMaxBytes(maxSize, file.name);
            }
            if (size > 0) {
                return _this.confirmUploadFile(size);
            }
        }).then(function () {
            // File isn't too large and user confirmed, let's upload.
            var modal = _this.domUtils.showModalLoading(uploadingStr);
            return _this.fileUploaderProvider.uploadFile(path, options, function (progress) {
                // Progress uploading.
                if (progress && progress.lengthComputable) {
                    var perc = Math.min((progress.loaded / progress.total) * 100, 100);
                    if (perc >= 0) {
                        modal.setContent(_this.translate.instant('core.fileuploader.uploadingperc', { $a: perc.toFixed(1) }));
                        if (modal._cmp && modal._cmp.changeDetectorRef) {
                            // Force a change detection, otherwise the content is not updated.
                            modal._cmp.changeDetectorRef.detectChanges();
                        }
                    }
                }
            }, siteId).catch(function (error) {
                _this.logger.error('Error uploading file.', error);
                modal.dismiss();
                if (typeof error != 'string') {
                    error = _this.translate.instant('core.fileuploader.errorwhileuploading');
                }
                return errorUploading(error);
            }).finally(function () {
                modal.dismiss();
            });
        });
    };
    CoreFileUploaderHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_7__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_4__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_11__fileuploader__["a" /* CoreFileUploaderProvider */], __WEBPACK_IMPORTED_MODULE_8__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_9__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_file__["a" /* CoreFileProvider */], __WEBPACK_IMPORTED_MODULE_10__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["a" /* ActionSheetController */], __WEBPACK_IMPORTED_MODULE_12__delegate__["a" /* CoreFileUploaderDelegate */],
            __WEBPACK_IMPORTED_MODULE_2__ionic_native_media_capture__["a" /* MediaCapture */], __WEBPACK_IMPORTED_MODULE_3__ionic_native_camera__["a" /* Camera */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */]])
    ], CoreFileUploaderHelperProvider);
    return CoreFileUploaderHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreLangProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_moment__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_globalization__ = __webpack_require__(224);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__config__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__configconstants__ = __webpack_require__(50);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};







/*
 * Service to handle language features, like changing the current language.
*/
var CoreLangProvider = /** @class */ (function () {
    function CoreLangProvider(translate, configProvider, platform, globalization) {
        var _this = this;
        this.translate = translate;
        this.configProvider = configProvider;
        this.globalization = globalization;
        this.fallbackLanguage = __WEBPACK_IMPORTED_MODULE_6__configconstants__["a" /* CoreConfigConstants */].default_lang || 'en';
        this.customStrings = {}; // Strings defined using the admin tool.
        this.sitePluginsStrings = {}; // Strings defined by site plugins.
        // Set fallback language and language to use until the app determines the right language to use.
        translate.setDefaultLang(this.fallbackLanguage);
        translate.use(this.fallbackLanguage);
        platform.ready().then(function () {
            _this.getCurrentLanguage().then(function (language) {
                translate.use(language);
                __WEBPACK_IMPORTED_MODULE_2_moment__["locale"](language);
            });
        });
    }
    /**
     * Add a set of site plugins strings for a certain language.
     *
     * @param {string} lang The language where to add the strings.
     * @param {any} strings Object with the strings to add.
     * @param {string} [prefix] A prefix to add to all keys.
     */
    CoreLangProvider.prototype.addSitePluginsStrings = function (lang, strings, prefix) {
        // Initialize structures if they don't exist.
        if (!this.sitePluginsStrings[lang]) {
            this.sitePluginsStrings[lang] = {};
        }
        if (!this.translate.translations[lang]) {
            this.translate.translations[lang] = {};
        }
        for (var key in strings) {
            var prefixedKey = prefix + key;
            var value = strings[key];
            if (this.customStrings[lang] && this.customStrings[lang][prefixedKey]) {
                // This string is overridden by a custom string, ignore it.
                continue;
            }
            // Add another curly bracket to string params ({$a} -> {{$a}}).
            value = value.replace(/{([^ ]+)}/gm, '{{$1}}');
            // Make sure we didn't add to many brackets in some case.
            value = value.replace(/{{{([^ ]+)}}}/gm, '{{$1}}');
            if (!this.sitePluginsStrings[lang][prefixedKey]) {
                // It's a new site plugin string. Store the original value.
                this.sitePluginsStrings[lang][prefixedKey] = {
                    original: this.translate.translations[lang][prefixedKey],
                    value: value
                };
            }
            else {
                // Site plugin string already defined. Store the new value.
                this.sitePluginsStrings[lang][prefixedKey].value = value;
            }
            // Store the string in the translations table.
            this.translate.translations[lang][prefixedKey] = value;
        }
    };
    /**
     * Change current language.
     *
     * @param {string} language New language to use.
     * @return {Promise<any>} Promise resolved when the change is finished.
     */
    CoreLangProvider.prototype.changeCurrentLanguage = function (language) {
        var promises = [];
        promises.push(this.translate.use(language));
        promises.push(this.configProvider.set('current_language', language));
        __WEBPACK_IMPORTED_MODULE_2_moment__["locale"](language);
        this.currentLanguage = language;
        return Promise.all(promises);
    };
    /**
     * Clear current custom strings.
     */
    CoreLangProvider.prototype.clearCustomStrings = function () {
        this.unloadStrings(this.customStrings);
        this.customStrings = {};
        this.customStringsRaw = '';
    };
    /**
     * Clear current site plugins strings.
     */
    CoreLangProvider.prototype.clearSitePluginsStrings = function () {
        this.unloadStrings(this.sitePluginsStrings);
        this.sitePluginsStrings = {};
    };
    /**
     * Get all current custom strings.
     *
     * @return {any} Custom strings.
     */
    CoreLangProvider.prototype.getAllCustomStrings = function () {
        return this.customStrings;
    };
    /**
     * Get all current site plugins strings.
     *
     * @return {any} Site plugins strings.
     */
    CoreLangProvider.prototype.getAllSitePluginsStrings = function () {
        return this.sitePluginsStrings;
    };
    /**
     * Get current language.
     *
     * @return {Promise<string>} Promise resolved with the current language.
     */
    CoreLangProvider.prototype.getCurrentLanguage = function () {
        var _this = this;
        if (typeof this.currentLanguage != 'undefined') {
            return Promise.resolve(this.currentLanguage);
        }
        // Get current language from config (user might have changed it).
        return this.configProvider.get('current_language').then(function (language) {
            return language;
        }).catch(function () {
            // User hasn't defined a language. If default language is forced, use it.
            if (!__WEBPACK_IMPORTED_MODULE_6__configconstants__["a" /* CoreConfigConstants */].forcedefaultlanguage) {
                return __WEBPACK_IMPORTED_MODULE_6__configconstants__["a" /* CoreConfigConstants */].default_lang;
            }
            try {
                // No forced language, try to get current language from cordova globalization.
                return _this.globalization.getPreferredLanguage().then(function (result) {
                    var language = result.value.toLowerCase();
                    if (language.indexOf('-') > -1) {
                        // Language code defined by locale has a dash, like en-US or es-ES. Check if it's supported.
                        if (__WEBPACK_IMPORTED_MODULE_6__configconstants__["a" /* CoreConfigConstants */].languages && typeof __WEBPACK_IMPORTED_MODULE_6__configconstants__["a" /* CoreConfigConstants */].languages[language] == 'undefined') {
                            // Code is NOT supported. Fallback to language without dash. E.g. 'en-US' would fallback to 'en'.
                            language = language.substr(0, language.indexOf('-'));
                        }
                    }
                    return language;
                }).catch(function () {
                    // Error getting locale. Use default language.
                    return _this.fallbackLanguage;
                });
            }
            catch (err) {
                // Error getting locale. Use default language.
                return Promise.resolve(_this.fallbackLanguage);
            }
        }).then(function (language) {
            _this.currentLanguage = language; // Save it for later.
            return language;
        });
    };
    /**
     * Load certain custom strings.
     *
     * @param {string} strings Custom strings to load (tool_mobile_customlangstrings).
     */
    CoreLangProvider.prototype.loadCustomStrings = function (strings) {
        var _this = this;
        if (strings == this.customStringsRaw) {
            // Strings haven't changed, stop.
            return;
        }
        // Reset current values.
        this.clearCustomStrings();
        if (!strings) {
            return;
        }
        var list = strings.split(/(?:\r\n|\r|\n)/);
        list.forEach(function (entry) {
            var values = entry.split('|');
            var lang;
            if (values.length < 3) {
                // Not enough data, ignore the entry.
                return;
            }
            lang = values[2];
            if (!_this.customStrings[lang]) {
                _this.customStrings[lang] = {};
            }
            // Store the original value of the custom string.
            _this.customStrings[lang][values[0]] = {
                original: _this.translate.translations[lang][values[0]],
                value: values[1]
            };
            // Store the string in the translations table.
            _this.translate.translations[lang][values[0]] = values[1];
        });
    };
    /**
     * Unload custom or site plugin strings, removing them from the translations table.
     *
     * @param {any} strings Strings to unload.
     */
    CoreLangProvider.prototype.unloadStrings = function (strings) {
        // Iterate over all languages and strings.
        for (var lang in strings) {
            var langStrings = strings[lang];
            for (var key in langStrings) {
                var entry = langStrings[key];
                if (entry.original) {
                    // The string had a value, restore it.
                    this.translate.translations[lang][key] = entry.original;
                }
                else {
                    // The string didn't exist, delete it.
                    delete this.translate.translations[lang][key];
                }
            }
        }
    };
    CoreLangProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_5__config__["a" /* CoreConfigProvider */], __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["n" /* Platform */],
            __WEBPACK_IMPORTED_MODULE_3__ionic_native_globalization__["a" /* Globalization */]])
    ], CoreLangProvider);
    return CoreLangProvider;
}());

//# sourceMappingURL=lang.js.map

/***/ }),
/* 97 */,
/* 98 */,
/* 99 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreContentLinksModuleIndexHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__base_handler__ = __webpack_require__(43);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

/**
 * Handler to handle URLs pointing to the index of a module.
 */
var CoreContentLinksModuleIndexHandler = /** @class */ (function (_super) {
    __extends(CoreContentLinksModuleIndexHandler, _super);
    /**
     * Construct the handler.
     *
     * @param {CoreCourseHelperProvider} courseHelper The CoreCourseHelperProvider instance.
     * @param {string} addon Name of the addon as it's registered in course delegate. It'll be used to check if it's disabled.
     * @param {string} modName Name of the module (assign, book, ...).
     */
    function CoreContentLinksModuleIndexHandler(courseHelper, addon, modName) {
        var _this = _super.call(this) || this;
        _this.courseHelper = courseHelper;
        _this.addon = addon;
        _this.modName = modName;
        // Match the view.php URL with an id param.
        _this.pattern = new RegExp('\/mod\/' + modName + '\/view\.php.*([\&\?]id=\\d+)');
        _this.featureName = '$mmCourseDelegate_' + addon;
        return _this;
    }
    /**
     * Get the list of actions for a link (url).
     *
     * @param {string[]} siteIds List of sites the URL belongs to.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {CoreContentLinksAction[]|Promise<CoreContentLinksAction[]>} List of (or promise resolved with list of) actions.
     */
    CoreContentLinksModuleIndexHandler.prototype.getActions = function (siteIds, url, params, courseId) {
        var _this = this;
        courseId = courseId || params.courseid || params.cid;
        return [{
                action: function (siteId, navCtrl) {
                    _this.courseHelper.navigateToModule(parseInt(params.id, 10), siteId, courseId);
                }
            }];
    };
    return CoreContentLinksModuleIndexHandler;
}(__WEBPACK_IMPORTED_MODULE_0__base_handler__["a" /* CoreContentLinksHandlerBase */]));

//# sourceMappingURL=module-index-handler.js.map

/***/ }),
/* 100 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseOptionsDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__classes_delegate__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_events__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_courses_providers_courses__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__course__ = __webpack_require__(14);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








/**
 * Service to interact with plugins to be shown in each course (participants, learning plans, ...).
 */
var CoreCourseOptionsDelegate = /** @class */ (function (_super) {
    __extends(CoreCourseOptionsDelegate, _super);
    function CoreCourseOptionsDelegate(loggerProvider, sitesProvider, utils, eventsProvider, coursesProvider) {
        var _this = _super.call(this, 'CoreCourseOptionsDelegate', loggerProvider, sitesProvider, eventsProvider) || this;
        _this.sitesProvider = sitesProvider;
        _this.utils = utils;
        _this.eventsProvider = eventsProvider;
        _this.coursesProvider = coursesProvider;
        _this.handlers = {}; // All registered handlers.
        _this.enabledHandlers = {}; // Handlers enabled for the current site.
        _this.loaded = {};
        _this.lastUpdateHandlersForCoursesStart = {};
        _this.coursesHandlers = {};
        _this.featurePrefix = '$mmCoursesDelegate_';
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */].LOGOUT, function () {
            _this.clearCoursesHandlers();
        });
        return _this;
    }
    /**
     * Check if handlers are loaded for a certain course.
     *
     * @param {number} courseId The course ID to check.
     * @return {boolean} True if handlers are loaded, false otherwise.
     */
    CoreCourseOptionsDelegate.prototype.areHandlersLoaded = function (courseId) {
        return !!this.loaded[courseId];
    };
    /**
     * Clear all course options handlers.
     *
     * @param {number} [courseId] The course ID. If not defined, all handlers will be cleared.
     */
    CoreCourseOptionsDelegate.prototype.clearCoursesHandlers = function (courseId) {
        if (courseId) {
            this.loaded[courseId] = false;
            delete this.coursesHandlers[courseId];
        }
        else {
            this.loaded = {};
            this.coursesHandlers = {};
        }
    };
    /**
     * Clear all courses handlers and invalidate its options.
     *
     * @param {number} [courseId] The course ID. If not defined, all handlers will be cleared.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseOptionsDelegate.prototype.clearAndInvalidateCoursesOptions = function (courseId) {
        var promises = [];
        this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_6__core_courses_providers_courses__["a" /* CoreCoursesProvider */].EVENT_MY_COURSES_REFRESHED);
        // Invalidate course enabled data for the handlers that are enabled at site level.
        if (courseId) {
            // Invalidate only options for this course.
            promises.push(this.coursesProvider.invalidateCoursesAdminAndNavOptions([courseId]));
            promises.push(this.invalidateCourseHandlers(courseId));
        }
        else {
            // Invalidate all options.
            promises.push(this.coursesProvider.invalidateUserNavigationOptions());
            promises.push(this.coursesProvider.invalidateUserAdministrationOptions());
            for (var cId in this.coursesHandlers) {
                promises.push(this.invalidateCourseHandlers(parseInt(cId, 10)));
            }
        }
        this.clearCoursesHandlers(courseId);
        return Promise.all(promises);
    };
    /**
     * Get the handlers for a course using a certain access type.
     *
     * @param {number} courseId The course ID.
     * @param {boolean} refresh True if it should refresh the list.
     * @param {any} accessData Access type and data. Default, guest, ...
     * @param {any} [navOptions] Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.
     * @param {any} [admOptions] Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.
     * @return {Promise<CoreCourseOptionsHandler[]>} Promise resolved with array of handlers.
     */
    CoreCourseOptionsDelegate.prototype.getHandlersForAccess = function (courseId, refresh, accessData, navOptions, admOptions) {
        var _this = this;
        // If the handlers aren't loaded, do not refresh.
        if (!this.loaded[courseId]) {
            refresh = false;
        }
        if (refresh || !this.coursesHandlers[courseId] || this.coursesHandlers[courseId].access.type != accessData.type) {
            if (!this.coursesHandlers[courseId]) {
                this.coursesHandlers[courseId] = {};
            }
            this.coursesHandlers[courseId].access = accessData;
            this.coursesHandlers[courseId].navOptions = navOptions;
            this.coursesHandlers[courseId].admOptions = admOptions;
            this.coursesHandlers[courseId].deferred = this.utils.promiseDefer();
            this.updateHandlersForCourse(courseId, accessData, navOptions, admOptions);
        }
        return this.coursesHandlers[courseId].deferred.promise.then(function () {
            return _this.coursesHandlers[courseId].enabledHandlers;
        });
    };
    /**
     * Get the list of handlers that should be displayed for a course.
     * This function should be called only when the handlers need to be displayed, since it can call several WebServices.
     *
     * @param {Injector} injector Injector.
     * @param {any} course The course object.
     * @param {boolean} [refresh] True if it should refresh the list.
     * @param {boolean} [isGuest] Whether it's guest.
     * @param {any} [navOptions] Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.
     * @param {any} [admOptions] Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.
     * @return {Promise<CoreCourseOptionsHandlerToDisplay[]>} Promise resolved with array of handlers.
     */
    CoreCourseOptionsDelegate.prototype.getHandlersToDisplay = function (injector, course, refresh, isGuest, navOptions, admOptions) {
        var _this = this;
        course.id = parseInt(course.id, 10);
        var accessData = {
            type: isGuest ? __WEBPACK_IMPORTED_MODULE_7__course__["a" /* CoreCourseProvider */].ACCESS_GUEST : __WEBPACK_IMPORTED_MODULE_7__course__["a" /* CoreCourseProvider */].ACCESS_DEFAULT
        };
        if (navOptions) {
            course.navOptions = navOptions;
        }
        if (admOptions) {
            course.admOptions = admOptions;
        }
        return this.loadCourseOptions(course, refresh).then(function () {
            // Call getHandlersForAccess to make sure the handlers have been loaded.
            return _this.getHandlersForAccess(course.id, refresh, accessData, course.navOptions, course.admOptions);
        }).then(function () {
            var handlersToDisplay = [], promises = [];
            _this.coursesHandlers[course.id].enabledHandlers.forEach(function (handler) {
                promises.push(Promise.resolve(handler.getDisplayData(injector, course)).then(function (data) {
                    handlersToDisplay.push({
                        data: data,
                        priority: handler.priority,
                        prefetch: handler.prefetch
                    });
                }).catch(function (err) {
                    _this.logger.error('Error getting data for handler', handler.name, err);
                }));
            });
            // Sort them by priority.
            handlersToDisplay.sort(function (a, b) {
                return b.priority - a.priority;
            });
            return handlersToDisplay;
        });
    };
    /**
     * Check if a course has any handler enabled for default access, using course object.
     *
     * @param {any} course The course object.
     * @param {boolean} [refresh] True if it should refresh the list.
     * @return {Promise<boolean>} Promise resolved with boolean: true if it has handlers, false otherwise.
     */
    CoreCourseOptionsDelegate.prototype.hasHandlersForCourse = function (course, refresh) {
        var _this = this;
        // Load course options if missing.
        return this.loadCourseOptions(course, refresh).then(function () {
            return _this.hasHandlersForDefault(course.id, refresh, course.navOptions, course.admOptions);
        });
    };
    /**
     * Check if a course has any handler enabled for default access.
     *
     * @param {number} courseId The course ID.
     * @param {boolean} [refresh] True if it should refresh the list.
     * @param {any} [navOptions] Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.
     * @param {any} [admOptions] Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.
     * @return {Promise<boolean>} Promise resolved with boolean: true if it has handlers, false otherwise.
     */
    CoreCourseOptionsDelegate.prototype.hasHandlersForDefault = function (courseId, refresh, navOptions, admOptions) {
        // Default access.
        var accessData = {
            type: __WEBPACK_IMPORTED_MODULE_7__course__["a" /* CoreCourseProvider */].ACCESS_DEFAULT
        };
        return this.getHandlersForAccess(courseId, refresh, accessData, navOptions, admOptions).then(function (handlers) {
            return !!(handlers && handlers.length);
        });
    };
    /**
     * Check if a course has any handler enabled for guest access.
     *
     * @param {number} courseId The course ID.
     * @param {boolean} [refresh] True if it should refresh the list.
     * @param {any} [navOptions] Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.
     * @param {any} [admOptions] Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.
     * @return {Promise<boolean>} Promise resolved with boolean: true if it has handlers, false otherwise.
     */
    CoreCourseOptionsDelegate.prototype.hasHandlersForGuest = function (courseId, refresh, navOptions, admOptions) {
        // Guest access.
        var accessData = {
            type: __WEBPACK_IMPORTED_MODULE_7__course__["a" /* CoreCourseProvider */].ACCESS_GUEST
        };
        return this.getHandlersForAccess(courseId, refresh, accessData, navOptions, admOptions).then(function (handlers) {
            return !!(handlers && handlers.length);
        });
    };
    /**
     * Invalidate the data to be able to determine if handlers are enabled for a certain course.
     *
     * @param {number} courseId Course ID.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseOptionsDelegate.prototype.invalidateCourseHandlers = function (courseId) {
        var promises = [], courseData = this.coursesHandlers[courseId];
        if (!courseData) {
            return Promise.resolve();
        }
        courseData.enabledHandlers.forEach(function (handler) {
            if (handler && handler.invalidateEnabledForCourse) {
                promises.push(Promise.resolve(handler.invalidateEnabledForCourse(courseId, courseData.navOptions, courseData.admOptions)));
            }
        });
        return this.utils.allPromises(promises);
    };
    /**
     * Check if a time belongs to the last update handlers for course call.
     * This is to handle the cases where updateHandlersForCourse don't finish in the same order as they're called.
     *
     * @param {number} courseId Course ID.
     * @param {number} time Time to check.
     * @return {boolean} Whether it's the last call.
     */
    CoreCourseOptionsDelegate.prototype.isLastUpdateCourseCall = function (courseId, time) {
        if (!this.lastUpdateHandlersForCoursesStart[courseId]) {
            return true;
        }
        return time == this.lastUpdateHandlersForCoursesStart[courseId];
    };
    /**
     * Load course options if missing.
     *
     * @param {any} course The course object.
     * @param {boolean} [refresh] True if it should refresh the list.
     * @return {Promise<void>} Promise resolved when done.
     */
    CoreCourseOptionsDelegate.prototype.loadCourseOptions = function (course, refresh) {
        if (typeof course.navOptions == 'undefined' || typeof course.admOptions == 'undefined' || refresh) {
            return this.coursesProvider.getCoursesAdminAndNavOptions([course.id]).then(function (options) {
                course.navOptions = options.navOptions[course.id];
                course.admOptions = options.admOptions[course.id];
            });
        }
        else {
            return Promise.resolve();
        }
    };
    /**
     * Update handlers for each course.
     *
     * @param {string} [siteId] Site ID.
     */
    CoreCourseOptionsDelegate.prototype.updateData = function (siteId) {
        if (this.sitesProvider.getCurrentSiteId() === siteId) {
            // Update handlers for all courses.
            for (var courseId in this.coursesHandlers) {
                var handler = this.coursesHandlers[courseId];
                this.updateHandlersForCourse(parseInt(courseId, 10), handler.access, handler.navOptions, handler.admOptions);
            }
        }
    };
    /**
     * Update the handlers for a certain course.
     *
     * @param {number} courseId The course ID.
     * @param {any} accessData Access type and data. Default, guest, ...
     * @param {any} [navOptions] Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.
     * @param {any} [admOptions] Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.
     * @return {Promise<any>} Resolved when updated.
     */
    CoreCourseOptionsDelegate.prototype.updateHandlersForCourse = function (courseId, accessData, navOptions, admOptions) {
        var _this = this;
        var promises = [], enabledForCourse = [], siteId = this.sitesProvider.getCurrentSiteId(), now = Date.now();
        this.lastUpdateHandlersForCoursesStart[courseId] = now;
        var _loop_1 = function (name_1) {
            var handler = this_1.enabledHandlers[name_1];
            // Checks if the handler is enabled for the user.
            promises.push(Promise.resolve(handler.isEnabledForCourse(courseId, accessData, navOptions, admOptions))
                .then(function (enabled) {
                if (enabled) {
                    enabledForCourse.push(handler);
                }
                else {
                    return Promise.reject(null);
                }
            }).catch(function () {
                // Nothing to do here, it is not enabled for this user.
            }));
        };
        var this_1 = this;
        for (var name_1 in this.enabledHandlers) {
            _loop_1(name_1);
        }
        return Promise.all(promises).then(function () {
            return true;
        }).catch(function () {
            // Never fails.
            return true;
        }).finally(function () {
            // Verify that this call is the last one that was started.
            // Check that site hasn't changed since the check started.
            if (_this.isLastUpdateCourseCall(courseId, now) && _this.sitesProvider.getCurrentSiteId() === siteId) {
                // Update the coursesHandlers array with the new enabled addons.
                _this.coursesHandlers[courseId].enabledHandlers = enabledForCourse;
                _this.loaded[courseId] = true;
                // Resolve the promise.
                _this.coursesHandlers[courseId].deferred.resolve();
            }
        });
    };
    CoreCourseOptionsDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_6__core_courses_providers_courses__["a" /* CoreCoursesProvider */]])
    ], CoreCourseOptionsDelegate);
    return CoreCourseOptionsDelegate;
}(__WEBPACK_IMPORTED_MODULE_1__classes_delegate__["a" /* CoreDelegate */]));

//# sourceMappingURL=options-delegate.js.map

/***/ }),
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseModulePrefetchHandlerBase; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_filepool__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_course__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__constants__ = __webpack_require__(22);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.








/**
 * Base prefetch handler to be registered in CoreCourseModulePrefetchDelegate. It is useful to minimize the amount of
 * functions that handlers need to implement. It also provides some helper features like preventing a module to be
 * downloaded twice at the same time.
 *
 * If your handler inherits from this service, you just need to override the functions that you want to change.
 *
 * The implementation of this default handler is aimed for resources that only need to prefetch files, not WebService calls.
 *
 * By default, prefetching a module will only download its files (downloadOrPrefetch). This might be enough for resources.
 * If you need to prefetch WebServices, then you need to override the "download" and "prefetch" functions. In this case, it's
 * recommended to call the prefetchPackage function since it'll handle changing the status of the module.
 */
var CoreCourseModulePrefetchHandlerBase = /** @class */ (function () {
    function CoreCourseModulePrefetchHandlerBase(injector) {
        /**
         * Name of the module. It should match the "modname" of the module returned in core_course_get_contents.
         * @type {string}
         */
        this.name = '';
        /**
         * The handler's component.
         * @type {string}
         */
        this.component = 'core_module';
        /**
         * The RegExp to check updates. If a module has an update whose name matches this RegExp, the module will be marked
         * as outdated. This RegExp is ignored if hasUpdates function is defined.
         * @type {RegExp}
         */
        this.updatesNames = /^.*files$/;
        /**
         * List of download promises to prevent downloading the module twice at the same time.
         * @type {{[s: string]: {[s: string]: Promise<any>}}}
         */
        this.downloadPromises = {};
        this.translate = injector.get(__WEBPACK_IMPORTED_MODULE_0__ngx_translate_core__["c" /* TranslateService */]);
        this.appProvider = injector.get(__WEBPACK_IMPORTED_MODULE_1__providers_app__["a" /* CoreAppProvider */]);
        this.courseProvider = injector.get(__WEBPACK_IMPORTED_MODULE_6__providers_course__["a" /* CoreCourseProvider */]);
        this.filepoolProvider = injector.get(__WEBPACK_IMPORTED_MODULE_2__providers_filepool__["a" /* CoreFilepoolProvider */]);
        this.sitesProvider = injector.get(__WEBPACK_IMPORTED_MODULE_3__providers_sites__["a" /* CoreSitesProvider */]);
        this.domUtils = injector.get(__WEBPACK_IMPORTED_MODULE_4__providers_utils_dom__["a" /* CoreDomUtilsProvider */]);
        this.utils = injector.get(__WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__["a" /* CoreUtilsProvider */]);
    }
    /**
     * Add an ongoing download to the downloadPromises list. When the promise finishes it will be removed.
     *
     * @param {number} id Unique identifier per component.
     * @param {Promise<any>} promise Promise to add.
     * @param {String} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise of the current download.
     */
    CoreCourseModulePrefetchHandlerBase.prototype.addOngoingDownload = function (id, promise, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var uniqueId = this.getUniqueId(id);
        if (!this.downloadPromises[siteId]) {
            this.downloadPromises[siteId] = {};
        }
        this.downloadPromises[siteId][uniqueId] = promise.finally(function () {
            delete _this.downloadPromises[siteId][uniqueId];
        });
        return this.downloadPromises[siteId][uniqueId];
    };
    /**
     * Download the module.
     *
     * @param {any} module The module object returned by WS.
     * @param {number} courseId Course ID.
     * @param {string} [dirPath] Path of the directory where to store all the content files. @see downloadOrPrefetch.
     * @return {Promise<any>} Promise resolved when all content is downloaded.
     */
    CoreCourseModulePrefetchHandlerBase.prototype.download = function (module, courseId, dirPath) {
        return this.downloadOrPrefetch(module, courseId, false, dirPath);
    };
    /**
     * Download or prefetch the content.
     *
     * @param {any} module The module object returned by WS.
     * @param {number} courseId Course ID.
     * @param {boolean} [prefetch] True to prefetch, false to download right away.
     * @param {string} [dirPath] Path of the directory where to store all the content files. This is to keep the files
     *                           relative paths and make the package work in an iframe. Undefined to download the files
     *                           in the filepool root folder.
     * @return {Promise<any>} Promise resolved when all content is downloaded. Data returned is not reliable.
     */
    CoreCourseModulePrefetchHandlerBase.prototype.downloadOrPrefetch = function (module, courseId, prefetch, dirPath) {
        var _this = this;
        if (!this.appProvider.isOnline()) {
            // Cannot download in offline.
            return Promise.reject(this.translate.instant('core.networkerrormsg'));
        }
        var siteId = this.sitesProvider.getCurrentSiteId();
        // Load module contents (ignore cache so we always have the latest data).
        return this.loadContents(module, courseId, true).then(function () {
            // Get the intro files.
            return _this.getIntroFiles(module, courseId);
        }).then(function (introFiles) {
            var downloadFn = prefetch ? _this.filepoolProvider.prefetchPackage.bind(_this.filepoolProvider) :
                _this.filepoolProvider.downloadPackage.bind(_this.filepoolProvider), contentFiles = _this.getContentDownloadableFiles(module), promises = [];
            if (dirPath) {
                // Download intro files in filepool root folder.
                promises.push(_this.filepoolProvider.downloadOrPrefetchFiles(siteId, introFiles, prefetch, false, _this.component, module.id));
                // Download content files inside dirPath.
                promises.push(downloadFn(siteId, contentFiles, _this.component, module.id, undefined, dirPath));
            }
            else {
                // No dirPath, download everything in filepool root folder.
                var files = introFiles.concat(contentFiles);
                promises.push(downloadFn(siteId, files, _this.component, module.id));
            }
            return Promise.all(promises);
        });
    };
    /**
     * Returns a list of content files that can be downloaded.
     *
     * @param {any} module The module object returned by WS.
     * @return {any[]} List of files.
     */
    CoreCourseModulePrefetchHandlerBase.prototype.getContentDownloadableFiles = function (module) {
        var _this = this;
        var files = [];
        if (module.contents && module.contents.length) {
            module.contents.forEach(function (content) {
                if (_this.isFileDownloadable(content)) {
                    files.push(content);
                }
            });
        }
        return files;
    };
    /**
     * Get the download size of a module.
     *
     * @param {any} module Module.
     * @param {Number} courseId Course ID the module belongs to.
     * @param {boolean} [single] True if we're downloading a single module, false if we're downloading a whole section.
     * @return {Promise<{size: number, total: boolean}>} Promise resolved with the size and a boolean indicating if it was able
     *                                                   to calculate the total size.
     */
    CoreCourseModulePrefetchHandlerBase.prototype.getDownloadSize = function (module, courseId, single) {
        var _this = this;
        return this.getFiles(module, courseId).then(function (files) {
            return _this.utils.sumFileSizes(files);
        }).catch(function () {
            return { size: -1, total: false };
        });
    };
    /**
     * Get the downloaded size of a module. If not defined, we'll use getFiles to calculate it (it can be slow).
     *
     * @param {any} module Module.
     * @param {number} courseId Course ID the module belongs to.
     * @return {number|Promise<number>} Size, or promise resolved with the size.
     */
    CoreCourseModulePrefetchHandlerBase.prototype.getDownloadedSize = function (module, courseId) {
        var siteId = this.sitesProvider.getCurrentSiteId();
        return this.filepoolProvider.getFilesSizeByComponent(siteId, this.component, module.id);
    };
    /**
     * Get list of files. If not defined, we'll assume they're in module.contents.
     *
     * @param {any} module Module.
     * @param {Number} courseId Course ID the module belongs to.
     * @param {boolean} [single] True if we're downloading a single module, false if we're downloading a whole section.
     * @return {Promise<any[]>} Promise resolved with the list of files.
     */
    CoreCourseModulePrefetchHandlerBase.prototype.getFiles = function (module, courseId, single) {
        var _this = this;
        // Load module contents if needed.
        return this.loadContents(module, courseId).then(function () {
            return _this.getIntroFiles(module, courseId).then(function (files) {
                return files.concat(_this.getContentDownloadableFiles(module));
            });
        });
    };
    /**
     * Returns module intro files.
     *
     * @param {any} module The module object returned by WS.
     * @param {number} courseId Course ID.
     * @return {Promise<any[]>} Promise resolved with list of intro files.
     */
    CoreCourseModulePrefetchHandlerBase.prototype.getIntroFiles = function (module, courseId) {
        return Promise.resolve(this.getIntroFilesFromInstance(module));
    };
    /**
     * Returns module intro files from instance.
     *
     * @param {any} module The module object returned by WS.
     * @param {any} [instance] The instance to get the intro files (book, assign, ...). If not defined, module will be used.
     * @return {any[]} List of intro files.
     */
    CoreCourseModulePrefetchHandlerBase.prototype.getIntroFilesFromInstance = function (module, instance) {
        if (instance) {
            if (typeof instance.introfiles != 'undefined') {
                return instance.introfiles;
            }
            else if (instance.intro) {
                return this.domUtils.extractDownloadableFilesFromHtmlAsFakeFileObjects(instance.intro);
            }
        }
        if (module.description) {
            return this.domUtils.extractDownloadableFilesFromHtmlAsFakeFileObjects(module.description);
        }
        return [];
    };
    /**
     * If there's an ongoing download for a certain identifier return it.
     *
     * @param {number} id Unique identifier per component.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise of the current download.
     */
    CoreCourseModulePrefetchHandlerBase.prototype.getOngoingDownload = function (id, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (this.isDownloading(id, siteId)) {
            // There's already a download ongoing, return the promise.
            return this.downloadPromises[siteId][this.getUniqueId(id)];
        }
        return Promise.resolve();
    };
    /**
     * Create unique identifier using component and id.
     *
     * @param {number} id Unique ID inside component.
     * @return {string} Unique ID.
     */
    CoreCourseModulePrefetchHandlerBase.prototype.getUniqueId = function (id) {
        return this.component + '#' + id;
    };
    /**
     * Invalidate the prefetched content.
     *
     * @param {number} moduleId The module ID.
     * @param {number} courseId The course ID the module belongs to.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCourseModulePrefetchHandlerBase.prototype.invalidateContent = function (moduleId, courseId) {
        var promises = [], siteId = this.sitesProvider.getCurrentSiteId();
        promises.push(this.courseProvider.invalidateModule(moduleId));
        promises.push(this.filepoolProvider.invalidateFilesByComponent(siteId, this.component, moduleId));
        return Promise.all(promises);
    };
    /**
     * Invalidate WS calls needed to determine module status (usually, to check if module is downloadable).
     * It doesn't need to invalidate check updates. It should NOT invalidate files nor all the prefetched data.
     *
     * @param {any} module Module.
     * @param {number} courseId Course ID the module belongs to.
     * @return {Promise<any>} Promise resolved when invalidated.
     */
    CoreCourseModulePrefetchHandlerBase.prototype.invalidateModule = function (module, courseId) {
        return this.courseProvider.invalidateModule(module.id);
    };
    /**
     * Check if a module can be downloaded. If the function is not defined, we assume that all modules are downloadable.
     *
     * @param {any} module Module.
     * @param {number} courseId Course ID the module belongs to.
     * @return {boolean|Promise<boolean>} Whether the module can be downloaded. The promise should never be rejected.
     */
    CoreCourseModulePrefetchHandlerBase.prototype.isDownloadable = function (module, courseId) {
        // By default, mark all instances as downloadable.
        return true;
    };
    /**
     * Check if a there's an ongoing download for the given identifier.
     *
     * @param {number} id Unique identifier per component.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {boolean} True if downloading, false otherwise.
     */
    CoreCourseModulePrefetchHandlerBase.prototype.isDownloading = function (id, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return !!(this.downloadPromises[siteId] && this.downloadPromises[siteId][this.getUniqueId(id)]);
    };
    /**
     * Whether or not the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} A boolean, or a promise resolved with a boolean, indicating if the handler is enabled.
     */
    CoreCourseModulePrefetchHandlerBase.prototype.isEnabled = function () {
        return true;
    };
    /**
     * Check if a file is downloadable.
     *
     * @param {any} file File to check.
     * @return {boolean} Whether the file is downloadable.
     */
    CoreCourseModulePrefetchHandlerBase.prototype.isFileDownloadable = function (file) {
        return file.type === 'file';
    };
    /**
     * Load module contents into module.contents if they aren't loaded already.
     *
     * @param {any} module Module to load the contents.
     * @param {number} [courseId] The course ID. Recommended to speed up the process and minimize data usage.
     * @param {boolean} [ignoreCache] True if it should ignore cached data (it will always fail in offline or server down).
     * @return {Promise}           Promise resolved when loaded.
     */
    CoreCourseModulePrefetchHandlerBase.prototype.loadContents = function (module, courseId, ignoreCache) {
        if (this.isResource) {
            return this.courseProvider.loadModuleContents(module, courseId, undefined, false, ignoreCache);
        }
        return Promise.resolve();
    };
    /**
     * Prefetch a module.
     *
     * @param {any} module Module.
     * @param {number} courseId Course ID the module belongs to.
     * @param {boolean} [single] True if we're downloading a single module, false if we're downloading a whole section.
     * @param {string} [dirPath] Path of the directory where to store all the content files. @see downloadOrPrefetch.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseModulePrefetchHandlerBase.prototype.prefetch = function (module, courseId, single, dirPath) {
        return this.downloadOrPrefetch(module, courseId, true, dirPath);
    };
    /**
     * Prefetch the module, setting package status at start and finish.
     *
     * Example usage from a child instance:
     *     return this.prefetchPackage(module, courseId, single, this.prefetchModule.bind(this), siteId, someParam, anotherParam);
     *
     * Then the function "prefetchModule" will receive params:
     *     prefetchModule(module, courseId, single, siteId, someParam, anotherParam)
     *
     * @param {any} module Module.
     * @param {number} courseId Course ID the module belongs to.
     * @param {boolean} [single] True if we're downloading a single module, false if we're downloading a whole section.
     * @param {prefetchFunction} downloadFn Function to perform the prefetch. Please check the documentation of prefetchFunction.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the module has been downloaded. Data returned is not reliable.
     */
    CoreCourseModulePrefetchHandlerBase.prototype.prefetchPackage = function (module, courseId, single, downloadFn, siteId) {
        var _this = this;
        var args = [];
        for (var _i = 5; _i < arguments.length; _i++) {
            args[_i - 5] = arguments[_i];
        }
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (!this.appProvider.isOnline()) {
            // Cannot prefetch in offline.
            return Promise.reject(this.translate.instant('core.networkerrormsg'));
        }
        if (this.isDownloading(module.id, siteId)) {
            // There's already a download ongoing for this module, return the promise.
            return this.getOngoingDownload(module.id, siteId);
        }
        var prefetchPromise = this.setDownloading(module.id, siteId).then(function () {
            // Package marked as downloading, call the download function.
            // Send all the params except downloadFn. This includes all params passed after siteId.
            return downloadFn.apply(downloadFn, [module, courseId, single, siteId].concat(args));
        }).then(function (extra) {
            // Prefetch finished, mark as downloaded.
            return _this.setDownloaded(module.id, siteId, extra);
        }).catch(function (error) {
            // Error prefetching, go back to previous status and reject the promise.
            return _this.setPreviousStatusAndReject(module.id, error, siteId);
        });
        return this.addOngoingDownload(module.id, prefetchPromise, siteId);
    };
    /**
     * Mark the module as downloaded.
     *
     * @param {number} id Unique identifier per component.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {string} [extra] Extra data to store.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseModulePrefetchHandlerBase.prototype.setDownloaded = function (id, siteId, extra) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.filepoolProvider.storePackageStatus(siteId, __WEBPACK_IMPORTED_MODULE_7__constants__["a" /* CoreConstants */].DOWNLOADED, this.component, id, extra);
    };
    /**
     * Mark the module as downloading.
     *
     * @param {number} id Unique identifier per component.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseModulePrefetchHandlerBase.prototype.setDownloading = function (id, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.filepoolProvider.storePackageStatus(siteId, __WEBPACK_IMPORTED_MODULE_7__constants__["a" /* CoreConstants */].DOWNLOADING, this.component, id);
    };
    /**
     * Set previous status and return a rejected promise.
     *
     * @param {number} id Unique identifier per component.
     * @param {any} [error] Error to return.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<never>} Rejected promise.
     */
    CoreCourseModulePrefetchHandlerBase.prototype.setPreviousStatusAndReject = function (id, error, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.filepoolProvider.setPackagePreviousStatus(siteId, this.component, id).then(function () {
            return Promise.reject(error);
        });
    };
    /**
     * Remove module downloaded files. If not defined, we'll use getFiles to remove them (slow).
     *
     * @param {any} module Module.
     * @param {number} courseId Course ID the module belongs to.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseModulePrefetchHandlerBase.prototype.removeFiles = function (module, courseId) {
        return this.filepoolProvider.removeFilesByComponent(this.sitesProvider.getCurrentSiteId(), this.component, module.id);
    };
    return CoreCourseModulePrefetchHandlerBase;
}());

//# sourceMappingURL=module-prefetch-handler.js.map

/***/ }),
/* 107 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModPageProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_course_providers_course__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_filepool__ = __webpack_require__(35);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






/**
 * Service that provides some features for page.
 */
var AddonModPageProvider = /** @class */ (function () {
    function AddonModPageProvider(logger, sitesProvider, courseProvider, utils, filepoolProvider) {
        this.sitesProvider = sitesProvider;
        this.courseProvider = courseProvider;
        this.utils = utils;
        this.filepoolProvider = filepoolProvider;
        this.ROOT_CACHE_KEY = 'mmaModPage:';
        this.logger = logger.getInstance('mmaModPageProvider');
    }
    AddonModPageProvider_1 = AddonModPageProvider;
    /**
     * Get a page by course module ID.
     *
     * @param {number} courseId Course ID.
     * @param {number} cmId     Course module ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved when the book is retrieved.
     */
    AddonModPageProvider.prototype.getPageData = function (courseId, cmId, siteId) {
        return this.getPageByKey(courseId, 'coursemodule', cmId, siteId);
    };
    /**
     * Get a page.
     *
     * @param {number} courseId  Course ID.
     * @param {string} key       Name of the property to check.
     * @param {any}  value     Value to search.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}          Promise resolved when the book is retrieved.
     */
    AddonModPageProvider.prototype.getPageByKey = function (courseId, key, value, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                courseids: [courseId]
            }, preSets = {
                cacheKey: _this.getPageCacheKey(courseId)
            };
            return site.read('mod_page_get_pages_by_courses', params, preSets).then(function (response) {
                if (response && response.pages) {
                    var currentPage = response.pages.find(function (page) {
                        return page[key] == value;
                    });
                    if (currentPage) {
                        return currentPage;
                    }
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get cache key for page data WS calls.
     *
     * @param {number} courseId Course ID.
     * @return {string}         Cache key.
     */
    AddonModPageProvider.prototype.getPageCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'page:' + courseId;
    };
    /**
     * Invalidate the prefetched content.
     *
     * @param  {number} moduleId The module ID.
     * @param  {number} courseId Course ID of the module.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}
     */
    AddonModPageProvider.prototype.invalidateContent = function (moduleId, courseId, siteId) {
        var promises = [];
        promises.push(this.invalidatePageData(courseId, siteId));
        promises.push(this.filepoolProvider.invalidateFilesByComponent(siteId, AddonModPageProvider_1.COMPONENT, moduleId));
        promises.push(this.courseProvider.invalidateModule(moduleId, siteId));
        return this.utils.allPromises(promises);
    };
    /**
     * Invalidates page data.
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}   Promise resolved when the data is invalidated.
     */
    AddonModPageProvider.prototype.invalidatePageData = function (courseId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getPageCacheKey(courseId));
        });
    };
    /**
     * Returns whether or not getPage WS available or not.
     *
     * @return {boolean} If WS is avalaible.
     * @since 3.3
     */
    AddonModPageProvider.prototype.isGetPageWSAvailable = function () {
        return this.sitesProvider.wsAvailableInCurrentSite('mod_page_get_pages_by_courses');
    };
    /**
     * Return whether or not the plugin is enabled.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    AddonModPageProvider.prototype.isPluginEnabled = function (siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.canDownloadFiles();
        });
    };
    /**
     * Report a page as being viewed.
     *
     * @param {number} id Module ID.
     * @return {Promise<any>}  Promise resolved when the WS call is successful.
     */
    AddonModPageProvider.prototype.logView = function (id) {
        var params = {
            pageid: id
        };
        return this.sitesProvider.getCurrentSite().write('mod_page_view_page', params);
    };
    AddonModPageProvider.COMPONENT = 'mmaModPage';
    AddonModPageProvider = AddonModPageProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_4__core_course_providers_course__["a" /* CoreCourseProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_filepool__["a" /* CoreFilepoolProvider */]])
    ], AddonModPageProvider);
    return AddonModPageProvider;
    var AddonModPageProvider_1;
}());

//# sourceMappingURL=page.js.map

/***/ }),
/* 108 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModResourceProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_course_providers_course__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_filepool__ = __webpack_require__(35);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






/**
 * Service that provides some features for resources.
 */
var AddonModResourceProvider = /** @class */ (function () {
    function AddonModResourceProvider(logger, sitesProvider, courseProvider, filepoolProvider, utils) {
        this.sitesProvider = sitesProvider;
        this.courseProvider = courseProvider;
        this.filepoolProvider = filepoolProvider;
        this.utils = utils;
        this.ROOT_CACHE_KEY = 'mmaModResource:';
        this.logger = logger.getInstance('AddonModResourceProvider');
    }
    AddonModResourceProvider_1 = AddonModResourceProvider;
    /**
     * Get cache key for resource data WS calls.
     *
     * @param {number} courseId Course ID.
     * @return {string}         Cache key.
     */
    AddonModResourceProvider.prototype.getResourceCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'resource:' + courseId;
    };
    /**
     * Get a resource data.
     *
     * @param {number} courseId Course ID.
     * @param {string} key     Name of the property to check.
     * @param {any}  value   Value to search.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}  Promise resolved when the resource is retrieved.
     */
    AddonModResourceProvider.prototype.getResourceDataByKey = function (courseId, key, value, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                courseids: [courseId]
            }, preSets = {
                cacheKey: _this.getResourceCacheKey(courseId)
            };
            return site.read('mod_resource_get_resources_by_courses', params, preSets).then(function (response) {
                if (response && response.resources) {
                    var currentResource = response.resources.find(function (resource) {
                        return resource[key] == value;
                    });
                    if (currentResource) {
                        return currentResource;
                    }
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get a resource by course module ID.
     *
     * @param {number} courseId Course ID.
     * @param {number} cmId     Course module ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}   Promise resolved when the resource is retrieved.
     */
    AddonModResourceProvider.prototype.getResourceData = function (courseId, cmId, siteId) {
        return this.getResourceDataByKey(courseId, 'coursemodule', cmId, siteId);
    };
    /**
     * Invalidate the prefetched content.
     *
     * @param  {number} moduleId The module ID.
     * @param  {number} courseId Course ID of the module.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved when the data is invalidated.
     */
    AddonModResourceProvider.prototype.invalidateContent = function (moduleId, courseId, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var promises = [];
        promises.push(this.invalidateResourceData(courseId, siteId));
        promises.push(this.filepoolProvider.invalidateFilesByComponent(siteId, AddonModResourceProvider_1.COMPONENT, moduleId));
        promises.push(this.courseProvider.invalidateModule(moduleId, siteId));
        return this.utils.allPromises(promises);
    };
    /**
     * Invalidates resource data.
     *
     * @param {number} courseid Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}   Promise resolved when the data is invalidated.
     */
    AddonModResourceProvider.prototype.invalidateResourceData = function (courseId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getResourceCacheKey(courseId));
        });
    };
    /**
     * Returns whether or not getResource WS available or not.
     *
     * @return {boolean} If WS is abalaible.
     * @since 3.3
     */
    AddonModResourceProvider.prototype.isGetResourceWSAvailable = function () {
        return this.sitesProvider.wsAvailableInCurrentSite('mod_resource_get_resources_by_courses');
    };
    /**
     * Return whether or not the plugin is enabled.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    AddonModResourceProvider.prototype.isPluginEnabled = function (siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.canDownloadFiles();
        });
    };
    /**
     * Report the resource as being viewed.
     *
     * @param {number} id Module ID.
     * @return {Promise<any>}  Promise resolved when the WS call is successful.
     */
    AddonModResourceProvider.prototype.logView = function (id) {
        var params = {
            resourceid: id
        };
        return this.sitesProvider.getCurrentSite().write('mod_resource_view_resource', params);
    };
    AddonModResourceProvider.COMPONENT = 'mmaModResource';
    AddonModResourceProvider = AddonModResourceProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_4__core_course_providers_course__["a" /* CoreCourseProvider */],
            __WEBPACK_IMPORTED_MODULE_5__providers_filepool__["a" /* CoreFilepoolProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], AddonModResourceProvider);
    return AddonModResourceProvider;
    var AddonModResourceProvider_1;
}());

//# sourceMappingURL=resource.js.map

/***/ }),
/* 109 */,
/* 110 */,
/* 111 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSitePluginsBaseHandler; });
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * Super class for handlers for site plugins.
 */
var CoreSitePluginsBaseHandler = /** @class */ (function () {
    function CoreSitePluginsBaseHandler(name) {
        this.name = name;
    }
    /**
     * Whether or not the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} A boolean, or a promise resolved with a boolean, indicating if the handler is enabled.
     */
    CoreSitePluginsBaseHandler.prototype.isEnabled = function () {
        return true;
    };
    return CoreSitePluginsBaseHandler;
}());

//# sourceMappingURL=base-handler.js.map

/***/ }),
/* 112 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonCompetencyProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(3);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Service to handle caompetency learning plans.
 */
var AddonCompetencyProvider = /** @class */ (function () {
    function AddonCompetencyProvider(loggerProvider, sitesProvider) {
        this.sitesProvider = sitesProvider;
        this.ROOT_CACHE_KEY = 'mmaCompetency:';
        this.logger = loggerProvider.getInstance('AddonCompetencyProvider');
    }
    AddonCompetencyProvider_1 = AddonCompetencyProvider;
    /**
     * Get cache key for user learning plans data WS calls.
     *
     * @param {number} userId User ID.
     * @return {string}         Cache key.
     */
    AddonCompetencyProvider.prototype.getLearningPlansCacheKey = function (userId) {
        return this.ROOT_CACHE_KEY + 'userplans:' + userId;
    };
    /**
     * Get cache key for learning plan data WS calls.
     *
     * @param {number} planId Plan ID.
     * @return {string}         Cache key.
     */
    AddonCompetencyProvider.prototype.getLearningPlanCacheKey = function (planId) {
        return this.ROOT_CACHE_KEY + 'learningplan:' + planId;
    };
    /**
     * Get cache key for competency in plan data WS calls.
     *
     * @param {number} planId Plan ID.
     * @param {number} competencyId Competency ID.
     * @return {string}         Cache key.
     */
    AddonCompetencyProvider.prototype.getCompetencyInPlanCacheKey = function (planId, competencyId) {
        return this.ROOT_CACHE_KEY + 'plancompetency:' + planId + ':' + competencyId;
    };
    /**
     * Get cache key for competency in course data WS calls.
     *
     * @param {number} courseId Course ID.
     * @param {number} competencyId Competency ID.
     * @param {number} userId User ID.
     * @return {string}         Cache key.
     */
    AddonCompetencyProvider.prototype.getCompetencyInCourseCacheKey = function (courseId, competencyId, userId) {
        return this.ROOT_CACHE_KEY + 'coursecompetency:' + userId + ':' + courseId + ':' + competencyId;
    };
    /**
     * Get cache key for competency summary data WS calls.
     *
     * @param {number} competencyId Competency ID.
     * @param {number} userId User ID.
     * @return {string}         Cache key.
     */
    AddonCompetencyProvider.prototype.getCompetencySummaryCacheKey = function (competencyId, userId) {
        return this.ROOT_CACHE_KEY + 'competencysummary:' + userId + ':' + competencyId;
    };
    /**
     * Get cache key for course competencies data WS calls.
     *
     * @param {number} courseId Course ID.
     * @return {string}         Cache key.
     */
    AddonCompetencyProvider.prototype.getCourseCompetenciesCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'coursecompetencies:' + courseId;
    };
    /**
     * Returns whether competencies are enabled.
     *
     * @param  {number} courseId Course ID.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} competencies if enabled for the given course, false otherwise.
     */
    AddonCompetencyProvider.prototype.isPluginForCourseEnabled = function (courseId, siteId) {
        if (!this.sitesProvider.isLoggedIn()) {
            return Promise.resolve(false);
        }
        return this.getCourseCompetencies(courseId, 0, siteId).catch(function () {
            return false;
        });
    };
    /**
     * Get plans for a certain user.
     *
     * @param  {number} [userId]    ID of the user. If not defined, current user.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>}            Promise to be resolved when the plans are retrieved.
     */
    AddonCompetencyProvider.prototype.getLearningPlans = function (userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            _this.logger.debug('Get plans for user ' + userId);
            var params = {
                userid: userId
            }, preSets = {
                cacheKey: _this.getLearningPlansCacheKey(userId)
            };
            return site.read('tool_lp_data_for_plans_page', params, preSets).then(function (response) {
                if (response.plans) {
                    return response.plans;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get a certain plan.
     *
     * @param  {number} planId    ID of the plan.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>}            Promise to be resolved when the plans are retrieved.
     */
    AddonCompetencyProvider.prototype.getLearningPlan = function (planId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            _this.logger.debug('Get plan ' + planId);
            var params = {
                planid: planId
            }, preSets = {
                cacheKey: _this.getLearningPlanCacheKey(planId)
            };
            return site.read('tool_lp_data_for_plan_page', params, preSets).then(function (response) {
                if (response.plan) {
                    return response;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get a certain competency in a plan.
     *
     * @param  {number} planId    ID of the plan.
     * @param  {number} competencyId    ID of the competency.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>}            Promise to be resolved when the plans are retrieved.
     */
    AddonCompetencyProvider.prototype.getCompetencyInPlan = function (planId, competencyId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            _this.logger.debug('Get competency ' + competencyId + ' in plan ' + planId);
            var params = {
                planid: planId,
                competencyid: competencyId
            }, preSets = {
                cacheKey: _this.getCompetencyInPlanCacheKey(planId, competencyId)
            };
            return site.read('tool_lp_data_for_user_competency_summary_in_plan', params, preSets).then(function (response) {
                if (response.usercompetencysummary) {
                    return response;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get a certain competency in a course.
     *
     * @param  {number} courseId    ID of the course.
     * @param  {number} competencyId    ID of the competency.
     * @param  {number} [userId]    ID of the user. If not defined, current user.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>}            Promise to be resolved when the plans are retrieved.
     */
    AddonCompetencyProvider.prototype.getCompetencyInCourse = function (courseId, competencyId, userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            _this.logger.debug('Get competency ' + competencyId + ' in course ' + courseId);
            var params = {
                courseid: courseId,
                competencyid: competencyId,
                userid: userId
            }, preSets = {
                cacheKey: _this.getCompetencyInCourseCacheKey(courseId, competencyId, userId)
            };
            return site.read('tool_lp_data_for_user_competency_summary_in_course', params, preSets).then(function (response) {
                if (response.usercompetencysummary) {
                    return response;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get a certain competency summary.
     *
     * @param  {number} competencyId    ID of the competency.
     * @param  {number} [userId]    ID of the user. If not defined, current user.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>}            Promise to be resolved when the plans are retrieved.
     */
    AddonCompetencyProvider.prototype.getCompetencySummary = function (competencyId, userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            _this.logger.debug('Get competency ' + competencyId + ' summary for user' + userId);
            var params = {
                competencyid: competencyId,
                userid: userId
            }, preSets = {
                cacheKey: _this.getCompetencySummaryCacheKey(competencyId, userId)
            };
            return site.read('tool_lp_data_for_user_competency_summary', params, preSets).then(function (response) {
                if (response.competency) {
                    return response.competency;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get all competencies in a course.
     *
     * @param  {number} courseId    ID of the course.
     * @param  {number} [userId]    ID of the user.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>}            Promise to be resolved when the course competencies are retrieved.
     */
    AddonCompetencyProvider.prototype.getCourseCompetencies = function (courseId, userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            _this.logger.debug('Get course competencies for course ' + courseId);
            var params = {
                courseid: courseId
            }, preSets = {
                cacheKey: _this.getCourseCompetenciesCacheKey(courseId)
            };
            return site.read('tool_lp_data_for_course_competencies_page', params, preSets).then(function (response) {
                if (response.competencies) {
                    return response;
                }
                return Promise.reject(null);
            });
        }).then(function (response) {
            if (!userId || userId == _this.sitesProvider.getCurrentSiteUserId()) {
                return response;
            }
            var promises = response.competencies.map(function (competency) {
                return _this.getCompetencyInCourse(courseId, competency.competency.id, userId, siteId);
            });
            return Promise.all(promises).then(function (responses) {
                responses.forEach(function (resp, index) {
                    response.competencies[index].usercompetencycourse = resp.usercompetencysummary.usercompetencycourse;
                });
                return response;
            });
        });
    };
    /**
     * Invalidates User Learning Plans data.
     *
     * @param  {number} [userId]    ID of the user. If not defined, current user.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>}            Promise resolved when the data is invalidated.
     */
    AddonCompetencyProvider.prototype.invalidateLearningPlans = function (userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(_this.getLearningPlansCacheKey(userId));
        });
    };
    /**
     * Invalidates Learning Plan data.
     *
     * @param  {number} planId    ID of the plan.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved when the data is invalidated.
     */
    AddonCompetencyProvider.prototype.invalidateLearningPlan = function (planId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getLearningPlanCacheKey(planId));
        });
    };
    /**
     * Invalidates Competency in Plan data.
     *
     * @param  {number} planId    ID of the plan.
     * @param  {number} competencyId    ID of the competency.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved when the data is invalidated.
     */
    AddonCompetencyProvider.prototype.invalidateCompetencyInPlan = function (planId, competencyId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getCompetencyInPlanCacheKey(planId, competencyId));
        });
    };
    /**
     * Invalidates Competency in Course data.
     *
     * @param  {number} courseId    ID of the course.
     * @param  {number} competencyId    ID of the competency.
     * @param  {number} [userId]    ID of the user. If not defined, current user.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved when the data is invalidated.
     */
    AddonCompetencyProvider.prototype.invalidateCompetencyInCourse = function (courseId, competencyId, userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(_this.getCompetencyInCourseCacheKey(courseId, competencyId, userId));
        });
    };
    /**
     * Invalidates Competency Summary data.
     *
     * @param  {number} competencyId    ID of the competency.
     * @param  {number} [userId]    ID of the user. If not defined, current user.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved when the data is invalidated.
     */
    AddonCompetencyProvider.prototype.invalidateCompetencySummary = function (competencyId, userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(_this.getCompetencySummaryCacheKey(competencyId, userId));
        });
    };
    /**
     * Invalidates Course Competencies data.
     *
     * @param  {number} courseId    ID of the course.
     * @param  {number} [userId]      ID of the user.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved when the data is invalidated.
     */
    AddonCompetencyProvider.prototype.invalidateCourseCompetencies = function (courseId, userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getCourseCompetenciesCacheKey(courseId));
        }).then(function () {
            if (!userId || userId == _this.sitesProvider.getCurrentSiteUserId()) {
                return;
            }
            /* Competencies for other users are fetched with getCompetencyInCourse (and saved in their own cache).
               We need to fecth the list of competencies to know which ones to invalidate. We can pass 0 as userId
               to getCourseCompetencies, we just need the competency IDs and this way we avid extra WS calls. */
            return _this.getCourseCompetencies(courseId, 0, siteId).then(function (competencies) {
                var promises = competencies.competencies.map(function (competency) {
                    return _this.invalidateCompetencyInCourse(courseId, competency.competency.id, userId, siteId);
                });
                return Promise.all(promises);
            });
        });
    };
    /**
     * Report the competency as being viewed in plan.
     *
     * @param  {number} planId    ID of the plan.
     * @param  {number} competencyId  ID of the competency.
     * @param  {number} planStatus    Current plan Status to decide what action should be logged.
     * @param  {number} [userId] User ID. If not defined, current user.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}  Promise resolved when the WS call is successful.
     */
    AddonCompetencyProvider.prototype.logCompetencyInPlanView = function (planId, competencyId, planStatus, userId, siteId) {
        if (planId && competencyId) {
            return this.sitesProvider.getSite(siteId).then(function (site) {
                userId = userId || site.getUserId();
                var params = {
                    planid: planId,
                    competencyid: competencyId,
                    userid: userId
                }, preSets = {
                    typeExpected: 'boolean'
                };
                if (planStatus == AddonCompetencyProvider_1.STATUS_COMPLETE) {
                    return site.write('core_competency_user_competency_plan_viewed', params, preSets);
                }
                else {
                    return site.write('core_competency_user_competency_viewed_in_plan', params, preSets);
                }
            });
        }
        return Promise.reject(null);
    };
    /**
     * Report the competency as being viewed in course.
     *
     * @param  {number} courseId        ID of the course.
     * @param  {number} competencyId    ID of the competency.
     * @param  {number} [userId] User ID. If not defined, current user.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}  Promise resolved when the WS call is successful.
     */
    AddonCompetencyProvider.prototype.logCompetencyInCourseView = function (courseId, competencyId, userId, siteId) {
        if (courseId && competencyId) {
            return this.sitesProvider.getSite(siteId).then(function (site) {
                userId = userId || site.getUserId();
                var params = {
                    courseid: courseId,
                    competencyid: competencyId,
                    userid: userId
                };
                var preSets = {
                    typeExpected: 'boolean'
                };
                return site.write('core_competency_user_competency_viewed_in_course', params, preSets);
            });
        }
        return Promise.reject(null);
    };
    /**
     * Report the competency as being viewed.
     *
     * @param  {number} competencyId    ID of the competency.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}  Promise resolved when the WS call is successful.
     */
    AddonCompetencyProvider.prototype.logCompetencyView = function (competencyId, siteId) {
        if (competencyId) {
            return this.sitesProvider.getSite(siteId).then(function (site) {
                var params = {
                    id: competencyId,
                };
                var preSets = {
                    typeExpected: 'boolean'
                };
                return site.write('core_competency_competency_viewed', params, preSets);
            });
        }
        return Promise.reject(null);
    };
    AddonCompetencyProvider.STATUS_DRAFT = 0;
    AddonCompetencyProvider.STATUS_ACTIVE = 1;
    AddonCompetencyProvider.STATUS_COMPLETE = 2;
    AddonCompetencyProvider.STATUS_WAITIN_GFOR_REVIEW = 3;
    AddonCompetencyProvider.STATUS_IN_REVIEW = 4;
    AddonCompetencyProvider.REVIEW_STATUS_IDLE = 0;
    AddonCompetencyProvider.REVIEW_STATUS_WAITING_FOR_REVIEW = 1;
    AddonCompetencyProvider.REVIEW_STATUS_IN_REVIEW = 2;
    AddonCompetencyProvider = AddonCompetencyProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */]])
    ], AddonCompetencyProvider);
    return AddonCompetencyProvider;
    var AddonCompetencyProvider_1;
}());

//# sourceMappingURL=competency.js.map

/***/ }),
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CorePluginFileDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__logger__ = __webpack_require__(5);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Delegate to register pluginfile information handlers.
 */
var CorePluginFileDelegate = /** @class */ (function () {
    function CorePluginFileDelegate(logger) {
        this.handlers = {};
        this.logger = logger.getInstance('CorePluginFileDelegate');
    }
    /**
     * Get the handler for a certain pluginfile url.
     *
     * @param {string} pluginType Type of the plugin.
     * @return {CorePluginFileHandler} Handler. Undefined if no handler found for the plugin.
     */
    CorePluginFileDelegate.prototype.getPluginHandler = function (pluginType) {
        if (typeof this.handlers[pluginType] != 'undefined') {
            return this.handlers[pluginType];
        }
    };
    /**
     * Get the RegExp of the component and filearea described in the URL.
     *
     * @param {string[]} args Arguments of the pluginfile URL defining component and filearea at least.
     * @return {RegExp}  RegExp to match the revision or undefined if not found.
     */
    CorePluginFileDelegate.prototype.getComponentRevisionRegExp = function (args) {
        // Get handler based on component (args[1]).
        var handler = this.getPluginHandler(args[1]);
        if (handler && handler.getComponentRevisionRegExp) {
            return handler.getComponentRevisionRegExp(args);
        }
    };
    /**
     * Register a handler.
     *
     * @param {CorePluginFileHandler} handler The handler to register.
     * @return {boolean} True if registered successfully, false otherwise.
     */
    CorePluginFileDelegate.prototype.registerHandler = function (handler) {
        if (typeof this.handlers[handler.name] !== 'undefined') {
            this.logger.log("Addon '" + handler.name + "' already registered");
            return false;
        }
        this.logger.log("Registered addon '" + handler.name + "'");
        this.handlers[handler.name] = handler;
        return true;
    };
    /**
     * Removes the revision number from a file URL.
     *
     * @param {string} url URL to be replaced.
     * @param {string[]} args Arguments of the pluginfile URL defining component and filearea at least.
     * @return {string} Replaced URL without revision.
     */
    CorePluginFileDelegate.prototype.removeRevisionFromUrl = function (url, args) {
        // Get handler based on component (args[1]).
        var handler = this.getPluginHandler(args[1]);
        if (handler && handler.getComponentRevisionRegExp && handler.getComponentRevisionReplace) {
            var revisionRegex = handler.getComponentRevisionRegExp(args);
            if (revisionRegex) {
                return url.replace(revisionRegex, handler.getComponentRevisionReplace(args));
            }
        }
        return url;
    };
    CorePluginFileDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__logger__["a" /* CoreLoggerProvider */]])
    ], CorePluginFileDelegate);
    return CorePluginFileDelegate;
}());

//# sourceMappingURL=plugin-file-delegate.js.map

/***/ }),
/* 130 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseModuleMainResourceComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

/**
 * Template class to easily create CoreCourseModuleMainComponent of resources (or activities without syncing).
 */
var CoreCourseModuleMainResourceComponent = /** @class */ (function () {
    function CoreCourseModuleMainResourceComponent(textUtils, courseHelper, translate, domUtils) {
        this.textUtils = textUtils;
        this.courseHelper = courseHelper;
        this.translate = translate;
        this.domUtils = domUtils;
        this.fetchContentDefaultError = 'core.course.errorgetmodule'; // Default error to show when loading contents.
        this.dataRetrieved = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
    }
    /**
     * Component being initialized.
     */
    CoreCourseModuleMainResourceComponent.prototype.ngOnInit = function () {
        this.description = this.module.description;
        this.componentId = this.module.id;
        this.externalUrl = this.module.url;
        this.loaded = false;
        this.refreshIcon = 'spinner';
    };
    /**
     * Refresh the data.
     *
     * @param {any} [refresher] Refresher.
     * @param {Function} [done] Function to call when done.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseModuleMainResourceComponent.prototype.doRefresh = function (refresher, done) {
        var _this = this;
        if (this.loaded) {
            this.refreshIcon = 'spinner';
            return this.refreshContent().finally(function () {
                _this.refreshIcon = 'refresh';
                refresher && refresher.complete();
                done && done();
            });
        }
        return Promise.resolve();
    };
    /**
     * Perform the refresh content function.
     *
     * @return {Promise<any>} Resolved when done.
     */
    CoreCourseModuleMainResourceComponent.prototype.refreshContent = function () {
        var _this = this;
        return this.invalidateContent().catch(function () {
            // Ignore errors.
        }).then(function () {
            return _this.loadContent(true);
        });
    };
    /**
     * Perform the invalidate content function.
     *
     * @return {Promise<any>} Resolved when done.
     */
    CoreCourseModuleMainResourceComponent.prototype.invalidateContent = function () {
        return Promise.resolve();
    };
    /**
     * Download the component contents.
     *
     * @param {boolean} [refresh] Whether we're refreshing data.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseModuleMainResourceComponent.prototype.fetchContent = function (refresh) {
        return Promise.resolve();
    };
    /**
     * Loads the component contents and shows the corresponding error.
     *
     * @param {boolean} [refresh] Whether we're refreshing data.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseModuleMainResourceComponent.prototype.loadContent = function (refresh) {
        var _this = this;
        return this.fetchContent(refresh).catch(function (error) {
            // Error getting data, fail.
            _this.domUtils.showErrorModalDefault(error, _this.fetchContentDefaultError, true);
        }).finally(function () {
            _this.loaded = true;
            _this.refreshIcon = 'refresh';
        });
    };
    /**
     * Fill the context menu options
     */
    CoreCourseModuleMainResourceComponent.prototype.fillContextMenu = function (refresh) {
        if (refresh === void 0) { refresh = false; }
        // All data obtained, now fill the context menu.
        this.courseHelper.fillContextMenu(this, this.module, this.courseId, refresh, this.component);
    };
    /**
     * Expand the description.
     */
    CoreCourseModuleMainResourceComponent.prototype.expandDescription = function () {
        this.textUtils.expandText(this.translate.instant('core.description'), this.description, this.component, this.module.id);
    };
    /**
     * Prefetch the module.
     */
    CoreCourseModuleMainResourceComponent.prototype.prefetch = function () {
        this.courseHelper.contextMenuPrefetch(this, this.module, this.courseId);
    };
    /**
     * Confirm and remove downloaded files.
     */
    CoreCourseModuleMainResourceComponent.prototype.removeFiles = function () {
        this.courseHelper.confirmAndRemoveFiles(this.module, this.courseId);
    };
    /**
     * Component being destroyed.
     */
    CoreCourseModuleMainResourceComponent.prototype.ngOnDestroy = function () {
        this.isDestroyed = true;
        this.statusObserver && this.statusObserver.off();
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreCourseModuleMainResourceComponent.prototype, "module", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreCourseModuleMainResourceComponent.prototype, "courseId", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreCourseModuleMainResourceComponent.prototype, "dataRetrieved", void 0);
    return CoreCourseModuleMainResourceComponent;
}());

//# sourceMappingURL=main-resource-component.js.map

/***/ }),
/* 131 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModBookProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_http__ = __webpack_require__(105);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_file__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_filepool__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_text__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__core_course_providers_course__ = __webpack_require__(14);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};










/**
 * Service that provides some features for books.
 */
var AddonModBookProvider = /** @class */ (function () {
    function AddonModBookProvider(logger, sitesProvider, textUtils, fileProvider, filepoolProvider, http, utils, courseProvider, domUtils) {
        this.sitesProvider = sitesProvider;
        this.textUtils = textUtils;
        this.fileProvider = fileProvider;
        this.filepoolProvider = filepoolProvider;
        this.http = http;
        this.utils = utils;
        this.courseProvider = courseProvider;
        this.domUtils = domUtils;
        this.ROOT_CACHE_KEY = 'mmaModBook:';
        this.logger = logger.getInstance('AddonModBookProvider');
    }
    AddonModBookProvider_1 = AddonModBookProvider;
    /**
     * Get a book by course module ID.
     *
     * @param {number} courseId Course ID.
     * @param {number} cmId Course module ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the book is retrieved.
     */
    AddonModBookProvider.prototype.getBook = function (courseId, cmId, siteId) {
        return this.getBookByField(courseId, 'coursemodule', cmId, siteId);
    };
    /**
     * Get a book with key=value. If more than one is found, only the first will be returned.
     *
     * @param {number} courseId Course ID.
     * @param {string} key Name of the property to check.
     * @param {any} value Value to search.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the book is retrieved.
     */
    AddonModBookProvider.prototype.getBookByField = function (courseId, key, value, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                courseids: [courseId]
            }, preSets = {
                cacheKey: _this.getBookDataCacheKey(courseId)
            };
            return site.read('mod_book_get_books_by_courses', params, preSets).then(function (response) {
                // Search the book.
                if (response && response.books) {
                    for (var i in response.books) {
                        var book = response.books[i];
                        if (book[key] == value) {
                            return book;
                        }
                    }
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get cache key for get book data WS calls.
     *
     * @param {number} courseId Course ID.
     * @return {string} Cache key.
     */
    AddonModBookProvider.prototype.getBookDataCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'book:' + courseId;
    };
    /**
     * Gets a chapter contents.
     *
     * @param {AddonModBookContentsMap} contentsMap Contents map returned by getContentsMap.
     * @param {string} chapterId Chapter to retrieve.
     * @param {number} moduleId The module ID.
     * @return {Promise<string>} Promise resolved with the contents.
     */
    AddonModBookProvider.prototype.getChapterContent = function (contentsMap, chapterId, moduleId) {
        var _this = this;
        var indexUrl = contentsMap[chapterId] ? contentsMap[chapterId].indexUrl : undefined, siteId = this.sitesProvider.getCurrentSiteId();
        var promise;
        if (!indexUrl) {
            // It shouldn't happen.
            this.logger.debug('Could not locate the index chapter');
            return Promise.reject(null);
        }
        if (this.fileProvider.isAvailable()) {
            promise = this.filepoolProvider.downloadUrl(siteId, indexUrl, false, AddonModBookProvider_1.COMPONENT, moduleId);
        }
        else {
            // We return the live URL.
            return Promise.resolve(this.sitesProvider.getCurrentSite().fixPluginfileURL(indexUrl));
        }
        return promise.then(function (url) {
            // Fetch the URL content.
            var promise = _this.http.get(url).toPromise();
            return promise.then(function (response) {
                var content = response.text();
                if (typeof content !== 'string') {
                    return Promise.reject(null);
                }
                else {
                    // Now that we have the content, we update the SRC to point back to the external resource.
                    return _this.domUtils.restoreSourcesInHtml(content, contentsMap[chapterId].paths);
                }
            });
        });
    };
    /**
     * Convert an array of book contents into an object where contents are organized in chapters.
     * Each chapter has an indexUrl and the list of contents in that chapter.
     *
     * @param {any[]} contents The module contents.
     * @return {AddonModBookContentsMap} Contents map.
     */
    AddonModBookProvider.prototype.getContentsMap = function (contents) {
        var _this = this;
        var map = {};
        if (!contents) {
            return map;
        }
        contents.forEach(function (content) {
            if (_this.isFileDownloadable(content)) {
                var chapter = void 0, matches = void 0, split = void 0, filepathIsChapter = void 0, key = void 0;
                // Search the chapter number in the filepath.
                matches = content.filepath.match(/\/(\d+)\//);
                if (matches && matches[1]) {
                    chapter = matches[1];
                    filepathIsChapter = content.filepath == '/' + chapter + '/';
                    // Init the chapter if it's not defined yet.
                    map[chapter] = map[chapter] || { paths: {} };
                    if (content.filename == 'index.html' && filepathIsChapter) {
                        // Index of the chapter, set indexUrl of the chapter.
                        map[chapter].indexUrl = content.fileurl;
                    }
                    else {
                        if (filepathIsChapter) {
                            // It's a file in the root folder OR the WS isn't returning the filepath as it should (MDL-53671).
                            // Try to get the path to the file from the URL.
                            split = content.fileurl.split('mod_book/chapter' + content.filepath);
                            key = split[1] || content.filename; // Use filename if we couldn't find the path.
                        }
                        else {
                            // Remove the chapter folder from the path and add the filename.
                            key = content.filepath.replace('/' + chapter + '/', '') + content.filename;
                        }
                        map[chapter].paths[_this.textUtils.decodeURIComponent(key)] = content.fileurl;
                    }
                }
            }
        });
        return map;
    };
    /**
     * Get the first chapter of a book.
     *
     * @param {AddonModBookTocChapter[]} chapters The chapters list.
     * @return {string} The chapter id.
     */
    AddonModBookProvider.prototype.getFirstChapter = function (chapters) {
        if (!chapters || !chapters.length) {
            return;
        }
        return chapters[0].id;
    };
    /**
     * Get the next chapter to the given one.
     *
     * @param {AddonModBookTocChapter[]} chapters The chapters list.
     * @param {string} chapterId The current chapter.
     * @return {string} The next chapter id.
     */
    AddonModBookProvider.prototype.getNextChapter = function (chapters, chapterId) {
        var next = '0';
        for (var i = 0; i < chapters.length; i++) {
            if (chapters[i].id == chapterId) {
                if (typeof chapters[i + 1] != 'undefined') {
                    next = chapters[i + 1].id;
                    break;
                }
            }
        }
        return next;
    };
    /**
     * Get the previous chapter to the given one.
     *
     * @param {AddonModBookTocChapter[]} chapters The chapters list.
     * @param {string} chapterId The current chapter.
     * @return {string} The next chapter id.
     */
    AddonModBookProvider.prototype.getPreviousChapter = function (chapters, chapterId) {
        var previous = '0';
        for (var i = 0; i < chapters.length; i++) {
            if (chapters[i].id == chapterId) {
                break;
            }
            previous = chapters[i].id;
        }
        return previous;
    };
    /**
     * Get the book toc as an array.
     *
     * @param {any[]} contents The module contents.
     * @return {any[]} The toc.
     */
    AddonModBookProvider.prototype.getToc = function (contents) {
        if (!contents || !contents.length) {
            return [];
        }
        return this.textUtils.parseJSON(contents[0].content, []);
    };
    /**
     * Get the book toc as an array of chapters (not nested).
     *
     * @param {any[]} contents The module contents.
     * @return {AddonModBookTocChapter[]} The toc as a list.
     */
    AddonModBookProvider.prototype.getTocList = function (contents) {
        var chapters = [], toc = this.getToc(contents);
        toc.forEach(function (chapter) {
            // Add the chapter to the list.
            var chapterId = chapter.href.replace('/index.html', '');
            chapters.push({ id: chapterId, title: chapter.title, level: chapter.level });
            if (chapter.subitems) {
                // Add all the subchapters to the list.
                chapter.subitems.forEach(function (subChapter) {
                    chapterId = subChapter.href.replace('/index.html', '');
                    chapters.push({ id: chapterId, title: subChapter.title, level: subChapter.level });
                });
            }
        });
        return chapters;
    };
    /**
     * Invalidates book data.
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModBookProvider.prototype.invalidateBookData = function (courseId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getBookDataCacheKey(courseId));
        });
    };
    /**
     * Invalidate the prefetched content.
     *
     * @param {number} moduleId The module ID.
     * @param {number} courseId Course ID of the module.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModBookProvider.prototype.invalidateContent = function (moduleId, courseId, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var promises = [];
        promises.push(this.invalidateBookData(courseId, siteId));
        promises.push(this.filepoolProvider.invalidateFilesByComponent(siteId, AddonModBookProvider_1.COMPONENT, moduleId));
        promises.push(this.courseProvider.invalidateModule(moduleId, siteId));
        return this.utils.allPromises(promises);
    };
    /**
     * Check if a file is downloadable. The file param must have a 'type' attribute like in core_course_get_contents response.
     *
     * @param {any} file File to check.
     * @return {boolean} Whether it's downloadable.
     */
    AddonModBookProvider.prototype.isFileDownloadable = function (file) {
        return file.type === 'file';
    };
    /**
     * Return whether or not the plugin is enabled.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with true if plugin is enabled, rejected or resolved with false otherwise.
     */
    AddonModBookProvider.prototype.isPluginEnabled = function (siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.canDownloadFiles();
        });
    };
    /**
     * Report a book as being viewed.
     *
     * @param {number} id Module ID.
     * @param {string} chapterId Chapter ID.
     * @return {Promise<any>} Promise resolved when the WS call is successful.
     */
    AddonModBookProvider.prototype.logView = function (id, chapterId) {
        var params = {
            bookid: id,
            chapterid: chapterId
        };
        return this.sitesProvider.getCurrentSite().write('mod_book_view_book', params);
    };
    AddonModBookProvider.COMPONENT = 'mmaModBook';
    AddonModBookProvider = AddonModBookProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_7__providers_utils_text__["a" /* CoreTextUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_2__providers_file__["a" /* CoreFileProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_filepool__["a" /* CoreFilepoolProvider */], __WEBPACK_IMPORTED_MODULE_1__angular_http__["a" /* Http */],
            __WEBPACK_IMPORTED_MODULE_8__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_9__core_course_providers_course__["a" /* CoreCourseProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_utils_dom__["a" /* CoreDomUtilsProvider */]])
    ], AddonModBookProvider);
    return AddonModBookProvider;
    var AddonModBookProvider_1;
}());

//# sourceMappingURL=book.js.map

/***/ }),
/* 132 */,
/* 133 */,
/* 134 */,
/* 135 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonBadgesProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(3);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Service to handle badges.
 */
var AddonBadgesProvider = /** @class */ (function () {
    function AddonBadgesProvider(logger, sitesProvider) {
        this.sitesProvider = sitesProvider;
        this.ROOT_CACHE_KEY = 'mmaBadges:';
        this.logger = logger.getInstance('AddonBadgesProvider');
    }
    /**
     * Returns whether or not the badge plugin is enabled for a certain site.
     *
     * This method is called quite often and thus should only perform a quick
     * check, we should not be calling WS from here.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with true if enabled, false otherwise.
     */
    AddonBadgesProvider.prototype.isPluginEnabled = function (siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            if (!site.canUseAdvancedFeature('enablebadges')) {
                return false;
            }
            else if (!site.wsAvailable('core_course_get_user_navigation_options')) {
                return false;
            }
            return true;
        });
    };
    /**
     * Get the cache key for the get badges call.
     *
     * @param {number} courseId ID of the course to get the badges from.
     * @param {number} userId ID of the user to get the badges from.
     * @return {string} Cache key.
     */
    AddonBadgesProvider.prototype.getBadgesCacheKey = function (courseId, userId) {
        return this.ROOT_CACHE_KEY + 'badges:' + courseId + ':' + userId;
    };
    /**
     * Get issued badges for a certain user in a course.
     *
     * @param {number} courseId ID of the course to get the badges from.
     * @param {number} userId ID of the user to get the badges from.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}Promise to be resolved when the badges are retrieved.
     */
    AddonBadgesProvider.prototype.getUserBadges = function (courseId, userId, siteId) {
        var _this = this;
        this.logger.debug('Get badges for course ' + courseId);
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var data = {
                courseid: courseId,
                userid: userId
            }, presets = {
                cacheKey: _this.getBadgesCacheKey(courseId, userId)
            };
            return site.read('core_badges_get_user_badges', data, presets).then(function (response) {
                if (response && response.badges) {
                    return response.badges;
                }
                else {
                    return Promise.reject(null);
                }
            });
        });
    };
    /**
     * Invalidate get badges WS call.
     *
     * @param {number} courseId Course ID.
     * @param {number} userId ID of the user to get the badges from.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when data is invalidated.
     */
    AddonBadgesProvider.prototype.invalidateUserBadges = function (courseId, userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getBadgesCacheKey(courseId, userId));
        });
    };
    AddonBadgesProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */]])
    ], AddonBadgesProvider);
    return AddonBadgesProvider;
}());

//# sourceMappingURL=badges.js.map

/***/ }),
/* 136 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonPushNotificationsDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_rxjs__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Service to handle push notifications actions to perform when clicked and received.
 */
var AddonPushNotificationsDelegate = /** @class */ (function () {
    function AddonPushNotificationsDelegate(loggerProvider) {
        this.observables = {};
        this.counterHandlers = {};
        this.logger = loggerProvider.getInstance('AddonPushNotificationsDelegate');
        this.observables['click'] = new __WEBPACK_IMPORTED_MODULE_2_rxjs__["Subject"]();
        this.observables['receive'] = new __WEBPACK_IMPORTED_MODULE_2_rxjs__["Subject"]();
    }
    /**
     * Function called when a push notification is clicked. Sends notification to handlers.
     *
     * @param {any} notification Notification clicked.
     */
    AddonPushNotificationsDelegate.prototype.clicked = function (notification) {
        this.observables['click'].next(notification);
    };
    /**
     * Function called when a push notification is received in foreground (cannot tell when it's received in background).
     * Sends notification to all handlers.
     *
     * @param {any} notification Notification received.
     */
    AddonPushNotificationsDelegate.prototype.received = function (notification) {
        this.observables['receive'].next(notification);
    };
    /**
     * Register a push notifications observable for click and receive notification event.
     * When a notification is clicked or received, the observable will receive a notification to treat.
     * let observer = pushNotificationsDelegate.on('click').subscribe((notification) => {
     * ...
     * observer.unsuscribe();
     *
     * @param {string}  eventName Only click and receive are permitted.
     * @return {Subject<any>} Observer to subscribe.
     */
    AddonPushNotificationsDelegate.prototype.on = function (eventName) {
        if (typeof this.observables[eventName] == 'undefined') {
            var eventNames = Object.keys(this.observables).join(', ');
            this.logger.warn("'" + eventName + "' event name is not allowed. Use one of the following: '" + eventNames + "'.");
            return new __WEBPACK_IMPORTED_MODULE_2_rxjs__["Subject"]();
        }
        return this.observables[eventName];
    };
    /**
     * Register a push notifications handler for update badge counter.
     *
     * @param {string} name  Handler's name.
     */
    AddonPushNotificationsDelegate.prototype.registerCounterHandler = function (name) {
        if (typeof this.counterHandlers[name] == 'undefined') {
            this.logger.debug("Registered handler '" + name + "' as badge counter handler.");
            this.counterHandlers[name] = name;
        }
        else {
            this.logger.log("Handler '" + name + "' as badge counter handler already registered.");
        }
    };
    /**
     * Check if a counter handler is present.
     *
     * @param {string} name       Handler's name.
     * @return {boolean}  If handler name is present.
     */
    AddonPushNotificationsDelegate.prototype.isCounterHandlerRegistered = function (name) {
        return typeof this.counterHandlers[name] != 'undefined';
    };
    /**
     * Get all counter badge handlers.
     *
     * @return {any}  with all the handler names.
     */
    AddonPushNotificationsDelegate.prototype.getCounterHandlers = function () {
        return this.counterHandlers;
    };
    AddonPushNotificationsDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */]])
    ], AddonPushNotificationsDelegate);
    return AddonPushNotificationsDelegate;
}());

//# sourceMappingURL=delegate.js.map

/***/ }),
/* 137 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreWSProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_http__ = __webpack_require__(105);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_common_http__ = __webpack_require__(104);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ionic_native_file_transfer__ = __webpack_require__(240);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__file__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__utils_mimetype__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__utils_text__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__core_constants__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_ts_md5_dist_md5__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_ts_md5_dist_md5___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12_ts_md5_dist_md5__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__classes_interceptor__ = __webpack_require__(582);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};














/**
 * This service allows performing WS calls and download/upload files.
 */
var CoreWSProvider = /** @class */ (function () {
    function CoreWSProvider(http, translate, appProvider, textUtils, logger, utils, fileProvider, fileTransfer, commonHttp, mimeUtils) {
        this.http = http;
        this.translate = translate;
        this.appProvider = appProvider;
        this.textUtils = textUtils;
        this.utils = utils;
        this.fileProvider = fileProvider;
        this.fileTransfer = fileTransfer;
        this.commonHttp = commonHttp;
        this.mimeUtils = mimeUtils;
        this.mimeTypeCache = {}; // A "cache" to store file mimetypes to prevent performing too many HEAD requests.
        this.ongoingCalls = {};
        this.retryCalls = [];
        this.retryTimeout = 0;
        this.logger = logger.getInstance('CoreWSProvider');
    }
    /**
     * Adds the call data to an special queue to be processed when retrying.
     *
     * @param {string} method The WebService method to be called.
     * @param {string} siteUrl Complete site url to perform the call.
     * @param {any} ajaxData Arguments to pass to the method.
     * @param {CoreWSPreSets} preSets Extra settings and information.
     * @return {Promise<any>} Deferred promise resolved with the response data in success and rejected with the error message
     *                        if it fails.
     */
    CoreWSProvider.prototype.addToRetryQueue = function (method, siteUrl, ajaxData, preSets) {
        var call = {
            method: method,
            siteUrl: siteUrl,
            ajaxData: ajaxData,
            preSets: preSets,
            deferred: this.utils.promiseDefer(),
        };
        this.retryCalls.push(call);
        return call.deferred.promise;
    };
    /**
     * A wrapper function for a moodle WebService call.
     *
     * @param {string} method The WebService method to be called.
     * @param {any} data Arguments to pass to the method. It's recommended to call convertValuesToString before passing the data.
     * @param {CoreWSPreSets} preSets Extra settings and information.
     * @return {Promise<any>} Promise resolved with the response data in success and rejected if it fails.
     */
    CoreWSProvider.prototype.call = function (method, data, preSets) {
        var siteUrl;
        if (!preSets) {
            return Promise.reject(this.utils.createFakeWSError('core.unexpectederror', true));
        }
        else if (!this.appProvider.isOnline()) {
            return Promise.reject(this.utils.createFakeWSError('core.networkerrormsg', true));
        }
        preSets.typeExpected = preSets.typeExpected || 'object';
        if (typeof preSets.responseExpected == 'undefined') {
            preSets.responseExpected = true;
        }
        data = data || {};
        data = this.utils.clone(data); // Clone the data so the changes don't affect the original data.
        data.wsfunction = method;
        data.wstoken = preSets.wsToken;
        siteUrl = preSets.siteUrl + '/webservice/rest/server.php?moodlewsrestformat=json';
        var promise = this.getPromiseHttp('post', preSets.siteUrl, data);
        if (!promise) {
            // There are some ongoing retry calls, wait for timeout.
            if (this.retryCalls.length > 0) {
                this.logger.warn('Calls locked, trying later...');
                promise = this.addToRetryQueue(method, siteUrl, data, preSets);
            }
            else {
                promise = this.performPost(method, siteUrl, data, preSets);
            }
        }
        return promise;
    };
    /**
     * Call a Moodle WS using the AJAX API. Please use it if the WS layer is not an option.
     *
     * @param {string} method The WebService method to be called.
     * @param {any} data Arguments to pass to the method.
     * @param {CoreWSAjaxPreSets} preSets Extra settings and information. Only some
     * @return {Promise<any>} Promise resolved with the response data in success and rejected with an object containing:
     *                                 - error: Error message.
     *                                 - errorcode: Error code returned by the site (if any).
     *                                 - available: 0 if unknown, 1 if available, -1 if not available.
     */
    CoreWSProvider.prototype.callAjax = function (method, data, preSets) {
        var _this = this;
        var siteUrl, ajaxData;
        if (typeof preSets.siteUrl == 'undefined') {
            return rejectWithError(this.translate.instant('core.unexpectederror'));
        }
        else if (!this.appProvider.isOnline()) {
            return rejectWithError(this.translate.instant('core.networkerrormsg'));
        }
        if (typeof preSets.responseExpected == 'undefined') {
            preSets.responseExpected = true;
        }
        ajaxData = [{
                index: 0,
                methodname: method,
                args: this.convertValuesToString(data)
            }];
        siteUrl = preSets.siteUrl + '/lib/ajax/service.php';
        var promise = this.http.post(siteUrl, JSON.stringify(ajaxData)).timeout(__WEBPACK_IMPORTED_MODULE_11__core_constants__["a" /* CoreConstants */].WS_TIMEOUT).toPromise();
        return promise.then(function (data) {
            // Some moodle web services return null.
            // If the responseExpected value is set then so long as no data is returned, we create a blank object.
            if (!data && !preSets.responseExpected) {
                data = [{}];
            }
            // Check if error. Ajax layer should always return an object (if error) or an array (if success).
            if (!data || typeof data != 'object') {
                return rejectWithError(_this.translate.instant('core.serverconnection'));
            }
            else if (data.error) {
                return rejectWithError(data.error, data.errorcode);
            }
            // Get the first response since only one request was done.
            data = data[0];
            if (data.error) {
                return rejectWithError(data.exception.message, data.exception.errorcode);
            }
            return data.data;
        }, function (data) {
            var available = data.status == 404 ? -1 : 0;
            return rejectWithError(_this.translate.instant('core.serverconnection'), '', available);
        });
        // Convenience function to return an error.
        function rejectWithError(message, code, available) {
            if (typeof available == 'undefined') {
                if (code) {
                    available = code == 'invalidrecord' ? -1 : 1;
                }
                else {
                    available = 0;
                }
            }
            return Promise.reject({
                error: message,
                errorcode: code,
                available: available
            });
        }
    };
    /**
     * Converts an objects values to strings where appropriate.
     * Arrays (associative or otherwise) will be maintained.
     *
     * @param {object} data The data that needs all the non-object values set to strings.
     * @param {boolean} [stripUnicode] If Unicode long chars need to be stripped.
     * @return {object} The cleaned object, with multilevel array and objects preserved.
     */
    CoreWSProvider.prototype.convertValuesToString = function (data, stripUnicode) {
        var result;
        if (!Array.isArray(data) && typeof data == 'object') {
            result = {};
        }
        else {
            result = [];
        }
        for (var el in data) {
            if (typeof data[el] == 'object') {
                result[el] = this.convertValuesToString(data[el], stripUnicode);
            }
            else {
                if (typeof data[el] == 'string') {
                    result[el] = stripUnicode ? this.textUtils.stripUnicode(data[el]) : data[el];
                    if (stripUnicode && data[el] != result[el] && result[el].trim().length == 0) {
                        throw new Error();
                    }
                }
                else {
                    result[el] = data[el] + '';
                }
            }
        }
        return result;
    };
    /**
     * Downloads a file from Moodle using Cordova File API.
     *
     * @param {string} url Download url.
     * @param {string} path Local path to store the file.
     * @param {boolean} [addExtension] True if extension need to be added to the final path.
     * @param {Function} [onProgress] Function to call on progress.
     * @return {Promise<any>} Promise resolved with the downloaded file.
     */
    CoreWSProvider.prototype.downloadFile = function (url, path, addExtension, onProgress) {
        var _this = this;
        this.logger.debug('Downloading file', url, path, addExtension);
        if (!this.appProvider.isOnline()) {
            return Promise.reject(this.translate.instant('core.networkerrormsg'));
        }
        // Use a tmp path to download the file and then move it to final location.
        // This is because if the download fails, the local file is deleted.
        var tmpPath = path + '.tmp';
        // Create the tmp file as an empty file.
        return this.fileProvider.createFile(tmpPath).then(function (fileEntry) {
            var transfer = _this.fileTransfer.create();
            transfer.onProgress(onProgress);
            return transfer.download(url, fileEntry.toURL(), true).then(function () {
                var promise;
                if (addExtension) {
                    var ext_1 = _this.mimeUtils.getFileExtension(path);
                    // Google Drive extensions will be considered invalid since Moodle usually converts them.
                    if (!ext_1 || ext_1 == 'gdoc' || ext_1 == 'gsheet' || ext_1 == 'gslides' || ext_1 == 'gdraw') {
                        // Not valid, get the file's mimetype.
                        promise = _this.getRemoteFileMimeType(url).then(function (mime) {
                            if (mime) {
                                var remoteExt = _this.mimeUtils.getExtension(mime, url);
                                // If the file is from Google Drive, ignore mimetype application/json.
                                if (remoteExt && (!ext_1 || mime != 'application/json')) {
                                    if (ext_1) {
                                        // Remove existing extension since we will use another one.
                                        path = _this.mimeUtils.removeExtension(path);
                                    }
                                    path += '.' + remoteExt;
                                    return remoteExt;
                                }
                            }
                            return ext_1;
                        });
                    }
                    else {
                        promise = Promise.resolve(ext_1);
                    }
                }
                else {
                    promise = Promise.resolve('');
                }
                return promise.then(function (extension) {
                    return _this.fileProvider.moveFile(tmpPath, path).then(function (movedEntry) {
                        // Save the extension.
                        movedEntry.extension = extension;
                        movedEntry.path = path;
                        _this.logger.debug("Success downloading file " + url + " to " + path + " with extension " + extension);
                        return movedEntry;
                    });
                });
            });
        }).catch(function (err) {
            _this.logger.error("Error downloading " + url + " to " + path, err);
            return Promise.reject(err);
        });
    };
    /**
     * Get a promise from the cache.
     *
     * @param {string} method Method of the HTTP request.
     * @param {string} url Base URL of the HTTP request.
     * @param {any} [params] Params of the HTTP request.
     */
    CoreWSProvider.prototype.getPromiseHttp = function (method, url, params) {
        var queueItemId = this.getQueueItemId(method, url, params);
        if (typeof this.ongoingCalls[queueItemId] != 'undefined') {
            return this.ongoingCalls[queueItemId];
        }
        return false;
    };
    /**
     * Perform a HEAD request to get the mimetype of a remote file.
     *
     * @param {string} url File URL.
     * @param {boolean} [ignoreCache] True to ignore cache, false otherwise.
     * @return {Promise<string>} Promise resolved with the mimetype or '' if failure.
     */
    CoreWSProvider.prototype.getRemoteFileMimeType = function (url, ignoreCache) {
        var _this = this;
        if (this.mimeTypeCache[url] && !ignoreCache) {
            return Promise.resolve(this.mimeTypeCache[url]);
        }
        return this.performHead(url).then(function (data) {
            var mimeType = data.headers.get('Content-Type');
            if (mimeType) {
                // Remove "parameters" like charset.
                mimeType = mimeType.split(';')[0];
            }
            _this.mimeTypeCache[url] = mimeType;
            return mimeType || '';
        }).catch(function () {
            // Error, resolve with empty mimetype.
            return '';
        });
    };
    /**
     * Perform a HEAD request to get the size of a remote file.
     *
     * @param {string} url File URL.
     * @return {Promise<number>} Promise resolved with the size or -1 if failure.
     */
    CoreWSProvider.prototype.getRemoteFileSize = function (url) {
        return this.performHead(url).then(function (data) {
            var size = parseInt(data.headers.get('Content-Length'), 10);
            if (size) {
                return size;
            }
            return -1;
        }).catch(function () {
            // Error, return -1.
            return -1;
        });
    };
    /**
     * Get the unique queue item id of the cache for a HTTP request.
     *
     * @param {string} method Method of the HTTP request.
     * @param {string} url Base URL of the HTTP request.
     * @param {object} [params] Params of the HTTP request.
     * @return {string} Queue item ID.
     */
    CoreWSProvider.prototype.getQueueItemId = function (method, url, params) {
        if (params) {
            url += '###' + __WEBPACK_IMPORTED_MODULE_13__classes_interceptor__["a" /* CoreInterceptor */].serialize(params);
        }
        return method + '#' + __WEBPACK_IMPORTED_MODULE_12_ts_md5_dist_md5__["Md5"].hashAsciiStr(url);
    };
    /**
     * Perform a HEAD request and save the promise while waiting to be resolved.
     *
     * @param {string} url URL to perform the request.
     * @return {Promise<any>} Promise resolved with the response.
     */
    CoreWSProvider.prototype.performHead = function (url) {
        var promise = this.getPromiseHttp('head', url);
        if (!promise) {
            promise = this.commonHttp.head(url).timeout(__WEBPACK_IMPORTED_MODULE_11__core_constants__["a" /* CoreConstants */].WS_TIMEOUT).toPromise();
            promise = this.setPromiseHttp(promise, 'head', url);
        }
        return promise;
    };
    /**
     * Perform the post call and save the promise while waiting to be resolved.
     *
     * @param {string} method The WebService method to be called.
     * @param {string} siteUrl Complete site url to perform the call.
     * @param {any} ajaxData Arguments to pass to the method.
     * @param {CoreWSPreSets} preSets Extra settings and information.
     * @return {Promise<any>} Promise resolved with the response data in success and rejected with CoreWSError if it fails.
     */
    CoreWSProvider.prototype.performPost = function (method, siteUrl, ajaxData, preSets) {
        var _this = this;
        var options = {};
        // This is done because some returned values like 0 are treated as null if responseType is json.
        if (preSets.typeExpected == 'number' || preSets.typeExpected == 'boolean' || preSets.typeExpected == 'string') {
            // Avalaible values are: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType
            options['responseType'] = 'text';
        }
        // Perform the post request.
        var promise = this.http.post(siteUrl, ajaxData, options).timeout(__WEBPACK_IMPORTED_MODULE_11__core_constants__["a" /* CoreConstants */].WS_TIMEOUT).toPromise();
        promise = promise.then(function (data) {
            // Some moodle web services return null.
            // If the responseExpected value is set to false, we create a blank object if the response is null.
            if (!data && !preSets.responseExpected) {
                data = {};
            }
            if (!data) {
                return Promise.reject(_this.utils.createFakeWSError('core.serverconnection', true));
            }
            else if (typeof data != preSets.typeExpected) {
                // If responseType is text an string will be returned, parse before returning.
                if (typeof data == 'string') {
                    if (preSets.typeExpected == 'number') {
                        data = Number(data);
                        if (isNaN(data)) {
                            _this.logger.warn("Response expected type \"" + preSets.typeExpected + "\" cannot be parsed to number");
                            return Promise.reject(_this.utils.createFakeWSError('core.errorinvalidresponse', true));
                        }
                    }
                    else if (preSets.typeExpected == 'boolean') {
                        if (data === 'true') {
                            data = true;
                        }
                        else if (data === 'false') {
                            data = false;
                        }
                        else {
                            _this.logger.warn("Response expected type \"" + preSets.typeExpected + "\" is not true or false");
                            return Promise.reject(_this.utils.createFakeWSError('core.errorinvalidresponse', true));
                        }
                    }
                    else {
                        _this.logger.warn('Response of type "' + typeof data + ("\" received, expecting \"" + preSets.typeExpected + "\""));
                        return Promise.reject(_this.utils.createFakeWSError('core.errorinvalidresponse', true));
                    }
                }
                else {
                    _this.logger.warn('Response of type "' + typeof data + ("\" received, expecting \"" + preSets.typeExpected + "\""));
                    return Promise.reject(_this.utils.createFakeWSError('core.errorinvalidresponse', true));
                }
            }
            if (typeof data.exception !== 'undefined') {
                // Special debugging for site plugins, otherwise it's hard to debug errors if the data is cached.
                if (method == 'tool_mobile_get_content') {
                    _this.logger.error('Error calling WS', method, data);
                }
                return Promise.reject(data);
            }
            if (typeof data.debuginfo != 'undefined') {
                return Promise.reject(_this.utils.createFakeWSError('Error. ' + data.message));
            }
            return data;
        }, function (error) {
            // If server has heavy load, retry after some seconds.
            if (error.status == 429) {
                var retryPromise = _this.addToRetryQueue(method, siteUrl, ajaxData, preSets);
                // Only process the queue one time.
                if (_this.retryTimeout == 0) {
                    _this.retryTimeout = parseInt(error.headers.get('Retry-After'), 10) || 5;
                    _this.logger.warn(error.statusText + ". Retrying in " + _this.retryTimeout + " seconds. " +
                        (_this.retryCalls.length + " calls left."));
                    setTimeout(function () {
                        _this.logger.warn("Retrying now with " + _this.retryCalls.length + " calls to process.");
                        // Finish timeout.
                        _this.retryTimeout = 0;
                        _this.processRetryQueue();
                    }, _this.retryTimeout * 1000);
                }
                else {
                    _this.logger.warn('Calls locked, trying later...');
                }
                return retryPromise;
            }
            return Promise.reject(_this.utils.createFakeWSError('core.serverconnection', true));
        });
        promise = this.setPromiseHttp(promise, 'post', preSets.siteUrl, ajaxData);
        return promise;
    };
    /**
     * Retry all requests in the queue.
     * This function uses recursion in order to add a delay between requests to reduce stress.
     */
    CoreWSProvider.prototype.processRetryQueue = function () {
        var _this = this;
        if (this.retryCalls.length > 0 && this.retryTimeout == 0) {
            var call_1 = this.retryCalls.shift();
            // Add a delay between calls.
            setTimeout(function () {
                call_1.deferred.resolve(_this.performPost(call_1.method, call_1.siteUrl, call_1.ajaxData, call_1.preSets));
                _this.processRetryQueue();
            }, 200);
        }
        else {
            this.logger.warn("Retry queue has stopped with " + this.retryCalls.length + " calls and " + this.retryTimeout + " timeout secs.");
        }
    };
    /**
     * Save promise on the cache.
     *
     * @param {Promise<any>} promise Promise to be saved.
     * @param {string} method Method of the HTTP request.
     * @param {string} url Base URL of the HTTP request.
     * @param {any} [params] Params of the HTTP request.
     * @return {Promise<any>} The promise saved.
     */
    CoreWSProvider.prototype.setPromiseHttp = function (promise, method, url, params) {
        var _this = this;
        var queueItemId = this.getQueueItemId(method, url, params);
        var timeout;
        this.ongoingCalls[queueItemId] = promise;
        // HTTP not finished, but we should delete the promise after timeout.
        timeout = setTimeout(function () {
            delete _this.ongoingCalls[queueItemId];
        }, __WEBPACK_IMPORTED_MODULE_11__core_constants__["a" /* CoreConstants */].WS_TIMEOUT);
        // HTTP finished, delete from ongoing.
        return promise.finally(function () {
            delete _this.ongoingCalls[queueItemId];
            clearTimeout(timeout);
        });
    };
    /**
     * A wrapper function for a synchronous Moodle WebService call.
     * Warning: This function should only be used if synchronous is a must. It's recommended to use call.
     *
     * @param {string} method The WebService method to be called.
     * @param {any} data Arguments to pass to the method.
     * @param {CoreWSPreSets} preSets Extra settings and information.
     * @return {Promise} Promise resolved with the response data in success and rejected with the error message if it fails.
     * @return {any} Request response. If the request fails, returns an object with 'error'=true and 'message' properties.
     */
    CoreWSProvider.prototype.syncCall = function (method, data, preSets) {
        var errorResponse = {
            error: true,
            message: ''
        };
        var siteUrl, xhr;
        if (!preSets) {
            errorResponse.message = this.translate.instant('core.unexpectederror');
            return errorResponse;
        }
        else if (!this.appProvider.isOnline()) {
            errorResponse.message = this.translate.instant('core.networkerrormsg');
            return errorResponse;
        }
        preSets.typeExpected = preSets.typeExpected || 'object';
        if (typeof preSets.responseExpected == 'undefined') {
            preSets.responseExpected = true;
        }
        try {
            data = this.convertValuesToString(data, preSets.cleanUnicode);
        }
        catch (e) {
            // Empty cleaned text found.
            errorResponse.message = this.translate.instant('core.unicodenotsupportedcleanerror');
            return errorResponse;
        }
        data.wsfunction = method;
        data.wstoken = preSets.wsToken;
        siteUrl = preSets.siteUrl + '/webservice/rest/server.php?moodlewsrestformat=json';
        // Serialize data.
        data = __WEBPACK_IMPORTED_MODULE_13__classes_interceptor__["a" /* CoreInterceptor */].serialize(data);
        // Perform sync request using XMLHttpRequest.
        xhr = new window.XMLHttpRequest();
        xhr.open('post', siteUrl, false);
        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded;charset=utf-8');
        xhr.send(data);
        // Get response.
        data = ('response' in xhr) ? xhr.response : xhr.responseText;
        // Check status.
        xhr.status = Math.max(xhr.status === 1223 ? 204 : xhr.status, 0);
        if (xhr.status < 200 || xhr.status >= 300) {
            // Request failed.
            errorResponse.message = data;
            return errorResponse;
        }
        // Treat response.
        data = this.textUtils.parseJSON(data);
        // Some moodle web services return null.
        // If the responseExpected value is set then so long as no data is returned, we create a blank object.
        if ((!data || !data.data) && !preSets.responseExpected) {
            data = {};
        }
        if (!data) {
            errorResponse.message = this.translate.instant('core.serverconnection');
        }
        else if (typeof data != preSets.typeExpected) {
            this.logger.warn('Response of type "' + typeof data + '" received, expecting "' + preSets.typeExpected + '"');
            errorResponse.message = this.translate.instant('core.errorinvalidresponse');
        }
        if (typeof data.exception != 'undefined' || typeof data.debuginfo != 'undefined') {
            errorResponse.message = data.message;
        }
        if (errorResponse.message !== '') {
            return errorResponse;
        }
        return data;
    };
    /*
     * Uploads a file.
     *
     * @param {string} filePath File path.
     * @param {CoreWSFileUploadOptions} options File upload options.
     * @param {CoreWSPreSets} preSets Must contain siteUrl and wsToken.
     * @param {Function} [onProgress] Function to call on progress.
     * @return {Promise<any>} Promise resolved when uploaded.
     */
    CoreWSProvider.prototype.uploadFile = function (filePath, options, preSets, onProgress) {
        var _this = this;
        this.logger.debug("Trying to upload file: " + filePath);
        if (!filePath || !options || !preSets) {
            return Promise.reject(null);
        }
        if (!this.appProvider.isOnline()) {
            return Promise.reject(this.translate.instant('core.networkerrormsg'));
        }
        var uploadUrl = preSets.siteUrl + '/webservice/upload.php', transfer = this.fileTransfer.create();
        transfer.onProgress(onProgress);
        options.httpMethod = 'POST';
        options.params = {
            token: preSets.wsToken,
            filearea: options.fileArea || 'draft',
            itemid: options.itemId || 0
        };
        options.chunkedMode = false;
        options.headers = {
            Connection: 'close'
        };
        return transfer.upload(filePath, uploadUrl, options, true).then(function (success) {
            var data = _this.textUtils.parseJSON(success.response, null, _this.logger.error.bind(_this.logger, 'Error parsing response from upload'));
            if (data === null) {
                return Promise.reject(_this.translate.instant('core.errorinvalidresponse'));
            }
            if (!data) {
                return Promise.reject(_this.translate.instant('core.serverconnection'));
            }
            else if (typeof data != 'object') {
                _this.logger.warn('Upload file: Response of type "' + typeof data + '" received, expecting "object"');
                return Promise.reject(_this.translate.instant('core.errorinvalidresponse'));
            }
            if (typeof data.exception !== 'undefined') {
                return Promise.reject(data.message);
            }
            else if (data && typeof data.error !== 'undefined') {
                return Promise.reject(data.error);
            }
            else if (data[0] && typeof data[0].error !== 'undefined') {
                return Promise.reject(data[0].error);
            }
            // We uploaded only 1 file, so we only return the first file returned.
            _this.logger.debug('Successfully uploaded file', filePath);
            return data[0];
        }).catch(function (error) {
            _this.logger.error('Error while uploading file', filePath, error);
            return Promise.reject(_this.translate.instant('core.errorinvalidresponse'));
        });
    };
    CoreWSProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__angular_common_http__["b" /* HttpClient */], __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_5__app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_9__utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_7__logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_10__utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_6__file__["a" /* CoreFileProvider */], __WEBPACK_IMPORTED_MODULE_4__ionic_native_file_transfer__["a" /* FileTransfer */], __WEBPACK_IMPORTED_MODULE_1__angular_http__["a" /* Http */],
            __WEBPACK_IMPORTED_MODULE_8__utils_mimetype__["a" /* CoreMimetypeUtilsProvider */]])
    ], CoreWSProvider);
    return CoreWSProvider;
}());

//# sourceMappingURL=ws.js.map

/***/ }),
/* 138 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSiteHomeProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_course_providers_course__ = __webpack_require__(14);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Service that provides some features regarding site home.
 */
var CoreSiteHomeProvider = /** @class */ (function () {
    function CoreSiteHomeProvider(logger, sitesProvider, courseProvider) {
        this.sitesProvider = sitesProvider;
        this.courseProvider = courseProvider;
        this.logger = logger.getInstance('CoreSiteHomeProvider');
    }
    /**
     * Returns whether or not the frontpage is available for the current site.
     *
     * @param {string} [siteId] The site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with boolean: whether it's available.
     */
    CoreSiteHomeProvider.prototype.isAvailable = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            // First check if it's disabled.
            if (_this.isDisabledInSite(site)) {
                return false;
            }
            // Use a WS call to check if there's content in the site home.
            var siteHomeId = site.getSiteHomeId(), preSets = { emergencyCache: false };
            _this.logger.debug('Using WS call to check if site home is available.');
            return _this.courseProvider.getSections(siteHomeId, false, true, preSets, site.id).then(function (sections) {
                if (!sections || !sections.length) {
                    return Promise.reject(null);
                }
                for (var i = 0; i < sections.length; i++) {
                    var section = sections[i];
                    if (section.summary || (section.modules && section.modules.length)) {
                        // It has content, return true.
                        return true;
                    }
                }
                return Promise.reject(null);
            }).catch(function () {
                var config = site.getStoredConfig();
                if (config && config.frontpageloggedin) {
                    var items = config.frontpageloggedin.split(',');
                    if (items.length > 0) {
                        // It's enabled.
                        return true;
                    }
                }
                return false;
            });
        }).catch(function () {
            return false;
        });
    };
    /**
     * Check if Site Home is disabled in a certain site.
     *
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<boolean>} Promise resolved with true if disabled, rejected or resolved with false otherwise.
     */
    CoreSiteHomeProvider.prototype.isDisabled = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.isDisabledInSite(site);
        });
    };
    /**
     * Check if Site Home is disabled in a certain site.
     *
     * @param {CoreSite} [site] Site. If not defined, use current site.
     * @return {boolean} Whether it's disabled.
     */
    CoreSiteHomeProvider.prototype.isDisabledInSite = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.isFeatureDisabled('$mmSideMenuDelegate_mmaFrontpage');
    };
    CoreSiteHomeProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_3__core_course_providers_course__["a" /* CoreCourseProvider */]])
    ], CoreSiteHomeProvider);
    return CoreSiteHomeProvider;
}());

//# sourceMappingURL=sitehome.js.map

/***/ }),
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFileHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__file__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__filepool__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_constants__ = __webpack_require__(22);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








/**
 * Provider to provide some helper functions regarding files and packages.
 */
var CoreFileHelperProvider = /** @class */ (function () {
    function CoreFileHelperProvider(fileProvider, filepoolProvider, sitesProvider, appProvider, translate, utils) {
        this.fileProvider = fileProvider;
        this.filepoolProvider = filepoolProvider;
        this.sitesProvider = sitesProvider;
        this.appProvider = appProvider;
        this.translate = translate;
        this.utils = utils;
    }
    /**
     * Convenience function to open a file, downloading it if needed.
     *
     * @param {any} file The file to download.
     * @param {string} [component] The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {string} [state] The file's state. If not provided, it will be calculated.
     * @param {Function} [onProgress] Function to call on progress.
     * @param {string} [siteId] The site ID. If not defined, current site.
     * @return {Promise<any>} Resolved on success.
     */
    CoreFileHelperProvider.prototype.downloadAndOpenFile = function (file, component, componentId, state, onProgress, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var fileUrl = this.getFileUrl(file), timemodified = this.getFileTimemodified(file);
        return this.downloadFileIfNeeded(file, fileUrl, component, componentId, timemodified, state, onProgress, siteId)
            .then(function (url) {
            if (!url) {
                return;
            }
            if (url.indexOf('http') === 0) {
                return _this.utils.openOnlineFile(url).catch(function (error) {
                    // Error opening the file, some apps don't allow opening online files.
                    if (!_this.fileProvider.isAvailable()) {
                        return Promise.reject(error);
                    }
                    // Get the state.
                    if (state) {
                        return state;
                    }
                    else {
                        return _this.filepoolProvider.getFileStateByUrl(siteId, fileUrl, timemodified);
                    }
                }).then(function (state) {
                    if (state == __WEBPACK_IMPORTED_MODULE_7__core_constants__["a" /* CoreConstants */].DOWNLOADING) {
                        return Promise.reject(_this.translate.instant('core.erroropenfiledownloading'));
                    }
                    var promise;
                    if (state === __WEBPACK_IMPORTED_MODULE_7__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED) {
                        // File is not downloaded, download and then return the local URL.
                        promise = _this.downloadFile(fileUrl, component, componentId, timemodified, onProgress, file, siteId);
                    }
                    else {
                        // File is outdated and can't be opened in online, return the local URL.
                        promise = _this.filepoolProvider.getInternalUrlByUrl(siteId, fileUrl);
                    }
                    return promise.then(function (url) {
                        return _this.utils.openFile(url);
                    });
                });
            }
            else {
                return _this.utils.openFile(url);
            }
        });
    };
    /**
     * Download a file if it needs to be downloaded.
     *
     * @param {any} file The file to download.
     * @param {string} fileUrl The file URL.
     * @param {string} [component] The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {number} [timemodified] The time this file was modified.
     * @param {string} [state] The file's state. If not provided, it will be calculated.
     * @param {Function} [onProgress] Function to call on progress.
     * @param {string} [siteId] The site ID. If not defined, current site.
     * @return {Promise<string>} Resolved with the URL to use on success.
     */
    CoreFileHelperProvider.prototype.downloadFileIfNeeded = function (file, fileUrl, component, componentId, timemodified, state, onProgress, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var fixedUrl = site.fixPluginfileURL(fileUrl);
            if (_this.fileProvider.isAvailable()) {
                var promise = void 0;
                if (state) {
                    promise = Promise.resolve(state);
                }
                else {
                    // Calculate the state.
                    promise = _this.filepoolProvider.getFileStateByUrl(siteId, fileUrl, timemodified);
                }
                return promise.then(function (state) {
                    // The file system is available.
                    var isWifi = !_this.appProvider.isNetworkAccessLimited(), isOnline = _this.appProvider.isOnline();
                    if (state == __WEBPACK_IMPORTED_MODULE_7__core_constants__["a" /* CoreConstants */].DOWNLOADED) {
                        // File is downloaded, get the local file URL.
                        return _this.filepoolProvider.getUrlByUrl(siteId, fileUrl, component, componentId, timemodified, false, false, file);
                    }
                    else {
                        if (!isOnline && !_this.isStateDownloaded(state)) {
                            // Not downloaded and user is offline, reject.
                            return Promise.reject(_this.translate.instant('core.networkerrormsg'));
                        }
                        if (onProgress) {
                            // This call can take a while. Send a fake event to notify that we're doing some calculations.
                            onProgress({ calculating: true });
                        }
                        return _this.filepoolProvider.shouldDownloadBeforeOpen(fixedUrl, file.filesize).then(function () {
                            if (state == __WEBPACK_IMPORTED_MODULE_7__core_constants__["a" /* CoreConstants */].DOWNLOADING) {
                                // It's already downloading, stop.
                                return;
                            }
                            // Download and then return the local URL.
                            return _this.downloadFile(fileUrl, component, componentId, timemodified, onProgress, file, siteId);
                        }, function () {
                            // Start the download if in wifi, but return the URL right away so the file is opened.
                            if (isWifi && isOnline) {
                                _this.downloadFile(fileUrl, component, componentId, timemodified, onProgress, file, siteId);
                            }
                            if (!_this.isStateDownloaded(state) || isOnline) {
                                // Not downloaded or online, return the online URL.
                                return fixedUrl;
                            }
                            else {
                                // Outdated but offline, so we return the local URL.
                                return _this.filepoolProvider.getUrlByUrl(siteId, fileUrl, component, componentId, timemodified, false, false, file);
                            }
                        });
                    }
                });
            }
            else {
                // Use the online URL.
                return fixedUrl;
            }
        });
    };
    /**
     * Download the file.
     *
     * @param {string} fileUrl The file URL.
     * @param {string} [component] The component to link the file to.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {number} [timemodified] The time this file was modified.
     * @param {Function} [onProgress] Function to call on progress.
     * @param {any} [file] The file to download.
     * @param {string} [siteId] The site ID. If not defined, current site.
     * @return {Promise<string>} Resolved with internal URL on success, rejected otherwise.
     */
    CoreFileHelperProvider.prototype.downloadFile = function (fileUrl, component, componentId, timemodified, onProgress, file, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Get the site and check if it can download files.
        return this.sitesProvider.getSite(siteId).then(function (site) {
            if (!site.canDownloadFiles()) {
                return Promise.reject(_this.translate.instant('core.cannotdownloadfiles'));
            }
            return _this.filepoolProvider.downloadUrl(siteId, fileUrl, false, component, componentId, timemodified, onProgress, undefined, file).catch(function (error) {
                // Download failed, check the state again to see if the file was downloaded before.
                return _this.filepoolProvider.getFileStateByUrl(siteId, fileUrl, timemodified).then(function (state) {
                    if (_this.isStateDownloaded(state)) {
                        return _this.filepoolProvider.getInternalUrlByUrl(siteId, fileUrl);
                    }
                    else {
                        return Promise.reject(error);
                    }
                });
            });
        });
    };
    /**
     * Get the file's URL.
     *
     * @param {any} file The file.
     */
    CoreFileHelperProvider.prototype.getFileUrl = function (file) {
        return file.fileurl || file.url;
    };
    /**
     * Get the file's timemodified.
     *
     * @param {any} file The file.
     */
    CoreFileHelperProvider.prototype.getFileTimemodified = function (file) {
        return file.timemodified || 0;
    };
    /**
     * Check if a state is downloaded or outdated.
     *
     * @param {string} state The state to check.
     */
    CoreFileHelperProvider.prototype.isStateDownloaded = function (state) {
        return state === __WEBPACK_IMPORTED_MODULE_7__core_constants__["a" /* CoreConstants */].DOWNLOADED || state === __WEBPACK_IMPORTED_MODULE_7__core_constants__["a" /* CoreConstants */].OUTDATED;
    };
    /**
     * Whether the file has to be opened in browser (external repository).
     * The file must have a mimetype attribute.
     *
     * @param {any} file The file to check.
     * @return {boolean} Whether the file should be opened in browser.
     */
    CoreFileHelperProvider.prototype.shouldOpenInBrowser = function (file) {
        if (!file || !file.isexternalfile || !file.mimetype) {
            return false;
        }
        var mimetype = file.mimetype;
        if (mimetype.indexOf('application/vnd.google-apps.') != -1) {
            // Google Docs file, always open in browser.
            return true;
        }
        if (file.repositorytype == 'onedrive') {
            // In OneDrive, open in browser the office docs
            return mimetype.indexOf('application/vnd.openxmlformats-officedocument') != -1 ||
                mimetype == 'text/plain' || mimetype == 'document/unknown';
        }
        return false;
    };
    CoreFileHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__file__["a" /* CoreFileProvider */], __WEBPACK_IMPORTED_MODULE_4__filepool__["a" /* CoreFilepoolProvider */],
            __WEBPACK_IMPORTED_MODULE_5__sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_2__app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_6__utils_utils__["a" /* CoreUtilsProvider */]])
    ], CoreFileHelperProvider);
    return CoreFileHelperProvider;
}());

//# sourceMappingURL=file-helper.js.map

/***/ }),
/* 161 */,
/* 162 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFileUploaderProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_file__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_filepool__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_mimetype__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_text__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_time__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_utils_utils__ = __webpack_require__(9);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};











/**
 * Service to upload files.
 */
var CoreFileUploaderProvider = /** @class */ (function () {
    function CoreFileUploaderProvider(logger, fileProvider, textUtils, utils, sitesProvider, timeUtils, mimeUtils, filepoolProvider, platform, translate) {
        this.fileProvider = fileProvider;
        this.textUtils = textUtils;
        this.utils = utils;
        this.sitesProvider = sitesProvider;
        this.timeUtils = timeUtils;
        this.mimeUtils = mimeUtils;
        this.filepoolProvider = filepoolProvider;
        this.platform = platform;
        this.translate = translate;
        this.logger = logger.getInstance('CoreFileUploaderProvider');
    }
    /**
     * Add a dot to the beginning of an extension.
     *
     * @param {string} extension Extension.
     * @return {string}           Treated extension.
     */
    CoreFileUploaderProvider.prototype.addDot = function (extension) {
        return '.' + extension;
    };
    /**
     * Compares two file lists and returns if they are different.
     *
     * @param {any[]} a First file list.
     * @param {any[]} b Second file list.
     * @return {boolean} Whether both lists are different.
     */
    CoreFileUploaderProvider.prototype.areFileListDifferent = function (a, b) {
        a = a || [];
        b = b || [];
        if (a.length != b.length) {
            return true;
        }
        // Currently we are going to compare the order of the files as well.
        // This function can be improved comparing more fields or not comparing the order.
        for (var i = 0; i < a.length; i++) {
            if ((a[i].name || a[i].filename) != (b[i].name || b[i].filename)) {
                return true;
            }
        }
        return false;
    };
    /**
     * Clear temporary attachments to be uploaded.
     * Attachments already saved in an offline store will NOT be deleted.
     *
     * @param {any[]} files List of files.
     */
    CoreFileUploaderProvider.prototype.clearTmpFiles = function (files) {
        // Delete the local files.
        files.forEach(function (file) {
            if (!file.offline && file.remove) {
                // Pass an empty function to prevent missing parameter error.
                file.remove(function () {
                    // Nothing to do.
                });
            }
        });
    };
    /**
     * Get the upload options for a file taken with the Camera Cordova plugin.
     *
     * @param {string} uri File URI.
     * @param {boolean} [isFromAlbum] True if the image was taken from album, false if it's a new image taken with camera.
     * @return {CoreFileUploaderOptions} Options.
     */
    CoreFileUploaderProvider.prototype.getCameraUploadOptions = function (uri, isFromAlbum) {
        var extension = this.mimeUtils.getExtension(uri), mimetype = this.mimeUtils.getMimeType(extension), isIOS = this.platform.is('ios'), options = {
            deleteAfterUpload: !isFromAlbum,
            mimeType: mimetype
        };
        if (isIOS && (mimetype == 'image/jpeg' || mimetype == 'image/png')) {
            // In iOS, the pictures can have repeated names, even if they come from the album.
            options.fileName = 'image_' + this.timeUtils.readableTimestamp() + '.' + extension;
        }
        else {
            // Use the same name that the file already has.
            options.fileName = this.fileProvider.getFileAndDirectoryFromPath(uri).name;
        }
        if (isFromAlbum) {
            // If the file was picked from the album, delete it only if it was copied to the app's folder.
            options.deleteAfterUpload = this.fileProvider.isFileInAppFolder(uri);
            if (this.platform.is('android')) {
                // Picking an image from album in Android adds a timestamp at the end of the file. Delete it.
                options.fileName = options.fileName.replace(/(\.[^\.]*)\?[^\.]*$/, '$1');
            }
        }
        return options;
    };
    /**
     * Get the upload options for a file of any type.
     *
     * @param {string} uri File URI.
     * @param {string} name File name.
     * @param {string} type File type.
     * @param {boolean} [deleteAfterUpload] Whether the file should be deleted after upload.
     * @param {string} [fileArea] File area to upload the file to. It defaults to 'draft'.
     * @param {number} [itemId] Draft ID to upload the file to, 0 to create new.
     * @return {CoreFileUploaderOptions} Options.
     */
    CoreFileUploaderProvider.prototype.getFileUploadOptions = function (uri, name, type, deleteAfterUpload, fileArea, itemId) {
        var options = {};
        options.fileName = name;
        options.mimeType = type || this.mimeUtils.getMimeType(this.mimeUtils.getFileExtension(options.fileName));
        options.deleteAfterUpload = !!deleteAfterUpload;
        options.itemId = itemId || 0;
        options.fileArea = fileArea;
        return options;
    };
    /**
     * Get the upload options for a file taken with the media capture Cordova plugin.
     *
     * @param {MediaFile} mediaFile File object to upload.
     * @return {CoreFileUploaderOptions} Options.
     */
    CoreFileUploaderProvider.prototype.getMediaUploadOptions = function (mediaFile) {
        var options = {};
        var filename = mediaFile.name, split;
        // Add a timestamp to the filename to make it unique.
        split = filename.split('.');
        split[0] += '_' + this.timeUtils.readableTimestamp();
        filename = split.join('.');
        options.fileName = filename;
        options.deleteAfterUpload = true;
        if (mediaFile.type) {
            options.mimeType = mediaFile.type;
        }
        else {
            options.mimeType = this.mimeUtils.getMimeType(this.mimeUtils.getFileExtension(options.fileName));
        }
        return options;
    };
    /**
     * Get the files stored in a folder, marking them as offline.
     *
     * @param {string} folderPath Folder where to get the files.
     * @return {Promise<any[]>} Promise resolved with the list of files.
     */
    CoreFileUploaderProvider.prototype.getStoredFiles = function (folderPath) {
        var _this = this;
        return this.fileProvider.getDirectoryContents(folderPath).then(function (files) {
            return _this.markOfflineFiles(files);
        });
    };
    /**
     * Get stored files from combined online and offline file object.
     *
     * @param {{online: any[], offline: number}} filesObject The combined offline and online files object.
     * @param {string} folderPath Folder path to get files from.
     * @return {Promise<any[]>} Promise resolved with files.
     */
    CoreFileUploaderProvider.prototype.getStoredFilesFromOfflineFilesObject = function (filesObject, folderPath) {
        var files = [];
        if (filesObject) {
            if (filesObject.online && filesObject.online.length > 0) {
                files = this.utils.clone(filesObject.online);
            }
            if (filesObject.offline > 0) {
                return this.getStoredFiles(folderPath).then(function (offlineFiles) {
                    return files.concat(offlineFiles);
                }).catch(function () {
                    // Ignore not found files.
                    return files;
                });
            }
        }
        return Promise.resolve(files);
    };
    /**
     * Check if a file's mimetype is invalid based on the list of accepted mimetypes. This function needs either the file's
     * mimetype or the file's path/name.
     *
     * @param {string[]} [mimetypes] List of supported mimetypes. If undefined, all mimetypes supported.
     * @param {string} [path] File's path or name.
     * @param {string} [mimetype] File's mimetype.
     * @return {string} Undefined if file is valid, error message if file is invalid.
     */
    CoreFileUploaderProvider.prototype.isInvalidMimetype = function (mimetypes, path, mimetype) {
        var extension;
        if (mimetypes) {
            // Verify that the mimetype of the file is supported.
            if (mimetype) {
                extension = this.mimeUtils.getExtension(mimetype);
            }
            else {
                extension = this.mimeUtils.getFileExtension(path);
                mimetype = this.mimeUtils.getMimeType(extension);
            }
            if (mimetype && mimetypes.indexOf(mimetype) == -1) {
                extension = extension || this.translate.instant('core.unknown');
                return this.translate.instant('core.fileuploader.invalidfiletype', { $a: extension });
            }
        }
    };
    /**
     * Mark files as offline.
     *
     * @param {any[]} files Files to mark as offline.
     * @return {any[]} Files marked as offline.
     */
    CoreFileUploaderProvider.prototype.markOfflineFiles = function (files) {
        // Mark the files as pending offline.
        files.forEach(function (file) {
            file.offline = true;
            file.filename = file.name;
        });
        return files;
    };
    /**
     * Parse filetypeList to get the list of allowed mimetypes and the data to render information.
     *
     * @param {string} filetypeList Formatted string list where the mimetypes can be checked.
     * @return {{info: any[], mimetypes: string[]}}  Mimetypes and the filetypes informations.
     */
    CoreFileUploaderProvider.prototype.prepareFiletypeList = function (filetypeList) {
        var _this = this;
        var filetypes = filetypeList.split(/[;, ]+/g), mimetypes = {}, // Use an object to prevent duplicates.
        typesInfo = [];
        filetypes.forEach(function (filetype) {
            filetype = filetype.trim();
            if (filetype) {
                if (filetype.indexOf('/') != -1) {
                    // It's a mimetype.
                    typesInfo.push({
                        name: _this.mimeUtils.getMimetypeDescription(filetype),
                        extlist: _this.mimeUtils.getExtensions(filetype).map(_this.addDot).join(' ')
                    });
                    mimetypes[filetype] = true;
                }
                else if (filetype.indexOf('.') === 0) {
                    // It's an extension.
                    var mimetype = _this.mimeUtils.getMimeType(filetype);
                    typesInfo.push({
                        name: mimetype ? _this.mimeUtils.getMimetypeDescription(mimetype) : false,
                        extlist: filetype
                    });
                    if (mimetype) {
                        mimetypes[mimetype] = true;
                    }
                }
                else {
                    // It's a group.
                    var groupExtensions = _this.mimeUtils.getGroupMimeInfo(filetype, 'extensions'), groupMimetypes = _this.mimeUtils.getGroupMimeInfo(filetype, 'mimetypes');
                    if (groupExtensions.length > 0) {
                        typesInfo.push({
                            name: _this.mimeUtils.getTranslatedGroupName(filetype),
                            extlist: groupExtensions ? groupExtensions.map(_this.addDot).join(' ') : ''
                        });
                        groupMimetypes.forEach(function (mimetype) {
                            if (mimetype) {
                                mimetypes[mimetype] = true;
                            }
                        });
                    }
                    else {
                        // Treat them as extensions.
                        filetype = _this.addDot(filetype);
                        var mimetype = _this.mimeUtils.getMimeType(filetype);
                        typesInfo.push({
                            name: mimetype ? _this.mimeUtils.getMimetypeDescription(mimetype) : false,
                            extlist: filetype
                        });
                        if (mimetype) {
                            mimetypes[mimetype] = true;
                        }
                    }
                }
            }
        });
        return {
            info: typesInfo,
            mimetypes: Object.keys(mimetypes)
        };
    };
    /**
     * Given a list of files (either online files or local files), store the local files in a local folder
     * to be uploaded later.
     *
     * @param {string} folderPath Path of the folder where to store the files.
     * @param {any[]} files List of files.
     * @return {Promise<{online: any[], offline: number}>} Promise resolved if success.
     */
    CoreFileUploaderProvider.prototype.storeFilesToUpload = function (folderPath, files) {
        var _this = this;
        var result = {
            online: [],
            offline: 0
        };
        if (!files || !files.length) {
            return Promise.resolve(result);
        }
        // Remove unused files from previous saves.
        return this.fileProvider.removeUnusedFiles(folderPath, files).then(function () {
            var promises = [];
            files.forEach(function (file) {
                if (file.filename && !file.name) {
                    // It's an online file, add it to the result and ignore it.
                    result.online.push({
                        filename: file.filename,
                        fileurl: file.fileurl
                    });
                }
                else if (!file.name) {
                    // Error.
                    promises.push(Promise.reject(null));
                }
                else if (file.fullPath && file.fullPath.indexOf(folderPath) != -1) {
                    // File already in the submission folder.
                    result.offline++;
                }
                else {
                    // Local file, copy it.
                    // Use copy instead of move to prevent having a unstable state if some copies succeed and others don't.
                    var destFile = _this.textUtils.concatenatePaths(folderPath, file.name);
                    promises.push(_this.fileProvider.copyFile(file.toURL(), destFile));
                    result.offline++;
                }
            });
            return Promise.all(promises).then(function () {
                return result;
            });
        });
    };
    /**
     * Upload a file.
     *
     * @param {string} uri File URI.
     * @param {CoreFileUploaderOptions} [options] Options for the upload.
     * @param {Function} [onProgress] Function to call on progress.
     * @param {string} [siteId] Id of the site to upload the file to. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreFileUploaderProvider.prototype.uploadFile = function (uri, options, onProgress, siteId) {
        var _this = this;
        options = options || {};
        var deleteAfterUpload = options.deleteAfterUpload, ftOptions = this.utils.clone(options);
        delete ftOptions.deleteAfterUpload;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.uploadFile(uri, ftOptions, onProgress);
        }).then(function (result) {
            if (deleteAfterUpload) {
                setTimeout(function () {
                    // Use set timeout, otherwise in Electron the upload threw an error sometimes.
                    _this.fileProvider.removeExternalFile(uri);
                }, 500);
            }
            return result;
        });
    };
    /**
     * Upload a file to a draft area. If the file is an online file it will be downloaded and then re-uploaded.
     *
     * @param {any} file Online file or local FileEntry.
     * @param {number} [itemId] Draft ID to use. Undefined or 0 to create a new draft ID.
     * @param {string} [component] The component to set to the downloaded files.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<number>} Promise resolved with the itemId.
     */
    CoreFileUploaderProvider.prototype.uploadOrReuploadFile = function (file, itemId, component, componentId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var promise, fileName;
        if (file.filename && !file.name) {
            // It's an online file. We need to download it and re-upload it.
            fileName = file.filename;
            promise = this.filepoolProvider.downloadUrl(siteId, file.url || file.fileurl, false, component, componentId, file.timemodified, undefined, undefined, file).then(function (path) {
                return _this.fileProvider.getExternalFile(path);
            });
        }
        else {
            // Local file, we already have the file entry.
            fileName = file.name;
            promise = Promise.resolve(file);
        }
        return promise.then(function (fileEntry) {
            // Now upload the file.
            var options = _this.getFileUploadOptions(fileEntry.toURL(), fileName, fileEntry.type, true, 'draft', itemId);
            return _this.uploadFile(fileEntry.toURL(), options, undefined, siteId).then(function (result) {
                return result.itemid;
            });
        });
    };
    /**
     * Given a list of files (either online files or local files), upload them to a draft area and return the draft ID.
     * Online files will be downloaded and then re-uploaded.
     * If there are no files to upload it will return a fake draft ID (1).
     *
     * @param {any[]} files List of files.
     * @param {string} [component] The component to set to the downloaded files.
     * @param {string|number} [componentId] An ID to use in conjunction with the component.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<number>} Promise resolved with the itemId.
     */
    CoreFileUploaderProvider.prototype.uploadOrReuploadFiles = function (files, component, componentId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (!files || !files.length) {
            // Return fake draft ID.
            return Promise.resolve(1);
        }
        // Upload only the first file first to get a draft id.
        return this.uploadOrReuploadFile(files[0], 0, component, componentId, siteId).then(function (itemId) {
            var promises = [];
            for (var i = 1; i < files.length; i++) {
                var file = files[i];
                promises.push(_this.uploadOrReuploadFile(file, itemId, component, componentId, siteId));
            }
            return Promise.all(promises).then(function () {
                return itemId;
            });
        });
    };
    CoreFileUploaderProvider.LIMITED_SIZE_WARNING = 1048576; // 1 MB.
    CoreFileUploaderProvider.WIFI_SIZE_WARNING = 10485760; // 10 MB.
    CoreFileUploaderProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_file__["a" /* CoreFileProvider */], __WEBPACK_IMPORTED_MODULE_8__providers_utils_text__["a" /* CoreTextUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_10__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_9__providers_utils_time__["a" /* CoreTimeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_7__providers_utils_mimetype__["a" /* CoreMimetypeUtilsProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_filepool__["a" /* CoreFilepoolProvider */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */], __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */]])
    ], CoreFileUploaderProvider);
    return CoreFileUploaderProvider;
}());

//# sourceMappingURL=fileuploader.js.map

/***/ }),
/* 163 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModFolderProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_course_providers_course__ = __webpack_require__(14);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Service that provides some features for folder.
 */
var AddonModFolderProvider = /** @class */ (function () {
    function AddonModFolderProvider(logger, sitesProvider, courseProvider, utils) {
        this.sitesProvider = sitesProvider;
        this.courseProvider = courseProvider;
        this.utils = utils;
        this.ROOT_CACHE_KEY = 'mmaModFolder:';
        this.logger = logger.getInstance('mmaModFolderProvider');
    }
    /**
     * Get a folder by course module ID.
     *
     * @param {number} courseId Course ID.
     * @param {number} cmId     Course module ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}        Promise resolved when the book is retrieved.
     */
    AddonModFolderProvider.prototype.getFolder = function (courseId, cmId, siteId) {
        return this.getFolderByKey(courseId, 'coursemodule', cmId, siteId);
    };
    /**
     * Get a folder.
     *
     * @param {number} courseId  Course ID.
     * @param {string} key       Name of the property to check.
     * @param {any}  value     Value to search.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}          Promise resolved when the book is retrieved.
     */
    AddonModFolderProvider.prototype.getFolderByKey = function (courseId, key, value, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                courseids: [courseId]
            }, preSets = {
                cacheKey: _this.getFolderCacheKey(courseId)
            };
            return site.read('mod_folder_get_folders_by_courses', params, preSets).then(function (response) {
                if (response && response.folders) {
                    var currentFolder = response.folders.find(function (folder) {
                        return folder[key] == value;
                    });
                    if (currentFolder) {
                        return currentFolder;
                    }
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get cache key for folder data WS calls.
     *
     * @param {number} courseId Course ID.
     * @return {string}         Cache key.
     */
    AddonModFolderProvider.prototype.getFolderCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'folder:' + courseId;
    };
    /**
     * Invalidate the prefetched content.
     *
     * @param  {number} moduleId The module ID.
     * @param  {number} courseId Course ID of the module.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}
     */
    AddonModFolderProvider.prototype.invalidateContent = function (moduleId, courseId, siteId) {
        var promises = [];
        promises.push(this.invalidateFolderData(courseId, siteId));
        promises.push(this.courseProvider.invalidateModule(moduleId, siteId));
        return this.utils.allPromises(promises);
    };
    /**
     * Invalidates folder data.
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}   Promise resolved when the data is invalidated.
     */
    AddonModFolderProvider.prototype.invalidateFolderData = function (courseId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getFolderCacheKey(courseId));
        });
    };
    /**
     * Returns whether or not getFolder WS available or not.
     *
     * @return {boolean} If WS is avalaible.
     * @since 3.3
     */
    AddonModFolderProvider.prototype.isGetFolderWSAvailable = function () {
        return this.sitesProvider.wsAvailableInCurrentSite('mod_folder_get_folders_by_courses');
    };
    /**
     * Report a folder as being viewed.
     *
     * @param {number} id Module ID.
     * @return {Promise<any>}  Promise resolved when the WS call is successful.
     */
    AddonModFolderProvider.prototype.logView = function (id) {
        var params = {
            folderid: id
        };
        return this.sitesProvider.getCurrentSite().write('mod_folder_view_folder', params);
    };
    AddonModFolderProvider.COMPONENT = 'mmaModFolder';
    AddonModFolderProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_4__core_course_providers_course__["a" /* CoreCourseProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], AddonModFolderProvider);
    return AddonModFolderProvider;
}());

//# sourceMappingURL=folder.js.map

/***/ }),
/* 164 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModResourceHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_course_providers_course__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_course_providers_helper__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__resource__ = __webpack_require__(108);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_filepool__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_file__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_mimetype__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_utils_text__ = __webpack_require__(13);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};











/**
 * Service that provides helper functions for resources.
 */
var AddonModResourceHelperProvider = /** @class */ (function () {
    function AddonModResourceHelperProvider(courseProvider, domUtils, resourceProvider, courseHelper, textUtils, mimetypeUtils, fileProvider, appProvider, filepoolProvider, sitesProvider) {
        this.courseProvider = courseProvider;
        this.domUtils = domUtils;
        this.resourceProvider = resourceProvider;
        this.courseHelper = courseHelper;
        this.textUtils = textUtils;
        this.mimetypeUtils = mimetypeUtils;
        this.fileProvider = fileProvider;
        this.appProvider = appProvider;
        this.filepoolProvider = filepoolProvider;
        this.sitesProvider = sitesProvider;
        /* Constants to determine how a resource should be displayed in Moodle. */
        // Try the best way.
        this.DISPLAY_AUTO = 0;
        // Display using object tag.
        this.DISPLAY_EMBED = 1;
    }
    /**
     * Get the HTML to display an embedded resource.
     *
     * @param {any} module The module object.
     * @return {Promise<any>}      Promise resolved with the iframe src.
     */
    AddonModResourceHelperProvider.prototype.getEmbeddedHtml = function (module) {
        var _this = this;
        return this.courseHelper.downloadModuleWithMainFileIfNeeded(module, module.course, __WEBPACK_IMPORTED_MODULE_4__resource__["a" /* AddonModResourceProvider */].COMPONENT, module.id, module.contents).then(function (result) {
            var file = module.contents[0], ext = _this.mimetypeUtils.getFileExtension(file.filename), type = _this.mimetypeUtils.getExtensionType(ext), mimeType = _this.mimetypeUtils.getMimeType(ext);
            if (type == 'image') {
                return '<img src="' + result.path + '"></img>';
            }
            if (type == 'audio' || type == 'video') {
                return '<' + type + ' controls title="' + file.filename + '"" src="' + result.path + '">' +
                    '<source src="' + result.path + '" type="' + mimeType + '">' +
                    '</' + type + '>';
            }
            // Shouldn't reach here, the user should have called CoreMimetypeUtilsProvider#canBeEmbedded.
            return '';
        });
    };
    /**
     * Download all the files needed and returns the src of the iframe.
     *
     * @param {any} module The module object.
     * @return {Promise<string>} Promise resolved with the iframe src.
     */
    AddonModResourceHelperProvider.prototype.getIframeSrc = function (module) {
        var _this = this;
        if (!module.contents.length) {
            return Promise.reject(null);
        }
        var mainFile = module.contents[0];
        var mainFilePath = mainFile.filename;
        if (mainFile.filepath !== '/') {
            mainFilePath = mainFile.filepath.substr(1) + mainFilePath;
        }
        return this.filepoolProvider.getPackageDirUrlByUrl(this.sitesProvider.getCurrentSiteId(), module.url).then(function (dirPath) {
            // This URL is going to be injected in an iframe, we need trustAsResourceUrl to make it work in a browser.
            return _this.textUtils.concatenatePaths(dirPath, mainFilePath);
        }).catch(function () {
            // Error getting directory, there was an error downloading or we're in browser. Return online URL.
            if (_this.appProvider.isOnline() && mainFile.fileurl) {
                // This URL is going to be injected in an iframe, we need this to make it work.
                return Promise.resolve(_this.sitesProvider.getCurrentSite().fixPluginfileURL(mainFile.fileurl));
            }
            return Promise.reject(null);
        });
    };
    /**
     * Whether the resource has to be displayed embedded.
     *
     * @param {any} module    The module object.
     * @param {number} [display] The display mode (if available).
     * @return {boolean}         Whether the resource should be displayed embeded.
     */
    AddonModResourceHelperProvider.prototype.isDisplayedEmbedded = function (module, display) {
        if (!module.contents.length || !this.fileProvider.isAvailable()) {
            return false;
        }
        var ext = this.mimetypeUtils.getFileExtension(module.contents[0].filename);
        return (display == this.DISPLAY_EMBED || display == this.DISPLAY_AUTO) && this.mimetypeUtils.canBeEmbedded(ext);
    };
    /**
     * Whether the resource has to be displayed in an iframe.
     *
     * @param {any} module The module object.
     * @return {boolean}   Whether the resource should be displayed in an iframe.
     */
    AddonModResourceHelperProvider.prototype.isDisplayedInIframe = function (module) {
        if (!module.contents.length || !this.fileProvider.isAvailable()) {
            return false;
        }
        var ext = this.mimetypeUtils.getFileExtension(module.contents[0].filename), mimetype = this.mimetypeUtils.getMimeType(ext);
        return mimetype == 'text/html';
    };
    /**
     * Opens a file of the resource activity.
     *
     * @param  {any} module        Module where to get the contents.
     * @param  {number} courseId   Course Id, used for completion purposes.
     * @return {Promise<any>}      Resolved when done.
     */
    AddonModResourceHelperProvider.prototype.openModuleFile = function (module, courseId) {
        var _this = this;
        var modal = this.domUtils.showModalLoading();
        // Download and open the file from the resource contents.
        return this.courseHelper.downloadModuleAndOpenFile(module, courseId, __WEBPACK_IMPORTED_MODULE_4__resource__["a" /* AddonModResourceProvider */].COMPONENT, module.id, module.contents).then(function () {
            _this.resourceProvider.logView(module.instance).then(function () {
                _this.courseProvider.checkModuleCompletion(courseId, module.completionstatus);
            });
        }).catch(function (error) {
            _this.domUtils.showErrorModalDefault(error, 'addon.mod_resource.errorwhileloadingthecontent', true);
        }).finally(function () {
            modal.dismiss();
        });
    };
    AddonModResourceHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__core_course_providers_course__["a" /* CoreCourseProvider */], __WEBPACK_IMPORTED_MODULE_1__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_4__resource__["a" /* AddonModResourceProvider */], __WEBPACK_IMPORTED_MODULE_3__core_course_providers_helper__["a" /* CoreCourseHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_10__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_9__providers_utils_mimetype__["a" /* CoreMimetypeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_7__providers_file__["a" /* CoreFileProvider */], __WEBPACK_IMPORTED_MODULE_8__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_6__providers_filepool__["a" /* CoreFilepoolProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_sites__["a" /* CoreSitesProvider */]])
    ], AddonModResourceHelperProvider);
    return AddonModResourceHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),
/* 165 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModUrlProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_course_providers_course__ = __webpack_require__(14);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Service that provides some features for urls.
 */
var AddonModUrlProvider = /** @class */ (function () {
    function AddonModUrlProvider(logger, sitesProvider, courseProvider, utils) {
        this.sitesProvider = sitesProvider;
        this.courseProvider = courseProvider;
        this.utils = utils;
        this.ROOT_CACHE_KEY = 'mmaModUrl:';
        this.logger = logger.getInstance('AddonModUrlProvider');
    }
    /**
     * Get cache key for url data WS calls.
     *
     * @param {number} courseId Course ID.
     * @return {string}         Cache key.
     */
    AddonModUrlProvider.prototype.getUrlCacheKey = function (courseId) {
        return this.ROOT_CACHE_KEY + 'url:' + courseId;
    };
    /**
     * Get a url data.
     *
     * @param {number} courseId Course ID.
     * @param {string} key     Name of the property to check.
     * @param {any}  value   Value to search.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}  Promise resolved when the url is retrieved.
     */
    AddonModUrlProvider.prototype.getUrlDataByKey = function (courseId, key, value, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                courseids: [courseId]
            }, preSets = {
                cacheKey: _this.getUrlCacheKey(courseId)
            };
            return site.read('mod_url_get_urls_by_courses', params, preSets).then(function (response) {
                if (response && response.urls) {
                    var currentUrl = response.urls.find(function (url) {
                        return url[key] == value;
                    });
                    if (currentUrl) {
                        return currentUrl;
                    }
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get a url by course module ID.
     *
     * @param {number} courseId Course ID.
     * @param {number} cmId     Course module ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}   Promise resolved when the url is retrieved.
     */
    AddonModUrlProvider.prototype.getUrl = function (courseId, cmId, siteId) {
        return this.getUrlDataByKey(courseId, 'coursemodule', cmId, siteId);
    };
    /**
     * Invalidate the prefetched content.
     *
     * @param  {number} moduleId The module ID.
     * @param  {number} courseId Course ID of the module.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved when the data is invalidated.
     */
    AddonModUrlProvider.prototype.invalidateContent = function (moduleId, courseId, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var promises = [];
        promises.push(this.invalidateUrlData(courseId, siteId));
        promises.push(this.courseProvider.invalidateModule(moduleId, siteId));
        return this.utils.allPromises(promises);
    };
    /**
     * Invalidates url data.
     *
     * @param {number} courseid Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}   Promise resolved when the data is invalidated.
     */
    AddonModUrlProvider.prototype.invalidateUrlData = function (courseId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getUrlCacheKey(courseId));
        });
    };
    /**
     * Returns whether or not getUrl WS available or not.
     *
     * @return {boolean} If WS is abalaible.
     * @since 3.3
     */
    AddonModUrlProvider.prototype.isGetUrlWSAvailable = function () {
        return this.sitesProvider.wsAvailableInCurrentSite('mod_url_get_urls_by_courses');
    };
    /**
     * Report the url as being viewed.
     *
     * @param {number} id Module ID.
     * @return {Promise<any>}  Promise resolved when the WS call is successful.
     */
    AddonModUrlProvider.prototype.logView = function (id) {
        var params = {
            urlid: id
        };
        return this.sitesProvider.getCurrentSite().write('mod_url_view_url', params);
    };
    AddonModUrlProvider.COMPONENT = 'mmaModUrl';
    AddonModUrlProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_4__core_course_providers_course__["a" /* CoreCourseProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], AddonModUrlProvider);
    return AddonModUrlProvider;
}());

//# sourceMappingURL=url.js.map

/***/ }),
/* 166 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreEmulatorCaptureHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_mimetype__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__ = __webpack_require__(9);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Helper service with some features to capture media (image, audio, video).
 */
var CoreEmulatorCaptureHelperProvider = /** @class */ (function () {
    function CoreEmulatorCaptureHelperProvider(utils, mimeUtils, modalCtrl) {
        this.utils = utils;
        this.mimeUtils = mimeUtils;
        this.modalCtrl = modalCtrl;
        this.possibleAudioMimeTypes = {
            'audio/webm': 'weba',
            'audio/ogg': 'ogg'
        };
        this.possibleVideoMimeTypes = {
            'video/webm;codecs=vp9': 'webm',
            'video/webm;codecs=vp8': 'webm',
            'video/ogg': 'ogv'
        };
        // Convert the window to "any" type because some of the variables used (like MediaRecorder) aren't in the window spec.
        this.win = window;
    }
    /**
     * Capture media (image, audio, video).
     *
     * @param {string} type Type of media: image, audio, video.
     * @param {any} [options] Optional options.
     * @return {Promise<any>} Promise resolved when captured, rejected if error.
     */
    CoreEmulatorCaptureHelperProvider.prototype.captureMedia = function (type, options) {
        options = options || {};
        try {
            // Build the params to send to the modal.
            var deferred_1 = this.utils.promiseDefer(), params = {
                type: type
            };
            var mimeAndExt = void 0, modal = void 0;
            // Initialize some data based on the type of media to capture.
            if (type == 'video') {
                mimeAndExt = this.getMimeTypeAndExtension(type, options.mimetypes);
                params.mimetype = mimeAndExt.mimetype;
                params.extension = mimeAndExt.extension;
            }
            else if (type == 'audio') {
                mimeAndExt = this.getMimeTypeAndExtension(type, options.mimetypes);
                params.mimetype = mimeAndExt.mimetype;
                params.extension = mimeAndExt.extension;
            }
            else if (type == 'image') {
                if (typeof options.sourceType != 'undefined' && options.sourceType != 1) {
                    return Promise.reject('This source type is not supported in desktop.');
                }
                if (options.cameraDirection == 1) {
                    params.facingMode = 'user';
                }
                if (options.encodingType == 1) {
                    params.mimetype = 'image/png';
                    params.extension = 'png';
                }
                else {
                    params.mimetype = 'image/jpeg';
                    params.extension = 'jpeg';
                }
                if (options.quality >= 0 && options.quality <= 100) {
                    params.quality = options.quality / 100;
                }
                if (options.destinationType == 0) {
                    params.returnDataUrl = true;
                }
            }
            if (options.duration) {
                params.maxTime = options.duration * 1000;
            }
            modal = this.modalCtrl.create('CoreEmulatorCaptureMediaPage', params);
            modal.present();
            modal.onDidDismiss(function (data, role) {
                if (role == 'success') {
                    deferred_1.resolve(data);
                }
                else {
                    deferred_1.reject(data);
                }
            });
            return deferred_1.promise;
        }
        catch (ex) {
            return Promise.reject(ex.toString());
        }
    };
    /**
     * Get the mimetype and extension to capture media.
     *
     * @param {string} type Type of media: image, audio, video.
     * @param {string[]} [mimetypes] List of supported mimetypes. If undefined, all mimetypes supported.
     * @return {{extension: string, mimetype: string}} An object with mimetype and extension to use.
     */
    CoreEmulatorCaptureHelperProvider.prototype.getMimeTypeAndExtension = function (type, mimetypes) {
        var result = {};
        if (mimetypes && mimetypes.length) {
            // Search for a supported mimetype.
            for (var i = 0; i < mimetypes.length; i++) {
                var mimetype = mimetypes[i], matches = mimetype.match(new RegExp('^' + type + '/'));
                if (matches && matches.length && this.win.MediaRecorder.isTypeSupported(mimetype)) {
                    result.mimetype = mimetype;
                    break;
                }
            }
        }
        if (result.mimetype) {
            // Found a supported mimetype in the mimetypes array, get the extension.
            result.extension = this.mimeUtils.getExtension(result.mimetype);
        }
        else if (type == 'video') {
            // No mimetype found, use default extension.
            result.mimetype = this.videoMimeType;
            result.extension = this.possibleVideoMimeTypes[result.mimetype];
        }
        else if (type == 'audio') {
            // No mimetype found, use default extension.
            result.mimetype = this.audioMimeType;
            result.extension = this.possibleAudioMimeTypes[result.mimetype];
        }
        return result;
    };
    /**
     * Init the getUserMedia function, using a deprecated function as fallback if the new one doesn't exist.
     *
     * @return {boolean} Whether the function is supported.
     */
    CoreEmulatorCaptureHelperProvider.prototype.initGetUserMedia = function () {
        var _this = this;
        var nav = navigator;
        // Check if there is a function to get user media.
        if (typeof nav.mediaDevices == 'undefined') {
            nav.mediaDevices = {};
        }
        if (!nav.mediaDevices.getUserMedia) {
            // New function doesn't exist, check if the deprecated function is supported.
            nav.getUserMedia = nav.getUserMedia || nav.webkitGetUserMedia || nav.mozGetUserMedia || nav.msGetUserMedia;
            if (nav.getUserMedia) {
                // Deprecated function exists, support the new function using the deprecated one.
                navigator.mediaDevices.getUserMedia = function (constraints) {
                    var deferred = _this.utils.promiseDefer();
                    nav.getUserMedia(constraints, deferred.resolve, deferred.reject);
                    return deferred.promise;
                };
            }
            else {
                return false;
            }
        }
        return true;
    };
    /**
     * Initialize the mimetypes to use when capturing.
     */
    CoreEmulatorCaptureHelperProvider.prototype.initMimeTypes = function () {
        // Determine video and audio mimetype to use.
        for (var mimeType in this.possibleVideoMimeTypes) {
            if (this.win.MediaRecorder.isTypeSupported(mimeType)) {
                this.videoMimeType = mimeType;
                break;
            }
        }
        for (var mimeType in this.possibleAudioMimeTypes) {
            if (this.win.MediaRecorder.isTypeSupported(mimeType)) {
                this.audioMimeType = mimeType;
                break;
            }
        }
    };
    /**
     * Load the Mocks that need it.
     *
     * @return {Promise<void>} Promise resolved when loaded.
     */
    CoreEmulatorCaptureHelperProvider.prototype.load = function () {
        if (typeof this.win.MediaRecorder != 'undefined' && this.initGetUserMedia()) {
            this.initMimeTypes();
        }
        return Promise.resolve();
    };
    CoreEmulatorCaptureHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_mimetype__["a" /* CoreMimetypeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["j" /* ModalController */]])
    ], CoreEmulatorCaptureHelperProvider);
    return CoreEmulatorCaptureHelperProvider;
}());

//# sourceMappingURL=capture-helper.js.map

/***/ }),
/* 167 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */,
/* 178 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSplitViewComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
// Code based on https://github.com/martinpritchardelevate/ionic-split-pane-demo


/**
 * Directive to create a split view layout.
 *
 * @description
 * To init/change the right pane contents (content pane), inject this component in the master page.
 * @ViewChild(CoreSplitViewComponent) splitviewCtrl: CoreSplitViewComponent;
 * Then use the push function to load.
 *
 * Accepts the following params:
 *
 * @param {string|boolean} [when] When the split-pane should be shown. Can be a CSS media query expression, or a shortcut
 * expression. Can also be a boolean expression. Check split-pane component documentation for more information.
 *
 * Example:
 *
 * <core-split-view [when]="lg">
 *     <ion-content><!-- CONTENT TO SHOW ON THE LEFT PANEL (MENU) --></ion-content>
 * </core-split-view>
 */
var CoreSplitViewComponent = /** @class */ (function () {
    function CoreSplitViewComponent(masterNav, element) {
        this.masterNav = masterNav;
        this.when = 'md';
        this.isEnabled = false;
        this.masterPageName = '';
        this.masterPageIndex = 0;
        this.loadDetailPage = false;
        // Empty placeholder for the 'detail' page.
        this.detailPage = null;
        this.element = element.nativeElement;
    }
    /**
     * Component being initialized.
     */
    CoreSplitViewComponent.prototype.ngOnInit = function () {
        // Get the master page name and set an empty page as a placeholder.
        this.masterPageName = this.masterNav.getActive().component.name;
        this.masterPageIndex = this.masterNav.indexOf(this.masterNav.getActive());
        this.emptyDetails();
    };
    /**
     * Get the details NavController. If split view is not enabled, it will return the master nav.
     *
     * @return {NavController} Details NavController.
     */
    CoreSplitViewComponent.prototype.getDetailsNav = function () {
        if (this.isEnabled) {
            return this.detailNav;
        }
        else {
            return this.masterNav;
        }
    };
    /**
     * Get the master NavController.
     *
     * @return {NavController} Master NavController.
     */
    CoreSplitViewComponent.prototype.getMasterNav = function () {
        return this.masterNav;
    };
    /**
     * Check if both panels are shown. It depends on screen width.
     *
     * @return {boolean} If split view is enabled.
     */
    CoreSplitViewComponent.prototype.isOn = function () {
        return this.isEnabled;
    };
    /**
     * Push a page to the navigation stack. It will decide where to load it depending on the size of the screen.
     *
     * @param {any} page   The component class or deeplink name you want to push onto the navigation stack.
     * @param {any} params Any NavParams you want to pass along to the next view.
     */
    CoreSplitViewComponent.prototype.push = function (page, params) {
        if (this.isEnabled) {
            this.detailNav.setRoot(page, params);
        }
        else {
            this.loadDetailPage = {
                component: page,
                data: params
            };
            this.masterNav.push(page, params);
        }
    };
    /**
     * Set the details panel to default info.
     */
    CoreSplitViewComponent.prototype.emptyDetails = function () {
        this.loadDetailPage = false;
        this.detailNav.setRoot('CoreSplitViewPlaceholderPage');
    };
    /**
     * Splitpanel visibility has changed.
     *
     * @param {Boolean} isOn If it fits both panels at the same time.
     */
    CoreSplitViewComponent.prototype.onSplitPaneChanged = function (isOn) {
        this.isEnabled = isOn;
        if (this.masterNav && this.detailNav) {
            (isOn) ? this.activateSplitView() : this.deactivateSplitView();
        }
    };
    /**
     * Enable the split view, show both panels and do some magical navigation.
     */
    CoreSplitViewComponent.prototype.activateSplitView = function () {
        var currentView = this.masterNav.getActive(), currentPageName = currentView.component.name;
        if (this.masterNav.getPrevious() && this.masterNav.getPrevious().component.name == this.masterPageName) {
            if (currentPageName != this.masterPageName) {
                // CurrentView is a 'Detail' page remove it from the 'master' nav stack.
                this.masterNav.pop();
                // And add it to the 'detail' nav stack.
                this.detailNav.setRoot(currentView.component, currentView.data);
            }
            else if (this.loadDetailPage) {
                // MasterPage is shown, load the last detail page if found.
                this.detailNav.setRoot(this.loadDetailPage.component, this.loadDetailPage.data);
            }
            this.loadDetailPage = false;
        }
    };
    /**
     * Disabled the split view, show only one panel and do some magical navigation.
     */
    CoreSplitViewComponent.prototype.deactivateSplitView = function () {
        var detailView = this.detailNav.getActive(), currentPageName = detailView.component.name;
        if (currentPageName != 'CoreSplitViewPlaceholderPage') {
            // Current detail view is a 'Detail' page so, not the placeholder page, push it on 'master' nav stack.
            this.masterNav.insert(this.masterPageIndex + 1, detailView.component, detailView.data);
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])('detailNav'),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["k" /* Nav */])
    ], CoreSplitViewComponent.prototype, "detailNav", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreSplitViewComponent.prototype, "when", void 0);
    CoreSplitViewComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-split-view',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/components/split-view/split-view.html"*/'<ion-split-pane (ionChange)="onSplitPaneChanged($event._visible);" [when]="when">\n    <ion-menu [content]="detailNav" type="push" class="core-avoid-header">\n        <ng-content></ng-content>\n    </ion-menu>\n    <ion-nav [root]="detailPage" #detailNav main class="core-avoid-header"></ion-nav>\n</ion-split-pane>'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/components/split-view/split-view.html"*/
        }),
        __param(0, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["N" /* Optional */])()),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavController */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */]])
    ], CoreSplitViewComponent);
    return CoreSplitViewComponent;
}());

//# sourceMappingURL=split-view.js.map

/***/ }),
/* 179 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonFilesProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_mimetype__ = __webpack_require__(44);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Service to handle my files and site files.
 */
var AddonFilesProvider = /** @class */ (function () {
    function AddonFilesProvider(sitesProvider, mimeUtils) {
        this.sitesProvider = sitesProvider;
        this.mimeUtils = mimeUtils;
        this.ROOT_CACHE_KEY = 'mmaFiles:';
    }
    /**
     * Check if core_user_get_private_files_info WS call is available.
     *
     * @return {boolean} Whether the WS is available, false otherwise.
     */
    AddonFilesProvider.prototype.canGetPrivateFilesInfo = function () {
        return this.sitesProvider.wsAvailableInCurrentSite('core_user_get_private_files_info');
    };
    /**
     * Check if user can view his private files.
     *
     * @return {boolean} Whether the user can view his private files.
     */
    AddonFilesProvider.prototype.canViewPrivateFiles = function () {
        return this.sitesProvider.getCurrentSite().canAccessMyFiles() && !this.isPrivateFilesDisabledInSite();
    };
    /**
     * Check if user can view site files.
     *
     * @return {boolean} Whether the user can view site files.
     */
    AddonFilesProvider.prototype.canViewSiteFiles = function () {
        return !this.isSiteFilesDisabledInSite();
    };
    /**
     * Check if user can upload private files.
     *
     * @return {boolean} Whether the user can upload private files.
     */
    AddonFilesProvider.prototype.canUploadFiles = function () {
        var currentSite = this.sitesProvider.getCurrentSite();
        return currentSite.canAccessMyFiles() && currentSite.canUploadFiles() && !this.isUploadDisabledInSite();
    };
    /**
     * Get the list of files.
     *
     * @param {any} params A list of parameters accepted by the Web service.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved with the files.
     */
    AddonFilesProvider.prototype.getFiles = function (params, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var preSets = {
                cacheKey: _this.getFilesListCacheKey(params)
            };
            return site.read('core_files_get_files', params, preSets);
        }).then(function (result) {
            var entries = [];
            if (result.files) {
                result.files.forEach(function (entry) {
                    if (entry.isdir) {
                        // Create a "link" to load the folder.
                        entry.link = {
                            contextid: entry.contextid || '',
                            component: entry.component || '',
                            filearea: entry.filearea || '',
                            itemid: entry.itemid || 0,
                            filepath: entry.filepath || '',
                            filename: entry.filename || ''
                        };
                        if (entry.component) {
                            // Delete unused elements that may break the request.
                            entry.link.filename = '';
                        }
                    }
                    if (entry.isdir) {
                        entry.imgPath = _this.mimeUtils.getFolderIcon();
                    }
                    else {
                        entry.imgPath = _this.mimeUtils.getFileIcon(entry.filename);
                    }
                    entries.push(entry);
                });
            }
            return entries;
        });
    };
    /**
     * Get cache key for file list WS calls.
     *
     * @param {any} params Params of the WS.
     * @return {string} Cache key.
     */
    AddonFilesProvider.prototype.getFilesListCacheKey = function (params) {
        var root = !params.component ? 'site' : 'my';
        return this.ROOT_CACHE_KEY + 'list:' + root + ':' + params.contextid + ':' + params.filepath;
    };
    /**
     * Get the private files of the current user.
     *
     * @return {Promise<any[]>} Promise resolved with the files.
     */
    AddonFilesProvider.prototype.getPrivateFiles = function () {
        return this.getFiles(this.getPrivateFilesRootParams());
    };
    /**
     * Get params to get root private files directory.
     *
     * @return {any} Params.
     */
    AddonFilesProvider.prototype.getPrivateFilesRootParams = function () {
        return {
            contextid: -1,
            component: 'user',
            filearea: 'private',
            contextlevel: 'user',
            instanceid: this.sitesProvider.getCurrentSite().getUserId(),
            itemid: 0,
            filepath: '',
            filename: ''
        };
    };
    /**
     * Get private files info.
     *
     * @param {number} [userId] User ID. If not defined, current user in the site.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any>} Promise resolved with the info.
     */
    AddonFilesProvider.prototype.getPrivateFilesInfo = function (userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            var params = {
                userid: userId
            }, preSets = {
                cacheKey: _this.getPrivateFilesInfoCacheKey(userId)
            };
            return site.read('core_user_get_private_files_info', params, preSets);
        });
    };
    /**
     * Get the cache key for private files info WS calls.
     *
     * @param {number} userId User ID.
     * @return {string} Cache key.
     */
    AddonFilesProvider.prototype.getPrivateFilesInfoCacheKey = function (userId) {
        return this.getPrivateFilesInfoCommonCacheKey() + ':' + userId;
    };
    /**
     * Get the common part of the cache keys for private files info WS calls.
     *
     * @return {string} Cache key.
     */
    AddonFilesProvider.prototype.getPrivateFilesInfoCommonCacheKey = function () {
        return this.ROOT_CACHE_KEY + 'privateInfo';
    };
    /**
     * Get the site files.
     *
     * @return {Promise<any[]>} Promise resolved with the files.
     */
    AddonFilesProvider.prototype.getSiteFiles = function () {
        return this.getFiles(this.getSiteFilesRootParams());
    };
    /**
     * Get params to get root site files directory.
     *
     * @return {any} Params.
     */
    AddonFilesProvider.prototype.getSiteFilesRootParams = function () {
        return {
            contextid: 0,
            component: '',
            filearea: '',
            itemid: 0,
            filepath: '',
            filename: ''
        };
    };
    /**
     * Invalidates list of files in a certain directory.
     *
     * @param {string} root Root of the directory ('my' for private files, 'site' for site files).
     * @param {string} path Path to the directory.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonFilesProvider.prototype.invalidateDirectory = function (root, path, siteId) {
        var _this = this;
        var params;
        if (!path) {
            if (root === 'site') {
                params = this.getSiteFilesRootParams();
            }
            else if (root === 'my') {
                params = this.getPrivateFilesRootParams();
            }
        }
        else {
            params = path;
        }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getFilesListCacheKey(params));
        });
    };
    /**
     * Invalidates private files info for all users.
     *
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonFilesProvider.prototype.invalidatePrivateFilesInfo = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getPrivateFilesInfoCommonCacheKey());
        });
    };
    /**
     * Invalidates private files info for a certain user.
     *
     * @param {number} [userId] User ID. If not defined, current user in the site.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonFilesProvider.prototype.invalidatePrivateFilesInfoForUser = function (userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(_this.getPrivateFilesInfoCacheKey(userId));
        });
    };
    /**
     * Check if Files is disabled in a certain site.
     *
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<boolean>} Promise resolved with true if disabled, rejected or resolved with false otherwise.
     */
    AddonFilesProvider.prototype.isDisabled = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.isDisabledInSite(site);
        });
    };
    /**
     * Check if Files is disabled in a certain site.
     *
     * @param {CoreSite} [site] Site. If not defined, use current site.
     * @return {boolean} Whether it's disabled.
     */
    AddonFilesProvider.prototype.isDisabledInSite = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.isFeatureDisabled('$mmSideMenuDelegate_mmaFiles');
    };
    /**
     * Return whether or not the plugin is enabled.
     *
     * @return {boolean} True if enabled, false otherwise.
     */
    AddonFilesProvider.prototype.isPluginEnabled = function () {
        return this.canViewPrivateFiles() || this.canViewSiteFiles() || this.canUploadFiles();
    };
    /**
     * Check if private files is disabled in a certain site.
     *
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<boolean>} Promise resolved with true if disabled, rejected or resolved with false otherwise.
     */
    AddonFilesProvider.prototype.isPrivateFilesDisabled = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.isPrivateFilesDisabledInSite(site);
        });
    };
    /**
     * Check if private files is disabled in a certain site.
     *
     * @param {CoreSite} [site] Site. If not defined, use current site.
     * @return {boolean} Whether it's disabled.
     */
    AddonFilesProvider.prototype.isPrivateFilesDisabledInSite = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.isFeatureDisabled('files_privatefiles');
    };
    /**
     * Check if site files is disabled in a certain site.
     *
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<boolean>} Promise resolved with true if disabled, rejected or resolved with false otherwise.
     */
    AddonFilesProvider.prototype.isSiteFilesDisabled = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.isSiteFilesDisabledInSite(site);
        });
    };
    /**
     * Check if site files is disabled in a certain site.
     *
     * @param {CoreSite} [site] Site. If not defined, use current site.
     * @return {boolean} Whether it's disabled.
     */
    AddonFilesProvider.prototype.isSiteFilesDisabledInSite = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.isFeatureDisabled('files_sitefiles');
    };
    /**
     * Check if upload files is disabled in a certain site.
     *
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<boolean>} Promise resolved with true if disabled, rejected or resolved with false otherwise.
     */
    AddonFilesProvider.prototype.isUploadDisabled = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.isUploadDisabledInSite(site);
        });
    };
    /**
     * Check if upload files is disabled in a certain site.
     *
     * @param {CoreSite} [site] Site. If not defined, use current site.
     * @return {boolean} Whether it's disabled.
     */
    AddonFilesProvider.prototype.isUploadDisabledInSite = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.isFeatureDisabled('files_upload');
    };
    /**
     * Move a file from draft area to private files.
     *
     * @param {number} draftId The draft area ID of the file.
     * @param {string} [siteid] ID of the site. If not defined, use current site.
     * @return {Promise<any>} Promise resolved in success, rejected otherwise.
     */
    AddonFilesProvider.prototype.moveFromDraftToPrivate = function (draftId, siteId) {
        var params = {
            draftid: draftId
        }, preSets = {
            responseExpected: false
        };
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.write('core_user_add_user_private_files', params, preSets);
        });
    };
    /**
     * Check the Moodle version in order to check if upload files is working.
     *
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<boolean>} Promise resolved with true if WS is working, false otherwise.
     */
    AddonFilesProvider.prototype.versionCanUploadFiles = function (siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            // Upload private files doesn't work for Moodle 3.1.0 due to a bug.
            return site.isVersionGreaterEqualThan('3.1.1');
        });
    };
    AddonFilesProvider.PRIVATE_FILES_COMPONENT = 'mmaFilesMy';
    AddonFilesProvider.SITE_FILES_COMPONENT = 'mmaFilesSite';
    AddonFilesProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_mimetype__["a" /* CoreMimetypeUtilsProvider */]])
    ], AddonFilesProvider);
    return AddonFilesProvider;
}());

//# sourceMappingURL=files.js.map

/***/ }),
/* 180 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCoursesMyOverviewProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_moment__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_moment__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Service that provides some features regarding course overview.
 */
var CoreCoursesMyOverviewProvider = /** @class */ (function () {
    function CoreCoursesMyOverviewProvider(sitesProvider) {
        this.sitesProvider = sitesProvider;
        this.ROOT_CACHE_KEY = 'myoverview:';
    }
    CoreCoursesMyOverviewProvider_1 = CoreCoursesMyOverviewProvider;
    /**
     * Get calendar action events for the given course.
     *
     * @param {number} courseId Only events in this course.
     * @param {number} [afterEventId] The last seen event id.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<{events: any[], canLoadMore: number}>} Promise resolved when the info is retrieved.
     */
    CoreCoursesMyOverviewProvider.prototype.getActionEventsByCourse = function (courseId, afterEventId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var time = __WEBPACK_IMPORTED_MODULE_2_moment__().subtract(14, 'days').unix(), // Check two weeks ago.
            data = {
                timesortfrom: time,
                courseid: courseId,
                limitnum: CoreCoursesMyOverviewProvider_1.EVENTS_LIMIT_PER_COURSE
            }, preSets = {
                cacheKey: _this.getActionEventsByCourseCacheKey(courseId)
            };
            if (afterEventId) {
                data.aftereventid = afterEventId;
            }
            return site.read('core_calendar_get_action_events_by_course', data, preSets).then(function (courseEvents) {
                if (courseEvents && courseEvents.events) {
                    return _this.treatCourseEvents(courseEvents, time);
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get cache key for get calendar action events for the given course value WS call.
     *
     * @param {number} courseId Only events in this course.
     * @return {string} Cache key.
     */
    CoreCoursesMyOverviewProvider.prototype.getActionEventsByCourseCacheKey = function (courseId) {
        return this.getActionEventsByCoursesCacheKey() + ':' + courseId;
    };
    /**
     * Get calendar action events for a given list of courses.
     *
     * @param {number[]} courseIds Course IDs.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<{[s: string]: {events: any[], canLoadMore: number}}>} Promise resolved when the info is retrieved.
     */
    CoreCoursesMyOverviewProvider.prototype.getActionEventsByCourses = function (courseIds, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var time = __WEBPACK_IMPORTED_MODULE_2_moment__().subtract(14, 'days').unix(), // Check two weeks ago.
            data = {
                timesortfrom: time,
                courseids: courseIds,
                limitnum: CoreCoursesMyOverviewProvider_1.EVENTS_LIMIT_PER_COURSE
            }, preSets = {
                cacheKey: _this.getActionEventsByCoursesCacheKey()
            };
            return site.read('core_calendar_get_action_events_by_courses', data, preSets).then(function (events) {
                if (events && events.groupedbycourse) {
                    var courseEvents_1 = {};
                    events.groupedbycourse.forEach(function (course) {
                        courseEvents_1[course.courseid] = _this.treatCourseEvents(course, time);
                    });
                    return courseEvents_1;
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get cache key for get calendar action events for a given list of courses value WS call.
     *
     * @return {string} Cache key.
     */
    CoreCoursesMyOverviewProvider.prototype.getActionEventsByCoursesCacheKey = function () {
        return this.ROOT_CACHE_KEY + 'bycourse';
    };
    /**
     * Get calendar action events based on the timesort value.
     *
     * @param {number} [afterEventId] The last seen event id.
     * @param {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<{events: any[], canLoadMore: number}>} Promise resolved when the info is retrieved.
     */
    CoreCoursesMyOverviewProvider.prototype.getActionEventsByTimesort = function (afterEventId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var time = __WEBPACK_IMPORTED_MODULE_2_moment__().subtract(14, 'days').unix(), // Check two weeks ago.
            data = {
                timesortfrom: time,
                limitnum: CoreCoursesMyOverviewProvider_1.EVENTS_LIMIT
            }, preSets = {
                cacheKey: _this.getActionEventsByTimesortCacheKey(afterEventId, data.limitnum),
                getCacheUsingCacheKey: true,
                uniqueCacheKey: true
            };
            if (afterEventId) {
                data.aftereventid = afterEventId;
            }
            return site.read('core_calendar_get_action_events_by_timesort', data, preSets).then(function (events) {
                if (events && events.events) {
                    var canLoadMore = events.events.length >= data.limitnum ? events.lastid : undefined;
                    // Filter events by time in case it uses cache.
                    events = events.events.filter(function (element) {
                        return element.timesort >= time;
                    });
                    return {
                        events: events,
                        canLoadMore: canLoadMore
                    };
                }
                return Promise.reject(null);
            });
        });
    };
    /**
     * Get prefix cache key for calendar action events based on the timesort value WS calls.
     *
     * @return {string} Cache key.
     */
    CoreCoursesMyOverviewProvider.prototype.getActionEventsByTimesortPrefixCacheKey = function () {
        return this.ROOT_CACHE_KEY + 'bytimesort:';
    };
    /**
     * Get cache key for get calendar action events based on the timesort value WS call.
     *
     * @param {number} [afterEventId] The last seen event id.
     * @param {number} [limit] Limit num of the call.
     * @return {string} Cache key.
     */
    CoreCoursesMyOverviewProvider.prototype.getActionEventsByTimesortCacheKey = function (afterEventId, limit) {
        afterEventId = afterEventId || 0;
        limit = limit || 0;
        return this.getActionEventsByTimesortPrefixCacheKey() + afterEventId + ':' + limit;
    };
    /**
     * Invalidates get calendar action events for a given list of courses WS call.
     *
     * @param {string} [siteId] Site ID to invalidate. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesMyOverviewProvider.prototype.invalidateActionEventsByCourses = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getActionEventsByCoursesCacheKey());
        });
    };
    /**
     * Invalidates get calendar action events based on the timesort value WS call.
     *
     * @param {string} [siteId] Site ID to invalidate. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCoursesMyOverviewProvider.prototype.invalidateActionEventsByTimesort = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKeyStartingWith(_this.getActionEventsByTimesortPrefixCacheKey());
        });
    };
    /**
     * Returns whether or not My Overview is available for a certain site.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with true if available, resolved with false or rejected otherwise.
     */
    CoreCoursesMyOverviewProvider.prototype.isAvailable = function (siteId) {
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.wsAvailable('core_calendar_get_action_events_by_courses');
        });
    };
    /**
     * Check if My Overview is disabled in a certain site.
     *
     * @param {CoreSite} [site] Site. If not defined, use current site.
     * @return {boolean} Whether it's disabled.
     */
    CoreCoursesMyOverviewProvider.prototype.isDisabledInSite = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.isFeatureDisabled('$mmSideMenuDelegate_mmaMyOverview');
    };
    /**
     * Check if My Overview is available and not disabled.
     *
     * @return {Promise<boolean>} Promise resolved with true if enabled, resolved with false otherwise.
     */
    CoreCoursesMyOverviewProvider.prototype.isEnabled = function () {
        if (!this.isDisabledInSite()) {
            return this.isAvailable().catch(function () {
                return false;
            });
        }
        return Promise.resolve(false);
    };
    /**
     * Handles course events, filtering and treating if more can be loaded.
     *
     * @param {any} course Object containing response course events info.
     * @param {number} timeFrom Current time to filter events from.
     * @return {{events: any[], canLoadMore: number}} Object with course events and last loaded event id if more can be loaded.
     */
    CoreCoursesMyOverviewProvider.prototype.treatCourseEvents = function (course, timeFrom) {
        var canLoadMore = course.events.length >= CoreCoursesMyOverviewProvider_1.EVENTS_LIMIT_PER_COURSE ? course.lastid : undefined;
        // Filter events by time in case it uses cache.
        course.events = course.events.filter(function (element) {
            return element.timesort >= timeFrom;
        });
        return {
            events: course.events,
            canLoadMore: canLoadMore
        };
    };
    CoreCoursesMyOverviewProvider.EVENTS_LIMIT = 20;
    CoreCoursesMyOverviewProvider.EVENTS_LIMIT_PER_COURSE = 10;
    CoreCoursesMyOverviewProvider = CoreCoursesMyOverviewProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_sites__["a" /* CoreSitesProvider */]])
    ], CoreCoursesMyOverviewProvider);
    return CoreCoursesMyOverviewProvider;
    var CoreCoursesMyOverviewProvider_1;
}());

//# sourceMappingURL=my-overview.js.map

/***/ }),
/* 181 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSitePluginsModuleIndexComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_text__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_siteplugins__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_course_providers_module_prefetch_delegate__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__core_course_providers_helper__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__plugin_content_plugin_content__ = __webpack_require__(81);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};







/**
 * Component that displays the index of a module site plugin.
 */
var CoreSitePluginsModuleIndexComponent = /** @class */ (function () {
    function CoreSitePluginsModuleIndexComponent(sitePluginsProvider, courseHelper, prefetchDelegate, textUtils, translate) {
        this.sitePluginsProvider = sitePluginsProvider;
        this.courseHelper = courseHelper;
        this.prefetchDelegate = prefetchDelegate;
        this.textUtils = textUtils;
        this.translate = translate;
        this.isDestroyed = false;
    }
    /**
     * Component being initialized.
     */
    CoreSitePluginsModuleIndexComponent.prototype.ngOnInit = function () {
        this.refreshIcon = 'spinner';
        if (this.module) {
            var handler = this.sitePluginsProvider.getSitePluginHandler(this.module.modname);
            if (handler) {
                this.component = handler.plugin.component;
                this.method = handler.handlerSchema.method;
                this.args = {
                    courseid: this.courseId,
                    cmid: this.module.id
                };
                this.bootstrapResult = handler.bootstrapResult;
            }
            // Get the data for the context menu.
            this.description = this.module.description;
            this.externalUrl = this.module.url;
        }
    };
    /**
     * Refresh the data.
     *
     * @param {any} [refresher] Refresher.
     * @param {Function} [done] Function to call when done.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreSitePluginsModuleIndexComponent.prototype.doRefresh = function (refresher, done) {
        if (this.content) {
            this.refreshIcon = 'spinner';
            return Promise.resolve(this.content.refreshData()).finally(function () {
                refresher && refresher.complete();
                done && done();
            });
        }
        else {
            refresher && refresher.complete();
            done && done();
            return Promise.resolve();
        }
    };
    /**
     * Function called when the data of the site plugin content is loaded.
     */
    CoreSitePluginsModuleIndexComponent.prototype.contentLoaded = function (refresh) {
        this.refreshIcon = 'refresh';
        // Check if there is a prefetch handler for this type of module.
        if (this.prefetchDelegate.getPrefetchHandlerFor(this.module)) {
            this.courseHelper.fillContextMenu(this, this.module, this.courseId, refresh, this.component);
        }
    };
    /**
     * Function called when starting to load the data of the site plugin content.
     */
    CoreSitePluginsModuleIndexComponent.prototype.contentLoading = function (refresh) {
        this.refreshIcon = 'spinner';
    };
    /**
     * Expand the description.
     */
    CoreSitePluginsModuleIndexComponent.prototype.expandDescription = function () {
        this.textUtils.expandText(this.translate.instant('core.description'), this.description, this.component, this.module.id);
    };
    /**
     * Prefetch the module.
     */
    CoreSitePluginsModuleIndexComponent.prototype.prefetch = function () {
        this.courseHelper.contextMenuPrefetch(this, this.module, this.courseId);
    };
    /**
     * Confirm and remove downloaded files.
     */
    CoreSitePluginsModuleIndexComponent.prototype.removeFiles = function () {
        this.courseHelper.confirmAndRemoveFiles(this.module, this.courseId);
    };
    /**
     * Component destroyed.
     */
    CoreSitePluginsModuleIndexComponent.prototype.ngOnDestroy = function () {
        this.isDestroyed = true;
        this.statusObserver && this.statusObserver.off();
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreSitePluginsModuleIndexComponent.prototype, "module", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreSitePluginsModuleIndexComponent.prototype, "courseId", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])(__WEBPACK_IMPORTED_MODULE_6__plugin_content_plugin_content__["a" /* CoreSitePluginsPluginContentComponent */]),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_6__plugin_content_plugin_content__["a" /* CoreSitePluginsPluginContentComponent */])
    ], CoreSitePluginsModuleIndexComponent.prototype, "content", void 0);
    CoreSitePluginsModuleIndexComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-site-plugins-module-index',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/core/siteplugins/components/module-index/module-index.html"*/'<!-- Buttons to add to the header. -->\n<core-navbar-buttons end>\n    <core-context-menu>\n        <core-context-menu-item *ngIf="externalUrl" [priority]="900" [content]="\'core.openinbrowser\' | translate" [href]="externalUrl" [iconAction]="\'open\'"></core-context-menu-item>\n        <core-context-menu-item *ngIf="description" [priority]="800" [content]="\'core.moduleintro\' | translate" (action)="expandDescription()" [iconAction]="\'arrow-forward\'"></core-context-menu-item>\n        <core-context-menu-item [priority]="700" [content]="\'core.refresh\' | translate" (action)="doRefresh(null, $event)" [iconAction]="refreshIcon" [closeOnClick]="false"></core-context-menu-item>\n        <core-context-menu-item *ngIf="prefetchStatusIcon" [priority]="600" [content]="prefetchText" (action)="prefetch()" [iconAction]="prefetchStatusIcon" [closeOnClick]="false"></core-context-menu-item>\n        <core-context-menu-item *ngIf="size" [priority]="500" [content]="size" [iconDescription]="\'cube\'" (action)="removeFiles()" [iconAction]="\'trash\'"></core-context-menu-item>\n    </core-context-menu>\n</core-navbar-buttons>\n\n<core-site-plugins-plugin-content *ngIf="component && method" [component]="component" [method]="method" [args]="args" [bootstrapResult]="bootstrapResult" (onContentLoaded)="contentLoaded($event)" (onLoadingContent)="contentLoading($event)"></core-site-plugins-plugin-content>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/core/siteplugins/components/module-index/module-index.html"*/,
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_siteplugins__["a" /* CoreSitePluginsProvider */], __WEBPACK_IMPORTED_MODULE_5__core_course_providers_helper__["a" /* CoreCourseHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_4__core_course_providers_module_prefetch_delegate__["a" /* CoreCourseModulePrefetchDelegate */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_text__["a" /* CoreTextUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
    ], CoreSitePluginsModuleIndexComponent);
    return CoreSitePluginsModuleIndexComponent;
}());

//# sourceMappingURL=module-index.js.map

/***/ }),
/* 182 */,
/* 183 */,
/* 184 */,
/* 185 */,
/* 186 */,
/* 187 */,
/* 188 */,
/* 189 */,
/* 190 */,
/* 191 */,
/* 192 */,
/* 193 */,
/* 194 */,
/* 195 */,
/* 196 */,
/* 197 */,
/* 198 */,
/* 199 */,
/* 200 */,
/* 201 */,
/* 202 */,
/* 203 */,
/* 204 */,
/* 205 */,
/* 206 */,
/* 207 */,
/* 208 */,
/* 209 */,
/* 210 */,
/* 211 */,
/* 212 */,
/* 213 */,
/* 214 */,
/* 215 */,
/* 216 */,
/* 217 */,
/* 218 */,
/* 219 */,
/* 220 */,
/* 221 */,
/* 222 */,
/* 223 */,
/* 224 */,
/* 225 */,
/* 226 */,
/* 227 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreDbProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_sqlite__ = __webpack_require__(494);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__classes_sqlitedb__ = __webpack_require__(495);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_emulator_classes_sqlitedb__ = __webpack_require__(771);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * This service allows interacting with the local database to store and retrieve data.
 */
var CoreDbProvider = /** @class */ (function () {
    function CoreDbProvider(sqlite, platform) {
        this.sqlite = sqlite;
        this.platform = platform;
        this.dbInstances = {};
    }
    /**
     * Get or create a database object.
     *
     * The database objects are cached statically.
     *
     * @param {string} name DB name.
     * @param {boolean} forceNew True if it should always create a new instance.
     * @return {SQLiteDB} DB.
     */
    CoreDbProvider.prototype.getDB = function (name, forceNew) {
        if (typeof this.dbInstances[name] === 'undefined' || forceNew) {
            if (this.platform.is('cordova')) {
                this.dbInstances[name] = new __WEBPACK_IMPORTED_MODULE_3__classes_sqlitedb__["a" /* SQLiteDB */](name, this.sqlite, this.platform);
            }
            else {
                this.dbInstances[name] = new __WEBPACK_IMPORTED_MODULE_4__core_emulator_classes_sqlitedb__["a" /* SQLiteDBMock */](name);
            }
        }
        return this.dbInstances[name];
    };
    /**
     * Delete a DB.
     *
     * @param {string} name DB name.
     * @return {Promise<any>} Promise resolved when the DB is deleted.
     */
    CoreDbProvider.prototype.deleteDB = function (name) {
        var _this = this;
        var promise;
        if (typeof this.dbInstances[name] != 'undefined') {
            // Close the database first.
            promise = this.dbInstances[name].close();
        }
        else {
            promise = Promise.resolve();
        }
        return promise.then(function () {
            var db = _this.dbInstances[name];
            delete _this.dbInstances[name];
            if (_this.platform.is('cordova')) {
                return _this.sqlite.deleteDatabase({
                    name: name,
                    location: 'default'
                });
            }
            else {
                // In WebSQL we cannot delete the database, just empty it.
                return db.emptyDatabase();
            }
        });
    };
    CoreDbProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__ionic_native_sqlite__["a" /* SQLite */], __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* Platform */]])
    ], CoreDbProvider);
    return CoreDbProvider;
}());

//# sourceMappingURL=db.js.map

/***/ }),
/* 228 */,
/* 229 */,
/* 230 */,
/* 231 */,
/* 232 */,
/* 233 */,
/* 234 */,
/* 235 */,
/* 236 */,
/* 237 */,
/* 238 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 239 */,
/* 240 */,
/* 241 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreDynamicComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger__ = __webpack_require__(5);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};



/**
 * Component to create another component dynamically.
 *
 * You need to pass the class of the component to this component (the class, not the name), along with the input data.
 *
 * So you should do something like:
 *
 *     import { MyComponent } from './component';
 *
 *     ...
 *
 *         this.component = MyComponent;
 *
 * And in the template:
 *
 *     <core-dynamic-component [component]="component" [data]="data">
 *         <p>Cannot render the data.</p>
 *     </core-dynamic-component>
 *
 * Please notice that the component that you pass needs to be declared in entryComponents of the module to be created dynamically.
 *
 * Alternatively, you can also supply a ComponentRef instead of the class of the component. In this case, the component won't
 * be instantiated because it already is, it will be attached to the view and the right data will be passed to it.
 * Passing ComponentRef is meant for site plugins, so we'll inject a NavController instance to the component.
 *
 * The contents of this component will be displayed if no component is supplied or it cannot be created. In the example above,
 * if no component is supplied then the template will show the message "Cannot render the data.".
 */
var CoreDynamicComponent = /** @class */ (function () {
    function CoreDynamicComponent(logger, factoryResolver, differs, navCtrl, cdr, element) {
        this.factoryResolver = factoryResolver;
        this.navCtrl = navCtrl;
        this.cdr = cdr;
        this.element = element;
        this.logger = logger.getInstance('CoreDynamicComponent');
        this.differ = differs.find([]).create();
    }
    Object.defineProperty(CoreDynamicComponent.prototype, "dynamicComponent", {
        // Get the container where to put the dynamic component.
        set: function (el) {
            this.container = el;
            this.createComponent();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Component being initialized.
     */
    CoreDynamicComponent.prototype.ngOnInit = function () {
        this.createComponent();
    };
    /**
     * Detect changes on input properties.
     */
    CoreDynamicComponent.prototype.ngOnChanges = function (changes) {
        if (!this.instance && changes.component) {
            this.createComponent();
        }
    };
    /**
     * Detect and act upon changes that Angular cant or wont detect on its own (objects and arrays).
     */
    CoreDynamicComponent.prototype.ngDoCheck = function () {
        if (this.instance) {
            // Check if there's any change in the data object.
            var changes = this.differ.diff(this.data);
            if (changes) {
                this.setInputData();
                if (this.instance.ngOnChanges) {
                    this.instance.ngOnChanges(this.createChangesForComponent(changes));
                }
            }
        }
    };
    /**
     * Call a certain function on the component.
     *
     * @param {string} name Name of the function to call.
     * @param {any[]} params List of params to send to the function.
     * @return {any} Result of the call. Undefined if no component instance or the function doesn't exist.
     */
    CoreDynamicComponent.prototype.callComponentFunction = function (name, params) {
        if (this.instance && typeof this.instance[name] == 'function') {
            return this.instance[name].apply(this.instance, params);
        }
    };
    /**
     * Create a component, add it to a container and set the input data.
     *
     * @return {boolean} Whether the component was successfully created.
     */
    CoreDynamicComponent.prototype.createComponent = function () {
        if (!this.component || !this.container) {
            // No component to instantiate or container doesn't exist right now.
            return false;
        }
        if (this.instance) {
            // Component already instantiated.
            return true;
        }
        if (this.component instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__["p" /* ComponentRef */]) {
            // A ComponentRef was supplied instead of the component class. Add it to the view.
            this.container.insert(this.component.hostView);
            this.instance = this.component.instance;
            // This feature is usually meant for site plugins. Inject some properties.
            this.instance['ChangeDetectorRef'] = this.cdr;
            this.instance['NavController'] = this.navCtrl;
            this.instance['componentContainer'] = this.element.nativeElement;
        }
        else {
            try {
                // Create the component and add it to the container.
                var factory = this.factoryResolver.resolveComponentFactory(this.component), componentRef = this.container.createComponent(factory);
                this.instance = componentRef.instance;
            }
            catch (ex) {
                this.logger.error('Error creating component', ex);
                return false;
            }
        }
        this.setInputData();
        return true;
    };
    /**
     * Set the input data for the component.
     */
    CoreDynamicComponent.prototype.setInputData = function () {
        for (var name_1 in this.data) {
            this.instance[name_1] = this.data[name_1];
        }
    };
    /**
     * Given the changes on the data input, create the changes object for the component.
     *
     * @param {any} changes Changes in the data input (detected by KeyValueDiffer).
     * @return {{[name: string]: SimpleChange}} List of changes for the component.
     */
    CoreDynamicComponent.prototype.createChangesForComponent = function (changes) {
        var newChanges = {};
        // Added items are considered first change.
        changes.forEachAddedItem(function (item) {
            newChanges[item.key] = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["_2" /* SimpleChange */](item.previousValue, item.currentValue, true);
        });
        // Changed or removed items aren't first change.
        changes.forEachChangedItem(function (item) {
            newChanges[item.key] = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["_2" /* SimpleChange */](item.previousValue, item.currentValue, false);
        });
        changes.forEachRemovedItem(function (item) {
            newChanges[item.key] = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["_2" /* SimpleChange */](item.previousValue, item.currentValue, true);
        });
        return newChanges;
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreDynamicComponent.prototype, "component", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreDynamicComponent.prototype, "data", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])('dynamicComponent', { read: __WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewContainerRef */] }),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewContainerRef */]),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewContainerRef */]])
    ], CoreDynamicComponent.prototype, "dynamicComponent", null);
    CoreDynamicComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-dynamic-component',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/components/dynamic-component/dynamic-component.html"*/'<!-- Content to display if no dynamic component. -->\n<ng-content *ngIf="!instance"></ng-content>\n\n<!-- Container of the dynamic component -->\n<ng-container #dynamicComponent></ng-container>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/components/dynamic-component/dynamic-component.html"*/
        }),
        __param(3, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["N" /* Optional */])()),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["o" /* ComponentFactoryResolver */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["F" /* KeyValueDiffers */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavController */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["j" /* ChangeDetectorRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */]])
    ], CoreDynamicComponent);
    return CoreDynamicComponent;
}());

//# sourceMappingURL=dynamic-component.js.map

/***/ }),
/* 242 */,
/* 243 */,
/* 244 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFileUploaderDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_events__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__classes_delegate__ = __webpack_require__(69);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Delegate to register handlers to be shown in the file picker.
 */
var CoreFileUploaderDelegate = /** @class */ (function (_super) {
    __extends(CoreFileUploaderDelegate, _super);
    function CoreFileUploaderDelegate(loggerProvider, sitesProvider, eventsProvider) {
        var _this = _super.call(this, 'CoreFileUploaderDelegate', loggerProvider, sitesProvider, eventsProvider) || this;
        _this.sitesProvider = sitesProvider;
        _this.eventsProvider = eventsProvider;
        _this.handlers = {}; // All registered handlers.
        _this.enabledHandlers = {}; // Handlers enabled for the current site.
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_1__providers_events__["a" /* CoreEventsProvider */].LOGOUT, _this.clearSiteHandlers.bind(_this));
        return _this;
    }
    /**
     * Clear current site handlers. Reserved for core use.
     */
    CoreFileUploaderDelegate.prototype.clearSiteHandlers = function () {
        this.enabledHandlers = {};
    };
    /**
     * Get the handlers for the current site.
     *
     * @param {string[]} [mimetypes] List of supported mimetypes. If undefined, all mimetypes supported.
     * @return {CoreFileUploaderHandlerDataToReturn[]} List of handlers data.
     */
    CoreFileUploaderDelegate.prototype.getHandlers = function (mimetypes) {
        var handlers = [];
        for (var name_1 in this.enabledHandlers) {
            var handler = this.enabledHandlers[name_1];
            var supportedMimetypes = void 0;
            if (mimetypes) {
                if (!handler.getSupportedMimetypes) {
                    // Handler doesn't implement a required function, don't add it.
                    continue;
                }
                supportedMimetypes = handler.getSupportedMimetypes(mimetypes);
                if (!supportedMimetypes.length) {
                    // Handler doesn't support any mimetype, don't add it.
                    continue;
                }
            }
            var data = handler.getData();
            data.priority = handler.priority;
            data.mimetypes = supportedMimetypes;
            handlers.push(data);
        }
        return handlers;
    };
    CoreFileUploaderDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_1__providers_events__["a" /* CoreEventsProvider */]])
    ], CoreFileUploaderDelegate);
    return CoreFileUploaderDelegate;
}(__WEBPACK_IMPORTED_MODULE_4__classes_delegate__["a" /* CoreDelegate */]));

//# sourceMappingURL=delegate.js.map

/***/ }),
/* 245 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonMessagesOfflineProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_app__ = __webpack_require__(12);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Service to handle Offline messages.
 */
var AddonMessagesOfflineProvider = /** @class */ (function () {
    function AddonMessagesOfflineProvider(logger, sitesProvider, appProvider) {
        this.sitesProvider = sitesProvider;
        this.appProvider = appProvider;
        // Variables for database.
        this.MESSAGES_TABLE = 'addon_messages_offline_messages';
        this.tablesSchema = [
            {
                name: this.MESSAGES_TABLE,
                columns: [
                    {
                        name: 'touserid',
                        type: 'INTEGER'
                    },
                    {
                        name: 'useridfrom',
                        type: 'INTEGER'
                    },
                    {
                        name: 'smallmessage',
                        type: 'TEXT'
                    },
                    {
                        name: 'timecreated',
                        type: 'INTEGER'
                    },
                    {
                        name: 'deviceoffline',
                        type: 'INTEGER'
                    }
                ],
                primaryKeys: ['touserid', 'smallmessage', 'timecreated']
            }
        ];
        this.logger = logger.getInstance('AddonMessagesOfflineProvider');
        this.sitesProvider.createTablesFromSchema(this.tablesSchema);
    }
    /**
     * Delete a message.
     *
     * @param  {number} toUserId    User ID to send the message to.
     * @param  {string} message     The message.
     * @param  {number} timeCreated The time the message was created.
     * @param  {string} [siteId]    Site ID. If not defined, current site.
     * @return {Promise<any>}       Promise resolved if stored, rejected if failure.
     */
    AddonMessagesOfflineProvider.prototype.deleteMessage = function (toUserId, message, timeCreated, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().deleteRecords(_this.MESSAGES_TABLE, {
                touserid: toUserId,
                smallmessage: message,
                timecreated: timeCreated
            });
        });
    };
    /**
     * Get all messages where deviceoffline is set to 1.
     *
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved with messages.
     */
    AddonMessagesOfflineProvider.prototype.getAllDeviceOfflineMessages = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getRecords(_this.MESSAGES_TABLE, { deviceoffline: 1 });
        });
    };
    /**
     * Get offline messages to send to a certain user.
     *
     * @param  {number} toUserId       User ID to get messages to.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved with messages.
     */
    AddonMessagesOfflineProvider.prototype.getMessages = function (toUserId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getRecords(_this.MESSAGES_TABLE, { touserid: toUserId });
        });
    };
    /**
     * Get all offline messages.
     *
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}         Promise resolved with messages.
     */
    AddonMessagesOfflineProvider.prototype.getAllMessages = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getAllRecords(_this.MESSAGES_TABLE);
        });
    };
    /**
     * Check if there are offline messages to send to a certain user.
     *
     * @param  {number} toUserId User ID to check.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved with boolean: true if has offline messages, false otherwise.
     */
    AddonMessagesOfflineProvider.prototype.hasMessages = function (toUserId, siteId) {
        return this.getMessages(toUserId, siteId).then(function (messages) {
            return !!messages.length;
        });
    };
    /**
     * Save a message to be sent later.
     *
     * @param  {number} toUserId User ID recipient of the message.
     * @param  {string} message  The message to send.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved if stored, rejected if failure.
     */
    AddonMessagesOfflineProvider.prototype.saveMessage = function (toUserId, message, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var entry = {
                touserid: toUserId,
                useridfrom: site.getUserId(),
                smallmessage: message,
                timecreated: new Date().getTime(),
                deviceoffline: _this.appProvider.isOnline() ? 0 : 1
            };
            return site.getDb().insertOrUpdateRecord(_this.MESSAGES_TABLE, entry, {
                touserid: toUserId,
                smallmessage: message,
                timecreated: entry.timecreated
            }).then(function () {
                return entry;
            });
        });
    };
    /**
     * Set deviceoffline for a group of messages.
     *
     * @param  {any} messages Messages to update. Should be the same entry as retrieved from the DB.
     * @param  {boolean} value   Value to set.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved if stored, rejected if failure.
     */
    AddonMessagesOfflineProvider.prototype.setMessagesDeviceOffline = function (messages, value, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var db = site.getDb(), promises = [], data = { deviceoffline: value ? 1 : 0 };
            messages.forEach(function (message) {
                promises.push(db.insertOrUpdateRecord(_this.MESSAGES_TABLE, data, {
                    touserid: message.touserid,
                    smallmessage: message.smallmessage,
                    timecreated: message.timecreated
                }));
            });
            return Promise.all(promises);
        });
    };
    AddonMessagesOfflineProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_app__["a" /* CoreAppProvider */]])
    ], AddonMessagesOfflineProvider);
    return AddonMessagesOfflineProvider;
}());

//# sourceMappingURL=messages-offline.js.map

/***/ }),
/* 246 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseUnsupportedModuleComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_course__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_module_delegate__ = __webpack_require__(61);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Component that displays info about an unsupported module.
 */
var CoreCourseUnsupportedModuleComponent = /** @class */ (function () {
    function CoreCourseUnsupportedModuleComponent(courseProvider, moduleDelegate) {
        this.courseProvider = courseProvider;
        this.moduleDelegate = moduleDelegate;
    }
    /**
     * Component being initialized.
     */
    CoreCourseUnsupportedModuleComponent.prototype.ngOnInit = function () {
        this.isDisabledInSite = this.moduleDelegate.isModuleDisabledInSite(this.module.modname);
        this.isSupportedByTheApp = this.moduleDelegate.hasHandler(this.module.modname);
        this.moduleName = this.courseProvider.translateModuleName(this.module.modname);
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreCourseUnsupportedModuleComponent.prototype, "course", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreCourseUnsupportedModuleComponent.prototype, "module", void 0);
    CoreCourseUnsupportedModuleComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-course-unsupported-module',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/core/course/components/unsupported-module/unsupported-module.html"*/'<div padding>\n    <core-course-module-description [description]="module.description"></core-course-module-description>\n    <h2 *ngIf="!isDisabledInSite && isSupportedByTheApp">{{ \'core.whoops\' | translate }}</h2>\n    <h2 *ngIf="isDisabledInSite ||!isSupportedByTheApp">{{ \'core.uhoh\' | translate }}</h2>\n\n    <p class="core-big" *ngIf="isDisabledInSite">{{ \'core.course.activitydisabled\' | translate }}</p>\n    <p class="core-big" *ngIf="!isDisabledInSite && isSupportedByTheApp">{{ \'core.course.activitynotyetviewablesiteupgradeneeded\' | translate }}</p>\n    <p class="core-big" *ngIf="!isDisabledInSite && !isSupportedByTheApp">{{ \'core.course.activitynotyetviewableremoteaddon\' | translate }}</p>\n    <p *ngIf="isDisabledInSite ||!isSupportedByTheApp"><strong>{{ \'core.course.askadmintosupport\' | translate }}</strong></p>\n\n    <div *ngIf="module.url">\n        <p><strong>{{ \'core.course.useactivityonbrowser\' | translate }}</strong></p>\n        <a ion-button block icon-end [href]="module.url" core-link>\n            {{ \'core.openinbrowser\' | translate }}\n            <ion-icon name="open"></ion-icon>\n        </a>\n    </div>\n</div>'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/core/course/components/unsupported-module/unsupported-module.html"*/,
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_course__["a" /* CoreCourseProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_module_delegate__["a" /* CoreCourseModuleDelegate */]])
    ], CoreCourseUnsupportedModuleComponent);
    return CoreCourseUnsupportedModuleComponent;
}());

//# sourceMappingURL=unsupported-module.js.map

/***/ }),
/* 247 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModPageHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_text__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_filepool__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__page__ = __webpack_require__(107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_file__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__angular_http__ = __webpack_require__(105);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};









/**
 * Service that provides some features for page.
 */
var AddonModPageHelperProvider = /** @class */ (function () {
    function AddonModPageHelperProvider(logger, domUtils, filepoolProvider, fileProvider, textUtils, http, sitesProvider) {
        this.domUtils = domUtils;
        this.filepoolProvider = filepoolProvider;
        this.fileProvider = fileProvider;
        this.textUtils = textUtils;
        this.http = http;
        this.sitesProvider = sitesProvider;
        this.logger = logger.getInstance('AddonModPageHelperProvider');
    }
    /**
     * Gets the page HTML.
     *
     * @param {any} contents The module contents.
     * @param {number} moduleId The module ID.
     * @return {Promise<string>} The HTML of the page.
     */
    AddonModPageHelperProvider.prototype.getPageHtml = function (contents, moduleId) {
        var _this = this;
        var indexUrl, promise;
        var paths = {};
        // Extract the information about paths from the module contents.
        contents.forEach(function (content) {
            var url = content.fileurl;
            if (_this.isMainPage(content)) {
                // This seems to be the most reliable way to spot the index page.
                indexUrl = url;
            }
            else {
                var key = content.filename;
                if (content.filepath !== '/') {
                    // Add the folders without the leading slash.
                    key = content.filepath.substr(1) + key;
                }
                paths[_this.textUtils.decodeURIComponent(key)] = url;
            }
        });
        // Promise handling when we are in a browser.
        if (!indexUrl) {
            // If ever that happens.
            this.logger.debug('Could not locate the index page');
            promise = Promise.reject(null);
        }
        else if (this.fileProvider.isAvailable()) {
            // The file system is available.
            promise = this.filepoolProvider.downloadUrl(this.sitesProvider.getCurrentSiteId(), indexUrl, false, __WEBPACK_IMPORTED_MODULE_5__page__["a" /* AddonModPageProvider */].COMPONENT, moduleId);
        }
        else {
            // We return the live URL.
            promise = Promise.resolve(this.sitesProvider.getCurrentSite().fixPluginfileURL(indexUrl));
        }
        return promise.then(function (url) {
            // Fetch the URL content.
            var promise = _this.http.get(url).toPromise();
            return promise.then(function (response) {
                var content = response.text();
                if (typeof content !== 'string') {
                    return Promise.reject(null);
                }
                // Now that we have the content, we update the SRC to point back to the external resource.
                // That will be caught by core-format-text.
                return _this.domUtils.restoreSourcesInHtml(content, paths);
            });
        });
    };
    /**
     * Returns whether the file is the main page of the module.
     *
     * @param {any} file An object returned from WS containing file info.
     * @return {boolean}  Whether the file is the main page or not.
     */
    AddonModPageHelperProvider.prototype.isMainPage = function (file) {
        var filename = file.filename || '', fileurl = file.fileurl || '', url = '/mod_page/content/index.html', encodedUrl = encodeURIComponent(url);
        return (filename === 'index.html' && (fileurl.indexOf(url) > 0 || fileurl.indexOf(encodedUrl) > 0));
    };
    AddonModPageHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_filepool__["a" /* CoreFilepoolProvider */],
            __WEBPACK_IMPORTED_MODULE_6__providers_file__["a" /* CoreFileProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_8__angular_http__["a" /* Http */],
            __WEBPACK_IMPORTED_MODULE_7__providers_sites__["a" /* CoreSitesProvider */]])
    ], AddonModPageHelperProvider);
    return AddonModPageHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),
/* 248 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModUrlHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_contentlinks_providers_helper__ = __webpack_require__(45);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Service that provides helper functions for urls.
 */
var AddonModUrlHelperProvider = /** @class */ (function () {
    function AddonModUrlHelperProvider(sitesProvider, domUtils, contentLinksHelper) {
        this.sitesProvider = sitesProvider;
        this.domUtils = domUtils;
        this.contentLinksHelper = contentLinksHelper;
    }
    /**
     * Opens a URL.
     *
     * @param {string} url The URL to go to.
     */
    AddonModUrlHelperProvider.prototype.open = function (url) {
        var _this = this;
        var modal = this.domUtils.showModalLoading();
        this.contentLinksHelper.handleLink(url).then(function (treated) {
            if (!treated) {
                return _this.sitesProvider.getCurrentSite().openInBrowserWithAutoLoginIfSameSite(url);
            }
        }).finally(function () {
            modal.dismiss();
        });
    };
    AddonModUrlHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_3__core_contentlinks_providers_helper__["a" /* CoreContentLinksHelperProvider */]])
    ], AddonModUrlHelperProvider);
    return AddonModUrlHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),
/* 249 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCompileProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__app_app_module__ = __webpack_require__(312);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__core_contentlinks_contentlinks_module__ = __webpack_require__(607);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_course_course_module__ = __webpack_require__(608);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_courses_courses_module__ = __webpack_require__(610);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__core_fileuploader_fileuploader_module__ = __webpack_require__(611);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__core_grades_grades_module__ = __webpack_require__(612);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__core_login_login_module__ = __webpack_require__(613);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__core_mainmenu_mainmenu_module__ = __webpack_require__(614);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__core_sharedfiles_sharedfiles_module__ = __webpack_require__(615);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__core_sitehome_sitehome_module__ = __webpack_require__(616);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__core_user_user_module__ = __webpack_require__(617);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__core_emulator_emulator_module__ = __webpack_require__(618);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__core_siteplugins_providers_siteplugins__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__angular_platform_browser__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__angular_forms__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__angular_http__ = __webpack_require__(105);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__angular_common_http__ = __webpack_require__(104);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__configconstants__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__core_constants__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23_moment__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_23_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24_ts_md5_dist_md5__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24_ts_md5_dist_md5___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_24_ts_md5_dist_md5__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__classes_base_sync__ = __webpack_require__(591);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__classes_cache__ = __webpack_require__(593);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__classes_delegate__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__core_contentlinks_classes_base_handler__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__core_contentlinks_classes_module_grade_handler__ = __webpack_require__(1191);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__core_contentlinks_classes_module_index_handler__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__core_course_classes_module_prefetch_handler__ = __webpack_require__(106);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__components_components_module__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_33__directives_directives_module__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_34__pipes_pipes_module__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_35__core_course_components_components_module__ = __webpack_require__(91);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_36__core_course_directives_directives_module__ = __webpack_require__(1192);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_37__core_courses_components_components_module__ = __webpack_require__(713);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_38__core_siteplugins_directives_directives_module__ = __webpack_require__(1194);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_39__core_sitehome_components_components_module__ = __webpack_require__(715);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_40__core_user_components_components_module__ = __webpack_require__(286);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_41__core_course_components_unsupported_module_unsupported_module__ = __webpack_require__(246);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_42__core_course_formats_singleactivity_components_singleactivity__ = __webpack_require__(250);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_43__core_siteplugins_components_module_index_module_index__ = __webpack_require__(181);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_44__core_siteplugins_components_course_option_course_option__ = __webpack_require__(259);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_45__core_siteplugins_components_course_format_course_format__ = __webpack_require__(260);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




// Import core providers.












// Import only this provider to prevent circular dependencies.

// Import other libraries and providers.








// Import core classes that can be useful for site plugins.







// Import all modules that define components, directives and pipes.









// Import some components listed in entryComponents so they can be injected dynamically.





/**
 * Service to provide functionalities regarding compiling dynamic HTML and Javascript.
 */
var CoreCompileProvider = /** @class */ (function () {
    function CoreCompileProvider(injector, logger, compiler) {
        this.injector = injector;
        this.compiler = compiler;
        // Other Ionic/Angular providers that don't depend on where they are injected.
        this.OTHER_PROVIDERS = [
            __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_19__angular_http__["a" /* Http */], __WEBPACK_IMPORTED_MODULE_20__angular_common_http__["b" /* HttpClient */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */], __WEBPACK_IMPORTED_MODULE_17__angular_platform_browser__["c" /* DomSanitizer */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["a" /* ActionSheetController */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["b" /* AlertController */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["i" /* LoadingController */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["j" /* ModalController */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["o" /* PopoverController */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["r" /* ToastController */], __WEBPACK_IMPORTED_MODULE_18__angular_forms__["a" /* FormBuilder */]
        ];
        // List of imports for dynamic module. Since the template can have any component we need to import all core components modules.
        this.IMPORTS = [
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["g" /* IonicModule */], __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["b" /* TranslateModule */].forChild(), __WEBPACK_IMPORTED_MODULE_32__components_components_module__["a" /* CoreComponentsModule */], __WEBPACK_IMPORTED_MODULE_33__directives_directives_module__["a" /* CoreDirectivesModule */], __WEBPACK_IMPORTED_MODULE_34__pipes_pipes_module__["a" /* CorePipesModule */],
            __WEBPACK_IMPORTED_MODULE_35__core_course_components_components_module__["a" /* CoreCourseComponentsModule */], __WEBPACK_IMPORTED_MODULE_37__core_courses_components_components_module__["a" /* CoreCoursesComponentsModule */], __WEBPACK_IMPORTED_MODULE_39__core_sitehome_components_components_module__["a" /* CoreSiteHomeComponentsModule */], __WEBPACK_IMPORTED_MODULE_40__core_user_components_components_module__["a" /* CoreUserComponentsModule */],
            __WEBPACK_IMPORTED_MODULE_36__core_course_directives_directives_module__["a" /* CoreCourseDirectivesModule */], __WEBPACK_IMPORTED_MODULE_38__core_siteplugins_directives_directives_module__["a" /* CoreSitePluginsDirectivesModule */]
        ];
        this.logger = logger.getInstance('CoreCompileProvider');
    }
    /**
     * Create and compile a dynamic component.
     *
     * @param {string} template The template of the component.
     * @param {any} componentClass The JS class of the component.
     * @return {Promise<ComponentFactory<any>>} Promise resolved with the factory to instantiate the component.
     */
    CoreCompileProvider.prototype.createAndCompileComponent = function (template, componentClass) {
        // Create the component using the template and the class.
        var component = Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            template: template
        })(componentClass);
        // Now create the module containing the component.
        var module = Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({ imports: this.IMPORTS, declarations: [component] })(/** @class */ (function () {
            function class_1() {
            }
            return class_1;
        }()));
        // Compile the module and the component.
        return this.compiler.compileModuleAndAllComponentsAsync(module).then(function (factories) {
            // Search and return the factory of the component we just created.
            for (var i in factories.componentFactories) {
                var factory = factories.componentFactories[i];
                if (factory.componentType == component) {
                    return factory;
                }
            }
        });
    };
    /**
     * Eval some javascript using the context of the function.
     *
     * @param {string} javascript The javascript to eval.
     * @return {any} Result of the eval.
     */
    CoreCompileProvider.prototype.evalInContext = function (javascript) {
        // tslint:disable: no-eval
        return eval(javascript);
    };
    /**
     * Execute some javascript code, using a certain instance as the context.
     *
     * @param {any} instance Instance to use as the context. In the JS code, "this" will be this instance.
     * @param {string} javascript The javascript code to eval.
     * @return {any} Result of the javascript execution.
     */
    CoreCompileProvider.prototype.executeJavascript = function (instance, javascript) {
        try {
            return this.evalInContext.call(instance, javascript);
        }
        catch (ex) {
            this.logger.error('Error evaluating javascript', ex);
        }
    };
    /**
     * Inject all the core libraries in a certain object.
     *
     * @param {any} instance The instance where to inject the libraries.
     */
    CoreCompileProvider.prototype.injectLibraries = function (instance) {
        var providers = __WEBPACK_IMPORTED_MODULE_4__app_app_module__["b" /* CORE_PROVIDERS */].concat(__WEBPACK_IMPORTED_MODULE_5__core_contentlinks_contentlinks_module__["a" /* CORE_CONTENTLINKS_PROVIDERS */]).concat(__WEBPACK_IMPORTED_MODULE_6__core_course_course_module__["a" /* CORE_COURSE_PROVIDERS */])
            .concat(__WEBPACK_IMPORTED_MODULE_7__core_courses_courses_module__["a" /* CORE_COURSES_PROVIDERS */]).concat(__WEBPACK_IMPORTED_MODULE_8__core_fileuploader_fileuploader_module__["a" /* CORE_FILEUPLOADER_PROVIDERS */]).concat(__WEBPACK_IMPORTED_MODULE_9__core_grades_grades_module__["a" /* CORE_GRADES_PROVIDERS */])
            .concat(__WEBPACK_IMPORTED_MODULE_10__core_login_login_module__["a" /* CORE_LOGIN_PROVIDERS */]).concat(__WEBPACK_IMPORTED_MODULE_11__core_mainmenu_mainmenu_module__["a" /* CORE_MAINMENU_PROVIDERS */]).concat(__WEBPACK_IMPORTED_MODULE_12__core_sharedfiles_sharedfiles_module__["a" /* CORE_SHAREDFILES_PROVIDERS */])
            .concat(__WEBPACK_IMPORTED_MODULE_13__core_sitehome_sitehome_module__["a" /* CORE_SITEHOME_PROVIDERS */]).concat([__WEBPACK_IMPORTED_MODULE_16__core_siteplugins_providers_siteplugins__["a" /* CoreSitePluginsProvider */]]).concat(__WEBPACK_IMPORTED_MODULE_14__core_user_user_module__["a" /* CORE_USER_PROVIDERS */])
            .concat(__WEBPACK_IMPORTED_MODULE_15__core_emulator_emulator_module__["b" /* IONIC_NATIVE_PROVIDERS */]).concat(this.OTHER_PROVIDERS);
        // We cannot inject anything to this constructor. Use the Injector to inject all the providers into the instance.
        for (var i in providers) {
            var providerDef = providers[i];
            if (typeof providerDef == 'function' && providerDef.name) {
                try {
                    // Inject the provider to the instance. We use the class name as the property name.
                    instance[providerDef.name] = this.injector.get(providerDef);
                }
                catch (ex) {
                    this.logger.warn('Error injecting provider', providerDef.name, ex);
                }
            }
        }
        // Inject current service.
        instance['CoreCompileProvider'] = this;
        // Add some final classes.
        instance['injector'] = this.injector;
        instance['Validators'] = __WEBPACK_IMPORTED_MODULE_18__angular_forms__["h" /* Validators */];
        instance['CoreConfigConstants'] = __WEBPACK_IMPORTED_MODULE_21__configconstants__["a" /* CoreConfigConstants */];
        instance['CoreConstants'] = __WEBPACK_IMPORTED_MODULE_22__core_constants__["a" /* CoreConstants */];
        instance['moment'] = __WEBPACK_IMPORTED_MODULE_23_moment__;
        instance['Md5'] = __WEBPACK_IMPORTED_MODULE_24_ts_md5_dist_md5__["Md5"];
        instance['CoreSyncBaseProvider'] = __WEBPACK_IMPORTED_MODULE_25__classes_base_sync__["a" /* CoreSyncBaseProvider */];
        instance['CoreCache'] = __WEBPACK_IMPORTED_MODULE_26__classes_cache__["a" /* CoreCache */];
        instance['CoreDelegate'] = __WEBPACK_IMPORTED_MODULE_27__classes_delegate__["a" /* CoreDelegate */];
        instance['CoreContentLinksHandlerBase'] = __WEBPACK_IMPORTED_MODULE_28__core_contentlinks_classes_base_handler__["a" /* CoreContentLinksHandlerBase */];
        instance['CoreContentLinksModuleGradeHandler'] = __WEBPACK_IMPORTED_MODULE_29__core_contentlinks_classes_module_grade_handler__["a" /* CoreContentLinksModuleGradeHandler */];
        instance['CoreContentLinksModuleIndexHandler'] = __WEBPACK_IMPORTED_MODULE_30__core_contentlinks_classes_module_index_handler__["a" /* CoreContentLinksModuleIndexHandler */];
        instance['CoreCourseModulePrefetchHandlerBase'] = __WEBPACK_IMPORTED_MODULE_31__core_course_classes_module_prefetch_handler__["a" /* CoreCourseModulePrefetchHandlerBase */];
        instance['CoreCourseUnsupportedModuleComponent'] = __WEBPACK_IMPORTED_MODULE_41__core_course_components_unsupported_module_unsupported_module__["a" /* CoreCourseUnsupportedModuleComponent */];
        instance['CoreCourseFormatSingleActivityComponent'] = __WEBPACK_IMPORTED_MODULE_42__core_course_formats_singleactivity_components_singleactivity__["a" /* CoreCourseFormatSingleActivityComponent */];
        instance['CoreSitePluginsModuleIndexComponent'] = __WEBPACK_IMPORTED_MODULE_43__core_siteplugins_components_module_index_module_index__["a" /* CoreSitePluginsModuleIndexComponent */];
        instance['CoreSitePluginsCourseOptionComponent'] = __WEBPACK_IMPORTED_MODULE_44__core_siteplugins_components_course_option_course_option__["a" /* CoreSitePluginsCourseOptionComponent */];
        instance['CoreSitePluginsCourseFormatComponent'] = __WEBPACK_IMPORTED_MODULE_45__core_siteplugins_components_course_format_course_format__["a" /* CoreSitePluginsCourseFormatComponent */];
    };
    /**
     * Instantiate a dynamic component.
     *
     * @param {string} template The template of the component.
     * @param {any} componentClass The JS class of the component.
     * @param {Injector} [injector] The injector to use. It's recommended to pass it so NavController and similar can be injected.
     * @return {Promise<ComponentRef<any>>} Promise resolved with the component instance.
     */
    CoreCompileProvider.prototype.instantiateDynamicComponent = function (template, componentClass, injector) {
        injector = injector || this.injector;
        return this.createAndCompileComponent(template, componentClass).then(function (factory) {
            if (factory) {
                // Create and return the component.
                return factory.create(injector, undefined, undefined, injector.get(__WEBPACK_IMPORTED_MODULE_0__angular_core__["K" /* NgModuleRef */]));
            }
        });
    };
    CoreCompileProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["C" /* Injector */], __WEBPACK_IMPORTED_MODULE_3__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["k" /* Compiler */]])
    ], CoreCompileProvider);
    return CoreCompileProvider;
}());

//# sourceMappingURL=compile.js.map

/***/ }),
/* 250 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseFormatSingleActivityComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_module_delegate__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__components_unsupported_module_unsupported_module__ = __webpack_require__(246);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__components_dynamic_component_dynamic_component__ = __webpack_require__(241);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Component to display single activity format. It will determine the right component to use and instantiate it.
 *
 * The instantiated component will receive the course and the module as inputs.
 */
var CoreCourseFormatSingleActivityComponent = /** @class */ (function () {
    function CoreCourseFormatSingleActivityComponent(moduleDelegate, injector) {
        this.moduleDelegate = moduleDelegate;
        this.injector = injector;
        this.data = {}; // Data to pass to the component.
    }
    /**
     * Detect changes on input properties.
     */
    CoreCourseFormatSingleActivityComponent.prototype.ngOnChanges = function (changes) {
        var _this = this;
        if (this.course && this.sections && this.sections.length) {
            // In single activity the module should only have 1 section and 1 module. Get the module.
            var module_1 = this.sections[0] && this.sections[0].modules && this.sections[0].modules[0];
            if (module_1 && !this.componentClass) {
                // We haven't obtained the class yet. Get it now.
                this.moduleDelegate.getMainComponent(this.injector, this.course, module_1).then(function (component) {
                    _this.componentClass = component || __WEBPACK_IMPORTED_MODULE_2__components_unsupported_module_unsupported_module__["a" /* CoreCourseUnsupportedModuleComponent */];
                });
            }
            this.data.courseId = this.course.id;
            this.data.module = module_1;
        }
    };
    /**
     * Refresh the data.
     *
     * @param {any} [refresher] Refresher.
     * @param {Function} [done] Function to call when done.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseFormatSingleActivityComponent.prototype.doRefresh = function (refresher, done) {
        return Promise.resolve(this.dynamicComponent.callComponentFunction('doRefresh', [refresher, done]));
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreCourseFormatSingleActivityComponent.prototype, "course", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Array)
    ], CoreCourseFormatSingleActivityComponent.prototype, "sections", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Boolean)
    ], CoreCourseFormatSingleActivityComponent.prototype, "downloadEnabled", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])(__WEBPACK_IMPORTED_MODULE_3__components_dynamic_component_dynamic_component__["a" /* CoreDynamicComponent */]),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_3__components_dynamic_component_dynamic_component__["a" /* CoreDynamicComponent */])
    ], CoreCourseFormatSingleActivityComponent.prototype, "dynamicComponent", void 0);
    CoreCourseFormatSingleActivityComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-course-format-single-activity',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/core/course/formats/singleactivity/components/singleactivity.html"*/'<core-dynamic-component [component]="componentClass" [data]="data"></core-dynamic-component>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/core/course/formats/singleactivity/components/singleactivity.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_module_delegate__["a" /* CoreCourseModuleDelegate */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["C" /* Injector */]])
    ], CoreCourseFormatSingleActivityComponent);
    return CoreCourseFormatSingleActivityComponent;
}());

//# sourceMappingURL=singleactivity.js.map

/***/ }),
/* 251 */,
/* 252 */,
/* 253 */,
/* 254 */,
/* 255 */,
/* 256 */,
/* 257 */,
/* 258 */,
/* 259 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSitePluginsCourseOptionComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_siteplugins__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__plugin_content_plugin_content__ = __webpack_require__(81);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Component that displays the index of a course option site plugin.
 */
var CoreSitePluginsCourseOptionComponent = /** @class */ (function () {
    function CoreSitePluginsCourseOptionComponent(sitePluginsProvider) {
        this.sitePluginsProvider = sitePluginsProvider;
    }
    /**
     * Component being initialized.
     */
    CoreSitePluginsCourseOptionComponent.prototype.ngOnInit = function () {
        if (this.handlerUniqueName) {
            var handler = this.sitePluginsProvider.getSitePluginHandler(this.handlerUniqueName);
            if (handler) {
                this.component = handler.plugin.component;
                this.method = handler.handlerSchema.method;
                this.args = {
                    courseid: this.courseId,
                };
                this.bootstrapResult = handler.bootstrapResult;
            }
        }
    };
    /**
     * Refresh the data.
     *
     * @param {any} refresher Refresher.
     */
    CoreSitePluginsCourseOptionComponent.prototype.refreshData = function (refresher) {
        this.content.refreshData().finally(function () {
            refresher.complete();
        });
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreSitePluginsCourseOptionComponent.prototype, "courseId", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreSitePluginsCourseOptionComponent.prototype, "handlerUniqueName", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])(__WEBPACK_IMPORTED_MODULE_2__plugin_content_plugin_content__["a" /* CoreSitePluginsPluginContentComponent */]),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_2__plugin_content_plugin_content__["a" /* CoreSitePluginsPluginContentComponent */])
    ], CoreSitePluginsCourseOptionComponent.prototype, "content", void 0);
    CoreSitePluginsCourseOptionComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-site-plugins-course-option',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/core/siteplugins/components/course-option/course-option.html"*/'<ion-content>\n    <ion-refresher [enabled]="content && content.dataLoaded" (ionRefresh)="refreshData($event)">\n        <ion-refresher-content pullingText="{{ \'core.pulltorefresh\' | translate }}"></ion-refresher-content>\n    </ion-refresher>\n    <core-site-plugins-plugin-content *ngIf="component && method" [component]="component" [method]="method" [args]="args" [bootstrapResult]="bootstrapResult"></core-site-plugins-plugin-content>\n</ion-content>'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/core/siteplugins/components/course-option/course-option.html"*/,
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_siteplugins__["a" /* CoreSitePluginsProvider */]])
    ], CoreSitePluginsCourseOptionComponent);
    return CoreSitePluginsCourseOptionComponent;
}());

//# sourceMappingURL=course-option.js.map

/***/ }),
/* 260 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSitePluginsCourseFormatComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_siteplugins__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__plugin_content_plugin_content__ = __webpack_require__(81);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Component that displays the index of a course format site plugin.
 */
var CoreSitePluginsCourseFormatComponent = /** @class */ (function () {
    function CoreSitePluginsCourseFormatComponent(sitePluginsProvider) {
        this.sitePluginsProvider = sitePluginsProvider;
    }
    /**
     * Component being initialized.
     */
    CoreSitePluginsCourseFormatComponent.prototype.ngOnInit = function () {
        if (this.course && this.course.format) {
            var handler = this.sitePluginsProvider.getSitePluginHandler(this.course.format);
            if (handler) {
                this.component = handler.plugin.component;
                this.method = handler.handlerSchema.method;
                this.args = {
                    courseid: this.course.id,
                    downloadenabled: this.downloadEnabled
                };
                this.bootstrapResult = handler.bootstrapResult;
            }
        }
    };
    /**
     * Refresh the data.
     *
     * @param {any} [refresher] Refresher.
     * @param {Function} [done] Function to call when done.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreSitePluginsCourseFormatComponent.prototype.doRefresh = function (refresher, done) {
        return Promise.resolve(this.content.refreshData());
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreSitePluginsCourseFormatComponent.prototype, "course", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Array)
    ], CoreSitePluginsCourseFormatComponent.prototype, "sections", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Boolean)
    ], CoreSitePluginsCourseFormatComponent.prototype, "downloadEnabled", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])(__WEBPACK_IMPORTED_MODULE_2__plugin_content_plugin_content__["a" /* CoreSitePluginsPluginContentComponent */]),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_2__plugin_content_plugin_content__["a" /* CoreSitePluginsPluginContentComponent */])
    ], CoreSitePluginsCourseFormatComponent.prototype, "content", void 0);
    CoreSitePluginsCourseFormatComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-site-plugins-course-format',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/core/siteplugins/components/course-format/course-format.html"*/'<core-site-plugins-plugin-content *ngIf="component && method" [component]="component" [method]="method" [args]="args" [bootstrapResult]="bootstrapResult"></core-site-plugins-plugin-content>'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/core/siteplugins/components/course-format/course-format.html"*/,
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_siteplugins__["a" /* CoreSitePluginsProvider */]])
    ], CoreSitePluginsCourseFormatComponent);
    return CoreSitePluginsCourseFormatComponent;
}());

//# sourceMappingURL=course-format.js.map

/***/ }),
/* 261 */,
/* 262 */,
/* 263 */,
/* 264 */,
/* 265 */,
/* 266 */,
/* 267 */,
/* 268 */,
/* 269 */,
/* 270 */,
/* 271 */,
/* 272 */,
/* 273 */,
/* 274 */,
/* 275 */,
/* 276 */,
/* 277 */,
/* 278 */,
/* 279 */,
/* 280 */,
/* 281 */,
/* 282 */,
/* 283 */,
/* 284 */,
/* 285 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonCalendarProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_courses_providers_courses__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_time__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_groups__ = __webpack_require__(589);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_constants__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_local_notifications__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_config__ = __webpack_require__(75);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};









/**
 * Service to handle calendar events.
 */
var AddonCalendarProvider = /** @class */ (function () {
    function AddonCalendarProvider(logger, sitesProvider, groupsProvider, coursesProvider, timeUtils, localNotificationsProvider, configProvider) {
        this.sitesProvider = sitesProvider;
        this.groupsProvider = groupsProvider;
        this.coursesProvider = coursesProvider;
        this.timeUtils = timeUtils;
        this.localNotificationsProvider = localNotificationsProvider;
        this.configProvider = configProvider;
        this.DEFAULT_NOTIFICATION_TIME_SETTING = 'mmaCalendarDefaultNotifTime';
        this.ROOT_CACHE_KEY = 'mmaCalendar:';
        this.DEFAULT_NOTIFICATION_TIME = 60;
        // Variables for database.
        this.EVENTS_TABLE = 'calendar_events';
        this.tablesSchema = [
            {
                name: this.EVENTS_TABLE,
                columns: [
                    {
                        name: 'id',
                        type: 'INTEGER',
                        primaryKey: true
                    },
                    {
                        name: 'notificationtime',
                        type: 'INTEGER'
                    },
                    {
                        name: 'name',
                        type: 'TEXT',
                        notNull: true
                    },
                    {
                        name: 'description',
                        type: 'TEXT'
                    },
                    {
                        name: 'eventtype',
                        type: 'TEXT'
                    },
                    {
                        name: 'courseid',
                        type: 'INTEGER'
                    },
                    {
                        name: 'timestart',
                        type: 'INTEGER'
                    },
                    {
                        name: 'timeduration',
                        type: 'INTEGER'
                    },
                    {
                        name: 'categoryid',
                        type: 'INTEGER'
                    },
                    {
                        name: 'groupid',
                        type: 'INTEGER'
                    },
                    {
                        name: 'instance',
                        type: 'INTEGER'
                    },
                    {
                        name: 'modulename',
                        type: 'TEXT'
                    },
                    {
                        name: 'timemodified',
                        type: 'INTEGER'
                    },
                    {
                        name: 'repeatid',
                        type: 'INTEGER'
                    }
                ]
            }
        ];
        this.logger = logger.getInstance('AddonCalendarProvider');
        this.sitesProvider.createTablesFromSchema(this.tablesSchema);
    }
    AddonCalendarProvider_1 = AddonCalendarProvider;
    /**
     * Get the configured default notification time.
     *
     * @param  {string} [siteId] ID of the site. If not defined, use current site.
     * @return {Promise<number>}  Promise resolved with the default time.
     */
    AddonCalendarProvider.prototype.getDefaultNotificationTime = function (siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var key = this.DEFAULT_NOTIFICATION_TIME_SETTING + '#' + siteId;
        return this.configProvider.get(key, this.DEFAULT_NOTIFICATION_TIME);
    };
    /**
     * Get a calendar event. If the server request fails and data is not cached, try to get it from local DB.
     *
     * @param {number}  id        Event ID.
     * @param {boolean} [refresh] True when we should update the event data.
     * @param {string} [siteId] ID of the site. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the event data is retrieved.
     */
    AddonCalendarProvider.prototype.getEvent = function (id, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var preSets = {
                cacheKey: _this.getEventCacheKey(id)
            }, data = {
                options: {
                    userevents: 0,
                    siteevents: 0,
                },
                events: {
                    eventids: [
                        id
                    ]
                }
            };
            return site.read('core_calendar_get_calendar_events', data, preSets).then(function (response) {
                // The WebService returns all category events. Check the response to search for the event we want.
                var event = response.events.find(function (e) { return e.id == id; });
                return event || _this.getEventFromLocalDb(id);
            }).catch(function () {
                return _this.getEventFromLocalDb(id);
            });
        });
    };
    /**
     * Get cache key for a single event WS call.
     *
     * @param {number} id Event ID.
     * @return {string} Cache key.
     */
    AddonCalendarProvider.prototype.getEventCacheKey = function (id) {
        return this.ROOT_CACHE_KEY + 'events:' + id;
    };
    /**
     * Get a calendar event from local Db.
     *
     * @param  {number} id       Event ID.
     * @param  {string} [siteId] ID of the site the event belongs to. If not defined, use current site.
     * @return {Promise<any>}    Promise resolved when the event data is retrieved.
     */
    AddonCalendarProvider.prototype.getEventFromLocalDb = function (id, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.getDb().getRecord(_this.EVENTS_TABLE, { id: id });
        });
    };
    /**
     * Get event notification time. Always returns number of minutes (0 if disabled).
     *
     * @param  {number} id       Event ID.
     * @param  {string} [siteId] ID of the site the event belongs to. If not defined, use current site.
     * @return {Promise<number>}  Event notification time in minutes. 0 if disabled.
     */
    AddonCalendarProvider.prototype.getEventNotificationTime = function (id, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.getEventNotificationTimeOption(id, siteId).then(function (time) {
            if (time == -1) {
                return _this.getDefaultNotificationTime(siteId);
            }
            return time;
        });
    };
    /**
     * Get event notification time for options. Returns -1 for default time.
     *
     * @param  {number} id       Event ID.
     * @param  {string} [siteId] ID of the site the event belongs to. If not defined, use current site.
     * @return {Promise<number>}  Promise with wvent notification time in minutes. 0 if disabled, -1 if default time.
     */
    AddonCalendarProvider.prototype.getEventNotificationTimeOption = function (id, siteId) {
        return this.getEventFromLocalDb(id, siteId).then(function (e) {
            return e.notificationtime || -1;
        }).catch(function () {
            return -1;
        });
    };
    /**
     * Get the events in a certain period. The period is calculated like this:
     *     start time: now + daysToStart
     *     end time: start time + daysInterval
     * E.g. using provider.getEventsList(30, 30) is going to get the events starting after 30 days from now
     * and ending before 60 days from now.
     *
     * @param {number} [daysToStart=0]   Number of days from now to start getting events.
     * @param {number} [daysInterval=30] Number of days between timestart and timeend.
     * @param {string} [siteId]          Site to get the events from. If not defined, use current site.
     * @return {Promise<any[]>}          Promise to be resolved when the participants are retrieved.
     */
    AddonCalendarProvider.prototype.getEventsList = function (daysToStart, daysInterval, siteId) {
        var _this = this;
        if (daysToStart === void 0) { daysToStart = 0; }
        if (daysInterval === void 0) { daysInterval = AddonCalendarProvider_1.DAYS_INTERVAL; }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            siteId = site.getId();
            return _this.coursesProvider.getUserCourses(false, siteId).then(function (courses) {
                courses.push({ id: site.getSiteHomeId() }); // Add front page.
                return _this.groupsProvider.getUserGroups(courses, siteId).then(function (groups) {
                    var now = _this.timeUtils.timestamp(), start = now + (__WEBPACK_IMPORTED_MODULE_6__core_constants__["a" /* CoreConstants */].SECONDS_DAY * daysToStart), end = start + (__WEBPACK_IMPORTED_MODULE_6__core_constants__["a" /* CoreConstants */].SECONDS_DAY * daysInterval), data = {
                        options: {
                            userevents: 1,
                            siteevents: 1,
                            timestart: start,
                            timeend: end
                        },
                        events: {
                            courseids: [],
                            groupids: []
                        }
                    };
                    courses.forEach(function (course, index) {
                        data.events.courseids[index] = course.id;
                    });
                    groups.forEach(function (group, index) {
                        data.events.groupids[index] = group.id;
                    });
                    // We need to retrieve cached data using cache key because we have timestamp in the params.
                    var preSets = {
                        cacheKey: _this.getEventsListCacheKey(daysToStart, daysInterval),
                        getCacheUsingCacheKey: true
                    };
                    return site.read('core_calendar_get_calendar_events', data, preSets).then(function (response) {
                        _this.storeEventsInLocalDB(response.events, siteId);
                        return response.events;
                    });
                });
            });
        });
    };
    /**
     * Get prefix cache key for events list WS calls.
     *
     * @return {string} Prefix Cache key.
     */
    AddonCalendarProvider.prototype.getEventsListPrefixCacheKey = function () {
        return this.ROOT_CACHE_KEY + 'eventslist:';
    };
    /**
     * Get cache key for events list WS calls.
     *
     * @param {number} daysToStart  Number of days from now to start getting events.
     * @param {number} daysInterval Number of days between timestart and timeend.
     * @return {string} Cache key.
     */
    AddonCalendarProvider.prototype.getEventsListCacheKey = function (daysToStart, daysInterval) {
        return this.getEventsListPrefixCacheKey() + daysToStart + ':' + daysInterval;
    };
    /**
     * Invalidates events list and all the single events and related info.
     *
     * @param {any[]} courses List of courses or course ids.
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<any[]>} Promise resolved when the list is invalidated.
     */
    AddonCalendarProvider.prototype.invalidateEventsList = function (courses, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            siteId = site.getId();
            var promises = [];
            promises.push(_this.coursesProvider.invalidateUserCourses(siteId));
            promises.push(_this.groupsProvider.invalidateUserGroups(courses, siteId));
            promises.push(site.invalidateWsCacheForKeyStartingWith(_this.getEventsListPrefixCacheKey()));
            return Promise.all(promises);
        });
    };
    /**
     * Invalidates a single event.
     *
     * @param {number} eventId List of courses or course ids.
     * @param {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<any>} Promise resolved when the list is invalidated.
     */
    AddonCalendarProvider.prototype.invalidateEvent = function (eventId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getEventCacheKey(eventId));
        });
    };
    /**
     * Check if Calendar is disabled in a certain site.
     *
     * @param {CoreSite} [site] Site. If not defined, use current site.
     * @return {boolean} Whether it's disabled.
     */
    AddonCalendarProvider.prototype.isCalendarDisabledInSite = function (site) {
        site = site || this.sitesProvider.getCurrentSite();
        return site.isFeatureDisabled('$mmSideMenuDelegate_mmaCalendar');
    };
    /**
     * Check if Calendar is disabled in a certain site.
     *
     * @param  {string} [siteId] Site Id. If not defined, use current site.
     * @return {Promise<boolean>}     Promise resolved with true if disabled, rejected or resolved with false otherwise.
     */
    AddonCalendarProvider.prototype.isDisabled = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return _this.isCalendarDisabledInSite(site);
        });
    };
    /**
     * Get the next events for all the sites and schedules their notifications.
     * If an event notification time is 0, cancel its scheduled notification (if any).
     * If local notification plugin is not enabled, resolve the promise.
     *
     * @return {Promise}         Promise resolved when all the notifications have been scheduled.
     */
    AddonCalendarProvider.prototype.scheduleAllSitesEventsNotifications = function () {
        var _this = this;
        if (this.localNotificationsProvider.isAvailable()) {
            return this.sitesProvider.getSitesIds().then(function (siteIds) {
                var promises = [];
                siteIds.forEach(function (siteId) {
                    // Check if calendar is disabled for the site.
                    promises.push(_this.isDisabled(siteId).then(function (disabled) {
                        if (!disabled) {
                            // Get first events.
                            return _this.getEventsList(undefined, undefined, siteId).then(function (events) {
                                return _this.scheduleEventsNotifications(events, siteId);
                            });
                        }
                    }));
                });
                return Promise.all(promises);
            });
        }
        else {
            return Promise.resolve([]);
        }
    };
    /**
     * Schedules an event notification. If time is 0, cancel scheduled notification if any.
     * If local notification plugin is not enabled, resolve the promise.
     *
     * @param  {any} event    Event to schedule.
     * @param  {number} time     Notification setting time (in minutes). E.g. 10 means "notificate 10 minutes before start".
     * @param  {string} [siteId] Site ID the event belongs to. If not defined, use current site.
     * @return {Promise<void>}    Promise resolved when the notification is scheduled.
     */
    AddonCalendarProvider.prototype.scheduleEventNotification = function (event, time, siteId) {
        var _this = this;
        if (this.localNotificationsProvider.isAvailable()) {
            siteId = siteId || this.sitesProvider.getCurrentSiteId();
            if (time === 0) {
                // Cancel if it was scheduled.
                return this.localNotificationsProvider.cancel(event.id, AddonCalendarProvider_1.COMPONENT, siteId);
            }
            // If time is -1, get event default time.
            var promise = time == -1 ? this.getDefaultNotificationTime(siteId) : Promise.resolve(time);
            return promise.then(function (time) {
                var timeEnd = (event.timestart + event.timeduration) * 1000;
                if (timeEnd <= new Date().getTime()) {
                    // The event has finished already, don't schedule it.
                    return Promise.resolve();
                }
                var dateTriggered = new Date((event.timestart - (time * 60)) * 1000), startDate = new Date(event.timestart * 1000), notification = {
                    id: event.id,
                    title: event.name,
                    text: startDate.toLocaleString(),
                    at: dateTriggered,
                    data: {
                        eventid: event.id,
                        siteid: siteId
                    }
                };
                return _this.localNotificationsProvider.schedule(notification, AddonCalendarProvider_1.COMPONENT, siteId);
            });
        }
        else {
            return Promise.resolve();
        }
    };
    /**
     * Schedules the notifications for a list of events.
     * If an event notification time is 0, cancel its scheduled notification (if any).
     * If local notification plugin is not enabled, resolve the promise.
     *
     * @param  {any[]} events Events to schedule.
     * @param  {string} [siteId] ID of the site the events belong to. If not defined, use current site.
     * @return {Promise<any[]>}         Promise resolved when all the notifications have been scheduled.
     */
    AddonCalendarProvider.prototype.scheduleEventsNotifications = function (events, siteId) {
        var _this = this;
        var promises = [];
        if (this.localNotificationsProvider.isAvailable()) {
            siteId = siteId || this.sitesProvider.getCurrentSiteId();
            events.forEach(function (e) {
                promises.push(_this.getEventNotificationTime(e.id, siteId).then(function (time) {
                    return _this.scheduleEventNotification(e, time, siteId);
                }));
            });
        }
        return Promise.all(promises);
    };
    /**
     * Set the default notification time.
     *
     * @param  {number} time     New default time.
     * @param  {string} [siteId] ID of the site. If not defined, use current site.
     * @return {Promise<any[]>}    Promise resolved when stored.
     */
    AddonCalendarProvider.prototype.setDefaultNotificationTime = function (time, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var key = this.DEFAULT_NOTIFICATION_TIME_SETTING + '#' + siteId;
        return this.configProvider.set(key, time);
    };
    /**
     * Store events in local DB.
     *
     * @param {any[]} events  Events to store.
     * @param  {string} [siteId] ID of the site the event belongs to. If not defined, use current site.
     * @return {Promise<any[]>}         Promise resolved when the events are stored.
     */
    AddonCalendarProvider.prototype.storeEventsInLocalDB = function (events, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            siteId = site.getId();
            var promises = [], db = site.getDb();
            events.forEach(function (event) {
                // Don't override event notification time if the user configured it.
                promises.push(_this.getEventFromLocalDb(event.id, siteId).catch(function () {
                    // Event not stored, return empty object.
                    return {};
                }).then(function (e) {
                    var eventRecord = {
                        id: event.id,
                        name: event.name,
                        description: event.description,
                        eventtype: event.eventtype,
                        courseid: event.courseid,
                        timestart: event.timestart,
                        timeduration: event.timeduration,
                        categoryid: event.categoryid,
                        groupid: event.groupid,
                        instance: event.instance,
                        modulename: event.modulename,
                        timemodified: event.timemodified,
                        repeatid: event.repeatid,
                        notificationtime: e.notificationtime || -1
                    };
                    return db.insertOrUpdateRecord(_this.EVENTS_TABLE, eventRecord, { id: eventRecord.id });
                }));
            });
            return Promise.all(promises);
        });
    };
    /**
     * Updates an event notification time and schedule a new notification.
     *
     * @param  {any} event Event to update its notification time.
     * @param  {number} time  New notification setting time (in minutes). E.g. 10 means "notificate 10 minutes before start".
     * @param  {string} [siteId] ID of the site the event belongs to. If not defined, use current site.
     * @return {Promise<void>} Promise resolved when the notification is updated.
     */
    AddonCalendarProvider.prototype.updateNotificationTime = function (event, time, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            if (!_this.sitesProvider.isLoggedIn()) {
                // Not logged in, we can't get the site DB. User logged out or session expired while an operation was ongoing.
                return Promise.reject(null);
            }
            event.notificationtime = time;
            return site.getDb().insertOrUpdateRecord(_this.EVENTS_TABLE, event, { id: event.id }).then(function () {
                return _this.scheduleEventNotification(event, time);
            });
        });
    };
    AddonCalendarProvider.DAYS_INTERVAL = 30;
    AddonCalendarProvider.COMPONENT = 'AddonCalendarEvents';
    AddonCalendarProvider.DEFAULT_NOTIFICATION_TIME_CHANGED = 'AddonCalendarDefaultNotificationTimeChangedEvent';
    AddonCalendarProvider = AddonCalendarProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_groups__["a" /* CoreGroupsProvider */],
            __WEBPACK_IMPORTED_MODULE_3__core_courses_providers_courses__["a" /* CoreCoursesProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_utils_time__["a" /* CoreTimeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_7__providers_local_notifications__["a" /* CoreLocalNotificationsProvider */], __WEBPACK_IMPORTED_MODULE_8__providers_config__["a" /* CoreConfigProvider */]])
    ], AddonCalendarProvider);
    return AddonCalendarProvider;
    var AddonCalendarProvider_1;
}());

//# sourceMappingURL=calendar.js.map

/***/ }),
/* 286 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreUserComponentsModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__participants_participants__ = __webpack_require__(602);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__user_profile_field_user_profile_field__ = __webpack_require__(1081);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__components_components_module__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__directives_directives_module__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__pipes_pipes_module__ = __webpack_require__(90);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};









var CoreUserComponentsModule = /** @class */ (function () {
    function CoreUserComponentsModule() {
    }
    CoreUserComponentsModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_4__participants_participants__["a" /* CoreUserParticipantsComponent */],
                __WEBPACK_IMPORTED_MODULE_5__user_profile_field_user_profile_field__["a" /* CoreUserProfileFieldComponent */]
            ],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1__angular_common__["b" /* CommonModule */],
                __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["g" /* IonicModule */],
                __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["b" /* TranslateModule */].forChild(),
                __WEBPACK_IMPORTED_MODULE_6__components_components_module__["a" /* CoreComponentsModule */],
                __WEBPACK_IMPORTED_MODULE_7__directives_directives_module__["a" /* CoreDirectivesModule */],
                __WEBPACK_IMPORTED_MODULE_8__pipes_pipes_module__["a" /* CorePipesModule */]
            ],
            providers: [],
            exports: [
                __WEBPACK_IMPORTED_MODULE_4__participants_participants__["a" /* CoreUserParticipantsComponent */],
                __WEBPACK_IMPORTED_MODULE_5__user_profile_field_user_profile_field__["a" /* CoreUserProfileFieldComponent */]
            ],
            entryComponents: [
                __WEBPACK_IMPORTED_MODULE_4__participants_participants__["a" /* CoreUserParticipantsComponent */]
            ]
        })
    ], CoreUserComponentsModule);
    return CoreUserComponentsModule;
}());

//# sourceMappingURL=components.module.js.map

/***/ }),
/* 287 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreGradesHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_courses_providers_courses__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_course_providers_course__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__grades__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_text__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_url__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_dom__ = __webpack_require__(10);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};









/**
 * Service that provides some features regarding grades information.
 */
var CoreGradesHelperProvider = /** @class */ (function () {
    function CoreGradesHelperProvider(logger, coursesProvider, gradesProvider, sitesProvider, textUtils, courseProvider, domUtils, urlUtils) {
        this.coursesProvider = coursesProvider;
        this.gradesProvider = gradesProvider;
        this.sitesProvider = sitesProvider;
        this.textUtils = textUtils;
        this.courseProvider = courseProvider;
        this.domUtils = domUtils;
        this.urlUtils = urlUtils;
        this.logger = logger.getInstance('CoreGradesHelperProvider');
    }
    /**
     * Formats a row from the grades table te be rendered in a page.
     *
     * @param  {any}  tableRow JSON object representing row of grades table data.
     * @return {any}           Formatted row object.
     */
    CoreGradesHelperProvider.prototype.formatGradeRow = function (tableRow) {
        var row = {};
        for (var name_1 in tableRow) {
            if (typeof (tableRow[name_1].content) != 'undefined') {
                var content = tableRow[name_1].content;
                if (name_1 == 'itemname') {
                    this.setRowIcon(row, content);
                    row['link'] = this.getModuleLink(content);
                    row['rowclass'] += tableRow[name_1].class.indexOf('hidden') >= 0 ? ' hidden' : '';
                    row['rowclass'] += tableRow[name_1].class.indexOf('dimmed_text') >= 0 ? ' dimmed_text' : '';
                    content = content.replace(/<\/span>/gi, '\n');
                    content = this.textUtils.cleanTags(content);
                }
                else {
                    content = this.textUtils.replaceNewLines(content, '<br>');
                }
                if (content == '&nbsp;') {
                    content = '';
                }
                row[name_1] = content.trim();
            }
        }
        return row;
    };
    /**
     * Formats a row from the grades table to be rendered in one table.
     *
     * @param  {any}  tableRow JSON object representing row of grades table data.
     * @return {any}           Formatted row object.
     */
    CoreGradesHelperProvider.prototype.formatGradeRowForTable = function (tableRow) {
        var row = {};
        for (var name_2 in tableRow) {
            if (typeof (tableRow[name_2].content) != 'undefined') {
                var content = tableRow[name_2].content;
                if (name_2 == 'itemname') {
                    this.setRowIcon(row, content);
                    row['rowclass'] = tableRow[name_2].class.indexOf('leveleven') < 0 ? 'odd' : 'even';
                    row['rowclass'] += tableRow[name_2].class.indexOf('hidden') >= 0 ? ' hidden' : '';
                    row['rowclass'] += tableRow[name_2].class.indexOf('dimmed_text') >= 0 ? ' dimmed_text' : '';
                    content = content.replace(/<\/span>/gi, '\n');
                    content = this.textUtils.cleanTags(content);
                    row['id'] = parseInt(tableRow[name_2].id.split('_')[1], 10);
                    row['colspan'] = tableRow[name_2].colspan;
                    row['rowspan'] = (tableRow['leader'] && tableRow['leader'].rowspan) || 1;
                    name_2 = 'gradeitem';
                }
                else {
                    content = this.textUtils.replaceNewLines(content, '<br>');
                }
                if (content == '&nbsp;') {
                    content = '';
                }
                row[name_2] = content.trim();
            }
        }
        return row;
    };
    /**
     * Removes suffix formatted to compatibilize data from table and items.
     *
     * @param  {any} item Grade item to format.
     * @return {any}      Grade item formatted.
     */
    CoreGradesHelperProvider.prototype.formatGradeItem = function (item) {
        for (var name_3 in item) {
            var index = name_3.indexOf('formatted');
            if (index > 0) {
                item[name_3.substr(0, index)] = item[name_3];
            }
        }
        return item;
    };
    /**
     * Formats the response of gradereport_user_get_grades_table to be rendered.
     *
     * @param  {any}  table          JSON object representing a table with data.
     * @return {any}             Formatted HTML table.
     */
    CoreGradesHelperProvider.prototype.formatGradesTable = function (table) {
        var _this = this;
        var maxDepth = table.maxdepth, formatted = {
            columns: [],
            rows: []
        }, 
        // Columns, in order.
        columns = {
            gradeitem: true,
            weight: false,
            grade: false,
            range: false,
            percentage: false,
            lettergrade: false,
            rank: false,
            average: false,
            feedback: false,
            contributiontocoursetotal: false
        };
        formatted.rows = table.tabledata.map(function (row) {
            return _this.formatGradeRowForTable(row);
        }).filter(function (row) {
            return typeof row.gradeitem !== 'undefined';
        });
        // Get a row with some info.
        var normalRow = formatted.rows.find(function (e) {
            return e.itemtype != 'leader' && (typeof e.grade != 'undefined' || typeof e.percentage != 'undefined');
        });
        // Decide if grades or percentage is being shown on phones.
        if (normalRow && typeof normalRow.grade != 'undefined') {
            columns.grade = true;
        }
        else if (normalRow && typeof normalRow.percentage != 'undefined') {
            columns.percentage = true;
        }
        else {
            normalRow = formatted.rows.find(function (e) {
                return e.itemtype != 'leader';
            });
            columns.grade = true;
        }
        for (var colName in columns) {
            if (typeof normalRow[colName] != 'undefined') {
                formatted.columns.push({
                    name: colName,
                    colspan: colName == 'gradeitem' ? maxDepth : 1,
                    hiddenPhone: !columns[colName]
                });
            }
        }
        return formatted;
    };
    /**
     * Get course data for grades since they only have courseid.
     *
     * @param  {any} grades    Grades to get the data for.
     * @return {Promise<any>}  Promise always resolved. Resolve param is the formatted grades.
     */
    CoreGradesHelperProvider.prototype.getGradesCourseData = function (grades) {
        // Using cache for performance reasons.
        return this.coursesProvider.getUserCourses(true).then(function (courses) {
            var indexedCourses = {};
            courses.forEach(function (course) {
                indexedCourses[course.id] = course;
            });
            grades.forEach(function (grade) {
                if (typeof indexedCourses[grade.courseid] != 'undefined') {
                    grade.courseFullName = indexedCourses[grade.courseid].fullname;
                }
            });
            return grades;
        });
    };
    /**
     * Get an specific grade item.
     *
     * @param  {number}  courseId             ID of the course to get the grades from.
     * @param  {number}  gradeId              Grade ID.
     * @param  {number}  [userId]             ID of the user to get the grades from. If not defined use site's current user.
     * @param  {string}  [siteId]             Site ID. If not defined, current site.
     * @param  {boolean} [ignoreCache=false]  True if it should ignore cached data (it will always fail in offline or server down).
     * @return {Promise<any>}                Promise to be resolved when the grades are retrieved.
     */
    CoreGradesHelperProvider.prototype.getGradeItem = function (courseId, gradeId, userId, siteId, ignoreCache) {
        var _this = this;
        if (ignoreCache === void 0) { ignoreCache = false; }
        return this.gradesProvider.getCourseGradesTable(courseId, userId, siteId, ignoreCache).then(function (grades) {
            if (grades) {
                return _this.getGradesTableRow(grades, gradeId);
            }
            return Promise.reject(null);
        });
    };
    /**
     * Get the grade items for a certain module. Keep in mind that may have more than one item to include outcomes and scales.
     *
     * @param  {number}  courseId             ID of the course to get the grades from.
     * @param  {number}  moduleId             Module ID.
     * @param  {number}  [userId]             ID of the user to get the grades from. If not defined use site's current user.
     * @param  {number}  [groupId]            ID of the group to get the grades from. Not used for old gradebook table.
     * @param  {string}  [siteId]             Site ID. If not defined, current site.
     * @param  {boolean} [ignoreCache=false]  True if it should ignore cached data (it will always fail in offline or server down).
     * @return {Promise<any>}                Promise to be resolved when the grades are retrieved.
     */
    CoreGradesHelperProvider.prototype.getGradeModuleItems = function (courseId, moduleId, userId, groupId, siteId, ignoreCache) {
        var _this = this;
        if (ignoreCache === void 0) { ignoreCache = false; }
        return this.gradesProvider.getGradeItems(courseId, userId, groupId, siteId, ignoreCache).then(function (grades) {
            if (grades) {
                if (typeof grades.tabledata != 'undefined') {
                    // Table format.
                    return _this.getModuleGradesTableRows(grades, moduleId);
                }
                else {
                    return grades.filter(function (item) {
                        return item.cmid == moduleId;
                    }).map(function (item) {
                        return _this.formatGradeItem(item);
                    });
                }
            }
            return Promise.reject(null);
        });
    };
    /**
     * Gets the link to the module for the selected grade.
     *
     * @param  {string} text HTML where the link is present.
     * @return {string | false}      URL linking to the module.
     */
    CoreGradesHelperProvider.prototype.getModuleLink = function (text) {
        var el = this.domUtils.toDom(text)[0], link = el.attributes['href'] ? el.attributes['href'].value : false;
        if (!link || link.indexOf('/mod/') < 0) {
            return false;
        }
        return link;
    };
    /**
     * Get a row from the grades table.
     *
     * @param  {any}   table    JSON object representing a table with data.
     * @param  {number} gradeId Grade Object identifier.
     * @return {any}            Formatted HTML table.
     */
    CoreGradesHelperProvider.prototype.getGradesTableRow = function (table, gradeId) {
        if (table.tabledata) {
            var selectedRow = table.tabledata.find(function (row) {
                return row.itemname && row.itemname.id && row.itemname.id.substr(0, 3) == 'row' &&
                    parseInt(row.itemname.id.split('_')[1], 10) == gradeId;
            });
            if (selectedRow) {
                return this.formatGradeRow(selectedRow);
            }
        }
        return '';
    };
    /**
     * Get the rows related to a module from the grades table.
     *
     * @param  {any}   table     JSON object representing a table with data.
     * @param  {number} moduleId Grade Object identifier.
     * @return {any}             Formatted HTML table.
     */
    CoreGradesHelperProvider.prototype.getModuleGradesTableRows = function (table, moduleId) {
        var _this = this;
        if (table.tabledata) {
            // Find href containing "/mod/xxx/xxx.php".
            var regex_1 = /href="([^"]*\/mod\/[^"|^\/]*\/[^"|^\.]*\.php[^"]*)/;
            return table.tabledata.filter(function (row) {
                if (row.itemname && row.itemname.content) {
                    var matches = row.itemname.content.match(regex_1);
                    if (matches && matches.length) {
                        var hrefParams = _this.urlUtils.extractUrlParams(matches[1]);
                        return hrefParams && hrefParams.id == moduleId;
                    }
                }
                return false;
            }).map(function (row) {
                return _this.formatGradeRow(row);
            });
        }
        return [];
    };
    /**
     * Invalidate the grade items for a certain module.
     *
     * @param  {number}  courseId     ID of the course to invalidate the grades.
     * @param  {number}  [userId]     ID of the user to invalidate. If not defined use site's current user.
     * @param  {number}  [groupId]    ID of the group to invalidate. Not used for old gradebook table.
     * @param  {string}  [siteId]     Site ID. If not defined, current site.
     * @return {Promise}              Promise to be resolved when the grades are invalidated.
     */
    CoreGradesHelperProvider.prototype.invalidateGradeModuleItems = function (courseId, userId, groupId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return _this.gradesProvider.isGradeItemsAvalaible(siteId).then(function (enabled) {
                if (enabled) {
                    return _this.gradesProvider.invalidateCourseGradesItemsData(courseId, userId, groupId, siteId);
                }
                else {
                    return _this.gradesProvider.invalidateCourseGradesData(courseId, userId, siteId);
                }
            });
        });
    };
    /**
     * Parses the image and sets it to the row.
     *
     * @param  {any} row  Formatted grade row object.
     * @param  {string} text HTML where the image will be rendered.
     * @return {any}      Row object with the image.
     */
    CoreGradesHelperProvider.prototype.setRowIcon = function (row, text) {
        text = text.replace('%2F', '/').replace('%2f', '/');
        if (text.indexOf('/agg_mean') > -1) {
            row['itemtype'] = 'agg_mean';
            row['image'] = 'assets/img/grades/agg_mean.png';
        }
        else if (text.indexOf('/agg_sum') > -1) {
            row['itemtype'] = 'agg_sum';
            row['image'] = 'assets/img/grades/agg_sum.png';
        }
        else if (text.indexOf('/outcomes') > -1 || text.indexOf('fa-tasks') > -1) {
            row['itemtype'] = 'outcome';
            row['image'] = 'assets/img/grades/outcomes.png';
        }
        else if (text.indexOf('i/folder') > -1 || text.indexOf('fa-folder') > -1) {
            row['itemtype'] = 'category';
            row['icon'] = 'folder';
        }
        else if (text.indexOf('/manual_item') > -1 || text.indexOf('fa-square-o') > -1) {
            row['itemtype'] = 'manual';
            row['icon'] = 'square-outline';
        }
        else if (text.indexOf('/mod/') > -1) {
            var module_1 = text.match(/mod\/([^\/]*)\//);
            if (typeof module_1[1] != 'undefined') {
                row['itemtype'] = 'mod';
                row['itemmodule'] = module_1[1];
                row['image'] = this.courseProvider.getModuleIconSrc(module_1[1]);
            }
        }
        else if (text.indexOf('src=') > -1) {
            var src = text.match(/src="([^"]*)"/);
            row['image'] = src[1];
        }
        return row;
    };
    CoreGradesHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_3__core_courses_providers_courses__["a" /* CoreCoursesProvider */],
            __WEBPACK_IMPORTED_MODULE_5__grades__["a" /* CoreGradesProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_6__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_4__core_course_providers_course__["a" /* CoreCourseProvider */],
            __WEBPACK_IMPORTED_MODULE_8__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_7__providers_utils_url__["a" /* CoreUrlUtilsProvider */]])
    ], CoreGradesHelperProvider);
    return CoreGradesHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),
/* 288 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonCompetencyHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_user_providers_user__ = __webpack_require__(62);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Service that provides some features regarding learning plans.
 */
var AddonCompetencyHelperProvider = /** @class */ (function () {
    function AddonCompetencyHelperProvider(sitesProvider, userProvider) {
        this.sitesProvider = sitesProvider;
        this.userProvider = userProvider;
    }
    /**
     * Convenient helper to get the user profile image.
     *
     * @param  {number} userId User Id
     * @return {Promise<any>}  User profile Image URL or true if default icon.
     */
    AddonCompetencyHelperProvider.prototype.getProfile = function (userId) {
        if (!userId || userId == this.sitesProvider.getCurrentSiteUserId()) {
            return Promise.resolve(false);
        }
        // Get the user profile to retrieve the user image.
        return this.userProvider.getProfile(userId, null, true).then(function (user) {
            user.profileimageurl = user.profileimageurl || true;
            return user;
        });
    };
    AddonCompetencyHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_2__core_user_providers_user__["a" /* CoreUserProvider */]])
    ], AddonCompetencyHelperProvider);
    return AddonCompetencyHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),
/* 289 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonMessagesSyncProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__classes_base_sync__ = __webpack_require__(591);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__messages_offline__ = __webpack_require__(245);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__messages__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_user_providers_user__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_events__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_text__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_sync__ = __webpack_require__(592);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};













/**
 * Service to sync messages.
 */
var AddonMessagesSyncProvider = /** @class */ (function (_super) {
    __extends(AddonMessagesSyncProvider, _super);
    function AddonMessagesSyncProvider(sitesProvider, loggerProvider, appProvider, messagesOffline, eventsProvider, messagesProvider, userProvider, translate, utils, syncProvider, textUtils) {
        var _this = _super.call(this, 'AddonMessagesSync', sitesProvider, loggerProvider, appProvider, syncProvider, textUtils) || this;
        _this.sitesProvider = sitesProvider;
        _this.loggerProvider = loggerProvider;
        _this.appProvider = appProvider;
        _this.messagesOffline = messagesOffline;
        _this.eventsProvider = eventsProvider;
        _this.messagesProvider = messagesProvider;
        _this.userProvider = userProvider;
        _this.translate = translate;
        _this.utils = utils;
        _this.textUtils = textUtils;
        return _this;
    }
    AddonMessagesSyncProvider_1 = AddonMessagesSyncProvider;
    /**
     * Try to synchronize all the discussions in a certain site or in all sites.
     *
     * @param  {string} [siteId]                   Site ID to sync. If not defined, sync all sites.
     * @param  {boolean} [onlyDeviceOffline=false] True to only sync discussions that failed because device was offline,
     *                                             false to sync all.
     * @return {Promise<any>}                      Promise resolved if sync is successful, rejected if sync fails.
     */
    AddonMessagesSyncProvider.prototype.syncAllDiscussions = function (siteId, onlyDeviceOffline) {
        if (onlyDeviceOffline === void 0) { onlyDeviceOffline = false; }
        var syncFunctionLog = 'all discussions' + (onlyDeviceOffline ? ' (Only offline)' : '');
        return this.syncOnSites(syncFunctionLog, this.syncAllDiscussionsFunc.bind(this), [onlyDeviceOffline], siteId);
    };
    /**
     * Get all messages pending to be sent in the site.
     * @param  {boolean} [onlyDeviceOffline=false] True to only sync discussions that failed because device was offline,
     * @param  {string} [siteId]                   Site ID to sync. If not defined, sync all sites.
     * @param {Promise<any>}     Promise resolved if sync is successful, rejected if sync fails.
     */
    AddonMessagesSyncProvider.prototype.syncAllDiscussionsFunc = function (onlyDeviceOffline, siteId) {
        var _this = this;
        if (onlyDeviceOffline === void 0) { onlyDeviceOffline = false; }
        var promise = onlyDeviceOffline ?
            this.messagesOffline.getAllDeviceOfflineMessages(siteId) :
            this.messagesOffline.getAllMessages(siteId);
        return promise.then(function (messages) {
            var userIds = [], promises = [];
            // Get all the discussions to be synced.
            messages.forEach(function (message) {
                if (userIds.indexOf(message.touserid) == -1) {
                    userIds.push(message.touserid);
                }
            });
            // Sync all discussions.
            userIds.forEach(function (userId) {
                promises.push(_this.syncDiscussion(userId, siteId).then(function (warnings) {
                    if (typeof warnings != 'undefined') {
                        // Sync successful, send event.
                        _this.eventsProvider.trigger(AddonMessagesSyncProvider_1.AUTO_SYNCED, {
                            userid: userId,
                            warnings: warnings
                        }, siteId);
                    }
                }));
            });
            return Promise.all(promises);
        });
    };
    /**
     * Synchronize a discussion.
     *
     * @param  {number} userId   User ID of the discussion.
     * @param  {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}    Promise resolved if sync is successful, rejected otherwise.
     */
    AddonMessagesSyncProvider.prototype.syncDiscussion = function (userId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (this.isSyncing(userId, siteId)) {
            // There's already a sync ongoing for this SCORM, return the promise.
            return this.getOngoingSync(userId, siteId);
        }
        var warnings = [];
        this.logger.debug("Try to sync discussion with user '" + userId + "'");
        // Get offline messages to be sent.
        var syncPromise = this.messagesOffline.getMessages(userId, siteId).then(function (messages) {
            if (!messages.length) {
                // Nothing to sync.
                return [];
            }
            else if (!_this.appProvider.isOnline()) {
                // Cannot sync in offline. Mark messages as device offline.
                _this.messagesOffline.setMessagesDeviceOffline(messages, true);
                return Promise.reject(null);
            }
            var promise = Promise.resolve();
            var errors = [];
            // Order message by timecreated.
            messages = _this.messagesProvider.sortMessages(messages);
            // Send the messages.
            // We don't use AddonMessagesProvider#sendMessagesOnline because there's a problem with display order.
            // @todo Use AddonMessagesProvider#sendMessagesOnline once the display order is fixed.
            messages.forEach(function (message, index) {
                // Chain message sending. If 1 message fails to be sent we'll stop sending.
                promise = promise.then(function () {
                    return _this.messagesProvider.sendMessageOnline(userId, message.smallmessage, siteId).catch(function (error) {
                        if (_this.utils.isWebServiceError(error)) {
                            // Error returned by WS. Store the error to show a warning but keep sending messages.
                            if (errors.indexOf(error) == -1) {
                                errors.push(error);
                            }
                            return;
                        }
                        // Error sending, stop execution.
                        if (_this.appProvider.isOnline()) {
                            // App is online, unmark deviceoffline if marked.
                            _this.messagesOffline.setMessagesDeviceOffline(messages, false);
                        }
                        return Promise.reject(error);
                    }).then(function () {
                        // Message was sent, delete it from local DB.
                        return _this.messagesOffline.deleteMessage(userId, message.smallmessage, message.timecreated, siteId);
                    }).then(function () {
                        // All done. Wait 1 second to ensure timecreated of messages is different.
                        if (index < messages.length - 1) {
                            return setTimeout(function () { return; }, 1000);
                        }
                    });
                });
            });
            return promise.then(function () {
                return errors;
            });
        }).then(function (errors) {
            if (errors && errors.length) {
                // At least an error occurred, get user full name and add errors to warnings array.
                return _this.userProvider.getProfile(userId, undefined, true).catch(function () {
                    // Ignore errors.
                    return {};
                }).then(function (user) {
                    errors.forEach(function (error) {
                        warnings.push(_this.translate.instant('addon.messages.warningmessagenotsent', {
                            user: user.fullname ? user.fullname : userId,
                            error: error
                        }));
                    });
                });
            }
        }).then(function () {
            // All done, return the warnings.
            return warnings;
        });
        return this.addOngoingSync(userId, syncPromise, siteId);
    };
    AddonMessagesSyncProvider.AUTO_SYNCED = 'addon_messages_autom_synced';
    AddonMessagesSyncProvider = AddonMessagesSyncProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_5__messages_offline__["a" /* AddonMessagesOfflineProvider */],
            __WEBPACK_IMPORTED_MODULE_8__providers_events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_6__messages__["a" /* AddonMessagesProvider */],
            __WEBPACK_IMPORTED_MODULE_7__core_user_providers_user__["a" /* CoreUserProvider */], __WEBPACK_IMPORTED_MODULE_11__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_10__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_12__providers_sync__["a" /* CoreSyncProvider */], __WEBPACK_IMPORTED_MODULE_9__providers_utils_text__["a" /* CoreTextUtilsProvider */]])
    ], AddonMessagesSyncProvider);
    return AddonMessagesSyncProvider;
    var AddonMessagesSyncProvider_1;
}(__WEBPACK_IMPORTED_MODULE_3__classes_base_sync__["a" /* CoreSyncBaseProvider */]));

//# sourceMappingURL=sync.js.map

/***/ }),
/* 290 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModBookIndexComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_text__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_course_providers_course__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_course_providers_helper__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__core_course_classes_main_resource_component__ = __webpack_require__(130);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_book__ = __webpack_require__(131);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_prefetch_handler__ = __webpack_require__(596);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__components_toc_popover_toc_popover__ = __webpack_require__(597);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};












/**
 * Component that displays a book.
 */
var AddonModBookIndexComponent = /** @class */ (function (_super) {
    __extends(AddonModBookIndexComponent, _super);
    function AddonModBookIndexComponent(bookProvider, courseProvider, domUtils, appProvider, textUtils, courseHelper, prefetchDelegate, popoverCtrl, translate, content) {
        var _this = _super.call(this, textUtils, courseHelper, translate, domUtils) || this;
        _this.bookProvider = bookProvider;
        _this.courseProvider = courseProvider;
        _this.domUtils = domUtils;
        _this.appProvider = appProvider;
        _this.textUtils = textUtils;
        _this.courseHelper = courseHelper;
        _this.prefetchDelegate = prefetchDelegate;
        _this.popoverCtrl = popoverCtrl;
        _this.translate = translate;
        _this.content = content;
        _this.component = __WEBPACK_IMPORTED_MODULE_9__providers_book__["a" /* AddonModBookProvider */].COMPONENT;
        return _this;
    }
    /**
     * Component being initialized.
     */
    AddonModBookIndexComponent.prototype.ngOnInit = function () {
        _super.prototype.ngOnInit.call(this);
        this.loadContent();
    };
    /**
     * Show the TOC.
     *
     * @param {MouseEvent} event Event.
     */
    AddonModBookIndexComponent.prototype.showToc = function (event) {
        var _this = this;
        var popover = this.popoverCtrl.create(__WEBPACK_IMPORTED_MODULE_11__components_toc_popover_toc_popover__["a" /* AddonModBookTocPopoverComponent */], {
            chapters: this.chapters
        });
        popover.onDidDismiss(function (chapterId) {
            _this.changeChapter(chapterId);
        });
        popover.present({
            ev: event
        });
    };
    /**
     * Change the current chapter.
     *
     * @param {string} chapterId Chapter to load.
     * @return {Promise<void>} Promise resolved when done.
     */
    AddonModBookIndexComponent.prototype.changeChapter = function (chapterId) {
        if (chapterId && chapterId != this.currentChapter) {
            this.loaded = false;
            this.refreshIcon = 'spinner';
            this.loadChapter(chapterId);
        }
    };
    /**
     * Perform the invalidate content function.
     *
     * @return {Promise<any>} Resolved when done.
     */
    AddonModBookIndexComponent.prototype.invalidateContent = function () {
        return this.bookProvider.invalidateContent(this.module.id, this.courseId);
    };
    /**
     * Download book contents and load the current chapter.
     *
     * @param {boolean} [refresh] Whether we're refreshing data.
     * @return {Promise<any>} Promise resolved when done.
     */
    AddonModBookIndexComponent.prototype.fetchContent = function (refresh) {
        var _this = this;
        var promises = [];
        var downloadFailed = false;
        // Try to get the book data.
        promises.push(this.bookProvider.getBook(this.courseId, this.module.id).then(function (book) {
            _this.dataRetrieved.emit(book);
            _this.description = book.intro || _this.description;
        }).catch(function () {
            // Ignore errors since this WS isn't available in some Moodle versions.
        }));
        // Download content. This function also loads module contents if needed.
        promises.push(this.prefetchDelegate.download(this.module, this.courseId).catch(function () {
            // Mark download as failed but go on since the main files could have been downloaded.
            downloadFailed = true;
            if (!_this.module.contents.length) {
                // Try to load module contents for offline usage.
                return _this.courseProvider.loadModuleContents(_this.module, _this.courseId);
            }
        }));
        return Promise.all(promises).then(function () {
            _this.contentsMap = _this.bookProvider.getContentsMap(_this.module.contents);
            _this.chapters = _this.bookProvider.getTocList(_this.module.contents);
            if (typeof _this.currentChapter == 'undefined') {
                _this.currentChapter = _this.bookProvider.getFirstChapter(_this.chapters);
            }
            // Show chapter.
            return _this.loadChapter(_this.currentChapter).then(function () {
                if (downloadFailed && _this.appProvider.isOnline()) {
                    // We could load the main file but the download failed. Show error message.
                    _this.domUtils.showErrorModal('core.errordownloadingsomefiles', true);
                }
                // All data obtained, now fill the context menu.
                _this.fillContextMenu(refresh);
            }).catch(function () {
                // Ignore errors, they're handled inside the loadChapter function.
            });
        });
    };
    /**
     * Load a book chapter.
     *
     * @param {string} chapterId Chapter to load.
     * @return {Promise<void>} Promise resolved when done.
     */
    AddonModBookIndexComponent.prototype.loadChapter = function (chapterId) {
        var _this = this;
        this.currentChapter = chapterId;
        this.content && this.content.scrollToTop();
        return this.bookProvider.getChapterContent(this.contentsMap, chapterId, this.module.id).then(function (content) {
            _this.chapterContent = content;
            _this.previousChapter = _this.bookProvider.getPreviousChapter(_this.chapters, chapterId);
            _this.nextChapter = _this.bookProvider.getNextChapter(_this.chapters, chapterId);
            // Chapter loaded, log view. We don't return the promise because we don't want to block the user for this.
            _this.bookProvider.logView(_this.module.instance, chapterId).then(function () {
                // Module is completed when last chapter is viewed, so we only check completion if the last is reached.
                if (!_this.nextChapter) {
                    _this.courseProvider.checkModuleCompletion(_this.courseId, _this.module.completionstatus);
                }
            });
        }).catch(function (error) {
            _this.domUtils.showErrorModalDefault(error, 'addon.mod_book.errorchapter', true);
            return Promise.reject(null);
        }).finally(function () {
            _this.loaded = true;
            _this.refreshIcon = 'refresh';
        });
    };
    AddonModBookIndexComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'addon-mod-book-index',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/addon/mod/book/components/index/index.html"*/'<!-- Buttons to add to the header. -->\n<core-navbar-buttons end>\n    <button ion-button icon-only (click)="showToc($event)">\n        <ion-icon name="bookmark"></ion-icon>\n    </button>\n    <core-context-menu>\n        <core-context-menu-item *ngIf="externalUrl" [priority]="900" [content]="\'core.openinbrowser\' | translate" [href]="externalUrl" [iconAction]="\'open\'"></core-context-menu-item>\n        <core-context-menu-item *ngIf="description" [priority]="800" [content]="\'core.moduleintro\' | translate" (action)="expandDescription()" [iconAction]="\'arrow-forward\'"></core-context-menu-item>\n        <core-context-menu-item [priority]="700" [content]="\'core.refresh\' | translate" (action)="doRefresh(null, $event)" [iconAction]="refreshIcon" [closeOnClick]="false"></core-context-menu-item>\n        <core-context-menu-item *ngIf="prefetchStatusIcon" [priority]="600" [content]="prefetchText" (action)="prefetch()" [iconAction]="prefetchStatusIcon" [closeOnClick]="false"></core-context-menu-item>\n        <core-context-menu-item *ngIf="size" [priority]="500" [content]="size" [iconDescription]="\'cube\'" (action)="removeFiles()" [iconAction]="\'trash\'"></core-context-menu-item>\n    </core-context-menu>\n</core-navbar-buttons>\n\n<!-- Content. -->\n<core-loading [hideUntil]="loaded" class="core-loading-center">\n\n    <core-course-module-description [description]="description" [component]="component" [componentId]="componentId"></core-course-module-description>\n\n    <div padding>\n        <addon-mod-book-navigation-arrows [previous]="previousChapter" [next]="nextChapter" (action)="changeChapter($event)"></addon-mod-book-navigation-arrows>\n        <core-format-text [component]="component" [componentId]="componentId" [text]="chapterContent"></core-format-text>\n        <addon-mod-book-navigation-arrows [previous]="previousChapter" [next]="nextChapter" (action)="changeChapter($event)"></addon-mod-book-navigation-arrows>\n    </div>\n\n</core-loading>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/addon/mod/book/components/index/index.html"*/,
        }),
        __param(9, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["N" /* Optional */])()),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_9__providers_book__["a" /* AddonModBookProvider */], __WEBPACK_IMPORTED_MODULE_6__core_course_providers_course__["a" /* CoreCourseProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_5__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_7__core_course_providers_helper__["a" /* CoreCourseHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_10__providers_prefetch_handler__["a" /* AddonModBookPrefetchHandler */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["o" /* PopoverController */],
            __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["e" /* Content */]])
    ], AddonModBookIndexComponent);
    return AddonModBookIndexComponent;
}(__WEBPACK_IMPORTED_MODULE_8__core_course_classes_main_resource_component__["a" /* CoreCourseModuleMainResourceComponent */]));

//# sourceMappingURL=index.js.map

/***/ }),
/* 291 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModFolderIndexComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_text__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__core_course_providers_course__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_course_providers_helper__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_course_classes_main_resource_component__ = __webpack_require__(130);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_folder__ = __webpack_require__(163);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_helper__ = __webpack_require__(598);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};










/**
 * Component that displays a folder.
 * @todo Adding a new file in a folder updates the revision of all the files, so they're all shown as outdated.
 *       To ignore revision in folders we'll have to modify CoreCourseModulePrefetchDelegate, core-file and CoreFilepoolProvider.
 */
var AddonModFolderIndexComponent = /** @class */ (function (_super) {
    __extends(AddonModFolderIndexComponent, _super);
    function AddonModFolderIndexComponent(folderProvider, courseProvider, domUtils, appProvider, textUtils, courseHelper, translate, folderHelper) {
        var _this = _super.call(this, textUtils, courseHelper, translate, domUtils) || this;
        _this.folderProvider = folderProvider;
        _this.courseProvider = courseProvider;
        _this.domUtils = domUtils;
        _this.appProvider = appProvider;
        _this.textUtils = textUtils;
        _this.courseHelper = courseHelper;
        _this.translate = translate;
        _this.folderHelper = folderHelper;
        _this.component = __WEBPACK_IMPORTED_MODULE_8__providers_folder__["a" /* AddonModFolderProvider */].COMPONENT;
        return _this;
    }
    /**
     * Component being initialized.
     */
    AddonModFolderIndexComponent.prototype.ngOnInit = function () {
        var _this = this;
        _super.prototype.ngOnInit.call(this);
        this.canGetFolder = this.folderProvider.isGetFolderWSAvailable();
        if (this.path) {
            // Subfolder. Use module param.
            this.showModuleData(this.module);
            this.loaded = true;
            this.refreshIcon = 'refresh';
        }
        else {
            this.loadContent().then(function () {
                _this.folderProvider.logView(_this.module.instance).then(function () {
                    _this.courseProvider.checkModuleCompletion(_this.courseId, _this.module.completionstatus);
                });
            }).finally(function () {
                _this.loaded = true;
                _this.refreshIcon = 'refresh';
            });
        }
    };
    /**
     * Perform the invalidate content function.
     *
     * @return {Promise<any>} Resolved when done.
     */
    AddonModFolderIndexComponent.prototype.invalidateContent = function () {
        return this.folderProvider.invalidateContent(this.module.id, this.courseId);
    };
    /**
     * Convenience function to set scope data using module.
     * @param {any} module Module to show.
     */
    AddonModFolderIndexComponent.prototype.showModuleData = function (module) {
        this.description = module.intro || module.description;
        this.dataRetrieved.emit(module);
        if (this.path) {
            // Subfolder.
            this.contents = module.contents;
        }
        else {
            this.contents = this.folderHelper.formatContents(module.contents);
        }
    };
    /**
     * Download folder contents.
     *
     * @param {boolean} [refresh] Whether we're refreshing data.
     * @return {Promise<any>} Promise resolved when done.
     */
    AddonModFolderIndexComponent.prototype.fetchContent = function (refresh) {
        var _this = this;
        var promise;
        if (this.canGetFolder) {
            promise = this.folderProvider.getFolder(this.courseId, this.module.id).then(function (folder) {
                return _this.courseProvider.loadModuleContents(_this.module, _this.courseId).then(function () {
                    folder.contents = _this.module.contents;
                    return folder;
                });
            });
        }
        else {
            promise = this.courseProvider.getModule(this.module.id, this.courseId).then(function (folder) {
                if (!folder.contents.length && _this.module.contents.length && !_this.appProvider.isOnline()) {
                    // The contents might be empty due to a cached data. Use the old ones.
                    folder.contents = _this.module.contents;
                }
                _this.module = folder;
                return folder;
            });
        }
        return promise.then(function (folder) {
            if (folder) {
                _this.description = folder.intro || folder.description;
                _this.dataRetrieved.emit(folder);
            }
            _this.showModuleData(folder);
            // All data obtained, now fill the context menu.
            _this.fillContextMenu(refresh);
        });
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], AddonModFolderIndexComponent.prototype, "path", void 0);
    AddonModFolderIndexComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'addon-mod-folder-index',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/addon/mod/folder/components/index/index.html"*/'<!-- Buttons to add to the header. -->\n<core-navbar-buttons end>\n    <core-context-menu>\n        <core-context-menu-item *ngIf="externalUrl" [priority]="900" [content]="\'core.openinbrowser\' | translate" [href]="externalUrl" [iconAction]="\'open\'"></core-context-menu-item>\n        <core-context-menu-item *ngIf="description" [priority]="800" [content]="\'core.moduleintro\' | translate" (action)="expandDescription()" [iconAction]="\'arrow-forward\'"></core-context-menu-item>\n        <core-context-menu-item [priority]="700" [content]="\'core.refresh\' | translate" (action)="doRefresh(null, $event)" [iconAction]="refreshIcon" [closeOnClick]="false"></core-context-menu-item>\n        <core-context-menu-item *ngIf="prefetchStatusIcon" [priority]="600" [content]="prefetchText" (action)="prefetch()" [iconAction]="prefetchStatusIcon" [closeOnClick]="false"></core-context-menu-item>\n        <core-context-menu-item *ngIf="size" [priority]="500" [content]="size" [iconDescription]="\'cube\'" (action)="removeFiles()" [iconAction]="\'trash\'"></core-context-menu-item>\n    </core-context-menu>\n</core-navbar-buttons>\n\n<!-- Content. -->\n<core-loading [hideUntil]="loaded" class="core-loading-center">\n\n    <core-course-module-description [description]="description" [component]="component" [componentId]="componentId"></core-course-module-description>\n\n    <ion-list *ngIf="contents && contents.length > 0">\n        <ng-container *ngFor="let file of contents">\n            <a *ngIf="file.type === \'folder\'" ion-item class="item-media" [navPush]="\'AddonModFolderIndexPage\'" [navParams]="{path: file.filepath, courseId: courseId, module: file}">\n                <img [src]="file.fileicon" alt="" role="presentation" item-start>\n                <p>{{file.name}}</p>\n            </a>\n            <core-file *ngIf="file.type !== \'folder\'" [file]="file" [component]="component" [componentId]="file.contextid"></core-file>\n        </ng-container>\n    </ion-list>\n\n    <core-empty-box *ngIf="!contents || contents.length == 0" icon="folder" [message]=" \'addon.mod_folder.emptyfilelist\' | translate"></core-empty-box>\n\n</core-loading>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/addon/mod/folder/components/index/index.html"*/,
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_8__providers_folder__["a" /* AddonModFolderProvider */], __WEBPACK_IMPORTED_MODULE_5__core_course_providers_course__["a" /* CoreCourseProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_6__core_course_providers_helper__["a" /* CoreCourseHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_9__providers_helper__["a" /* AddonModFolderHelperProvider */]])
    ], AddonModFolderIndexComponent);
    return AddonModFolderIndexComponent;
}(__WEBPACK_IMPORTED_MODULE_7__core_course_classes_main_resource_component__["a" /* CoreCourseModuleMainResourceComponent */]));

//# sourceMappingURL=index.js.map

/***/ }),
/* 292 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModPageIndexComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_text__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__core_course_providers_course__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_course_providers_helper__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_course_classes_main_resource_component__ = __webpack_require__(130);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_page__ = __webpack_require__(107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_helper__ = __webpack_require__(247);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_prefetch_handler__ = __webpack_require__(599);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};











/**
 * Component that displays a page.
 */
var AddonModPageIndexComponent = /** @class */ (function (_super) {
    __extends(AddonModPageIndexComponent, _super);
    function AddonModPageIndexComponent(pageProvider, courseProvider, domUtils, appProvider, textUtils, courseHelper, translate, pageHelper, pagePrefetch) {
        var _this = _super.call(this, textUtils, courseHelper, translate, domUtils) || this;
        _this.pageProvider = pageProvider;
        _this.courseProvider = courseProvider;
        _this.domUtils = domUtils;
        _this.appProvider = appProvider;
        _this.textUtils = textUtils;
        _this.courseHelper = courseHelper;
        _this.translate = translate;
        _this.pageHelper = pageHelper;
        _this.pagePrefetch = pagePrefetch;
        _this.component = __WEBPACK_IMPORTED_MODULE_8__providers_page__["a" /* AddonModPageProvider */].COMPONENT;
        _this.fetchContentDefaultError = 'addon.mod_page.errorwhileloadingthepage';
        return _this;
    }
    /**
     * Component being initialized.
     */
    AddonModPageIndexComponent.prototype.ngOnInit = function () {
        var _this = this;
        _super.prototype.ngOnInit.call(this);
        this.canGetPage = this.pageProvider.isGetPageWSAvailable();
        this.loadContent().then(function () {
            _this.pageProvider.logView(_this.module.instance).then(function () {
                _this.courseProvider.checkModuleCompletion(_this.courseId, _this.module.completionstatus);
            });
        });
    };
    /**
     * Perform the invalidate content function.
     *
     * @return {Promise<any>} Resolved when done.
     */
    AddonModPageIndexComponent.prototype.invalidateContent = function () {
        return this.pageProvider.invalidateContent(this.module.id, this.courseId);
    };
    /**
     * Download page contents.
     *
     * @param {boolean} [refresh] Whether we're refreshing data.
     * @return {Promise<any>} Promise resolved when done.
     */
    AddonModPageIndexComponent.prototype.fetchContent = function (refresh) {
        var _this = this;
        var downloadFailed = false;
        // Download content. This function also loads module contents if needed.
        return this.pagePrefetch.download(this.module, this.courseId).catch(function () {
            // Mark download as failed but go on since the main files could have been downloaded.
            downloadFailed = true;
        }).then(function () {
            if (!_this.module.contents.length) {
                // Try to load module contents for offline usage.
                return _this.courseProvider.loadModuleContents(_this.module, _this.courseId);
            }
        }).then(function () {
            var promises = [];
            var getPagePromise;
            // Get the module to get the latest title and description. Data should've been updated in download.
            if (_this.canGetPage) {
                getPagePromise = _this.pageProvider.getPageData(_this.courseId, _this.module.id);
            }
            else {
                getPagePromise = _this.courseProvider.getModule(_this.module.id, _this.courseId);
            }
            promises.push(getPagePromise.then(function (page) {
                if (page) {
                    _this.description = page.intro || page.description;
                    _this.dataRetrieved.emit(page);
                }
            }).catch(function () {
                // Ignore errors.
            }));
            // Get the page HTML.
            promises.push(_this.pageHelper.getPageHtml(_this.module.contents, _this.module.id).then(function (content) {
                // All data obtained, now fill the context menu.
                _this.fillContextMenu(refresh);
                _this.contents = content;
                if (downloadFailed && _this.appProvider.isOnline()) {
                    // We could load the main file but the download failed. Show error message.
                    _this.domUtils.showErrorModal('core.errordownloadingsomefiles', true);
                }
            }));
            return Promise.all(promises);
        });
    };
    AddonModPageIndexComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'addon-mod-page-index',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/addon/mod/page/components/index/index.html"*/'<!-- Buttons to add to the header. -->\n<core-navbar-buttons end>\n    <core-context-menu>\n        <core-context-menu-item *ngIf="externalUrl" [priority]="900" [content]="\'core.openinbrowser\' | translate" [href]="externalUrl" [iconAction]="\'open\'"></core-context-menu-item>\n        <core-context-menu-item *ngIf="description" [priority]="800" [content]="\'core.moduleintro\' | translate" (action)="expandDescription()" [iconAction]="\'arrow-forward\'"></core-context-menu-item>\n        <core-context-menu-item [priority]="700" [content]="\'core.refresh\' | translate" (action)="doRefresh(null, $event)" [iconAction]="refreshIcon" [closeOnClick]="false"></core-context-menu-item>\n        <core-context-menu-item *ngIf="prefetchStatusIcon" [priority]="600" [content]="prefetchText" (action)="prefetch()" [iconAction]="prefetchStatusIcon" [closeOnClick]="false"></core-context-menu-item>\n        <core-context-menu-item *ngIf="size" [priority]="500" [content]="size" [iconDescription]="\'cube\'" (action)="removeFiles()" [iconAction]="\'trash\'"></core-context-menu-item>\n    </core-context-menu>\n</core-navbar-buttons>\n\n<!-- Content. -->\n<core-loading [hideUntil]="loaded" class="core-loading-center">\n\n    <core-course-module-description [description]="description" [component]="component" [componentId]="componentId"></core-course-module-description>\n\n    <div padding>\n        <core-format-text [component]="component" [componentId]="componentId" [text]="contents"></core-format-text>\n    </div>\n\n</core-loading>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/addon/mod/page/components/index/index.html"*/,
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_8__providers_page__["a" /* AddonModPageProvider */], __WEBPACK_IMPORTED_MODULE_5__core_course_providers_course__["a" /* CoreCourseProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_6__core_course_providers_helper__["a" /* CoreCourseHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_9__providers_helper__["a" /* AddonModPageHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_10__providers_prefetch_handler__["a" /* AddonModPagePrefetchHandler */]])
    ], AddonModPageIndexComponent);
    return AddonModPageIndexComponent;
}(__WEBPACK_IMPORTED_MODULE_7__core_course_classes_main_resource_component__["a" /* CoreCourseModuleMainResourceComponent */]));

//# sourceMappingURL=index.js.map

/***/ }),
/* 293 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModResourceIndexComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_text__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__core_course_providers_course__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_course_providers_helper__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_course_classes_main_resource_component__ = __webpack_require__(130);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_resource__ = __webpack_require__(108);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_prefetch_handler__ = __webpack_require__(600);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_helper__ = __webpack_require__(164);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};











/**
 * Component that displays a resource.
 */
var AddonModResourceIndexComponent = /** @class */ (function (_super) {
    __extends(AddonModResourceIndexComponent, _super);
    function AddonModResourceIndexComponent(resourceProvider, courseProvider, domUtils, appProvider, textUtils, courseHelper, translate, prefetchHandler, resourceHelper) {
        var _this = _super.call(this, textUtils, courseHelper, translate, domUtils) || this;
        _this.resourceProvider = resourceProvider;
        _this.courseProvider = courseProvider;
        _this.domUtils = domUtils;
        _this.appProvider = appProvider;
        _this.textUtils = textUtils;
        _this.courseHelper = courseHelper;
        _this.translate = translate;
        _this.prefetchHandler = prefetchHandler;
        _this.resourceHelper = resourceHelper;
        _this.component = __WEBPACK_IMPORTED_MODULE_8__providers_resource__["a" /* AddonModResourceProvider */].COMPONENT;
        return _this;
    }
    /**
     * Component being initialized.
     */
    AddonModResourceIndexComponent.prototype.ngOnInit = function () {
        var _this = this;
        _super.prototype.ngOnInit.call(this);
        this.canGetResource = this.resourceProvider.isGetResourceWSAvailable();
        this.loadContent().then(function () {
            _this.resourceProvider.logView(_this.module.instance).then(function () {
                _this.courseProvider.checkModuleCompletion(_this.courseId, _this.module.completionstatus);
            });
        });
    };
    /**
     * Perform the invalidate content function.
     *
     * @return {Promise<any>} Resolved when done.
     */
    AddonModResourceIndexComponent.prototype.invalidateContent = function () {
        return this.resourceProvider.invalidateContent(this.module.id, this.courseId);
    };
    /**
     * Download resource contents.
     *
     * @param {boolean} [refresh] Whether we're refreshing data.
     * @return {Promise<any>} Promise resolved when done.
     */
    AddonModResourceIndexComponent.prototype.fetchContent = function (refresh) {
        var _this = this;
        // Load module contents if needed. Passing refresh is needed to force reloading contents.
        return this.courseProvider.loadModuleContents(this.module, this.courseId, null, false, refresh).then(function () {
            if (!_this.module.contents || !_this.module.contents.length) {
                return Promise.reject(null);
            }
            // Get the resource instance to get the latest name/description and to know if it's embedded.
            if (_this.canGetResource) {
                return _this.resourceProvider.getResourceData(_this.courseId, _this.module.id).catch(function () {
                    // Ignore errors.
                });
            }
            return _this.courseProvider.getModule(_this.module.id, _this.courseId).catch(function () {
                // Ignore errors.
            });
        }).then(function (resource) {
            if (resource) {
                _this.description = resource.intro || resource.description;
                _this.dataRetrieved.emit(resource);
            }
            if (_this.resourceHelper.isDisplayedInIframe(_this.module)) {
                var downloadFailed_1 = false;
                return _this.prefetchHandler.download(_this.module, _this.courseId).catch(function () {
                    // Mark download as failed but go on since the main files could have been downloaded.
                    downloadFailed_1 = true;
                }).then(function () {
                    return _this.resourceHelper.getIframeSrc(_this.module).then(function (src) {
                        _this.mode = 'iframe';
                        if (_this.src && src.toString() == _this.src.toString()) {
                            // Re-loading same page.
                            // Set it to empty and then re-set the src in the next digest so it detects it has changed.
                            _this.src = '';
                            setTimeout(function () {
                                _this.src = src;
                            });
                        }
                        else {
                            _this.src = src;
                        }
                        if (downloadFailed_1 && _this.appProvider.isOnline()) {
                            // We could load the main file but the download failed. Show error message.
                            _this.domUtils.showErrorModal('core.errordownloadingsomefiles', true);
                        }
                    });
                });
            }
            else if (_this.resourceHelper.isDisplayedEmbedded(_this.module, resource && resource.display)) {
                _this.mode = 'embedded';
                return _this.resourceHelper.getEmbeddedHtml(_this.module).then(function (html) {
                    _this.contentText = html;
                });
            }
            else {
                _this.mode = 'external';
            }
        }).then(function () {
            // All data obtained, now fill the context menu.
            _this.fillContextMenu(refresh);
        });
    };
    /**
     * Opens a file.
     */
    AddonModResourceIndexComponent.prototype.open = function () {
        this.resourceHelper.openModuleFile(this.module, this.courseId);
    };
    AddonModResourceIndexComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'addon-mod-resource-index',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/addon/mod/resource/components/index/index.html"*/'<!-- Buttons to add to the header. -->\n<core-navbar-buttons end>\n    <core-context-menu>\n        <core-context-menu-item *ngIf="externalUrl" [priority]="900" [content]="\'core.openinbrowser\' | translate" [href]="externalUrl" [iconAction]="\'open\'"></core-context-menu-item>\n        <core-context-menu-item *ngIf="description" [priority]="800" [content]="\'core.moduleintro\' | translate" (action)="expandDescription()" [iconAction]="\'arrow-forward\'"></core-context-menu-item>\n        <core-context-menu-item [priority]="700" [content]="\'core.refresh\' | translate" (action)="doRefresh(null, $event)" [iconAction]="refreshIcon" [closeOnClick]="false"></core-context-menu-item>\n        <core-context-menu-item *ngIf="prefetchStatusIcon" [priority]="600" [content]="prefetchText" (action)="prefetch()" [iconAction]="prefetchStatusIcon" [closeOnClick]="false"></core-context-menu-item>\n        <core-context-menu-item *ngIf="size" [priority]="500" [content]="size" [iconDescription]="\'cube\'" (action)="removeFiles()" [iconAction]="\'trash\'"></core-context-menu-item>\n    </core-context-menu>\n</core-navbar-buttons>\n\n<!-- Content. -->\n<core-loading [hideUntil]="loaded" class="core-loading-center">\n\n    <core-course-module-description *ngIf="mode != \'iframe\'" [description]="description" [component]="component" [componentId]="componentId"></core-course-module-description>\n\n    <ng-container *ngIf="mode == \'iframe\'">\n        <core-iframe [src]="src"></core-iframe>\n    </ng-container>\n\n    <div *ngIf="mode == \'embedded\'">\n        <core-format-text [text]="contentText"></core-format-text>\n    </div>\n\n    <div padding *ngIf="mode == \'external\'">\n        <a ion-button block (click)="open()" icon-start>\n            <ion-icon name="document" start></ion-icon>\n            {{ \'addon.mod_resource.openthefile\' | translate }}\n        </a>\n    </div>\n\n</core-loading>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/addon/mod/resource/components/index/index.html"*/,
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_8__providers_resource__["a" /* AddonModResourceProvider */], __WEBPACK_IMPORTED_MODULE_5__core_course_providers_course__["a" /* CoreCourseProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_6__core_course_providers_helper__["a" /* CoreCourseHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_9__providers_prefetch_handler__["a" /* AddonModResourcePrefetchHandler */],
            __WEBPACK_IMPORTED_MODULE_10__providers_helper__["a" /* AddonModResourceHelperProvider */]])
    ], AddonModResourceIndexComponent);
    return AddonModResourceIndexComponent;
}(__WEBPACK_IMPORTED_MODULE_7__core_course_classes_main_resource_component__["a" /* CoreCourseModuleMainResourceComponent */]));

//# sourceMappingURL=index.js.map

/***/ }),
/* 294 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModUrlIndexComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_text__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_course_providers_course__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__core_course_classes_main_resource_component__ = __webpack_require__(130);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_url__ = __webpack_require__(165);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_helper__ = __webpack_require__(248);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__core_course_providers_helper__ = __webpack_require__(29);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};









/**
 * Component that displays a url.
 */
var AddonModUrlIndexComponent = /** @class */ (function (_super) {
    __extends(AddonModUrlIndexComponent, _super);
    function AddonModUrlIndexComponent(urlProvider, courseProvider, domUtils, textUtils, translate, urlHelper, courseHelper) {
        var _this = _super.call(this, textUtils, courseHelper, translate, domUtils) || this;
        _this.urlProvider = urlProvider;
        _this.courseProvider = courseProvider;
        _this.domUtils = domUtils;
        _this.textUtils = textUtils;
        _this.translate = translate;
        _this.urlHelper = urlHelper;
        _this.courseHelper = courseHelper;
        _this.component = __WEBPACK_IMPORTED_MODULE_6__providers_url__["a" /* AddonModUrlProvider */].COMPONENT;
        return _this;
    }
    /**
     * Component being initialized.
     */
    AddonModUrlIndexComponent.prototype.ngOnInit = function () {
        _super.prototype.ngOnInit.call(this);
        this.canGetUrl = this.urlProvider.isGetUrlWSAvailable();
        this.loadContent();
    };
    /**
     * Perform the invalidate content function.
     *
     * @return {Promise<any>} Resolved when done.
     */
    AddonModUrlIndexComponent.prototype.invalidateContent = function () {
        return this.urlProvider.invalidateContent(this.module.id, this.courseId);
    };
    /**
     * Download url contents.
     *
     * @param {boolean} [refresh] Whether we're refreshing data.
     * @return {Promise<any>} Promise resolved when done.
     */
    AddonModUrlIndexComponent.prototype.fetchContent = function (refresh) {
        var _this = this;
        var canGetUrl = this.canGetUrl;
        // Fetch the module data.
        var promise;
        if (canGetUrl) {
            promise = this.urlProvider.getUrl(this.courseId, this.module.id);
        }
        else {
            promise = Promise.reject(null);
        }
        return promise.catch(function () {
            canGetUrl = false;
            // Fallback in case is not prefetch or not avalaible.
            return _this.courseProvider.getModule(_this.module.id, _this.courseId);
        }).then(function (url) {
            if (!canGetUrl) {
                if (!url.contents.length) {
                    // If the data was cached maybe we don't have contents. Reject.
                    return Promise.reject(null);
                }
            }
            _this.description = url.intro || url.description;
            _this.dataRetrieved.emit(url);
            _this.url = canGetUrl ? url.externalurl :
                ((url.contents[0] && url.contents[0].fileurl) ? url.contents[0].fileurl : undefined);
        });
    };
    /**
     * Opens a file.
     */
    AddonModUrlIndexComponent.prototype.go = function () {
        var _this = this;
        this.urlProvider.logView(this.module.instance).then(function () {
            _this.courseProvider.checkModuleCompletion(_this.courseId, _this.module.completionstatus);
        });
        this.urlHelper.open(this.url);
    };
    AddonModUrlIndexComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'addon-mod-url-index',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/addon/mod/url/components/index/index.html"*/'<!-- Buttons to add to the header. -->\n<core-navbar-buttons end>\n    <core-context-menu>\n        <core-context-menu-item *ngIf="externalUrl" [priority]="900" [content]="\'core.openinbrowser\' | translate" [href]="externalUrl" [iconAction]="\'open\'"></core-context-menu-item>\n        <core-context-menu-item *ngIf="description" [priority]="800" [content]="\'core.moduleintro\' | translate" (action)="expandDescription()" [iconAction]="\'arrow-forward\'"></core-context-menu-item>\n        <core-context-menu-item [priority]="700" [content]="\'core.refresh\' | translate" (action)="doRefresh(null, $event)" [iconAction]="refreshIcon" [closeOnClick]="false"></core-context-menu-item>\n    </core-context-menu>\n</core-navbar-buttons>\n\n<!-- Content. -->\n<core-loading [hideUntil]="loaded" class="core-loading-center">\n\n    <core-course-module-description *ngIf="mode != \'iframe\'" [description]="description" [component]="component" [componentId]="componentId"></core-course-module-description>\n\n    <ion-item text-wrap>\n        <h2>{{ \'addon.mod_url.pointingtourl\' | translate }}</h2>\n        <p>{{ url }}</p>\n    </ion-item>\n    <div padding>\n        <a ion-button block (click)="go()" icon-start>\n            <ion-icon name="link" start></ion-icon>\n            {{ \'addon.mod_url.accessurl\' | translate }}\n        </a>\n    </div>\n</core-loading>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/addon/mod/url/components/index/index.html"*/,
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__providers_url__["a" /* AddonModUrlProvider */], __WEBPACK_IMPORTED_MODULE_4__core_course_providers_course__["a" /* CoreCourseProvider */],
            __WEBPACK_IMPORTED_MODULE_2__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_text__["a" /* CoreTextUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_7__providers_helper__["a" /* AddonModUrlHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_8__core_course_providers_helper__["a" /* CoreCourseHelperProvider */]])
    ], AddonModUrlIndexComponent);
    return AddonModUrlIndexComponent;
}(__WEBPACK_IMPORTED_MODULE_5__core_course_classes_main_resource_component__["a" /* CoreCourseModuleMainResourceComponent */]));

//# sourceMappingURL=index.js.map

/***/ }),
/* 295 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonPushNotificationsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_badge__ = __webpack_require__(603);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_push__ = __webpack_require__(604);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ionic_native_device__ = __webpack_require__(605);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__delegate__ = __webpack_require__(136);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_local_notifications__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_utils_text__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_config__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__configconstants__ = __webpack_require__(50);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};














/**
 * Service to handle push notifications.
 */
var AddonPushNotificationsProvider = /** @class */ (function () {
    function AddonPushNotificationsProvider(logger, appProvider, platform, pushNotificationsDelegate, sitesProvider, badge, localNotificationsProvider, utils, textUtils, push, configProvider, device) {
        this.appProvider = appProvider;
        this.platform = platform;
        this.pushNotificationsDelegate = pushNotificationsDelegate;
        this.sitesProvider = sitesProvider;
        this.badge = badge;
        this.localNotificationsProvider = localNotificationsProvider;
        this.utils = utils;
        this.textUtils = textUtils;
        this.push = push;
        this.configProvider = configProvider;
        this.device = device;
        // Variables for database.
        this.BADGE_TABLE = 'addon_pushnotifications_badge';
        this.tablesSchema = [
            {
                name: this.BADGE_TABLE,
                columns: [
                    {
                        name: 'siteid',
                        type: 'TEXT'
                    },
                    {
                        name: 'addon',
                        type: 'TEXT'
                    },
                    {
                        name: 'number',
                        type: 'INTEGER'
                    }
                ],
                primaryKeys: ['siteid', 'addon']
            }
        ];
        this.logger = logger.getInstance('AddonPushNotificationsProvider');
        this.appDB = appProvider.getDB();
        this.appDB.createTablesFromSchema(this.tablesSchema);
    }
    AddonPushNotificationsProvider_1 = AddonPushNotificationsProvider;
    /**
     * Delete all badge records for a given site.
     *
     * @param  {string} siteId Site ID.
     * @return {Promise<any>}  Resolved when done.
     */
    AddonPushNotificationsProvider.prototype.cleanSiteCounters = function (siteId) {
        var _this = this;
        return this.appDB.deleteRecords(this.BADGE_TABLE, { siteid: siteId }).finally(function () {
            _this.updateAppCounter();
        });
    };
    /**
     * Returns options for push notifications based on device.
     *
     * @return {Promise<PushOptions>} Promise with the push options resolved when done.
     */
    AddonPushNotificationsProvider.prototype.getOptions = function () {
        // @todo: CoreSettingsProvider.NOTIFICATION_SOUND
        return this.configProvider.get('CoreSettingsProvider.NOTIFICATION_SOUND', true).then(function (soundEnabled) {
            return {
                android: {
                    senderID: __WEBPACK_IMPORTED_MODULE_13__configconstants__["a" /* CoreConfigConstants */].gcmpn,
                    sound: !!soundEnabled
                },
                ios: {
                    alert: 'true',
                    badge: true,
                    sound: !!soundEnabled
                },
                windows: {
                    sound: !!soundEnabled
                }
            };
        });
    };
    /**
     * Get the pushID for this device.
     *
     * @return {string} Push ID.
     */
    AddonPushNotificationsProvider.prototype.getPushId = function () {
        return this.pushID;
    };
    /**
     * Get Sitebadge  counter from the database.
     *
     * @param  {string} siteId Site ID.
     * @return {Promise<any>}       Promise resolved with the stored badge counter for the site.
     */
    AddonPushNotificationsProvider.prototype.getSiteCounter = function (siteId) {
        return this.getAddonBadge(siteId);
    };
    /**
     * Function called when a push notification is clicked. Redirect the user to the right state.
     *
     * @param {any} notification Notification.
     */
    AddonPushNotificationsProvider.prototype.notificationClicked = function (notification) {
        var _this = this;
        this.platform.ready().then(function () {
            _this.pushNotificationsDelegate.clicked(notification);
        });
    };
    /**
     * This function is called when we receive a Notification from APNS or a message notification from GCM.
     * The app can be in foreground or background,
     * if we are in background this code is executed when we open the app clicking in the notification bar.
     *
     * @param {any} notification Notification received.
     */
    AddonPushNotificationsProvider.prototype.onMessageReceived = function (notification) {
        var _this = this;
        var data = notification ? notification.additionalData : {};
        this.sitesProvider.getSite(data.site).then(function () {
            if (_this.utils.isTrueOrOne(data.foreground)) {
                // If the app is in foreground when the notification is received, it's not shown. Let's show it ourselves.
                if (_this.localNotificationsProvider.isAvailable()) {
                    var localNotif_1 = {
                        id: 1,
                        at: new Date(),
                        data: {
                            notif: data.notif,
                            site: data.site
                        },
                        title: '',
                        text: ''
                    }, promises = [];
                    // Apply formatText to title and message.
                    promises.push(_this.textUtils.formatText(notification.title, true, true).then(function (formattedTitle) {
                        localNotif_1.title = formattedTitle;
                    }).catch(function () {
                        localNotif_1.title = notification.title;
                    }));
                    promises.push(_this.textUtils.formatText(notification.message, true, true).then(function (formattedMessage) {
                        localNotif_1.text = formattedMessage;
                    }).catch(function () {
                        localNotif_1.text = notification.message;
                    }));
                    Promise.all(promises).then(function () {
                        _this.localNotificationsProvider.schedule(localNotif_1, AddonPushNotificationsProvider_1.COMPONENT, data.site);
                    });
                }
                // Trigger a notification received event.
                _this.platform.ready().then(function () {
                    data.title = notification.title;
                    data.message = notification.message;
                    _this.pushNotificationsDelegate.received(data);
                });
            }
            else {
                // The notification was clicked.
                // For compatibility with old push plugin implementation we'll merge all the notification data in a single object.
                data.title = notification.title;
                data.message = notification.message;
                _this.notificationClicked(data);
            }
        });
    };
    /**
     * Unregisters a device from a certain Moodle site.
     *
     * @param {any} site Site to unregister from.
     * @return {Promise<any>}    Promise resolved when device is unregistered.
     */
    AddonPushNotificationsProvider.prototype.unregisterDeviceOnMoodle = function (site) {
        if (!site || !this.appProvider.isMobile()) {
            return Promise.reject(null);
        }
        this.logger.debug("Unregister device on Moodle: '" + site.id + "'");
        var data = {
            appid: __WEBPACK_IMPORTED_MODULE_13__configconstants__["a" /* CoreConfigConstants */].app_id,
            uuid: this.device.uuid
        };
        return site.write('core_user_remove_user_device', data).then(function (response) {
            if (!response || !response.removed) {
                return Promise.reject(null);
            }
        });
    };
    /**
     * Update Counter for an addon. It will update the refered siteId counter and the total badge.
     * It will return the updated addon counter.
     *
     * @param  {string} addon    Registered addon name to set the badge number.
     * @param  {number} value    The number to be stored.
     * @param  {string} [siteId] Site ID. If not defined, use current site.
     * @return {Promise<any>}    Promise resolved with the stored badge counter for the addon on the site.
     */
    AddonPushNotificationsProvider.prototype.updateAddonCounter = function (addon, value, siteId) {
        var _this = this;
        if (this.pushNotificationsDelegate.isCounterHandlerRegistered(addon)) {
            siteId = siteId || this.sitesProvider.getCurrentSiteId();
            return this.saveAddonBadge(value, siteId, addon).then(function () {
                return _this.updateSiteCounter(siteId).then(function () {
                    return value;
                });
            });
        }
        return Promise.resolve(0);
    };
    /**
     * Update total badge counter of the app.
     *
     * @return {Promise<any>}        Promise resolved with the stored badge counter for the site.
     */
    AddonPushNotificationsProvider.prototype.updateAppCounter = function () {
        var _this = this;
        return this.sitesProvider.getSitesIds().then(function (sites) {
            var promises = [];
            sites.forEach(function (siteId) {
                promises.push(_this.getAddonBadge(siteId));
            });
            return Promise.all(promises).then(function (counters) {
                var total = counters.reduce(function (previous, counter) {
                    // The app badge counter does not support strings, so parse to int before.
                    return previous + parseInt(counter, 10);
                }, 0);
                // Set the app badge.
                return _this.badge.set(total).then(function () {
                    return total;
                });
            });
        });
    };
    /**
     * Update counter for a site using the stored addon data. It will update the total badge application number.
     * It will return the updated site counter.
     *
     * @param  {string} siteId Site ID.
     * @return {Promise<any>}       Promise resolved with the stored badge counter for the site.
     */
    AddonPushNotificationsProvider.prototype.updateSiteCounter = function (siteId) {
        var _this = this;
        var addons = this.pushNotificationsDelegate.getCounterHandlers(), promises = [];
        for (var x in addons) {
            promises.push(this.getAddonBadge(siteId, addons[x]));
        }
        return Promise.all(promises).then(function (counters) {
            var plus = false, total = counters.reduce(function (previous, counter) {
                // Check if there is a plus sign at the end of the counter.
                if (counter != parseInt(counter, 10)) {
                    plus = true;
                    counter = parseInt(counter, 10);
                }
                return previous + counter;
            }, 0);
            total = plus && total > 0 ? total + '+' : total;
            // Save the counter on site.
            return _this.saveAddonBadge(total, siteId);
        }).then(function (siteTotal) {
            return _this.updateAppCounter().then(function () {
                return siteTotal;
            });
        });
    };
    /**
     * Register a device in Apple APNS or Google GCM.
     *
     * @return {Promise<any>} Promise resolved when the device is registered.
     */
    AddonPushNotificationsProvider.prototype.registerDevice = function () {
        var _this = this;
        try {
            // Check if sound is enabled for notifications.
            return this.getOptions().then(function (options) {
                var pushObject = _this.push.init(options);
                pushObject.on('notification').subscribe(function (notification) {
                    _this.logger.log('Received a notification', notification);
                    _this.onMessageReceived(notification);
                });
                pushObject.on('registration').subscribe(function (registrationId) {
                    _this.pushID = registrationId;
                    _this.registerDeviceOnMoodle().catch(function (error) {
                        _this.logger.warn('Can\'t register device', error);
                    });
                });
                pushObject.on('error').subscribe(function (error) {
                    _this.logger.warn('Error with Push plugin', error);
                });
            });
        }
        catch (ex) {
            // Ignore errors.
            this.logger.warn(ex);
        }
        return Promise.reject(null);
    };
    /**
     * Registers a device on current Moodle site.
     *
     * @return {Promise<any>}      Promise resolved when device is registered.
     */
    AddonPushNotificationsProvider.prototype.registerDeviceOnMoodle = function () {
        this.logger.debug('Register device on Moodle.');
        if (!this.sitesProvider.isLoggedIn() || !this.pushID || !this.appProvider.isMobile()) {
            return Promise.reject(null);
        }
        var data = {
            appid: __WEBPACK_IMPORTED_MODULE_13__configconstants__["a" /* CoreConfigConstants */].app_id,
            name: this.device.manufacturer || '',
            model: this.device.model,
            platform: this.device.platform,
            version: this.device.version,
            pushid: this.pushID,
            uuid: this.device.uuid
        };
        return this.sitesProvider.getCurrentSite().write('core_user_add_user_device', data);
    };
    /**
     * Get the addon/site badge counter from the database.
     *
     * @param  {string} siteId   Site ID.
     * @param  {string} [addon='site'] Registered addon name. If not defined it will store the site total.
     * @return {Promise<any>}         Promise resolved with the stored badge counter for the addon or site or 0 if none.
     */
    AddonPushNotificationsProvider.prototype.getAddonBadge = function (siteId, addon) {
        if (addon === void 0) { addon = 'site'; }
        return this.appDB.getRecord(this.BADGE_TABLE, { siteid: siteId, addon: addon }).then(function (entry) {
            return (entry && entry.number) || 0;
        }).catch(function () {
            return 0;
        });
    };
    /**
     * Save the addon/site badgecounter on the database.
     *
     * @param  {number} value   The number to be stored.
     * @param  {string} [siteId] Site ID. If not defined, use current site.
     * @param  {string} [addon='site'] Registered addon name. If not defined it will store the site total.
     * @return {Promise<any>}         Promise resolved with the stored badge counter for the addon or site.
     */
    AddonPushNotificationsProvider.prototype.saveAddonBadge = function (value, siteId, addon) {
        if (addon === void 0) { addon = 'site'; }
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var entry = {
            siteid: siteId,
            addon: addon,
            number: value
        };
        return this.appDB.insertOrUpdateRecord(this.BADGE_TABLE, entry, { siteid: siteId, addon: addon }).then(function () {
            return value;
        });
    };
    AddonPushNotificationsProvider.COMPONENT = 'AddonPushNotificationsProvider';
    AddonPushNotificationsProvider = AddonPushNotificationsProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */],
            __WEBPACK_IMPORTED_MODULE_8__delegate__["a" /* AddonPushNotificationsDelegate */], __WEBPACK_IMPORTED_MODULE_7__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_2__ionic_native_badge__["a" /* Badge */], __WEBPACK_IMPORTED_MODULE_9__providers_local_notifications__["a" /* CoreLocalNotificationsProvider */],
            __WEBPACK_IMPORTED_MODULE_10__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_11__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_3__ionic_native_push__["a" /* Push */],
            __WEBPACK_IMPORTED_MODULE_12__providers_config__["a" /* CoreConfigProvider */], __WEBPACK_IMPORTED_MODULE_4__ionic_native_device__["a" /* Device */]])
    ], AddonPushNotificationsProvider);
    return AddonPushNotificationsProvider;
    var AddonPushNotificationsProvider_1;
}());

//# sourceMappingURL=pushnotifications.js.map

/***/ }),
/* 296 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSharedFilesProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_events__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_file__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_mimetype__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_text__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_ts_md5_dist_md5__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_ts_md5_dist_md5___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_ts_md5_dist_md5__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};









/**
 * Service to share files with the app.
 */
var CoreSharedFilesProvider = /** @class */ (function () {
    function CoreSharedFilesProvider(logger, fileProvider, appProvider, textUtils, mimeUtils, sitesProvider, eventsProvider) {
        this.fileProvider = fileProvider;
        this.textUtils = textUtils;
        this.mimeUtils = mimeUtils;
        this.sitesProvider = sitesProvider;
        this.eventsProvider = eventsProvider;
        // Variables for the database.
        this.SHARED_FILES_TABLE = 'wscache';
        this.tableSchema = {
            name: this.SHARED_FILES_TABLE,
            columns: [
                {
                    name: 'id',
                    type: 'TEXT',
                    primaryKey: true
                }
            ]
        };
        this.logger = logger.getInstance('CoreSharedFilesProvider');
        this.appDB = appProvider.getDB();
        this.appDB.createTableFromSchema(this.tableSchema);
    }
    CoreSharedFilesProvider_1 = CoreSharedFilesProvider;
    /**
     * Checks if there is a new file received in iOS. If more than one file is found, treat only the first one.
     * The file returned is marked as "treated" and will be deleted in the next execution.
     *
     * @return {Promise<any>} Promise resolved with a new file to be treated. If no new files found, promise is rejected.
     */
    CoreSharedFilesProvider.prototype.checkIOSNewFiles = function () {
        var _this = this;
        this.logger.debug('Search for new files on iOS');
        return this.fileProvider.getDirectoryContents('Inbox').then(function (entries) {
            if (entries.length > 0) {
                var promises_1 = [];
                var fileToReturn_1;
                entries.forEach(function (entry) {
                    var fileId = _this.getFileId(entry);
                    // Check if file was already treated.
                    promises_1.push(_this.isFileTreated(fileId).then(function () {
                        // File already treated, delete it. Don't return delete promise, we'll ignore errors.
                        _this.deleteInboxFile(entry);
                    }).catch(function () {
                        // File not treated before.
                        _this.logger.debug('Found new file ' + entry.name + ' shared with the app.');
                        if (!fileToReturn_1) {
                            fileToReturn_1 = entry;
                        }
                    }));
                });
                return Promise.all(promises_1).then(function () {
                    var fileId;
                    if (fileToReturn_1) {
                        // Mark it as "treated".
                        fileId = _this.getFileId(fileToReturn_1);
                        return _this.markAsTreated(fileId).then(function () {
                            _this.logger.debug('File marked as "treated": ' + fileToReturn_1.name);
                            return fileToReturn_1;
                        });
                    }
                    else {
                        return Promise.reject(null);
                    }
                });
            }
            else {
                return Promise.reject(null);
            }
        });
    };
    /**
     * Deletes a file in the Inbox folder (shared with the app).
     *
     * @param {any} entry FileEntry.
     * @return {Promise<any>} Promise resolved when done, rejected otherwise.
     */
    CoreSharedFilesProvider.prototype.deleteInboxFile = function (entry) {
        var _this = this;
        this.logger.debug('Delete inbox file: ' + entry.name);
        return this.fileProvider.removeFileByFileEntry(entry).catch(function () {
            // Ignore errors.
        }).then(function () {
            return _this.unmarkAsTreated(_this.getFileId(entry)).then(function () {
                _this.logger.debug('"Treated" mark removed from file: ' + entry.name);
            }).catch(function (error) {
                _this.logger.debug('Error deleting "treated" mark from file: ' + entry.name, error);
                return Promise.reject(error);
            });
        });
    };
    /**
     * Get the ID of a file for managing "treated" files.
     *
     * @param {any} entry FileEntry.
     * @return {string} File ID.
     */
    CoreSharedFilesProvider.prototype.getFileId = function (entry) {
        return __WEBPACK_IMPORTED_MODULE_8_ts_md5_dist_md5__["Md5"].hashAsciiStr(entry.name);
    };
    /**
     * Get the shared files stored in a site.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {string} [path] Path to search inside the site shared folder.
     * @param {string[]} [mimetypes] List of supported mimetypes. If undefined, all mimetypes supported.
     * @return {Promise<any[]>} Promise resolved with the files.
     */
    CoreSharedFilesProvider.prototype.getSiteSharedFiles = function (siteId, path, mimetypes) {
        var _this = this;
        var pathToGet = this.getSiteSharedFilesDirPath(siteId);
        if (path) {
            pathToGet = this.textUtils.concatenatePaths(pathToGet, path);
        }
        return this.fileProvider.getDirectoryContents(pathToGet).then(function (files) {
            if (mimetypes) {
                // Only show files with the right mimetype and the ones we cannot determine the mimetype.
                files = files.filter(function (file) {
                    var extension = _this.mimeUtils.getFileExtension(file.name), mimetype = _this.mimeUtils.getMimeType(extension);
                    return !mimetype || mimetypes.indexOf(mimetype) > -1;
                });
            }
            return files;
        }).catch(function () {
            // Directory not found, return empty list.
            return [];
        });
    };
    /**
     * Get the path to a site's shared files folder.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {string} Path.
     */
    CoreSharedFilesProvider.prototype.getSiteSharedFilesDirPath = function (siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        return this.fileProvider.getSiteFolder(siteId) + '/' + CoreSharedFilesProvider_1.SHARED_FILES_FOLDER;
    };
    /**
     * Check if a file has been treated already.
     *
     * @param {string} fileId File ID.
     * @return {Promise<any>} Resolved if treated, rejected otherwise.
     */
    CoreSharedFilesProvider.prototype.isFileTreated = function (fileId) {
        return this.appDB.getRecord(this.SHARED_FILES_TABLE, { id: fileId });
    };
    /**
     * Mark a file as treated.
     *
     * @param {string} fileId File ID.
     * @return {Promise<any>} Promise resolved when marked.
     */
    CoreSharedFilesProvider.prototype.markAsTreated = function (fileId) {
        var _this = this;
        // Check if it's already marked.
        return this.isFileTreated(fileId).catch(function () {
            // Doesn't exist, insert it.
            return _this.appDB.insertRecord(_this.SHARED_FILES_TABLE, { id: fileId });
        });
    };
    /**
     * Store a file in a site's shared folder.
     *
     * @param {any} entry File entry.
     * @param {string} [newName] Name of the new file. If not defined, use original file's name.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>}Promise resolved when done.
     */
    CoreSharedFilesProvider.prototype.storeFileInSite = function (entry, newName, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (!entry || !siteId) {
            return Promise.reject(null);
        }
        newName = newName || entry.name;
        var sharedFilesFolder = this.getSiteSharedFilesDirPath(siteId), newPath = this.textUtils.concatenatePaths(sharedFilesFolder, newName);
        // Create dir if it doesn't exist already.
        return this.fileProvider.createDir(sharedFilesFolder).then(function () {
            return _this.fileProvider.moveFile(entry.fullPath, newPath).then(function (newFile) {
                _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */].FILE_SHARED, { siteId: siteId, name: newName });
                return newFile;
            });
        });
    };
    /**
     * Unmark a file as treated.
     *
     * @param {string} fileId File ID.
     * @return {Promise<any>} Resolved when unmarked.
     */
    CoreSharedFilesProvider.prototype.unmarkAsTreated = function (fileId) {
        return this.appDB.deleteRecords(this.SHARED_FILES_TABLE, { id: fileId });
    };
    CoreSharedFilesProvider.SHARED_FILES_FOLDER = 'sharedfiles';
    CoreSharedFilesProvider = CoreSharedFilesProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_file__["a" /* CoreFileProvider */], __WEBPACK_IMPORTED_MODULE_1__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_7__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_utils_mimetype__["a" /* CoreMimetypeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_5__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */]])
    ], CoreSharedFilesProvider);
    return CoreSharedFilesProvider;
    var CoreSharedFilesProvider_1;
}());

//# sourceMappingURL=sharedfiles.js.map

/***/ }),
/* 297 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSharedFilesHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_file__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_init__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__sharedfiles__ = __webpack_require__(296);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__core_fileuploader_providers_fileuploader__ = __webpack_require__(162);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};












/**
 * Helper service to share files with the app.
 */
var CoreSharedFilesHelperProvider = /** @class */ (function () {
    function CoreSharedFilesHelperProvider(logger, alertCtrl, translate, utils, sitesProvider, modalCtrl, fileUploaderProvider, initDelegate, sharedFilesProvider, domUtils, fileProvider, appProvider) {
        this.alertCtrl = alertCtrl;
        this.translate = translate;
        this.utils = utils;
        this.sitesProvider = sitesProvider;
        this.modalCtrl = modalCtrl;
        this.fileUploaderProvider = fileUploaderProvider;
        this.initDelegate = initDelegate;
        this.sharedFilesProvider = sharedFilesProvider;
        this.domUtils = domUtils;
        this.fileProvider = fileProvider;
        this.appProvider = appProvider;
        this.logger = logger.getInstance('CoreSharedFilesHelperProvider');
    }
    /**
     * Ask a user if he wants to replace a file (using originalName) or rename it (using newName).
     *
     * @param {string} originalName Original name.
     * @param {string} newName New name.
     * @return {Promise<string>} Promise resolved with the name to use when the user chooses. Rejected if user cancels.
     */
    CoreSharedFilesHelperProvider.prototype.askRenameReplace = function (originalName, newName) {
        var deferred = this.utils.promiseDefer(), alert = this.alertCtrl.create({
            title: this.translate.instant('core.sharedfiles.sharedfiles'),
            message: this.translate.instant('core.sharedfiles.chooseactionrepeatedfile', { $a: newName }),
            buttons: [
                {
                    text: this.translate.instant('core.sharedfiles.rename'),
                    handler: function () {
                        deferred.resolve(newName);
                    }
                },
                {
                    text: this.translate.instant('core.sharedfiles.replace'),
                    handler: function () {
                        deferred.resolve(originalName);
                    }
                }
            ]
        });
        alert.present();
        return deferred.promise;
    };
    /**
     * Go to the choose site view.
     *
     * @param {string} filePath File path to send to the view.
     */
    CoreSharedFilesHelperProvider.prototype.goToChooseSite = function (filePath) {
        var navCtrl = this.appProvider.getRootNavController();
        navCtrl.push('CoreSharedFilesChooseSitePage', { filePath: filePath });
    };
    /**
     * Open the view to select a shared file.
     *
     * @param  {string[]} [mimetypes] List of supported mimetypes. If undefined, all mimetypes supported.
     * @return {Promise<any>} Promise resolved when a file is picked, rejected if file picker is closed without selecting a file.
     */
    CoreSharedFilesHelperProvider.prototype.pickSharedFile = function (mimetypes) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var modal = _this.modalCtrl.create('CoreSharedFilesListPage', { mimetypes: mimetypes, isModal: true, pick: true });
            modal.present();
            modal.onDidDismiss(function (file) {
                if (!file) {
                    // User cancelled.
                    reject();
                    return;
                }
                var error = _this.fileUploaderProvider.isInvalidMimetype(mimetypes, file.fullPath);
                if (error) {
                    reject(error);
                }
                else {
                    resolve({
                        path: file.fullPath,
                        treated: false
                    });
                }
            });
        });
    };
    /**
     * Checks if there is a new file received in iOS and move it to the shared folder of current site.
     * If more than one site is found, the user will have to choose the site where to store it in.
     * If more than one file is found, treat only the first one.
     *
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreSharedFilesHelperProvider.prototype.searchIOSNewSharedFiles = function () {
        var _this = this;
        return this.initDelegate.ready().then(function () {
            var navCtrl = _this.appProvider.getRootNavController();
            if (navCtrl && navCtrl.getActive().id == 'CoreSharedFilesChooseSite') {
                // We're already treating a shared file. Abort.
                return Promise.reject(null);
            }
            return _this.sharedFilesProvider.checkIOSNewFiles().then(function (fileEntry) {
                return _this.sitesProvider.getSitesIds().then(function (siteIds) {
                    if (!siteIds.length) {
                        // No sites stored, show error and delete the file.
                        _this.domUtils.showErrorModal('core.sharedfiles.errorreceivefilenosites', true);
                        return _this.sharedFilesProvider.deleteInboxFile(fileEntry);
                    }
                    else if (siteIds.length == 1) {
                        return _this.storeSharedFileInSite(fileEntry, siteIds[0]);
                    }
                    else {
                        _this.goToChooseSite(fileEntry.fullPath);
                    }
                });
            });
        });
    };
    /**
     * Store a shared file in a site's shared files folder.
     *
     * @param {any} fileEntry Shared file entry.
     * @param {string} [siteId]  Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreSharedFilesHelperProvider.prototype.storeSharedFileInSite = function (fileEntry, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // First of all check if there's already a file with the same name in the shared files folder.
        var sharedFilesDirPath = this.sharedFilesProvider.getSiteSharedFilesDirPath(siteId);
        return this.fileProvider.getUniqueNameInFolder(sharedFilesDirPath, fileEntry.name).then(function (newName) {
            if (newName == fileEntry.name) {
                // No file with the same name. Use the original file name.
                return newName;
            }
            else {
                // Repeated name. Ask the user what he wants to do.
                return _this.askRenameReplace(fileEntry.name, newName);
            }
        }).then(function (name) {
            return _this.sharedFilesProvider.storeFileInSite(fileEntry, name, siteId).catch(function (err) {
                _this.domUtils.showErrorModal(err || 'Error moving file.');
            }).finally(function () {
                _this.sharedFilesProvider.deleteInboxFile(fileEntry);
                _this.domUtils.showAlertTranslated('core.success', 'core.sharedfiles.successstorefile');
            });
        });
    };
    CoreSharedFilesHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["b" /* AlertController */], __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_9__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_7__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["j" /* ModalController */],
            __WEBPACK_IMPORTED_MODULE_11__core_fileuploader_providers_fileuploader__["a" /* CoreFileUploaderProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_init__["a" /* CoreInitDelegate */],
            __WEBPACK_IMPORTED_MODULE_10__sharedfiles__["a" /* CoreSharedFilesProvider */], __WEBPACK_IMPORTED_MODULE_8__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_file__["a" /* CoreFileProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_app__["a" /* CoreAppProvider */]])
    ], CoreSharedFilesHelperProvider);
    return CoreSharedFilesHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),
/* 298 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSettingsDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__classes_delegate__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_events__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__ = __webpack_require__(9);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






/**
 * Service to interact with addons to be shown in app settings. Provides functions to register a plugin
 * and notify an update in the data.
 */
var CoreSettingsDelegate = /** @class */ (function (_super) {
    __extends(CoreSettingsDelegate, _super);
    function CoreSettingsDelegate(loggerProvider, sitesProvider, eventsProvider, utils) {
        var _this = _super.call(this, 'CoreSettingsDelegate', loggerProvider, sitesProvider, eventsProvider) || this;
        _this.loggerProvider = loggerProvider;
        _this.sitesProvider = sitesProvider;
        _this.eventsProvider = eventsProvider;
        _this.utils = utils;
        _this.handlers = {};
        _this.enabledHandlers = {};
        _this.siteHandlers = []; // Handlers to return.
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */].LOGOUT, _this.clearSiteHandlers.bind(_this));
        return _this;
    }
    /**
     * Clear current site handlers. Reserved for core use.
     */
    CoreSettingsDelegate.prototype.clearSiteHandlers = function () {
        this.siteHandlers = [];
    };
    /**
     * Get the handlers for the current site.
     *
     * @return {CoreSettingsHandlerData[]}
     */
    CoreSettingsDelegate.prototype.getHandlers = function () {
        return this.siteHandlers;
    };
    /**
     * Update handlers Data.
     */
    CoreSettingsDelegate.prototype.updateData = function () {
        var handlersData = [];
        for (var name_1 in this.enabledHandlers) {
            var handler = this.enabledHandlers[name_1], data = handler.getDisplayData();
            handlersData.push({
                data: data,
                priority: handler.priority
            });
        }
        // Sort them by priority.
        handlersData.sort(function (a, b) {
            return b.priority - a.priority;
        });
        // Return only the display data.
        this.siteHandlers = handlersData.map(function (item) {
            return item.data;
        });
    };
    CoreSettingsDelegate = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], CoreSettingsDelegate);
    return CoreSettingsDelegate;
}(__WEBPACK_IMPORTED_MODULE_1__classes_delegate__["a" /* CoreDelegate */]));

//# sourceMappingURL=delegate.js.map

/***/ }),
/* 299 */,
/* 300 */,
/* 301 */,
/* 302 */,
/* 303 */,
/* 304 */,
/* 305 */,
/* 306 */,
/* 307 */,
/* 308 */,
/* 309 */,
/* 310 */,
/* 311 */
/***/ (function(module, exports) {

function webpackEmptyAsyncContext(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncatched exception popping up in devtools
	return Promise.resolve().then(function() {
		throw new Error("Cannot find module '" + req + "'.");
	});
}
webpackEmptyAsyncContext.keys = function() { return []; };
webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;
module.exports = webpackEmptyAsyncContext;
webpackEmptyAsyncContext.id = 311;

/***/ }),
/* 312 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export createTranslateLoader */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return CORE_PROVIDERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AppModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_platform_browser__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_platform_browser_animations__ = __webpack_require__(735);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__angular_http__ = __webpack_require__(105);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__angular_common_http__ = __webpack_require__(104);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ngx_translate_http_loader__ = __webpack_require__(1214);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__app_component__ = __webpack_require__(1216);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__classes_interceptor__ = __webpack_require__(582);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_db__ = __webpack_require__(227);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_config__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_lang__ = __webpack_require__(96);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_utils_text__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_utils_time__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__providers_utils_url__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__providers_utils_mimetype__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__providers_init__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__providers_file__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__providers_ws__ = __webpack_require__(137);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__providers_events__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__providers_sites_factory__ = __webpack_require__(581);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__providers_local_notifications__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__providers_groups__ = __webpack_require__(589);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__providers_cron__ = __webpack_require__(696);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__providers_file_session__ = __webpack_require__(1217);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__providers_filepool__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__providers_update_manager__ = __webpack_require__(1218);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_33__providers_plugin_file_delegate__ = __webpack_require__(129);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_34__providers_sync__ = __webpack_require__(592);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_35__providers_file_helper__ = __webpack_require__(160);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_36__components_components_module__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_37__core_emulator_emulator_module__ = __webpack_require__(618);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_38__core_login_login_module__ = __webpack_require__(613);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_39__core_mainmenu_mainmenu_module__ = __webpack_require__(614);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_40__core_courses_courses_module__ = __webpack_require__(610);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_41__core_fileuploader_fileuploader_module__ = __webpack_require__(611);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_42__core_sharedfiles_sharedfiles_module__ = __webpack_require__(615);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_43__core_course_course_module__ = __webpack_require__(608);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_44__core_sitehome_sitehome_module__ = __webpack_require__(616);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_45__core_contentlinks_contentlinks_module__ = __webpack_require__(607);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_46__core_user_user_module__ = __webpack_require__(617);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_47__core_grades_grades_module__ = __webpack_require__(612);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_48__core_settings_settings_module__ = __webpack_require__(1219);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_49__core_siteplugins_siteplugins_module__ = __webpack_require__(1220);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_50__core_compile_compile_module__ = __webpack_require__(1229);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_51__addon_badges_badges_module__ = __webpack_require__(1230);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_52__addon_calendar_calendar_module__ = __webpack_require__(1234);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_53__addon_competency_competency_module__ = __webpack_require__(1236);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_54__addon_userprofilefield_userprofilefield_module__ = __webpack_require__(1240);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_55__addon_files_files_module__ = __webpack_require__(1251);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_56__addon_mod_book_book_module__ = __webpack_require__(1253);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_57__addon_mod_label_label_module__ = __webpack_require__(1256);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_58__addon_mod_resource_resource_module__ = __webpack_require__(1259);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_59__addon_mod_folder_folder_module__ = __webpack_require__(1263);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_60__addon_mod_page_page_module__ = __webpack_require__(1268);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_61__addon_mod_url_url_module__ = __webpack_require__(1272);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_62__addon_messages_messages_module__ = __webpack_require__(1275);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_63__addon_pushnotifications_pushnotifications_module__ = __webpack_require__(1282);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_64__addon_remotethemes_remotethemes_module__ = __webpack_require__(1283);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




































// Core modules.















// Addon modules.














// For translate loader. AoT requires an exported function for factories.
function createTranslateLoader(http) {
    return new __WEBPACK_IMPORTED_MODULE_7__ngx_translate_http_loader__["a" /* TranslateHttpLoader */](http, './assets/lang/', '.json');
}
// List of providers.
var CORE_PROVIDERS = [
    __WEBPACK_IMPORTED_MODULE_10__providers_logger__["a" /* CoreLoggerProvider */],
    __WEBPACK_IMPORTED_MODULE_11__providers_db__["a" /* CoreDbProvider */],
    __WEBPACK_IMPORTED_MODULE_12__providers_app__["a" /* CoreAppProvider */],
    __WEBPACK_IMPORTED_MODULE_13__providers_config__["a" /* CoreConfigProvider */],
    __WEBPACK_IMPORTED_MODULE_14__providers_lang__["a" /* CoreLangProvider */],
    __WEBPACK_IMPORTED_MODULE_15__providers_utils_text__["a" /* CoreTextUtilsProvider */],
    __WEBPACK_IMPORTED_MODULE_16__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
    __WEBPACK_IMPORTED_MODULE_17__providers_utils_time__["a" /* CoreTimeUtilsProvider */],
    __WEBPACK_IMPORTED_MODULE_18__providers_utils_url__["a" /* CoreUrlUtilsProvider */],
    __WEBPACK_IMPORTED_MODULE_19__providers_utils_utils__["a" /* CoreUtilsProvider */],
    __WEBPACK_IMPORTED_MODULE_20__providers_utils_mimetype__["a" /* CoreMimetypeUtilsProvider */],
    __WEBPACK_IMPORTED_MODULE_21__providers_init__["a" /* CoreInitDelegate */],
    __WEBPACK_IMPORTED_MODULE_22__providers_file__["a" /* CoreFileProvider */],
    __WEBPACK_IMPORTED_MODULE_23__providers_ws__["a" /* CoreWSProvider */],
    __WEBPACK_IMPORTED_MODULE_24__providers_events__["a" /* CoreEventsProvider */],
    __WEBPACK_IMPORTED_MODULE_25__providers_sites_factory__["a" /* CoreSitesFactoryProvider */],
    __WEBPACK_IMPORTED_MODULE_26__providers_sites__["a" /* CoreSitesProvider */],
    __WEBPACK_IMPORTED_MODULE_27__providers_local_notifications__["a" /* CoreLocalNotificationsProvider */],
    __WEBPACK_IMPORTED_MODULE_28__providers_groups__["a" /* CoreGroupsProvider */],
    __WEBPACK_IMPORTED_MODULE_29__providers_cron__["a" /* CoreCronDelegate */],
    __WEBPACK_IMPORTED_MODULE_30__providers_file_session__["a" /* CoreFileSessionProvider */],
    __WEBPACK_IMPORTED_MODULE_31__providers_filepool__["a" /* CoreFilepoolProvider */],
    __WEBPACK_IMPORTED_MODULE_32__providers_update_manager__["a" /* CoreUpdateManagerProvider */],
    __WEBPACK_IMPORTED_MODULE_33__providers_plugin_file_delegate__["a" /* CorePluginFileDelegate */],
    __WEBPACK_IMPORTED_MODULE_34__providers_sync__["a" /* CoreSyncProvider */],
    __WEBPACK_IMPORTED_MODULE_35__providers_file_helper__["a" /* CoreFileHelperProvider */]
];
var AppModule = /** @class */ (function () {
    function AppModule(platform, initDelegate, updateManager, sitesProvider) {
        // Register a handler for platform ready.
        initDelegate.registerProcess({
            name: 'CorePlatformReady',
            priority: __WEBPACK_IMPORTED_MODULE_21__providers_init__["a" /* CoreInitDelegate */].MAX_RECOMMENDED_PRIORITY + 400,
            blocking: true,
            load: platform.ready
        });
        // Register the update manager as an init process.
        initDelegate.registerProcess(updateManager);
        // Restore the user's session during the init process.
        initDelegate.registerProcess({
            name: 'CoreRestoreSession',
            priority: __WEBPACK_IMPORTED_MODULE_21__providers_init__["a" /* CoreInitDelegate */].MAX_RECOMMENDED_PRIORITY + 200,
            blocking: false,
            load: sitesProvider.restoreSession.bind(sitesProvider)
        });
        // Execute the init processes.
        initDelegate.executeInitProcesses();
    }
    AppModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_2__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_8__app_component__["a" /* MoodleMobileApp */]
            ],
            imports: [
                __WEBPACK_IMPORTED_MODULE_0__angular_platform_browser__["a" /* BrowserModule */],
                __WEBPACK_IMPORTED_MODULE_1__angular_platform_browser_animations__["a" /* BrowserAnimationsModule */],
                __WEBPACK_IMPORTED_MODULE_5__angular_common_http__["c" /* HttpClientModule */],
                __WEBPACK_IMPORTED_MODULE_4__angular_http__["b" /* HttpModule */],
                __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["g" /* IonicModule */].forRoot(__WEBPACK_IMPORTED_MODULE_8__app_component__["a" /* MoodleMobileApp */], {
                    pageTransition: 'ios-transition'
                }, {
                    links: [
                        { loadChildren: '../addon/badges/pages/issued-badge/issued-badge.module#AddonBadgesIssuedBadgePageModule', name: 'AddonBadgesIssuedBadgePage', segment: 'addon-badges-issued-badge', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../addon/badges/pages/user-badges/user-badges.module#AddonBadgesUserBadgesPageModule', name: 'AddonBadgesUserBadgesPage', segment: 'addon-badges-user-badges', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../addon/calendar/pages/list/list.module#AddonCalendarListPageModule', name: 'AddonCalendarListPage', segment: 'addon-calendar-list', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../addon/calendar/pages/event/event.module#AddonCalendarEventPageModule', name: 'AddonCalendarEventPage', segment: 'addon-calendar-event', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../addon/calendar/pages/settings/settings.module#AddonCalendarSettingsPageModule', name: 'AddonCalendarSettingsPage', segment: 'addon-calendar-settings', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../addon/competency/pages/competency/competency.module#AddonCompetencyCompetencyPageModule', name: 'AddonCompetencyCompetencyPage', segment: 'addon-competency-competency', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../addon/competency/pages/coursecompetencies/coursecompetencies.module#AddonCompetencyCourseCompetenciesPageModule', name: 'AddonCompetencyCourseCompetenciesPage', segment: 'addon-competency-coursecompetencies', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../addon/competency/pages/competencies/competencies.module#AddonCompetencyCompetenciesPageModule', name: 'AddonCompetencyCompetenciesPage', segment: 'addon-competency-competencies', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../addon/competency/pages/planlist/planlist.module#AddonCompetencyPlanListPageModule', name: 'AddonCompetencyPlanListPage', segment: 'addon-competency-planlist', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../addon/competency/pages/competencysummary/competencysummary.module#AddonCompetencyCompetencySummaryPageModule', name: 'AddonCompetencyCompetencySummaryPage', segment: 'addon-competency-competency-summary', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../addon/competency/pages/plan/plan.module#AddonCompetencyPlanPageModule', name: 'AddonCompetencyPlanPage', segment: 'addon-competency-plan', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../addon/files/pages/list/list.module#AddonFilesListPageModule', name: 'AddonFilesListPage', segment: 'addon-files-list', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../addon/messages/pages/index/index.module#AddonMessagesIndexPageModule', name: 'AddonMessagesIndexPage', segment: 'addon-messages-index', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../addon/messages/pages/settings/settings.module#AddonMessagesSettingsPageModule', name: 'AddonMessagesSettingsPage', segment: 'addon-messages-settings', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../addon/messages/pages/discussion/discussion.module#AddonMessagesDiscussionPageModule', name: 'AddonMessagesDiscussionPage', segment: 'addon-messages-discussion', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../addon/mod/book/pages/index/index.module#AddonModBookIndexPageModule', name: 'AddonModBookIndexPage', segment: 'addon-mod-book-index', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../addon/mod/folder/pages/index/index.module#AddonModFolderIndexPageModule', name: 'AddonModFolderIndexPage', segment: 'addon-mod-folder-index', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../addon/mod/page/pages/index/index.module#AddonModPageIndexPageModule', name: 'AddonModPageIndexPage', segment: 'addon-mod-page-index', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../addon/mod/resource/pages/index/index.module#AddonModResourceIndexPageModule', name: 'AddonModResourceIndexPage', segment: 'addon-mod-resource-index', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../addon/mod/url/pages/index/index.module#AddonModUrlIndexPageModule', name: 'AddonModUrlIndexPage', segment: 'addon-mod-url-index', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../components/split-view/placeholder/placeholder.module#CorePlaceholderPageModule', name: 'CoreSplitViewPlaceholderPage', segment: 'core-placeholder', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/contentlinks/pages/choose-site/choose-site.module#CoreContentLinksChooseSitePageModule', name: 'CoreContentLinksChooseSitePage', segment: 'core-content-links-choose-site', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/course/pages/unsupported-module/unsupported-module.module#CoreCourseUnsupportedModulePageModule', name: 'CoreCourseUnsupportedModulePage', segment: 'core-course-unsupported-module', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/course/pages/section/section.module#CoreCourseSectionPageModule', name: 'CoreCourseSectionPage', segment: 'core-course-section', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/courses/pages/available-courses/available-courses.module#CoreCoursesAvailableCoursesPageModule', name: 'CoreCoursesAvailableCoursesPage', segment: 'core-courses-available-courses', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/courses/pages/categories/categories.module#CoreCoursesCategoriesPageModule', name: 'CoreCoursesCategoriesPage', segment: 'core-courses-categories', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/courses/pages/my-courses/my-courses.module#CoreCoursesMyCoursesPageModule', name: 'CoreCoursesMyCoursesPage', segment: 'core-courses-my-courses', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/courses/pages/search/search.module#CoreCoursesSearchPageModule', name: 'CoreCoursesSearchPage', segment: 'core-courses-search', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/courses/pages/course-preview/course-preview.module#CoreCoursesCoursePreviewPageModule', name: 'CoreCoursesCoursePreviewPage', segment: 'core-courses-course-preview', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/courses/pages/self-enrol-password/self-enrol-password.module#CoreCoursesSelfEnrolPasswordPageModule', name: 'CoreCoursesSelfEnrolPasswordPage', segment: 'core-courses-self-enrol-password', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/courses/pages/my-overview/my-overview.module#CoreCoursesMyOverviewPageModule', name: 'CoreCoursesMyOverviewPage', segment: 'core-courses-my-overview', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/emulator/pages/capture-media/capture-media.module#CoreEmulatorCaptureMediaPageModule', name: 'CoreEmulatorCaptureMediaPage', segment: 'core-emulator-capture-media', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/grades/pages/courses/courses.module#CoreGradesCoursesPageModule', name: 'CoreGradesCoursesPage', segment: 'core-grades-courses', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/grades/pages/coursesplit/coursesplit.module#CoreGradesCourseSplitPageModule', name: 'CoreGradesCourseSplitPage', segment: 'core-grades-course-split', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/grades/pages/grade/grade.module#CoreGradesGradePageModule', name: 'CoreGradesGradePage', segment: 'core-grades-grade', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/grades/pages/course/course.module#CoreGradesCoursePageModule', name: 'CoreGradesCoursePage', segment: 'core-grades-course', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/login/pages/email-signup/email-signup.module#CoreLoginCredentialsPageModule', name: 'CoreLoginEmailSignupPage', segment: 'core-login-email-signup', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/login/pages/credentials/credentials.module#CoreLoginCredentialsPageModule', name: 'CoreLoginCredentialsPage', segment: 'core-login-credentials', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/login/pages/init/init.module#CoreLoginInitPageModule', name: 'CoreLoginInitPage', segment: 'core-login-init', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/login/pages/reconnect/reconnect.module#CoreLoginReconnectPageModule', name: 'CoreLoginReconnectPage', segment: 'core-login-reconnect', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/login/pages/site-error/site-error.module#CoreLoginSiteErrorPageModule', name: 'CoreLoginSiteErrorPage', segment: 'core-login-site-error', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/login/pages/site-policy/site-policy.module#CoreLoginSitePolicyPageModule', name: 'CoreLoginSitePolicyPage', segment: 'core-login-site-policy', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/login/pages/sites/sites.module#CoreLoginSitesPageModule', name: 'CoreLoginSitesPage', segment: 'core-login-sites', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/login/pages/forgotten-password/forgotten-password.module#CoreLoginForgottenPasswordPageModule', name: 'CoreLoginForgottenPasswordPage', segment: 'core-login-forgotten-password', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/login/pages/site/site.module#CoreLoginSitePageModule', name: 'CoreLoginSitePage', segment: 'core-login-site', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/login/pages/site-help/site-help.module#CoreLoginSiteHelpPageModule', name: 'CoreLoginSiteHelpPage', segment: 'core-login-site-help', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/mainmenu/pages/menu/menu.module#CoreMainMenuPageModule', name: 'CoreMainMenuPage', segment: 'core-mainmenu', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/mainmenu/pages/more/more.module#CoreMainMenuPageModule', name: 'CoreMainMenuMorePage', segment: 'core-mainmenu-more', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/sharedfiles/pages/list/list.module#CoreSharedFilesListPageModule', name: 'CoreSharedFilesListPage', segment: 'core-shared-files-list', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/sharedfiles/pages/choose-site/choose-site.module#CoreSharedFilesChooseSitePageModule', name: 'CoreSharedFilesChooseSitePage', segment: 'core-shared-files-choose-site', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/settings/pages/list/list.module#CoreSettingsListPageModule', name: 'CoreSettingsListPage', segment: 'core-settings-list', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/sitehome/pages/index/index.module#CoreSiteHomeIndexPageModule', name: 'CoreSiteHomeIndexPage', segment: 'core-sitehome-index', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/siteplugins/pages/module-index/module-index.module#CoreSitePluginsModuleIndexPageModule', name: 'CoreSitePluginsModuleIndexPage', segment: 'core-site-plugins-module-index-page', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/siteplugins/pages/plugin-page/plugin-page.module#CoreSitePluginsPluginPageModule', name: 'CoreSitePluginsPluginPage', segment: 'core-site-plugins-plugin-page', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/user/pages/participants/participants.module#CoreUserParticipantsPageModule', name: 'CoreUserParticipantsPage', segment: 'core-user-participants', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/user/pages/about/about.module#CoreUserAboutPageModule', name: 'CoreUserAboutPage', segment: 'core-user-about', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/user/pages/profile/profile.module#CoreUserProfilePageModule', name: 'CoreUserProfilePage', segment: 'core-user-profile', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/viewer/pages/text/text.module#CoreViewerTextPageModule', name: 'CoreViewerTextPage', segment: 'core-viewer-text', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/viewer/pages/iframe/iframe.module#CoreViewerIframePageModule', name: 'CoreViewerIframePage', segment: 'core-viewer-iframe', priority: 'low', defaultHistory: [] },
                        { loadChildren: '../core/viewer/pages/image/image.module#CoreViewerImagePageModule', name: 'CoreViewerImagePage', segment: 'core-viewer-image', priority: 'low', defaultHistory: [] }
                    ]
                }),
                __WEBPACK_IMPORTED_MODULE_6__ngx_translate_core__["b" /* TranslateModule */].forRoot({
                    loader: {
                        provide: __WEBPACK_IMPORTED_MODULE_6__ngx_translate_core__["a" /* TranslateLoader */],
                        useFactory: (createTranslateLoader),
                        deps: [__WEBPACK_IMPORTED_MODULE_5__angular_common_http__["b" /* HttpClient */]]
                    }
                }),
                __WEBPACK_IMPORTED_MODULE_36__components_components_module__["a" /* CoreComponentsModule */],
                __WEBPACK_IMPORTED_MODULE_37__core_emulator_emulator_module__["a" /* CoreEmulatorModule */],
                __WEBPACK_IMPORTED_MODULE_38__core_login_login_module__["b" /* CoreLoginModule */],
                __WEBPACK_IMPORTED_MODULE_39__core_mainmenu_mainmenu_module__["b" /* CoreMainMenuModule */],
                __WEBPACK_IMPORTED_MODULE_40__core_courses_courses_module__["b" /* CoreCoursesModule */],
                __WEBPACK_IMPORTED_MODULE_41__core_fileuploader_fileuploader_module__["b" /* CoreFileUploaderModule */],
                __WEBPACK_IMPORTED_MODULE_42__core_sharedfiles_sharedfiles_module__["b" /* CoreSharedFilesModule */],
                __WEBPACK_IMPORTED_MODULE_43__core_course_course_module__["b" /* CoreCourseModule */],
                __WEBPACK_IMPORTED_MODULE_44__core_sitehome_sitehome_module__["b" /* CoreSiteHomeModule */],
                __WEBPACK_IMPORTED_MODULE_45__core_contentlinks_contentlinks_module__["b" /* CoreContentLinksModule */],
                __WEBPACK_IMPORTED_MODULE_46__core_user_user_module__["b" /* CoreUserModule */],
                __WEBPACK_IMPORTED_MODULE_47__core_grades_grades_module__["b" /* CoreGradesModule */],
                __WEBPACK_IMPORTED_MODULE_48__core_settings_settings_module__["a" /* CoreSettingsModule */],
                __WEBPACK_IMPORTED_MODULE_49__core_siteplugins_siteplugins_module__["a" /* CoreSitePluginsModule */],
                __WEBPACK_IMPORTED_MODULE_50__core_compile_compile_module__["a" /* CoreCompileModule */],
                __WEBPACK_IMPORTED_MODULE_51__addon_badges_badges_module__["a" /* AddonBadgesModule */],
                __WEBPACK_IMPORTED_MODULE_52__addon_calendar_calendar_module__["a" /* AddonCalendarModule */],
                __WEBPACK_IMPORTED_MODULE_53__addon_competency_competency_module__["a" /* AddonCompetencyModule */],
                __WEBPACK_IMPORTED_MODULE_54__addon_userprofilefield_userprofilefield_module__["a" /* AddonUserProfileFieldModule */],
                __WEBPACK_IMPORTED_MODULE_55__addon_files_files_module__["a" /* AddonFilesModule */],
                __WEBPACK_IMPORTED_MODULE_56__addon_mod_book_book_module__["a" /* AddonModBookModule */],
                __WEBPACK_IMPORTED_MODULE_57__addon_mod_label_label_module__["a" /* AddonModLabelModule */],
                __WEBPACK_IMPORTED_MODULE_58__addon_mod_resource_resource_module__["a" /* AddonModResourceModule */],
                __WEBPACK_IMPORTED_MODULE_59__addon_mod_folder_folder_module__["a" /* AddonModFolderModule */],
                __WEBPACK_IMPORTED_MODULE_60__addon_mod_page_page_module__["a" /* AddonModPageModule */],
                __WEBPACK_IMPORTED_MODULE_61__addon_mod_url_url_module__["a" /* AddonModUrlModule */],
                __WEBPACK_IMPORTED_MODULE_62__addon_messages_messages_module__["a" /* AddonMessagesModule */],
                __WEBPACK_IMPORTED_MODULE_63__addon_pushnotifications_pushnotifications_module__["a" /* AddonPushNotificationsModule */],
                __WEBPACK_IMPORTED_MODULE_64__addon_remotethemes_remotethemes_module__["a" /* AddonRemoteThemesModule */]
            ],
            bootstrap: [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* IonicApp */]],
            entryComponents: [
                __WEBPACK_IMPORTED_MODULE_8__app_component__["a" /* MoodleMobileApp */]
            ],
            providers: CORE_PROVIDERS.concat([
                {
                    provide: __WEBPACK_IMPORTED_MODULE_5__angular_common_http__["a" /* HTTP_INTERCEPTORS */],
                    useClass: __WEBPACK_IMPORTED_MODULE_9__classes_interceptor__["a" /* CoreInterceptor */],
                    multi: true,
                }
            ])
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* Platform */], __WEBPACK_IMPORTED_MODULE_21__providers_init__["a" /* CoreInitDelegate */], __WEBPACK_IMPORTED_MODULE_32__providers_update_manager__["a" /* CoreUpdateManagerProvider */],
            __WEBPACK_IMPORTED_MODULE_26__providers_sites__["a" /* CoreSitesProvider */]])
    ], AppModule);
    return AppModule;
}());

//# sourceMappingURL=app.module.js.map

/***/ }),
/* 313 */,
/* 314 */,
/* 315 */,
/* 316 */,
/* 317 */,
/* 318 */,
/* 319 */,
/* 320 */,
/* 321 */,
/* 322 */,
/* 323 */,
/* 324 */,
/* 325 */,
/* 326 */,
/* 327 */,
/* 328 */,
/* 329 */,
/* 330 */,
/* 331 */,
/* 332 */,
/* 333 */,
/* 334 */,
/* 335 */,
/* 336 */,
/* 337 */,
/* 338 */,
/* 339 */,
/* 340 */,
/* 341 */,
/* 342 */,
/* 343 */,
/* 344 */,
/* 345 */,
/* 346 */,
/* 347 */,
/* 348 */,
/* 349 */,
/* 350 */,
/* 351 */,
/* 352 */,
/* 353 */,
/* 354 */,
/* 355 */,
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"../addon/badges/pages/issued-badge/issued-badge.module": [
		1301,
		59
	],
	"../addon/badges/pages/user-badges/user-badges.module": [
		1302,
		58
	],
	"../addon/calendar/pages/event/event.module": [
		1304,
		57
	],
	"../addon/calendar/pages/list/list.module": [
		1303,
		56
	],
	"../addon/calendar/pages/settings/settings.module": [
		1305,
		55
	],
	"../addon/competency/pages/competencies/competencies.module": [
		1308,
		54
	],
	"../addon/competency/pages/competency/competency.module": [
		1306,
		53
	],
	"../addon/competency/pages/competencysummary/competencysummary.module": [
		1310,
		52
	],
	"../addon/competency/pages/coursecompetencies/coursecompetencies.module": [
		1307,
		51
	],
	"../addon/competency/pages/plan/plan.module": [
		1311,
		50
	],
	"../addon/competency/pages/planlist/planlist.module": [
		1309,
		49
	],
	"../addon/files/pages/list/list.module": [
		1312,
		48
	],
	"../addon/messages/pages/discussion/discussion.module": [
		1315,
		47
	],
	"../addon/messages/pages/index/index.module": [
		1313,
		1
	],
	"../addon/messages/pages/settings/settings.module": [
		1314,
		0
	],
	"../addon/mod/book/pages/index/index.module": [
		1316,
		46
	],
	"../addon/mod/folder/pages/index/index.module": [
		1317,
		45
	],
	"../addon/mod/page/pages/index/index.module": [
		1318,
		44
	],
	"../addon/mod/resource/pages/index/index.module": [
		1319,
		43
	],
	"../addon/mod/url/pages/index/index.module": [
		1320,
		42
	],
	"../components/split-view/placeholder/placeholder.module": [
		1321,
		41
	],
	"../core/contentlinks/pages/choose-site/choose-site.module": [
		1322,
		40
	],
	"../core/course/pages/section/section.module": [
		1324,
		39
	],
	"../core/course/pages/unsupported-module/unsupported-module.module": [
		1323,
		38
	],
	"../core/courses/pages/available-courses/available-courses.module": [
		1325,
		37
	],
	"../core/courses/pages/categories/categories.module": [
		1326,
		36
	],
	"../core/courses/pages/course-preview/course-preview.module": [
		1329,
		35
	],
	"../core/courses/pages/my-courses/my-courses.module": [
		1327,
		34
	],
	"../core/courses/pages/my-overview/my-overview.module": [
		1331,
		33
	],
	"../core/courses/pages/search/search.module": [
		1328,
		32
	],
	"../core/courses/pages/self-enrol-password/self-enrol-password.module": [
		1330,
		31
	],
	"../core/emulator/pages/capture-media/capture-media.module": [
		1332,
		30
	],
	"../core/grades/pages/course/course.module": [
		1336,
		29
	],
	"../core/grades/pages/courses/courses.module": [
		1333,
		28
	],
	"../core/grades/pages/coursesplit/coursesplit.module": [
		1334,
		27
	],
	"../core/grades/pages/grade/grade.module": [
		1335,
		26
	],
	"../core/login/pages/credentials/credentials.module": [
		1338,
		25
	],
	"../core/login/pages/email-signup/email-signup.module": [
		1337,
		24
	],
	"../core/login/pages/forgotten-password/forgotten-password.module": [
		1344,
		23
	],
	"../core/login/pages/init/init.module": [
		1339,
		22
	],
	"../core/login/pages/reconnect/reconnect.module": [
		1340,
		21
	],
	"../core/login/pages/site-error/site-error.module": [
		1341,
		20
	],
	"../core/login/pages/site-help/site-help.module": [
		1346,
		19
	],
	"../core/login/pages/site-policy/site-policy.module": [
		1342,
		18
	],
	"../core/login/pages/site/site.module": [
		1345,
		17
	],
	"../core/login/pages/sites/sites.module": [
		1343,
		16
	],
	"../core/mainmenu/pages/menu/menu.module": [
		1347,
		15
	],
	"../core/mainmenu/pages/more/more.module": [
		1348,
		14
	],
	"../core/settings/pages/list/list.module": [
		1351,
		13
	],
	"../core/sharedfiles/pages/choose-site/choose-site.module": [
		1350,
		12
	],
	"../core/sharedfiles/pages/list/list.module": [
		1349,
		11
	],
	"../core/sitehome/pages/index/index.module": [
		1352,
		10
	],
	"../core/siteplugins/pages/module-index/module-index.module": [
		1353,
		9
	],
	"../core/siteplugins/pages/plugin-page/plugin-page.module": [
		1354,
		8
	],
	"../core/user/pages/about/about.module": [
		1356,
		7
	],
	"../core/user/pages/participants/participants.module": [
		1355,
		6
	],
	"../core/user/pages/profile/profile.module": [
		1357,
		5
	],
	"../core/viewer/pages/iframe/iframe.module": [
		1359,
		4
	],
	"../core/viewer/pages/image/image.module": [
		1360,
		3
	],
	"../core/viewer/pages/text/text.module": [
		1358,
		2
	]
};
function webpackAsyncContext(req) {
	var ids = map[req];
	if(!ids)
		return Promise.reject(new Error("Cannot find module '" + req + "'."));
	return __webpack_require__.e(ids[1]).then(function() {
		return __webpack_require__(ids[0]);
	});
};
webpackAsyncContext.keys = function webpackAsyncContextKeys() {
	return Object.keys(map);
};
webpackAsyncContext.id = 356;
module.exports = webpackAsyncContext;

/***/ }),
/* 357 */,
/* 358 */,
/* 359 */,
/* 360 */,
/* 361 */,
/* 362 */,
/* 363 */,
/* 364 */,
/* 365 */,
/* 366 */,
/* 367 */,
/* 368 */,
/* 369 */,
/* 370 */,
/* 371 */,
/* 372 */,
/* 373 */,
/* 374 */,
/* 375 */,
/* 376 */,
/* 377 */,
/* 378 */,
/* 379 */,
/* 380 */,
/* 381 */,
/* 382 */,
/* 383 */,
/* 384 */,
/* 385 */,
/* 386 */,
/* 387 */,
/* 388 */,
/* 389 */,
/* 390 */,
/* 391 */,
/* 392 */,
/* 393 */,
/* 394 */,
/* 395 */,
/* 396 */,
/* 397 */,
/* 398 */,
/* 399 */,
/* 400 */,
/* 401 */,
/* 402 */,
/* 403 */,
/* 404 */,
/* 405 */,
/* 406 */,
/* 407 */,
/* 408 */,
/* 409 */,
/* 410 */,
/* 411 */,
/* 412 */,
/* 413 */,
/* 414 */,
/* 415 */,
/* 416 */,
/* 417 */,
/* 418 */,
/* 419 */,
/* 420 */,
/* 421 */,
/* 422 */,
/* 423 */,
/* 424 */,
/* 425 */,
/* 426 */,
/* 427 */,
/* 428 */,
/* 429 */,
/* 430 */,
/* 431 */,
/* 432 */,
/* 433 */,
/* 434 */,
/* 435 */,
/* 436 */,
/* 437 */,
/* 438 */,
/* 439 */,
/* 440 */,
/* 441 */,
/* 442 */,
/* 443 */,
/* 444 */,
/* 445 */,
/* 446 */,
/* 447 */,
/* 448 */,
/* 449 */,
/* 450 */,
/* 451 */,
/* 452 */,
/* 453 */,
/* 454 */,
/* 455 */,
/* 456 */,
/* 457 */,
/* 458 */,
/* 459 */,
/* 460 */,
/* 461 */,
/* 462 */,
/* 463 */,
/* 464 */,
/* 465 */,
/* 466 */,
/* 467 */,
/* 468 */,
/* 469 */,
/* 470 */,
/* 471 */,
/* 472 */,
/* 473 */,
/* 474 */,
/* 475 */,
/* 476 */,
/* 477 */,
/* 478 */,
/* 479 */,
/* 480 */,
/* 481 */,
/* 482 */,
/* 483 */,
/* 484 */,
/* 485 */,
/* 486 */,
/* 487 */,
/* 488 */,
/* 489 */,
/* 490 */,
/* 491 */,
/* 492 */,
/* 493 */,
/* 494 */,
/* 495 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SQLiteDB; });
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * Class to interact with the local database.
 *
 * @description
 * This class allows creating and interacting with a SQLite database.
 *
 * You need to supply some dependencies when creating the instance:
 * this.db = new SQLiteDB('MyDB', sqlite, platform);
 */
var SQLiteDB = /** @class */ (function () {
    /**
     * Create and open the database.
     *
     * @param {string} name Database name.
     * @param {SQLite} sqlite SQLite library.
     * @param {Platform} platform Ionic platform.
     */
    function SQLiteDB(name, sqlite, platform) {
        this.name = name;
        this.sqlite = sqlite;
        this.platform = platform;
        this.init();
    }
    /**
     * Helper function to create a table if it doesn't exist.
     *
     * @param {string} name The table name.
     * @param {any[]} columns The columns to create in the table. Each column can have:
     *                    * {string} name  Column's name.
     *                    * {string} [type] Column's type.
     *                    * {boolean} [primaryKey] If column is primary key. Use it only if primary key is a single column.
     *                    * {boolean} [autoIncrement] Whether it should be autoincremented. Only if primaryKey is true.
     *                    * {boolean} [notNull] True if column shouldn't be null.
     *                    * {boolean} [unique] Whether the column is unique.
     *                    * {string} [check] Check constraint for the column.
     *                    * {string} [default] Default value for the column.
     * @param {string[]} [primaryKeys] Names of columns that are primary key. Use it for compound primary keys.
     * @param {string[][]} [uniqueKeys] List of sets of unique columns. E.g: [['section', 'title'], ['author', 'title']].
     * @param {any[]} [foreignKeys] List of foreign keys. Each key can have:
     *                    * {string[]} columns Columns to include in this foreign key.
     *                    * {string} table The external table referenced by this key.
     *                    * {string[]} [foreignColumns] List of referenced columns from the referenced table.
     *                    * {string} [actions] Text with the actions to apply to the foreign key.
     * @param {string} [tableCheck] Check constraint for the table.
     * @return SQL query.
     */
    SQLiteDB.prototype.buildCreateTableSql = function (name, columns, primaryKeys, uniqueKeys, foreignKeys, tableCheck) {
        var columnsSql = [];
        var sql = "CREATE TABLE IF NOT EXISTS " + name + " (";
        // First define all the columns.
        for (var index in columns) {
            var column = columns[index];
            var columnSql = column.name || '';
            if (column.type) {
                columnSql += ' ' + column.type;
            }
            if (column.primaryKey) {
                columnSql += ' PRIMARY KEY';
                if (column.autoIncrement) {
                    columnSql += ' AUTOINCREMENT';
                }
            }
            if (column.notNull) {
                columnSql += ' NOT NULL';
            }
            if (column.unique) {
                columnSql += ' UNIQUE';
            }
            if (column.check) {
                columnSql += " CHECK (" + column.check + ")";
            }
            if (typeof column.default != 'undefined') {
                columnSql += " DEFAULT " + column.default;
            }
            columnsSql.push(columnSql);
        }
        sql += columnsSql.join(', ');
        // Now add the table constraints.
        if (primaryKeys && primaryKeys.length) {
            sql += ", PRIMARY KEY (" + primaryKeys.join(', ') + ")";
        }
        if (uniqueKeys && uniqueKeys.length) {
            for (var index in uniqueKeys) {
                var setOfKeys = uniqueKeys[index];
                if (setOfKeys && setOfKeys.length) {
                    sql += ", UNIQUE (" + setOfKeys.join(', ') + ")";
                }
            }
        }
        if (tableCheck) {
            sql += ", CHECK (" + tableCheck + ")";
        }
        for (var index in foreignKeys) {
            var foreignKey = foreignKeys[index];
            if (!foreignKey.columns || !!foreignKey.columns.length) {
                return;
            }
            sql += ", FOREIGN KEY (" + foreignKey.columns.join(', ') + ") REFERENCES " + foreignKey.table + " ";
            if (foreignKey.foreignColumns && foreignKey.foreignColumns.length) {
                sql += "(" + foreignKey.foreignColumns.join(', ') + ")";
            }
            if (foreignKey.actions) {
                sql += " " + foreignKey.actions;
            }
        }
        return sql + ')';
    };
    /**
     * Close the database.
     *
     * @return {Promise<any>} Promise resolved when done.
     */
    SQLiteDB.prototype.close = function () {
        var _this = this;
        return this.ready().then(function () {
            return _this.db.close();
        });
    };
    /**
     * Count the records in a table where all the given conditions met.
     *
     * @param {string} table The table to query.
     * @param {object} [conditions] The conditions to build the where clause. Must not contain numeric indexes.
     * @return {Promise<number>} Promise resolved with the count of records returned from the specified criteria.
     */
    SQLiteDB.prototype.countRecords = function (table, conditions) {
        var selectAndParams = this.whereClause(conditions);
        return this.countRecordsSelect(table, selectAndParams[0], selectAndParams[1]);
    };
    /**
     * Count the records in a table which match a particular WHERE clause.
     *
     * @param {string} table The table to query.
     * @param {string} [select] A fragment of SQL to be used in a where clause in the SQL call.
     * @param {any} [params] An array of sql parameters.
     * @param {string} [countItem] The count string to be used in the SQL call. Default is COUNT('x').
     * @return {Promise<number>} Promise resolved with the count of records returned from the specified criteria.
     */
    SQLiteDB.prototype.countRecordsSelect = function (table, select, params, countItem) {
        if (select === void 0) { select = ''; }
        if (countItem === void 0) { countItem = 'COUNT(\'x\')'; }
        if (select) {
            select = 'WHERE ' + select;
        }
        return this.countRecordsSql("SELECT " + countItem + " FROM " + table + " " + select, params);
    };
    /**
     * Get the result of a SQL SELECT COUNT(...) query.
     *
     * Given a query that counts rows, return that count.
     *
     * @param {string} sql The SQL string you wish to be executed.
     * @param {any} [params] An array of sql parameters.
     * @return {Promise<number>} Promise resolved with the count.
     */
    SQLiteDB.prototype.countRecordsSql = function (sql, params) {
        return this.getFieldSql(sql, params).then(function (count) {
            if (typeof count != 'number' || count < 0) {
                return 0;
            }
            return count;
        });
    };
    /**
     * Create a table if it doesn't exist.
     *
     * @param {string} name The table name.
     * @param {any[]} columns The columns to create in the table. Each column can have:
     *                    * {string} name  Column's name.
     *                    * {string} [type] Column's type.
     *                    * {boolean} [primaryKey] If column is primary key. Use it only if primary key is a single column.
     *                    * {boolean} [autoIncrement] Whether it should be autoincremented. Only if primaryKey is true.
     *                    * {boolean} [notNull] True if column shouldn't be null.
     *                    * {boolean} [unique] Whether the column is unique.
     *                    * {string} [check] Check constraint for the column.
     *                    * {string} [default] Default value for the column.
     * @param {string[]} [primaryKeys] Names of columns that are primary key. Use it for compound primary keys.
     * @param {string[][]} [uniqueKeys] List of sets of unique columns. E.g: [['section', 'title'], ['author', 'title']].
     * @param {any[]} [foreignKeys] List of foreign keys. Each key can have:
     *                    * {string[]} columns Columns to include in this foreign key.
     *                    * {string} table The external table referenced by this key.
     *                    * {string[]} [foreignColumns] List of referenced columns from the referenced table.
     *                    * {string} [actions] Text with the actions to apply to the foreign key.
     * @param {string} [tableCheck] Check constraint for the table.
     * @return {Promise<any>} Promise resolved when success.
     */
    SQLiteDB.prototype.createTable = function (name, columns, primaryKeys, uniqueKeys, foreignKeys, tableCheck) {
        var sql = this.buildCreateTableSql(name, columns, primaryKeys, uniqueKeys, foreignKeys, tableCheck);
        return this.execute(sql);
    };
    /**
     * Create a table if it doesn't exist from a schema.
     *
     * @param {any} table Table schema.
     * @return {Promise<any>} Promise resolved when success.
     */
    SQLiteDB.prototype.createTableFromSchema = function (table) {
        return this.createTable(table.name, table.columns, table.primaryKeys, table.uniqueKeys, table.foreignKeys, table.tableCheck);
    };
    /**
     * Create several tables if they don't exist from a list of schemas.
     *
     * @param {any[]} tables List of table schema.
     * @return {Promise<any>} Promise resolved when success.
     */
    SQLiteDB.prototype.createTablesFromSchema = function (tables) {
        var _this = this;
        var promises = [];
        tables.forEach(function (table) {
            promises.push(_this.createTableFromSchema(table));
        });
        return Promise.all(promises);
    };
    /**
     * Delete the records from a table where all the given conditions met.
     * If conditions not specified, table is truncated.
     *
     * @param {string} table The table to delete from.
     * @param {object} [conditions] The conditions to build the where clause. Must not contain numeric indexes.
     * @return {Promise<any>} Promise resolved when done.
     */
    SQLiteDB.prototype.deleteRecords = function (table, conditions) {
        if (conditions === null || typeof conditions == 'undefined') {
            // No conditions, delete the whole table.
            return this.execute("DELETE FROM TABLE " + table);
        }
        var selectAndParams = this.whereClause(conditions);
        return this.deleteRecordsSelect(table, selectAndParams[0], selectAndParams[1]);
    };
    /**
     * Delete the records from a table where one field match one list of values.
     *
     * @param {string} table The table to delete from.
     * @param {string} field The name of a field.
     * @param {any[]} values The values field might take.
     * @return {Promise<any>} Promise resolved when done.
     */
    SQLiteDB.prototype.deleteRecordsList = function (table, field, values) {
        var selectAndParams = this.whereClauseList(field, values);
        return this.deleteRecordsSelect(table, selectAndParams[0], selectAndParams[1]);
    };
    /**
     * Delete one or more records from a table which match a particular WHERE clause.
     *
     * @param {string} table The table to delete from.
     * @param {string} [select] A fragment of SQL to be used in a where clause in the SQL call.
     * @param {any[]} [params] Array of sql parameters.
     * @return {Promise<any>} Promise resolved when done.
     */
    SQLiteDB.prototype.deleteRecordsSelect = function (table, select, params) {
        if (select === void 0) { select = ''; }
        if (select) {
            select = 'WHERE ' + select;
        }
        return this.execute("DELETE FROM " + table + " " + select, params);
    };
    /**
     * Execute a SQL query.
     * IMPORTANT: Use this function only if you cannot use any of the other functions in this API. Please take into account that
     * these query will be run in SQLite (Mobile) and Web SQL (desktop), so your query should work in both environments.
     *
     * @param {string} sql SQL query to execute.
     * @param {any[]} params Query parameters.
     * @return {Promise<any>} Promise resolved with the result.
     */
    SQLiteDB.prototype.execute = function (sql, params) {
        var _this = this;
        return this.ready().then(function () {
            return _this.db.executeSql(sql, params);
        });
    };
    /**
     * Execute a set of SQL queries. This operation is atomic.
     * IMPORTANT: Use this function only if you cannot use any of the other functions in this API. Please take into account that
     * these query will be run in SQLite (Mobile) and Web SQL (desktop), so your query should work in both environments.
     *
     * @param {any[]} sqlStatements SQL statements to execute.
     * @return {Promise<any>} Promise resolved with the result.
     */
    SQLiteDB.prototype.executeBatch = function (sqlStatements) {
        var _this = this;
        return this.ready().then(function () {
            return _this.db.sqlBatch(sqlStatements);
        });
    };
    /**
     * Format the data to insert in the database. Removes undefined entries so they are stored as null instead of 'undefined'.
     *
     * @param {object} data Data to insert.
     */
    SQLiteDB.prototype.formatDataToInsert = function (data) {
        // Remove undefined entries and convert null to "NULL".
        for (var name_1 in data) {
            var value = data[name_1];
            if (typeof value == 'undefined') {
                delete data[name_1];
            }
        }
    };
    /**
     * Get all the records from a table.
     *
     * @param {string} table The table to query.
     * @return {Promise<any>} Promise resolved with the records.
     */
    SQLiteDB.prototype.getAllRecords = function (table) {
        return this.getRecords(table);
    };
    /**
     * Get a single field value from a table record where all the given conditions met.
     *
     * @param {string} table The table to query.
     * @param {string} field The field to return the value of.
     * @param {object} [conditions] The conditions to build the where clause. Must not contain numeric indexes.
     * @return {Promise<any>} Promise resolved with the field's value.
     */
    SQLiteDB.prototype.getField = function (table, field, conditions) {
        var selectAndParams = this.whereClause(conditions);
        return this.getFieldSelect(table, field, selectAndParams[0], selectAndParams[1]);
    };
    /**
     * Get a single field value from a table record which match a particular WHERE clause.
     *
     * @param {string} table The table to query.
     * @param {string} field The field to return the value of.
     * @param {string} [select=''] A fragment of SQL to be used in a where clause returning one row with one column.
     * @param {any[]} [params] Array of sql parameters.
     * @return {Promise<any>} Promise resolved with the field's value.
     */
    SQLiteDB.prototype.getFieldSelect = function (table, field, select, params) {
        if (select === void 0) { select = ''; }
        if (select) {
            select = 'WHERE ' + select;
        }
        return this.getFieldSql("SELECT " + field + " FROM " + table + " " + select, params);
    };
    /**
     * Get a single field value (first field) using a SQL statement.
     *
     * @param {string} sql The SQL query returning one row with one column.
     * @param {any[]} [params] An array of sql parameters.
     * @return {Promise<any>} Promise resolved with the field's value.
     */
    SQLiteDB.prototype.getFieldSql = function (sql, params) {
        return this.getRecordSql(sql, params).then(function (record) {
            if (!record) {
                return Promise.reject(null);
            }
            // Return the first property.
            return record[Object.keys(record)[0]];
        });
    };
    /**
     * Constructs 'IN()' or '=' sql fragment
     *
     * @param {any} items A single value or array of values for the expression. It doesn't accept objects.
     * @param {boolean} [equal=true] True means we want to equate to the constructed expression.
     * @param {any} [onEmptyItems] This defines the behavior when the array of items provided is empty. Defaults to false,
     *              meaning return empty. Other values will become part of the returned SQL fragment.
     * @return {any[]} A list containing the constructed sql fragment and an array of parameters.
     */
    SQLiteDB.prototype.getInOrEqual = function (items, equal, onEmptyItems) {
        if (equal === void 0) { equal = true; }
        var sql, params;
        if (typeof onEmptyItems == 'undefined') {
            onEmptyItems = false;
        }
        // Default behavior, return empty data on empty array.
        if (Array.isArray(items) && !items.length && onEmptyItems === false) {
            return ['', []];
        }
        // Handle onEmptyItems on empty array of items.
        if (Array.isArray(items) && !items.length) {
            if (onEmptyItems === null) {
                sql = equal ? ' IS NULL' : ' IS NOT NULL';
                return [sql, []];
            }
            else {
                items = [onEmptyItems]; // Rest of cases, prepare items for processing.
            }
        }
        if (!Array.isArray(items) || items.length == 1) {
            sql = equal ? '= ?' : '<> ?';
            params = Array.isArray(items) ? items : [items];
        }
        else {
            sql = (equal ? '' : 'NOT ') + 'IN (' + ',?'.repeat(items.length).substr(1) + ')';
            params = items;
        }
        return [sql, params];
    };
    /**
     * Get the database name.
     *
     * @return {string} Database name.
     */
    SQLiteDB.prototype.getName = function () {
        return this.name;
    };
    /**
     * Get a single database record where all the given conditions met.
     *
     * @param {string} table The table to query.
     * @param {object} [conditions] The conditions to build the where clause. Must not contain numeric indexes.
     * @param {string} [fields='*'] A comma separated list of fields to return.
     * @return {Promise<any>} Promise resolved with the record, rejected if not found.
     */
    SQLiteDB.prototype.getRecord = function (table, conditions, fields) {
        if (fields === void 0) { fields = '*'; }
        var selectAndParams = this.whereClause(conditions);
        return this.getRecordSelect(table, selectAndParams[0], selectAndParams[1], fields);
    };
    /**
     * Get a single database record as an object which match a particular WHERE clause.
     *
     * @param {string} table The table to query.
     * @param {string} [select] A fragment of SQL to be used in a where clause in the SQL call.
     * @param {any[]} [params] An array of sql parameters.
     * @param {string} [fields='*'] A comma separated list of fields to return.
     * @return {Promise<any>} Promise resolved with the record, rejected if not found.
     */
    SQLiteDB.prototype.getRecordSelect = function (table, select, params, fields) {
        if (select === void 0) { select = ''; }
        if (params === void 0) { params = []; }
        if (fields === void 0) { fields = '*'; }
        if (select) {
            select = ' WHERE ' + select;
        }
        return this.getRecordSql("SELECT " + fields + " FROM " + table + " " + select, params);
    };
    /**
     * Get a single database record as an object using a SQL statement.
     *
     * The SQL statement should normally only return one record.
     * It is recommended to use getRecordsSql() if more matches possible!
     *
     * @param {string} sql The SQL string you wish to be executed, should normally only return one record.
     * @param {any[]} [params] List of sql parameters
     * @return {Promise<any>} Promise resolved with the records.
     */
    SQLiteDB.prototype.getRecordSql = function (sql, params) {
        return this.getRecordsSql(sql, params, 0, 1).then(function (result) {
            if (!result || !result.length) {
                // Not found, reject.
                return Promise.reject(null);
            }
            // Return only the first record.
            return result[0];
        });
    };
    /**
     * Get a number of records where all the given conditions met.
     *
     * @param {string} table The table to query.
     * @param {object} [conditions] The conditions to build the where clause. Must not contain numeric indexes.
     * @param {string} [sort=''] An order to sort the results in.
     * @param {string} [fields='*'] A comma separated list of fields to return.
     * @param {number} [limitFrom=0] Return a subset of records, starting at this point.
     * @param {number} [limitNum=0] Return a subset comprising this many records in total.
     * @return {Promise<any>} Promise resolved with the records.
     */
    SQLiteDB.prototype.getRecords = function (table, conditions, sort, fields, limitFrom, limitNum) {
        if (sort === void 0) { sort = ''; }
        if (fields === void 0) { fields = '*'; }
        if (limitFrom === void 0) { limitFrom = 0; }
        if (limitNum === void 0) { limitNum = 0; }
        var selectAndParams = this.whereClause(conditions);
        return this.getRecordsSelect(table, selectAndParams[0], selectAndParams[1], sort, fields, limitFrom, limitNum);
    };
    /**
     * Get a number of records where one field match one list of values.
     *
     * @param {string} table The database table to be checked against.
     * @param {string} field The name of a field.
     * @param {any[]} values The values field might take.
     * @param {string} [sort=''] An order to sort the results in.
     * @param {string} [fields='*'] A comma separated list of fields to return.
     * @param {number} [limitFrom=0] Return a subset of records, starting at this point.
     * @param {number} [limitNum=0] Return a subset comprising this many records in total.
     * @return {Promise<any>} Promise resolved with the records.
     */
    SQLiteDB.prototype.getRecordsList = function (table, field, values, sort, fields, limitFrom, limitNum) {
        if (sort === void 0) { sort = ''; }
        if (fields === void 0) { fields = '*'; }
        if (limitFrom === void 0) { limitFrom = 0; }
        if (limitNum === void 0) { limitNum = 0; }
        var selectAndParams = this.whereClauseList(field, values);
        return this.getRecordsSelect(table, selectAndParams[0], selectAndParams[1], sort, fields, limitFrom, limitNum);
    };
    /**
     * Get a number of records which match a particular WHERE clause.
     *
     * @param {string} table The table to query.
     * @param {string} [select] A fragment of SQL to be used in a where clause in the SQL call.
     * @param {any[]} [params] An array of sql parameters.
     * @param {string} [sort=''] An order to sort the results in.
     * @param {string} [fields='*'] A comma separated list of fields to return.
     * @param {number} [limitFrom=0] Return a subset of records, starting at this point.
     * @param {number} [limitNum=0] Return a subset comprising this many records in total.
     * @return {Promise<any>} Promise resolved with the records.
     */
    SQLiteDB.prototype.getRecordsSelect = function (table, select, params, sort, fields, limitFrom, limitNum) {
        if (select === void 0) { select = ''; }
        if (params === void 0) { params = []; }
        if (sort === void 0) { sort = ''; }
        if (fields === void 0) { fields = '*'; }
        if (limitFrom === void 0) { limitFrom = 0; }
        if (limitNum === void 0) { limitNum = 0; }
        if (select) {
            select = ' WHERE ' + select;
        }
        if (sort) {
            sort = ' ORDER BY ' + sort;
        }
        var sql = "SELECT " + fields + " FROM " + table + " " + select + " " + sort;
        return this.getRecordsSql(sql, params, limitFrom, limitNum);
    };
    /**
     * Get a number of records using a SQL statement.
     *
     * @param {string} sql The SQL select query to execute.
     * @param {any[]} [params] List of sql parameters
     * @param {number} [limitFrom] Return a subset of records, starting at this point.
     * @param {number} [limitNum] Return a subset comprising this many records.
     * @return {Promise<any>} Promise resolved with the records.
     */
    SQLiteDB.prototype.getRecordsSql = function (sql, params, limitFrom, limitNum) {
        var limits = this.normaliseLimitFromNum(limitFrom, limitNum);
        if (limits[0] || limits[1]) {
            if (limits[1] < 1) {
                limits[1] = Number.MAX_VALUE;
            }
            sql += ' LIMIT ' + limits[0] + ', ' + limits[1];
        }
        return this.execute(sql, params).then(function (result) {
            // Retrieve the records.
            var records = [];
            for (var i = 0; i < result.rows.length; i++) {
                records.push(result.rows.item(i));
            }
            return records;
        });
    };
    /**
     * Given a data object, returns the SQL query and the params to insert that record.
     *
     * @param {string} table The database table.
     * @param {object} data A data object with values for one or more fields in the record.
     * @return {any[]} Array with the SQL query and the params.
     */
    SQLiteDB.prototype.getSqlInsertQuery = function (table, data) {
        this.formatDataToInsert(data);
        var keys = Object.keys(data), fields = keys.join(','), questionMarks = ',?'.repeat(keys.length).substr(1);
        return [
            "INSERT INTO " + table + " (" + fields + ") VALUES (" + questionMarks + ")",
            keys.map(function (key) { return data[key]; })
        ];
    };
    /**
     * Initialize the database.
     */
    SQLiteDB.prototype.init = function () {
        var _this = this;
        this.promise = this.platform.ready().then(function () {
            return _this.sqlite.create({
                name: _this.name,
                location: 'default'
            });
        }).then(function (db) {
            _this.db = db;
        });
    };
    /**
     * Insert or update a record.
     *
     * @param {string} table The database table.
     * @param {object} data An object with the fields to insert/update: fieldname=>fieldvalue.
     * @param {object} conditions The conditions to check if the record already exists (and to update it).
     * @return {Promise<any>} Promise resolved with done.
     */
    SQLiteDB.prototype.insertOrUpdateRecord = function (table, data, conditions) {
        var _this = this;
        return this.getRecord(table, conditions).then(function () {
            // It exists, update it.
            return _this.updateRecords(table, data, conditions);
        }).catch(function () {
            // Doesn't exist, insert it.
            return _this.insertRecord(table, data);
        });
    };
    /**
     * Insert a record into a table and return the "rowId" field.
     *
     * @param {string} table The database table to be inserted into.
     * @param {object} data A data object with values for one or more fields in the record.
     * @return {Promise<number>} Promise resolved with new rowId. Please notice this rowId is internal from SQLite.
     */
    SQLiteDB.prototype.insertRecord = function (table, data) {
        var sqlAndParams = this.getSqlInsertQuery(table, data);
        return this.execute(sqlAndParams[0], sqlAndParams[1]).then(function (result) {
            return result.insertId;
        });
    };
    /**
     * Insert multiple records into database as fast as possible.
     *
     * @param {string} table The database table to be inserted into.
     * @param {object[]} dataObjects List of objects to be inserted.
     * @return {Promise<any>} Promise resolved when done.
     */
    SQLiteDB.prototype.insertRecords = function (table, dataObjects) {
        var _this = this;
        if (!Array.isArray(dataObjects)) {
            return Promise.reject(null);
        }
        var statements = [];
        dataObjects.forEach(function (dataObject) {
            statements.push(_this.getSqlInsertQuery(table, dataObject));
        });
        return this.executeBatch(statements);
    };
    /**
     * Ensures that limit params are numeric and positive integers, to be passed to the database.
     * We explicitly treat null, '' and -1 as 0 in order to provide compatibility with how limit
     * values have been passed historically.
     *
     * @param {any} limitFrom Where to start results from.
     * @param {any} limitNum How many results to return.
     * @return {number[]} Normalised limit params in array: [limitFrom, limitNum].
     */
    SQLiteDB.prototype.normaliseLimitFromNum = function (limitFrom, limitNum) {
        // We explicilty treat these cases as 0.
        if (typeof limitFrom == 'undefined' || limitFrom === null || limitFrom === '' || limitFrom === -1) {
            limitFrom = 0;
        }
        if (typeof limitNum == 'undefined' || limitNum === null || limitNum === '' || limitNum === -1) {
            limitNum = 0;
        }
        limitFrom = parseInt(limitFrom, 10);
        limitNum = parseInt(limitNum, 10);
        limitFrom = Math.max(0, limitFrom);
        limitNum = Math.max(0, limitNum);
        return [limitFrom, limitNum];
    };
    /**
     * Open the database. Only needed if it was closed before, a database is automatically opened when created.
     *
     * @return {Promise<void>} Promise resolved when open.
     */
    SQLiteDB.prototype.open = function () {
        var _this = this;
        return this.ready().then(function () {
            return _this.db.open();
        });
    };
    /**
     * Wait for the DB to be ready.
     *
     * @return {Promise<void>} Promise resolved when ready.
     */
    SQLiteDB.prototype.ready = function () {
        return this.promise;
    };
    /**
     * Test whether a record exists in a table where all the given conditions met.
     *
     * @param {string} table The table to check.
     * @param {object} [conditions] The conditions to build the where clause. Must not contain numeric indexes.
     * @return {Promise<void>} Promise resolved if exists, rejected otherwise.
     */
    SQLiteDB.prototype.recordExists = function (table, conditions) {
        return this.getRecord(table, conditions).then(function (record) {
            if (!record) {
                return Promise.reject(null);
            }
        });
    };
    /**
     * Test whether any records exists in a table which match a particular WHERE clause.
     *
     * @param {string} table The table to query.
     * @param {string} [select] A fragment of SQL to be used in a where clause in the SQL call.
     * @param {any[]} [params] An array of sql parameters.
     * @return {Promise<any>} Promise resolved if exists, rejected otherwise.
     */
    SQLiteDB.prototype.recordExistsSelect = function (table, select, params) {
        if (select === void 0) { select = ''; }
        if (params === void 0) { params = []; }
        return this.getRecordSelect(table, select, params).then(function (record) {
            if (!record) {
                return Promise.reject(null);
            }
        });
    };
    /**
     * Test whether a SQL SELECT statement returns any records.
     *
     * @param {string} sql The SQL query returning one row with one column.
     * @param {any[]} [params] An array of sql parameters.
     * @return {Promise<any>} Promise resolved if exists, rejected otherwise.
     */
    SQLiteDB.prototype.recordExistsSql = function (sql, params) {
        return this.getRecordSql(sql, params).then(function (record) {
            if (!record) {
                return Promise.reject(null);
            }
        });
    };
    /**
     * Update one or more records in a table.
     *
     * @param {string} string table The database table to update.
     * @param {any} data An object with the fields to update: fieldname=>fieldvalue.
     * @param {any} [conditions] The conditions to build the where clause. Must not contain numeric indexes.
     * @return {Promise<any>} Promise resolved when updated.
     */
    SQLiteDB.prototype.updateRecords = function (table, data, conditions) {
        if (!data || !Object.keys(data).length) {
            // No fields to update, consider it's done.
            return Promise.resolve();
        }
        var whereAndParams = this.whereClause(conditions), sets = [];
        var sql, params;
        this.formatDataToInsert(data);
        for (var key in data) {
            sets.push(key + " = ?");
        }
        sql = "UPDATE " + table + " SET " + sets.join(', ') + " WHERE " + whereAndParams[0];
        // Create the list of params using the "data" object and the params for the where clause.
        params = Object.keys(data).map(function (key) { return data[key]; }).concat(whereAndParams[1]);
        return this.execute(sql, params);
    };
    /**
     * Update one or more records in a table. It accepts a WHERE clause as a string.
     *
     * @param {string} string table The database table to update.
     * @param {any} data An object with the fields to update: fieldname=>fieldvalue.
     * @param {string} [where] Where clause. Must not include the "WHERE" word.
     * @param {any[]} [whereParams] Params for the where clause.
     * @return {Promise<any>} Promise resolved when updated.
     */
    SQLiteDB.prototype.updateRecordsWhere = function (table, data, where, whereParams) {
        if (!data || !Object.keys(data).length) {
            // No fields to update, consider it's done.
            return Promise.resolve();
        }
        var sets = [];
        var sql, params;
        for (var key in data) {
            sets.push(key + " = ?");
        }
        sql = "UPDATE " + table + " SET " + sets.join(', ');
        if (where) {
            sql += " WHERE " + where;
        }
        // Create the list of params using the "data" object and the params for the where clause.
        params = Object.keys(data).map(function (key) { return data[key]; });
        if (where && whereParams) {
            params = params.concat(whereParams);
        }
        return this.execute(sql, params);
    };
    /**
     * Returns the SQL WHERE conditions.
     *
     * @param {object} [conditions] The conditions to build the where clause. Must not contain numeric indexes.
     * @return {any[]} An array list containing sql 'where' part and 'params'.
     */
    SQLiteDB.prototype.whereClause = function (conditions) {
        if (conditions === void 0) { conditions = {}; }
        if (!conditions || !Object.keys(conditions).length) {
            return ['1 = 1', []];
        }
        var where = [], params = [];
        for (var key in conditions) {
            var value = conditions[key];
            if (typeof value == 'undefined' || value === null) {
                where.push(key + ' IS NULL');
            }
            else {
                where.push(key + ' = ?');
                params.push(value);
            }
        }
        return [where.join(' AND '), params];
    };
    /**
     * Returns SQL WHERE conditions for the ..._list group of methods.
     *
     * @param {string} field The name of a field.
     * @param {any[]} values The values field might take.
     * @return {any[]} An array containing sql 'where' part and 'params'.
     */
    SQLiteDB.prototype.whereClauseList = function (field, values) {
        if (!values || !values.length) {
            return ['1 = 2', []]; // Fake condition, won't return rows ever.
        }
        var params = [];
        var select = '';
        values.forEach(function (value) {
            if (typeof value == 'boolean') {
                value = Number(value);
            }
            if (typeof value == 'undefined' || value === null) {
                select = field + ' IS NULL';
            }
            else {
                params.push(value);
            }
        });
        if (params && params.length) {
            if (select !== '') {
                select = select + ' OR ';
            }
            if (params.length == 1) {
                select = select + field + ' = ?';
            }
            else {
                var questionMarks = ',?'.repeat(params.length).substr(1);
                select = select + field + ' IN (' + questionMarks + ')';
            }
        }
        return [select, params];
    };
    return SQLiteDB;
}());

//# sourceMappingURL=sqlitedb.js.map

/***/ }),
/* 496 */,
/* 497 */,
/* 498 */,
/* 499 */,
/* 500 */,
/* 501 */,
/* 502 */,
/* 503 */,
/* 504 */,
/* 505 */,
/* 506 */,
/* 507 */,
/* 508 */,
/* 509 */,
/* 510 */,
/* 511 */,
/* 512 */,
/* 513 */,
/* 514 */,
/* 515 */,
/* 516 */,
/* 517 */,
/* 518 */,
/* 519 */,
/* 520 */,
/* 521 */,
/* 522 */,
/* 523 */,
/* 524 */,
/* 525 */,
/* 526 */,
/* 527 */,
/* 528 */,
/* 529 */,
/* 530 */,
/* 531 */,
/* 532 */,
/* 533 */,
/* 534 */,
/* 535 */,
/* 536 */,
/* 537 */,
/* 538 */,
/* 539 */,
/* 540 */,
/* 541 */,
/* 542 */,
/* 543 */,
/* 544 */,
/* 545 */,
/* 546 */,
/* 547 */,
/* 548 */,
/* 549 */,
/* 550 */,
/* 551 */,
/* 552 */,
/* 553 */,
/* 554 */,
/* 555 */,
/* 556 */,
/* 557 */,
/* 558 */,
/* 559 */,
/* 560 */,
/* 561 */,
/* 562 */,
/* 563 */,
/* 564 */,
/* 565 */,
/* 566 */,
/* 567 */,
/* 568 */,
/* 569 */,
/* 570 */,
/* 571 */,
/* 572 */,
/* 573 */,
/* 574 */,
/* 575 */,
/* 576 */,
/* 577 */,
/* 578 */,
/* 579 */,
/* 580 */,
/* 581 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSitesFactoryProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__classes_site__ = __webpack_require__(1035);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/*
 * Provider to create sites instances.
*/
var CoreSitesFactoryProvider = /** @class */ (function () {
    function CoreSitesFactoryProvider(injector) {
        this.injector = injector;
    }
    /**
     * Make a site object.
     *
     * @param {string} id Site ID.
     * @param {string} siteUrl Site URL.
     * @param {string} [token] Site's WS token.
     * @param {any} [info] Site info.
     * @param {string} [privateToken] Private token.
     * @param {any} [config] Site public config.
     * @param {boolean} [loggedOut] Whether user is logged out.
     * @return {CoreSite} Site instance.
     * @description
     * This returns a site object.
     */
    CoreSitesFactoryProvider.prototype.makeSite = function (id, siteUrl, token, info, privateToken, config, loggedOut) {
        return new __WEBPACK_IMPORTED_MODULE_1__classes_site__["a" /* CoreSite */](this.injector, id, siteUrl, token, info, privateToken, config, loggedOut);
    };
    /**
     * Gets the list of Site methods.
     *
     * @return {string[]} List of methods.
     */
    CoreSitesFactoryProvider.prototype.getSiteMethods = function () {
        var methods = [];
        for (var name_1 in __WEBPACK_IMPORTED_MODULE_1__classes_site__["a" /* CoreSite */].prototype) {
            methods.push(name_1);
        }
        return methods;
    };
    CoreSitesFactoryProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["C" /* Injector */]])
    ], CoreSitesFactoryProvider);
    return CoreSitesFactoryProvider;
}());

//# sourceMappingURL=sites-factory.js.map

/***/ }),
/* 582 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreInterceptor; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

/**
 * Interceptor for Http calls. Adds the header 'Content-Type'='application/x-www-form-urlencoded'
 * and serializes the parameters if needed.
 */
var CoreInterceptor = /** @class */ (function () {
    function CoreInterceptor() {
        // Nothing to do.
    }
    CoreInterceptor_1 = CoreInterceptor;
    CoreInterceptor.prototype.intercept = function (req, next) {
        // Add the header and serialize the body if needed.
        var newReq = req.clone({
            headers: req.headers.set('Content-Type', 'application/x-www-form-urlencoded'),
            body: typeof req.body == 'object' && String(req.body) != '[object File]' ?
                CoreInterceptor_1.serialize(req.body) : req.body
        });
        // Pass on the cloned request instead of the original request.
        return next.handle(newReq);
    };
    /**
     * Serialize an object to be used in a request.
     *
     * @param {any} obj Object to serialize.
     * @param {boolean} [addNull] Add null values to the serialized as empty parameters.
     * @return {string} Serialization of the object.
     */
    CoreInterceptor.serialize = function (obj, addNull) {
        var query = '', fullSubName, subValue, innerObj;
        for (var name_1 in obj) {
            var value = obj[name_1];
            if (value instanceof Array) {
                for (var i = 0; i < value.length; ++i) {
                    subValue = value[i];
                    fullSubName = name_1 + '[' + i + ']';
                    innerObj = {};
                    innerObj[fullSubName] = subValue;
                    query += this.serialize(innerObj) + '&';
                }
            }
            else if (value instanceof Object) {
                for (var subName in value) {
                    subValue = value[subName];
                    fullSubName = name_1 + '[' + subName + ']';
                    innerObj = {};
                    innerObj[fullSubName] = subValue;
                    query += this.serialize(innerObj) + '&';
                }
            }
            else if (addNull || (typeof value != 'undefined' && value !== null)) {
                query += encodeURIComponent(name_1) + '=' + encodeURIComponent(value) + '&';
            }
        }
        return query.length ? query.substr(0, query.length - 1) : query;
    };
    CoreInterceptor = CoreInterceptor_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [])
    ], CoreInterceptor);
    return CoreInterceptor;
    var CoreInterceptor_1;
}());

//# sourceMappingURL=interceptor.js.map

/***/ }),
/* 583 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreExternalContentDirective; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_filepool__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_url__ = __webpack_require__(42);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








/**
 * Directive to handle external content.
 *
 * This directive should be used with any element that links to external content
 * which we want to have available when the app is offline. Typically media and links.
 *
 * If a file is downloaded, its URL will be replaced by the local file URL.
 */
var CoreExternalContentDirective = /** @class */ (function () {
    function CoreExternalContentDirective(element, logger, filepoolProvider, platform, sitesProvider, domUtils, urlUtils, appProvider) {
        this.filepoolProvider = filepoolProvider;
        this.platform = platform;
        this.sitesProvider = sitesProvider;
        this.domUtils = domUtils;
        this.urlUtils = urlUtils;
        this.appProvider = appProvider;
        // This directive can be added dynamically. In that case, the first param is the HTMLElement.
        this.element = element.nativeElement || element;
        this.logger = logger.getInstance('CoreExternalContentDirective');
    }
    /**
     * View has been initialized
     */
    CoreExternalContentDirective.prototype.ngAfterViewInit = function () {
        var currentSite = this.sitesProvider.getCurrentSite(), siteId = this.siteId || (currentSite && currentSite.getId()), tagName = this.element.tagName;
        var targetAttr, sourceAttr;
        if (tagName === 'A') {
            targetAttr = 'href';
            sourceAttr = 'href';
        }
        else if (tagName === 'IMG') {
            targetAttr = 'src';
            sourceAttr = 'src';
        }
        else if (tagName === 'AUDIO' || tagName === 'VIDEO' || tagName === 'SOURCE' || tagName === 'TRACK') {
            targetAttr = 'src';
            sourceAttr = 'targetSrc';
            if (tagName === 'VIDEO') {
                var poster = this.element.poster;
                if (poster) {
                    // Handle poster.
                    this.handleExternalContent('poster', poster, siteId).catch(function () {
                        // Ignore errors.
                    });
                }
            }
        }
        else {
            // Unsupported tag.
            this.logger.warn('Directive attached to non-supported tag: ' + tagName);
            return;
        }
        var url = this.element.getAttribute(sourceAttr) || this.element.getAttribute(targetAttr);
        this.handleExternalContent(targetAttr, url, siteId).catch(function () {
            // Ignore errors.
        });
    };
    /**
     * Add a new source with a certain URL as a sibling of the current element.
     *
     * @param {string} url URL to use in the source.
     */
    CoreExternalContentDirective.prototype.addSource = function (url) {
        if (this.element.tagName !== 'SOURCE') {
            return;
        }
        var newSource = document.createElement('source'), type = this.element.getAttribute('type');
        newSource.setAttribute('src', url);
        if (type) {
            if (this.platform.is('android') && type == 'video/quicktime') {
                // Fix for VideoJS/Chrome bug https://github.com/videojs/video.js/issues/423 .
                newSource.setAttribute('type', 'video/mp4');
            }
            else {
                newSource.setAttribute('type', type);
            }
        }
        this.element.parentNode.insertBefore(newSource, this.element);
    };
    /**
     * Handle external content, setting the right URL.
     *
     * @param {string} targetAttr Attribute to modify.
     * @param {string} url Original URL to treat.
     * @param {string} [siteId] Site ID.
     * @return {Promise<any>} Promise resolved if the element is successfully treated.
     */
    CoreExternalContentDirective.prototype.handleExternalContent = function (targetAttr, url, siteId) {
        var _this = this;
        var tagName = this.element.tagName;
        if (tagName == 'VIDEO' && targetAttr != 'poster') {
            var video = this.element;
            if (video.textTracks) {
                // It's a video with subtitles. In iOS, subtitles position is wrong so it needs to be fixed.
                video.textTracks.onaddtrack = function (event) {
                    var track = event.track;
                    if (track) {
                        track.oncuechange = function () {
                            var line = _this.platform.is('tablet') || _this.platform.is('android') ? 90 : 80;
                            // Position all subtitles to a percentage of video height.
                            Array.from(track.cues).forEach(function (cue) {
                                cue.snapToLines = false;
                                cue.line = line;
                                cue.size = 100; // This solves some Android issue.
                            });
                            // Delete listener.
                            track.oncuechange = null;
                        };
                    }
                };
            }
        }
        if (!url || !url.match(/^https?:\/\//i) || (tagName === 'A' && !this.urlUtils.isDownloadableUrl(url))) {
            this.logger.debug('Ignoring non-downloadable URL: ' + url);
            if (tagName === 'SOURCE') {
                // Restoring original src.
                this.addSource(url);
            }
            return Promise.reject(null);
        }
        // Get the webservice pluginfile URL, we ignore failures here.
        return this.sitesProvider.getSite(siteId).then(function (site) {
            if (!site.canDownloadFiles() && _this.urlUtils.isPluginFileUrl(url)) {
                _this.element.parentElement.removeChild(_this.element); // Remove element since it'll be broken.
                return Promise.reject(null);
            }
            // Download images, tracks and posters if size is unknown.
            var dwnUnknown = tagName == 'IMG' || tagName == 'TRACK' || targetAttr == 'poster';
            var promise;
            if (targetAttr === 'src' && tagName !== 'SOURCE' && tagName !== 'TRACK') {
                promise = _this.filepoolProvider.getSrcByUrl(siteId, url, _this.component, _this.componentId, 0, true, dwnUnknown);
            }
            else {
                promise = _this.filepoolProvider.getUrlByUrl(siteId, url, _this.component, _this.componentId, 0, true, dwnUnknown);
            }
            return promise.then(function (finalUrl) {
                _this.logger.debug('Using URL ' + finalUrl + ' for ' + url);
                if (tagName === 'SOURCE') {
                    // The browser does not catch changes in SRC, we need to add a new source.
                    // @todo: Check if changing src works in Android 4.4, maybe the problem was only in 4.1-4.3.
                    _this.addSource(finalUrl);
                }
                else {
                    _this.element.setAttribute(targetAttr, finalUrl);
                }
                // Set events to download big files (not downloaded automatically).
                if (finalUrl.indexOf('http') === 0 && targetAttr != 'poster' &&
                    (tagName == 'VIDEO' || tagName == 'AUDIO' || tagName == 'A' || tagName == 'SOURCE')) {
                    var eventName = tagName == 'A' ? 'click' : 'play';
                    var clickableEl = _this.element;
                    if (tagName == 'SOURCE') {
                        clickableEl = _this.domUtils.closest(_this.element, 'video,audio');
                        if (!clickableEl) {
                            return;
                        }
                    }
                    clickableEl.addEventListener(eventName, function () {
                        // User played media or opened a downloadable link.
                        // Download the file if in wifi and it hasn't been downloaded already (for big files).
                        if (!_this.appProvider.isNetworkAccessLimited()) {
                            // We aren't using the result, so it doesn't matter which of the 2 functions we call.
                            _this.filepoolProvider.getUrlByUrl(siteId, url, _this.component, _this.componentId, 0, false);
                        }
                    });
                }
            });
        });
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreExternalContentDirective.prototype, "siteId", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreExternalContentDirective.prototype, "component", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreExternalContentDirective.prototype, "componentId", void 0);
    CoreExternalContentDirective = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["s" /* Directive */])({
            selector: '[core-external-content]'
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_3__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_filepool__["a" /* CoreFilepoolProvider */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */], __WEBPACK_IMPORTED_MODULE_5__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_7__providers_utils_url__["a" /* CoreUrlUtilsProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */]])
    ], CoreExternalContentDirective);
    return CoreExternalContentDirective;
}());

//# sourceMappingURL=external-content.js.map

/***/ }),
/* 584 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreLinkDirective; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_url__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_contentlinks_providers_helper__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__configconstants__ = __webpack_require__(50);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};








/**
 * Directive to open a link in external browser.
 */
var CoreLinkDirective = /** @class */ (function () {
    function CoreLinkDirective(element, domUtils, utils, sitesProvider, urlUtils, contentLinksHelper, navCtrl, content) {
        this.domUtils = domUtils;
        this.utils = utils;
        this.sitesProvider = sitesProvider;
        this.urlUtils = urlUtils;
        this.contentLinksHelper = contentLinksHelper;
        this.navCtrl = navCtrl;
        this.content = content;
        this.autoLogin = 'check'; // If the link should be open with auto-login. Accepts the following values:
        // This directive can be added dynamically. In that case, the first param is the anchor HTMLElement.
        this.element = element.nativeElement || element;
    }
    /**
     * Function executed when the component is initialized.
     */
    CoreLinkDirective.prototype.ngOnInit = function () {
        var _this = this;
        this.inApp = this.utils.isTrueOrOne(this.inApp);
        this.element.addEventListener('click', function (event) {
            // If the event prevented default action, do nothing.
            if (!event.defaultPrevented) {
                var href_1 = _this.element.getAttribute('href');
                if (href_1) {
                    event.preventDefault();
                    event.stopPropagation();
                    if (_this.utils.isTrueOrOne(_this.capture)) {
                        _this.contentLinksHelper.handleLink(href_1, undefined, _this.navCtrl).then(function (treated) {
                            if (!treated) {
                                _this.navigate(href_1);
                            }
                        });
                    }
                    else {
                        _this.navigate(href_1);
                    }
                }
            }
        });
    };
    /**
     * Convenience function to correctly navigate, open file or url in the browser.
     *
     * @param {string} href HREF to be opened.
     */
    CoreLinkDirective.prototype.navigate = function (href) {
        var _this = this;
        var contentLinksScheme = __WEBPACK_IMPORTED_MODULE_7__configconstants__["a" /* CoreConfigConstants */].customurlscheme + '://link=';
        if (href.indexOf('cdvfile://') === 0 || href.indexOf('file://') === 0 || href.indexOf('filesystem:') === 0) {
            // We have a local file.
            this.utils.openFile(href).catch(function (error) {
                _this.domUtils.showErrorModal(error);
            });
        }
        else if (href.charAt(0) == '#') {
            href = href.substr(1);
            // In site links
            if (href.charAt(0) == '/') {
                // @todo: Investigate how to achieve this behaviour.
                // $location.url(href);
            }
            else {
                // Look for id or name.
                this.domUtils.scrollToElementBySelector(this.content, '#' + href + ', [name=\'' + href + '\']');
            }
        }
        else if (href.indexOf(contentLinksScheme) === 0) {
            // Link should be treated by Custom URL Scheme. Encode the right part, otherwise ':' is removed in iOS.
            href = contentLinksScheme + encodeURIComponent(href.replace(contentLinksScheme, ''));
            this.utils.openInBrowser(href);
        }
        else {
            // It's an external link, we will open with browser. Check if we need to auto-login.
            if (!this.sitesProvider.isLoggedIn()) {
                // Not logged in, cannot auto-login.
                if (this.inApp) {
                    this.utils.openInApp(href);
                }
                else {
                    this.utils.openInBrowser(href);
                }
            }
            else {
                // Check if URL does not have any protocol, so it's a relative URL.
                if (!this.urlUtils.isAbsoluteURL(href)) {
                    // Add the site URL at the begining.
                    if (href.charAt(0) == '/') {
                        href = this.sitesProvider.getCurrentSite().getURL() + href;
                    }
                    else {
                        href = this.sitesProvider.getCurrentSite().getURL() + '/' + href;
                    }
                }
                if (this.autoLogin == 'yes') {
                    if (this.inApp) {
                        this.sitesProvider.getCurrentSite().openInAppWithAutoLogin(href);
                    }
                    else {
                        this.sitesProvider.getCurrentSite().openInBrowserWithAutoLogin(href);
                    }
                }
                else if (this.autoLogin == 'no') {
                    if (this.inApp) {
                        this.utils.openInApp(href);
                    }
                    else {
                        this.utils.openInBrowser(href);
                    }
                }
                else {
                    if (this.inApp) {
                        this.sitesProvider.getCurrentSite().openInAppWithAutoLoginIfSameSite(href);
                    }
                    else {
                        this.sitesProvider.getCurrentSite().openInBrowserWithAutoLoginIfSameSite(href);
                    }
                }
            }
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreLinkDirective.prototype, "capture", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreLinkDirective.prototype, "inApp", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreLinkDirective.prototype, "autoLogin", void 0);
    CoreLinkDirective = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["s" /* Directive */])({
            selector: '[core-link]'
        }),
        __param(6, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["N" /* Optional */])()),
        __param(7, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["N" /* Optional */])()),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_utils_url__["a" /* CoreUrlUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_6__core_contentlinks_providers_helper__["a" /* CoreContentLinksHelperProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavController */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["e" /* Content */]])
    ], CoreLinkDirective);
    return CoreLinkDirective;
}());

//# sourceMappingURL=link.js.map

/***/ }),
/* 585 */,
/* 586 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreContextMenuComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__context_menu_popover__ = __webpack_require__(587);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_rxjs__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






/**
 * This component adds a button (usually in the navigation bar) that displays a context menu popover.
 */
var CoreContextMenuComponent = /** @class */ (function () {
    function CoreContextMenuComponent(translate, popoverCtrl, elementRef, domUtils) {
        var _this = this;
        this.translate = translate;
        this.popoverCtrl = popoverCtrl;
        this.domUtils = domUtils;
        this.items = [];
        this.itemsMovedToParent = [];
        // Create the stream and subscribe to it. We ignore successive changes during 250ms.
        this.itemsChangedStream = new __WEBPACK_IMPORTED_MODULE_5_rxjs__["Subject"]();
        this.itemsChangedStream.auditTime(250).subscribe(function () {
            // Hide the menu if all items are hidden.
            _this.hideMenu = !_this.items.some(function (item) {
                return !item.hidden;
            });
            // Sort the items by priority.
            _this.items.sort(function (a, b) {
                return a.priority <= b.priority ? 1 : -1;
            });
        });
        this.instanceId = this.domUtils.storeInstanceByElement(elementRef.nativeElement, this);
    }
    /**
     * Component being initialized.
     */
    CoreContextMenuComponent.prototype.ngOnInit = function () {
        this.icon = this.icon || 'more';
        this.ariaLabel = this.title || this.translate.instant('core.info');
    };
    /**
     * Add a context menu item.
     *
     * @param {CoreContextMenuItemComponent} item The item to add.
     */
    CoreContextMenuComponent.prototype.addItem = function (item) {
        if (this.parentContextMenu) {
            // All items were moved to the "parent" menu. Add the item in there.
            this.parentContextMenu.addItem(item);
            if (this.itemsMovedToParent.indexOf(item) == -1) {
                this.itemsMovedToParent.push(item);
            }
        }
        else if (this.items.indexOf(item) == -1) {
            this.items.push(item);
            this.itemsChanged();
        }
    };
    /**
     * Function called when the items change.
     */
    CoreContextMenuComponent.prototype.itemsChanged = function () {
        if (this.parentContextMenu) {
            // All items were moved to the "parent" menu, call the function in there.
            this.parentContextMenu.itemsChanged();
        }
        else {
            this.itemsChangedStream.next();
        }
    };
    /**
     * Merge the current context menu with the one passed as parameter. All the items in this menu will be moved to the
     * one passed as parameter.
     *
     * @param {CoreContextMenuComponent} contextMenu The context menu where to move the items.
     */
    CoreContextMenuComponent.prototype.mergeContextMenus = function (contextMenu) {
        this.parentContextMenu = contextMenu;
        // Add all the items to the other menu.
        for (var i = 0; i < this.items.length; i++) {
            var item = this.items[i];
            contextMenu.addItem(item);
            this.itemsMovedToParent.push(item);
        }
        // Remove all items from the current menu.
        this.items = [];
        this.itemsChanged();
    };
    /**
     * Remove an item from the context menu.
     *
     * @param {CoreContextMenuItemComponent} item The item to remove.
     */
    CoreContextMenuComponent.prototype.removeItem = function (item) {
        if (this.parentContextMenu) {
            // All items were moved to the "parent" menu. Remove the item from there.
            this.parentContextMenu.removeItem(item);
            var index = this.itemsMovedToParent.indexOf(item);
            if (index >= 0) {
                this.itemsMovedToParent.splice(index, 1);
            }
        }
        else {
            var index = this.items.indexOf(item);
            if (index >= 0) {
                this.items.splice(index, 1);
            }
            this.itemsChanged();
        }
    };
    /**
     * Remove the items that were merged to a parent context menu.
     */
    CoreContextMenuComponent.prototype.removeMergedItems = function () {
        if (this.parentContextMenu) {
            for (var i = 0; i < this.itemsMovedToParent.length; i++) {
                this.parentContextMenu.removeItem(this.itemsMovedToParent[i]);
            }
        }
    };
    /**
     * Restore the items that were merged to a parent context menu.
     */
    CoreContextMenuComponent.prototype.restoreMergedItems = function () {
        if (this.parentContextMenu) {
            for (var i = 0; i < this.itemsMovedToParent.length; i++) {
                this.parentContextMenu.addItem(this.itemsMovedToParent[i]);
            }
        }
    };
    /**
     * Show the context menu.
     *
     * @param {MouseEvent} event Event.
     */
    CoreContextMenuComponent.prototype.showContextMenu = function (event) {
        var popover = this.popoverCtrl.create(__WEBPACK_IMPORTED_MODULE_4__context_menu_popover__["a" /* CoreContextMenuPopoverComponent */], { title: this.title, items: this.items });
        popover.present({
            ev: event
        });
    };
    /**
     * Component destroyed.
     */
    CoreContextMenuComponent.prototype.ngOnDestroy = function () {
        this.domUtils.removeInstanceById(this.instanceId);
        this.removeMergedItems();
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreContextMenuComponent.prototype, "icon", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreContextMenuComponent.prototype, "title", void 0);
    CoreContextMenuComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-context-menu',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/components/context-menu/context-menu.html"*/'<button [hidden]="hideMenu" ion-button clear icon-only [attr.aria-label]="ariaLabel" (click)="showContextMenu($event)">\n    <ion-icon [name]="icon"></ion-icon>\n</button>\n<ng-content></ng-content>'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/components/context-menu/context-menu.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["o" /* PopoverController */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */],
            __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__["a" /* CoreDomUtilsProvider */]])
    ], CoreContextMenuComponent);
    return CoreContextMenuComponent;
}());

//# sourceMappingURL=context-menu.js.map

/***/ }),
/* 587 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreContextMenuPopoverComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger__ = __webpack_require__(5);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Component to display a list of items received by param in a popover.
 */
var CoreContextMenuPopoverComponent = /** @class */ (function () {
    function CoreContextMenuPopoverComponent(navParams, viewCtrl, logger) {
        this.viewCtrl = viewCtrl;
        this.title = navParams.get('title');
        this.items = navParams.get('items') || [];
        this.logger = logger.getInstance('CoreContextMenuPopoverComponent');
    }
    /**
     * Close the popover.
     */
    CoreContextMenuPopoverComponent.prototype.closeMenu = function () {
        this.viewCtrl.dismiss();
    };
    /**
     * Function called when an item is clicked.
     *
     * @param {Event} event Click event.
     * @param {CoreContextMenuItemComponent} item Item clicked.
     * @return {boolean} Return true if success, false if error.
     */
    CoreContextMenuPopoverComponent.prototype.itemClicked = function (event, item) {
        if (item.action.observers.length > 0) {
            event.preventDefault();
            event.stopPropagation();
            if (!item.iconAction) {
                this.logger.warn('Items with action must have an icon action to work', item);
                return false;
            }
            else if (item.iconAction == 'spinner') {
                return false;
            }
            if (item.closeOnClick) {
                this.closeMenu();
            }
            item.action.emit(this.closeMenu.bind(this));
        }
        else if (item.href && item.closeOnClick) {
            this.closeMenu();
        }
        return true;
    };
    CoreContextMenuPopoverComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-context-menu-popover',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/components/context-menu/context-menu-popover.html"*/'<ion-list>\n    <ion-list-header *ngIf="title">{{title}}</ion-list-header>\n    <a ion-item text-wrap *ngFor="let item of items" core-link [capture]="item.captureLink" [autoLogin]="item.autoLogin" [href]="item.href" (click)="itemClicked($event, item)" [attr.aria-label]="item.ariaAction" [hidden]="item.hidden" [attr.detail-none]="!item.href || item.iconAction">\n        <ion-icon *ngIf="item.iconDescription" [name]="item.iconDescription" [attr.aria-label]="item.ariaDescription" item-start></ion-icon>\n        <core-format-text [clean]="true" [text]="item.content"></core-format-text>\n        <ion-icon *ngIf="(item.href || item.action) && item.iconAction && item.iconAction != \'spinner\'" [name]="item.iconAction" item-end></ion-icon>\n        <ion-spinner *ngIf="(item.href || item.action) && item.iconAction == \'spinner\'" item-end></ion-spinner>\n        <ion-badge class="{{item.badgeClass}}" item-end *ngIf="item.badge">{{item.badge}}</ion-badge>\n    </a>\n</ion-list>'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/components/context-menu/context-menu-popover.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["m" /* NavParams */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["s" /* ViewController */], __WEBPACK_IMPORTED_MODULE_2__providers_logger__["a" /* CoreLoggerProvider */]])
    ], CoreContextMenuPopoverComponent);
    return CoreContextMenuPopoverComponent;
}());

//# sourceMappingURL=context-menu-popover.js.map

/***/ }),
/* 588 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreTabsComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * This component displays some tabs that usually share data between them.
 *
 * If your tabs don't share any data then you should probably use ion-tabs. This component doesn't use different ion-nav
 * for each tab, so it will not load pages.
 *
 * Example usage:
 *
 * <core-tabs selectedIndex="1">
 *     <core-tab [title]="'core.courses.timeline' | translate" (ionSelect)="switchTab('timeline')">
 *         <ng-template> <!-- This ng-template is required, @see CoreTabComponent. -->
 *             <!-- Tab contents. -->
 *         </ng-template>
 *     </core-tab>
 * </core-tabs>
 *
 * Obviously, the tab contents will only be shown if that tab is selected.
 */
var CoreTabsComponent = /** @class */ (function () {
    function CoreTabsComponent(element, content) {
        this.content = content;
        this.selectedIndex = 0; // Index of the tab to select.
        this.hideUntil = true; // Determine when should the contents be shown.
        this.ionChange = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */](); // Emitted when the tab changes.
        this.tabs = []; // List of tabs.
        this.initialized = false;
        this.afterViewInitTriggered = false;
        this.tabsShown = true;
        this.tabBarElement = element.nativeElement;
    }
    /**
     * Component being initialized.
     */
    CoreTabsComponent.prototype.ngOnInit = function () {
        this.originalTabsContainer = this.originalTabsRef.nativeElement;
        this.topTabsElement = this.topTabs.nativeElement;
    };
    /**
     * View has been initialized.
     */
    CoreTabsComponent.prototype.ngAfterViewInit = function () {
        this.afterViewInitTriggered = true;
        if (!this.initialized && this.hideUntil) {
            // Tabs should be shown, initialize them.
            this.initializeTabs();
        }
    };
    /**
     * Detect changes on input properties.
     */
    CoreTabsComponent.prototype.ngOnChanges = function (changes) {
        var _this = this;
        // We need to wait for ngAfterViewInit because we need core-tab components to be executed.
        if (!this.initialized && this.hideUntil && this.afterViewInitTriggered) {
            // Tabs should be shown, initialize them.
            // Use a setTimeout so child core-tab update their inputs before initializing the tabs.
            setTimeout(function () {
                _this.initializeTabs();
            });
        }
    };
    /**
     * Add a new tab if it isn't already in the list of tabs.
     *
     * @param {CoreTabComponent} tab The tab to add.
     */
    CoreTabsComponent.prototype.addTab = function (tab) {
        // Check if tab is already in the list.
        if (this.getIndex(tab) == -1) {
            this.tabs.push(tab);
            this.sortTabs();
        }
    };
    /**
     * Get the index of tab.
     *
     * @param  {any}    tab [description]
     * @return {number}     [description]
     */
    CoreTabsComponent.prototype.getIndex = function (tab) {
        for (var i = 0; i < this.tabs.length; i++) {
            var t = this.tabs[i];
            if (t === tab || (typeof t.id != 'undefined' && t.id === tab.id)) {
                return i;
            }
        }
        return -1;
    };
    /**
     * Get the current selected tab.
     *
     * @return {CoreTabComponent} Selected tab.
     */
    CoreTabsComponent.prototype.getSelected = function () {
        return this.tabs[this.selected];
    };
    /**
     * Initialize the tabs, determining the first tab to be shown.
     */
    CoreTabsComponent.prototype.initializeTabs = function () {
        var selectedIndex = this.selectedIndex || 0, selectedTab = this.tabs[selectedIndex];
        if (!selectedTab || !selectedTab.enabled || !selectedTab.show) {
            // The tab is not enabled or not shown. Get the first tab that is enabled.
            selectedTab = this.tabs.find(function (tab, index) {
                if (tab.enabled && tab.show) {
                    selectedIndex = index;
                    return true;
                }
                return false;
            });
        }
        if (selectedTab) {
            this.selectTab(selectedIndex);
        }
        // Setup tab scrolling.
        this.tabBarHeight = this.topTabsElement.offsetHeight;
        this.originalTabsContainer.style.paddingBottom = this.tabBarHeight + 'px';
        if (this.content) {
            this.scroll = this.content.getScrollElement();
            if (this.scroll) {
                this.scroll.classList.add('no-scroll');
            }
        }
        this.initialized = true;
    };
    /**
     * Show or hide the tabs. This is used when the user is scrolling inside a tab.
     *
     * @param {any} e Scroll event.
     */
    CoreTabsComponent.prototype.showHideTabs = function (e) {
        if (e.target.scrollTop < this.tabBarHeight) {
            if (!this.tabsShown) {
                this.tabBarElement.classList.remove('tabs-hidden');
                this.tabsShown = true;
            }
        }
        else {
            if (this.tabsShown) {
                this.tabBarElement.classList.add('tabs-hidden');
                this.tabsShown = false;
            }
        }
    };
    /**
     * Remove a tab from the list of tabs.
     *
     * @param {CoreTabComponent} tab The tab to remove.
     */
    CoreTabsComponent.prototype.removeTab = function (tab) {
        var index = this.getIndex(tab);
        this.tabs.splice(index, 1);
    };
    /**
     * Select a certain tab.
     *
     * @param {number} index The index of the tab to select.
     */
    CoreTabsComponent.prototype.selectTab = function (index) {
        if (index == this.selected) {
            // Already selected.
            return;
        }
        if (index < 0 || index >= this.tabs.length) {
            // Index isn't valid, select the first one.
            index = 0;
        }
        var currentTab = this.getSelected(), newTab = this.tabs[index];
        if (!newTab.enabled || !newTab.show) {
            // The tab isn't enabled or shown, stop.
            return;
        }
        if (currentTab) {
            // Unselect previous selected tab.
            currentTab.unselectTab();
        }
        this.selected = index;
        newTab.selectTab();
        this.ionChange.emit(newTab);
    };
    /**
     * Sort the tabs, keeping the same order as in the original list.
     */
    CoreTabsComponent.prototype.sortTabs = function () {
        var _this = this;
        if (this.originalTabsContainer) {
            var newTabs_1 = [];
            this.tabs.forEach(function (tab, index) {
                var originalIndex = Array.prototype.indexOf.call(_this.originalTabsContainer.children, tab.element);
                if (originalIndex != -1) {
                    newTabs_1[originalIndex] = tab;
                }
            });
            this.tabs = newTabs_1;
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreTabsComponent.prototype, "selectedIndex", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreTabsComponent.prototype, "hideUntil", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreTabsComponent.prototype, "ionChange", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])('originalTabs'),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */])
    ], CoreTabsComponent.prototype, "originalTabsRef", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])('topTabs'),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */])
    ], CoreTabsComponent.prototype, "topTabs", void 0);
    CoreTabsComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-tabs',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/components/tabs/tabs.html"*/'<core-loading [hideUntil]="hideUntil" class="core-loading-center">\n    <div class="core-tabs-bar" #topTabs>\n        <ng-container *ngFor="let tab of tabs; let idx = index">\n            <a *ngIf="tab.show" [attr.aria-selected]="selected == idx" (click)="selectTab(idx)">\n                <ion-icon *ngIf="tab.icon" [name]="tab.icon"></ion-icon>\n                <span *ngIf="tab.title">{{ tab.title }}</span>\n                <ion-badge *ngIf="tab.badge" [color]="tab.badgeStyle" class="tab-badge">{{tab.badge}}</ion-badge>\n            </a>\n        </ng-container>\n    </div>\n    <div class="core-tabs-content-container" #originalTabs>\n        <ng-content></ng-content>\n    </div>\n</core-loading>'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/components/tabs/tabs.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["e" /* Content */]])
    ], CoreTabsComponent);
    return CoreTabsComponent;
}());

//# sourceMappingURL=tabs.js.map

/***/ }),
/* 589 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreGroupsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__sites__ = __webpack_require__(3);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/*
 * Service to handle groups.
*/
var CoreGroupsProvider = /** @class */ (function () {
    function CoreGroupsProvider(sitesProvider, translate) {
        this.sitesProvider = sitesProvider;
        this.translate = translate;
        this.ROOT_CACHE_KEY = 'mmGroups:';
    }
    CoreGroupsProvider_1 = CoreGroupsProvider;
    /**
     * Check if group mode of an activity is enabled.
     *
     * @param {number} cmId Course module ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with true if the activity has groups, resolved with false otherwise.
     */
    CoreGroupsProvider.prototype.activityHasGroups = function (cmId, siteId) {
        return this.getActivityGroupMode(cmId, siteId).then(function (groupmode) {
            return groupmode === CoreGroupsProvider_1.SEPARATEGROUPS || groupmode === CoreGroupsProvider_1.VISIBLEGROUPS;
        }).catch(function () {
            return false;
        });
    };
    /**
     * Get the groups allowed in an activity.
     *
     * @param {number} cmId Course module ID.
     * @param {number} [userId] User ID. If not defined, use current user.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the groups are retrieved.
     */
    CoreGroupsProvider.prototype.getActivityAllowedGroups = function (cmId, userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            var params = {
                cmid: cmId,
                userid: userId
            }, preSets = {
                cacheKey: _this.getActivityAllowedGroupsCacheKey(cmId, userId)
            };
            return site.read('core_group_get_activity_allowed_groups', params, preSets).then(function (response) {
                if (!response || !response.groups) {
                    return Promise.reject(null);
                }
                return response.groups;
            });
        });
    };
    /**
     * Get cache key for group mode WS calls.
     *
     * @param {number} cmId Course module ID.
     * @param {number} userId User ID.
     * @return {string} Cache key.
     */
    CoreGroupsProvider.prototype.getActivityAllowedGroupsCacheKey = function (cmId, userId) {
        return this.ROOT_CACHE_KEY + 'allowedgroups:' + cmId + ':' + userId;
    };
    /**
     * Get the groups allowed in an activity if they are allowed.
     *
     * @param {number} cmId Course module ID.
     * @param {number} [userId] User ID. If not defined, use current user.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved when the groups are retrieved. If not allowed, empty array will be returned.
     */
    CoreGroupsProvider.prototype.getActivityAllowedGroupsIfEnabled = function (cmId, userId, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        // Get real groupmode, in case it's forced by the course.
        return this.activityHasGroups(cmId, siteId).then(function (hasGroups) {
            if (hasGroups) {
                // Get the groups available for the user.
                return _this.getActivityAllowedGroups(cmId, userId, siteId);
            }
            return [];
        });
    };
    /**
     * Helper function to get activity group info (group mode and list of groups).
     *
     * @param {number} cmId Course module ID.
     * @param {boolean} [addAllParts=true] Whether to add the all participants option. Always true for visible groups.
     * @param {number} [userId] User ID. If not defined, use current user.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<CoreGroupInfo>} Promise resolved with the group info.
     */
    CoreGroupsProvider.prototype.getActivityGroupInfo = function (cmId, addAllParts, userId, siteId) {
        var _this = this;
        if (addAllParts === void 0) { addAllParts = true; }
        var groupInfo = {
            groups: []
        };
        return this.getActivityGroupMode(cmId, siteId).then(function (groupMode) {
            groupInfo.separateGroups = groupMode === CoreGroupsProvider_1.SEPARATEGROUPS;
            groupInfo.visibleGroups = groupMode === CoreGroupsProvider_1.VISIBLEGROUPS;
            if (groupInfo.separateGroups || groupInfo.visibleGroups) {
                return _this.getActivityAllowedGroups(cmId, userId, siteId);
            }
            return [];
        }).then(function (groups) {
            if (groups.length <= 0) {
                groupInfo.separateGroups = false;
                groupInfo.visibleGroups = false;
            }
            else {
                if (addAllParts || groupInfo.visibleGroups) {
                    groupInfo.groups.push({ id: 0, name: _this.translate.instant('core.allparticipants') });
                }
                groupInfo.groups = groupInfo.groups.concat(groups);
            }
            return groupInfo;
        });
    };
    /**
     * Get the group mode of an activity.
     *
     * @param {number} cmId Course module ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<number>} Promise resolved when the group mode is retrieved.
     */
    CoreGroupsProvider.prototype.getActivityGroupMode = function (cmId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var params = {
                cmid: cmId
            }, preSets = {
                cacheKey: _this.getActivityGroupModeCacheKey(cmId)
            };
            return site.read('core_group_get_activity_groupmode', params, preSets).then(function (response) {
                if (!response || typeof response.groupmode == 'undefined') {
                    return Promise.reject(null);
                }
                return response.groupmode;
            });
        });
    };
    /**
     * Get cache key for group mode WS calls.
     *
     * @param {number} cmId Course module ID.
     * @return {string} Cache key.
     */
    CoreGroupsProvider.prototype.getActivityGroupModeCacheKey = function (cmId) {
        return this.ROOT_CACHE_KEY + 'groupmode:' + cmId;
    };
    /**
     * Get user groups in all the supplied courses.
     *
     * @param {any[]} courses List of courses or course ids to get the groups from.
     * @param {string} [siteId] Site to get the groups from. If not defined, use current site.
     * @param {number} [userId] ID of the user. If not defined, use the userId related to siteId.
     * @return {Promise<any[]>} Promise resolved when the groups are retrieved.
     */
    CoreGroupsProvider.prototype.getUserGroups = function (courses, siteId, userId) {
        var _this = this;
        var promises = [];
        var groups = [];
        courses.forEach(function (course) {
            var courseId = typeof course == 'object' ? course.id : course;
            promises.push(_this.getUserGroupsInCourse(courseId, siteId, userId).then(function (courseGroups) {
                groups = groups.concat(courseGroups);
            }));
        });
        return Promise.all(promises).then(function () {
            return groups;
        });
    };
    /**
     * Get user groups in a course.
     *
     * @param {number} courseId ID of the course.
     * @param {string} [siteId] Site to get the groups from. If not defined, use current site.
     * @param {number} [userId] ID of the user. If not defined, use ID related to siteid.
     * @return {Promise<any[]>} Promise resolved when the groups are retrieved.
     */
    CoreGroupsProvider.prototype.getUserGroupsInCourse = function (courseId, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var data = {
                userid: userId || site.getUserId(),
                courseid: courseId
            }, preSets = {
                cacheKey: _this.getUserGroupsInCourseCacheKey(courseId, userId)
            };
            return site.read('core_group_get_course_user_groups', data, preSets).then(function (response) {
                if (response && response.groups) {
                    return response.groups;
                }
                else {
                    return Promise.reject(null);
                }
            });
        });
    };
    /**
     * Get cache key for user groups in course WS calls.
     *
     * @param {number} courseId Course ID.
     * @param {number} userId User ID.
     * @return {string} Cache key.
     */
    CoreGroupsProvider.prototype.getUserGroupsInCourseCacheKey = function (courseId, userId) {
        return this.ROOT_CACHE_KEY + 'courseGroups:' + courseId + ':' + userId;
    };
    /**
     * Invalidates activity allowed groups.
     *
     * @param {number} cmId Course module ID.
     * @param {number} [userId] User ID. If not defined, use current user.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreGroupsProvider.prototype.invalidateActivityAllowedGroups = function (cmId, userId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(_this.getActivityAllowedGroupsCacheKey(cmId, userId));
        });
    };
    /**
     * Invalidates activity group mode.
     *
     * @param {number} cmId Course module ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreGroupsProvider.prototype.invalidateActivityGroupMode = function (cmId, siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            return site.invalidateWsCacheForKey(_this.getActivityGroupModeCacheKey(cmId));
        });
    };
    /**
     * Invalidates all activity group info: mode and allowed groups.
     *
     * @param {number} cmId Course module ID.
     * @param {number} [userId] User ID. If not defined, use current user.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreGroupsProvider.prototype.invalidateActivityGroupInfo = function (cmId, userId, siteId) {
        var promises = [];
        promises.push(this.invalidateActivityAllowedGroups(cmId, userId, siteId));
        promises.push(this.invalidateActivityGroupMode(cmId, siteId));
        return Promise.all(promises);
    };
    /**
     * Invalidates user groups in courses.
     *
     * @param {any[]} courses List of courses or course ids.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined, use current user.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreGroupsProvider.prototype.invalidateUserGroups = function (courses, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var promises = [];
            userId = userId || site.getUserId();
            courses.forEach(function (course) {
                var courseId = typeof course == 'object' ? course.id : course;
                promises.push(_this.invalidateUserGroupsInCourse(courseId, site.id, userId));
            });
            return Promise.all(promises);
        });
    };
    /**
     * Invalidates user groups in course.
     *
     * @param {number} courseId Course ID.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [userId] User ID. If not defined, use current user.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreGroupsProvider.prototype.invalidateUserGroupsInCourse = function (courseId, siteId, userId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(_this.getUserGroupsInCourseCacheKey(courseId, userId));
        });
    };
    // Group mode constants.
    CoreGroupsProvider.NOGROUPS = 0;
    CoreGroupsProvider.SEPARATEGROUPS = 1;
    CoreGroupsProvider.VISIBLEGROUPS = 2;
    CoreGroupsProvider = CoreGroupsProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
    ], CoreGroupsProvider);
    return CoreGroupsProvider;
    var CoreGroupsProvider_1;
}());

//# sourceMappingURL=groups.js.map

/***/ }),
/* 590 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonCompetencyCourseComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_competency__ = __webpack_require__(112);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_helper__ = __webpack_require__(288);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






/**
 * Component that displays the competencies of a course.
 */
var AddonCompetencyCourseComponent = /** @class */ (function () {
    function AddonCompetencyCourseComponent(navCtrl, appProvider, domUtils, competencyProvider, helperProvider) {
        this.navCtrl = navCtrl;
        this.appProvider = appProvider;
        this.domUtils = domUtils;
        this.competencyProvider = competencyProvider;
        this.helperProvider = helperProvider;
        this.competenciesLoaded = false;
    }
    /**
     * View loaded.
     */
    AddonCompetencyCourseComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.fetchCourseCompetencies().finally(function () {
            _this.competenciesLoaded = true;
        });
    };
    /**
     * Fetches the competencies and updates the view.
     *
     * @return {Promise<void>} Promise resolved when done.
     */
    AddonCompetencyCourseComponent.prototype.fetchCourseCompetencies = function () {
        var _this = this;
        return this.competencyProvider.getCourseCompetencies(this.courseId, this.userId).then(function (competencies) {
            _this.competencies = competencies;
            // Get the user profile image.
            _this.helperProvider.getProfile(_this.userId).then(function (user) {
                _this.user = user;
            });
        }).catch(function (message) {
            _this.domUtils.showErrorModalDefault(message, 'Error getting course competencies data.');
        });
    };
    /**
     * Opens a competency.
     *
     * @param {number} competencyId
     */
    AddonCompetencyCourseComponent.prototype.openCompetency = function (competencyId) {
        if (this.appProvider.isWide()) {
            this.navCtrl.push('AddonCompetencyCompetenciesPage', { competencyId: competencyId, courseId: this.courseId, userId: this.userId });
        }
        else {
            this.navCtrl.push('AddonCompetencyCompetencyPage', { competencyId: competencyId, courseId: this.courseId, userId: this.userId });
        }
    };
    /**
     * Opens the summary of a competency.
     *
     * @param {number} competencyId
     */
    AddonCompetencyCourseComponent.prototype.openCompetencySummary = function (competencyId) {
        this.navCtrl.push('AddonCompetencyCompetencySummaryPage', { competencyId: competencyId });
    };
    /**
     * Refreshes the competencies.
     *
     * @param {any} refresher Refresher.
     */
    AddonCompetencyCourseComponent.prototype.refreshCourseCompetencies = function (refresher) {
        var _this = this;
        this.competencyProvider.invalidateCourseCompetencies(this.courseId, this.userId).finally(function () {
            _this.fetchCourseCompetencies().finally(function () {
                refresher.complete();
            });
        });
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])(__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["e" /* Content */]),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["e" /* Content */])
    ], AddonCompetencyCourseComponent.prototype, "content", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], AddonCompetencyCourseComponent.prototype, "courseId", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], AddonCompetencyCourseComponent.prototype, "userId", void 0);
    AddonCompetencyCourseComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'addon-competency-course',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/addon/competency/components/course/course.html"*/'<ion-content>\n    <ion-refresher [enabled]="competenciesLoaded" (ionRefresh)="refreshCourseCompetencies($event)">\n        <ion-refresher-content pullingText="{{ \'core.pulltorefresh\' | translate }}"></ion-refresher-content>\n    </ion-refresher>\n    <core-loading [hideUntil]="competenciesLoaded">\n        <ion-card *ngIf="!user && competencies && competencies.statistics.competencycount > 0">\n            <ion-item text-wrap *ngIf="competencies.settings.pushratingstouserplans">\n                {{ \'addon.competency.coursecompetencyratingsarepushedtouserplans\' | translate }}\n            </ion-item>\n            <ion-item text-wrap *ngIf="!competencies.settings.pushratingstouserplans">\n                {{ \'addon.competency.coursecompetencyratingsarenotpushedtouserplans\' | translate }}\n            </ion-item>\n            <ion-item text-wrap>\n                <strong>{{ \'addon.competency.progress\' | translate }}</strong>:\n                {{ \'addon.competency.xcompetenciesproficientoutofyincourse\' | translate:{$a: {x: competencies.statistics.proficientcompetencycount, y: competencies.statistics.competencycount} } }} ({{ competencies.statistics.proficientcompetencypercentageformatted }}%)\n                <core-progress-bar [progress]="competencies.statistics.proficientcompetencypercentage"></core-progress-bar>\n            </ion-item>\n            <ion-item text-wrap *ngIf="competencies.statistics.leastproficientcount > 0">\n                <strong>{{ \'addon.competency.competenciesmostoftennotproficientincourse\' | translate }}</strong>:\n                <p *ngFor="let comp of competencies.statistics.leastproficient">\n                    <a (click)="openCompetencySummary(comp.id)">\n                        {{ comp.shortname }} - {{ comp.idnumber }}\n                    </a>\n                </p>\n            </ion-item>\n        </ion-card>\n\n        <h3 margin-horizontal *ngIf="competencies && competencies.statistics.competencycount > 0">{{ \'addon.competency.competencies\' | translate }}</h3>\n        <ion-card *ngIf="user">\n             <ion-item text-wrap>\n                <ion-avatar *ngIf="user.profileimageurl && user.profileimageurl !== true" item-start>\n                    <img  [src]="user.profileimageurl" [alt]="\'core.pictureof\' | translate:{$a: user.fullname}" core-external-content>\n                </ion-avatar>\n                <span *ngIf="user.profileimageurl === true" item-start>\n                    <ion-icon name="person"></ion-icon>\n                </span>\n                <h2><core-format-text [text]="user.fullname"></core-format-text></h2>\n            </ion-item>\n        </ion-card>\n        <core-empty-box *ngIf="competencies && competencies.statistics.competencycount == 0" icon="ribbon" message="{{ \'addon.competency.nocompetencies\' | translate }}"></core-empty-box>\n\n        <div *ngIf="competencies">\n            <ion-card *ngFor="let competency of competencies.competencies">\n                <a ion-item text-wrap (click)="openCompetency(competency.competency.id)" [title]="competency.competency.shortname">\n                    {{competency.competency.shortname}} <small>{{competency.competency.idnumber}}</small>\n                    <ion-badge item-end *ngIf="competency.usercompetencycourse && competency.usercompetencycourse.gradename" [color]="competency.usercompetencycourse.proficiency ? \'success\' : \'danger\'">{{ competency.usercompetencycourse.gradename }}</ion-badge>\n                </a>\n                <ion-item text-wrap>\n                    <div *ngIf="competency.competency.description">\n                        <core-format-text [text]=" competency.competency.description "></core-format-text>\n                    </div>\n                    <div>\n                        <strong>{{ \'addon.competency.path\' | translate }}</strong>:\n                        {{ competency.comppath.framework.name }}\n                        <span *ngFor="let ancestor of competency.comppath.ancestors">\n                            &nbsp;/&nbsp;<a (click)="openCompetencySummary(ancestor.id)">{{ ancestor.name }}</a>\n                        </span>\n                    </div>\n                    <div>\n                        <strong>{{ \'addon.competency.activities\' | translate }}</strong>:\n                        <span *ngIf="competency.coursemodules.length == 0">\n                            {{ \'addon.competency.noactivities\' | translate }}\n                        </span>\n                        <a ion-item text-wrap *ngFor="let activity of competency.coursemodules" [href]="activity.url" [title]="activity.name">\n                            <img item-start [src]="activity.iconurl" core-external-content alt="" role="presentation" *ngIf="activity.iconurl" class="core-module-icon">\n                            <core-format-text [text]="activity.name"></core-format-text>\n                        </a>\n                    </div>\n                </ion-item>\n            </ion-card>\n        </div>\n    </core-loading>\n</ion-content>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/addon/competency/components/course/course.html"*/,
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavController */], __WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_competency__["a" /* AddonCompetencyProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_helper__["a" /* AddonCompetencyHelperProvider */]])
    ], AddonCompetencyCourseComponent);
    return AddonCompetencyCourseComponent;
}());

//# sourceMappingURL=course.js.map

/***/ }),
/* 591 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSyncBaseProvider; });
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * Base class to create sync providers. It provides some common functions.
 */
var CoreSyncBaseProvider = /** @class */ (function () {
    function CoreSyncBaseProvider(component, sitesProvider, loggerProvider, appProvider, syncProvider, textUtils) {
        this.sitesProvider = sitesProvider;
        this.loggerProvider = loggerProvider;
        this.appProvider = appProvider;
        this.syncProvider = syncProvider;
        this.textUtils = textUtils;
        /**
         * Component of the sync provider.
         * @type {string}
         */
        this.component = 'core';
        /**
         * Sync provider's interval.
         * @type {number}
         */
        this.syncInterval = 300000;
        // Store sync promises.
        this.syncPromises = {};
        this.logger = this.loggerProvider.getInstance(component);
        this.component = component;
    }
    /**
     * Add an ongoing sync to the syncPromises list. On finish the promise will be removed.
     *
     * @param {string | number} id Unique sync identifier per component.
     * @param {Promise<any>} promise The promise of the sync to add.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} The sync promise.
     */
    CoreSyncBaseProvider.prototype.addOngoingSync = function (id, promise, siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var uniqueId = this.getUniqueSyncId(id);
        if (!this.syncPromises[siteId]) {
            this.syncPromises[siteId] = {};
        }
        this.syncPromises[siteId][uniqueId] = promise;
        // Promise will be deleted when finish.
        return promise.finally(function () {
            delete _this.syncPromises[siteId][uniqueId];
        });
    };
    /**
     * If there's an ongoing sync for a certain identifier return it.
     *
     * @param {string | number} id Unique sync identifier per component.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise of the current sync or undefined if there isn't any.
     */
    CoreSyncBaseProvider.prototype.getOngoingSync = function (id, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (this.isSyncing(id, siteId)) {
            // There's already a sync ongoing for this discussion, return the promise.
            var uniqueId = this.getUniqueSyncId(id);
            return this.syncPromises[siteId][uniqueId];
        }
    };
    /**
     * Get the synchronization time. Returns 0 if no time stored.
     *
     * @param {string | number} id Unique sync identifier per component.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<number>} Promise resolved with the time.
     */
    CoreSyncBaseProvider.prototype.getSyncTime = function (id, siteId) {
        return this.syncProvider.getSyncRecord(this.component, id, siteId).then(function (entry) {
            return entry.time;
        }).catch(function () {
            return 0;
        });
    };
    /**
     * Get the synchronization warnings of an instance.
     *
     * @param {string | number} id Unique sync identifier per component.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<string[]>} Promise resolved with the warnings.
     */
    CoreSyncBaseProvider.prototype.getSyncWarnings = function (id, siteId) {
        var _this = this;
        return this.syncProvider.getSyncRecord(this.component, id, siteId).then(function (entry) {
            return _this.textUtils.parseJSON(entry.warnings, []);
        }).catch(function () {
            return [];
        });
    };
    /**
     * Create a unique identifier from component and id.
     *
     * @param {string | number} id Unique sync identifier per component.
     * @return {string} Unique identifier from component and id.
     */
    CoreSyncBaseProvider.prototype.getUniqueSyncId = function (id) {
        return this.component + '#' + id;
    };
    /**
     * Check if a there's an ongoing syncronization for the given id.
     *
     * @param {string | number} id Unique sync identifier per component.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {boolean} Whether it's synchronizing.
     */
    CoreSyncBaseProvider.prototype.isSyncing = function (id, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var uniqueId = this.getUniqueSyncId(id);
        return !!(this.syncPromises[siteId] && this.syncPromises[siteId][uniqueId]);
    };
    /**
     * Check if a sync is needed: if a certain time has passed since the last time.
     *
     * @param {string} id Unique sync identifier per component.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<boolean>} Promise resolved with boolean: whether sync is needed.
     */
    CoreSyncBaseProvider.prototype.isSyncNeeded = function (id, siteId) {
        var _this = this;
        return this.getSyncTime(id, siteId).then(function (time) {
            return Date.now() - _this.syncInterval >= time;
        });
    };
    /**
     * Set the synchronization time.
     *
     * @param {string | number} id Unique sync identifier per component.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {number} [time] Time to set. If not defined, current time.
     * @return {Promise<any>} Promise resolved when the time is set.
     */
    CoreSyncBaseProvider.prototype.setSyncTime = function (id, siteId, time) {
        time = typeof time != 'undefined' ? time : Date.now();
        return this.syncProvider.insertOrUpdateSyncRecord(this.component, id, { time: time }, siteId);
    };
    /**
     * Set the synchronization warnings.
     *
     * @param {string} id Unique sync identifier per component.
     * @param {string[]} warnings Warnings to set.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreSyncBaseProvider.prototype.setSyncWarnings = function (id, warnings, siteId) {
        var warningsText = JSON.stringify(warnings || []);
        return this.syncProvider.insertOrUpdateSyncRecord(this.component, id, { warnings: warningsText }, siteId);
    };
    /**
     * Execute a sync function on selected sites.
     *
     * @param  {string} syncFunctionLog Log message to explain the sync function purpose.
     * @param  {Function} syncFunction  Sync function to execute.
     * @param  {any[]}    [params]      Array that defines the params that admit the funcion.
     * @param  {string} [siteId]        Site ID to sync. If not defined, sync all sites.
     * @return {Promise<any>}           Resolved with siteIds selected. Rejected if offline.
     */
    CoreSyncBaseProvider.prototype.syncOnSites = function (syncFunctionLog, syncFunction, params, siteId) {
        if (!this.appProvider.isOnline()) {
            this.logger.debug("Cannot sync '" + syncFunctionLog + "' because device is offline.");
            return Promise.reject(null);
        }
        var promise;
        if (!siteId) {
            // No site ID defined, sync all sites.
            this.logger.debug("Try to sync '" + syncFunctionLog + "' in all sites.");
            promise = this.sitesProvider.getSitesIds();
        }
        else {
            this.logger.debug("Try to sync '" + syncFunctionLog + "' in site '" + siteId + "'.");
            promise = Promise.resolve([siteId]);
        }
        params = params || [];
        return promise.then(function (siteIds) {
            var sitePromises = [];
            siteIds.forEach(function (siteId) {
                // Execute function for every site selected.
                sitePromises.push(syncFunction.apply(syncFunction, [siteId].concat(params)));
            });
            return Promise.all(sitePromises);
        });
    };
    /**
     * If there's an ongoing sync for a certain identifier, wait for it to end.
     * If there's no sync ongoing the promise will be resolved right away.
     *
     * @param {string | number} id Unique sync identifier per component.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any>} Promise resolved when there's no sync going on for the identifier.
     */
    CoreSyncBaseProvider.prototype.waitForSync = function (id, siteId) {
        var promise = this.getOngoingSync(id, siteId);
        if (promise) {
            return promise.catch(function () {
                // Ignore errors.
            });
        }
        return Promise.resolve();
    };
    return CoreSyncBaseProvider;
}());

//# sourceMappingURL=base-sync.js.map

/***/ }),
/* 592 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSyncProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__events__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__sites__ = __webpack_require__(3);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/*
 * Service that provides some features regarding synchronization.
*/
var CoreSyncProvider = /** @class */ (function () {
    function CoreSyncProvider(eventsProvider, sitesProvider) {
        var _this = this;
        this.sitesProvider = sitesProvider;
        // Variables for the database.
        this.SYNC_TABLE = 'sync';
        this.tableSchema = {
            name: this.SYNC_TABLE,
            columns: [
                {
                    name: 'component',
                    type: 'TEXT',
                    notNull: true
                },
                {
                    name: 'id',
                    type: 'TEXT',
                    notNull: true
                },
                {
                    name: 'time',
                    type: 'INTEGER'
                },
                {
                    name: 'warnings',
                    type: 'TEXT'
                }
            ],
            primaryKeys: ['component', 'id']
        };
        // Store blocked sync objects.
        this.blockedItems = {};
        this.sitesProvider.createTableFromSchema(this.tableSchema);
        // Unblock all blocks on logout.
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_1__events__["a" /* CoreEventsProvider */].LOGOUT, function (data) {
            _this.clearAllBlocks(data.siteId);
        });
    }
    /**
     * Block a component and ID so it cannot be synchronized.
     *
     * @param {string} component Component name.
     * @param {number} id Unique ID per component.
     * @param {string} [operation] Operation name. If not defined, a default text is used.
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    CoreSyncProvider.prototype.blockOperation = function (component, id, operation, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var uniqueId = this.getUniqueSyncBlockId(component, id);
        if (!this.blockedItems[siteId]) {
            this.blockedItems[siteId] = {};
        }
        if (!this.blockedItems[siteId][uniqueId]) {
            this.blockedItems[siteId][uniqueId] = {};
        }
        operation = operation || '-';
        this.blockedItems[siteId][uniqueId][operation] = true;
    };
    /**
     * Clear all blocks for a site or all sites.
     *
     * @param {string} [siteId] If set, clear the blocked objects only for this site. Otherwise clear them for all sites.
     */
    CoreSyncProvider.prototype.clearAllBlocks = function (siteId) {
        if (siteId) {
            delete this.blockedItems[siteId];
        }
        else {
            this.blockedItems = {};
        }
    };
    /**
     * Clear all blocks for a certain component.
     *
     * @param {string} component Component name.
     * @param {number} id Unique ID per component.
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    CoreSyncProvider.prototype.clearBlocks = function (component, id, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var uniqueId = this.getUniqueSyncBlockId(component, id);
        if (this.blockedItems[siteId]) {
            delete this.blockedItems[siteId][uniqueId];
        }
    };
    /**
     * Returns a sync record.
     * @param  {string}           component Component name.
     * @param  {string | number}  id        Unique ID per component.
     * @param  {string}           [siteId]  Site ID. If not defined, current site.
     * @return {Promise<any>}     Record if found or reject.
     */
    CoreSyncProvider.prototype.getSyncRecord = function (component, id, siteId) {
        var _this = this;
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            return db.getRecord(_this.SYNC_TABLE, { component: component, id: id });
        });
    };
    /**
     * Inserts or Updates info of a sync record.
     * @param  {string}           component Component name.
     * @param  {string | number}  id        Unique ID per component.
     * @param  {any}              data      Data that updates the record.
     * @param  {string}           [siteId]  Site ID. If not defined, current site.
     * @return {Promise<any>}     Promise resolved with done.
     */
    CoreSyncProvider.prototype.insertOrUpdateSyncRecord = function (component, id, data, siteId) {
        var _this = this;
        return this.sitesProvider.getSiteDb(siteId).then(function (db) {
            data.component = component;
            data.id = id;
            return db.insertOrUpdateRecord(_this.SYNC_TABLE, data, { component: component, id: id });
        });
    };
    /**
     * Convenience function to create unique identifiers for a component and id.
     *
     * @param {string} component Component name.
     * @param {number} id Unique ID per component.
     * @return {string} Unique sync id.
     */
    CoreSyncProvider.prototype.getUniqueSyncBlockId = function (component, id) {
        return component + '#' + id;
    };
    /**
     * Check if a component is blocked.
     * One block can have different operations. Here we check how many operations are being blocking the object.
     *
     * @param {string} component Component name.
     * @param {number} id Unique ID per component.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {boolean} Whether it's blocked.
     */
    CoreSyncProvider.prototype.isBlocked = function (component, id, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (!this.blockedItems[siteId]) {
            return false;
        }
        var uniqueId = this.getUniqueSyncBlockId(component, id);
        if (!this.blockedItems[siteId][uniqueId]) {
            return false;
        }
        return Object.keys(this.blockedItems[siteId][uniqueId]).length > 0;
    };
    /**
     * Unblock an operation on a component and ID.
     *
     * @param {string} component Component name.
     * @param {number} id Unique ID per component.
     * @param {string} [operation] Operation name. If not defined, a default text is used.
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    CoreSyncProvider.prototype.unblockOperation = function (component, id, operation, siteId) {
        operation = operation || '-';
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var uniqueId = this.getUniqueSyncBlockId(component, id);
        if (this.blockedItems[siteId] && this.blockedItems[siteId][uniqueId]) {
            delete this.blockedItems[siteId][uniqueId][operation];
        }
    };
    CoreSyncProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_2__sites__["a" /* CoreSitesProvider */]])
    ], CoreSyncProvider);
    return CoreSyncProvider;
}());

//# sourceMappingURL=sync.js.map

/***/ }),
/* 593 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCache; });
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * A cache to store values in memory to speed up processes.
 *
 * The data is organized by "entries" that are identified by an ID. Each entry can have multiple values stored,
 * and each value has its own timemodified.
 *
 * Values expire after a certain time.
 */
var CoreCache = /** @class */ (function () {
    function CoreCache() {
        this.cacheStore = {};
        // Nothing to do.
    }
    /**
     * Clear the cache.
     */
    CoreCache.prototype.clear = function () {
        this.cacheStore = {};
    };
    /**
     * Get all the data stored in the cache for a certain id.
     *
     * @param {any} id The ID to identify the entry.
     * @return {any} The data from the cache. Undefined if not found.
     */
    CoreCache.prototype.getEntry = function (id) {
        if (!this.cacheStore[id]) {
            this.cacheStore[id] = {};
        }
        return this.cacheStore[id];
    };
    /**
     * Get the status of a module from the "cache".
     *
     * @param {any} id The ID to identify the entry.
     * @param {string} name Name of the value to get.
     * @param {boolean} [ignoreInvalidate] Whether it should always return the cached data, even if it's expired.
     * @return {any} Cached value. Undefined if not cached or expired.
     */
    CoreCache.prototype.getValue = function (id, name, ignoreInvalidate) {
        var entry = this.getEntry(id);
        if (entry[name] && typeof entry[name].value != 'undefined') {
            var now = Date.now();
            // Invalidate after 5 minutes.
            if (ignoreInvalidate || entry[name].timemodified + 300000 >= now) {
                return entry[name].value;
            }
        }
        return undefined;
    };
    /**
     * Invalidate all the cached data for a certain entry.
     *
     * @param {any} id The ID to identify the entry.
     */
    CoreCache.prototype.invalidate = function (id) {
        var entry = this.getEntry(id);
        for (var name_1 in entry) {
            entry[name_1].timemodified = 0;
        }
    };
    /**
     * Update the status of a module in the "cache".
     *
     * @param {any} id The ID to identify the entry.
     * @param {string} name Name of the value to set.
     * @param {any} value Value to set.
     * @return {any} The set value.
     */
    CoreCache.prototype.setValue = function (id, name, value) {
        var entry = this.getEntry(id);
        entry[name] = {
            value: value,
            timemodified: Date.now()
        };
        return value;
    };
    return CoreCache;
}());

//# sourceMappingURL=cache.js.map

/***/ }),
/* 594 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseFormatDefaultHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_courses_providers_courses__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__course__ = __webpack_require__(14);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Default handler used when the course format doesn't have a specific implementation.
 */
var CoreCourseFormatDefaultHandler = /** @class */ (function () {
    function CoreCourseFormatDefaultHandler(coursesProvider) {
        this.coursesProvider = coursesProvider;
        this.name = 'default';
    }
    /**
     * Whether or not the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} True or promise resolved with true if enabled.
     */
    CoreCourseFormatDefaultHandler.prototype.isEnabled = function () {
        return true;
    };
    /**
     * Get the title to use in course page.
     *
     * @param {any} course The course.
     * @return {string} Title.
     */
    CoreCourseFormatDefaultHandler.prototype.getCourseTitle = function (course) {
        return course.fullname || '';
    };
    /**
     * Whether it allows seeing all sections at the same time. Defaults to true.
     *
     * @param {any} course The course to check.
     * @type {boolean} Whether it can view all sections.
     */
    CoreCourseFormatDefaultHandler.prototype.canViewAllSections = function (course) {
        return true;
    };
    /**
     * Whether the option to enable section/module download should be displayed. Defaults to true.
     *
     * @param {any} course The course to check.
     * @return {boolean} Whether the option to enable section/module download should be displayed
     */
    CoreCourseFormatDefaultHandler.prototype.displayEnableDownload = function (course) {
        return true;
    };
    /**
     * Whether the default section selector should be displayed. Defaults to true.
     *
     * @param {any} course The course to check.
     * @type {boolean} Whether the default section selector should be displayed.
     */
    CoreCourseFormatDefaultHandler.prototype.displaySectionSelector = function (course) {
        return true;
    };
    /**
     * Given a list of sections, get the "current" section that should be displayed first.
     *
     * @param {any} course The course to get the title.
     * @param {any[]} sections List of sections.
     * @return {any|Promise<any>} Current section (or promise resolved with current section).
     */
    CoreCourseFormatDefaultHandler.prototype.getCurrentSection = function (course, sections) {
        // We need the "marker" to determine the current section.
        return this.coursesProvider.getCoursesByField('id', course.id).catch(function () {
            // Ignore errors.
        }).then(function (courses) {
            if (courses && courses[0]) {
                // Find the marked section.
                var course_1 = courses[0];
                for (var i = 0; i < sections.length; i++) {
                    var section = sections[i];
                    if (section.section == course_1.marker) {
                        return section;
                    }
                }
            }
            // Marked section not found or we couldn't retrieve the marker. Return the first section.
            for (var i = 0; i < sections.length; i++) {
                var section = sections[i];
                if (section.id != __WEBPACK_IMPORTED_MODULE_2__course__["a" /* CoreCourseProvider */].ALL_SECTIONS_ID) {
                    return section;
                }
            }
            return Promise.reject(null);
        });
    };
    /**
     * Invalidate the data required to load the course format.
     *
     * @param {any} course The course to get the title.
     * @param {any[]} sections List of sections.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreCourseFormatDefaultHandler.prototype.invalidateData = function (course, sections) {
        return this.coursesProvider.invalidateCoursesByField('id', course.id);
    };
    /**
     * Open the page to display a course. If not defined, the page CoreCourseSectionPage will be opened.
     * Implement it only if you want to create your own page to display the course. In general it's better to use the method
     * getCourseFormatComponent because it will display the course handlers at the top.
     * Your page should include the course handlers using CoreCoursesDelegate.
     *
     * @param {NavController} navCtrl The NavController instance to use.
     * @param {any} course The course to open. It should contain a "format" attribute.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseFormatDefaultHandler.prototype.openCourse = function (navCtrl, course) {
        return navCtrl.push('CoreCourseSectionPage', { course: course });
    };
    CoreCourseFormatDefaultHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__core_courses_providers_courses__["a" /* CoreCoursesProvider */]])
    ], CoreCourseFormatDefaultHandler);
    return CoreCourseFormatDefaultHandler;
}());

//# sourceMappingURL=default-format.js.map

/***/ }),
/* 595 */,
/* 596 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModBookPrefetchHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_course_classes_module_prefetch_handler__ = __webpack_require__(106);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__book__ = __webpack_require__(131);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Handler to prefetch books.
 */
var AddonModBookPrefetchHandler = /** @class */ (function (_super) {
    __extends(AddonModBookPrefetchHandler, _super);
    function AddonModBookPrefetchHandler(injector, bookProvider) {
        var _this = _super.call(this, injector) || this;
        _this.bookProvider = bookProvider;
        _this.name = 'book';
        _this.component = __WEBPACK_IMPORTED_MODULE_2__book__["a" /* AddonModBookProvider */].COMPONENT;
        _this.updatesNames = /^configuration$|^.*files$|^entries$/;
        _this.isResource = true;
        return _this;
    }
    /**
     * Download or prefetch the content.
     *
     * @param {any} module The module object returned by WS.
     * @param {number} courseId Course ID.
     * @param {boolean} [prefetch] True to prefetch, false to download right away.
     * @param {string} [dirPath] Path of the directory where to store all the content files. This is to keep the files
     *                           relative paths and make the package work in an iframe. Undefined to download the files
     *                           in the filepool root folder.
     * @return {Promise<any>} Promise resolved when all content is downloaded. Data returned is not reliable.
     */
    AddonModBookPrefetchHandler.prototype.downloadOrPrefetch = function (module, courseId, prefetch, dirPath) {
        var promises = [];
        promises.push(_super.prototype.downloadOrPrefetch.call(this, module, courseId, prefetch));
        promises.push(this.bookProvider.getBook(courseId, module.id).catch(function () {
            // Ignore errors since this WS isn't available in some Moodle versions.
        }));
        return Promise.all(promises);
    };
    /**
     * Returns module intro files.
     *
     * @param {any} module The module object returned by WS.
     * @param {number} courseId Course ID.
     * @return {Promise<any[]>} Promise resolved with list of intro files.
     */
    AddonModBookPrefetchHandler.prototype.getIntroFiles = function (module, courseId) {
        var _this = this;
        return this.bookProvider.getBook(courseId, module.id).catch(function () {
            // Not found, return undefined so module description is used.
        }).then(function (book) {
            return _this.getIntroFilesFromInstance(module, book);
        });
    };
    /**
     * Invalidate the prefetched content.
     *
     * @param {number} moduleId The module ID.
     * @param {number} courseId Course ID the module belongs to.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModBookPrefetchHandler.prototype.invalidateContent = function (moduleId, courseId) {
        return this.bookProvider.invalidateContent(moduleId, courseId);
    };
    /**
     * Whether or not the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} A boolean, or a promise resolved with a boolean, indicating if the handler is enabled.
     */
    AddonModBookPrefetchHandler.prototype.isEnabled = function () {
        return this.bookProvider.isPluginEnabled();
    };
    AddonModBookPrefetchHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["C" /* Injector */], __WEBPACK_IMPORTED_MODULE_2__book__["a" /* AddonModBookProvider */]])
    ], AddonModBookPrefetchHandler);
    return AddonModBookPrefetchHandler;
}(__WEBPACK_IMPORTED_MODULE_1__core_course_classes_module_prefetch_handler__["a" /* CoreCourseModulePrefetchHandlerBase */]));

//# sourceMappingURL=prefetch-handler.js.map

/***/ }),
/* 597 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModBookTocPopoverComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Component to display the TOC of a book.
 */
var AddonModBookTocPopoverComponent = /** @class */ (function () {
    function AddonModBookTocPopoverComponent(navParams, viewCtrl) {
        this.viewCtrl = viewCtrl;
        this.chapters = navParams.get('chapters') || [];
    }
    /**
     * Function called when a course is clicked.
     *
     * @param {string} id ID of the clicked chapter.
     */
    AddonModBookTocPopoverComponent.prototype.loadChapter = function (id) {
        this.viewCtrl.dismiss(id);
    };
    AddonModBookTocPopoverComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'addon-mod-book-toc-popover',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/addon/mod/book/components/toc-popover/toc-popover.html"*/'<ion-list>\n    <a ion-item text-wrap *ngFor="let chapter of chapters" (click)="loadChapter(chapter.id)" detail-none>\n        <p [attr.padding-left]="chapter.level == 1 ? true : null">{{chapter.title}}</p>\n    </a>\n</ion-list>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/addon/mod/book/components/toc-popover/toc-popover.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["m" /* NavParams */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["s" /* ViewController */]])
    ], AddonModBookTocPopoverComponent);
    return AddonModBookTocPopoverComponent;
}());

//# sourceMappingURL=toc-popover.js.map

/***/ }),
/* 598 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModFolderHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_course_providers_course__ = __webpack_require__(14);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Service that provides some features for folder.
 */
var AddonModFolderHelperProvider = /** @class */ (function () {
    function AddonModFolderHelperProvider(courseProvider) {
        this.courseProvider = courseProvider;
    }
    /**
     * Format folder contents, creating directory structure.
     * Folders found in filepaths are added to the array. Each folder has the properties: name, fileicon,
     * type (folder), filepath and contents (array with files and subfolders).
     *
     * @param {any[]} contents Folder contents.
     * @return {any[]}         Formatted contents.
     */
    AddonModFolderHelperProvider.prototype.formatContents = function (contents) {
        var files = [], folders = [], folderIcon = this.courseProvider.getModuleIconSrc('folder');
        contents.forEach(function (entry) {
            if (entry.filepath !== '/') {
                // It's a file in a subfolder. Lets treat the path to add the subfolders to the array.
                var directories = void 0, currentList_1 = folders, // Start at root level.
                path = entry.filepath, subpath_1 = '';
                // Remove first and last slash if needed.
                if (path.substr(0, 1) === '/') {
                    path = path.substr(1);
                }
                if (path.substr(path.length - 1) === '/') {
                    path = path.slice(0, -1);
                }
                directories = path.split('/');
                directories.forEach(function (directory) {
                    subpath_1 = subpath_1 + '/' + directory;
                    // Search if the directory is already stored in folders array.
                    var foundList = currentList_1.find(function (list) {
                        return list.name === directory;
                    });
                    if (foundList) {
                        currentList_1 = foundList.contents;
                    }
                    else {
                        // Directory not found. Add it to the array.
                        var newFolder = {
                            name: directory,
                            fileicon: folderIcon,
                            contents: [],
                            filepath: subpath_1,
                            type: 'folder'
                        };
                        currentList_1.push(newFolder);
                        currentList_1 = newFolder.contents;
                    }
                });
                currentList_1.push(entry);
            }
            else {
                files.push(entry);
            }
        });
        return folders.concat(files);
    };
    AddonModFolderHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__core_course_providers_course__["a" /* CoreCourseProvider */]])
    ], AddonModFolderHelperProvider);
    return AddonModFolderHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),
/* 599 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModPagePrefetchHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_course_classes_module_prefetch_handler__ = __webpack_require__(106);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__page__ = __webpack_require__(107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__helper__ = __webpack_require__(247);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Handler to prefetch pages.
 */
var AddonModPagePrefetchHandler = /** @class */ (function (_super) {
    __extends(AddonModPagePrefetchHandler, _super);
    function AddonModPagePrefetchHandler(injector, pageProvider, utils, pageHelper) {
        var _this = _super.call(this, injector) || this;
        _this.pageProvider = pageProvider;
        _this.utils = utils;
        _this.pageHelper = pageHelper;
        _this.name = 'page';
        _this.component = __WEBPACK_IMPORTED_MODULE_3__page__["a" /* AddonModPageProvider */].COMPONENT;
        _this.updatesNames = /^configuration$|^.*files$/;
        _this.isResource = true;
        return _this;
    }
    /**
     * Download or prefetch the content.
     *
     * @param {any} module The module object returned by WS.
     * @param {number} courseId Course ID.
     * @param {boolean} [prefetch] True to prefetch, false to download right away.
     * @param {string} [dirPath] Path of the directory where to store all the content files. This is to keep the files
     *                           relative paths and make the package work in an iframe. Undefined to download the files
     *                           in the filepool root page.
     * @return {Promise<any>} Promise resolved when all content is downloaded. Data returned is not reliable.
     */
    AddonModPagePrefetchHandler.prototype.downloadOrPrefetch = function (module, courseId, prefetch, dirPath) {
        var promises = [];
        promises.push(_super.prototype.downloadOrPrefetch.call(this, module, courseId, prefetch));
        if (this.pageProvider.isGetPageWSAvailable()) {
            promises.push(this.pageProvider.getPageData(courseId, module.id));
        }
        return Promise.all(promises);
    };
    /**
     * Invalidate the prefetched content.
     *
     * @param {number} moduleId The module ID.
     * @param {number} courseId Course ID the module belongs to.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModPagePrefetchHandler.prototype.invalidateContent = function (moduleId, courseId) {
        return this.pageProvider.invalidateContent(moduleId, courseId);
    };
    /**
     * Invalidate WS calls needed to determine module status.
     *
     * @param {any} module Module.
     * @param {number} courseId Course ID the module belongs to.
     * @return {Promise<any>} Promise resolved when invalidated.
     */
    AddonModPagePrefetchHandler.prototype.invalidateModule = function (module, courseId) {
        var promises = [];
        promises.push(this.pageProvider.invalidatePageData(courseId));
        promises.push(this.courseProvider.invalidateModule(module.id));
        return this.utils.allPromises(promises);
    };
    AddonModPagePrefetchHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["C" /* Injector */], __WEBPACK_IMPORTED_MODULE_3__page__["a" /* AddonModPageProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_4__helper__["a" /* AddonModPageHelperProvider */]])
    ], AddonModPagePrefetchHandler);
    return AddonModPagePrefetchHandler;
}(__WEBPACK_IMPORTED_MODULE_1__core_course_classes_module_prefetch_handler__["a" /* CoreCourseModulePrefetchHandlerBase */]));

//# sourceMappingURL=prefetch-handler.js.map

/***/ }),
/* 600 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModResourcePrefetchHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_course_classes_module_prefetch_handler__ = __webpack_require__(106);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__resource__ = __webpack_require__(108);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__helper__ = __webpack_require__(164);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_filepool__ = __webpack_require__(35);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Handler to prefetch resources.
 */
var AddonModResourcePrefetchHandler = /** @class */ (function (_super) {
    __extends(AddonModResourcePrefetchHandler, _super);
    function AddonModResourcePrefetchHandler(injector, resourceProvider, filepoolProvider, resourceHelper) {
        var _this = _super.call(this, injector) || this;
        _this.resourceProvider = resourceProvider;
        _this.filepoolProvider = filepoolProvider;
        _this.resourceHelper = resourceHelper;
        _this.name = 'resource';
        _this.component = __WEBPACK_IMPORTED_MODULE_2__resource__["a" /* AddonModResourceProvider */].COMPONENT;
        _this.isResource = true;
        return _this;
    }
    /**
     * Download or prefetch the content.
     *
     * @param {any} module The module object returned by WS.
     * @param {number} courseId Course ID.
     * @param {boolean} [prefetch] True to prefetch, false to download right away.
     * @param {string} [dirPath] Path of the directory where to store all the content files. This is to keep the files
     *                           relative paths and make the package work in an iframe. Undefined to download the files
     *                           in the filepool root folder.
     * @return {Promise<any>} Promise resolved when all content is downloaded. Data returned is not reliable.
     */
    AddonModResourcePrefetchHandler.prototype.downloadOrPrefetch = function (module, courseId, prefetch, dirPath) {
        var _this = this;
        var promise;
        if (this.resourceHelper.isDisplayedInIframe(module)) {
            promise = this.filepoolProvider.getPackageDirPathByUrl(this.sitesProvider.getCurrentSiteId(), module.url);
        }
        else {
            promise = Promise.resolve();
        }
        return promise.then(function (dirPath) {
            var promises = [];
            promises.push(_super.prototype.downloadOrPrefetch.call(_this, module, courseId, prefetch, dirPath));
            if (_this.resourceProvider.isGetResourceWSAvailable()) {
                promises.push(_this.resourceProvider.getResourceData(courseId, module.id));
            }
            return Promise.all(promises);
        });
    };
    /**
     * Invalidate the prefetched content.
     *
     * @param {number} moduleId The module ID.
     * @param {number} courseId Course ID the module belongs to.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModResourcePrefetchHandler.prototype.invalidateContent = function (moduleId, courseId) {
        return this.resourceProvider.invalidateContent(moduleId, courseId);
    };
    /**
     * Invalidate WS calls needed to determine module status.
     *
     * @param {any} module Module.
     * @param {number} courseId Course ID the module belongs to.
     * @return {Promise<any>} Promise resolved when invalidated.
     */
    AddonModResourcePrefetchHandler.prototype.invalidateModule = function (module, courseId) {
        var promises = [];
        promises.push(this.resourceProvider.invalidateResourceData(courseId));
        promises.push(this.courseProvider.invalidateModule(module.id));
        return Promise.all(promises);
    };
    /**
     * Whether or not the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} A boolean, or a promise resolved with a boolean, indicating if the handler is enabled.
     */
    AddonModResourcePrefetchHandler.prototype.isEnabled = function () {
        return this.resourceProvider.isPluginEnabled();
    };
    AddonModResourcePrefetchHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["C" /* Injector */], __WEBPACK_IMPORTED_MODULE_2__resource__["a" /* AddonModResourceProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_filepool__["a" /* CoreFilepoolProvider */], __WEBPACK_IMPORTED_MODULE_3__helper__["a" /* AddonModResourceHelperProvider */]])
    ], AddonModResourcePrefetchHandler);
    return AddonModResourcePrefetchHandler;
}(__WEBPACK_IMPORTED_MODULE_1__core_course_classes_module_prefetch_handler__["a" /* CoreCourseModulePrefetchHandlerBase */]));

//# sourceMappingURL=prefetch-handler.js.map

/***/ }),
/* 601 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreGradesCourseComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_grades__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_helper__ = __webpack_require__(287);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__components_split_view_split_view__ = __webpack_require__(178);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_app__ = __webpack_require__(12);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};







/**
 * Component that displays a course grades.
 */
var CoreGradesCourseComponent = /** @class */ (function () {
    function CoreGradesCourseComponent(gradesProvider, domUtils, navParams, gradesHelper, navCtrl, appProvider, svComponent) {
        this.gradesProvider = gradesProvider;
        this.domUtils = domUtils;
        this.gradesHelper = gradesHelper;
        this.navCtrl = navCtrl;
        this.appProvider = appProvider;
        this.svComponent = svComponent;
        this.gradesLoaded = false;
    }
    /**
     * View loaded.
     */
    CoreGradesCourseComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.fetchData().then(function () {
            if (_this.gradeId) {
                // There is the grade to load.
                _this.gotoGrade(_this.gradeId);
            }
            // Add log in Moodle.
            return _this.gradesProvider.logCourseGradesView(_this.courseId, _this.userId);
        }).finally(function () {
            _this.gradesLoaded = true;
        });
    };
    /**
     * Fetch all the data required for the view.
     *
     * @param {boolean} [refresh] Empty events array first.
     * @return {Promise<any>}     Resolved when done.
     */
    CoreGradesCourseComponent.prototype.fetchData = function (refresh) {
        var _this = this;
        if (refresh === void 0) { refresh = false; }
        return this.gradesProvider.getCourseGradesTable(this.courseId, this.userId).then(function (table) {
            _this.gradesTable = _this.gradesHelper.formatGradesTable(table);
        }).catch(function (error) {
            _this.domUtils.showErrorModalDefault(error, 'Error loading grades');
        });
    };
    /**
     * Refresh data.
     *
     * @param {any} refresher Refresher.
     */
    CoreGradesCourseComponent.prototype.refreshGrades = function (refresher) {
        var _this = this;
        this.gradesProvider.invalidateCourseGradesData(this.courseId, this.userId).finally(function () {
            _this.fetchData().finally(function () {
                refresher.complete();
            });
        });
    };
    /**
     * Navigate to the grade of the selected item.
     * @param {number} gradeId  Grade item ID where to navigate.
     */
    CoreGradesCourseComponent.prototype.gotoGrade = function (gradeId) {
        if (gradeId) {
            this.gradeId = gradeId;
            var whereToPush = void 0, pageName = void 0;
            if (this.svComponent) {
                if (this.svComponent.getMasterNav().getActive().component.name == 'CoreGradesCourseSplitPage') {
                    // Table is on left side. Push on right.
                    whereToPush = this.svComponent;
                    pageName = 'CoreGradesGradePage';
                }
                else {
                    // Table is on right side. Load new split view.
                    whereToPush = this.svComponent.getMasterNav();
                    pageName = 'CoreGradesCourseSplitPage';
                }
            }
            else {
                if (this.appProvider.isWide()) {
                    // Table is full screen and large. Load here.
                    whereToPush = this.navCtrl;
                    pageName = 'CoreGradesCourseSplitPage';
                }
                else {
                    // Table is full screen but on mobile. Load here.
                    whereToPush = this.navCtrl;
                    pageName = 'CoreGradesGradePage';
                }
            }
            whereToPush.push(pageName, { courseId: this.courseId, userId: this.userId, gradeId: gradeId });
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])(__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["e" /* Content */]),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["e" /* Content */])
    ], CoreGradesCourseComponent.prototype, "content", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreGradesCourseComponent.prototype, "courseId", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreGradesCourseComponent.prototype, "userId", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreGradesCourseComponent.prototype, "gradeId", void 0);
    CoreGradesCourseComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-grades-course',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/core/grades/components/course/course.html"*/'<ion-content>\n    <ion-refresher [enabled]="gradesLoaded" (ionRefresh)="refreshGrades($event)">\n        <ion-refresher-content pullingText="{{ \'core.pulltorefresh\' | translate }}"></ion-refresher-content>\n    </ion-refresher>\n    <core-loading [hideUntil]="gradesLoaded">\n        <core-empty-box *ngIf="!gradesTable" icon="stats" [message]="\'core.grades.nogradesreturned\' | translate">\n        </core-empty-box>\n\n        <div *ngIf="gradesTable" class="core-grades-container">\n            <table cellspacing="0" cellpadding="0" class="core-grades-table">\n                <thead>\n                    <tr>\n                        <th *ngFor="let column of gradesTable.columns" id="{{column.name}}" [class.hidden-phone]="column.hiddenPhone" [attr.colspan]="column.colspan">\n                            {{ \'core.grades.\' + column.name | translate }}\n                        </th>\n                    </tr>\n                </thead>\n                <tbody>\n                    <tr *ngFor="let row of gradesTable.rows" (click)="row.itemtype != \'category\' && gotoGrade(row.id)" [class]="row.rowclass">\n                        <td *ngIf="row.itemtype == \'category\'" class="core-grades-table-category" [attr.rowspan]="row.rowspan">\n                        </td>\n                        <th class="core-grades-table-gradeitem" [attr.colspan]="row.colspan" [class.core-split-item-selected]="gradeId == row.id">\n                            <ion-icon *ngIf="row.icon" name="{{row.icon}}" item-start></ion-icon>\n                            <img *ngIf="row.image" [src]="row.image" item-start/>\n                            <span [innerHTML]="row.gradeitem"></span>\n                        </th>\n                        <ng-container *ngFor="let column of gradesTable.columns">\n                            <td *ngIf="column.name != \'gradeitem\' && row[column.name] != undefined" [class]="\'core-grades-table-\' + column.name" [innerHTML]="row[column.name]" [class.hidden-phone]="column.hiddenPhone">\n                            </td>\n                        </ng-container>\n                    </tr>\n                </tbody>\n            </table>\n        </div>\n    </core-loading>\n</ion-content>'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/core/grades/components/course/course.html"*/,
        }),
        __param(4, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["N" /* Optional */])()),
        __param(6, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["N" /* Optional */])()),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_grades__["a" /* CoreGradesProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["m" /* NavParams */],
            __WEBPACK_IMPORTED_MODULE_4__providers_helper__["a" /* CoreGradesHelperProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavController */],
            __WEBPACK_IMPORTED_MODULE_6__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_5__components_split_view_split_view__["a" /* CoreSplitViewComponent */]])
    ], CoreGradesCourseComponent);
    return CoreGradesCourseComponent;
}());

//# sourceMappingURL=course.js.map

/***/ }),
/* 602 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreUserParticipantsComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_user__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__components_split_view_split_view__ = __webpack_require__(178);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Component that displays the list of course participants.
 */
var CoreUserParticipantsComponent = /** @class */ (function () {
    function CoreUserParticipantsComponent(userProvider, domUtils) {
        this.userProvider = userProvider;
        this.domUtils = domUtils;
        this.participants = [];
        this.canLoadMore = false;
        this.participantsLoaded = false;
    }
    /**
     * View loaded.
     */
    CoreUserParticipantsComponent.prototype.ngOnInit = function () {
        var _this = this;
        // Get first participants.
        this.fetchData(true).then(function () {
            if (!_this.participantId && _this.splitviewCtrl.isOn() && _this.participants.length > 0) {
                // Take first and load it.
                _this.gotoParticipant(_this.participants[0].id);
            }
            // Add log in Moodle.
            _this.userProvider.logParticipantsView(_this.courseId).catch(function () {
                // Ignore errors.
            });
        }).finally(function () {
            _this.participantsLoaded = true;
        });
    };
    /**
     * Fetch all the data required for the view.
     *
     * @param {boolean} [refresh] Empty events array first.
     * @return {Promise<any>}     Resolved when done.
     */
    CoreUserParticipantsComponent.prototype.fetchData = function (refresh) {
        var _this = this;
        if (refresh === void 0) { refresh = false; }
        var firstToGet = refresh ? 0 : this.participants.length;
        return this.userProvider.getParticipants(this.courseId, firstToGet).then(function (data) {
            if (refresh) {
                _this.participants = data.participants;
            }
            else {
                _this.participants = _this.participants.concat(data.participants);
            }
            _this.canLoadMore = data.canLoadMore;
        }).catch(function (error) {
            _this.domUtils.showErrorModalDefault(error, 'Error loading participants');
            _this.canLoadMore = false; // Set to false to prevent infinite calls with infinite-loading.
        });
    };
    /**
     * Refresh data.
     *
     * @param {any} refresher Refresher.
     */
    CoreUserParticipantsComponent.prototype.refreshParticipants = function (refresher) {
        var _this = this;
        this.userProvider.invalidateParticipantsList(this.courseId).finally(function () {
            _this.fetchData(true).finally(function () {
                refresher.complete();
            });
        });
    };
    /**
     * Navigate to a particular user profile.
     * @param {number} userId  User Id where to navigate.
     */
    CoreUserParticipantsComponent.prototype.gotoParticipant = function (userId) {
        this.participantId = userId;
        this.splitviewCtrl.push('CoreUserProfilePage', { userId: userId, courseId: this.courseId });
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])(__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["e" /* Content */]),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["e" /* Content */])
    ], CoreUserParticipantsComponent.prototype, "content", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])(__WEBPACK_IMPORTED_MODULE_4__components_split_view_split_view__["a" /* CoreSplitViewComponent */]),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_4__components_split_view_split_view__["a" /* CoreSplitViewComponent */])
    ], CoreUserParticipantsComponent.prototype, "splitviewCtrl", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreUserParticipantsComponent.prototype, "courseId", void 0);
    CoreUserParticipantsComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-user-participants',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/core/user/components/participants/participants.html"*/'<core-split-view>\n    <ion-content>\n        <ion-refresher [enabled]="participantsLoaded" (ionRefresh)="refreshParticipants($event)">\n            <ion-refresher-content pullingText="{{ \'core.pulltorefresh\' | translate }}"></ion-refresher-content>\n        </ion-refresher>\n        <core-loading [hideUntil]="participantsLoaded">\n            <core-empty-box *ngIf="participants && participants.length == 0" icon="person" [message]="\'core.user.noparticipants\' | translate">\n            </core-empty-box>\n\n            <ion-list *ngIf="participants && participants.length > 0" no-margin>\n                <a ion-item text-wrap *ngFor="let participant of participants" [title]="participant.fullname" (click)="gotoParticipant(participant.id)" [class.core-split-item-selected]="participant.id == participantId">\n                    <ion-avatar item-start>\n                        <img src="{{participant.profileimageurl}}" [alt]="\'core.pictureof\' | translate:{$a: participant.fullname}" core-external-content onError="this.src=\'assets/img/user-avatar.png\'">\n                    </ion-avatar>\n                    <h2><core-format-text [text]="participant.fullname"></core-format-text></h2>\n                    <p *ngIf="participant.lastaccess"><strong>{{ \'core.lastaccess\' | translate }}: </strong>{{ participant.lastaccess * 1000 | coreFormatDate:"dfmediumdate"}}</p>\n                </a>\n            </ion-list>\n\n            <ion-infinite-scroll [enabled]="canLoadMore" (ionInfinite)="$event.waitFor(fetchData())">\n               <ion-infinite-scroll-content></ion-infinite-scroll-content>\n            </ion-infinite-scroll>\n        </core-loading>\n    </ion-content>\n</core-split-view>'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/core/user/components/participants/participants.html"*/,
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_user__["a" /* CoreUserProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__["a" /* CoreDomUtilsProvider */]])
    ], CoreUserParticipantsComponent);
    return CoreUserParticipantsComponent;
}());

//# sourceMappingURL=participants.js.map

/***/ }),
/* 603 */,
/* 604 */,
/* 605 */,
/* 606 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCompileHtmlComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_compile__ = __webpack_require__(249);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_rxjs__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};




/**
 * This component has a behaviour similar to $compile for AngularJS. Given an HTML code, it will compile it so all its
 * components and directives are instantiated.
 *
 * IMPORTANT: Use this component only if it is a must. It will create and compile a new component and module everytime this
 * component is used, so it can slow down the app.
 *
 * This component has its own module to prevent circular dependencies. If you want to use it,
 * you need to import CoreCompileHtmlComponentModule.
 *
 * You can provide some Javascript code (as text) to be executed inside the component. The context of the javascript code (this)
 * will be the component instance created to compile the template. This means your javascript code can interact with the template.
 * The component instance will have most of the providers so you can use them in the javascript code. E.g. if you want to use
 * CoreAppProvider, you can do it with "this.CoreAppProvider".
 */
var CoreCompileHtmlComponent = /** @class */ (function () {
    function CoreCompileHtmlComponent(compileProvider, cdr, element, navCtrl) {
        this.compileProvider = compileProvider;
        this.cdr = cdr;
        this.navCtrl = navCtrl;
        this.element = element.nativeElement;
        this.componentObservable = new __WEBPACK_IMPORTED_MODULE_3_rxjs__["BehaviorSubject"](null);
    }
    /**
     * Detect changes on input properties.
     */
    CoreCompileHtmlComponent.prototype.ngOnChanges = function (changes) {
        var _this = this;
        if ((changes.text || changes.javascript) && this.text) {
            // Create a new component and a new module.
            this.compileProvider.createAndCompileComponent(this.text, this.getComponentClass()).then(function (factory) {
                // Destroy previous components.
                _this.componentRef && _this.componentRef.destroy();
                if (factory) {
                    // Create the component.
                    _this.componentRef = _this.container.createComponent(factory);
                    _this.componentObservable.next(_this.componentRef.instance);
                }
            });
        }
    };
    /**
     * Component destroyed.
     */
    CoreCompileHtmlComponent.prototype.ngOnDestroy = function () {
        this.componentRef && this.componentRef.destroy();
    };
    /**
     * Get a class that defines the dynamic component.
     *
     * @return {any} The component class.
     */
    CoreCompileHtmlComponent.prototype.getComponentClass = function () {
        // tslint:disable: no-this-assignment
        var compileInstance = this;
        // Create the component, using the text as the template.
        return /** @class */ (function () {
            function CoreCompileHtmlFakeComponent() {
                // If there is some javascript to run, prepare the instance.
                if (compileInstance.javascript) {
                    compileInstance.compileProvider.injectLibraries(this);
                    // Add some more components and classes.
                    this['ChangeDetectorRef'] = compileInstance.cdr;
                    this['NavController'] = compileInstance.navCtrl;
                    this['componentContainer'] = compileInstance.element;
                }
                // Add the data passed to the component.
                for (var name_1 in compileInstance.jsData) {
                    this[name_1] = compileInstance.jsData[name_1];
                }
            }
            CoreCompileHtmlFakeComponent.prototype.ngOnInit = function () {
                // If there is some javascript to run, do it now.
                if (compileInstance.javascript) {
                    compileInstance.compileProvider.executeJavascript(this, compileInstance.javascript);
                }
            };
            return CoreCompileHtmlFakeComponent;
        }());
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreCompileHtmlComponent.prototype, "text", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreCompileHtmlComponent.prototype, "javascript", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreCompileHtmlComponent.prototype, "jsData", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])('dynamicComponent', { read: __WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewContainerRef */] }),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewContainerRef */])
    ], CoreCompileHtmlComponent.prototype, "container", void 0);
    CoreCompileHtmlComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-compile-html',
            template: '<ng-container #dynamicComponent></ng-container>'
        }),
        __param(3, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["N" /* Optional */])()),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_compile__["a" /* CoreCompileProvider */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["j" /* ChangeDetectorRef */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavController */]])
    ], CoreCompileHtmlComponent);
    return CoreCompileHtmlComponent;
}());

//# sourceMappingURL=compile-html.js.map

/***/ }),
/* 607 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CORE_CONTENTLINKS_PROVIDERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return CoreContentLinksModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_delegate__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_helper__ = __webpack_require__(45);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};



// List of providers.
var CORE_CONTENTLINKS_PROVIDERS = [
    __WEBPACK_IMPORTED_MODULE_1__providers_delegate__["a" /* CoreContentLinksDelegate */],
    __WEBPACK_IMPORTED_MODULE_2__providers_helper__["a" /* CoreContentLinksHelperProvider */]
];
var CoreContentLinksModule = /** @class */ (function () {
    function CoreContentLinksModule() {
    }
    CoreContentLinksModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [],
            providers: CORE_CONTENTLINKS_PROVIDERS,
            exports: []
        })
    ], CoreContentLinksModule);
    return CoreContentLinksModule;
}());

//# sourceMappingURL=contentlinks.module.js.map

/***/ }),
/* 608 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CORE_COURSE_PROVIDERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return CoreCourseModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_course__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_helper__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_format_delegate__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_module_delegate__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_module_prefetch_delegate__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_options_delegate__ = __webpack_require__(100);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_default_format__ = __webpack_require__(594);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__formats_singleactivity_singleactivity_module__ = __webpack_require__(1083);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__formats_social_social_module__ = __webpack_require__(1084);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__formats_topics_topics_module__ = __webpack_require__(1086);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__formats_weeks_weeks_module__ = __webpack_require__(1088);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};












// List of providers (without handlers).
var CORE_COURSE_PROVIDERS = [
    __WEBPACK_IMPORTED_MODULE_1__providers_course__["a" /* CoreCourseProvider */],
    __WEBPACK_IMPORTED_MODULE_2__providers_helper__["a" /* CoreCourseHelperProvider */],
    __WEBPACK_IMPORTED_MODULE_3__providers_format_delegate__["a" /* CoreCourseFormatDelegate */],
    __WEBPACK_IMPORTED_MODULE_4__providers_module_delegate__["a" /* CoreCourseModuleDelegate */],
    __WEBPACK_IMPORTED_MODULE_5__providers_module_prefetch_delegate__["a" /* CoreCourseModulePrefetchDelegate */],
    __WEBPACK_IMPORTED_MODULE_6__providers_options_delegate__["a" /* CoreCourseOptionsDelegate */]
];
var CoreCourseModule = /** @class */ (function () {
    function CoreCourseModule() {
    }
    CoreCourseModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [
                __WEBPACK_IMPORTED_MODULE_8__formats_singleactivity_singleactivity_module__["a" /* CoreCourseFormatSingleActivityModule */],
                __WEBPACK_IMPORTED_MODULE_10__formats_topics_topics_module__["a" /* CoreCourseFormatTopicsModule */],
                __WEBPACK_IMPORTED_MODULE_11__formats_weeks_weeks_module__["a" /* CoreCourseFormatWeeksModule */],
                __WEBPACK_IMPORTED_MODULE_9__formats_social_social_module__["a" /* CoreCourseFormatSocialModule */]
            ],
            providers: CORE_COURSE_PROVIDERS.concat([
                __WEBPACK_IMPORTED_MODULE_7__providers_default_format__["a" /* CoreCourseFormatDefaultHandler */]
            ]),
            exports: []
        })
    ], CoreCourseModule);
    return CoreCourseModule;
}());

//# sourceMappingURL=course.module.js.map

/***/ }),
/* 609 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseFormatSingleActivityHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_singleactivity__ = __webpack_require__(250);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Handler to support singleactivity course format.
 */
var CoreCourseFormatSingleActivityHandler = /** @class */ (function () {
    function CoreCourseFormatSingleActivityHandler() {
        this.name = 'singleactivity';
        // Nothing to do.
    }
    /**
     * Whether or not the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} True or promise resolved with true if enabled.
     */
    CoreCourseFormatSingleActivityHandler.prototype.isEnabled = function () {
        return true;
    };
    /**
     * Whether it allows seeing all sections at the same time. Defaults to true.
     *
     * @param {any} course The course to check.
     * @type {boolean} Whether it can view all sections.
     */
    CoreCourseFormatSingleActivityHandler.prototype.canViewAllSections = function (course) {
        return false;
    };
    /**
     * Get the title to use in course page. If not defined, course fullname.
     * This function will be called without sections first, and then call it again when the sections are retrieved.
     *
     * @param {any} course The course.
     * @param {any[]} [sections] List of sections.
     * @return {string} Title.
     */
    CoreCourseFormatSingleActivityHandler.prototype.getCourseTitle = function (course, sections) {
        if (sections && sections[0] && sections[0].modules && sections[0].modules[0]) {
            return sections[0].modules[0].name;
        }
        return course.fullname || '';
    };
    /**
     * Whether the option to enable section/module download should be displayed. Defaults to true.
     *
     * @param {any} course The course to check.
     * @return {boolean} Whether the option to enable section/module download should be displayed
     */
    CoreCourseFormatSingleActivityHandler.prototype.displayEnableDownload = function (course) {
        return false;
    };
    /**
     * Whether the default section selector should be displayed. Defaults to true.
     *
     * @param {any} course The course to check.
     * @type {boolean} Whether the default section selector should be displayed.
     */
    CoreCourseFormatSingleActivityHandler.prototype.displaySectionSelector = function (course) {
        return false;
    };
    /**
     * Return the Component to use to display the course format instead of using the default one.
     * Use it if you want to display a format completely different from the default one.
     * If you want to customize the default format there are several methods to customize parts of it.
     * It's recommended to return the class of the component, but you can also return an instance of the component.
     *
     * @param {Injector} injector Injector.
     * @param {any} course The course to render.
     * @return {any|Promise<any>} The component (or promise resolved with component) to use, undefined if not found.
     */
    CoreCourseFormatSingleActivityHandler.prototype.getCourseFormatComponent = function (injector, course) {
        return __WEBPACK_IMPORTED_MODULE_1__components_singleactivity__["a" /* CoreCourseFormatSingleActivityComponent */];
    };
    CoreCourseFormatSingleActivityHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [])
    ], CoreCourseFormatSingleActivityHandler);
    return CoreCourseFormatSingleActivityHandler;
}());

//# sourceMappingURL=handler.js.map

/***/ }),
/* 610 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CORE_COURSES_PROVIDERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return CoreCoursesModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_courses__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_mainmenu_handler__ = __webpack_require__(1090);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_my_overview__ = __webpack_require__(180);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_course_link_handler__ = __webpack_require__(1091);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_courses_index_link_handler__ = __webpack_require__(1092);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_my_overview_link_handler__ = __webpack_require__(1093);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_mainmenu_providers_delegate__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__core_contentlinks_providers_delegate__ = __webpack_require__(46);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};









// List of providers (without handlers).
var CORE_COURSES_PROVIDERS = [
    __WEBPACK_IMPORTED_MODULE_1__providers_courses__["a" /* CoreCoursesProvider */],
    __WEBPACK_IMPORTED_MODULE_3__providers_my_overview__["a" /* CoreCoursesMyOverviewProvider */]
];
var CoreCoursesModule = /** @class */ (function () {
    function CoreCoursesModule(mainMenuDelegate, contentLinksDelegate, mainMenuHandler, courseLinkHandler, indexLinkHandler, myOverviewLinkHandler) {
        mainMenuDelegate.registerHandler(mainMenuHandler);
        contentLinksDelegate.registerHandler(courseLinkHandler);
        contentLinksDelegate.registerHandler(indexLinkHandler);
        contentLinksDelegate.registerHandler(myOverviewLinkHandler);
    }
    CoreCoursesModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [],
            providers: CORE_COURSES_PROVIDERS.concat([
                __WEBPACK_IMPORTED_MODULE_2__providers_mainmenu_handler__["a" /* CoreCoursesMainMenuHandler */],
                __WEBPACK_IMPORTED_MODULE_4__providers_course_link_handler__["a" /* CoreCoursesCourseLinkHandler */],
                __WEBPACK_IMPORTED_MODULE_5__providers_courses_index_link_handler__["a" /* CoreCoursesIndexLinkHandler */],
                __WEBPACK_IMPORTED_MODULE_6__providers_my_overview_link_handler__["a" /* CoreCoursesMyOverviewLinkHandler */]
            ]),
            exports: []
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_7__core_mainmenu_providers_delegate__["a" /* CoreMainMenuDelegate */], __WEBPACK_IMPORTED_MODULE_8__core_contentlinks_providers_delegate__["a" /* CoreContentLinksDelegate */],
            __WEBPACK_IMPORTED_MODULE_2__providers_mainmenu_handler__["a" /* CoreCoursesMainMenuHandler */], __WEBPACK_IMPORTED_MODULE_4__providers_course_link_handler__["a" /* CoreCoursesCourseLinkHandler */],
            __WEBPACK_IMPORTED_MODULE_5__providers_courses_index_link_handler__["a" /* CoreCoursesIndexLinkHandler */], __WEBPACK_IMPORTED_MODULE_6__providers_my_overview_link_handler__["a" /* CoreCoursesMyOverviewLinkHandler */]])
    ], CoreCoursesModule);
    return CoreCoursesModule;
}());

//# sourceMappingURL=courses.module.js.map

/***/ }),
/* 611 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CORE_FILEUPLOADER_PROVIDERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return CoreFileUploaderModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_fileuploader__ = __webpack_require__(162);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_helper__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_delegate__ = __webpack_require__(244);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_album_handler__ = __webpack_require__(1094);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_audio_handler__ = __webpack_require__(1095);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_camera_handler__ = __webpack_require__(1096);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_file_handler__ = __webpack_require__(1097);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_video_handler__ = __webpack_require__(1098);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};









// List of providers (without handlers).
var CORE_FILEUPLOADER_PROVIDERS = [
    __WEBPACK_IMPORTED_MODULE_1__providers_fileuploader__["a" /* CoreFileUploaderProvider */],
    __WEBPACK_IMPORTED_MODULE_2__providers_helper__["a" /* CoreFileUploaderHelperProvider */],
    __WEBPACK_IMPORTED_MODULE_3__providers_delegate__["a" /* CoreFileUploaderDelegate */]
];
var CoreFileUploaderModule = /** @class */ (function () {
    function CoreFileUploaderModule(delegate, albumHandler, audioHandler, cameraHandler, videoHandler, fileHandler) {
        delegate.registerHandler(albumHandler);
        delegate.registerHandler(audioHandler);
        delegate.registerHandler(cameraHandler);
        delegate.registerHandler(fileHandler);
        delegate.registerHandler(videoHandler);
    }
    CoreFileUploaderModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [],
            providers: CORE_FILEUPLOADER_PROVIDERS.concat([
                __WEBPACK_IMPORTED_MODULE_4__providers_album_handler__["a" /* CoreFileUploaderAlbumHandler */],
                __WEBPACK_IMPORTED_MODULE_5__providers_audio_handler__["a" /* CoreFileUploaderAudioHandler */],
                __WEBPACK_IMPORTED_MODULE_6__providers_camera_handler__["a" /* CoreFileUploaderCameraHandler */],
                __WEBPACK_IMPORTED_MODULE_7__providers_file_handler__["a" /* CoreFileUploaderFileHandler */],
                __WEBPACK_IMPORTED_MODULE_8__providers_video_handler__["a" /* CoreFileUploaderVideoHandler */]
            ])
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_delegate__["a" /* CoreFileUploaderDelegate */], __WEBPACK_IMPORTED_MODULE_4__providers_album_handler__["a" /* CoreFileUploaderAlbumHandler */],
            __WEBPACK_IMPORTED_MODULE_5__providers_audio_handler__["a" /* CoreFileUploaderAudioHandler */], __WEBPACK_IMPORTED_MODULE_6__providers_camera_handler__["a" /* CoreFileUploaderCameraHandler */],
            __WEBPACK_IMPORTED_MODULE_8__providers_video_handler__["a" /* CoreFileUploaderVideoHandler */], __WEBPACK_IMPORTED_MODULE_7__providers_file_handler__["a" /* CoreFileUploaderFileHandler */]])
    ], CoreFileUploaderModule);
    return CoreFileUploaderModule;
}());

//# sourceMappingURL=fileuploader.module.js.map

/***/ }),
/* 612 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CORE_GRADES_PROVIDERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return CoreGradesModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_grades__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_helper__ = __webpack_require__(287);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_mainmenu_providers_delegate__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_mainmenu_handler__ = __webpack_require__(1099);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_course_option_handler__ = __webpack_require__(1100);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__components_components_module__ = __webpack_require__(716);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_course_providers_options_delegate__ = __webpack_require__(100);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_user_link_handler__ = __webpack_require__(1101);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_overview_link_handler__ = __webpack_require__(1102);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__core_contentlinks_providers_delegate__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_user_handler__ = __webpack_require__(1103);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__core_user_providers_user_delegate__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_events__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__core_user_providers_user__ = __webpack_require__(62);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
















// List of providers (without handlers).
var CORE_GRADES_PROVIDERS = [
    __WEBPACK_IMPORTED_MODULE_1__providers_grades__["a" /* CoreGradesProvider */],
    __WEBPACK_IMPORTED_MODULE_2__providers_helper__["a" /* CoreGradesHelperProvider */]
];
var CoreGradesModule = /** @class */ (function () {
    function CoreGradesModule(mainMenuDelegate, gradesMenuHandler, courseOptionHandler, courseOptionsDelegate, contentLinksDelegate, userLinkHandler, overviewLinkHandler, userHandler, userDelegate, eventsProvider, sitesProvider) {
        // Register handlers.
        mainMenuDelegate.registerHandler(gradesMenuHandler);
        courseOptionsDelegate.registerHandler(courseOptionHandler);
        contentLinksDelegate.registerHandler(userLinkHandler);
        contentLinksDelegate.registerHandler(overviewLinkHandler);
        userDelegate.registerHandler(userHandler);
        // Clear user profile handler cache.
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_15__core_user_providers_user__["a" /* CoreUserProvider */].PROFILE_REFRESHED, function (data) {
            userHandler.clearViewGradesCache(data.courseId, data.userId);
        }, sitesProvider.getCurrentSiteId());
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_13__providers_events__["a" /* CoreEventsProvider */].LOGOUT, function () {
            userHandler.clearViewGradesCache();
        }, sitesProvider.getCurrentSiteId());
    }
    CoreGradesModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [
                __WEBPACK_IMPORTED_MODULE_6__components_components_module__["a" /* CoreGradesComponentsModule */]
            ],
            providers: CORE_GRADES_PROVIDERS.concat([
                __WEBPACK_IMPORTED_MODULE_4__providers_mainmenu_handler__["a" /* CoreGradesMainMenuHandler */],
                __WEBPACK_IMPORTED_MODULE_5__providers_course_option_handler__["a" /* CoreGradesCourseOptionHandler */],
                __WEBPACK_IMPORTED_MODULE_8__providers_user_link_handler__["a" /* CoreGradesUserLinkHandler */],
                __WEBPACK_IMPORTED_MODULE_9__providers_overview_link_handler__["a" /* CoreGradesOverviewLinkHandler */],
                __WEBPACK_IMPORTED_MODULE_11__providers_user_handler__["a" /* CoreGradesUserHandler */]
            ])
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__core_mainmenu_providers_delegate__["a" /* CoreMainMenuDelegate */], __WEBPACK_IMPORTED_MODULE_4__providers_mainmenu_handler__["a" /* CoreGradesMainMenuHandler */],
            __WEBPACK_IMPORTED_MODULE_5__providers_course_option_handler__["a" /* CoreGradesCourseOptionHandler */], __WEBPACK_IMPORTED_MODULE_7__core_course_providers_options_delegate__["a" /* CoreCourseOptionsDelegate */],
            __WEBPACK_IMPORTED_MODULE_10__core_contentlinks_providers_delegate__["a" /* CoreContentLinksDelegate */], __WEBPACK_IMPORTED_MODULE_8__providers_user_link_handler__["a" /* CoreGradesUserLinkHandler */],
            __WEBPACK_IMPORTED_MODULE_9__providers_overview_link_handler__["a" /* CoreGradesOverviewLinkHandler */], __WEBPACK_IMPORTED_MODULE_11__providers_user_handler__["a" /* CoreGradesUserHandler */],
            __WEBPACK_IMPORTED_MODULE_12__core_user_providers_user_delegate__["a" /* CoreUserDelegate */], __WEBPACK_IMPORTED_MODULE_13__providers_events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_14__providers_sites__["a" /* CoreSitesProvider */]])
    ], CoreGradesModule);
    return CoreGradesModule;
}());

//# sourceMappingURL=grades.module.js.map

/***/ }),
/* 613 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CORE_LOGIN_PROVIDERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return CoreLoginModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_helper__ = __webpack_require__(51);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


// List of providers.
var CORE_LOGIN_PROVIDERS = [
    __WEBPACK_IMPORTED_MODULE_1__providers_helper__["a" /* CoreLoginHelperProvider */]
];
var CoreLoginModule = /** @class */ (function () {
    function CoreLoginModule() {
    }
    CoreLoginModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [],
            providers: CORE_LOGIN_PROVIDERS
        })
    ], CoreLoginModule);
    return CoreLoginModule;
}());

//# sourceMappingURL=login.module.js.map

/***/ }),
/* 614 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CORE_MAINMENU_PROVIDERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return CoreMainMenuModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_delegate__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_mainmenu__ = __webpack_require__(717);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};



// List of providers.
var CORE_MAINMENU_PROVIDERS = [
    __WEBPACK_IMPORTED_MODULE_1__providers_delegate__["a" /* CoreMainMenuDelegate */],
    __WEBPACK_IMPORTED_MODULE_2__providers_mainmenu__["a" /* CoreMainMenuProvider */]
];
var CoreMainMenuModule = /** @class */ (function () {
    function CoreMainMenuModule() {
    }
    CoreMainMenuModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [],
            providers: CORE_MAINMENU_PROVIDERS
        })
    ], CoreMainMenuModule);
    return CoreMainMenuModule;
}());

//# sourceMappingURL=mainmenu.module.js.map

/***/ }),
/* 615 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CORE_SHAREDFILES_PROVIDERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return CoreSharedFilesModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sharedfiles__ = __webpack_require__(296);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_helper__ = __webpack_require__(297);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_upload_handler__ = __webpack_require__(1104);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__core_fileuploader_providers_delegate__ = __webpack_require__(244);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






// List of providers (without handlers).
var CORE_SHAREDFILES_PROVIDERS = [
    __WEBPACK_IMPORTED_MODULE_2__providers_sharedfiles__["a" /* CoreSharedFilesProvider */],
    __WEBPACK_IMPORTED_MODULE_3__providers_helper__["a" /* CoreSharedFilesHelperProvider */]
];
var CoreSharedFilesModule = /** @class */ (function () {
    function CoreSharedFilesModule(platform, delegate, handler, helper) {
        // Register the handler.
        delegate.registerHandler(handler);
        if (platform.is('ios')) {
            // Check if there are new files at app start and when the app is resumed.
            helper.searchIOSNewSharedFiles();
            platform.resume.subscribe(function () {
                helper.searchIOSNewSharedFiles();
            });
        }
    }
    CoreSharedFilesModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [],
            providers: CORE_SHAREDFILES_PROVIDERS.concat([
                __WEBPACK_IMPORTED_MODULE_4__providers_upload_handler__["a" /* CoreSharedFilesUploadHandler */]
            ])
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */], __WEBPACK_IMPORTED_MODULE_5__core_fileuploader_providers_delegate__["a" /* CoreFileUploaderDelegate */], __WEBPACK_IMPORTED_MODULE_4__providers_upload_handler__["a" /* CoreSharedFilesUploadHandler */],
            __WEBPACK_IMPORTED_MODULE_3__providers_helper__["a" /* CoreSharedFilesHelperProvider */]])
    ], CoreSharedFilesModule);
    return CoreSharedFilesModule;
}());

//# sourceMappingURL=sharedfiles.module.js.map

/***/ }),
/* 616 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CORE_SITEHOME_PROVIDERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return CoreSiteHomeModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_sitehome__ = __webpack_require__(138);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_mainmenu_handler__ = __webpack_require__(1105);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_index_link_handler__ = __webpack_require__(1106);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_mainmenu_providers_delegate__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__core_contentlinks_providers_delegate__ = __webpack_require__(46);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






// List of providers (without handlers).
var CORE_SITEHOME_PROVIDERS = [
    __WEBPACK_IMPORTED_MODULE_1__providers_sitehome__["a" /* CoreSiteHomeProvider */]
];
var CoreSiteHomeModule = /** @class */ (function () {
    function CoreSiteHomeModule(mainMenuDelegate, contentLinksDelegate, mainMenuHandler, indexLinkHandler) {
        mainMenuDelegate.registerHandler(mainMenuHandler);
        contentLinksDelegate.registerHandler(indexLinkHandler);
    }
    CoreSiteHomeModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [],
            providers: CORE_SITEHOME_PROVIDERS.concat([
                __WEBPACK_IMPORTED_MODULE_2__providers_mainmenu_handler__["a" /* CoreSiteHomeMainMenuHandler */],
                __WEBPACK_IMPORTED_MODULE_3__providers_index_link_handler__["a" /* CoreSiteHomeIndexLinkHandler */]
            ]),
            exports: []
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__core_mainmenu_providers_delegate__["a" /* CoreMainMenuDelegate */], __WEBPACK_IMPORTED_MODULE_5__core_contentlinks_providers_delegate__["a" /* CoreContentLinksDelegate */],
            __WEBPACK_IMPORTED_MODULE_2__providers_mainmenu_handler__["a" /* CoreSiteHomeMainMenuHandler */], __WEBPACK_IMPORTED_MODULE_3__providers_index_link_handler__["a" /* CoreSiteHomeIndexLinkHandler */]])
    ], CoreSiteHomeModule);
    return CoreSiteHomeModule;
}());

//# sourceMappingURL=sitehome.module.js.map

/***/ }),
/* 617 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CORE_USER_PROVIDERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return CoreUserModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_user_delegate__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_user_profile_field_delegate__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_user__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_helper__ = __webpack_require__(719);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_user_handler__ = __webpack_require__(1107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_events__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__core_contentlinks_providers_delegate__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_user_link_handler__ = __webpack_require__(1108);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_course_option_handler__ = __webpack_require__(1109);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_participants_link_handler__ = __webpack_require__(1110);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__core_course_providers_options_delegate__ = __webpack_require__(100);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__components_components_module__ = __webpack_require__(286);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};














// List of providers (without handlers).
var CORE_USER_PROVIDERS = [
    __WEBPACK_IMPORTED_MODULE_1__providers_user_delegate__["a" /* CoreUserDelegate */],
    __WEBPACK_IMPORTED_MODULE_2__providers_user_profile_field_delegate__["a" /* CoreUserProfileFieldDelegate */],
    __WEBPACK_IMPORTED_MODULE_3__providers_user__["a" /* CoreUserProvider */],
    __WEBPACK_IMPORTED_MODULE_4__providers_helper__["a" /* CoreUserHelperProvider */],
];
var CoreUserModule = /** @class */ (function () {
    function CoreUserModule(userDelegate, userProfileMailHandler, eventsProvider, sitesProvider, userProvider, contentLinksDelegate, userLinkHandler, courseOptionHandler, linkHandler, courseOptionsDelegate) {
        userDelegate.registerHandler(userProfileMailHandler);
        courseOptionsDelegate.registerHandler(courseOptionHandler);
        contentLinksDelegate.registerHandler(userLinkHandler);
        contentLinksDelegate.registerHandler(linkHandler);
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_6__providers_events__["a" /* CoreEventsProvider */].USER_DELETED, function (data) {
            // Search for userid in params.
            var params = data.params;
            var userId = 0;
            if (params.userid) {
                userId = params.userid;
            }
            else if (params.userids) {
                userId = params.userids[0];
            }
            else if (params.field === 'id' && params.values && params.values.length) {
                userId = params.values[0];
            }
            else if (params.userlist && params.userlist.length) {
                userId = params.userlist[0].userid;
            }
            if (userId > 0) {
                userProvider.deleteStoredUser(userId, data.siteId);
            }
        }, sitesProvider.getCurrentSiteId());
    }
    CoreUserModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [
                __WEBPACK_IMPORTED_MODULE_13__components_components_module__["a" /* CoreUserComponentsModule */]
            ],
            providers: CORE_USER_PROVIDERS.concat([
                __WEBPACK_IMPORTED_MODULE_5__providers_user_handler__["a" /* CoreUserProfileMailHandler */],
                __WEBPACK_IMPORTED_MODULE_9__providers_user_link_handler__["a" /* CoreUserProfileLinkHandler */],
                __WEBPACK_IMPORTED_MODULE_10__providers_course_option_handler__["a" /* CoreUserParticipantsCourseOptionHandler */],
                __WEBPACK_IMPORTED_MODULE_11__providers_participants_link_handler__["a" /* CoreUserParticipantsLinkHandler */]
            ])
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_user_delegate__["a" /* CoreUserDelegate */], __WEBPACK_IMPORTED_MODULE_5__providers_user_handler__["a" /* CoreUserProfileMailHandler */],
            __WEBPACK_IMPORTED_MODULE_6__providers_events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_7__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_user__["a" /* CoreUserProvider */],
            __WEBPACK_IMPORTED_MODULE_8__core_contentlinks_providers_delegate__["a" /* CoreContentLinksDelegate */], __WEBPACK_IMPORTED_MODULE_9__providers_user_link_handler__["a" /* CoreUserProfileLinkHandler */],
            __WEBPACK_IMPORTED_MODULE_10__providers_course_option_handler__["a" /* CoreUserParticipantsCourseOptionHandler */], __WEBPACK_IMPORTED_MODULE_11__providers_participants_link_handler__["a" /* CoreUserParticipantsLinkHandler */],
            __WEBPACK_IMPORTED_MODULE_12__core_course_providers_options_delegate__["a" /* CoreCourseOptionsDelegate */]])
    ], CoreUserModule);
    return CoreUserModule;
}());

//# sourceMappingURL=user.module.js.map

/***/ }),
/* 618 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return IONIC_NATIVE_PROVIDERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreEmulatorModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_badge__ = __webpack_require__(603);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_camera__ = __webpack_require__(243);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ionic_native_clipboard__ = __webpack_require__(228);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ionic_native_device__ = __webpack_require__(605);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ionic_native_file__ = __webpack_require__(128);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ionic_native_file_transfer__ = __webpack_require__(240);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__ionic_native_globalization__ = __webpack_require__(224);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__ionic_native_in_app_browser__ = __webpack_require__(152);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__ionic_native_keyboard__ = __webpack_require__(226);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__ionic_native_local_notifications__ = __webpack_require__(161);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__ionic_native_media_capture__ = __webpack_require__(242);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__ionic_native_network__ = __webpack_require__(103);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__ionic_native_push__ = __webpack_require__(604);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__ionic_native_splash_screen__ = __webpack_require__(619);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__ionic_native_status_bar__ = __webpack_require__(620);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__ionic_native_sqlite__ = __webpack_require__(494);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__ionic_native_zip__ = __webpack_require__(239);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__providers_camera__ = __webpack_require__(1111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__providers_clipboard__ = __webpack_require__(1112);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__providers_file__ = __webpack_require__(1113);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__providers_file_transfer__ = __webpack_require__(621);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__providers_globalization__ = __webpack_require__(1117);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__providers_inappbrowser__ = __webpack_require__(1118);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__providers_local_notifications__ = __webpack_require__(1120);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__providers_media_capture__ = __webpack_require__(1138);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__providers_network__ = __webpack_require__(1139);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__providers_zip__ = __webpack_require__(1140);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__providers_helper__ = __webpack_require__(1189);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__providers_capture_helper__ = __webpack_require__(166);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__providers_app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__providers_file__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_33__providers_utils_text__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_34__providers_utils_mimetype__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_35__providers_utils_url__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_36__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_37__providers_init__ = __webpack_require__(63);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


// Ionic Native services.

















// Services that Mock Ionic Native in browser an desktop.



















// List of Ionic Native providers.
var IONIC_NATIVE_PROVIDERS = [
    __WEBPACK_IMPORTED_MODULE_3__ionic_native_camera__["a" /* Camera */],
    __WEBPACK_IMPORTED_MODULE_4__ionic_native_clipboard__["a" /* Clipboard */],
    __WEBPACK_IMPORTED_MODULE_6__ionic_native_file__["a" /* File */],
    __WEBPACK_IMPORTED_MODULE_7__ionic_native_file_transfer__["a" /* FileTransfer */],
    __WEBPACK_IMPORTED_MODULE_8__ionic_native_globalization__["a" /* Globalization */],
    __WEBPACK_IMPORTED_MODULE_9__ionic_native_in_app_browser__["a" /* InAppBrowser */],
    __WEBPACK_IMPORTED_MODULE_10__ionic_native_keyboard__["a" /* Keyboard */],
    __WEBPACK_IMPORTED_MODULE_11__ionic_native_local_notifications__["a" /* LocalNotifications */],
    __WEBPACK_IMPORTED_MODULE_12__ionic_native_media_capture__["a" /* MediaCapture */],
    __WEBPACK_IMPORTED_MODULE_13__ionic_native_network__["a" /* Network */],
    __WEBPACK_IMPORTED_MODULE_15__ionic_native_splash_screen__["a" /* SplashScreen */],
    __WEBPACK_IMPORTED_MODULE_16__ionic_native_status_bar__["a" /* StatusBar */],
    __WEBPACK_IMPORTED_MODULE_17__ionic_native_sqlite__["a" /* SQLite */],
    __WEBPACK_IMPORTED_MODULE_18__ionic_native_zip__["a" /* Zip */]
];
/**
 * This module handles the emulation of Cordova plugins in browser and desktop.
 *
 * It includes the "mock" of all the Ionic Native services that should be supported in browser and desktop,
 * otherwise those features would only work in a Cordova environment.
 *
 * This module also determines if the app should use the original service or the mock. In each of the "useFactory"
 * functions we check if the app is running in mobile or not, and then provide the right service to use.
 */
var CoreEmulatorModule = /** @class */ (function () {
    function CoreEmulatorModule(appProvider, initDelegate, helper) {
        var win = window; // Convert the "window" to "any" type to be able to use non-standard properties.
        // Emulate Custom URL Scheme plugin in desktop apps.
        if (appProvider.isDesktop()) {
            __webpack_require__(1190).ipcRenderer.on('mmAppLaunched', function (event, url) {
                if (typeof win.handleOpenURL != 'undefined') {
                    win.handleOpenURL(url);
                }
            });
        }
        if (!appProvider.isMobile()) {
            // Register an init process to load the Mocks that need it.
            initDelegate.registerProcess(helper);
        }
    }
    CoreEmulatorModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [],
            providers: [
                __WEBPACK_IMPORTED_MODULE_2__ionic_native_badge__["a" /* Badge */],
                __WEBPACK_IMPORTED_MODULE_29__providers_helper__["a" /* CoreEmulatorHelperProvider */],
                __WEBPACK_IMPORTED_MODULE_30__providers_capture_helper__["a" /* CoreEmulatorCaptureHelperProvider */],
                {
                    provide: __WEBPACK_IMPORTED_MODULE_3__ionic_native_camera__["a" /* Camera */],
                    deps: [__WEBPACK_IMPORTED_MODULE_31__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_30__providers_capture_helper__["a" /* CoreEmulatorCaptureHelperProvider */]],
                    useFactory: function (appProvider, captureHelper) {
                        return appProvider.isMobile() ? new __WEBPACK_IMPORTED_MODULE_3__ionic_native_camera__["a" /* Camera */]() : new __WEBPACK_IMPORTED_MODULE_19__providers_camera__["a" /* CameraMock */](captureHelper);
                    }
                },
                {
                    provide: __WEBPACK_IMPORTED_MODULE_4__ionic_native_clipboard__["a" /* Clipboard */],
                    deps: [__WEBPACK_IMPORTED_MODULE_31__providers_app__["a" /* CoreAppProvider */]],
                    useFactory: function (appProvider) {
                        return appProvider.isMobile() ? new __WEBPACK_IMPORTED_MODULE_4__ionic_native_clipboard__["a" /* Clipboard */]() : new __WEBPACK_IMPORTED_MODULE_20__providers_clipboard__["a" /* ClipboardMock */](appProvider);
                    }
                },
                __WEBPACK_IMPORTED_MODULE_5__ionic_native_device__["a" /* Device */],
                {
                    provide: __WEBPACK_IMPORTED_MODULE_6__ionic_native_file__["a" /* File */],
                    deps: [__WEBPACK_IMPORTED_MODULE_31__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_33__providers_utils_text__["a" /* CoreTextUtilsProvider */]],
                    useFactory: function (appProvider, textUtils) {
                        // Use platform instead of CoreAppProvider to prevent circular dependencies.
                        return appProvider.isMobile() ? new __WEBPACK_IMPORTED_MODULE_6__ionic_native_file__["a" /* File */]() : new __WEBPACK_IMPORTED_MODULE_21__providers_file__["a" /* FileMock */](appProvider, textUtils);
                    }
                },
                {
                    provide: __WEBPACK_IMPORTED_MODULE_7__ionic_native_file_transfer__["a" /* FileTransfer */],
                    deps: [__WEBPACK_IMPORTED_MODULE_31__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_32__providers_file__["a" /* CoreFileProvider */]],
                    useFactory: function (appProvider, fileProvider) {
                        // Use platform instead of CoreAppProvider to prevent circular dependencies.
                        return appProvider.isMobile() ? new __WEBPACK_IMPORTED_MODULE_7__ionic_native_file_transfer__["a" /* FileTransfer */]() : new __WEBPACK_IMPORTED_MODULE_22__providers_file_transfer__["b" /* FileTransferMock */](appProvider, fileProvider);
                    }
                },
                {
                    provide: __WEBPACK_IMPORTED_MODULE_8__ionic_native_globalization__["a" /* Globalization */],
                    deps: [__WEBPACK_IMPORTED_MODULE_31__providers_app__["a" /* CoreAppProvider */]],
                    useFactory: function (appProvider) {
                        return appProvider.isMobile() ? new __WEBPACK_IMPORTED_MODULE_8__ionic_native_globalization__["a" /* Globalization */]() : new __WEBPACK_IMPORTED_MODULE_23__providers_globalization__["a" /* GlobalizationMock */](appProvider);
                    }
                },
                {
                    provide: __WEBPACK_IMPORTED_MODULE_9__ionic_native_in_app_browser__["a" /* InAppBrowser */],
                    deps: [__WEBPACK_IMPORTED_MODULE_31__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_32__providers_file__["a" /* CoreFileProvider */], __WEBPACK_IMPORTED_MODULE_35__providers_utils_url__["a" /* CoreUrlUtilsProvider */]],
                    useFactory: function (appProvider, fileProvider, urlUtils) {
                        return !appProvider.isDesktop() ? new __WEBPACK_IMPORTED_MODULE_9__ionic_native_in_app_browser__["a" /* InAppBrowser */]() : new __WEBPACK_IMPORTED_MODULE_24__providers_inappbrowser__["a" /* InAppBrowserMock */](appProvider, fileProvider, urlUtils);
                    }
                },
                __WEBPACK_IMPORTED_MODULE_10__ionic_native_keyboard__["a" /* Keyboard */],
                {
                    provide: __WEBPACK_IMPORTED_MODULE_11__ionic_native_local_notifications__["a" /* LocalNotifications */],
                    deps: [__WEBPACK_IMPORTED_MODULE_31__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_36__providers_utils_utils__["a" /* CoreUtilsProvider */]],
                    useFactory: function (appProvider, utils) {
                        // Use platform instead of CoreAppProvider to prevent circular dependencies.
                        return appProvider.isMobile() ? new __WEBPACK_IMPORTED_MODULE_11__ionic_native_local_notifications__["a" /* LocalNotifications */]() : new __WEBPACK_IMPORTED_MODULE_25__providers_local_notifications__["a" /* LocalNotificationsMock */](appProvider, utils);
                    }
                },
                {
                    provide: __WEBPACK_IMPORTED_MODULE_12__ionic_native_media_capture__["a" /* MediaCapture */],
                    deps: [__WEBPACK_IMPORTED_MODULE_31__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_30__providers_capture_helper__["a" /* CoreEmulatorCaptureHelperProvider */]],
                    useFactory: function (appProvider, captureHelper) {
                        return appProvider.isMobile() ? new __WEBPACK_IMPORTED_MODULE_12__ionic_native_media_capture__["a" /* MediaCapture */]() : new __WEBPACK_IMPORTED_MODULE_26__providers_media_capture__["a" /* MediaCaptureMock */](captureHelper);
                    }
                },
                {
                    provide: __WEBPACK_IMPORTED_MODULE_13__ionic_native_network__["a" /* Network */],
                    deps: [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */]],
                    useFactory: function (platform) {
                        // Use platform instead of CoreAppProvider to prevent circular dependencies.
                        return platform.is('cordova') ? new __WEBPACK_IMPORTED_MODULE_13__ionic_native_network__["a" /* Network */]() : new __WEBPACK_IMPORTED_MODULE_27__providers_network__["a" /* NetworkMock */]();
                    }
                },
                __WEBPACK_IMPORTED_MODULE_14__ionic_native_push__["a" /* Push */],
                __WEBPACK_IMPORTED_MODULE_15__ionic_native_splash_screen__["a" /* SplashScreen */],
                __WEBPACK_IMPORTED_MODULE_16__ionic_native_status_bar__["a" /* StatusBar */],
                __WEBPACK_IMPORTED_MODULE_17__ionic_native_sqlite__["a" /* SQLite */],
                {
                    provide: __WEBPACK_IMPORTED_MODULE_18__ionic_native_zip__["a" /* Zip */],
                    deps: [__WEBPACK_IMPORTED_MODULE_31__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_6__ionic_native_file__["a" /* File */], __WEBPACK_IMPORTED_MODULE_34__providers_utils_mimetype__["a" /* CoreMimetypeUtilsProvider */], __WEBPACK_IMPORTED_MODULE_33__providers_utils_text__["a" /* CoreTextUtilsProvider */]],
                    useFactory: function (appProvider, file, mimeUtils) {
                        // Use platform instead of CoreAppProvider to prevent circular dependencies.
                        return appProvider.isMobile() ? new __WEBPACK_IMPORTED_MODULE_18__ionic_native_zip__["a" /* Zip */]() : new __WEBPACK_IMPORTED_MODULE_28__providers_zip__["a" /* ZipMock */](file, mimeUtils);
                    }
                },
            ]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_31__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_37__providers_init__["a" /* CoreInitDelegate */], __WEBPACK_IMPORTED_MODULE_29__providers_helper__["a" /* CoreEmulatorHelperProvider */]])
    ], CoreEmulatorModule);
    return CoreEmulatorModule;
}());

//# sourceMappingURL=emulator.module.js.map

/***/ }),
/* 619 */,
/* 620 */,
/* 621 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FileTransferErrorMock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return FileTransferMock; });
/* unused harmony export FileTransferObjectMock */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_file_transfer__ = __webpack_require__(240);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_file__ = __webpack_require__(25);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Mock the File Transfer Error.
 */
var FileTransferErrorMock = /** @class */ (function () {
    // tslint:disable-next-line: variable-name
    function FileTransferErrorMock(code, source, target, http_status, body, exception) {
        this.code = code;
        this.source = source;
        this.target = target;
        this.http_status = http_status;
        this.body = body;
        this.exception = exception;
    }
    FileTransferErrorMock.FILE_NOT_FOUND_ERR = 1;
    FileTransferErrorMock.INVALID_URL_ERR = 2;
    FileTransferErrorMock.CONNECTION_ERR = 3;
    FileTransferErrorMock.ABORT_ERR = 4;
    FileTransferErrorMock.NOT_MODIFIED_ERR = 5;
    return FileTransferErrorMock;
}());

/**
 * Emulates the Cordova FileTransfer plugin in desktop apps and in browser.
 */
var FileTransferMock = /** @class */ (function (_super) {
    __extends(FileTransferMock, _super);
    function FileTransferMock(appProvider, fileProvider) {
        var _this = _super.call(this) || this;
        _this.appProvider = appProvider;
        _this.fileProvider = fileProvider;
        return _this;
    }
    /**
     * Creates a new FileTransferObjectMock object.
     *
     * @return {FileTransferObjectMock}
     */
    FileTransferMock.prototype.create = function () {
        return new FileTransferObjectMock(this.appProvider, this.fileProvider);
    };
    FileTransferMock = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_file__["a" /* CoreFileProvider */]])
    ], FileTransferMock);
    return FileTransferMock;
}(__WEBPACK_IMPORTED_MODULE_1__ionic_native_file_transfer__["a" /* FileTransfer */]));

/**
 * Emulates the FileTransferObject class in desktop apps and in browser.
 */
var FileTransferObjectMock = /** @class */ (function (_super) {
    __extends(FileTransferObjectMock, _super);
    function FileTransferObjectMock(appProvider, fileProvider) {
        var _this = _super.call(this) || this;
        _this.appProvider = appProvider;
        _this.fileProvider = fileProvider;
        return _this;
    }
    /**
     * Aborts an in-progress transfer. The onerror callback is passed a FileTransferError
     * object which has an error code of FileTransferError.ABORT_ERR.
     */
    FileTransferObjectMock.prototype.abort = function () {
        if (this.xhr) {
            this.xhr.abort();
            this.reject(new FileTransferErrorMock(FileTransferErrorMock.ABORT_ERR, this.source, this.target, null, null, null));
        }
    };
    /**
     * Downloads a file from server.
     *
     * @param {string} source URL of the server to download the file, as encoded by encodeURI().
     * @param {string} target Filesystem url representing the file on the device.
     * @param {boolean} [trustAllHosts] If set to true, it accepts all security certificates.
     * @param {object} [options] Optional parameters, currently only supports headers.
     * @returns {Promise<any>} Returns a Promise that resolves to a FileEntry object.
     */
    FileTransferObjectMock.prototype.download = function (source, target, trustAllHosts, options) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            // Use XMLHttpRequest instead of HttpClient to support onprogress and abort.
            var basicAuthHeader = _this.getBasicAuthHeader(source), xhr = new XMLHttpRequest(), isDesktop = _this.appProvider.isDesktop();
            var headers = null;
            _this.xhr = xhr;
            _this.source = source;
            _this.target = target;
            _this.reject = reject;
            if (basicAuthHeader) {
                source = source.replace(_this.getUrlCredentials(source) + '@', '');
                options = options || {};
                options.headers = options.headers || {};
                options.headers[basicAuthHeader.name] = basicAuthHeader.value;
            }
            if (options) {
                headers = options.headers || null;
            }
            // Prepare the request.
            xhr.open('GET', source, true);
            xhr.responseType = isDesktop ? 'arraybuffer' : 'blob';
            for (var name_1 in headers) {
                xhr.setRequestHeader(name_1, headers[name_1]);
            }
            xhr.onprogress = function (xhr, ev) {
                if (_this.progressListener) {
                    _this.progressListener(ev);
                }
            };
            xhr.onerror = function (err) {
                reject(new FileTransferError(-1, source, target, xhr.status, xhr.statusText));
            };
            xhr.onload = function () {
                // Finished dowloading the file.
                var response = xhr.response;
                if (!response) {
                    reject();
                }
                else {
                    var basePath = _this.fileProvider.getBasePathInstant();
                    target = target.replace(basePath, ''); // Remove basePath from the target.
                    target = target.replace(/%20/g, ' '); // Replace all %20 with spaces.
                    if (isDesktop) {
                        // In desktop we need to convert the arraybuffer into a Buffer.
                        response = Buffer.from(new Uint8Array(response));
                    }
                    _this.fileProvider.writeFile(target, response).then(resolve, reject);
                }
            };
            xhr.send();
        });
    };
    /**
     * Given a URL, check if it has a credentials in it and, if so, return them in a header object.
     * This code is extracted from Cordova FileTransfer plugin.
     *
     * @param {string} urlString The URL to get the credentials from.
     * @return {any} The header with the credentials, null if no credentials.
     */
    FileTransferObjectMock.prototype.getBasicAuthHeader = function (urlString) {
        var header = null;
        // MS Windows doesn't support credentials in http uris so we detect them by regexp and strip off from result url.
        if (window.btoa) {
            var credentials = this.getUrlCredentials(urlString);
            if (credentials) {
                var authHeader = 'Authorization', authHeaderValue = 'Basic ' + window.btoa(credentials);
                header = {
                    name: authHeader,
                    value: authHeaderValue
                };
            }
        }
        return header;
    };
    /**
     * Given an instance of XMLHttpRequest, get the response headers as an object.
     *
     * @param {XMLHttpRequest} xhr XMLHttpRequest instance.
     * @return {{[s: string]: any}} Object with the headers.
     */
    FileTransferObjectMock.prototype.getHeadersAsObject = function (xhr) {
        var headersString = xhr.getAllResponseHeaders(), result = {};
        if (headersString) {
            var headers = headersString.split('\n');
            for (var i in headers) {
                var headerString = headers[i], separatorPos = headerString.indexOf(':');
                if (separatorPos != -1) {
                    result[headerString.substr(0, separatorPos)] = headerString.substr(separatorPos + 1).trim();
                }
            }
        }
        return result;
    };
    /**
     * Get the credentials from a URL.
     * This code is extracted from Cordova FileTransfer plugin.
     *
     * @param {string} urlString The URL to get the credentials from.
     * @return {string} Retrieved credentials.
     */
    FileTransferObjectMock.prototype.getUrlCredentials = function (urlString) {
        var credentialsPattern = /^https?\:\/\/(?:(?:(([^:@\/]*)(?::([^@\/]*))?)?@)?([^:\/?#]*)(?::(\d*))?).*$/, credentials = credentialsPattern.exec(urlString);
        return credentials && credentials[1];
    };
    /**
     * Registers a listener that gets called whenever a new chunk of data is transferred.
     *
     * @param {Function} listener Listener that takes a progress event.
     */
    FileTransferObjectMock.prototype.onProgress = function (listener) {
        this.progressListener = listener;
    };
    /**
     * Sends a file to a server.
     *
     * @param {string} fileUrl Filesystem URL representing the file on the device or a data URI.
     * @param {string} url URL of the server to receive the file, as encoded by encodeURI().
     * @param {FileUploadOptions} [options] Optional parameters.
     * @param {boolean} [trustAllHosts] If set to true, it accepts all security certificates.
     * @returns {Promise<FileUploadResult>} Promise that resolves to a FileUploadResult and rejects with FileTransferError.
     */
    FileTransferObjectMock.prototype.upload = function (fileUrl, url, options, trustAllHosts) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var basicAuthHeader = _this.getBasicAuthHeader(url);
            var fileKey = null, fileName = null, params = null, headers = null, httpMethod = null;
            if (basicAuthHeader) {
                url = url.replace(_this.getUrlCredentials(url) + '@', '');
                options = options || {};
                options.headers = options.headers || {};
                options.headers[basicAuthHeader.name] = basicAuthHeader.value;
            }
            if (options) {
                fileKey = options.fileKey;
                fileName = options.fileName;
                headers = options.headers;
                httpMethod = options.httpMethod || 'POST';
                if (httpMethod.toUpperCase() == 'PUT') {
                    httpMethod = 'PUT';
                }
                else {
                    httpMethod = 'POST';
                }
                if (options.params) {
                    params = options.params;
                }
                else {
                    params = {};
                }
            }
            // Add fileKey and fileName to the headers.
            headers = headers || {};
            if (!headers['Content-Disposition']) {
                headers['Content-Disposition'] = 'form-data;' + (fileKey ? ' name="' + fileKey + '";' : '') +
                    (fileName ? ' filename="' + fileName + '"' : '');
            }
            // Adding a Content-Type header with the mimeType makes the request fail (it doesn't detect the token in the params).
            // Don't include this header, and delete it if it's supplied.
            delete headers['Content-Type'];
            // Get the file to upload.
            _this.fileProvider.getFile(fileUrl).then(function (fileEntry) {
                return _this.fileProvider.getFileObjectFromFileEntry(fileEntry);
            }).then(function (file) {
                // Use XMLHttpRequest instead of HttpClient to support onprogress and abort.
                var xhr = new XMLHttpRequest();
                xhr.open(httpMethod || 'POST', url);
                for (var name_2 in headers) {
                    // Filter "unsafe" headers.
                    if (name_2 != 'Connection') {
                        xhr.setRequestHeader(name_2, headers[name_2]);
                    }
                }
                xhr.onprogress = function (ev) {
                    if (_this.progressListener) {
                        _this.progressListener(ev);
                    }
                };
                _this.xhr = xhr;
                _this.source = fileUrl;
                _this.target = url;
                _this.reject = reject;
                xhr.onerror = function () {
                    reject(new FileTransferError(-1, fileUrl, url, xhr.status, xhr.statusText));
                };
                xhr.onload = function () {
                    // Finished uploading the file.
                    resolve({
                        bytesSent: file.size,
                        responseCode: xhr.status,
                        response: xhr.response,
                        headers: _this.getHeadersAsObject(xhr)
                    });
                };
                // Create a form data to send params and the file.
                var fd = new FormData();
                for (var name_3 in params) {
                    fd.append(name_3, params[name_3]);
                }
                fd.append('file', file);
                xhr.send(fd);
            }).catch(reject);
        });
    };
    return FileTransferObjectMock;
}(__WEBPACK_IMPORTED_MODULE_1__ionic_native_file_transfer__["b" /* FileTransferObject */]));

//# sourceMappingURL=file-transfer.js.map
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(109).Buffer))

/***/ }),
/* 622 */,
/* 623 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 624 */,
/* 625 */,
/* 626 */,
/* 627 */,
/* 628 */,
/* 629 */,
/* 630 */,
/* 631 */,
/* 632 */,
/* 633 */,
/* 634 */,
/* 635 */,
/* 636 */,
/* 637 */,
/* 638 */,
/* 639 */,
/* 640 */,
/* 641 */,
/* 642 */,
/* 643 */,
/* 644 */,
/* 645 */,
/* 646 */,
/* 647 */,
/* 648 */,
/* 649 */,
/* 650 */,
/* 651 */,
/* 652 */,
/* 653 */,
/* 654 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSitePluginsCallWSOnClickBaseDirective; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__call_ws_directive__ = __webpack_require__(655);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Base class for directives to call a WS when the element is clicked.
 *
 * The directives that inherit from this class will call a WS method when the element is clicked.
 *
 * @see CoreSitePluginsCallWSBaseDirective
 */
var CoreSitePluginsCallWSOnClickBaseDirective = /** @class */ (function (_super) {
    __extends(CoreSitePluginsCallWSOnClickBaseDirective, _super);
    function CoreSitePluginsCallWSOnClickBaseDirective(element, translate, domUtils, sitePluginsProvider, parentContent) {
        var _this = _super.call(this, element, translate, domUtils, sitePluginsProvider, parentContent) || this;
        _this.translate = translate;
        _this.domUtils = domUtils;
        _this.sitePluginsProvider = sitePluginsProvider;
        _this.parentContent = parentContent;
        return _this;
    }
    /**
     * Component being initialized.
     */
    CoreSitePluginsCallWSOnClickBaseDirective.prototype.ngOnInit = function () {
        var _this = this;
        _super.prototype.ngOnInit.call(this);
        this.element.addEventListener('click', function (ev) {
            ev.preventDefault();
            ev.stopPropagation();
            if (typeof _this.confirmMessage != 'undefined') {
                // Ask for confirm.
                _this.domUtils.showConfirm(_this.confirmMessage || _this.translate.instant('core.areyousure')).then(function () {
                    _this.callWS();
                }).catch(function () {
                    // User cancelled, ignore.
                });
            }
            else {
                _this.callWS();
            }
        });
    };
    /**
     * Call a WS.
     *
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreSitePluginsCallWSOnClickBaseDirective.prototype.callWS = function () {
        var modal = this.domUtils.showModalLoading();
        return _super.prototype.callWS.call(this).finally(function () {
            modal.dismiss();
        });
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreSitePluginsCallWSOnClickBaseDirective.prototype, "confirmMessage", void 0);
    return CoreSitePluginsCallWSOnClickBaseDirective;
}(__WEBPACK_IMPORTED_MODULE_1__call_ws_directive__["a" /* CoreSitePluginsCallWSBaseDirective */]));

//# sourceMappingURL=call-ws-click-directive.js.map

/***/ }),
/* 655 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSitePluginsCallWSBaseDirective; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

/**
 * Base class for directives that need to call a WS.
 */
var CoreSitePluginsCallWSBaseDirective = /** @class */ (function () {
    function CoreSitePluginsCallWSBaseDirective(element, translate, domUtils, sitePluginsProvider, parentContent) {
        this.translate = translate;
        this.domUtils = domUtils;
        this.sitePluginsProvider = sitePluginsProvider;
        this.parentContent = parentContent;
        this.element = element.nativeElement || element;
    }
    /**
     * Component being initialized.
     */
    CoreSitePluginsCallWSBaseDirective.prototype.ngOnInit = function () {
        var _this = this;
        if (this.parentContent && this.parentContent.invalidateObservable) {
            this.invalidateObserver = this.parentContent.invalidateObservable.subscribe(function () {
                _this.invalidate();
            });
        }
    };
    /**
     * Call a WS.
     *
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreSitePluginsCallWSBaseDirective.prototype.callWS = function () {
        var _this = this;
        var params = this.getParamsForWS();
        return this.sitePluginsProvider.callWS(this.name, params, this.preSets).then(function (result) {
            return _this.wsCallSuccess(result);
        }).catch(function (error) {
            _this.domUtils.showErrorModalDefault(error, 'core.serverconnection', true);
        });
    };
    /**
     * Get the params for the WS call.
     *
     * @return {any} Params.
     */
    CoreSitePluginsCallWSBaseDirective.prototype.getParamsForWS = function () {
        var params = this.params || {};
        if (this.parentContent) {
            params = this.sitePluginsProvider.loadOtherDataInArgs(params, this.parentContent.otherData, this.useOtherDataForWS);
        }
        if (this.form && document.forms[this.form]) {
            params = Object.assign(params, this.domUtils.getDataFromForm(document.forms[this.form]));
        }
        return params;
    };
    /**
     * Function called when the WS call is successful.
     *
     * @param {any} result Result of the WS call.
     */
    CoreSitePluginsCallWSBaseDirective.prototype.wsCallSuccess = function (result) {
        // Function to be overridden.
    };
    /**
     * Invalidate the WS call.
     *
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreSitePluginsCallWSBaseDirective.prototype.invalidate = function () {
        var params = this.getParamsForWS();
        return this.sitePluginsProvider.invalidateCallWS(this.name, params, this.preSets);
    };
    /**
     * Directive destroyed.
     */
    CoreSitePluginsCallWSBaseDirective.prototype.ngOnDestroy = function () {
        this.invalidateObserver && this.invalidateObserver.unsubscribe();
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreSitePluginsCallWSBaseDirective.prototype, "name", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreSitePluginsCallWSBaseDirective.prototype, "params", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreSitePluginsCallWSBaseDirective.prototype, "preSets", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Array)
    ], CoreSitePluginsCallWSBaseDirective.prototype, "useOtherDataForWS", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreSitePluginsCallWSBaseDirective.prototype, "form", void 0);
    return CoreSitePluginsCallWSBaseDirective;
}());

//# sourceMappingURL=call-ws-directive.js.map

/***/ }),
/* 656 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSitePluginsUserProfileFieldComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_siteplugins__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_compile_components_compile_html_compile_html__ = __webpack_require__(606);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Component that displays a user profile field created using a site plugin.
 */
var CoreSitePluginsUserProfileFieldComponent = /** @class */ (function () {
    function CoreSitePluginsUserProfileFieldComponent(sitePluginsProvider) {
        this.sitePluginsProvider = sitePluginsProvider;
        this.signup = false; // True if editing the field in signup. Defaults to false.
        this.edit = false; // True if editing the field. Defaults to false.
        this.content = ''; // Content.
    }
    /**
     * Component being initialized.
     */
    CoreSitePluginsUserProfileFieldComponent.prototype.ngOnInit = function () {
        // Pass the input data to the component.
        this.jsData = {
            field: this.field,
            signup: this.signup,
            edit: this.edit,
            form: this.form,
            registerAuth: this.registerAuth
        };
        if (this.field) {
            // Retrieve the handler data.
            var handler = this.sitePluginsProvider.getSitePluginHandler(this.field.type || this.field.datatype), handlerSchema_1 = handler && handler.handlerSchema;
            if (handlerSchema_1) {
                // Load first template.
                if (handlerSchema_1.methodTemplates && handlerSchema_1.methodTemplates.length) {
                    this.content = handler.handlerSchema.methodTemplates[0].html;
                }
                // Wait for the instance to be created.
                if (this.compileComponent && this.compileComponent.componentObservable &&
                    handlerSchema_1.methodJSResult && handlerSchema_1.methodJSResult.componentInit) {
                    this.componentObserver = this.compileComponent.componentObservable.subscribe(function (instance) {
                        if (instance) {
                            // Instance created, call component init.
                            handlerSchema_1.methodJSResult.componentInit.apply(instance);
                        }
                    });
                }
            }
        }
    };
    /**
     * Component destroyed.
     */
    CoreSitePluginsUserProfileFieldComponent.prototype.ngOnDestroy = function () {
        this.componentObserver && this.componentObserver.unsubscribe();
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreSitePluginsUserProfileFieldComponent.prototype, "field", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreSitePluginsUserProfileFieldComponent.prototype, "signup", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreSitePluginsUserProfileFieldComponent.prototype, "edit", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreSitePluginsUserProfileFieldComponent.prototype, "form", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreSitePluginsUserProfileFieldComponent.prototype, "registerAuth", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])(__WEBPACK_IMPORTED_MODULE_2__core_compile_components_compile_html_compile_html__["a" /* CoreCompileHtmlComponent */]),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_2__core_compile_components_compile_html_compile_html__["a" /* CoreCompileHtmlComponent */])
    ], CoreSitePluginsUserProfileFieldComponent.prototype, "compileComponent", void 0);
    CoreSitePluginsUserProfileFieldComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-site-plugins-user-profile-field',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/core/siteplugins/components/user-profile-field/user-profile-field.html"*/'<core-compile-html [text]="content" [jsData]="jsData"></core-compile-html>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/core/siteplugins/components/user-profile-field/user-profile-field.html"*/,
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_siteplugins__["a" /* CoreSitePluginsProvider */]])
    ], CoreSitePluginsUserProfileFieldComponent);
    return CoreSitePluginsUserProfileFieldComponent;
}());

//# sourceMappingURL=user-profile-field.js.map

/***/ }),
/* 657 */,
/* 658 */,
/* 659 */,
/* 660 */,
/* 661 */,
/* 662 */,
/* 663 */,
/* 664 */,
/* 665 */,
/* 666 */,
/* 667 */,
/* 668 */,
/* 669 */,
/* 670 */,
/* 671 */,
/* 672 */,
/* 673 */,
/* 674 */,
/* 675 */,
/* 676 */,
/* 677 */,
/* 678 */,
/* 679 */,
/* 680 */,
/* 681 */,
/* 682 */,
/* 683 */,
/* 684 */,
/* 685 */,
/* 686 */,
/* 687 */,
/* 688 */,
/* 689 */,
/* 690 */,
/* 691 */,
/* 692 */,
/* 693 */,
/* 694 */,
/* 695 */,
/* 696 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCronDelegate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_network__ = __webpack_require__(103);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__config__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_constants__ = __webpack_require__(22);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};







/*
 * Service to handle cron processes. The registered processes will be executed every certain time.
*/
var CoreCronDelegate = /** @class */ (function () {
    function CoreCronDelegate(logger, appProvider, configProvider, utils, network) {
        var _this = this;
        this.appProvider = appProvider;
        this.configProvider = configProvider;
        this.utils = utils;
        // Variables for database.
        this.CRON_TABLE = 'cron';
        this.tableSchema = {
            name: this.CRON_TABLE,
            columns: [
                {
                    name: 'id',
                    type: 'TEXT',
                    primaryKey: true
                },
                {
                    name: 'value',
                    type: 'INTEGER'
                }
            ]
        };
        this.handlers = {};
        this.queuePromise = Promise.resolve();
        this.logger = logger.getInstance('CoreCronDelegate');
        this.appDB = this.appProvider.getDB();
        this.appDB.createTableFromSchema(this.tableSchema);
        // When the app is re-connected, start network handlers that were stopped.
        network.onConnect().subscribe(function () {
            _this.startNetworkHandlers();
        });
    }
    CoreCronDelegate_1 = CoreCronDelegate;
    /**
     * Try to execute a handler. It will schedule the next execution once done.
     * If the handler cannot be executed or it fails, it will be re-executed after mmCoreCronMinInterval.
     *
     * @param {string} name Name of the handler.
     * @param {boolean} [force] Wether the execution is forced (manual sync).
     * @param {string}  [siteId] Site ID. If not defined, all sites.
     * @return {Promise<any>} Promise resolved if handler is executed successfully, rejected otherwise.
     */
    CoreCronDelegate.prototype.checkAndExecuteHandler = function (name, force, siteId) {
        var _this = this;
        if (!this.handlers[name] || !this.handlers[name].execute) {
            // Invalid handler.
            this.logger.debug('Cannot execute handler because is invalid: ' + name);
            return Promise.reject(null);
        }
        var usesNetwork = this.handlerUsesNetwork(name), isSync = !force && this.isHandlerSync(name);
        var promise;
        if (usesNetwork && !this.appProvider.isOnline()) {
            // Offline, stop executing.
            this.logger.debug('Cannot execute handler because device is offline: ' + name);
            this.stopHandler(name);
            return Promise.reject(null);
        }
        if (isSync) {
            // Check network connection.
            promise = this.configProvider.get(__WEBPACK_IMPORTED_MODULE_6__core_constants__["a" /* CoreConstants */].SETTINGS_SYNC_ONLY_ON_WIFI, false).then(function (syncOnlyOnWifi) {
                return !syncOnlyOnWifi || !_this.appProvider.isNetworkAccessLimited();
            });
        }
        else {
            promise = Promise.resolve(true);
        }
        return promise.then(function (execute) {
            if (!execute) {
                // Cannot execute in this network connection, retry soon.
                _this.logger.debug('Cannot execute handler because device is using limited connection: ' + name);
                _this.scheduleNextExecution(name, CoreCronDelegate_1.MIN_INTERVAL);
                return Promise.reject(null);
            }
            // Add the execution to the queue.
            _this.queuePromise = _this.queuePromise.catch(function () {
                // Ignore errors in previous handlers.
            }).then(function () {
                return _this.executeHandler(name, siteId).then(function () {
                    _this.logger.debug("Execution of handler '" + name + "' was a success.");
                    return _this.setHandlerLastExecutionTime(name, Date.now()).then(function () {
                        _this.scheduleNextExecution(name);
                    });
                }, function () {
                    // Handler call failed. Retry soon.
                    _this.logger.debug("Execution of handler '" + name + "' failed.");
                    _this.scheduleNextExecution(name, CoreCronDelegate_1.MIN_INTERVAL);
                    return Promise.reject(null);
                });
            });
            return _this.queuePromise;
        });
    };
    /**
     * Run a handler, cancelling the execution if it takes more than MAX_TIME_PROCESS.
     *
     * @param {string} name Name of the handler.
     * @param {string} [siteId] Site ID. If not defined, all sites.
     * @return {Promise<any>} Promise resolved when the handler finishes or reaches max time, rejected if it fails.
     */
    CoreCronDelegate.prototype.executeHandler = function (name, siteId) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var cancelTimeout;
            _this.logger.debug('Executing handler: ' + name);
            // Wrap the call in Promise.resolve to make sure it's a promise.
            Promise.resolve(_this.handlers[name].execute(siteId)).then(resolve).catch(reject).finally(function () {
                clearTimeout(cancelTimeout);
            });
            cancelTimeout = setTimeout(function () {
                // The handler took too long. Resolve because we don't want to retry soon.
                _this.logger.debug("Resolving execution of handler '" + name + "' because it took too long.");
                resolve();
            }, CoreCronDelegate_1.MAX_TIME_PROCESS);
        });
    };
    /**
     * Force execution of synchronization cron tasks without waiting for the scheduled time.
     * Please notice that some tasks may not be executed depending on the network connection and sync settings.
     *
     * @param {string} [siteId] Site ID. If not defined, all sites.
     * @return {Promise<any>} Promise resolved if all handlers are executed successfully, rejected otherwise.
     */
    CoreCronDelegate.prototype.forceSyncExecution = function (siteId) {
        var promises = [];
        for (var name_1 in this.handlers) {
            var handler = this.handlers[name_1];
            if (this.isHandlerManualSync(name_1)) {
                // Mark the handler as running (it might be running already).
                handler.running = true;
                // Cancel pending timeout.
                clearTimeout(handler.timeout);
                delete handler.timeout;
                // Now force the execution of the handler.
                promises.push(this.checkAndExecuteHandler(name_1, true, siteId));
            }
        }
        return this.utils.allPromises(promises);
    };
    /**
     * Get a handler's interval.
     *
     * @param {string} name Handler's name.
     * @return {number} Handler's interval.
     */
    CoreCronDelegate.prototype.getHandlerInterval = function (name) {
        if (!this.handlers[name] || !this.handlers[name].getInterval) {
            // Invalid, return default.
            return CoreCronDelegate_1.DEFAULT_INTERVAL;
        }
        // Don't allow intervals lower than the minimum.
        var minInterval = this.appProvider.isDesktop() ? CoreCronDelegate_1.DESKTOP_MIN_INTERVAL : CoreCronDelegate_1.MIN_INTERVAL, handlerInterval = this.handlers[name].getInterval();
        if (!handlerInterval) {
            return CoreCronDelegate_1.DEFAULT_INTERVAL;
        }
        else {
            return Math.max(minInterval, handlerInterval);
        }
    };
    /**
     * Get a handler's last execution ID.
     *
     * @param {string} name Handler's name.
     * @return {string} Handler's last execution ID.
     */
    CoreCronDelegate.prototype.getHandlerLastExecutionId = function (name) {
        return 'last_execution_' + name;
    };
    /**
     * Get a handler's last execution time. If not defined, return 0.
     *
     * @param {string} name Handler's name.
     * @return {Promise<number>} Promise resolved with the handler's last execution time.
     */
    CoreCronDelegate.prototype.getHandlerLastExecutionTime = function (name) {
        var id = this.getHandlerLastExecutionId(name);
        return this.appDB.getRecord(this.CRON_TABLE, { id: id }).then(function (entry) {
            var time = parseInt(entry.value, 10);
            return isNaN(time) ? 0 : time;
        }).catch(function () {
            return 0; // Not set, return 0.
        });
    };
    /**
     * Check if a handler uses network. Defaults to true.
     *
     * @param {string} name Handler's name.
     * @return {boolean} True if handler uses network or not defined, false otherwise.
     */
    CoreCronDelegate.prototype.handlerUsesNetwork = function (name) {
        if (!this.handlers[name] || !this.handlers[name].usesNetwork) {
            // Invalid, return default.
            return true;
        }
        return this.handlers[name].usesNetwork();
    };
    /**
     * Check if there is any manual sync handler registered.
     *
     * @return {boolean} Whether it has at least 1 manual sync handler.
     */
    CoreCronDelegate.prototype.hasManualSyncHandlers = function () {
        for (var name_2 in this.handlers) {
            if (this.isHandlerManualSync(name_2)) {
                return true;
            }
        }
        return false;
    };
    /**
     * Check if there is any sync handler registered.
     *
     * @return {boolean} Whether it has at least 1 sync handler.
     */
    CoreCronDelegate.prototype.hasSyncHandlers = function () {
        for (var name_3 in this.handlers) {
            if (this.isHandlerSync(name_3)) {
                return true;
            }
        }
        return false;
    };
    /**
     * Check if a handler can be manually synced. Defaults will use isSync instead.
     *
     * @param {string} name Handler's name.
     * @return {boolean} True if handler is a sync process and can be manually executed or not defined, false otherwise.
     */
    CoreCronDelegate.prototype.isHandlerManualSync = function (name) {
        if (!this.handlers[name] || !this.handlers[name].canManualSync) {
            // Invalid, return default.
            return this.isHandlerSync(name);
        }
        return this.handlers[name].canManualSync();
    };
    /**
     * Check if a handler is a sync process. Defaults to true.
     *
     * @param {string} name Handler's name.
     * @return {boolean} True if handler is a sync process or not defined, false otherwise.
     */
    CoreCronDelegate.prototype.isHandlerSync = function (name) {
        if (!this.handlers[name] || !this.handlers[name].isSync) {
            // Invalid, return default.
            return true;
        }
        return this.handlers[name].isSync();
    };
    /**
     * Register a handler to be executed every certain time.
     *
     * @param {CoreCronHandler} handler The handler to register.
     */
    CoreCronDelegate.prototype.register = function (handler) {
        if (!handler || !handler.name) {
            // Invalid handler.
            return;
        }
        if (typeof this.handlers[handler.name] != 'undefined') {
            this.logger.debug("The cron handler '" + handler.name + "' is already registered.");
            return;
        }
        this.logger.debug("Register handler '" + handler.name + "' in cron.");
        handler.running = false;
        this.handlers[handler.name] = handler;
        // Start the handler.
        this.startHandler(handler.name);
    };
    /**
     * Schedule a next execution for a handler.
     *
     * @param {string} name Name of the handler.
     * @param {number} [time] Time to the next execution. If not supplied it will be calculated using the last execution and
     *                        the handler's interval. This param should be used only if it's really necessary.
     */
    CoreCronDelegate.prototype.scheduleNextExecution = function (name, time) {
        var _this = this;
        if (!this.handlers[name]) {
            // Invalid handler.
            return;
        }
        if (this.handlers[name].timeout) {
            // There's already a pending timeout.
            return;
        }
        var promise;
        if (time) {
            promise = Promise.resolve(time);
        }
        else {
            // Get last execution time to check when do we need to execute it.
            promise = this.getHandlerLastExecutionTime(name).then(function (lastExecution) {
                var interval = _this.getHandlerInterval(name), nextExecution = lastExecution + interval;
                return nextExecution - Date.now();
            });
        }
        promise.then(function (nextExecution) {
            _this.logger.debug("Scheduling next execution of handler '" + name + "' in '" + nextExecution + "' ms");
            if (nextExecution < 0) {
                nextExecution = 0; // Big negative numbers aren't executed immediately.
            }
            _this.handlers[name].timeout = setTimeout(function () {
                delete _this.handlers[name].timeout;
                _this.checkAndExecuteHandler(name);
            }, nextExecution);
        });
    };
    /**
     * Set a handler's last execution time.
     *
     * @param {string} name Handler's name.
     * @param {number} time Time to set.
     * @return {Promise}    Promise resolved when the execution time is saved.
     */
    CoreCronDelegate.prototype.setHandlerLastExecutionTime = function (name, time) {
        var id = this.getHandlerLastExecutionId(name), entry = {
            id: id,
            value: time
        };
        return this.appDB.insertOrUpdateRecord(this.CRON_TABLE, entry, { id: id });
    };
    /**
     * Start running a handler periodically.
     *
     * @param {string} name Name of the handler.
     */
    CoreCronDelegate.prototype.startHandler = function (name) {
        if (!this.handlers[name]) {
            // Invalid handler.
            this.logger.debug("Cannot start handler '" + name + "', is invalid.");
            return;
        }
        if (this.handlers[name].running) {
            this.logger.debug("Handler '" + name + "', is already running.");
            return;
        }
        this.handlers[name].running = true;
        this.scheduleNextExecution(name);
    };
    /**
     * Start running periodically the handlers that use network.
     */
    CoreCronDelegate.prototype.startNetworkHandlers = function () {
        for (var name_4 in this.handlers) {
            if (this.handlerUsesNetwork(name_4)) {
                this.startHandler(name_4);
            }
        }
    };
    /**
     * Stop running a handler periodically.
     *
     * @param {string} name Name of the handler.
     */
    CoreCronDelegate.prototype.stopHandler = function (name) {
        if (!this.handlers[name]) {
            // Invalid handler.
            this.logger.debug("Cannot stop handler '" + name + "', is invalid.");
            return;
        }
        if (!this.handlers[name].running) {
            this.logger.debug("Cannot stop handler '" + name + "', it's not running.");
            return;
        }
        this.handlers[name].running = false;
        clearTimeout(this.handlers[name].timeout);
        delete this.handlers[name].timeout;
    };
    // Constants.
    CoreCronDelegate.DEFAULT_INTERVAL = 3600000; // Default interval is 1 hour.
    CoreCronDelegate.MIN_INTERVAL = 300000; // Minimum interval is 5 minutes.
    CoreCronDelegate.DESKTOP_MIN_INTERVAL = 60000; // Minimum interval in desktop is 1 minute.
    CoreCronDelegate.MAX_TIME_PROCESS = 120000; // Max time a process can block the queue. Defaults to 2 minutes.
    CoreCronDelegate = CoreCronDelegate_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_3__config__["a" /* CoreConfigProvider */],
            __WEBPACK_IMPORTED_MODULE_5__utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_1__ionic_native_network__["a" /* Network */]])
    ], CoreCronDelegate);
    return CoreCronDelegate;
    var CoreCronDelegate_1;
}());

//# sourceMappingURL=cron.js.map

/***/ }),
/* 697 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonUserProfileFieldCheckboxComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_forms__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__ = __webpack_require__(9);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Directive to render a checkbox user profile field.
 */
var AddonUserProfileFieldCheckboxComponent = /** @class */ (function () {
    function AddonUserProfileFieldCheckboxComponent(fb, utils) {
        this.fb = fb;
        this.utils = utils;
        this.edit = false; // True if editing the field. Defaults to false.
        this.disabled = false; // True if disabled. Defaults to false.
    }
    /**
     * Component being initialized.
     */
    AddonUserProfileFieldCheckboxComponent.prototype.ngOnInit = function () {
        var field = this.field;
        if (field && this.edit && this.form) {
            field.modelName = 'profile_field_' + field.shortname;
            // Initialize the value.
            var formData = {
                value: this.utils.isTrueOrOne(field.defaultdata),
                disabled: this.disabled
            };
            this.form.addControl(field.modelName, this.fb.control(formData, field.required && !field.locked ? __WEBPACK_IMPORTED_MODULE_1__angular_forms__["h" /* Validators */].requiredTrue : null));
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], AddonUserProfileFieldCheckboxComponent.prototype, "field", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], AddonUserProfileFieldCheckboxComponent.prototype, "edit", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], AddonUserProfileFieldCheckboxComponent.prototype, "disabled", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_1__angular_forms__["c" /* FormGroup */])
    ], AddonUserProfileFieldCheckboxComponent.prototype, "form", void 0);
    AddonUserProfileFieldCheckboxComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'addon-user-profile-field-checkbox',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/addon/userprofilefield/checkbox/component/checkbox.html"*/'<!-- Render (no edit). -->\n<ion-item *ngIf="!edit && field && field.name">\n    <h2>{{ field.name }}</h2>\n    <p *ngIf="field.value != \'0\'">\n        {{ \'core.yes\' | translate }}\n    </p>\n    <p *ngIf="field.value == \'0\'">\n        {{ \'core.no\' | translate }}\n    </p>\n</ion-item>\n<!-- Edit. -->\n<ion-item *ngIf="edit && field && field.shortname" [formGroup]="form">\n    <ion-label [core-mark-required]="field.required">{{ field.name }}</ion-label>\n    <ion-checkbox item-end [formControlName]="field.modelName">\n    </ion-checkbox>\n    <core-input-errors [control]="form.controls[field.modelName]" [errorMessages]="errors"></core-input-errors>\n</ion-item>'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/addon/userprofilefield/checkbox/component/checkbox.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_forms__["a" /* FormBuilder */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], AddonUserProfileFieldCheckboxComponent);
    return AddonUserProfileFieldCheckboxComponent;
}());

//# sourceMappingURL=checkbox.js.map

/***/ }),
/* 698 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonUserProfileFieldDatetimeComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_forms__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_time__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__ = __webpack_require__(9);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Directive to render a datetime user profile field.
 */
var AddonUserProfileFieldDatetimeComponent = /** @class */ (function () {
    function AddonUserProfileFieldDatetimeComponent(fb, timeUtils, utils) {
        this.fb = fb;
        this.timeUtils = timeUtils;
        this.utils = utils;
        this.edit = false; // True if editing the field. Defaults to false.
        this.disabled = false; // True if disabled. Defaults to false.
    }
    /**
     * Component being initialized.
     */
    AddonUserProfileFieldDatetimeComponent.prototype.ngOnInit = function () {
        var field = this.field;
        var year;
        if (field && this.edit && this.form) {
            field.modelName = 'profile_field_' + field.shortname;
            // Check if it's only date or it has time too.
            var hasTime = this.utils.isTrueOrOne(field.param3);
            field.format = hasTime ? this.timeUtils.getLocalizedDateFormat('LLL') : this.timeUtils.getLocalizedDateFormat('LL');
            // Check min value.
            if (field.param1) {
                year = parseInt(field.param1, 10);
                if (year) {
                    field.min = year;
                }
            }
            // Check max value.
            if (field.param2) {
                year = parseInt(field.param2, 10);
                if (year) {
                    field.max = year;
                }
            }
            var formData = {
                value: field.defaultdata,
                disabled: this.disabled
            };
            this.form.addControl(field.modelName, this.fb.control(formData, field.required && !field.locked ? __WEBPACK_IMPORTED_MODULE_1__angular_forms__["h" /* Validators */].required : null));
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], AddonUserProfileFieldDatetimeComponent.prototype, "field", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], AddonUserProfileFieldDatetimeComponent.prototype, "edit", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], AddonUserProfileFieldDatetimeComponent.prototype, "disabled", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_1__angular_forms__["c" /* FormGroup */])
    ], AddonUserProfileFieldDatetimeComponent.prototype, "form", void 0);
    AddonUserProfileFieldDatetimeComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'addon-user-profile-field-datetime',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/addon/userprofilefield/datetime/component/datetime.html"*/'<!-- Render (no edit). -->\n<ion-item *ngIf="!edit && field && field.name">\n    <h2>{{ field.name }}</h2>\n    <p>{{ field.value * 1000 | coreFormatDate:"dfmediumdate"}}</p>\n</ion-item>\n<!-- Edit. -->\n<ion-item *ngIf="edit && field && field.shortname" text-wrap [formGroup]="form">\n    <ion-label stacked [core-mark-required]="field.required">{{ field.name }}</ion-label>\n    <ion-datetime [formControlName]="field.modelName" [placeholder]="\'core.choosedots\' |translate" [displayFormat]="field.format" core-input-errors [max]="field.max" [min]="field.min"></ion-datetime>\n</ion-item>'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/addon/userprofilefield/datetime/component/datetime.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_forms__["a" /* FormBuilder */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_time__["a" /* CoreTimeUtilsProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], AddonUserProfileFieldDatetimeComponent);
    return AddonUserProfileFieldDatetimeComponent;
}());

//# sourceMappingURL=datetime.js.map

/***/ }),
/* 699 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonUserProfileFieldMenuComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_forms__ = __webpack_require__(32);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Directive to render a menu user profile field.
 */
var AddonUserProfileFieldMenuComponent = /** @class */ (function () {
    function AddonUserProfileFieldMenuComponent(fb) {
        this.fb = fb;
        this.edit = false; // True if editing the field. Defaults to false.
        this.disabled = false; // True if disabled. Defaults to false.
    }
    /**
     * Component being initialized.
     */
    AddonUserProfileFieldMenuComponent.prototype.ngOnInit = function () {
        var field = this.field;
        if (field && this.edit && this.form) {
            field.modelName = 'profile_field_' + field.shortname;
            // Parse options.
            if (field.param1) {
                field.options = field.param1.split(/\r\n|\r|\n/g);
            }
            else {
                field.options = [];
            }
            var formData = {
                value: field.defaultdata,
                disabled: this.disabled
            };
            // Initialize the value using default data.
            this.form.addControl(field.modelName, this.fb.control(formData, field.required && !field.locked ? __WEBPACK_IMPORTED_MODULE_1__angular_forms__["h" /* Validators */].required : null));
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], AddonUserProfileFieldMenuComponent.prototype, "field", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], AddonUserProfileFieldMenuComponent.prototype, "edit", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], AddonUserProfileFieldMenuComponent.prototype, "disabled", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_1__angular_forms__["c" /* FormGroup */])
    ], AddonUserProfileFieldMenuComponent.prototype, "form", void 0);
    AddonUserProfileFieldMenuComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'addon-user-profile-field-menu',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/addon/userprofilefield/menu/component/menu.html"*/'<!-- Render (no edit). -->\n<ion-item *ngIf="!edit && field && field.name">\n    <h2>{{ field.name }}</h2>\n    <p><core-format-text [text]="field.value"></core-format-text></p>\n</ion-item>\n<!-- Edit. -->\n<ion-item *ngIf="edit && field && field.shortname" text-wrap [formGroup]="form">\n    <ion-label stacked [core-mark-required]="field.required">{{ field.name }}</ion-label>\n    <ion-select [formControlName]="field.modelName" [placeholder]="\'core.choosedots\' |translate" core-input-errors>\n        <ion-option value="">{{ \'core.choosedots\' |translate }}</ion-option>\n        <ion-option *ngFor="let option of field.options" [value]="option">{{option}}</ion-option>\n    </ion-select>\n</ion-item>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/addon/userprofilefield/menu/component/menu.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_forms__["a" /* FormBuilder */]])
    ], AddonUserProfileFieldMenuComponent);
    return AddonUserProfileFieldMenuComponent;
}());

//# sourceMappingURL=menu.js.map

/***/ }),
/* 700 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonUserProfileFieldTextComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_forms__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__ = __webpack_require__(9);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Directive to render a text user profile field.
 */
var AddonUserProfileFieldTextComponent = /** @class */ (function () {
    function AddonUserProfileFieldTextComponent(fb, utils) {
        this.fb = fb;
        this.utils = utils;
        this.edit = false; // True if editing the field. Defaults to false.
        this.disabled = false; // True if disabled. Defaults to false.
    }
    /**
     * Component being initialized.
     */
    AddonUserProfileFieldTextComponent.prototype.ngOnInit = function () {
        var field = this.field;
        if (field && this.edit && this.form) {
            field.modelName = 'profile_field_' + field.shortname;
            // Check max length.
            if (field.param2) {
                field.maxlength = parseInt(field.param2, 10) || '';
            }
            // Check if it's a password or text.
            field.inputType = this.utils.isTrueOrOne(field.param3) ? 'password' : 'text';
            var formData = {
                value: field.defaultdata,
                disabled: this.disabled
            };
            // Initialize the value using default data.
            this.form.addControl(field.modelName, this.fb.control(formData, field.required && !field.locked ? __WEBPACK_IMPORTED_MODULE_1__angular_forms__["h" /* Validators */].required : null));
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], AddonUserProfileFieldTextComponent.prototype, "field", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], AddonUserProfileFieldTextComponent.prototype, "edit", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], AddonUserProfileFieldTextComponent.prototype, "disabled", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_1__angular_forms__["c" /* FormGroup */])
    ], AddonUserProfileFieldTextComponent.prototype, "form", void 0);
    AddonUserProfileFieldTextComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'addon-user-profile-field-text',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/addon/userprofilefield/text/component/text.html"*/'<!-- Render (no edit). -->\n<ion-item *ngIf="!edit && field && field.name">\n    <h2>{{ field.name }}</h2>\n    <p><core-format-text [text]="field.value"></core-format-text></p>\n</ion-item>\n<!-- Edit. -->\n<ion-item *ngIf="edit && field && field.shortname" text-wrap [formGroup]="form">\n    <ion-label stacked [core-mark-required]="field.required">{{ field.name }}</ion-label>\n    <ion-input [type]="field.inputType" [formControlName]="field.modelName" [placeholder]="field.name" maxlength="{{field.maxlength}}" core-input-errors></ion-input>\n</ion-item>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/addon/userprofilefield/text/component/text.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_forms__["a" /* FormBuilder */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], AddonUserProfileFieldTextComponent);
    return AddonUserProfileFieldTextComponent;
}());

//# sourceMappingURL=text.js.map

/***/ }),
/* 701 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonUserProfileFieldTextareaComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_forms__ = __webpack_require__(32);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Directive to render a textarea user profile field.
 */
var AddonUserProfileFieldTextareaComponent = /** @class */ (function () {
    function AddonUserProfileFieldTextareaComponent() {
        this.edit = false; // True if editing the field. Defaults to false.
        this.disabled = false; // True if disabled. Defaults to false.
        // Nothing to do.
    }
    /**
     * Component being initialized.
     */
    AddonUserProfileFieldTextareaComponent.prototype.ngOnInit = function () {
        var field = this.field;
        if (field && this.edit && this.form) {
            field.modelName = 'profile_field_' + field.shortname;
            var formData = {
                value: field.defaultdata,
                disabled: this.disabled
            };
            this.control = new __WEBPACK_IMPORTED_MODULE_1__angular_forms__["b" /* FormControl */](formData, field.required && !field.locked ? __WEBPACK_IMPORTED_MODULE_1__angular_forms__["h" /* Validators */].required : null);
            this.form.addControl(field.modelName, this.control);
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], AddonUserProfileFieldTextareaComponent.prototype, "field", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], AddonUserProfileFieldTextareaComponent.prototype, "edit", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], AddonUserProfileFieldTextareaComponent.prototype, "disabled", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_1__angular_forms__["c" /* FormGroup */])
    ], AddonUserProfileFieldTextareaComponent.prototype, "form", void 0);
    AddonUserProfileFieldTextareaComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'addon-user-profile-field-textarea',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/addon/userprofilefield/textarea/component/textarea.html"*/'<!-- Render (no edit). -->\n<ion-item *ngIf="!edit && field && field.name">\n    <h2>{{ field.name }}</h2>\n    <p><core-format-text [text]="field.value"></core-format-text></p>\n</ion-item>\n<!-- Edit. -->\n<ion-item *ngIf="edit && field && field.shortname" text-wrap [formGroup]="form">\n    <ion-label stacked [core-mark-required]="field.required">{{ field.name }}</ion-label>\n    <core-rich-text-editor item-content [control]="control" [placeholder]="field.name"></core-rich-text-editor>\n</ion-item>'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/addon/userprofilefield/textarea/component/textarea.html"*/
        }),
        __metadata("design:paramtypes", [])
    ], AddonUserProfileFieldTextareaComponent);
    return AddonUserProfileFieldTextareaComponent;
}());

//# sourceMappingURL=textarea.js.map

/***/ }),
/* 702 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonMessagesAddContactUserHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_user_providers_user_delegate__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__messages__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__user_block_contact_handler__ = __webpack_require__(703);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_events__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ngx_translate_core__ = __webpack_require__(7);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








/**
 * Profile add/remove contact handler.
 */
var AddonMessagesAddContactUserHandler = /** @class */ (function () {
    function AddonMessagesAddContactUserHandler(sitesProvider, messagesProvider, eventsProvider, domUtils, translate) {
        var _this = this;
        this.sitesProvider = sitesProvider;
        this.messagesProvider = messagesProvider;
        this.eventsProvider = eventsProvider;
        this.domUtils = domUtils;
        this.translate = translate;
        this.name = 'AddonMessages:addContact';
        this.priority = 800;
        this.type = __WEBPACK_IMPORTED_MODULE_1__core_user_providers_user_delegate__["a" /* CoreUserDelegate */].TYPE_ACTION;
        this.disabled = false;
        this.updateObs = eventsProvider.on(__WEBPACK_IMPORTED_MODULE_4__user_block_contact_handler__["a" /* AddonMessagesBlockContactUserHandler */].UPDATED_EVENT, function (data) {
            _this.checkButton(data.userId);
        });
    }
    AddonMessagesAddContactUserHandler_1 = AddonMessagesAddContactUserHandler;
    /**
     * Check if handler is enabled.
     *
     * @return {Promise<boolean>} Promise resolved with true if enabled, rejected or resolved with false otherwise.
     */
    AddonMessagesAddContactUserHandler.prototype.isEnabled = function () {
        return this.messagesProvider.isPluginEnabled();
    };
    /**
     * Check if handler is enabled for this user in this context.
     *
     * @param {any} user          User to check.
     * @param {number} courseId   Course ID.
     * @param  {any} [navOptions] Course navigation options for current user. See $mmCourses#getUserNavigationOptions.
     * @param  {any} [admOptions] Course admin options for current user. See $mmCourses#getUserAdministrationOptions.
     * @return  {boolean|Promise<boolean>}   Promise resolved with true if enabled, resolved with false otherwise.
     */
    AddonMessagesAddContactUserHandler.prototype.isEnabledForUser = function (user, courseId, navOptions, admOptions) {
        return user.id != this.sitesProvider.getCurrentSiteUserId();
    };
    /**
     * Returns the data needed to render the handler.
     *
     * @return {CoreUserProfileHandlerData} Data needed to render the handler.
     */
    AddonMessagesAddContactUserHandler.prototype.getDisplayData = function (user, courseId) {
        var _this = this;
        this.checkButton(user.id);
        return {
            icon: '',
            title: '',
            spinner: false,
            class: '',
            action: function (event, navCtrl, user, courseId) {
                event.preventDefault();
                event.stopPropagation();
                if (_this.disabled) {
                    return;
                }
                _this.disabled = true;
                _this.updateButton({ spinner: true });
                _this.messagesProvider.isContact(user.id).then(function (isContact) {
                    if (isContact) {
                        var template = _this.translate.instant('addon.messages.removecontactconfirm'), title = _this.translate.instant('addon.messages.removecontact');
                        return _this.domUtils.showConfirm(template, title, title).then(function () {
                            return _this.messagesProvider.removeContact(user.id);
                        }, function () {
                            // Ignore on cancel.
                        });
                    }
                    else {
                        return _this.messagesProvider.addContact(user.id);
                    }
                }).catch(function (error) {
                    _this.domUtils.showErrorModalDefault(error, 'core.error', true);
                }).finally(function () {
                    _this.eventsProvider.trigger(AddonMessagesAddContactUserHandler_1.UPDATED_EVENT, { userId: user.id });
                    _this.checkButton(user.id).finally(function () {
                        _this.disabled = false;
                    });
                });
            }
        };
    };
    /**
     * Update Button with avalaible data.
     * @param {number} userId User Id to update.
     * @return {Promise<void>}   Promise resolved when done.
     */
    AddonMessagesAddContactUserHandler.prototype.checkButton = function (userId) {
        var _this = this;
        this.updateButton({ spinner: true });
        return this.messagesProvider.isContact(userId).then(function (isContact) {
            if (isContact) {
                _this.updateButton({
                    title: 'addon.messages.removecontact',
                    class: 'addon-messages-removecontact-handler',
                    icon: 'remove',
                    hidden: false,
                    spinner: false
                });
            }
            else {
                _this.updateButton({
                    title: 'addon.messages.addcontact',
                    class: 'addon-messages-addcontact-handler',
                    icon: 'add',
                    hidden: false,
                    spinner: false
                });
            }
        }).catch(function () {
            // This fails for some reason, let's just hide the button.
            _this.updateButton({ hidden: true });
        });
    };
    /**
     * Triggers the event to update the handler information.
     * @param {any} data Data that should be updated.
     */
    AddonMessagesAddContactUserHandler.prototype.updateButton = function (data) {
        // This fails for some reason, let's just hide the button.
        this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_1__core_user_providers_user_delegate__["a" /* CoreUserDelegate */].UPDATE_HANDLER_EVENT, { handler: this.name, data: data });
    };
    /**
     * Destroyed method.
     */
    AddonMessagesAddContactUserHandler.prototype.ngOnDestroy = function () {
        this.updateObs && this.updateObs.off();
    };
    /**
     * Update handler information event.
     * @type {string}
     */
    AddonMessagesAddContactUserHandler.UPDATED_EVENT = 'AddonMessagesAddContactUserHandler_updated_event';
    AddonMessagesAddContactUserHandler = AddonMessagesAddContactUserHandler_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_3__messages__["a" /* AddonMessagesProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_events__["a" /* CoreEventsProvider */],
            __WEBPACK_IMPORTED_MODULE_6__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_7__ngx_translate_core__["c" /* TranslateService */]])
    ], AddonMessagesAddContactUserHandler);
    return AddonMessagesAddContactUserHandler;
    var AddonMessagesAddContactUserHandler_1;
}());

//# sourceMappingURL=user-add-contact-handler.js.map

/***/ }),
/* 703 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonMessagesBlockContactUserHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_user_providers_user_delegate__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__messages__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__user_add_contact_handler__ = __webpack_require__(702);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_events__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ngx_translate_core__ = __webpack_require__(7);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








/**
 * Profile block/unblock contact handler.
 */
var AddonMessagesBlockContactUserHandler = /** @class */ (function () {
    function AddonMessagesBlockContactUserHandler(sitesProvider, messagesProvider, eventsProvider, domUtils, translate) {
        var _this = this;
        this.sitesProvider = sitesProvider;
        this.messagesProvider = messagesProvider;
        this.eventsProvider = eventsProvider;
        this.domUtils = domUtils;
        this.translate = translate;
        this.name = 'AddonMessages:blockContact';
        this.priority = 600;
        this.type = __WEBPACK_IMPORTED_MODULE_1__core_user_providers_user_delegate__["a" /* CoreUserDelegate */].TYPE_ACTION;
        this.disabled = false;
        this.updateObs = eventsProvider.on(__WEBPACK_IMPORTED_MODULE_4__user_add_contact_handler__["a" /* AddonMessagesAddContactUserHandler */].UPDATED_EVENT, function (data) {
            _this.checkButton(data.userId);
        });
    }
    AddonMessagesBlockContactUserHandler_1 = AddonMessagesBlockContactUserHandler;
    /**
     * Check if handler is enabled.
     *
     * @return {Promise<boolean>} Promise resolved with true if enabled, rejected or resolved with false otherwise.
     */
    AddonMessagesBlockContactUserHandler.prototype.isEnabled = function () {
        return this.messagesProvider.isPluginEnabled();
    };
    /**
     * Check if handler is enabled for this user in this context.
     *
     * @param {any} user          User to check.
     * @param {number} courseId   Course ID.
     * @param  {any} [navOptions] Course navigation options for current user. See $mmCourses#getUserNavigationOptions.
     * @param  {any} [admOptions] Course admin options for current user. See $mmCourses#getUserAdministrationOptions.
     * @return  {boolean|Promise<boolean>}   Promise resolved with true if enabled, resolved with false otherwise.
     */
    AddonMessagesBlockContactUserHandler.prototype.isEnabledForUser = function (user, courseId, navOptions, admOptions) {
        return user.id != this.sitesProvider.getCurrentSiteUserId();
    };
    /**
     * Returns the data needed to render the handler.
     *
     * @return {CoreUserProfileHandlerData} Data needed to render the handler.
     */
    AddonMessagesBlockContactUserHandler.prototype.getDisplayData = function (user, courseId) {
        var _this = this;
        this.checkButton(user.id);
        return {
            icon: '',
            title: '',
            spinner: false,
            class: '',
            action: function (event, navCtrl, user, courseId) {
                event.preventDefault();
                event.stopPropagation();
                if (_this.disabled) {
                    return;
                }
                _this.disabled = true;
                _this.updateButton({ spinner: true });
                _this.messagesProvider.isBlocked(user.id).then(function (isBlocked) {
                    if (isBlocked) {
                        return _this.messagesProvider.unblockContact(user.id);
                    }
                    else {
                        var template = _this.translate.instant('addon.messages.blockcontactconfirm'), title = _this.translate.instant('addon.messages.blockcontact');
                        return _this.domUtils.showConfirm(template, title, title).then(function () {
                            return _this.messagesProvider.blockContact(user.id);
                        }, function () {
                            // Ignore on cancel.
                        });
                    }
                }).catch(function (error) {
                    _this.domUtils.showErrorModalDefault(error, 'core.error', true);
                }).finally(function () {
                    _this.eventsProvider.trigger(AddonMessagesBlockContactUserHandler_1.UPDATED_EVENT, { userId: user.id });
                    _this.checkButton(user.id).finally(function () {
                        _this.disabled = false;
                    });
                });
            }
        };
    };
    /**
     * Update Button with avalaible data.
     * @param {number} userId User Id to update.
     * @return {Promise<void>}   Promise resolved when done.
     */
    AddonMessagesBlockContactUserHandler.prototype.checkButton = function (userId) {
        var _this = this;
        this.updateButton({ spinner: true });
        return this.messagesProvider.isBlocked(userId).then(function (isBlocked) {
            if (isBlocked) {
                _this.updateButton({
                    title: 'addon.messages.unblockcontact',
                    class: 'addon-messages-unblockcontact-handler',
                    icon: 'checkmark-circle',
                    hidden: false,
                    spinner: false
                });
            }
            else {
                _this.updateButton({
                    title: 'addon.messages.blockcontact',
                    class: 'addon-messages-blockcontact-handler',
                    icon: 'close-circle',
                    hidden: false,
                    spinner: false
                });
            }
        }).catch(function () {
            // This fails for some reason, let's just hide the button.
            _this.updateButton({ hidden: true });
        });
    };
    /**
     * Triggers the event to update the handler information.
     * @param {any} data Data that should be updated.
     */
    AddonMessagesBlockContactUserHandler.prototype.updateButton = function (data) {
        // This fails for some reason, let's just hide the button.
        this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_1__core_user_providers_user_delegate__["a" /* CoreUserDelegate */].UPDATE_HANDLER_EVENT, { handler: this.name, data: data });
    };
    /**
     * Destroyed method.
     */
    AddonMessagesBlockContactUserHandler.prototype.ngOnDestroy = function () {
        this.updateObs && this.updateObs.off();
    };
    /**
     * Update handler information event.
     * @type {string}
     */
    AddonMessagesBlockContactUserHandler.UPDATED_EVENT = 'AddonMessagesBlockContactUserHandler_updated_event';
    AddonMessagesBlockContactUserHandler = AddonMessagesBlockContactUserHandler_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_3__messages__["a" /* AddonMessagesProvider */],
            __WEBPACK_IMPORTED_MODULE_5__providers_events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_7__ngx_translate_core__["c" /* TranslateService */]])
    ], AddonMessagesBlockContactUserHandler);
    return AddonMessagesBlockContactUserHandler;
    var AddonMessagesBlockContactUserHandler_1;
}());

//# sourceMappingURL=user-block-contact-handler.js.map

/***/ }),
/* 704 */,
/* 705 */,
/* 706 */,
/* 707 */,
/* 708 */,
/* 709 */,
/* 710 */,
/* 711 */,
/* 712 */,
/* 713 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCoursesComponentsModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__components_components_module__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__directives_directives_module__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__pipes_pipes_module__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__components_course_progress_course_progress__ = __webpack_require__(1072);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__components_course_list_item_course_list_item__ = __webpack_require__(1073);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__components_overview_events_overview_events__ = __webpack_require__(1074);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};










var CoreCoursesComponentsModule = /** @class */ (function () {
    function CoreCoursesComponentsModule() {
    }
    CoreCoursesComponentsModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_7__components_course_progress_course_progress__["a" /* CoreCoursesCourseProgressComponent */],
                __WEBPACK_IMPORTED_MODULE_8__components_course_list_item_course_list_item__["a" /* CoreCoursesCourseListItemComponent */],
                __WEBPACK_IMPORTED_MODULE_9__components_overview_events_overview_events__["a" /* CoreCoursesOverviewEventsComponent */]
            ],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1__angular_common__["b" /* CommonModule */],
                __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["g" /* IonicModule */],
                __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["b" /* TranslateModule */].forChild(),
                __WEBPACK_IMPORTED_MODULE_4__components_components_module__["a" /* CoreComponentsModule */],
                __WEBPACK_IMPORTED_MODULE_5__directives_directives_module__["a" /* CoreDirectivesModule */],
                __WEBPACK_IMPORTED_MODULE_6__pipes_pipes_module__["a" /* CorePipesModule */]
            ],
            providers: [],
            exports: [
                __WEBPACK_IMPORTED_MODULE_7__components_course_progress_course_progress__["a" /* CoreCoursesCourseProgressComponent */],
                __WEBPACK_IMPORTED_MODULE_8__components_course_list_item_course_list_item__["a" /* CoreCoursesCourseListItemComponent */],
                __WEBPACK_IMPORTED_MODULE_9__components_overview_events_overview_events__["a" /* CoreCoursesOverviewEventsComponent */]
            ]
        })
    ], CoreCoursesComponentsModule);
    return CoreCoursesComponentsModule;
}());

//# sourceMappingURL=components.module.js.map

/***/ }),
/* 714 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonCalendarHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_course_providers_course__ = __webpack_require__(14);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Service that provides some features regarding lists of courses and categories.
 */
var AddonCalendarHelperProvider = /** @class */ (function () {
    function AddonCalendarHelperProvider(logger, courseProvider) {
        this.courseProvider = courseProvider;
        this.EVENTICONS = {
            course: 'ionic',
            group: 'people',
            site: 'globe',
            user: 'person',
            category: 'albums'
        };
        this.logger = logger.getInstance('AddonCalendarHelperProvider');
    }
    /**
     * Convenience function to format some event data to be rendered.
     *
     * @param {any} e Event to format.
     */
    AddonCalendarHelperProvider.prototype.formatEventData = function (e) {
        e.icon = this.EVENTICONS[e.eventtype] || false;
        if (!e.icon) {
            e.icon = this.courseProvider.getModuleIconSrc(e.modulename);
            e.moduleIcon = e.icon;
        }
    };
    AddonCalendarHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__core_course_providers_course__["a" /* CoreCourseProvider */]])
    ], AddonCalendarHelperProvider);
    return AddonCalendarHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),
/* 715 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSiteHomeComponentsModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__components_components_module__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__directives_directives_module__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_course_components_components_module__ = __webpack_require__(91);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__index_index__ = __webpack_require__(1075);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__all_course_list_all_course_list__ = __webpack_require__(1076);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__categories_categories__ = __webpack_require__(1077);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__course_search_course_search__ = __webpack_require__(1078);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__enrolled_course_list_enrolled_course_list__ = __webpack_require__(1079);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__news_news__ = __webpack_require__(1080);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};













var CoreSiteHomeComponentsModule = /** @class */ (function () {
    function CoreSiteHomeComponentsModule() {
    }
    CoreSiteHomeComponentsModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_7__index_index__["a" /* CoreSiteHomeIndexComponent */],
                __WEBPACK_IMPORTED_MODULE_8__all_course_list_all_course_list__["a" /* CoreSiteHomeAllCourseListComponent */],
                __WEBPACK_IMPORTED_MODULE_9__categories_categories__["a" /* CoreSiteHomeCategoriesComponent */],
                __WEBPACK_IMPORTED_MODULE_10__course_search_course_search__["a" /* CoreSiteHomeCourseSearchComponent */],
                __WEBPACK_IMPORTED_MODULE_11__enrolled_course_list_enrolled_course_list__["a" /* CoreSiteHomeEnrolledCourseListComponent */],
                __WEBPACK_IMPORTED_MODULE_12__news_news__["a" /* CoreSiteHomeNewsComponent */]
            ],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1__angular_common__["b" /* CommonModule */],
                __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["g" /* IonicModule */],
                __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["b" /* TranslateModule */].forChild(),
                __WEBPACK_IMPORTED_MODULE_4__components_components_module__["a" /* CoreComponentsModule */],
                __WEBPACK_IMPORTED_MODULE_5__directives_directives_module__["a" /* CoreDirectivesModule */],
                __WEBPACK_IMPORTED_MODULE_6__core_course_components_components_module__["a" /* CoreCourseComponentsModule */]
            ],
            exports: [
                __WEBPACK_IMPORTED_MODULE_7__index_index__["a" /* CoreSiteHomeIndexComponent */],
                __WEBPACK_IMPORTED_MODULE_8__all_course_list_all_course_list__["a" /* CoreSiteHomeAllCourseListComponent */],
                __WEBPACK_IMPORTED_MODULE_9__categories_categories__["a" /* CoreSiteHomeCategoriesComponent */],
                __WEBPACK_IMPORTED_MODULE_10__course_search_course_search__["a" /* CoreSiteHomeCourseSearchComponent */],
                __WEBPACK_IMPORTED_MODULE_11__enrolled_course_list_enrolled_course_list__["a" /* CoreSiteHomeEnrolledCourseListComponent */],
                __WEBPACK_IMPORTED_MODULE_12__news_news__["a" /* CoreSiteHomeNewsComponent */]
            ]
        })
    ], CoreSiteHomeComponentsModule);
    return CoreSiteHomeComponentsModule;
}());

//# sourceMappingURL=components.module.js.map

/***/ }),
/* 716 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreGradesComponentsModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__course_course__ = __webpack_require__(601);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__components_components_module__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__directives_directives_module__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__pipes_pipes_module__ = __webpack_require__(90);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};








var CoreGradesComponentsModule = /** @class */ (function () {
    function CoreGradesComponentsModule() {
    }
    CoreGradesComponentsModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_4__course_course__["a" /* CoreGradesCourseComponent */]
            ],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1__angular_common__["b" /* CommonModule */],
                __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["g" /* IonicModule */],
                __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["b" /* TranslateModule */].forChild(),
                __WEBPACK_IMPORTED_MODULE_5__components_components_module__["a" /* CoreComponentsModule */],
                __WEBPACK_IMPORTED_MODULE_6__directives_directives_module__["a" /* CoreDirectivesModule */],
                __WEBPACK_IMPORTED_MODULE_7__pipes_pipes_module__["a" /* CorePipesModule */]
            ],
            providers: [],
            exports: [
                __WEBPACK_IMPORTED_MODULE_4__course_course__["a" /* CoreGradesCourseComponent */]
            ],
            entryComponents: [
                __WEBPACK_IMPORTED_MODULE_4__course_course__["a" /* CoreGradesCourseComponent */]
            ]
        })
    ], CoreGradesComponentsModule);
    return CoreGradesComponentsModule;
}());

//# sourceMappingURL=components.module.js.map

/***/ }),
/* 717 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreMainMenuProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_lang__ = __webpack_require__(96);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__configconstants__ = __webpack_require__(50);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Service that provides some features regarding Main Menu.
 */
var CoreMainMenuProvider = /** @class */ (function () {
    function CoreMainMenuProvider(langProvider, sitesProvider) {
        this.langProvider = langProvider;
        this.sitesProvider = sitesProvider;
    }
    /**
     * Get a list of custom menu items for a certain site.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<CoreMainMenuCustomItem[]>} List of custom menu items.
     */
    CoreMainMenuProvider.prototype.getCustomMenuItems = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var itemsString = site.getStoredConfig('tool_mobile_custommenuitems'), map = {}, result = [];
            var items, position = 0; // Position of each item, to keep the same order as it's configured.
            if (!itemsString || typeof itemsString != 'string') {
                // Setting not valid.
                return result;
            }
            // Add items to the map.
            items = itemsString.split(/(?:\r\n|\r|\n)/);
            items.forEach(function (item) {
                var values = item.split('|'), label = values[0] ? values[0].trim() : values[0], url = values[1] ? values[1].trim() : values[1], type = values[2] ? values[2].trim() : values[2], lang = (values[3] ? values[3].trim() : values[3]) || 'none';
                var id, icon = values[4] ? values[4].trim() : values[4];
                if (!label || !url || !type) {
                    // Invalid item, ignore it.
                    return;
                }
                id = url + '#' + type;
                if (!icon) {
                    // Icon not defined, use default one.
                    icon = type == 'embedded' ? 'qr-scanner' : 'link';
                }
                if (!map[id]) {
                    // New entry, add it to the map.
                    map[id] = {
                        url: url,
                        type: type,
                        position: position,
                        labels: {}
                    };
                    position++;
                }
                map[id].labels[lang.toLowerCase()] = {
                    label: label,
                    icon: icon
                };
            });
            if (!position) {
                // No valid items found, stop.
                return result;
            }
            return _this.langProvider.getCurrentLanguage().then(function (currentLang) {
                var fallbackLang = __WEBPACK_IMPORTED_MODULE_3__configconstants__["a" /* CoreConfigConstants */].default_lang || 'en';
                // Get the right label for each entry and add it to the result.
                for (var id in map) {
                    var entry = map[id];
                    var data = entry.labels[currentLang] || entry.labels[currentLang + '_only'] ||
                        entry.labels.none || entry.labels[fallbackLang];
                    if (!data) {
                        // No valid label found, get the first one that is not "_only".
                        for (var lang in entry.labels) {
                            if (lang.indexOf('_only') == -1) {
                                data = entry.labels[lang];
                                break;
                            }
                        }
                        if (!data) {
                            // No valid label, ignore this entry.
                            return;
                        }
                    }
                    result[entry.position] = {
                        url: entry.url,
                        type: entry.type,
                        label: data.label,
                        icon: data.icon
                    };
                }
                return result;
            });
        });
    };
    CoreMainMenuProvider.NUM_MAIN_HANDLERS = 4;
    CoreMainMenuProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_lang__["a" /* CoreLangProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */]])
    ], CoreMainMenuProvider);
    return CoreMainMenuProvider;
}());

//# sourceMappingURL=mainmenu.js.map

/***/ }),
/* 718 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSitePluginsComponentsModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__components_components_module__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__core_compile_components_compile_html_compile_html_module__ = __webpack_require__(1082);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__plugin_content_plugin_content__ = __webpack_require__(81);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__module_index_module_index__ = __webpack_require__(181);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__course_option_course_option__ = __webpack_require__(259);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__course_format_course_format__ = __webpack_require__(260);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__user_profile_field_user_profile_field__ = __webpack_require__(656);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};











var CoreSitePluginsComponentsModule = /** @class */ (function () {
    function CoreSitePluginsComponentsModule() {
    }
    CoreSitePluginsComponentsModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_6__plugin_content_plugin_content__["a" /* CoreSitePluginsPluginContentComponent */],
                __WEBPACK_IMPORTED_MODULE_7__module_index_module_index__["a" /* CoreSitePluginsModuleIndexComponent */],
                __WEBPACK_IMPORTED_MODULE_8__course_option_course_option__["a" /* CoreSitePluginsCourseOptionComponent */],
                __WEBPACK_IMPORTED_MODULE_9__course_format_course_format__["a" /* CoreSitePluginsCourseFormatComponent */],
                __WEBPACK_IMPORTED_MODULE_10__user_profile_field_user_profile_field__["a" /* CoreSitePluginsUserProfileFieldComponent */]
            ],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1__angular_common__["b" /* CommonModule */],
                __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["g" /* IonicModule */],
                __WEBPACK_IMPORTED_MODULE_4__components_components_module__["a" /* CoreComponentsModule */],
                __WEBPACK_IMPORTED_MODULE_5__core_compile_components_compile_html_compile_html_module__["a" /* CoreCompileHtmlComponentModule */],
                __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["b" /* TranslateModule */].forChild()
            ],
            providers: [],
            exports: [
                __WEBPACK_IMPORTED_MODULE_6__plugin_content_plugin_content__["a" /* CoreSitePluginsPluginContentComponent */],
                __WEBPACK_IMPORTED_MODULE_7__module_index_module_index__["a" /* CoreSitePluginsModuleIndexComponent */],
                __WEBPACK_IMPORTED_MODULE_8__course_option_course_option__["a" /* CoreSitePluginsCourseOptionComponent */],
                __WEBPACK_IMPORTED_MODULE_9__course_format_course_format__["a" /* CoreSitePluginsCourseFormatComponent */],
                __WEBPACK_IMPORTED_MODULE_10__user_profile_field_user_profile_field__["a" /* CoreSitePluginsUserProfileFieldComponent */]
            ],
            entryComponents: [
                __WEBPACK_IMPORTED_MODULE_7__module_index_module_index__["a" /* CoreSitePluginsModuleIndexComponent */],
                __WEBPACK_IMPORTED_MODULE_8__course_option_course_option__["a" /* CoreSitePluginsCourseOptionComponent */],
                __WEBPACK_IMPORTED_MODULE_9__course_format_course_format__["a" /* CoreSitePluginsCourseFormatComponent */],
                __WEBPACK_IMPORTED_MODULE_10__user_profile_field_user_profile_field__["a" /* CoreSitePluginsUserProfileFieldComponent */]
            ]
        })
    ], CoreSitePluginsComponentsModule);
    return CoreSitePluginsComponentsModule;
}());

//# sourceMappingURL=components.module.js.map

/***/ }),
/* 719 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreUserHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(7);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Service that provides some features regarding users information.
 */
var CoreUserHelperProvider = /** @class */ (function () {
    function CoreUserHelperProvider(logger, translate) {
        this.translate = translate;
        this.logger = logger.getInstance('CoreUserHelperProvider');
    }
    /**
     * Formats a user address, concatenating address, city and country.
     *
     * @param {string} address Address.
     * @param {string} city    City.
     * @param {string} country Country.
     * @return {string} Formatted address.
     */
    CoreUserHelperProvider.prototype.formatAddress = function (address, city, country) {
        var separator = this.translate.instant('core.listsep');
        var values = [address, city, country];
        values = values.filter(function (value) {
            return value && value.length > 0;
        });
        return values.join(separator + ' ');
    };
    /**
     * Formats a user role list, translating and concatenating them.
     *
     * @param {any[]} [roles] List of user roles.
     * @return {string} The formatted roles.
     */
    CoreUserHelperProvider.prototype.formatRoleList = function (roles) {
        var _this = this;
        if (!roles || roles.length <= 0) {
            return '';
        }
        var separator = this.translate.instant('core.listsep');
        return roles.map(function (value) {
            var translation = _this.translate.instant('core.user.' + value.shortname);
            return translation.indexOf('core.user.') < 0 ? translation : value.shortname;
        }).join(separator + ' ');
    };
    CoreUserHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */]])
    ], CoreUserHelperProvider);
    return CoreUserHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),
/* 720 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return coreShowHideAnimation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return coreSlideInOut; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_animations__ = __webpack_require__(187);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

var coreShowHideAnimation = Object(__WEBPACK_IMPORTED_MODULE_0__angular_animations__["j" /* trigger */])('coreShowHideAnimation', [
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_animations__["i" /* transition */])(':enter', [
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_animations__["h" /* style */])({ opacity: 0 }),
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_animations__["e" /* animate */])('500ms ease-in-out', Object(__WEBPACK_IMPORTED_MODULE_0__angular_animations__["h" /* style */])({ opacity: 1 }))
    ]),
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_animations__["i" /* transition */])(':leave', [
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_animations__["h" /* style */])({ opacity: 1 }),
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_animations__["e" /* animate */])('500ms ease-in-out', Object(__WEBPACK_IMPORTED_MODULE_0__angular_animations__["h" /* style */])({ opacity: 0 }))
    ])
]);
var coreSlideInOut = Object(__WEBPACK_IMPORTED_MODULE_0__angular_animations__["j" /* trigger */])('coreSlideInOut', [
    // Enter animation.
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_animations__["i" /* transition */])('void => fromLeft', [
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_animations__["h" /* style */])({ transform: 'translateX(0)', opacity: 1 }),
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_animations__["e" /* animate */])(300, Object(__WEBPACK_IMPORTED_MODULE_0__angular_animations__["f" /* keyframes */])([
            Object(__WEBPACK_IMPORTED_MODULE_0__angular_animations__["h" /* style */])({ opacity: 0, transform: 'translateX(-100%)', offset: 0 }),
            Object(__WEBPACK_IMPORTED_MODULE_0__angular_animations__["h" /* style */])({ opacity: 1, transform: 'translateX(5%)', offset: 0.7 }),
            Object(__WEBPACK_IMPORTED_MODULE_0__angular_animations__["h" /* style */])({ opacity: 1, transform: 'translateX(0)', offset: 1.0 })
        ]))
    ]),
    // Leave animation.
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_animations__["i" /* transition */])('fromLeft => void', [
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_animations__["h" /* style */])({ transform: 'translateX(-100%)', opacity: 0 }),
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_animations__["e" /* animate */])(300, Object(__WEBPACK_IMPORTED_MODULE_0__angular_animations__["f" /* keyframes */])([
            Object(__WEBPACK_IMPORTED_MODULE_0__angular_animations__["h" /* style */])({ opacity: 1, transform: 'translateX(0)', offset: 0 }),
            Object(__WEBPACK_IMPORTED_MODULE_0__angular_animations__["h" /* style */])({ opacity: 1, transform: 'translateX(5%)', offset: 0.3 }),
            Object(__WEBPACK_IMPORTED_MODULE_0__angular_animations__["h" /* style */])({ opacity: 0, transform: 'translateX(-100%)', offset: 1.0 })
        ]))
    ]),
    // Enter animation.
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_animations__["i" /* transition */])('void => fromRight', [
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_animations__["h" /* style */])({ transform: 'translateX(0)', opacity: 1 }),
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_animations__["e" /* animate */])(300, Object(__WEBPACK_IMPORTED_MODULE_0__angular_animations__["f" /* keyframes */])([
            Object(__WEBPACK_IMPORTED_MODULE_0__angular_animations__["h" /* style */])({ opacity: 0, transform: 'translateX(100%)', offset: 0 }),
            Object(__WEBPACK_IMPORTED_MODULE_0__angular_animations__["h" /* style */])({ opacity: 1, transform: 'translateX(-5%)', offset: 0.7 }),
            Object(__WEBPACK_IMPORTED_MODULE_0__angular_animations__["h" /* style */])({ opacity: 1, transform: 'translateX(0)', offset: 1.0 })
        ]))
    ]),
    // Leave animation.
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_animations__["i" /* transition */])('fromRight => void', [
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_animations__["h" /* style */])({ transform: 'translateX(-100%)', opacity: 0 }),
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_animations__["e" /* animate */])(300, Object(__WEBPACK_IMPORTED_MODULE_0__angular_animations__["f" /* keyframes */])([
            Object(__WEBPACK_IMPORTED_MODULE_0__angular_animations__["h" /* style */])({ opacity: 1, transform: 'translateX(0)', offset: 0 }),
            Object(__WEBPACK_IMPORTED_MODULE_0__angular_animations__["h" /* style */])({ opacity: 1, transform: 'translateX(-5%)', offset: 0.3 }),
            Object(__WEBPACK_IMPORTED_MODULE_0__angular_animations__["h" /* style */])({ opacity: 0, transform: 'translateX(100%)', offset: 1.0 })
        ]))
    ])
]);
//# sourceMappingURL=animations.js.map

/***/ }),
/* 721 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCoursePickerMenuPopoverComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Component to display a list of courses.
 */
var CoreCoursePickerMenuPopoverComponent = /** @class */ (function () {
    function CoreCoursePickerMenuPopoverComponent(navParams, viewCtrl) {
        this.viewCtrl = viewCtrl;
        this.courseId = -1;
        this.courses = navParams.get('courses') || [];
        this.courseId = navParams.get('courseId') || -1;
    }
    /**
     * Function called when a course is clicked.
     *
     * @param {Event} event Click event.
     * @param {any} course Course object clicked.
     * @return {boolean} Return true if success, false if error.
     */
    CoreCoursePickerMenuPopoverComponent.prototype.coursePicked = function (event, course) {
        this.viewCtrl.dismiss(course);
        return true;
    };
    CoreCoursePickerMenuPopoverComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-course-picker-menu-popover',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/components/course-picker-menu/course-picker-menu-popover.html"*/'<ion-list radio-group [(ngModel)]="courseId">\n    <ion-item text-wrap *ngFor="let course of courses" >\n        <ion-label><core-format-text [text]="course.fullname"></core-format-text></ion-label>\n        <ion-radio value="{{course.id}}" (ionSelect)="coursePicked($event, course)" ></ion-radio>\n    </ion-item>\n</ion-list>'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/components/course-picker-menu/course-picker-menu-popover.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["m" /* NavParams */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["s" /* ViewController */]])
    ], CoreCoursePickerMenuPopoverComponent);
    return CoreCoursePickerMenuPopoverComponent;
}());

//# sourceMappingURL=course-picker-menu-popover.js.map

/***/ }),
/* 722 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonCompetencyComponentsModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__components_components_module__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__directives_directives_module__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__pipes_pipes_module__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__course_course__ = __webpack_require__(590);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};








var AddonCompetencyComponentsModule = /** @class */ (function () {
    function AddonCompetencyComponentsModule() {
    }
    AddonCompetencyComponentsModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_7__course_course__["a" /* AddonCompetencyCourseComponent */]
            ],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1__angular_common__["b" /* CommonModule */],
                __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["g" /* IonicModule */],
                __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["b" /* TranslateModule */].forChild(),
                __WEBPACK_IMPORTED_MODULE_4__components_components_module__["a" /* CoreComponentsModule */],
                __WEBPACK_IMPORTED_MODULE_5__directives_directives_module__["a" /* CoreDirectivesModule */],
                __WEBPACK_IMPORTED_MODULE_6__pipes_pipes_module__["a" /* CorePipesModule */]
            ],
            providers: [],
            exports: [
                __WEBPACK_IMPORTED_MODULE_7__course_course__["a" /* AddonCompetencyCourseComponent */]
            ],
            entryComponents: [
                __WEBPACK_IMPORTED_MODULE_7__course_course__["a" /* AddonCompetencyCourseComponent */]
            ]
        })
    ], AddonCompetencyComponentsModule);
    return AddonCompetencyComponentsModule;
}());

//# sourceMappingURL=components.module.js.map

/***/ }),
/* 723 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonFilesHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_fileuploader_providers_helper__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__files__ = __webpack_require__(179);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Service that provides some features regarding private and site files.
 */
var AddonFilesHelperProvider = /** @class */ (function () {
    function AddonFilesHelperProvider(sitesProvider, fileUploaderHelper, filesProvider, domUtils) {
        this.sitesProvider = sitesProvider;
        this.fileUploaderHelper = fileUploaderHelper;
        this.filesProvider = filesProvider;
        this.domUtils = domUtils;
    }
    /**
     * Select a file, upload it and move it to private files.
     *
     * @param {any} [info] Private files info. See AddonFilesProvider.getPrivateFilesInfo.
     * @return {Promise<any>} Promise resolved when a file is uploaded, rejected otherwise.
     */
    AddonFilesHelperProvider.prototype.uploadPrivateFile = function (info) {
        var _this = this;
        // Calculate the max size.
        var currentSite = this.sitesProvider.getCurrentSite();
        var maxSize = currentSite.getInfo().usermaxuploadfilesize, userQuota = currentSite.getInfo().userquota;
        if (userQuota === 0) {
            // 0 means ignore user quota. In the app it is -1.
            userQuota = -1;
        }
        else if (userQuota > 0 && typeof info != 'undefined') {
            userQuota = userQuota - info.filesizewithoutreferences;
        }
        if (typeof userQuota != 'undefined') {
            // Use the minimum value.
            maxSize = Math.min(maxSize, userQuota);
        }
        // Select and upload the file.
        return this.fileUploaderHelper.selectAndUploadFile(maxSize).then(function (result) {
            if (!result) {
                return Promise.reject(null);
            }
            // File uploaded. Move it to private files.
            var modal = _this.domUtils.showModalLoading('core.fileuploader.uploading', true);
            return _this.filesProvider.moveFromDraftToPrivate(result.itemid).catch(function (error) {
                _this.domUtils.showErrorModalDefault(error, 'core.fileuploader.errorwhileuploading', true);
                return Promise.reject(null);
            }).finally(function () {
                modal.dismiss();
            });
        }).then(function () {
            _this.domUtils.showToast('core.fileuploader.fileuploaded', true, undefined, 'core-toast-success');
        });
    };
    AddonFilesHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_3__core_fileuploader_providers_helper__["a" /* CoreFileUploaderHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_4__files__["a" /* AddonFilesProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_dom__["a" /* CoreDomUtilsProvider */]])
    ], AddonFilesHelperProvider);
    return AddonFilesHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),
/* 724 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModBookComponentsModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__components_components_module__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__directives_directives_module__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_course_components_components_module__ = __webpack_require__(91);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__index_index__ = __webpack_require__(290);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__toc_popover_toc_popover__ = __webpack_require__(597);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__navigation_arrows_navigation_arrows__ = __webpack_require__(1071);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};










var AddonModBookComponentsModule = /** @class */ (function () {
    function AddonModBookComponentsModule() {
    }
    AddonModBookComponentsModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_7__index_index__["a" /* AddonModBookIndexComponent */],
                __WEBPACK_IMPORTED_MODULE_8__toc_popover_toc_popover__["a" /* AddonModBookTocPopoverComponent */],
                __WEBPACK_IMPORTED_MODULE_9__navigation_arrows_navigation_arrows__["a" /* AddonModBookNavigationArrowsComponent */]
            ],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1__angular_common__["b" /* CommonModule */],
                __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["g" /* IonicModule */],
                __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["b" /* TranslateModule */].forChild(),
                __WEBPACK_IMPORTED_MODULE_4__components_components_module__["a" /* CoreComponentsModule */],
                __WEBPACK_IMPORTED_MODULE_5__directives_directives_module__["a" /* CoreDirectivesModule */],
                __WEBPACK_IMPORTED_MODULE_6__core_course_components_components_module__["a" /* CoreCourseComponentsModule */]
            ],
            providers: [],
            exports: [
                __WEBPACK_IMPORTED_MODULE_7__index_index__["a" /* AddonModBookIndexComponent */],
                __WEBPACK_IMPORTED_MODULE_8__toc_popover_toc_popover__["a" /* AddonModBookTocPopoverComponent */],
                __WEBPACK_IMPORTED_MODULE_9__navigation_arrows_navigation_arrows__["a" /* AddonModBookNavigationArrowsComponent */]
            ],
            entryComponents: [
                __WEBPACK_IMPORTED_MODULE_7__index_index__["a" /* AddonModBookIndexComponent */],
                __WEBPACK_IMPORTED_MODULE_8__toc_popover_toc_popover__["a" /* AddonModBookTocPopoverComponent */]
            ]
        })
    ], AddonModBookComponentsModule);
    return AddonModBookComponentsModule;
}());

//# sourceMappingURL=components.module.js.map

/***/ }),
/* 725 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseFormatComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_events__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_course_providers_course__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_course_providers_helper__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__core_course_providers_format_delegate__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__core_course_providers_module_prefetch_delegate__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__components_dynamic_component_dynamic_component__ = __webpack_require__(241);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};











/**
 * Component to display course contents using a certain format. If the format isn't found, use default one.
 *
 * The inputs of this component will be shared with the course format components. Please use CoreCourseFormatDelegate
 * to register your handler for course formats.
 *
 * Example usage:
 *
 * <core-course-format [course]="course" [sections]="sections" (completionChanged)="onCompletionChange()"></core-course-format>
 */
var CoreCourseFormatComponent = /** @class */ (function () {
    function CoreCourseFormatComponent(cfDelegate, translate, injector, courseHelper, domUtils, eventsProvider, sitesProvider, content, prefetchDelegate) {
        var _this = this;
        this.cfDelegate = cfDelegate;
        this.injector = injector;
        this.courseHelper = courseHelper;
        this.domUtils = domUtils;
        this.sitesProvider = sitesProvider;
        this.content = content;
        // Data to pass to the components.
        this.data = {};
        this.allSectionsId = __WEBPACK_IMPORTED_MODULE_6__core_course_providers_course__["a" /* CoreCourseProvider */].ALL_SECTIONS_ID;
        this.selectOptions = {};
        this.selectOptions.title = translate.instant('core.course.sections');
        this.completionChanged = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
        // Listen for section status changes.
        this.sectionStatusObserver = eventsProvider.on(__WEBPACK_IMPORTED_MODULE_3__providers_events__["a" /* CoreEventsProvider */].SECTION_STATUS_CHANGED, function (data) {
            if (_this.downloadEnabled && _this.sections && _this.sections.length && _this.course && data.sectionId &&
                data.courseId == _this.course.id) {
                // Check if the affected section is being downloaded.
                // If so, we don't update section status because it'll already be updated when the download finishes.
                var downloadId_1 = _this.courseHelper.getSectionDownloadId({ id: data.sectionId });
                if (prefetchDelegate.isBeingDownloaded(downloadId_1)) {
                    return;
                }
                // Get the affected section.
                var section_1;
                for (var i = 0; i < _this.sections.length; i++) {
                    var s = _this.sections[i];
                    if (s.id === data.sectionId) {
                        section_1 = s;
                        break;
                    }
                }
                if (!section_1) {
                    // Section not found, stop.
                    return;
                }
                // Recalculate the status.
                _this.courseHelper.calculateSectionStatus(section_1, _this.course.id, false).then(function () {
                    if (section_1.isDownloading && !prefetchDelegate.isBeingDownloaded(downloadId_1)) {
                        // All the modules are now downloading, set a download all promise.
                        _this.prefetch(section_1, false);
                    }
                });
            }
        }, this.sitesProvider.getCurrentSiteId());
    }
    /**
     * Component being initialized.
     */
    CoreCourseFormatComponent.prototype.ngOnInit = function () {
        this.displaySectionSelector = this.cfDelegate.displaySectionSelector(this.course);
    };
    /**
     * Detect changes on input properties.
     */
    CoreCourseFormatComponent.prototype.ngOnChanges = function (changes) {
        var _this = this;
        this.setInputData();
        if (changes.course) {
            // Course has changed, try to get the components.
            this.getComponents();
        }
        if (changes.sections && this.sections) {
            if (!this.selectedSection) {
                // There is no selected section yet, calculate which one to load.
                if (this.initialSectionId || this.initialSectionNumber) {
                    // We have an input indicating the section ID to load. Search the section.
                    for (var i = 0; i < this.sections.length; i++) {
                        var section = this.sections[i];
                        if ((section.id && section.id == this.initialSectionId) ||
                            (section.section && section.section == this.initialSectionNumber)) {
                            this.loaded = true;
                            this.sectionChanged(section);
                            break;
                        }
                    }
                }
                else {
                    // No section specified, get current section.
                    this.cfDelegate.getCurrentSection(this.course, this.sections).then(function (section) {
                        _this.loaded = true;
                        _this.sectionChanged(section);
                    });
                }
            }
            else {
                // We have a selected section, but the list has changed. Search the section in the list.
                var newSection = void 0;
                for (var i = 0; i < this.sections.length; i++) {
                    var section = this.sections[i];
                    if (this.compareSections(section, this.selectedSection)) {
                        newSection = section;
                        break;
                    }
                }
                if (!newSection) {
                    // Section not found, calculate which one to use.
                    newSection = this.cfDelegate.getCurrentSection(this.course, this.sections);
                }
                this.sectionChanged(newSection);
            }
        }
        if (changes.downloadEnabled && this.downloadEnabled) {
            this.calculateSectionsStatus(false);
        }
    };
    /**
     * Set the input data for components.
     */
    CoreCourseFormatComponent.prototype.setInputData = function () {
        this.data.course = this.course;
        this.data.sections = this.sections;
        this.data.initialSectionId = this.initialSectionId;
        this.data.initialSectionNumber = this.initialSectionNumber;
        this.data.downloadEnabled = this.downloadEnabled;
    };
    /**
     * Get the components classes.
     */
    CoreCourseFormatComponent.prototype.getComponents = function () {
        var _this = this;
        if (this.course) {
            if (!this.courseFormatComponent) {
                this.cfDelegate.getCourseFormatComponent(this.injector, this.course).then(function (component) {
                    _this.courseFormatComponent = component;
                });
            }
            if (!this.courseSummaryComponent) {
                this.cfDelegate.getCourseSummaryComponent(this.injector, this.course).then(function (component) {
                    _this.courseSummaryComponent = component;
                });
            }
            if (!this.sectionSelectorComponent) {
                this.cfDelegate.getSectionSelectorComponent(this.injector, this.course).then(function (component) {
                    _this.sectionSelectorComponent = component;
                });
            }
            if (!this.singleSectionComponent) {
                this.cfDelegate.getSingleSectionComponent(this.injector, this.course).then(function (component) {
                    _this.singleSectionComponent = component;
                });
            }
            if (!this.allSectionsComponent) {
                this.cfDelegate.getAllSectionsComponent(this.injector, this.course).then(function (component) {
                    _this.allSectionsComponent = component;
                });
            }
        }
    };
    /**
     * Function called when selected section changes.
     *
     * @param {any} newSection The new selected section.
     */
    CoreCourseFormatComponent.prototype.sectionChanged = function (newSection) {
        var _this = this;
        var previousValue = this.selectedSection;
        this.selectedSection = newSection;
        this.data.section = this.selectedSection;
        if (this.moduleId && typeof previousValue == 'undefined') {
            setTimeout(function () {
                _this.domUtils.scrollToElementBySelector(_this.content, '#core-course-module-' + _this.moduleId);
            }, 200);
        }
    };
    /**
     * Compare if two sections are equal.
     *
     * @param {any} s1 First section.
     * @param {any} s2 Second section.
     * @return {boolean} Whether they're equal.
     */
    CoreCourseFormatComponent.prototype.compareSections = function (s1, s2) {
        return s1 && s2 ? s1.id === s2.id : s1 === s2;
    };
    /**
     * Calculate the status of sections.
     *
     * @param {boolean} refresh [description]
     */
    CoreCourseFormatComponent.prototype.calculateSectionsStatus = function (refresh) {
        this.courseHelper.calculateSectionsStatus(this.sections, this.course.id, refresh).catch(function () {
            // Ignore errors (shouldn't happen).
        });
    };
    /**
     * Confirm and prefetch a section. If the section is "all sections", prefetch all the sections.
     *
     * @param {Event} e Click event.
     * @param {any} section Section to download.
     */
    CoreCourseFormatComponent.prototype.prefetch = function (e, section) {
        var _this = this;
        e.preventDefault();
        e.stopPropagation();
        section.isCalculating = true;
        this.courseHelper.confirmDownloadSizeSection(this.course.id, section, this.sections).then(function () {
            _this.prefetchSection(section, true);
        }, function (error) {
            // User cancelled or there was an error calculating the size.
            if (error) {
                _this.domUtils.showErrorModal(error);
            }
        }).finally(function () {
            section.isCalculating = false;
        });
    };
    /**
     * Prefetch a section.
     *
     * @param {any} section The section to download.
     * @param {boolean} [manual] Whether the prefetch was started manually or it was automatically started because all modules
     *                           are being downloaded.
     */
    CoreCourseFormatComponent.prototype.prefetchSection = function (section, manual) {
        var _this = this;
        this.courseHelper.prefetchSection(section, this.course.id, this.sections).catch(function (error) {
            // Don't show error message if it's an automatic download.
            if (!manual) {
                return;
            }
            _this.domUtils.showErrorModalDefault(error, 'core.course.errordownloadingsection', true);
        });
    };
    /**
     * Refresh the data.
     *
     * @param {any} [refresher] Refresher.
     * @param {Function} [done] Function to call when done.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCourseFormatComponent.prototype.doRefresh = function (refresher, done) {
        var promises = [];
        this.dynamicComponents.forEach(function (component) {
            promises.push(Promise.resolve(component.callComponentFunction('doRefresh', [refresher, done])));
        });
        return Promise.all(promises);
    };
    /**
     * Component destroyed.
     */
    CoreCourseFormatComponent.prototype.ngOnDestroy = function () {
        if (this.sectionStatusObserver) {
            this.sectionStatusObserver.off();
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreCourseFormatComponent.prototype, "course", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Array)
    ], CoreCourseFormatComponent.prototype, "sections", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Boolean)
    ], CoreCourseFormatComponent.prototype, "downloadEnabled", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreCourseFormatComponent.prototype, "initialSectionId", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreCourseFormatComponent.prototype, "initialSectionNumber", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreCourseFormatComponent.prototype, "moduleId", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreCourseFormatComponent.prototype, "completionChanged", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_10" /* ViewChildren */])(__WEBPACK_IMPORTED_MODULE_10__components_dynamic_component_dynamic_component__["a" /* CoreDynamicComponent */]),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["T" /* QueryList */])
    ], CoreCourseFormatComponent.prototype, "dynamicComponents", void 0);
    CoreCourseFormatComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-course-format',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/core/course/components/format/format.html"*/'<!-- Default course format. -->\n<core-dynamic-component [component]="courseFormatComponent" [data]="data">\n    <!-- Course summary. By default we only display the course progress. -->\n    <core-dynamic-component [component]="courseSummaryComponent" [data]="data">\n        <ion-list no-lines>\n            <ion-item *ngIf="course.progress != null && course.progress >= 0">\n                <core-progress-bar [progress]="course.progress"></core-progress-bar>\n            </ion-item>\n        </ion-list>\n    </core-dynamic-component>\n\n    <core-loading [hideUntil]="loaded">\n        <!-- Section selector. -->\n        <core-dynamic-component [component]="sectionSelectorComponent" [data]="data">\n            <div text-wrap *ngIf="displaySectionSelector && sections && sections.length" no-padding class="clearfix">\n                <!-- @todo: How to display availabilityinfo and not visible messages? -->\n                <ion-select [ngModel]="selectedSection" (ngModelChange)="sectionChanged($event)" [compareWith]="compareSections" [selectOptions]="selectOptions" float-start interface="popover">\n                    <ion-option *ngFor="let section of sections" [value]="section">{{section.formattedName || section.name}}</ion-option>\n                </ion-select>\n                <!-- Section download. -->\n                <ng-container *ngTemplateOutlet="sectionDownloadTemplate; context: {section: selectedSection}"></ng-container>\n            </div>\n        </core-dynamic-component>\n\n        <!-- Single section. -->\n        <div *ngIf="selectedSection && selectedSection.id != allSectionsId">\n            <core-dynamic-component [component]="singleSectionComponent" [data]="data">\n                <ng-container *ngTemplateOutlet="sectionTemplate; context: {section: selectedSection}"></ng-container>\n                <core-empty-box *ngIf="!selectedSection.hasContent" icon="qr-scanner" [message]="\'core.course.nocontentavailable\' | translate"></core-empty-box>\n            </core-dynamic-component>\n        </div>\n\n        <!-- Multiple sections. -->\n        <div *ngIf="selectedSection && selectedSection.id == allSectionsId">\n            <core-dynamic-component [component]="allSectionsComponent" [data]="data">\n                <ng-container *ngFor="let section of sections">\n                    <ng-container *ngTemplateOutlet="sectionTemplate; context: {section: section}"></ng-container>\n                </ng-container>\n            </core-dynamic-component>\n        </div>\n    </core-loading>\n</core-dynamic-component>\n\n<!-- Template to render a section. -->\n<ng-template #sectionTemplate let-section="section">\n    <section ion-list *ngIf="section.hasContent">\n        <!-- Title is only displayed when viewing all sections. -->\n        <ion-item-divider text-wrap color="light" *ngIf="selectedSection.id == allSectionsId && section.name">\n            <core-format-text [text]="section.name"></core-format-text>\n            <!-- Section download. -->\n            <ng-container *ngTemplateOutlet="sectionDownloadTemplate; context: {section: section}"></ng-container>\n        </ion-item-divider>\n\n        <ion-item text-wrap *ngIf="section.summary">\n            <core-format-text [text]="section.summary"></core-format-text>\n        </ion-item>\n\n        <ng-container *ngFor="let module of section.modules">\n            <core-course-module *ngIf="module.visibleoncoursepage !== 0" [module]="module" [courseId]="course.id" [downloadEnabled]="downloadEnabled" (completionChanged)="completionChanged.emit()"></core-course-module>\n        </ng-container>\n    </section>\n</ng-template>\n\n<!-- Template to render a section download button/progress. -->\n<ng-template #sectionDownloadTemplate let-section="section">\n    <div *ngIf="section && downloadEnabled" class="core-button-spinner" float-end>\n        <!-- Download button. -->\n        <button *ngIf="section.showDownload && !section.isDownloading && !section.isCalculating" (click)="prefetch($event, section)" ion-button icon-only clear color="dark" [attr.aria-label]="\'core.download\' | translate">\n            <ion-icon name="cloud-download"></ion-icon>\n        </button>\n        <!-- Refresh button. -->\n        <button *ngIf="section.showRefresh && !section.isDownloading && !section.isCalculating" (click)="prefetch($event, section)" ion-button icon-only clear color="dark" [attr.aria-label]="\'core.refresh\' | translate">\n            <ion-icon name="refresh"></ion-icon>\n        </button>\n        <!-- Download progress. -->\n        <ion-badge class="core-course-download-section-progress" *ngIf="section.isDownloading && section.total > 0 && section.count < section.total">{{section.count}} / {{section.total}}</ion-badge>\n        <!-- Spinner (downloading or calculating status). -->\n        <ion-spinner *ngIf="(section.isDownloading && section.total > 0) || section.isCalculating"></ion-spinner>\n    </div>\n</ng-template>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/core/course/components/format/format.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_8__core_course_providers_format_delegate__["a" /* CoreCourseFormatDelegate */], __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["C" /* Injector */],
            __WEBPACK_IMPORTED_MODULE_7__core_course_providers_helper__["a" /* CoreCourseHelperProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["e" /* Content */],
            __WEBPACK_IMPORTED_MODULE_9__core_course_providers_module_prefetch_delegate__["a" /* CoreCourseModulePrefetchDelegate */]])
    ], CoreCourseFormatComponent);
    return CoreCourseFormatComponent;
}());

//# sourceMappingURL=format.js.map

/***/ }),
/* 726 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModFolderComponentsModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__components_components_module__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__core_course_components_components_module__ = __webpack_require__(91);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__index_index__ = __webpack_require__(291);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};







var AddonModFolderComponentsModule = /** @class */ (function () {
    function AddonModFolderComponentsModule() {
    }
    AddonModFolderComponentsModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_6__index_index__["a" /* AddonModFolderIndexComponent */]
            ],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1__angular_common__["b" /* CommonModule */],
                __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["g" /* IonicModule */],
                __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["b" /* TranslateModule */].forChild(),
                __WEBPACK_IMPORTED_MODULE_4__components_components_module__["a" /* CoreComponentsModule */],
                __WEBPACK_IMPORTED_MODULE_5__core_course_components_components_module__["a" /* CoreCourseComponentsModule */]
            ],
            providers: [],
            exports: [
                __WEBPACK_IMPORTED_MODULE_6__index_index__["a" /* AddonModFolderIndexComponent */]
            ],
            entryComponents: [
                __WEBPACK_IMPORTED_MODULE_6__index_index__["a" /* AddonModFolderIndexComponent */]
            ]
        })
    ], AddonModFolderComponentsModule);
    return AddonModFolderComponentsModule;
}());

//# sourceMappingURL=components.module.js.map

/***/ }),
/* 727 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModPageComponentsModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__components_components_module__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__directives_directives_module__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_course_components_components_module__ = __webpack_require__(91);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__index_index__ = __webpack_require__(292);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};








var AddonModPageComponentsModule = /** @class */ (function () {
    function AddonModPageComponentsModule() {
    }
    AddonModPageComponentsModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_7__index_index__["a" /* AddonModPageIndexComponent */]
            ],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1__angular_common__["b" /* CommonModule */],
                __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["g" /* IonicModule */],
                __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["b" /* TranslateModule */].forChild(),
                __WEBPACK_IMPORTED_MODULE_4__components_components_module__["a" /* CoreComponentsModule */],
                __WEBPACK_IMPORTED_MODULE_5__directives_directives_module__["a" /* CoreDirectivesModule */],
                __WEBPACK_IMPORTED_MODULE_6__core_course_components_components_module__["a" /* CoreCourseComponentsModule */]
            ],
            providers: [],
            exports: [
                __WEBPACK_IMPORTED_MODULE_7__index_index__["a" /* AddonModPageIndexComponent */]
            ],
            entryComponents: [
                __WEBPACK_IMPORTED_MODULE_7__index_index__["a" /* AddonModPageIndexComponent */]
            ]
        })
    ], AddonModPageComponentsModule);
    return AddonModPageComponentsModule;
}());

//# sourceMappingURL=components.module.js.map

/***/ }),
/* 728 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModResourceComponentsModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__components_components_module__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__directives_directives_module__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_course_components_components_module__ = __webpack_require__(91);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__index_index__ = __webpack_require__(293);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};








var AddonModResourceComponentsModule = /** @class */ (function () {
    function AddonModResourceComponentsModule() {
    }
    AddonModResourceComponentsModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_7__index_index__["a" /* AddonModResourceIndexComponent */]
            ],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1__angular_common__["b" /* CommonModule */],
                __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["g" /* IonicModule */],
                __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["b" /* TranslateModule */].forChild(),
                __WEBPACK_IMPORTED_MODULE_4__components_components_module__["a" /* CoreComponentsModule */],
                __WEBPACK_IMPORTED_MODULE_5__directives_directives_module__["a" /* CoreDirectivesModule */],
                __WEBPACK_IMPORTED_MODULE_6__core_course_components_components_module__["a" /* CoreCourseComponentsModule */]
            ],
            providers: [],
            exports: [
                __WEBPACK_IMPORTED_MODULE_7__index_index__["a" /* AddonModResourceIndexComponent */]
            ],
            entryComponents: [
                __WEBPACK_IMPORTED_MODULE_7__index_index__["a" /* AddonModResourceIndexComponent */]
            ]
        })
    ], AddonModResourceComponentsModule);
    return AddonModResourceComponentsModule;
}());

//# sourceMappingURL=components.module.js.map

/***/ }),
/* 729 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModUrlComponentsModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__components_components_module__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__directives_directives_module__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_course_components_components_module__ = __webpack_require__(91);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__index_index__ = __webpack_require__(294);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};








var AddonModUrlComponentsModule = /** @class */ (function () {
    function AddonModUrlComponentsModule() {
    }
    AddonModUrlComponentsModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_7__index_index__["a" /* AddonModUrlIndexComponent */]
            ],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1__angular_common__["b" /* CommonModule */],
                __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["g" /* IonicModule */],
                __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["b" /* TranslateModule */].forChild(),
                __WEBPACK_IMPORTED_MODULE_4__components_components_module__["a" /* CoreComponentsModule */],
                __WEBPACK_IMPORTED_MODULE_5__directives_directives_module__["a" /* CoreDirectivesModule */],
                __WEBPACK_IMPORTED_MODULE_6__core_course_components_components_module__["a" /* CoreCourseComponentsModule */]
            ],
            providers: [],
            exports: [
                __WEBPACK_IMPORTED_MODULE_7__index_index__["a" /* AddonModUrlIndexComponent */]
            ],
            entryComponents: [
                __WEBPACK_IMPORTED_MODULE_7__index_index__["a" /* AddonModUrlIndexComponent */]
            ]
        })
    ], AddonModUrlComponentsModule);
    return AddonModUrlComponentsModule;
}());

//# sourceMappingURL=components.module.js.map

/***/ }),
/* 730 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_platform_browser_dynamic__ = __webpack_require__(731);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__app_module__ = __webpack_require__(312);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_promise_prototype_finally__ = __webpack_require__(1285);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_promise_prototype_finally___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_promise_prototype_finally__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.



Object(__WEBPACK_IMPORTED_MODULE_2_promise_prototype_finally__["shim"])(); // Support promise.finally.
Object(__WEBPACK_IMPORTED_MODULE_0__angular_platform_browser_dynamic__["a" /* platformBrowserDynamic */])().bootstrapModule(__WEBPACK_IMPORTED_MODULE_1__app_module__["a" /* AppModule */]);
//# sourceMappingURL=main.js.map

/***/ }),
/* 731 */,
/* 732 */,
/* 733 */,
/* 734 */,
/* 735 */,
/* 736 */,
/* 737 */,
/* 738 */,
/* 739 */,
/* 740 */,
/* 741 */,
/* 742 */,
/* 743 */,
/* 744 */,
/* 745 */,
/* 746 */,
/* 747 */,
/* 748 */,
/* 749 */,
/* 750 */,
/* 751 */,
/* 752 */,
/* 753 */,
/* 754 */,
/* 755 */,
/* 756 */,
/* 757 */,
/* 758 */,
/* 759 */,
/* 760 */,
/* 761 */,
/* 762 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreAutoFocusDirective; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__ = __webpack_require__(9);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};




/**
 * Directive to auto focus an element when a view is loaded.
 *
 * You can apply it conditionallity assigning it a boolean value: <ion-input [core-auto-focus]="{{showKeyboard}}">
 */
var CoreAutoFocusDirective = /** @class */ (function () {
    function CoreAutoFocusDirective(element, domUtils, utils, navCtrl) {
        this.domUtils = domUtils;
        this.utils = utils;
        this.navCtrl = navCtrl;
        this.coreAutoFocus = true;
        this.element = element.nativeElement || element;
    }
    /**
     * Component being initialized.
     */
    CoreAutoFocusDirective.prototype.ngOnInit = function () {
        var _this = this;
        if (this.navCtrl.isTransitioning()) {
            // Navigating to a new page. Wait for the transition to be over.
            var subscription_1 = this.navCtrl.viewDidEnter.subscribe(function () {
                _this.autoFocus();
                subscription_1.unsubscribe();
            });
        }
        else {
            this.autoFocus();
        }
    };
    /**
     * Function after the view is initialized.
     */
    CoreAutoFocusDirective.prototype.autoFocus = function () {
        var _this = this;
        var autoFocus = this.utils.isTrueOrOne(this.coreAutoFocus);
        if (autoFocus) {
            // If it's a ion-input or ion-textarea, search the right input to use.
            var element_1 = this.element;
            if (this.element.tagName == 'ION-INPUT') {
                element_1 = this.element.querySelector('input') || element_1;
            }
            else if (this.element.tagName == 'ION-TEXTAREA') {
                element_1 = this.element.querySelector('textarea') || element_1;
            }
            // Wait a bit to make sure the view is loaded.
            setTimeout(function () {
                _this.domUtils.focusElement(element_1);
            }, 200);
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])('core-auto-focus'),
        __metadata("design:type", Object)
    ], CoreAutoFocusDirective.prototype, "coreAutoFocus", void 0);
    CoreAutoFocusDirective = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["s" /* Directive */])({
            selector: '[core-auto-focus]'
        }),
        __param(3, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["N" /* Optional */])()),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavController */]])
    ], CoreAutoFocusDirective);
    return CoreAutoFocusDirective;
}());

//# sourceMappingURL=auto-focus.js.map

/***/ }),
/* 763 */,
/* 764 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./af": 372,
	"./af.js": 372,
	"./ar": 373,
	"./ar-dz": 374,
	"./ar-dz.js": 374,
	"./ar-kw": 375,
	"./ar-kw.js": 375,
	"./ar-ly": 376,
	"./ar-ly.js": 376,
	"./ar-ma": 377,
	"./ar-ma.js": 377,
	"./ar-sa": 378,
	"./ar-sa.js": 378,
	"./ar-tn": 379,
	"./ar-tn.js": 379,
	"./ar.js": 373,
	"./az": 380,
	"./az.js": 380,
	"./be": 381,
	"./be.js": 381,
	"./bg": 382,
	"./bg.js": 382,
	"./bm": 383,
	"./bm.js": 383,
	"./bn": 384,
	"./bn.js": 384,
	"./bo": 385,
	"./bo.js": 385,
	"./br": 386,
	"./br.js": 386,
	"./bs": 387,
	"./bs.js": 387,
	"./ca": 388,
	"./ca.js": 388,
	"./cs": 389,
	"./cs.js": 389,
	"./cv": 390,
	"./cv.js": 390,
	"./cy": 391,
	"./cy.js": 391,
	"./da": 392,
	"./da.js": 392,
	"./de": 393,
	"./de-at": 394,
	"./de-at.js": 394,
	"./de-ch": 395,
	"./de-ch.js": 395,
	"./de.js": 393,
	"./dv": 396,
	"./dv.js": 396,
	"./el": 397,
	"./el.js": 397,
	"./en-au": 398,
	"./en-au.js": 398,
	"./en-ca": 399,
	"./en-ca.js": 399,
	"./en-gb": 400,
	"./en-gb.js": 400,
	"./en-ie": 401,
	"./en-ie.js": 401,
	"./en-nz": 402,
	"./en-nz.js": 402,
	"./eo": 403,
	"./eo.js": 403,
	"./es": 404,
	"./es-do": 405,
	"./es-do.js": 405,
	"./es-us": 406,
	"./es-us.js": 406,
	"./es.js": 404,
	"./et": 407,
	"./et.js": 407,
	"./eu": 408,
	"./eu.js": 408,
	"./fa": 409,
	"./fa.js": 409,
	"./fi": 410,
	"./fi.js": 410,
	"./fo": 411,
	"./fo.js": 411,
	"./fr": 412,
	"./fr-ca": 413,
	"./fr-ca.js": 413,
	"./fr-ch": 414,
	"./fr-ch.js": 414,
	"./fr.js": 412,
	"./fy": 415,
	"./fy.js": 415,
	"./gd": 416,
	"./gd.js": 416,
	"./gl": 417,
	"./gl.js": 417,
	"./gom-latn": 418,
	"./gom-latn.js": 418,
	"./gu": 419,
	"./gu.js": 419,
	"./he": 420,
	"./he.js": 420,
	"./hi": 421,
	"./hi.js": 421,
	"./hr": 422,
	"./hr.js": 422,
	"./hu": 423,
	"./hu.js": 423,
	"./hy-am": 424,
	"./hy-am.js": 424,
	"./id": 425,
	"./id.js": 425,
	"./is": 426,
	"./is.js": 426,
	"./it": 427,
	"./it.js": 427,
	"./ja": 428,
	"./ja.js": 428,
	"./jv": 429,
	"./jv.js": 429,
	"./ka": 430,
	"./ka.js": 430,
	"./kk": 431,
	"./kk.js": 431,
	"./km": 432,
	"./km.js": 432,
	"./kn": 433,
	"./kn.js": 433,
	"./ko": 434,
	"./ko.js": 434,
	"./ky": 435,
	"./ky.js": 435,
	"./lb": 436,
	"./lb.js": 436,
	"./lo": 437,
	"./lo.js": 437,
	"./lt": 438,
	"./lt.js": 438,
	"./lv": 439,
	"./lv.js": 439,
	"./me": 440,
	"./me.js": 440,
	"./mi": 441,
	"./mi.js": 441,
	"./mk": 442,
	"./mk.js": 442,
	"./ml": 443,
	"./ml.js": 443,
	"./mr": 444,
	"./mr.js": 444,
	"./ms": 445,
	"./ms-my": 446,
	"./ms-my.js": 446,
	"./ms.js": 445,
	"./my": 447,
	"./my.js": 447,
	"./nb": 448,
	"./nb.js": 448,
	"./ne": 449,
	"./ne.js": 449,
	"./nl": 450,
	"./nl-be": 451,
	"./nl-be.js": 451,
	"./nl.js": 450,
	"./nn": 452,
	"./nn.js": 452,
	"./pa-in": 453,
	"./pa-in.js": 453,
	"./pl": 454,
	"./pl.js": 454,
	"./pt": 455,
	"./pt-br": 456,
	"./pt-br.js": 456,
	"./pt.js": 455,
	"./ro": 457,
	"./ro.js": 457,
	"./ru": 458,
	"./ru.js": 458,
	"./sd": 459,
	"./sd.js": 459,
	"./se": 460,
	"./se.js": 460,
	"./si": 461,
	"./si.js": 461,
	"./sk": 462,
	"./sk.js": 462,
	"./sl": 463,
	"./sl.js": 463,
	"./sq": 464,
	"./sq.js": 464,
	"./sr": 465,
	"./sr-cyrl": 466,
	"./sr-cyrl.js": 466,
	"./sr.js": 465,
	"./ss": 467,
	"./ss.js": 467,
	"./sv": 468,
	"./sv.js": 468,
	"./sw": 469,
	"./sw.js": 469,
	"./ta": 470,
	"./ta.js": 470,
	"./te": 471,
	"./te.js": 471,
	"./tet": 472,
	"./tet.js": 472,
	"./th": 473,
	"./th.js": 473,
	"./tl-ph": 474,
	"./tl-ph.js": 474,
	"./tlh": 475,
	"./tlh.js": 475,
	"./tr": 476,
	"./tr.js": 476,
	"./tzl": 477,
	"./tzl.js": 477,
	"./tzm": 478,
	"./tzm-latn": 479,
	"./tzm-latn.js": 479,
	"./tzm.js": 478,
	"./uk": 480,
	"./uk.js": 480,
	"./ur": 481,
	"./ur.js": 481,
	"./uz": 482,
	"./uz-latn": 483,
	"./uz-latn.js": 483,
	"./uz.js": 482,
	"./vi": 484,
	"./vi.js": 484,
	"./x-pseudo": 485,
	"./x-pseudo.js": 485,
	"./yo": 486,
	"./yo.js": 486,
	"./zh-cn": 487,
	"./zh-cn.js": 487,
	"./zh-hk": 488,
	"./zh-hk.js": 488,
	"./zh-tw": 489,
	"./zh-tw.js": 489
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number or string
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 764;

/***/ }),
/* 765 */,
/* 766 */,
/* 767 */,
/* 768 */,
/* 769 */,
/* 770 */,
/* 771 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SQLiteDBMock; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__classes_sqlitedb__ = __webpack_require__(495);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* tslint:disable:no-console */

/**
 * Class to mock the interaction with the SQLite database.
 */
var SQLiteDBMock = /** @class */ (function (_super) {
    __extends(SQLiteDBMock, _super);
    /**
     * Create and open the database.
     *
     * @param {string} name Database name.
     */
    function SQLiteDBMock(name) {
        var _this = _super.call(this, name, null, null) || this;
        _this.name = name;
        return _this;
    }
    /**
     * Close the database.
     *
     * @return {Promise<any>} Promise resolved when done.
     */
    SQLiteDBMock.prototype.close = function () {
        // WebSQL databases aren't closed.
        return Promise.resolve();
    };
    /**
     * Drop all the data in the database.
     *
     * @return {Promise<any>} Promise resolved when done.
     */
    SQLiteDBMock.prototype.emptyDatabase = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.db.transaction(function (tx) {
                // Query all tables from sqlite_master that we have created and can modify.
                var args = [], query = "SELECT * FROM sqlite_master\n                            WHERE name NOT LIKE 'sqlite\\_%' escape '\\' AND name NOT LIKE '\\_%' escape '\\'";
                tx.executeSql(query, args, function (tx, result) {
                    if (result.rows.length <= 0) {
                        // No tables to delete, stop.
                        resolve();
                        return;
                    }
                    // Drop all the tables.
                    var promises = [];
                    var _loop_1 = function (i) {
                        promises.push(new Promise(function (resolve, reject) {
                            // Drop the table.
                            var name = JSON.stringify(result.rows.item(i).name);
                            tx.executeSql('DROP TABLE ' + name, [], resolve, reject);
                        }));
                    };
                    for (var i = 0; i < result.rows.length; i++) {
                        _loop_1(i);
                    }
                    Promise.all(promises).then(resolve, reject);
                }, reject);
            });
        });
    };
    /**
     * Execute a SQL query.
     * IMPORTANT: Use this function only if you cannot use any of the other functions in this API. Please take into account that
     * these query will be run in SQLite (Mobile) and Web SQL (desktop), so your query should work in both environments.
     *
     * @param {string} sql SQL query to execute.
     * @param {any[]} params Query parameters.
     * @return {Promise<any>} Promise resolved with the result.
     */
    SQLiteDBMock.prototype.execute = function (sql, params) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            // With WebSQL, all queries must be run in a transaction.
            _this.db.transaction(function (tx) {
                tx.executeSql(sql, params, function (tx, results) {
                    resolve(results);
                }, function (tx, error) {
                    console.error(sql, params, error);
                    reject(error);
                });
            });
        });
    };
    /**
     * Execute a set of SQL queries. This operation is atomic.
     * IMPORTANT: Use this function only if you cannot use any of the other functions in this API. Please take into account that
     * these query will be run in SQLite (Mobile) and Web SQL (desktop), so your query should work in both environments.
     *
     * @param {any[]} sqlStatements SQL statements to execute.
     * @return {Promise<any>} Promise resolved with the result.
     */
    SQLiteDBMock.prototype.executeBatch = function (sqlStatements) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            // Create a transaction to execute the queries.
            _this.db.transaction(function (tx) {
                var promises = [];
                // Execute all the queries. Each statement can be a string or an array.
                sqlStatements.forEach(function (statement) {
                    promises.push(new Promise(function (resolve, reject) {
                        var query, params;
                        if (Array.isArray(statement)) {
                            query = statement[0];
                            params = statement[1];
                        }
                        else {
                            query = statement;
                            params = null;
                        }
                        tx.executeSql(query, params, function (tx, results) {
                            resolve(results);
                        }, reject);
                    }));
                });
                Promise.all(promises).then(resolve, reject);
            });
        });
    };
    /**
     * Initialize the database.
     */
    SQLiteDBMock.prototype.init = function () {
        // This DB is for desktop apps, so use a big size to be sure it isn't filled.
        this.db = window.openDatabase(this.name, '1.0', this.name, 500 * 1024 * 1024);
        this.promise = Promise.resolve();
    };
    /**
     * Open the database. Only needed if it was closed before, a database is automatically opened when created.
     *
     * @return {Promise<any>} Promise resolved when done.
     */
    SQLiteDBMock.prototype.open = function () {
        // WebSQL databases can't closed, so the open method isn't needed.
        return Promise.resolve();
    };
    return SQLiteDBMock;
}(__WEBPACK_IMPORTED_MODULE_0__classes_sqlitedb__["a" /* SQLiteDB */]));

//# sourceMappingURL=sqlitedb.js.map

/***/ }),
/* 772 */,
/* 773 */,
/* 774 */,
/* 775 */,
/* 776 */,
/* 777 */,
/* 778 */,
/* 779 */,
/* 780 */,
/* 781 */,
/* 782 */,
/* 783 */,
/* 784 */,
/* 785 */,
/* 786 */,
/* 787 */,
/* 788 */,
/* 789 */,
/* 790 */,
/* 791 */,
/* 792 */,
/* 793 */,
/* 794 */,
/* 795 */,
/* 796 */,
/* 797 */,
/* 798 */,
/* 799 */,
/* 800 */,
/* 801 */,
/* 802 */,
/* 803 */,
/* 804 */,
/* 805 */,
/* 806 */,
/* 807 */,
/* 808 */,
/* 809 */,
/* 810 */,
/* 811 */,
/* 812 */,
/* 813 */,
/* 814 */,
/* 815 */,
/* 816 */,
/* 817 */,
/* 818 */,
/* 819 */,
/* 820 */,
/* 821 */,
/* 822 */,
/* 823 */,
/* 824 */,
/* 825 */,
/* 826 */,
/* 827 */,
/* 828 */,
/* 829 */,
/* 830 */,
/* 831 */,
/* 832 */,
/* 833 */,
/* 834 */,
/* 835 */,
/* 836 */,
/* 837 */,
/* 838 */,
/* 839 */,
/* 840 */,
/* 841 */,
/* 842 */,
/* 843 */,
/* 844 */,
/* 845 */,
/* 846 */,
/* 847 */,
/* 848 */,
/* 849 */,
/* 850 */,
/* 851 */,
/* 852 */,
/* 853 */,
/* 854 */,
/* 855 */,
/* 856 */,
/* 857 */,
/* 858 */,
/* 859 */,
/* 860 */,
/* 861 */,
/* 862 */,
/* 863 */,
/* 864 */,
/* 865 */,
/* 866 */,
/* 867 */,
/* 868 */,
/* 869 */,
/* 870 */,
/* 871 */,
/* 872 */,
/* 873 */,
/* 874 */,
/* 875 */,
/* 876 */,
/* 877 */,
/* 878 */,
/* 879 */,
/* 880 */,
/* 881 */,
/* 882 */,
/* 883 */,
/* 884 */,
/* 885 */,
/* 886 */,
/* 887 */,
/* 888 */,
/* 889 */,
/* 890 */,
/* 891 */,
/* 892 */,
/* 893 */,
/* 894 */,
/* 895 */,
/* 896 */,
/* 897 */,
/* 898 */,
/* 899 */,
/* 900 */,
/* 901 */,
/* 902 */,
/* 903 */,
/* 904 */,
/* 905 */,
/* 906 */,
/* 907 */,
/* 908 */,
/* 909 */,
/* 910 */,
/* 911 */,
/* 912 */,
/* 913 */,
/* 914 */,
/* 915 */,
/* 916 */,
/* 917 */,
/* 918 */,
/* 919 */,
/* 920 */,
/* 921 */,
/* 922 */,
/* 923 */,
/* 924 */,
/* 925 */,
/* 926 */,
/* 927 */,
/* 928 */,
/* 929 */,
/* 930 */,
/* 931 */,
/* 932 */,
/* 933 */,
/* 934 */,
/* 935 */,
/* 936 */,
/* 937 */,
/* 938 */,
/* 939 */,
/* 940 */,
/* 941 */,
/* 942 */,
/* 943 */,
/* 944 */,
/* 945 */,
/* 946 */,
/* 947 */,
/* 948 */,
/* 949 */,
/* 950 */,
/* 951 */,
/* 952 */,
/* 953 */,
/* 954 */,
/* 955 */,
/* 956 */,
/* 957 */,
/* 958 */,
/* 959 */,
/* 960 */,
/* 961 */,
/* 962 */,
/* 963 */,
/* 964 */,
/* 965 */,
/* 966 */,
/* 967 */,
/* 968 */,
/* 969 */,
/* 970 */,
/* 971 */,
/* 972 */,
/* 973 */,
/* 974 */,
/* 975 */,
/* 976 */,
/* 977 */,
/* 978 */,
/* 979 */,
/* 980 */,
/* 981 */,
/* 982 */,
/* 983 */,
/* 984 */,
/* 985 */,
/* 986 */,
/* 987 */,
/* 988 */,
/* 989 */,
/* 990 */,
/* 991 */,
/* 992 */,
/* 993 */,
/* 994 */,
/* 995 */,
/* 996 */,
/* 997 */,
/* 998 */,
/* 999 */,
/* 1000 */,
/* 1001 */,
/* 1002 */,
/* 1003 */,
/* 1004 */,
/* 1005 */,
/* 1006 */,
/* 1007 */,
/* 1008 */,
/* 1009 */,
/* 1010 */,
/* 1011 */,
/* 1012 */,
/* 1013 */,
/* 1014 */,
/* 1015 */,
/* 1016 */,
/* 1017 */,
/* 1018 */,
/* 1019 */,
/* 1020 */,
/* 1021 */,
/* 1022 */,
/* 1023 */,
/* 1024 */,
/* 1025 */,
/* 1026 */,
/* 1027 */,
/* 1028 */,
/* 1029 */,
/* 1030 */,
/* 1031 */,
/* 1032 */,
/* 1033 */,
/* 1034 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreDownloadFileDirective; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_file_helper__ = __webpack_require__(160);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_dom__ = __webpack_require__(10);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Directive to allow downloading and open a file. When the item with this directive is clicked, the file will be
 * downloaded (if needed) and opened.
 */
var CoreDownloadFileDirective = /** @class */ (function () {
    function CoreDownloadFileDirective(element, domUtils, fileHelper) {
        this.domUtils = domUtils;
        this.fileHelper = fileHelper;
        this.element = element.nativeElement || element;
    }
    /**
     * Component being initialized.
     */
    CoreDownloadFileDirective.prototype.ngOnInit = function () {
        var _this = this;
        this.element.addEventListener('click', function (ev) {
            if (!_this.file) {
                return;
            }
            ev.preventDefault();
            ev.stopPropagation();
            var modal = _this.domUtils.showModalLoading();
            _this.fileHelper.downloadAndOpenFile(_this.file, _this.component, _this.componentId).catch(function (error) {
                _this.domUtils.showErrorModalDefault(error, 'core.errordownloading', true);
            }).finally(function () {
                modal.dismiss();
            });
        });
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])('core-download-file'),
        __metadata("design:type", Object)
    ], CoreDownloadFileDirective.prototype, "file", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreDownloadFileDirective.prototype, "component", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreDownloadFileDirective.prototype, "componentId", void 0);
    CoreDownloadFileDirective = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["s" /* Directive */])({
            selector: '[core-download-file]'
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_1__providers_file_helper__["a" /* CoreFileHelperProvider */]])
    ], CoreDownloadFileDirective);
    return CoreDownloadFileDirective;
}());

//# sourceMappingURL=download-file.js.map

/***/ }),
/* 1035 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSite; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(104);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_db__ = __webpack_require__(227);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_events__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_file__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_ws__ = __webpack_require__(137);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_text__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_utils_time__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_utils_url__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__core_constants__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__configconstants__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_ts_md5_dist_md5__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_ts_md5_dist_md5___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_15_ts_md5_dist_md5__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
















/**
 * Class that represents a site (combination of site + user).
 * It will have all the site data and provide utility functions regarding a site.
 * To add tables to the site's database, please use CoreSitesProvider.createTablesFromSchema. This will make sure that
 * the tables are created in all the sites, not just the current one.
 */
var CoreSite = /** @class */ (function () {
    /**
     * Create a site.
     *
     * @param {Injector} injector Angular injector to prevent having to pass all the required services.
     * @param {string} id Site ID.
     * @param {string} siteUrl Site URL.
     * @param {string} [token] Site's WS token.
     * @param {any} [info] Site info.
     * @param {string} [privateToken] Private token.
     * @param {any} [config] Site public config.
     * @param {boolean} [loggedOut] Whether user is logged out.
     */
    function CoreSite(injector, id, siteUrl, token, infos, privateToken, config, loggedOut) {
        this.id = id;
        this.siteUrl = siteUrl;
        this.token = token;
        this.infos = infos;
        this.privateToken = privateToken;
        this.config = config;
        this.loggedOut = loggedOut;
        // Variables for the database.
        this.WS_CACHE_TABLE = 'wscache';
        this.tableSchema = {
            name: this.WS_CACHE_TABLE,
            columns: [
                {
                    name: 'id',
                    type: 'TEXT',
                    primaryKey: true
                },
                {
                    name: 'data',
                    type: 'TEXT'
                },
                {
                    name: 'key',
                    type: 'TEXT'
                },
                {
                    name: 'expirationTime',
                    type: 'INTEGER'
                }
            ]
        };
        this.cleanUnicode = false;
        this.lastAutoLogin = 0;
        this.moodleReleases = {
            3.1: 2016052300,
            3.2: 2016120500,
            3.3: 2017051503,
            3.4: 2017111300
        };
        // Inject the required services.
        var logger = injector.get(__WEBPACK_IMPORTED_MODULE_6__providers_logger__["a" /* CoreLoggerProvider */]);
        this.appProvider = injector.get(__WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */]);
        this.dbProvider = injector.get(__WEBPACK_IMPORTED_MODULE_3__providers_db__["a" /* CoreDbProvider */]);
        this.domUtils = injector.get(__WEBPACK_IMPORTED_MODULE_8__providers_utils_dom__["a" /* CoreDomUtilsProvider */]);
        this.eventsProvider = injector.get(__WEBPACK_IMPORTED_MODULE_4__providers_events__["a" /* CoreEventsProvider */]);
        this.fileProvider = injector.get(__WEBPACK_IMPORTED_MODULE_5__providers_file__["a" /* CoreFileProvider */]);
        this.http = injector.get(__WEBPACK_IMPORTED_MODULE_1__angular_common_http__["b" /* HttpClient */]);
        this.textUtils = injector.get(__WEBPACK_IMPORTED_MODULE_9__providers_utils_text__["a" /* CoreTextUtilsProvider */]);
        this.timeUtils = injector.get(__WEBPACK_IMPORTED_MODULE_10__providers_utils_time__["a" /* CoreTimeUtilsProvider */]);
        this.translate = injector.get(__WEBPACK_IMPORTED_MODULE_0__ngx_translate_core__["c" /* TranslateService */]);
        this.utils = injector.get(__WEBPACK_IMPORTED_MODULE_12__providers_utils_utils__["a" /* CoreUtilsProvider */]);
        this.urlUtils = injector.get(__WEBPACK_IMPORTED_MODULE_11__providers_utils_url__["a" /* CoreUrlUtilsProvider */]);
        this.wsProvider = injector.get(__WEBPACK_IMPORTED_MODULE_7__providers_ws__["a" /* CoreWSProvider */]);
        this.logger = logger.getInstance('CoreWSProvider');
        if (this.id) {
            this.initDB();
        }
    }
    /**
     * Initialize the database.
     */
    CoreSite.prototype.initDB = function () {
        this.db = this.dbProvider.getDB('Site-' + this.id);
        this.db.createTableFromSchema(this.tableSchema);
    };
    /**
     * Get site ID.
     *
     * @return {string} Site ID.
     */
    CoreSite.prototype.getId = function () {
        return this.id;
    };
    /**
     * Get site URL.
     *
     * @return {string} Site URL.
     */
    CoreSite.prototype.getURL = function () {
        return this.siteUrl;
    };
    /**
     * Get site token.
     *
     * @return {string} Site token.
     */
    CoreSite.prototype.getToken = function () {
        return this.token;
    };
    /**
     * Get site info.
     *
     * @return {any} Site info.
     */
    CoreSite.prototype.getInfo = function () {
        return this.infos;
    };
    /**
     * Get site private token.
     *
     * @return {string} Site private token.
     */
    CoreSite.prototype.getPrivateToken = function () {
        return this.privateToken;
    };
    /**
     * Get site DB.
     *
     * @return {SQLiteDB} Site DB.
     */
    CoreSite.prototype.getDb = function () {
        return this.db;
    };
    /**
     * Get site user's ID.
     *
     * @return {number} User's ID.
     */
    CoreSite.prototype.getUserId = function () {
        if (typeof this.infos != 'undefined' && typeof this.infos.userid != 'undefined') {
            return this.infos.userid;
        }
    };
    /**
     * Get site Course ID for frontpage course. If not declared it will return 1 as default.
     *
     * @return {number} Site Home ID.
     */
    CoreSite.prototype.getSiteHomeId = function () {
        return this.infos && this.infos.siteid || 1;
    };
    /**
     * Set site ID.
     *
     * @param {string} New ID.
     */
    CoreSite.prototype.setId = function (id) {
        this.id = id;
        this.initDB();
    };
    /**
     * Set site token.
     *
     * @param {string} New token.
     */
    CoreSite.prototype.setToken = function (token) {
        this.token = token;
    };
    /**
     * Set site private token.
     *
     * @param {string} privateToken New private token.
     */
    CoreSite.prototype.setPrivateToken = function (privateToken) {
        this.privateToken = privateToken;
    };
    /**
     * Check if user logged out from the site and needs to authenticate again.
     *
     * @return {boolean} Whether is logged out.
     */
    CoreSite.prototype.isLoggedOut = function () {
        return !!this.loggedOut;
    };
    /**
     * Set site info.
     *
     * @param {any} New info.
     */
    CoreSite.prototype.setInfo = function (infos) {
        this.infos = infos;
    };
    /**
     * Set site config.
     *
     * @param {any} Config.
     */
    CoreSite.prototype.setConfig = function (config) {
        this.config = config;
    };
    /**
     * Set site logged out.
     *
     * @param {boolean} loggedOut True if logged out and needs to authenticate again, false otherwise.
     */
    CoreSite.prototype.setLoggedOut = function (loggedOut) {
        this.loggedOut = !!loggedOut;
    };
    /**
     * Can the user access their private files?
     *
     * @return {boolean} Whether can access my files.
     */
    CoreSite.prototype.canAccessMyFiles = function () {
        var infos = this.getInfo();
        return infos && (typeof infos.usercanmanageownfiles === 'undefined' || infos.usercanmanageownfiles);
    };
    /**
     * Can the user download files?
     *
     * @return {boolean} Whether can download files.
     */
    CoreSite.prototype.canDownloadFiles = function () {
        var infos = this.getInfo();
        return infos && infos.downloadfiles;
    };
    /**
     * Can the user use an advanced feature?
     *
     * @param {string} feature The name of the feature.
     * @param {boolean} [whenUndefined=true] The value to return when the parameter is undefined.
     * @return {boolean} Whether can use advanced feature.
     */
    CoreSite.prototype.canUseAdvancedFeature = function (feature, whenUndefined) {
        if (whenUndefined === void 0) { whenUndefined = true; }
        var infos = this.getInfo();
        var canUse = true;
        if (typeof infos.advancedfeatures === 'undefined') {
            canUse = whenUndefined;
        }
        else {
            for (var i in infos.advancedfeatures) {
                var item = infos.advancedfeatures[i];
                if (item.name === feature && parseInt(item.value, 10) === 0) {
                    canUse = false;
                }
            }
        }
        return canUse;
    };
    /**
     * Can the user upload files?
     *
     * @return {boolean} Whether can upload files.
     */
    CoreSite.prototype.canUploadFiles = function () {
        var infos = this.getInfo();
        return infos && infos.uploadfiles;
    };
    /**
     * Fetch site info from the Moodle site.
     *
     * @return {Promise<any>} A promise to be resolved when the site info is retrieved.
     */
    CoreSite.prototype.fetchSiteInfo = function () {
        // The get_site_info WS call won't be cached.
        var preSets = {
            getFromCache: false,
            saveToCache: false
        };
        // Reset clean Unicode to check if it's supported again.
        this.cleanUnicode = false;
        return this.read('core_webservice_get_site_info', {}, preSets);
    };
    /**
     * Read some data from the Moodle site using WS. Requests are cached by default.
     *
     * @param {string} method WS method to use.
     * @param {any} data Data to send to the WS.
     * @param {CoreSiteWSPreSets} [preSets] Extra options.
     * @return {Promise<any>} Promise resolved with the response, rejected with CoreWSError if it fails.
     */
    CoreSite.prototype.read = function (method, data, preSets) {
        preSets = preSets || {};
        if (typeof preSets.getFromCache == 'undefined') {
            preSets.getFromCache = true;
        }
        if (typeof preSets.saveToCache == 'undefined') {
            preSets.saveToCache = true;
        }
        return this.request(method, data, preSets);
    };
    /**
     * Sends some data to the Moodle site using WS. Requests are NOT cached by default.
     *
     * @param {string} method  WS method to use.
     * @param {any} data Data to send to the WS.
     * @param {CoreSiteWSPreSets} [preSets] Extra options.
     * @return {Promise<any>} Promise resolved with the response, rejected with CoreWSError if it fails.
     */
    CoreSite.prototype.write = function (method, data, preSets) {
        preSets = preSets || {};
        if (typeof preSets.getFromCache == 'undefined') {
            preSets.getFromCache = false;
        }
        if (typeof preSets.saveToCache == 'undefined') {
            preSets.saveToCache = false;
        }
        if (typeof preSets.emergencyCache == 'undefined') {
            preSets.emergencyCache = false;
        }
        return this.request(method, data, preSets);
    };
    /**
     * WS request to the site.
     *
     * @param {string} method The WebService method to be called.
     * @param {any} data Arguments to pass to the method.
     * @param {CoreSiteWSPreSets} preSets Extra options.
     * @param {boolean} [retrying] True if we're retrying the call for some reason. This is to prevent infinite loops.
     * @return {Promise<any>} Promise resolved with the response, rejected with CoreWSError if it fails.
     * @description
     *
     * Sends a webservice request to the site. This method will automatically add the
     * required parameters and pass it on to the low level API in CoreWSProvider.call().
     *
     * Caching is also implemented, when enabled this method will returned a cached version of the request if the
     * data hasn't expired.
     *
     * This method is smart which means that it will try to map the method to a compatibility one if need be, usually this
     * means that it will fallback on the 'local_mobile_' prefixed function if it is available and the non-prefixed is not.
     */
    CoreSite.prototype.request = function (method, data, preSets, retrying) {
        var _this = this;
        var initialToken = this.token;
        data = data || {};
        // Check if the method is available, use a prefixed version if possible.
        // We ignore this check when we do not have the site info, as the list of functions is not loaded yet.
        if (this.getInfo() && !this.wsAvailable(method, false)) {
            var compatibilityMethod = __WEBPACK_IMPORTED_MODULE_13__core_constants__["a" /* CoreConstants */].WS_PREFIX + method;
            if (this.wsAvailable(compatibilityMethod, false)) {
                this.logger.info("Using compatibility WS method '" + compatibilityMethod + "'");
                method = compatibilityMethod;
            }
            else {
                this.logger.error("WS function '" + method + "' is not available, even in compatibility mode.");
                return Promise.reject(this.utils.createFakeWSError('core.wsfunctionnotavailable', true));
            }
        }
        var wsPreSets = {
            wsToken: this.token,
            siteUrl: this.siteUrl,
            cleanUnicode: this.cleanUnicode,
            typeExpected: preSets.typeExpected,
            responseExpected: preSets.responseExpected
        };
        if (wsPreSets.cleanUnicode && this.textUtils.hasUnicodeData(data)) {
            // Data will be cleaned, notify the user.
            this.domUtils.showToast('core.unicodenotsupported', true, 3000);
        }
        else {
            // No need to clean data in this call.
            wsPreSets.cleanUnicode = false;
        }
        // Enable text filtering by default.
        data.moodlewssettingfilter = preSets.filter === false ? false : true;
        data.moodlewssettingfileurl = preSets.rewriteurls === false ? false : true;
        // Convert the values to string before starting the cache process.
        try {
            data = this.wsProvider.convertValuesToString(data, wsPreSets.cleanUnicode);
        }
        catch (e) {
            // Empty cleaned text found.
            return Promise.reject(this.utils.createFakeWSError('core.unicodenotsupportedcleanerror', true));
        }
        return this.getFromCache(method, data, preSets).catch(function () {
            // Do not pass those options to the core WS factory.
            return _this.wsProvider.call(method, data, wsPreSets).then(function (response) {
                if (preSets.saveToCache) {
                    _this.saveToCache(method, data, response, preSets);
                }
                // We pass back a clone of the original object, this may prevent errors if in the callback the object is modified.
                return _this.utils.clone(response);
            }).catch(function (error) {
                if (error.errorcode == 'invalidtoken' ||
                    (error.errorcode == 'accessexception' && error.message.indexOf('Invalid token - token expired') > -1)) {
                    if (initialToken !== _this.token && !retrying) {
                        // Token has changed, retry with the new token.
                        return _this.request(method, data, preSets, true);
                    }
                    else if (_this.appProvider.isSSOAuthenticationOngoing()) {
                        // There's an SSO authentication ongoing, wait for it to finish and try again.
                        return _this.appProvider.waitForSSOAuthentication().then(function () {
                            return _this.request(method, data, preSets, true);
                        });
                    }
                    // Session expired, trigger event.
                    _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_4__providers_events__["a" /* CoreEventsProvider */].SESSION_EXPIRED, {}, _this.id);
                    // Change error message. We'll try to get data from cache.
                    error.message = _this.translate.instant('core.lostconnection');
                }
                else if (error.errorcode === 'userdeleted') {
                    // User deleted, trigger event.
                    _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_4__providers_events__["a" /* CoreEventsProvider */].USER_DELETED, { params: data }, _this.id);
                    error.message = _this.translate.instant('core.userdeleted');
                    return Promise.reject(error);
                }
                else if (error.errorcode === 'forcepasswordchangenotice') {
                    // Password Change Forced, trigger event.
                    _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_4__providers_events__["a" /* CoreEventsProvider */].PASSWORD_CHANGE_FORCED, {}, _this.id);
                    error.message = _this.translate.instant('core.forcepasswordchangenotice');
                    return Promise.reject(error);
                }
                else if (error.errorcode === 'usernotfullysetup') {
                    // User not fully setup, trigger event.
                    _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_4__providers_events__["a" /* CoreEventsProvider */].USER_NOT_FULLY_SETUP, {}, _this.id);
                    error.message = _this.translate.instant('core.usernotfullysetup');
                    return Promise.reject(error);
                }
                else if (error.errorcode === 'sitepolicynotagreed') {
                    // Site policy not agreed, trigger event.
                    _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_4__providers_events__["a" /* CoreEventsProvider */].SITE_POLICY_NOT_AGREED, {}, _this.id);
                    error.message = _this.translate.instant('core.sitepolicynotagreederror');
                    return Promise.reject(error);
                }
                else if (error.errorcode === 'dmlwriteexception' && _this.textUtils.hasUnicodeData(data)) {
                    if (!_this.cleanUnicode) {
                        // Try again cleaning unicode.
                        _this.cleanUnicode = true;
                        return _this.request(method, data, preSets);
                    }
                    // This should not happen.
                    error.message = _this.translate.instant('core.unicodenotsupported');
                    return Promise.reject(error);
                }
                else if (typeof preSets.emergencyCache !== 'undefined' && !preSets.emergencyCache) {
                    _this.logger.debug("WS call '" + method + "' failed. Emergency cache is forbidden, rejecting.");
                    return Promise.reject(error);
                }
                _this.logger.debug("WS call '" + method + "' failed. Trying to use the emergency cache.");
                preSets.omitExpires = true;
                preSets.getFromCache = true;
                return _this.getFromCache(method, data, preSets, true).catch(function () {
                    return Promise.reject(error);
                });
            });
        });
    };
    /**
     * Check if a WS is available in this site.
     *
     * @param {string} method WS name.
     * @param {boolean} [checkPrefix=true] When true also checks with the compatibility prefix.
     * @return {boolean} Whether the WS is available.
     */
    CoreSite.prototype.wsAvailable = function (method, checkPrefix) {
        if (checkPrefix === void 0) { checkPrefix = true; }
        if (typeof this.infos == 'undefined') {
            return false;
        }
        for (var i = 0; i < this.infos.functions.length; i++) {
            var func = this.infos.functions[i];
            if (func.name == method) {
                return true;
            }
        }
        // Let's try again with the compatibility prefix.
        if (checkPrefix) {
            return this.wsAvailable(__WEBPACK_IMPORTED_MODULE_13__core_constants__["a" /* CoreConstants */].WS_PREFIX + method, false);
        }
        return false;
    };
    /**
     * Get cache ID.
     *
     * @param {string} method The WebService method.
     * @param {any} data Arguments to pass to the method.
     * @return {string} Cache ID.
     */
    CoreSite.prototype.getCacheId = function (method, data) {
        return __WEBPACK_IMPORTED_MODULE_15_ts_md5_dist_md5__["Md5"].hashAsciiStr(method + ':' + this.utils.sortAndStringify(data));
    };
    /**
     * Get a WS response from cache.
     *
     * @param {string} method The WebService method to be called.
     * @param {any} data Arguments to pass to the method.
     * @param {CoreSiteWSPreSets} preSets Extra options.
     * @param {boolean} emergency Whether it's an "emergency" cache call (WS call failed).
     * @return {Promise<any>} Promise resolved with the WS response.
     */
    CoreSite.prototype.getFromCache = function (method, data, preSets, emergency) {
        var _this = this;
        if (!this.db || !preSets.getFromCache) {
            return Promise.reject(null);
        }
        var id = this.getCacheId(method, data);
        var promise;
        if (preSets.getCacheUsingCacheKey || (emergency && preSets.getEmergencyCacheUsingCacheKey)) {
            promise = this.db.getRecords(this.WS_CACHE_TABLE, { key: preSets.cacheKey }).then(function (entries) {
                if (!entries.length) {
                    // Cache key not found, get by params sent.
                    return _this.db.getRecord(_this.WS_CACHE_TABLE, { id: id });
                }
                else if (entries.length > 1) {
                    // More than one entry found. Search the one with same ID as this call.
                    for (var i = 0, len = entries.length; i < len; i++) {
                        var entry = entries[i];
                        if (entry.id == id) {
                            return entry;
                        }
                    }
                }
                return entries[0];
            });
        }
        else {
            promise = this.db.getRecord(this.WS_CACHE_TABLE, { id: id });
        }
        return promise.then(function (entry) {
            var now = Date.now();
            preSets.omitExpires = preSets.omitExpires || !_this.appProvider.isOnline();
            if (!preSets.omitExpires) {
                if (now > entry.expirationTime) {
                    _this.logger.debug('Cached element found, but it is expired');
                    return Promise.reject(null);
                }
            }
            if (typeof entry != 'undefined' && typeof entry.data != 'undefined') {
                var expires = (entry.expirationTime - now) / 1000;
                _this.logger.info("Cached element found, id: " + id + " expires in " + expires + " seconds");
                return _this.textUtils.parseJSON(entry.data, {});
            }
            return Promise.reject(null);
        });
    };
    /**
     * Save a WS response to cache.
     *
     * @param {string} method The WebService method.
     * @param {any} data Arguments to pass to the method.
     * @param {any} response The WS response.
     * @param {CoreSiteWSPreSets} preSets Extra options.
     * @return {Promise<any>} Promise resolved when the response is saved.
     */
    CoreSite.prototype.saveToCache = function (method, data, response, preSets) {
        var _this = this;
        if (!this.db) {
            return Promise.reject(null);
        }
        var promise;
        if (preSets.uniqueCacheKey) {
            // Cache key must be unique, delete all entries with same cache key.
            promise = this.deleteFromCache(method, data, preSets, true).catch(function () {
                // Ignore errors.
            });
        }
        else {
            promise = Promise.resolve();
        }
        return promise.then(function () {
            var id = _this.getCacheId(method, data), entry = {
                id: id,
                data: JSON.stringify(response)
            };
            var cacheExpirationTime = __WEBPACK_IMPORTED_MODULE_14__configconstants__["a" /* CoreConfigConstants */].cache_expiration_time;
            cacheExpirationTime = isNaN(cacheExpirationTime) ? 300000 : cacheExpirationTime;
            entry.expirationTime = new Date().getTime() + cacheExpirationTime;
            if (preSets.cacheKey) {
                entry.key = preSets.cacheKey;
            }
            return _this.db.insertOrUpdateRecord(_this.WS_CACHE_TABLE, entry, { id: id });
        });
    };
    /**
     * Delete a WS cache entry or entries.
     *
     * @param {string} method The WebService method to be called.
     * @param {any} data Arguments to pass to the method.
     * @param {CoreSiteWSPreSets} preSets Extra options.
     * @param {boolean} [allCacheKey] True to delete all entries with the cache key, false to delete only by ID.
     * @return {Promise<any>} Promise resolved when the entries are deleted.
     */
    CoreSite.prototype.deleteFromCache = function (method, data, preSets, allCacheKey) {
        if (!this.db) {
            return Promise.reject(null);
        }
        var id = this.getCacheId(method, data);
        if (allCacheKey) {
            return this.db.deleteRecords(this.WS_CACHE_TABLE, { key: preSets.cacheKey });
        }
        return this.db.deleteRecords(this.WS_CACHE_TABLE, { id: id });
    };
    /*
     * Uploads a file using Cordova File API.
     *
     * @param {string} filePath File path.
     * @param {CoreWSFileUploadOptions} options File upload options.
     * @param {Function} [onProgress] Function to call on progress.
     * @return {Promise<any>} Promise resolved when uploaded.
     */
    CoreSite.prototype.uploadFile = function (filePath, options, onProgress) {
        if (!options.fileArea) {
            options.fileArea = 'draft';
        }
        return this.wsProvider.uploadFile(filePath, options, {
            siteUrl: this.siteUrl,
            wsToken: this.token
        }, onProgress);
    };
    /**
     * Invalidates all the cache entries.
     *
     * @return {Promise<any>} Promise resolved when the cache entries are invalidated.
     */
    CoreSite.prototype.invalidateWsCache = function () {
        if (!this.db) {
            return Promise.reject(null);
        }
        this.logger.debug('Invalidate all the cache for site: ' + this.id);
        return this.db.updateRecords(this.WS_CACHE_TABLE, { expirationTime: 0 });
    };
    /**
     * Invalidates all the cache entries with a certain key.
     *
     * @param {string} key Key to search.
     * @return {Promise<any>} Promise resolved when the cache entries are invalidated.
     */
    CoreSite.prototype.invalidateWsCacheForKey = function (key) {
        if (!this.db) {
            return Promise.reject(null);
        }
        if (!key) {
            return Promise.resolve();
        }
        this.logger.debug('Invalidate cache for key: ' + key);
        return this.db.updateRecords(this.WS_CACHE_TABLE, { expirationTime: 0 }, { key: key });
    };
    /**
     * Invalidates all the cache entries in an array of keys.
     *
     * @param {string[]} keys Keys to search.
     * @return {Promise<any>} Promise resolved when the cache entries are invalidated.
     */
    CoreSite.prototype.invalidateMultipleWsCacheForKey = function (keys) {
        var _this = this;
        if (!this.db) {
            return Promise.reject(null);
        }
        if (!keys || !keys.length) {
            return Promise.resolve();
        }
        var promises = [];
        this.logger.debug('Invalidating multiple cache keys');
        keys.forEach(function (key) {
            promises.push(_this.invalidateWsCacheForKey(key));
        });
        return Promise.all(promises);
    };
    /**
     * Invalidates all the cache entries whose key starts with a certain value.
     *
     * @param {string} key Key to search.
     * @return {Promise}    Promise resolved when the cache entries are invalidated.
     */
    CoreSite.prototype.invalidateWsCacheForKeyStartingWith = function (key) {
        if (!this.db) {
            return Promise.reject(null);
        }
        if (!key) {
            return Promise.resolve();
        }
        this.logger.debug('Invalidate cache for key starting with: ' + key);
        var sql = 'UPDATE ' + this.WS_CACHE_TABLE + ' SET expirationTime=0 WHERE key LIKE ?';
        return this.db.execute(sql, [key + '%']);
    };
    /**
     * Generic function for adding the wstoken to Moodle urls and for pointing to the correct script.
     * Uses CoreUtilsProvider.fixPluginfileURL, passing site's token.
     *
     * @param {string} url The url to be fixed.
     * @return {string} Fixed URL.
     */
    CoreSite.prototype.fixPluginfileURL = function (url) {
        return this.urlUtils.fixPluginfileURL(url, this.token);
    };
    /**
     * Deletes site's DB.
     *
     * @return {Promise<any>} Promise to be resolved when the DB is deleted.
     */
    CoreSite.prototype.deleteDB = function () {
        return this.dbProvider.deleteDB('Site-' + this.id);
    };
    /**
     * Deletes site's folder.
     *
     * @return {Promise<any>} Promise to be resolved when the DB is deleted.
     */
    CoreSite.prototype.deleteFolder = function () {
        if (this.fileProvider.isAvailable()) {
            var siteFolder = this.fileProvider.getSiteFolder(this.id);
            return this.fileProvider.removeDir(siteFolder).catch(function () {
                // Ignore any errors, $mmFS.removeDir fails if folder doesn't exists.
            });
        }
        else {
            return Promise.resolve();
        }
    };
    /**
     * Get space usage of the site.
     *
     * @return {Promise<number>} Promise resolved with the site space usage (size).
     */
    CoreSite.prototype.getSpaceUsage = function () {
        if (this.fileProvider.isAvailable()) {
            var siteFolderPath = this.fileProvider.getSiteFolder(this.id);
            return this.fileProvider.getDirectorySize(siteFolderPath).catch(function () {
                return 0;
            });
        }
        else {
            return Promise.resolve(0);
        }
    };
    /**
     * Returns the URL to the documentation of the app, based on Moodle version and current language.
     *
     * @param {string} [page] Docs page to go to.
     * @return {Promise<string>} Promise resolved with the Moodle docs URL.
     */
    CoreSite.prototype.getDocsUrl = function (page) {
        var release = this.infos.release ? this.infos.release : undefined;
        return this.urlUtils.getDocsUrl(release, page);
    };
    /**
     * Check if the local_mobile plugin is installed in the Moodle site.
     *
     * @param {boolean} [retrying] True if we're retrying the check.
     * @return {Promise<LocalMobileResponse>} Promise resolved when the check is done.
     */
    CoreSite.prototype.checkLocalMobilePlugin = function (retrying) {
        var _this = this;
        var checkUrl = this.siteUrl + '/local/mobile/check.php', service = __WEBPACK_IMPORTED_MODULE_14__configconstants__["a" /* CoreConfigConstants */].wsextservice;
        if (!service) {
            // External service not defined.
            return Promise.resolve({ code: 0 });
        }
        var promise = this.http.post(checkUrl, { service: service }).timeout(__WEBPACK_IMPORTED_MODULE_13__core_constants__["a" /* CoreConstants */].WS_TIMEOUT).toPromise();
        return promise.then(function (data) {
            if (typeof data != 'undefined' && data.errorcode === 'requirecorrectaccess') {
                if (!retrying) {
                    _this.siteUrl = _this.urlUtils.addOrRemoveWWW(_this.siteUrl);
                    return _this.checkLocalMobilePlugin(true);
                }
                else {
                    return Promise.reject(data.error);
                }
            }
            else if (typeof data == 'undefined' || typeof data.code == 'undefined') {
                // The local_mobile returned something we didn't expect. Let's assume it's not installed.
                return { code: 0, warning: 'core.login.localmobileunexpectedresponse' };
            }
            var code = parseInt(data.code, 10);
            if (data.error) {
                switch (code) {
                    case 1:
                        // Site in maintenance mode.
                        return Promise.reject(_this.translate.instant('core.login.siteinmaintenance'));
                    case 2:
                        // Web services not enabled.
                        return Promise.reject(_this.translate.instant('core.login.webservicesnotenabled'));
                    case 3:
                        // Extended service not enabled, but the official is enabled.
                        return { code: 0 };
                    case 4:
                        // Neither extended or official services enabled.
                        return Promise.reject(_this.translate.instant('core.login.mobileservicesnotenabled'));
                    default:
                        return Promise.reject(_this.translate.instant('core.unexpectederror'));
                }
            }
            else {
                return { code: code, service: service, coresupported: !!data.coresupported };
            }
        }, function () {
            return { code: 0 };
        });
    };
    /**
     * Check if local_mobile has been installed in Moodle.
     *
     * @return {boolean} Whether the App is able to use local_mobile plugin for this site.
     */
    CoreSite.prototype.checkIfAppUsesLocalMobile = function () {
        var appUsesLocalMobile = false;
        if (!this.infos || !this.infos.functions) {
            return appUsesLocalMobile;
        }
        this.infos.functions.forEach(function (func) {
            if (func.name.indexOf(__WEBPACK_IMPORTED_MODULE_13__core_constants__["a" /* CoreConstants */].WS_PREFIX) != -1) {
                appUsesLocalMobile = true;
            }
        });
        return appUsesLocalMobile;
    };
    /**
     * Check if local_mobile has been installed in Moodle but the app is not using it.
     *
     * @return {Promise<any>} Promise resolved it local_mobile was added, rejected otherwise.
     */
    CoreSite.prototype.checkIfLocalMobileInstalledAndNotUsed = function () {
        var appUsesLocalMobile = this.checkIfAppUsesLocalMobile();
        if (appUsesLocalMobile) {
            // App already uses local_mobile, it wasn't added.
            return Promise.reject(null);
        }
        return this.checkLocalMobilePlugin().then(function (data) {
            if (typeof data.service == 'undefined') {
                // The local_mobile NOT installed. Reject.
                return Promise.reject(null);
            }
            return data;
        });
    };
    /**
     * Check if a URL belongs to this site.
     *
     * @param {string} url URL to check.
     * @return {boolean} Whether the URL belongs to this site.
     */
    CoreSite.prototype.containsUrl = function (url) {
        if (!url) {
            return false;
        }
        var siteUrl = this.urlUtils.removeProtocolAndWWW(this.siteUrl);
        url = this.urlUtils.removeProtocolAndWWW(url);
        return url.indexOf(siteUrl) == 0;
    };
    /**
     * Get the public config of this site.
     *
     * @return {Promise<any>} Promise resolved with public config. Rejected with an object if error, see CoreWSProvider.callAjax.
     */
    CoreSite.prototype.getPublicConfig = function () {
        var _this = this;
        return this.wsProvider.callAjax('tool_mobile_get_public_config', {}, { siteUrl: this.siteUrl }).then(function (config) {
            // Use the wwwroot returned by the server.
            if (config.httpswwwroot) {
                _this.siteUrl = config.httpswwwroot;
            }
            return config;
        });
    };
    /**
     * Open a URL in browser using auto-login in the Moodle site if available.
     *
     * @param {string} url The URL to open.
     * @param {string} [alertMessage] If defined, an alert will be shown before opening the browser.
     * @return {Promise<any>} Promise resolved when done, rejected otherwise.
     */
    CoreSite.prototype.openInBrowserWithAutoLogin = function (url, alertMessage) {
        return this.openWithAutoLogin(false, url, undefined, alertMessage);
    };
    /**
     * Open a URL in browser using auto-login in the Moodle site if available and the URL belongs to the site.
     *
     * @param {string} url The URL to open.
     * @param {string} [alertMessage] If defined, an alert will be shown before opening the browser.
     * @return {Promise<any>} Promise resolved when done, rejected otherwise.
     */
    CoreSite.prototype.openInBrowserWithAutoLoginIfSameSite = function (url, alertMessage) {
        return this.openWithAutoLoginIfSameSite(false, url, undefined, alertMessage);
    };
    /**
     * Open a URL in inappbrowser using auto-login in the Moodle site if available.
     *
     * @param {string} url The URL to open.
     * @param {any} [options] Override default options passed to InAppBrowser.
     * @param {string} [alertMessage] If defined, an alert will be shown before opening the inappbrowser.
     * @return {Promise<InAppBrowserObject>} Promise resolved when done.
     */
    CoreSite.prototype.openInAppWithAutoLogin = function (url, options, alertMessage) {
        return this.openWithAutoLogin(true, url, options, alertMessage);
    };
    /**
     * Open a URL in inappbrowser using auto-login in the Moodle site if available and the URL belongs to the site.
     *
     * @param {string} url The URL to open.
     * @param {object} [options] Override default options passed to inappbrowser.
     * @param {string} [alertMessage] If defined, an alert will be shown before opening the inappbrowser.
     * @return {Promise<InAppBrowserObject>} Promise resolved when done.
     */
    CoreSite.prototype.openInAppWithAutoLoginIfSameSite = function (url, options, alertMessage) {
        return this.openWithAutoLoginIfSameSite(true, url, options, alertMessage);
    };
    /**
     * Open a URL in browser or InAppBrowser using auto-login in the Moodle site if available.
     *
     * @param {boolean} inApp True to open it in InAppBrowser, false to open in browser.
     * @param {string} url The URL to open.
     * @param {object} [options] Override default options passed to $cordovaInAppBrowser#open.
     * @param {string} [alertMessage] If defined, an alert will be shown before opening the browser/inappbrowser.
     * @return {Promise<InAppBrowserObject>} Promise resolved when done. Resolve param is returned only if inApp=true.
     */
    CoreSite.prototype.openWithAutoLogin = function (inApp, url, options, alertMessage) {
        var _this = this;
        // Convenience function to open the URL.
        var open = function (url) {
            return new Promise(function (resolve, reject) {
                if (modal) {
                    modal.dismiss();
                }
                if (alertMessage) {
                    var alert_1 = _this.domUtils.showAlert(_this.translate.instant('core.notice'), alertMessage, undefined, 3000);
                    alert_1.onDidDismiss(function () {
                        if (inApp) {
                            resolve(_this.utils.openInApp(url, options));
                        }
                        else {
                            resolve(_this.utils.openInBrowser(url));
                        }
                    });
                }
                else {
                    if (inApp) {
                        resolve(_this.utils.openInApp(url, options));
                    }
                    else {
                        resolve(_this.utils.openInBrowser(url));
                    }
                }
            });
        };
        if (!this.privateToken || !this.wsAvailable('tool_mobile_get_autologin_key') ||
            (this.lastAutoLogin && this.timeUtils.timestamp() - this.lastAutoLogin < __WEBPACK_IMPORTED_MODULE_13__core_constants__["a" /* CoreConstants */].SECONDS_MINUTE * 6)) {
            // No private token, WS not available or last auto-login was less than 6 minutes ago.
            // Open the final URL without auto-login.
            return Promise.resolve(open(url));
        }
        var userId = this.getUserId(), params = {
            privatetoken: this.privateToken
        }, modal = this.domUtils.showModalLoading();
        // Use write to not use cache.
        return this.write('tool_mobile_get_autologin_key', params).then(function (data) {
            if (!data.autologinurl || !data.key) {
                // Not valid data, open the final URL without auto-login.
                return open(url);
            }
            _this.lastAutoLogin = _this.timeUtils.timestamp();
            return open(data.autologinurl + '?userid=' + userId + '&key=' + data.key + '&urltogo=' + url);
        }).catch(function () {
            // Couldn't get autologin key, open the final URL without auto-login.
            return open(url);
        });
    };
    /**
     * Open a URL in browser or InAppBrowser using auto-login in the Moodle site if available and the URL belongs to the site.
     *
     * @param {boolean} inApp True to open it in InAppBrowser, false to open in browser.
     * @param {string} url The URL to open.
     * @param {object} [options] Override default options passed to inappbrowser.
     * @param {string} [alertMessage] If defined, an alert will be shown before opening the browser/inappbrowser.
     * @return {Promise<InAppBrowserObject>} Promise resolved when done. Resolve param is returned only if inApp=true.
     */
    CoreSite.prototype.openWithAutoLoginIfSameSite = function (inApp, url, options, alertMessage) {
        if (this.containsUrl(url)) {
            return this.openWithAutoLogin(inApp, url, options, alertMessage);
        }
        else {
            if (inApp) {
                this.utils.openInApp(url, options);
            }
            else {
                this.utils.openInBrowser(url);
            }
            return Promise.resolve(null);
        }
    };
    /**
     * Get the config of this site.
     * It is recommended to use getStoredConfig instead since it's faster and doesn't use network.
     *
     * @param {string} [name] Name of the setting to get. If not set or false, all settings will be returned.
     * @param {boolean} [ignoreCache] True if it should ignore cached data.
     * @return {Promise<any>} Promise resolved with site config.
     */
    CoreSite.prototype.getConfig = function (name, ignoreCache) {
        var preSets = {
            cacheKey: this.getConfigCacheKey()
        };
        if (ignoreCache) {
            preSets.getFromCache = false;
            preSets.emergencyCache = false;
        }
        return this.read('tool_mobile_get_config', {}, preSets).then(function (config) {
            if (name) {
                // Return the requested setting.
                for (var x in config.settings) {
                    if (config.settings[x].name == name) {
                        return config.settings[x].value;
                    }
                }
                return Promise.reject(null);
            }
            else {
                // Return all settings in the same array.
                var settings_1 = {};
                config.settings.forEach(function (setting) {
                    settings_1[setting.name] = setting.value;
                });
                return settings_1;
            }
        });
    };
    /**
     * Invalidates config WS call.
     *
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreSite.prototype.invalidateConfig = function () {
        return this.invalidateWsCacheForKey(this.getConfigCacheKey());
    };
    /**
     * Get cache key for getConfig WS calls.
     *
     * @return {string} Cache key.
     */
    CoreSite.prototype.getConfigCacheKey = function () {
        return 'tool_mobile_get_config';
    };
    /**
     * Get the stored config of this site.
     *
     * @param {string} [name] Name of the setting to get. If not set, all settings will be returned.
     * @return {any} Site config or a specific setting.
     */
    CoreSite.prototype.getStoredConfig = function (name) {
        if (!this.config) {
            return;
        }
        if (name) {
            return this.config[name];
        }
        else {
            return this.config;
        }
    };
    /**
     * Check if a certain feature is disabled in the site.
     *
     * @param {string} name Name of the feature to check.
     * @return {boolean} Whether it's disabled.
     */
    CoreSite.prototype.isFeatureDisabled = function (name) {
        var disabledFeatures = this.getStoredConfig('tool_mobile_disabledfeatures');
        if (!disabledFeatures) {
            return false;
        }
        var regEx = new RegExp('(,|^)' + this.textUtils.escapeForRegex(name) + '(,|$)', 'g');
        return !!disabledFeatures.match(regEx);
    };
    /**
     * Check if the site version is greater than one or several versions.
     * This function accepts a string or an array of strings. If array, the last version must be the highest.
     *
     * @param {string | string[]} versions Version or list of versions to check.
     * @return {boolean} Whether it's greater or equal, false otherwise.
     * @description
     * If a string is supplied (e.g. '3.2.1'), it will check if the site version is greater or equal than this version.
     *
     * If an array of versions is supplied, it will check if the site version is greater or equal than the last version,
     * or if it's higher or equal than any of the other releases supplied but lower than the next major release. The last
     * version of the array must be the highest version.
     * For example, if the values supplied are ['3.0.5', '3.2.3', '3.3.1'] the function will return true if the site version
     * is either:
     *     - Greater or equal than 3.3.1.
     *     - Greater or equal than 3.2.3 but lower than 3.3.
     *     - Greater or equal than 3.0.5 but lower than 3.1.
     *
     * This function only accepts versions from 2.4.0 and above. If any of the versions supplied isn't found, it will assume
     * it's the last released major version.
     */
    CoreSite.prototype.isVersionGreaterEqualThan = function (versions) {
        var siteVersion = parseInt(this.getInfo().version, 10);
        if (Array.isArray(versions)) {
            if (!versions.length) {
                return false;
            }
            for (var i = 0; i < versions.length; i++) {
                var versionNumber = this.getVersionNumber(versions[i]);
                if (i == versions.length - 1) {
                    // It's the last version, check only if site version is greater than this one.
                    return siteVersion >= versionNumber;
                }
                else {
                    // Check if site version if bigger than this number but lesser than next major.
                    if (siteVersion >= versionNumber && siteVersion < this.getNextMajorVersionNumber(versions[i])) {
                        return true;
                    }
                }
            }
        }
        else if (typeof versions == 'string') {
            // Compare with this version.
            return siteVersion >= this.getVersionNumber(versions);
        }
        return false;
    };
    /**
     * Get a version number from a release version.
     * If release version is valid but not found in the list of Moodle releases, it will use the last released major version.
     *
     * @param {string} version Release version to convert to version number.
     * @return {number} Version number, 0 if invalid.
     */
    CoreSite.prototype.getVersionNumber = function (version) {
        var data = this.getMajorAndMinor(version);
        if (!data) {
            // Invalid version.
            return 0;
        }
        if (typeof this.moodleReleases[data.major] == 'undefined') {
            // Major version not found. Use the last one.
            data.major = Object.keys(this.moodleReleases).slice(-1);
        }
        return this.moodleReleases[data.major] + data.minor;
    };
    /**
     * Given a release version, return the major and minor versions.
     *
     * @param {string} version Release version (e.g. '3.1.0').
     * @return {object} Object with major and minor. Returns false if invalid version.
     */
    CoreSite.prototype.getMajorAndMinor = function (version) {
        var match = version.match(/(\d)+(?:\.(\d)+)?(?:\.(\d)+)?/);
        if (!match || !match[1]) {
            // Invalid version.
            return false;
        }
        return {
            major: match[1] + '.' + (match[2] || '0'),
            minor: parseInt(match[3], 10) || 0
        };
    };
    /**
     * Given a release version, return the next major version number.
     *
     * @param {string} version Release version (e.g. '3.1.0').
     * @return {number} Next major version number.
     */
    CoreSite.prototype.getNextMajorVersionNumber = function (version) {
        var data = this.getMajorAndMinor(version), releases = Object.keys(this.moodleReleases);
        var position;
        if (!data) {
            // Invalid version.
            return 0;
        }
        position = releases.indexOf(data.major);
        if (position == -1 || position == releases.length - 1) {
            // Major version not found or it's the last one. Use the last one.
            return this.moodleReleases[releases[position]];
        }
        return this.moodleReleases[releases[position + 1]];
    };
    return CoreSite;
}());

//# sourceMappingURL=site.js.map

/***/ }),
/* 1036 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFormatTextDirective; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_filepool__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_text__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_url__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__directives_link__ = __webpack_require__(584);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__directives_external_content__ = __webpack_require__(583);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__core_contentlinks_providers_helper__ = __webpack_require__(45);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};














/**
 * Directive to format text rendered. It renders the HTML and treats all links and media, using CoreLinkDirective
 * and CoreExternalContentDirective.
 *
 * Example usage:
 * <core-format-text [text]="myText" [component]="component" [componentId]="componentId"></core-format-text>
 *
 */
var CoreFormatTextDirective = /** @class */ (function () {
    function CoreFormatTextDirective(element, sitesProvider, domUtils, textUtils, translate, platform, utils, urlUtils, loggerProvider, filepoolProvider, appProvider, contentLinksHelper, navCtrl, content) {
        this.sitesProvider = sitesProvider;
        this.domUtils = domUtils;
        this.textUtils = textUtils;
        this.translate = translate;
        this.platform = platform;
        this.utils = utils;
        this.urlUtils = urlUtils;
        this.loggerProvider = loggerProvider;
        this.filepoolProvider = filepoolProvider;
        this.appProvider = appProvider;
        this.contentLinksHelper = contentLinksHelper;
        this.navCtrl = navCtrl;
        this.content = content;
        this.adaptImg = true; // Whether to adapt images to screen width.
        this.tagsToIgnore = ['AUDIO', 'VIDEO', 'BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'A'];
        this.element = element.nativeElement;
        this.element.classList.add('opacity-hide'); // Hide contents until they're treated.
        this.afterRender = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
    }
    /**
     * Detect changes on input properties.
     */
    CoreFormatTextDirective.prototype.ngOnChanges = function (changes) {
        if (changes.text) {
            this.formatAndRenderContents();
        }
    };
    /**
     * Apply CoreExternalContentDirective to a certain element.
     *
     * @param {HTMLElement} element Element to add the attributes to.
     */
    CoreFormatTextDirective.prototype.addExternalContent = function (element) {
        // Angular 2 doesn't let adding directives dynamically. Create the CoreExternalContentDirective manually.
        var extContent = new __WEBPACK_IMPORTED_MODULE_12__directives_external_content__["a" /* CoreExternalContentDirective */](element, this.loggerProvider, this.filepoolProvider, this.platform, this.sitesProvider, this.domUtils, this.urlUtils, this.appProvider);
        extContent.component = this.component;
        extContent.componentId = this.componentId;
        extContent.siteId = this.siteId;
        extContent.ngAfterViewInit();
    };
    /**
     * Add class to adapt media to a certain element.
     *
     * @param {HTMLElement} element Element to add the class to.
     */
    CoreFormatTextDirective.prototype.addMediaAdaptClass = function (element) {
        element.classList.add('core-media-adapt-width');
    };
    /**
     * Wrap an image with a container to adapt its width and, if needed, add an anchor to view it in full size.
     *
     * @param {number} elWidth Width of the directive's element.
     * @param {HTMLElement} img Image to adapt.
     */
    CoreFormatTextDirective.prototype.adaptImage = function (elWidth, img) {
        var imgWidth = this.getElementWidth(img), 
        // Element to wrap the image.
        container = document.createElement('span');
        container.classList.add('core-adapted-img-container');
        container.style.cssFloat = img.style.cssFloat; // Copy the float to correctly position the search icon.
        if (img.classList.contains('atto_image_button_right')) {
            container.classList.add('atto_image_button_right');
        }
        else if (img.classList.contains('atto_image_button_left')) {
            container.classList.add('atto_image_button_left');
        }
        this.domUtils.wrapElement(img, container);
        if (imgWidth > elWidth) {
            // The image has been adapted, add an anchor to view it in full size.
            this.addMagnifyingGlass(container, img);
        }
    };
    /**
     * Add a magnifying glass icon to view an image at full size.
     *
     * @param {HTMLElement} container The container of the image.
     * @param {HTMLElement} img The image.
     */
    CoreFormatTextDirective.prototype.addMagnifyingGlass = function (container, img) {
        var _this = this;
        var imgSrc = this.textUtils.escapeHTML(img.getAttribute('src')), label = this.textUtils.escapeHTML(this.translate.instant('core.openfullimage')), anchor = document.createElement('a');
        anchor.classList.add('core-image-viewer-icon');
        anchor.setAttribute('aria-label', label);
        // Add an ion-icon item to apply the right styles, but the ion-icon component won't be executed.
        anchor.innerHTML = '<ion-icon name="search" class="icon icon-md ion-md-search"></ion-icon>';
        anchor.addEventListener('click', function (e) {
            e.preventDefault();
            e.stopPropagation();
            _this.domUtils.viewImage(imgSrc, img.getAttribute('alt'), _this.component, _this.componentId);
        });
        container.appendChild(anchor);
    };
    /**
     * Finish the rendering, displaying the element again and calling afterRender.
     */
    CoreFormatTextDirective.prototype.finishRender = function () {
        // Show the element again.
        this.element.classList.remove('opacity-hide');
        // Emit the afterRender output.
        this.afterRender.emit();
    };
    /**
     * Format contents and render.
     */
    CoreFormatTextDirective.prototype.formatAndRenderContents = function () {
        var _this = this;
        if (!this.text) {
            this.element.innerHTML = ''; // Remove current contents.
            this.finishRender();
            return;
        }
        this.text = this.text ? this.text.trim() : '';
        this.formatContents().then(function (div) {
            // Disable media adapt to correctly calculate the height.
            _this.element.classList.add('core-disable-media-adapt');
            _this.element.innerHTML = ''; // Remove current contents.
            if (_this.maxHeight && div.innerHTML != '') {
                // Move the children to the current element to be able to calculate the height.
                // @todo: Display the element?
                _this.domUtils.moveChildren(div, _this.element);
                // Height cannot be calculated if the element is not shown while calculating.
                // Force shorten if it was previously shortened.
                // @todo: Work on calculate this height better.
                var height = _this.element.style.maxHeight ? 0 : _this.getElementHeight(_this.element);
                // If cannot calculate height, shorten always.
                if (!height || height > _this.maxHeight) {
                    var expandInFullview_1 = _this.utils.isTrueOrOne(_this.fullOnClick) || false, showMoreDiv = document.createElement('div');
                    showMoreDiv.classList.add('core-show-more');
                    showMoreDiv.innerHTML = _this.translate.instant('core.showmore');
                    _this.element.appendChild(showMoreDiv);
                    if (expandInFullview_1) {
                        _this.element.classList.add('core-expand-in-fullview');
                    }
                    _this.element.classList.add('core-text-formatted');
                    _this.element.classList.add('core-shortened');
                    _this.element.style.maxHeight = _this.maxHeight + 'px';
                    _this.element.addEventListener('click', function (e) {
                        e.preventDefault();
                        e.stopPropagation();
                        var target = e.target;
                        if (_this.tagsToIgnore.indexOf(target.tagName) === -1 || (target.tagName === 'A' &&
                            !target.getAttribute('href'))) {
                            if (!expandInFullview_1) {
                                // Change class.
                                _this.element.classList.toggle('core-shortened');
                                return;
                            }
                        }
                        // Open a new state with the contents.
                        _this.textUtils.expandText(_this.fullTitle || _this.translate.instant('core.description'), _this.text, _this.component, _this.componentId);
                    });
                }
            }
            else {
                _this.domUtils.moveChildren(div, _this.element);
            }
            _this.element.classList.remove('core-disable-media-adapt');
            _this.finishRender();
        });
    };
    /**
     * Apply formatText and set sub-directives.
     *
     * @return {Promise<HTMLElement>} Promise resolved with a div element containing the code.
     */
    CoreFormatTextDirective.prototype.formatContents = function () {
        var _this = this;
        var site;
        // Retrieve the site since it might be needed later.
        return this.sitesProvider.getSite(this.siteId).catch(function () {
            // Error getting the site. This probably means that there is no current site and no siteId was supplied.
        }).then(function (siteInstance) {
            site = siteInstance;
            // Apply format text function.
            return _this.textUtils.formatText(_this.text, _this.utils.isTrueOrOne(_this.clean), _this.utils.isTrueOrOne(_this.singleLine));
        }).then(function (formatted) {
            var div = document.createElement('div'), canTreatVimeo = site && site.isVersionGreaterEqualThan(['3.3.4', '3.4']);
            var images, anchors, audios, videos, iframes, buttons;
            div.innerHTML = formatted;
            images = Array.from(div.querySelectorAll('img'));
            anchors = Array.from(div.querySelectorAll('a'));
            audios = Array.from(div.querySelectorAll('audio'));
            videos = Array.from(div.querySelectorAll('video'));
            iframes = Array.from(div.querySelectorAll('iframe'));
            buttons = Array.from(div.querySelectorAll('.button'));
            // Walk through the content to find the links and add our directive to it.
            // Important: We need to look for links first because in 'img' we add new links without core-link.
            anchors.forEach(function (anchor) {
                // Angular 2 doesn't let adding directives dynamically. Create the CoreLinkDirective manually.
                var linkDir = new __WEBPACK_IMPORTED_MODULE_11__directives_link__["a" /* CoreLinkDirective */](anchor, _this.domUtils, _this.utils, _this.sitesProvider, _this.urlUtils, _this.contentLinksHelper, _this.navCtrl, _this.content);
                linkDir.capture = true;
                linkDir.ngOnInit();
                _this.addExternalContent(anchor);
            });
            if (images && images.length > 0) {
                // If cannot calculate element's width, use a medium number to avoid false adapt image icons appearing.
                var elWidth_1 = _this.getElementWidth(_this.element) || 100;
                // Walk through the content to find images, and add our directive.
                images.forEach(function (img) {
                    _this.addMediaAdaptClass(img);
                    _this.addExternalContent(img);
                    if (_this.utils.isTrueOrOne(_this.adaptImg)) {
                        _this.adaptImage(elWidth_1, img);
                    }
                });
            }
            audios.forEach(function (audio) {
                _this.treatMedia(audio);
                if (_this.platform.is('ios')) {
                    // Set data-tap-disabled="true" to make slider work in iOS.
                    audio.setAttribute('data-tap-disabled', true);
                }
            });
            videos.forEach(function (video) {
                _this.treatVideoFilters(video);
                _this.treatMedia(video);
                // Set data-tap-disabled="true" to make controls work in Android (see MOBILE-1452).
                video.setAttribute('data-tap-disabled', true);
            });
            iframes.forEach(function (iframe) {
                _this.treatIframe(iframe, site, canTreatVimeo);
            });
            // Handle buttons with inner links.
            buttons.forEach(function (button) {
                // Check if it has a link inside.
                if (button.querySelector('a')) {
                    button.classList.add('core-button-with-inner-link');
                }
            });
            return div;
        });
    };
    /**
     * Returns the element width in pixels.
     *
     * @param {HTMLElement} element Element to get width from.
     * @return {number} The width of the element in pixels. When 0 is returned it means the element is not visible.
     */
    CoreFormatTextDirective.prototype.getElementWidth = function (element) {
        var width = this.domUtils.getElementWidth(element);
        if (!width) {
            // All elements inside are floating or inline. Change display mode to allow calculate the width.
            var parentWidth = this.domUtils.getElementWidth(element.parentNode, true, false, false, true), previousDisplay = getComputedStyle(element, null).display;
            element.style.display = 'inline-block';
            width = this.domUtils.getElementWidth(element);
            // If width is incorrectly calculated use parent width instead.
            if (parentWidth > 0 && (!width || width > parentWidth)) {
                width = parentWidth;
            }
            element.style.display = previousDisplay;
        }
        return width;
    };
    /**
     * Returns the element height in pixels.
     *
     * @param {HTMLElement} elementAng Element to get height from.
     * @return {number} The height of the element in pixels. When 0 is returned it means the element is not visible.
     */
    CoreFormatTextDirective.prototype.getElementHeight = function (element) {
        return this.domUtils.getElementHeight(element) || 0;
    };
    /**
     * Treat video filters. Currently only treating youtube video using video JS.
     *
     * @param {HTMLElement} el Video element.
     */
    CoreFormatTextDirective.prototype.treatVideoFilters = function (video) {
        // Treat Video JS Youtube video links and translate them to iframes.
        if (!video.classList.contains('video-js')) {
            return;
        }
        var data = this.textUtils.parseJSON(video.getAttribute('data-setup') || video.getAttribute('data-setup-lazy') || '{}'), youtubeId = data.techOrder && data.techOrder[0] && data.techOrder[0] == 'youtube' && data.sources && data.sources[0] &&
            data.sources[0].src && this.youtubeGetId(data.sources[0].src);
        if (!youtubeId) {
            return;
        }
        var iframe = document.createElement('iframe');
        iframe.id = video.id;
        iframe.src = 'https://www.youtube.com/embed/' + youtubeId;
        iframe.setAttribute('frameborder', '0');
        iframe.width = '100%';
        iframe.height = '300';
        // Replace video tag by the iframe.
        video.parentNode.replaceChild(iframe, video);
    };
    /**
     * Add media adapt class and apply CoreExternalContentDirective to the media element and its sources and tracks.
     *
     * @param {HTMLElement} element Video or audio to treat.
     */
    CoreFormatTextDirective.prototype.treatMedia = function (element) {
        var _this = this;
        this.addMediaAdaptClass(element);
        this.addExternalContent(element);
        var sources = Array.from(element.querySelectorAll('source')), tracks = Array.from(element.querySelectorAll('track'));
        sources.forEach(function (source) {
            source.setAttribute('target-src', source.getAttribute('src'));
            source.removeAttribute('src');
            _this.addExternalContent(source);
        });
        tracks.forEach(function (track) {
            _this.addExternalContent(track);
        });
    };
    /**
     * Add media adapt class and treat the iframe source.
     *
     * @param {HTMLIFrameElement} iframe Iframe to treat.
     * @param {CoreSite} site Site instance.
     * @param  {Boolean} canTreatVimeo Whether Vimeo videos can be treated in the site.
     */
    CoreFormatTextDirective.prototype.treatIframe = function (iframe, site, canTreatVimeo) {
        this.addMediaAdaptClass(iframe);
        if (iframe.src && canTreatVimeo) {
            // Check if it's a Vimeo video. If it is, use the wsplayer script instead to make restricted videos work.
            var matches = iframe.src.match(/https?:\/\/player\.vimeo\.com\/video\/([^\/]*)/);
            if (matches && matches[1]) {
                var newUrl = this.textUtils.concatenatePaths(site.getURL(), '/media/player/vimeo/wsplayer.php?video=') +
                    matches[1] + '&token=' + site.getToken();
                if (iframe.width) {
                    newUrl = newUrl + '&width=' + iframe.width;
                }
                if (iframe.height) {
                    newUrl = newUrl + '&height=' + iframe.height;
                }
                iframe.src = newUrl;
            }
        }
    };
    /**
     * Convenience function to extract YouTube Id to translate to embedded video.
     * Based on http://stackoverflow.com/questions/3452546/javascript-regex-how-to-get-youtube-video-id-from-url
     *
     * @param {string} url URL of the video.
     */
    CoreFormatTextDirective.prototype.youtubeGetId = function (url) {
        var regExp = /^.*(?:(?:youtu.be\/)|(?:v\/)|(?:\/u\/\w\/)|(?:embed\/)|(?:watch\?))\??v?=?([^#\&\?]*).*/, match = url.match(regExp);
        return (match && match[1].length == 11) ? match[1] : '';
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreFormatTextDirective.prototype, "text", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreFormatTextDirective.prototype, "siteId", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreFormatTextDirective.prototype, "component", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreFormatTextDirective.prototype, "componentId", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreFormatTextDirective.prototype, "adaptImg", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreFormatTextDirective.prototype, "clean", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreFormatTextDirective.prototype, "singleLine", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreFormatTextDirective.prototype, "maxHeight", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreFormatTextDirective.prototype, "fullOnClick", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreFormatTextDirective.prototype, "fullTitle", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreFormatTextDirective.prototype, "afterRender", void 0);
    CoreFormatTextDirective = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["s" /* Directive */])({
            selector: 'core-format-text'
        }),
        __param(12, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["N" /* Optional */])()),
        __param(13, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["N" /* Optional */])()),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_6__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_7__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_8__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */],
            __WEBPACK_IMPORTED_MODULE_10__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_9__providers_utils_url__["a" /* CoreUrlUtilsProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_logger__["a" /* CoreLoggerProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_filepool__["a" /* CoreFilepoolProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_13__core_contentlinks_providers_helper__["a" /* CoreContentLinksHelperProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavController */],
            __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["e" /* Content */]])
    ], CoreFormatTextDirective);
    return CoreFormatTextDirective;
}());

//# sourceMappingURL=format-text.js.map

/***/ }),
/* 1037 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreKeepKeyboardDirective; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__ = __webpack_require__(9);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Directive to keep the keyboard open when clicking a certain element (usually a button).
 *
 * @description
 *
 * This directive needs to be applied to an input or textarea. The value of the directive needs to be a selector
 * to identify the element to listen for clicks (usually a button).
 *
 * When that element is clicked, the input that has this directive will keep the focus if it has it already and the keyboard
 * won't be closed.
 *
 * Example usage:
 *
 * <textarea [core-keep-keyboard]="'#mma-messages-send-message-button'"></textarea>
 * <button id="mma-messages-send-message-button">Send</button>
 *
 * Alternatively, this directive can be applied to the button. The value of the directive needs to be a selector to identify
 * the input element. In this case, you need to set [inButton]="true".
 *
 * Example usage:
 *
 * <textarea id="send-message-input"></textarea>
 * <button [core-keep-keyboard]="'#send-message-input'" [inButton]="true">Send</button>
 */
var CoreKeepKeyboardDirective = /** @class */ (function () {
    function CoreKeepKeyboardDirective(element, domUtils, utils) {
        this.domUtils = domUtils;
        this.utils = utils;
        this.lastFocusOut = 0; // Last time the input was focused out.
        this.element = element.nativeElement;
    }
    /**
     * View has been initialized.
     */
    CoreKeepKeyboardDirective.prototype.ngAfterViewInit = function () {
        var _this = this;
        // Use a setTimeout because to make sure that child components have been treated.
        setTimeout(function () {
            var inButton = _this.utils.isTrueOrOne(_this.inButton);
            var candidateEls, selectedEl;
            if (typeof _this.selector != 'string' || !_this.selector) {
                // Not a valid selector, stop.
                return;
            }
            // Get the selected element. Get the last one found.
            candidateEls = document.querySelectorAll(_this.selector);
            selectedEl = candidateEls[candidateEls.length - 1];
            if (!selectedEl) {
                // Element not found.
                return;
            }
            if (inButton) {
                // The directive is applied to the button.
                _this.button = _this.element;
                _this.input = selectedEl;
            }
            else {
                // The directive is applied to the input.
                _this.button = selectedEl;
                if (_this.element.tagName == 'ION-INPUT') {
                    // Search the inner input.
                    _this.input = _this.element.querySelector('input');
                }
                else if (_this.element.tagName == 'ION-TEXTAREA') {
                    // Search the inner textarea.
                    _this.input = _this.element.querySelector('textarea');
                }
                else {
                    _this.input = _this.element;
                }
                if (!_this.input) {
                    // Input not found, stop.
                    return;
                }
            }
            // Listen for focusout event. This is to be able to check if previous focus was on this element.
            _this.focusOutListener = _this.focusOut.bind(_this);
            _this.input.addEventListener('focusout', _this.focusOutListener);
            // Listen for clicks in the button.
            _this.clickListener = _this.buttonClicked.bind(_this);
            _this.button.addEventListener('click', _this.clickListener);
        });
    };
    /**
     * Component destroyed.
     */
    CoreKeepKeyboardDirective.prototype.ngOnDestroy = function () {
        if (this.button && this.clickListener) {
            this.button.removeEventListener('click', this.clickListener);
        }
        if (this.input && this.focusOutListener) {
            this.input.removeEventListener('focusout', this.focusOutListener);
        }
    };
    /**
     * The button we're interested in was clicked.
     */
    CoreKeepKeyboardDirective.prototype.buttonClicked = function () {
        if (document.activeElement == this.input) {
            // Directive's element is focused at the time the button is clicked. Listen for focusout to focus it again.
            this.focusAgainListener = this.focusElementAgain.bind(this);
            this.input.addEventListener('focusout', this.focusAgainListener);
        }
        else if (document.activeElement == this.button && Date.now() - this.lastFocusOut < 200) {
            // Last focused element was the directive's element, focus it again.
            setTimeout(this.focusElementAgain.bind(this), 0);
        }
    };
    /**
     * If keyboard is open, focus the input again and stop listening focusout to focus again if needed.
     */
    CoreKeepKeyboardDirective.prototype.focusElementAgain = function () {
        var _this = this;
        this.domUtils.focusElement(this.input);
        if (this.focusAgainListener) {
            // Sometimes we can receive more than 1 focus out event.
            // If we spend 1 second without receiving any, stop listening for them.
            var listener_1 = this.focusAgainListener; // Store it in a local variable, in case it changes.
            clearTimeout(this.stopFocusAgainTimeout);
            this.stopFocusAgainTimeout = setTimeout(function () {
                _this.input.removeEventListener('focusout', listener_1);
                if (listener_1 == _this.focusAgainListener) {
                    delete _this.focusAgainListener;
                }
            }, 1000);
        }
    };
    /**
     * Input was focused out, save the time it was done.
     */
    CoreKeepKeyboardDirective.prototype.focusOut = function () {
        this.lastFocusOut = Date.now();
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])('core-keep-keyboard'),
        __metadata("design:type", String)
    ], CoreKeepKeyboardDirective.prototype, "selector", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreKeepKeyboardDirective.prototype, "inButton", void 0);
    CoreKeepKeyboardDirective = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["s" /* Directive */])({
            selector: '[core-keep-keyboard]'
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_1__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], CoreKeepKeyboardDirective);
    return CoreKeepKeyboardDirective;
}());

//# sourceMappingURL=keep-keyboard.js.map

/***/ }),
/* 1038 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreUserLinkDirective; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};


/**
 * Directive to go to user profile on click.
 */
var CoreUserLinkDirective = /** @class */ (function () {
    function CoreUserLinkDirective(element, navCtrl) {
        this.navCtrl = navCtrl;
        // This directive can be added dynamically. In that case, the first param is the anchor HTMLElement.
        this.element = element.nativeElement || element;
    }
    /**
     * Function executed when the component is initialized.
     */
    CoreUserLinkDirective.prototype.ngOnInit = function () {
        var _this = this;
        this.element.addEventListener('click', function (event) {
            // If the event prevented default action, do nothing.
            if (!event.defaultPrevented) {
                event.preventDefault();
                event.stopPropagation();
                _this.navCtrl.push('CoreUserProfilePage', { userId: _this.userId, courseId: _this.courseId });
            }
        });
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreUserLinkDirective.prototype, "userId", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreUserLinkDirective.prototype, "courseId", void 0);
    CoreUserLinkDirective = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["s" /* Directive */])({
            selector: '[core-user-link]'
        }),
        __param(1, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["N" /* Optional */])()),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavController */]])
    ], CoreUserLinkDirective);
    return CoreUserLinkDirective;
}());

//# sourceMappingURL=user-link.js.map

/***/ }),
/* 1039 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreAutoRowsDirective; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

/**
 * Directive to adapt a textarea rows depending on the input text. It's based on Moodle's data-auto-rows.
 *
 * @description
 * Usage:
 * <textarea class="core-textarea" [(ngModel)]="message" rows="1" core-auto-rows></textarea>
 */
var CoreAutoRowsDirective = /** @class */ (function () {
    function CoreAutoRowsDirective(element) {
        this.height = 0;
        this.element = element.nativeElement || element;
        this.height = this.element.scrollHeight;
        this.onResize = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
    }
    CoreAutoRowsDirective.prototype.onInput = function () {
        this.resize();
    };
    CoreAutoRowsDirective.prototype.onChange = function () {
        var _this = this;
        // Fired on reset. Wait to the change to be finished.
        setTimeout(function () {
            _this.resize();
        }, 300);
    };
    /**
     * Resize after init.
     */
    CoreAutoRowsDirective.prototype.ngAfterViewInit = function () {
        this.resize();
    };
    /**
     * Resize the textarea.
     * @param {any} $event Event fired.
     */
    CoreAutoRowsDirective.prototype.resize = function ($event) {
        // Set height to 1px to force scroll height to calculate correctly.
        this.element.style.height = '1px';
        this.element.style.height = this.element.scrollHeight + 'px';
        // Emit event when resizing.
        if (this.height != this.element.scrollHeight) {
            this.height = this.element.scrollHeight;
            this.onResize.emit();
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreAutoRowsDirective.prototype, "onResize", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["y" /* HostListener */])('input'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], CoreAutoRowsDirective.prototype, "onInput", null);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["y" /* HostListener */])('change'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], CoreAutoRowsDirective.prototype, "onChange", null);
    CoreAutoRowsDirective = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["s" /* Directive */])({
            selector: 'textarea[core-auto-rows]'
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */]])
    ], CoreAutoRowsDirective);
    return CoreAutoRowsDirective;
}());

//# sourceMappingURL=auto-rows.js.map

/***/ }),
/* 1040 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreLongPressDirective; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular_gestures_gesture__ = __webpack_require__(585);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
// Based on http://roblouie.com/article/198/using-gestures-in-the-ionic-2-beta/


/**
 * Directive to add long press actions to html elements.
 */
var CoreLongPressDirective = /** @class */ (function () {
    function CoreLongPressDirective(el) {
        this.longPress = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
        this.el = el.nativeElement;
        this.el.setAttribute('tappable', '');
    }
    /**
     * Initialize gesture listening.
     */
    CoreLongPressDirective.prototype.ngOnInit = function () {
        var _this = this;
        this.pressGesture = new __WEBPACK_IMPORTED_MODULE_1_ionic_angular_gestures_gesture__["a" /* Gesture */](this.el);
        this.pressGesture.listen();
        this.pressGesture.on('press', function (e) {
            _this.longPress.emit(e);
        });
    };
    /**
     * Destroy gesture listening.
     */
    CoreLongPressDirective.prototype.ngOnDestroy = function () {
        this.pressGesture.destroy();
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", Object)
    ], CoreLongPressDirective.prototype, "longPress", void 0);
    CoreLongPressDirective = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["s" /* Directive */])({
            selector: '[longPress]'
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */]])
    ], CoreLongPressDirective);
    return CoreLongPressDirective;
}());

//# sourceMappingURL=long-press.js.map

/***/ }),
/* 1041 */,
/* 1042 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreBytesToSizePipe; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_text__ = __webpack_require__(13);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Pipe to turn a number in bytes to a human readable size (e.g. 5,25 MB).
 */
var CoreBytesToSizePipe = /** @class */ (function () {
    function CoreBytesToSizePipe(logger, textUtils) {
        this.textUtils = textUtils;
        this.logger = logger.getInstance('CoreBytesToSizePipe');
    }
    /**
     * Takes a number and turns it to a human readable size.
     *
     * @param {number|string} value The bytes to convert.
     * @return {string} Readable bytes.
     */
    CoreBytesToSizePipe.prototype.transform = function (value) {
        if (typeof value == 'string') {
            // Convert the value to a number.
            var numberValue = parseInt(value, 10);
            if (isNaN(numberValue)) {
                this.logger.error('Invalid value received', value);
                return value;
            }
            value = numberValue;
        }
        return this.textUtils.bytesToSize(value);
    };
    CoreBytesToSizePipe = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["S" /* Pipe */])({
            name: 'coreBytesToSize',
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_text__["a" /* CoreTextUtilsProvider */]])
    ], CoreBytesToSizePipe);
    return CoreBytesToSizePipe;
}());

//# sourceMappingURL=bytes-to-size.js.map

/***/ }),
/* 1043 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCreateLinksPipe; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

/**
 * Pipe to search URLs that are not inside <a> tags and add the corresponding <a> tags.
 */
var CoreCreateLinksPipe = /** @class */ (function () {
    function CoreCreateLinksPipe() {
        this.replacePattern = /(\b(https?|ftp):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])(?![^<]*>|[^<>]*<\/)/gim;
    }
    /**
     * Takes some text and adds anchor tags to all links that aren't inside anchors.
     *
     * @param {string} text Text to treat.
     * @return {string} Treated text.
     */
    CoreCreateLinksPipe.prototype.transform = function (text) {
        return text.replace(this.replacePattern, '<a href="$1">$1</a>');
    };
    CoreCreateLinksPipe = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["S" /* Pipe */])({
            name: 'coreCreateLinks',
        })
    ], CoreCreateLinksPipe);
    return CoreCreateLinksPipe;
}());

//# sourceMappingURL=create-links.js.map

/***/ }),
/* 1044 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreDateDayOrTimePipe; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_moment__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_moment__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Filter to display a date using the day, or the time.
 *
 * This shows a short version of a date. Use this filter when you want
 * the user to visualise when the action was done relatively to today's date.
 *
 * For instance, if the action happened during this day it will display the time,
 * but when the action happened few days ago, it will display the day of the week.
 *
 * The older the date is, the more information about it will be displayed.
 *
 * This filter expects a timestamp NOT including milliseconds.
 */
var CoreDateDayOrTimePipe = /** @class */ (function () {
    function CoreDateDayOrTimePipe(logger, translate) {
        this.translate = translate;
        this.logger = logger.getInstance('CoreDateDayOrTimePipe');
    }
    /**
     * Format a timestamp.
     *
     * @param {number|string} timestamp The UNIX timestamp (without milliseconds).
     * @return {string} Formatted time.
     */
    CoreDateDayOrTimePipe.prototype.transform = function (timestamp) {
        if (typeof timestamp == 'string') {
            // Convert the value to a number.
            var numberTimestamp = parseInt(timestamp, 10);
            if (isNaN(numberTimestamp)) {
                this.logger.error('Invalid value received', timestamp);
                return timestamp;
            }
            timestamp = numberTimestamp;
        }
        return __WEBPACK_IMPORTED_MODULE_3_moment__(timestamp * 1000).calendar(null, {
            sameDay: 'LT',
            lastDay: this.translate.instant('core.dflastweekdate'),
            lastWeek: this.translate.instant('core.dflastweekdate'),
            sameElse: 'L'
        });
    };
    CoreDateDayOrTimePipe = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["S" /* Pipe */])({
            name: 'coreDateDayOrTime',
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
    ], CoreDateDayOrTimePipe);
    return CoreDateDayOrTimePipe;
}());

//# sourceMappingURL=date-day-or-time.js.map

/***/ }),
/* 1045 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreDurationPipe; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_moment__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_moment__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Filter to turn a number of seconds to a duration. E.g. 60 -> 1 minute.
 */
var CoreDurationPipe = /** @class */ (function () {
    function CoreDurationPipe(logger) {
        this.logger = logger.getInstance('CoreBytesToSizePipe');
    }
    /**
     * Turn a number of seconds to a duration. E.g. 60 -> 1 minute.
     *
     * @param {number|string} seconds The number of seconds.
     * @return {string} Formatted duration.
     */
    CoreDurationPipe.prototype.transform = function (seconds) {
        if (typeof seconds == 'string') {
            // Convert the value to a number.
            var numberSeconds = parseInt(seconds, 10);
            if (isNaN(numberSeconds)) {
                this.logger.error('Invalid value received', seconds);
                return seconds;
            }
            seconds = numberSeconds;
        }
        return __WEBPACK_IMPORTED_MODULE_2_moment__["duration"](seconds * 1000).humanize();
    };
    CoreDurationPipe = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["S" /* Pipe */])({
            name: 'coreDuration',
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */]])
    ], CoreDurationPipe);
    return CoreDurationPipe;
}());

//# sourceMappingURL=duration.js.map

/***/ }),
/* 1046 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFormatDatePipe; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_moment__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_moment__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Filter to format a date.
 */
var CoreFormatDatePipe = /** @class */ (function () {
    function CoreFormatDatePipe(logger, translate) {
        this.translate = translate;
        this.logger = logger.getInstance('CoreDateDayOrTimePipe');
    }
    /**
     * Format a date.
     *
     * @param {string|number} timestamp Timestamp to format (in milliseconds). If not defined, use current time.
     * @param {string} format Format to use. It should be a string code to handle i18n (e.g. core.dftimedate). If the code
     *                        doesn't have a prefix, 'core' will be used by default. E.g. 'dftimedate' -> 'core.dftimedate'.
     * @return {string} Formatted date.
     */
    CoreFormatDatePipe.prototype.transform = function (timestamp, format) {
        timestamp = timestamp || Date.now();
        if (typeof timestamp == 'string') {
            // Convert the value to a number.
            var numberTimestamp = parseInt(timestamp, 10);
            if (isNaN(numberTimestamp)) {
                this.logger.error('Invalid value received', timestamp);
                return timestamp;
            }
            timestamp = numberTimestamp;
        }
        if (format.indexOf('df') == 0) {
            format = this.translate.instant('core.' + format);
        }
        else if (format.indexOf('.') > 0) {
            format = this.translate.instant(format);
        }
        return __WEBPACK_IMPORTED_MODULE_3_moment__(timestamp).format(format);
    };
    CoreFormatDatePipe = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["S" /* Pipe */])({
            name: 'coreFormatDate',
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
    ], CoreFormatDatePipe);
    return CoreFormatDatePipe;
}());

//# sourceMappingURL=format-date.js.map

/***/ }),
/* 1047 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreNoTagsPipe; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

/**
 * Pipe to remove HTML tags.
 */
var CoreNoTagsPipe = /** @class */ (function () {
    function CoreNoTagsPipe() {
    }
    /**
     * Takes a text and removes HTML tags.
     *
     * @param {string} text The text to treat.
     * @return {string} Treated text.
     */
    CoreNoTagsPipe.prototype.transform = function (text) {
        return text.replace(/(<([^>]+)>)/ig, '');
    };
    CoreNoTagsPipe = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["S" /* Pipe */])({
            name: 'coreNoTags',
        })
    ], CoreNoTagsPipe);
    return CoreNoTagsPipe;
}());

//# sourceMappingURL=no-tags.js.map

/***/ }),
/* 1048 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSecondsToHMSPipe; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_text__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_constants__ = __webpack_require__(22);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Pipe to convert a number of seconds to Hours:Minutes:Seconds.
 *
 * This converts a number of seconds to Hours:Minutes:Seconds. If the number of seconds is negative, returns 00:00:00.
 */
var CoreSecondsToHMSPipe = /** @class */ (function () {
    function CoreSecondsToHMSPipe(logger, textUtils) {
        this.textUtils = textUtils;
        this.logger = logger.getInstance('CoreSecondsToHMSPipe');
    }
    /**
     * Convert a number of seconds to Hours:Minutes:Seconds.
     *
     * @param {number|string} seconds Number of seconds.
     * @return {string} Formatted seconds.
     */
    CoreSecondsToHMSPipe.prototype.transform = function (seconds) {
        var hours, minutes;
        if (!seconds || seconds < 0) {
            seconds = 0;
        }
        else if (typeof seconds == 'string') {
            // Convert the value to a number.
            var numberSeconds = parseInt(seconds, 10);
            if (isNaN(numberSeconds)) {
                this.logger.error('Invalid value received', seconds);
                return seconds;
            }
            seconds = numberSeconds;
        }
        // Don't allow decimals.
        seconds = Math.floor(seconds);
        hours = Math.floor(seconds / __WEBPACK_IMPORTED_MODULE_3__core_constants__["a" /* CoreConstants */].SECONDS_HOUR);
        seconds -= hours * __WEBPACK_IMPORTED_MODULE_3__core_constants__["a" /* CoreConstants */].SECONDS_HOUR;
        minutes = Math.floor(seconds / __WEBPACK_IMPORTED_MODULE_3__core_constants__["a" /* CoreConstants */].SECONDS_MINUTE);
        seconds -= minutes * __WEBPACK_IMPORTED_MODULE_3__core_constants__["a" /* CoreConstants */].SECONDS_MINUTE;
        return this.textUtils.twoDigits(hours) + ':' + this.textUtils.twoDigits(minutes) + ':' + this.textUtils.twoDigits(seconds);
    };
    CoreSecondsToHMSPipe = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["S" /* Pipe */])({
            name: 'coreSecondsToHMS',
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_text__["a" /* CoreTextUtilsProvider */]])
    ], CoreSecondsToHMSPipe);
    return CoreSecondsToHMSPipe;
}());

//# sourceMappingURL=seconds-to-hms.js.map

/***/ }),
/* 1049 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreTimeAgoPipe; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_moment__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_moment__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Pipe to turn a UNIX timestamp to "time ago".
 */
var CoreTimeAgoPipe = /** @class */ (function () {
    function CoreTimeAgoPipe(logger) {
        this.logger = logger.getInstance('CoreTimeAgoPipe');
    }
    /**
     * Turn a UNIX timestamp to "time ago".
     *
     * @param {number|string} timestamp The UNIX timestamp (without milliseconds).
     * @return {string} Formatted time.
     */
    CoreTimeAgoPipe.prototype.transform = function (timestamp) {
        if (typeof timestamp == 'string') {
            // Convert the value to a number.
            var numberTimestamp = parseInt(timestamp, 10);
            if (isNaN(numberTimestamp)) {
                this.logger.error('Invalid value received', timestamp);
                return timestamp;
            }
            timestamp = numberTimestamp;
        }
        return __WEBPACK_IMPORTED_MODULE_2_moment__(timestamp * 1000).fromNow(true);
    };
    CoreTimeAgoPipe = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["S" /* Pipe */])({
            name: 'coreTimeAgo',
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */]])
    ], CoreTimeAgoPipe);
    return CoreTimeAgoPipe;
}());

//# sourceMappingURL=time-ago.js.map

/***/ }),
/* 1050 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreToLocaleStringPipe; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger__ = __webpack_require__(5);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Filter to format a timestamp to a locale string. Timestamp can be in seconds or milliseconds.
 */
var CoreToLocaleStringPipe = /** @class */ (function () {
    function CoreToLocaleStringPipe(logger) {
        this.logger = logger.getInstance('CoreToLocaleStringPipe');
    }
    /**
     * Format a timestamp to a locale string.
     *
     * @param {number|string} timestamp The timestamp (can be in seconds or milliseconds).
     * @return {string} Formatted time.
     */
    CoreToLocaleStringPipe.prototype.transform = function (timestamp) {
        if (typeof timestamp == 'string') {
            // Convert the value to a number.
            var numberTimestamp = parseInt(timestamp, 10);
            if (isNaN(numberTimestamp)) {
                this.logger.error('Invalid value received', timestamp);
                return timestamp;
            }
            timestamp = numberTimestamp;
        }
        if (timestamp < 0) {
            // Date not valid.
            return '';
        }
        if (timestamp < 100000000000) {
            // Timestamp is in seconds, convert it to milliseconds.
            timestamp = timestamp * 1000;
        }
        return new Date(timestamp).toLocaleString();
    };
    CoreToLocaleStringPipe = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["S" /* Pipe */])({
            name: 'coreToLocaleString',
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger__["a" /* CoreLoggerProvider */]])
    ], CoreToLocaleStringPipe);
    return CoreToLocaleStringPipe;
}());

//# sourceMappingURL=to-locale-string.js.map

/***/ }),
/* 1051 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreLoadingComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__classes_animations__ = __webpack_require__(720);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Component to show a loading spinner and message while data is being loaded.
 *
 * It will show a spinner with a message and hide all the content until 'dataLoaded' variable is set to true.
 * If 'message' and 'dynMessage' attributes aren't set, default message "Loading" is shown.
 * 'message' attribute accepts hardcoded strings, variables, filters, etc. E.g. message="'core.loading' | translate".
 *
 * Usage:
 * <core-loading [message]="loadingMessage" [hideUntil]="dataLoaded">
 *     <!-- CONTENT TO HIDE UNTIL LOADED -->
 * </core-loading>
 *
 * IMPORTANT: Due to how ng-content works in Angular, the content of core-loading will be executed as soon as your view
 * is loaded, even if the content hidden. So if you have the following code:
 * <core-loading [hideUntil]="dataLoaded"><my-component></my-component></core-loading>
 *
 * The component "my-component" will be initialized immediately, even if dataLoaded is false, but it will be hidden. If you want
 * your component to be initialized only if dataLoaded is true, then you should use ngIf:
 * <core-loading [hideUntil]="dataLoaded"><my-component *ngIf="dataLoaded"></my-component></core-loading>
 */
var CoreLoadingComponent = /** @class */ (function () {
    function CoreLoadingComponent(translate) {
        this.translate = translate;
    }
    /**
     * Component being initialized.
     */
    CoreLoadingComponent.prototype.ngOnInit = function () {
        if (!this.message) {
            // Default loading message.
            this.message = this.translate.instant('core.loading');
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Boolean)
    ], CoreLoadingComponent.prototype, "hideUntil", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreLoadingComponent.prototype, "message", void 0);
    CoreLoadingComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-loading',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/components/loading/loading.html"*/'<div [@coreShowHideAnimation] class="core-loading-container" *ngIf="!hideUntil">\n    <span class="core-loading-spinner">\n        <ion-spinner></ion-spinner>\n        <p class="core-loading-message" *ngIf="message">{{message}}</p>\n    </span>\n</div>\n<ng-content [@coreShowHideAnimation] class="core-loading-content" *ngIf="hideUntil">\n</ng-content>'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/components/loading/loading.html"*/,
            animations: [__WEBPACK_IMPORTED_MODULE_2__classes_animations__["a" /* coreShowHideAnimation */]]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
    ], CoreLoadingComponent);
    return CoreLoadingComponent;
}());

//# sourceMappingURL=loading.js.map

/***/ }),
/* 1052 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreMarkRequiredComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_text__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__ = __webpack_require__(9);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Directive to add a red asterisk for required input fields.
 *
 * @description
 * For forms with required and not required fields, it is recommended to use this directive to mark the required ones.
 *
 * This directive should be applied in the label. Example:
 *
 * <ion-label core-mark-required="{{field.required}}">{{ 'core.login.username' | translate }}</ion-label>
 */
var CoreMarkRequiredComponent = /** @class */ (function () {
    function CoreMarkRequiredComponent(element, translate, textUtils, utils) {
        this.translate = translate;
        this.textUtils = textUtils;
        this.utils = utils;
        this.coreMarkRequired = true;
        this.element = element.nativeElement;
        this.requiredLabel = this.translate.instant('core.required');
    }
    /**
     * Component being initialized.
     */
    CoreMarkRequiredComponent.prototype.ngOnInit = function () {
        this.coreMarkRequired = this.utils.isTrueOrOne(this.coreMarkRequired);
    };
    /**
     * Called after the view is initialized.
     */
    CoreMarkRequiredComponent.prototype.ngAfterViewInit = function () {
        if (this.coreMarkRequired) {
            // Add the "required" to the aria-label.
            var ariaLabel = this.element.getAttribute('aria-label') || this.textUtils.cleanTags(this.element.innerHTML, true);
            if (ariaLabel) {
                this.element.setAttribute('aria-label', ariaLabel + ' ' + this.requiredLabel);
            }
        }
        else {
            // Remove the "required" from the aria-label.
            var ariaLabel = this.element.getAttribute('aria-label');
            if (ariaLabel) {
                this.element.setAttribute('aria-label', ariaLabel.replace(' ' + this.requiredLabel, ''));
            }
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])('core-mark-required'),
        __metadata("design:type", Object)
    ], CoreMarkRequiredComponent.prototype, "coreMarkRequired", void 0);
    CoreMarkRequiredComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: '[core-mark-required]',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/components/mark-required/mark-required.html"*/'<ng-content></ng-content>\n<ion-icon *ngIf="coreMarkRequired" class="core-input-required-asterisk" name="medical" md="ios-medical" [title]="requiredLabel"></ion-icon> <!-- Use iOS icon because it\'s more narrow, so it looks better since it\'s small. -->\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/components/mark-required/mark-required.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_text__["a" /* CoreTextUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], CoreMarkRequiredComponent);
    return CoreMarkRequiredComponent;
}());

//# sourceMappingURL=mark-required.js.map

/***/ }),
/* 1053 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreInputErrorsComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_forms__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(7);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Component to show errors if an input isn't valid.
 *
 * @description
 * The purpose of this component is to make easier and consistent the validation of forms.
 *
 * It should be applied next to the input element (ion-input, ion-select, ...). In case of ion-checkbox, it should be in another
 * item, placing it in the same item as the checkbox will cause problems.
 *
 * Please notice that the inputs need to have a FormControl to make it work. That FormControl needs to be passed to this component.
 *
 * If this component is placed in the same ion-item as a ion-label or ion-input, then it should have the attribute "item-content",
 * otherwise Ionic will remove it.
 *
 * Example usage:
 *
 * <ion-item text-wrap>
 *     <ion-label stacked core-mark-required="true">{{ 'core.login.username' | translate }}</ion-label>
 *     <ion-input type="text" name="username" formControlName="username"></ion-input>
 *     <core-input-errors item-content [control]="myForm.controls.username" [errorMessages]="usernameErrors"></core-input-errors>
 * </ion-item>
 */
var CoreInputErrorsComponent = /** @class */ (function () {
    function CoreInputErrorsComponent(translate) {
        this.translate = translate;
    }
    /**
     * Component is being initialized.
     */
    CoreInputErrorsComponent.prototype.ngOnInit = function () {
        this.initErrorMessages();
        this.errorKeys = Object.keys(this.errorMessages);
    };
    /**
     * Initialize some common errors if they aren't set.
     */
    CoreInputErrorsComponent.prototype.initErrorMessages = function () {
        this.errorMessages = this.errorMessages || {};
        this.errorMessages.required = this.errorMessages.required || this.translate.instant('core.required');
        this.errorMessages.email = this.errorMessages.email || this.translate.instant('core.login.invalidemail');
        this.errorMessages.date = this.errorMessages.date || this.translate.instant('core.login.invaliddate');
        this.errorMessages.datetime = this.errorMessages.datetime || this.translate.instant('core.login.invaliddate');
        this.errorMessages.datetimelocal = this.errorMessages.datetimelocal || this.translate.instant('core.login.invaliddate');
        this.errorMessages.time = this.errorMessages.time || this.translate.instant('core.login.invalidtime');
        this.errorMessages.url = this.errorMessages.url || this.translate.instant('core.login.invalidurl');
        // @todo: Check how to handle min/max errors once we have a test case to use. Also, review previous errors.
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])('control'),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_1__angular_forms__["b" /* FormControl */])
    ], CoreInputErrorsComponent.prototype, "formControl", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreInputErrorsComponent.prototype, "errorMessages", void 0);
    CoreInputErrorsComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-input-errors',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/components/input-errors/input-errors.html"*/'<div class="core-input-error-container" *ngIf="formControl.dirty && !formControl.valid" role="alert">\n    <ng-container *ngFor="let error of errorKeys">\n        <div *ngIf="formControl.hasError(error)" class="core-input-error">{{errorMessages[error]}}</div>\n    </ng-container>\n</div>'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/components/input-errors/input-errors.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */]])
    ], CoreInputErrorsComponent);
    return CoreInputErrorsComponent;
}());

//# sourceMappingURL=input-errors.js.map

/***/ }),
/* 1054 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreShowPasswordComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_utils_utils__ = __webpack_require__(9);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Component to allow showing and hiding a password. The affected input MUST have a name to identify it.
 *
 * @description
 * This directive needs to surround the input with the password.
 *
 * You need to supply the name of the input.
 *
 * Example:
 *
 * <core-show-password item-content [name]="'password'">
 *     <ion-input type="password" name="password"></ion-input>
 * </core-show-password>
 */
var CoreShowPasswordComponent = /** @class */ (function () {
    function CoreShowPasswordComponent(element, utils) {
        this.utils = utils;
        this.selector = ''; // Selector to identify the input.
        this.element = element.nativeElement;
    }
    /**
     * Component being initialized.
     */
    CoreShowPasswordComponent.prototype.ngOnInit = function () {
        this.shown = this.utils.isTrueOrOne(this.initialShown);
        this.selector = 'input[name="' + this.name + '"]';
        this.setData();
    };
    /**
     * View has been initialized.
     */
    CoreShowPasswordComponent.prototype.ngAfterViewInit = function () {
        this.searchInput();
    };
    /**
     * Search the input to show/hide.
     */
    CoreShowPasswordComponent.prototype.searchInput = function () {
        // Search the input.
        this.input = this.element.querySelector(this.selector);
        if (this.input) {
            // Input found. Set the right type.
            this.input.type = this.shown ? 'text' : 'password';
            // By default, don't autocapitalize and autocorrect.
            if (!this.input.getAttribute('autocorrect')) {
                this.input.setAttribute('autocorrect', 'off');
            }
            if (!this.input.getAttribute('autocapitalize')) {
                this.input.setAttribute('autocapitalize', 'none');
            }
        }
    };
    /**
     * Set label, icon name and input type.
     */
    CoreShowPasswordComponent.prototype.setData = function () {
        this.label = this.shown ? 'core.hide' : 'core.show';
        this.iconName = this.shown ? 'eye-off' : 'eye';
        if (this.input) {
            this.input.type = this.shown ? 'text' : 'password';
        }
    };
    /**
     * Toggle show/hide password.
     */
    CoreShowPasswordComponent.prototype.toggle = function () {
        this.shown = !this.shown;
        this.setData();
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreShowPasswordComponent.prototype, "name", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreShowPasswordComponent.prototype, "initialShown", void 0);
    CoreShowPasswordComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-show-password',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/components/show-password/show-password.html"*/'<ng-content></ng-content>\n<a ion-button icon-only clear [attr.aria-label]="label | translate" (click)="toggle()" [core-keep-keyboard]="selector" [inButton]="true">\n    <ion-icon [name]="iconName"></ion-icon>\n</a>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/components/show-password/show-password.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_1__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], CoreShowPasswordComponent);
    return CoreShowPasswordComponent;
}());

//# sourceMappingURL=show-password.js.map

/***/ }),
/* 1055 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreIframeComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_platform_browser__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_file__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_text__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_url__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_utils_utils__ = __webpack_require__(9);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};










/**
 */
var CoreIframeComponent = /** @class */ (function () {
    function CoreIframeComponent(logger, fileProvider, urlUtils, textUtils, utils, domUtils, sitesProvider, platform, sanitizer) {
        this.fileProvider = fileProvider;
        this.urlUtils = urlUtils;
        this.textUtils = textUtils;
        this.utils = utils;
        this.domUtils = domUtils;
        this.sitesProvider = sitesProvider;
        this.platform = platform;
        this.sanitizer = sanitizer;
        this.tags = ['iframe', 'frame', 'object', 'embed'];
        this.IFRAME_TIMEOUT = 15000;
        this.logger = logger.getInstance('CoreIframe');
    }
    /**
     * Component being initialized.
     */
    CoreIframeComponent.prototype.ngOnInit = function () {
        var _this = this;
        var iframe = this.iframe && this.iframe.nativeElement;
        this.safeUrl = this.sanitizer.bypassSecurityTrustResourceUrl(this.src);
        this.iframeWidth = this.domUtils.formatPixelsSize(this.iframeWidth) || '100%';
        this.iframeHeight = this.domUtils.formatPixelsSize(this.iframeHeight) || '100%';
        // Show loading only with external URLs.
        this.loading = !this.src || !!this.src.match(/^https?:\/\//i);
        this.treatFrame(iframe);
        if (this.loading) {
            iframe.addEventListener('load', function () {
                _this.loading = false;
            });
            iframe.addEventListener('error', function () {
                _this.loading = false;
                _this.domUtils.showErrorModal('core.errorloadingcontent', true);
            });
            setTimeout(function () {
                _this.loading = false;
            }, this.IFRAME_TIMEOUT);
        }
    };
    /**
     * Given an element, return the content window and document.
     *
     * @param {any} element Element to treat.
     * @return {{ window: Window, document: Document }} Window and Document.
     */
    CoreIframeComponent.prototype.getContentWindowAndDocument = function (element) {
        var contentWindow = element.contentWindow, contentDocument = element.contentDocument || (contentWindow && contentWindow.document);
        if (!contentWindow && contentDocument) {
            // It's probably an <object>. Try to get the window.
            contentWindow = contentDocument.defaultView;
        }
        if (!contentWindow && element.getSVGDocument) {
            // It's probably an <embed>. Try to get the window and the document.
            contentDocument = element.getSVGDocument();
            if (contentDocument && contentDocument.defaultView) {
                contentWindow = contentDocument.defaultView;
            }
            else if (element.window) {
                contentWindow = element.window;
            }
            else if (element.getWindow) {
                contentWindow = element.getWindow();
            }
        }
        return { window: contentWindow, document: contentDocument };
    };
    /**
     * Intercept window.open in a frame and its subframes, shows an error modal instead.
     * Search links (<a>) and open them in browser or InAppBrowser if needed.
     *
     * @param {any} element Element to treat.
     */
    CoreIframeComponent.prototype.treatFrame = function (element) {
        var _this = this;
        if (element) {
            var winAndDoc_1 = this.getContentWindowAndDocument(element);
            // Redefine window.open in this element and sub frames, it might have been loaded already.
            this.redefineWindowOpen(element, winAndDoc_1.window, winAndDoc_1.document);
            // Treat links.
            this.treatLinks(element, winAndDoc_1.document);
            element.addEventListener('load', function () {
                // Element loaded, redefine window.open and treat links again.
                winAndDoc_1 = _this.getContentWindowAndDocument(element);
                _this.redefineWindowOpen(element, winAndDoc_1.window, winAndDoc_1.document);
                _this.treatLinks(element, winAndDoc_1.document);
            });
        }
    };
    /**
     * Redefine the open method in the contentWindow of an element and the sub frames.
     *
     * @param {any} element Element to treat.
     * @param {Window} contentWindow The window of the element contents.
     * @param {Document} contentDocument The document of the element contents.
     */
    CoreIframeComponent.prototype.redefineWindowOpen = function (element, contentWindow, contentDocument) {
        var _this = this;
        if (contentWindow) {
            // Intercept window.open.
            contentWindow.open = function (url) {
                var scheme = _this.urlUtils.getUrlScheme(url);
                if (!scheme) {
                    // It's a relative URL, use the frame src to create the full URL.
                    var src = element.src || element.data;
                    if (src) {
                        var dirAndFile = _this.fileProvider.getFileAndDirectoryFromPath(src);
                        if (dirAndFile.directory) {
                            url = _this.textUtils.concatenatePaths(dirAndFile.directory, url);
                        }
                        else {
                            _this.logger.warn('Cannot get iframe dir path to open relative url', url, element);
                            return new Window(); // Return new Window object.
                        }
                    }
                    else {
                        _this.logger.warn('Cannot get iframe src to open relative url', url, element);
                        return new Window(); // Return new Window object.
                    }
                }
                if (url.indexOf('cdvfile://') === 0 || url.indexOf('file://') === 0) {
                    // It's a local file.
                    _this.utils.openFile(url).catch(function (error) {
                        _this.domUtils.showErrorModal(error);
                    });
                }
                else {
                    // It's an external link, we will open with browser. Check if we need to auto-login.
                    if (!_this.sitesProvider.isLoggedIn()) {
                        // Not logged in, cannot auto-login.
                        _this.utils.openInBrowser(url);
                    }
                    else {
                        _this.sitesProvider.getCurrentSite().openInBrowserWithAutoLoginIfSameSite(url);
                    }
                }
                return new Window(); // Return new Window object.
            };
        }
        if (contentDocument) {
            // Search sub frames.
            this.tags.forEach(function (tag) {
                var elements = Array.from(contentDocument.querySelectorAll(tag));
                elements.forEach(function (subElement) {
                    _this.treatFrame(subElement);
                });
            });
        }
    };
    /**
     * Search links (<a>) and open them in browser or InAppBrowser if needed.
     * Only links that haven't been treated by the iframe's Javascript will be treated.
     *
     * @param {any} element Element to treat.
     * @param {Document} contentDocument The document of the element contents.
     */
    CoreIframeComponent.prototype.treatLinks = function (element, contentDocument) {
        var _this = this;
        if (!contentDocument) {
            return;
        }
        var links = Array.from(contentDocument.querySelectorAll('a'));
        links.forEach(function (el) {
            var href = el.href;
            // Check that href is not null.
            if (href) {
                var scheme = _this.urlUtils.getUrlScheme(href);
                if (scheme && scheme == 'javascript') {
                    // Javascript links should be treated by the iframe's Javascript.
                    // There's nothing to be done with these links, so they'll be ignored.
                    return;
                }
                else if (scheme && scheme != 'file' && scheme != 'filesystem') {
                    // Scheme suggests it's an external resource, open it in browser.
                    el.addEventListener('click', function (e) {
                        // If the link's already prevented by SCORM JS then we won't open it in browser.
                        if (!e.defaultPrevented) {
                            e.preventDefault();
                            if (!_this.sitesProvider.isLoggedIn()) {
                                _this.utils.openInBrowser(href);
                            }
                            else {
                                _this.sitesProvider.getCurrentSite().openInBrowserWithAutoLoginIfSameSite(href);
                            }
                        }
                    });
                }
                else if (el.target == '_parent' || el.target == '_top' || el.target == '_blank') {
                    // Opening links with _parent, _top or _blank can break the app. We'll open it in InAppBrowser.
                    el.addEventListener('click', function (e) {
                        // If the link's already prevented by SCORM JS then we won't open it in InAppBrowser.
                        if (!e.defaultPrevented) {
                            e.preventDefault();
                            _this.utils.openFile(href).catch(function (error) {
                                _this.domUtils.showErrorModal(error);
                            });
                        }
                    });
                }
                else if (_this.platform.is('ios') && (!el.target || el.target == '_self')) {
                    // In cordova ios 4.1.0 links inside iframes stopped working. We'll manually treat them.
                    el.addEventListener('click', function (e) {
                        // If the link's already prevented by SCORM JS then we won't treat it.
                        if (!e.defaultPrevented) {
                            if (element.tagName.toLowerCase() == 'object') {
                                e.preventDefault();
                                element.attr('data', href);
                            }
                            else {
                                e.preventDefault();
                                element.attr('src', href);
                            }
                        }
                    });
                }
            }
        });
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])('iframe'),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */])
    ], CoreIframeComponent.prototype, "iframe", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreIframeComponent.prototype, "src", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreIframeComponent.prototype, "iframeWidth", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreIframeComponent.prototype, "iframeHeight", void 0);
    CoreIframeComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-iframe',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/components/iframe/iframe.html"*/'<div [class.core-loading-container]="loading">\n    <iframe #iframe [hidden]="loading" class="core-iframe" [ngStyle]="{\'width\': iframeWidth, \'height\': iframeHeight}" [src]="safeUrl"></iframe>\n    <ion-spinner *ngIf="loading"></ion-spinner>\n</div>'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/components/iframe/iframe.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_file__["a" /* CoreFileProvider */], __WEBPACK_IMPORTED_MODULE_8__providers_utils_url__["a" /* CoreUrlUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_7__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_9__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_5__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* Platform */], __WEBPACK_IMPORTED_MODULE_1__angular_platform_browser__["c" /* DomSanitizer */]])
    ], CoreIframeComponent);
    return CoreIframeComponent;
}());

//# sourceMappingURL=iframe.js.map

/***/ }),
/* 1056 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreProgressBarComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_platform_browser__ = __webpack_require__(57);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Component to show a progress bar and its value.
 *
 * Example usage:
 * <core-progress-bar [progress]="percentage"></core-progress-bar>
 */
var CoreProgressBarComponent = /** @class */ (function () {
    function CoreProgressBarComponent(sanitizer) {
        this.sanitizer = sanitizer;
        this.textSupplied = false;
    }
    /**
     * Detect changes on input properties.
     */
    CoreProgressBarComponent.prototype.ngOnChanges = function (changes) {
        if (changes.text && typeof changes.text.currentValue != 'undefined') {
            // User provided a custom text, don't use default.
            this.textSupplied = true;
        }
        if (changes.progress) {
            // Progress has changed.
            if (typeof this.progress == 'string') {
                this.progress = parseInt(this.progress, 10);
            }
            if (this.progress < 0 || isNaN(this.progress)) {
                this.progress = -1;
            }
            if (this.progress != -1) {
                // Remove decimals.
                this.progress = Math.floor(this.progress);
                if (!this.textSupplied) {
                    this.text = String(this.progress);
                }
                this.width = this.sanitizer.bypassSecurityTrustStyle(this.progress + '%');
            }
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreProgressBarComponent.prototype, "progress", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreProgressBarComponent.prototype, "text", void 0);
    CoreProgressBarComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-progress-bar',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/components/progress-bar/progress-bar.html"*/'<div *ngIf="progress >= 0">\n    <progress max="100" [value]="progress">\n        <div class="progress-bar-fallback" role="progressbar" aria-valuemin="0" aria-valuemax="100" [attr.aria-valuenow]="progress">\n            <span [style.width]="width"></span>\n        </div>\n    </progress>\n    <span class="core-progress-text">{{ \'core.percentagenumber\' | translate: {$a: text} }}</span>\n</div>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/components/progress-bar/progress-bar.html"*/,
            changeDetection: __WEBPACK_IMPORTED_MODULE_0__angular_core__["i" /* ChangeDetectionStrategy */].OnPush
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_platform_browser__["c" /* DomSanitizer */]])
    ], CoreProgressBarComponent);
    return CoreProgressBarComponent;
}());

//# sourceMappingURL=progress-bar.js.map

/***/ }),
/* 1057 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreEmptyBoxComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

/**
 * Component to show an empty box message. It will show an optional icon or image and a text centered on page.
 *
 * Usage:
 * <core-empty-box *ngIf="empty" icon="bell" [message]="'core.emptymessage' | translate"></core-empty-box>
 */
var CoreEmptyBoxComponent = /** @class */ (function () {
    function CoreEmptyBoxComponent() {
        // Nothing to do.
    }
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreEmptyBoxComponent.prototype, "message", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreEmptyBoxComponent.prototype, "icon", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreEmptyBoxComponent.prototype, "image", void 0);
    CoreEmptyBoxComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-empty-box',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/components/empty-box/empty-box.html"*/'<div class="core-empty-box" [class.core-empty-box-inline]="!image && !icon">\n    <div class="core-empty-box-content" padding>\n        <img *ngIf="image && !icon" [src]="image" role="presentation">\n        <ion-icon *ngIf="icon" [name]="icon"></ion-icon>\n        <p *ngIf="message" [class.padding-top]="image || icon">{{ message }}</p>\n        <ng-content></ng-content>\n    </div>\n</div>'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/components/empty-box/empty-box.html"*/
        }),
        __metadata("design:paramtypes", [])
    ], CoreEmptyBoxComponent);
    return CoreEmptyBoxComponent;
}());

//# sourceMappingURL=empty-box.js.map

/***/ }),
/* 1058 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSearchBoxComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__ = __webpack_require__(9);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Component to display a "search box".
 *
 * @description
 * This component will display a standalone search box with its search button in order to have a better UX.
 *
 * Example usage:
 * <core-search-box (onSubmit)="search($event)" [placeholder]="'core.courses.search' | translate"
 *     [searchLabel]="'core.courses.search' | translate" autoFocus="true"></core-search-box>
 */
var CoreSearchBoxComponent = /** @class */ (function () {
    function CoreSearchBoxComponent(translate, utils) {
        this.translate = translate;
        this.utils = utils;
        this.autocorrect = 'on'; // Enables/disable Autocorrection on search text input.
        this.spellcheck = true; // Enables/disable Spellchecker on search text input.
        this.lengthCheck = 3; // Check value length before submit. If 0, any string will be submitted.
        this.showClear = true; // Show/hide clear button.
        this.disabled = false; // Disables the input text.
        this.searched = false;
        this.searchText = '';
        this.onSubmit = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
        this.onClear = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
    }
    CoreSearchBoxComponent.prototype.ngOnInit = function () {
        this.searchLabel = this.searchLabel || this.translate.instant('core.search');
        this.placeholder = this.placeholder || this.translate.instant('core.search');
        this.spellcheck = this.utils.isTrueOrOne(this.spellcheck);
        this.showClear = this.utils.isTrueOrOne(this.showClear);
    };
    /**
     * Form submitted.
     *
     * @param {string} value Entered value.
     */
    CoreSearchBoxComponent.prototype.submitForm = function (value) {
        if (this.searchText.length < this.lengthCheck) {
            // The view should handle this case, but we check it here too just in case.
            return;
        }
        this.searched = true;
        this.onSubmit.emit(this.searchText);
    };
    /**
     * Form submitted.
     */
    CoreSearchBoxComponent.prototype.clearForm = function () {
        this.searched = false;
        this.searchText = '';
        this.onClear.emit();
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreSearchBoxComponent.prototype, "searchLabel", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreSearchBoxComponent.prototype, "placeholder", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreSearchBoxComponent.prototype, "autocorrect", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreSearchBoxComponent.prototype, "spellcheck", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreSearchBoxComponent.prototype, "autoFocus", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreSearchBoxComponent.prototype, "lengthCheck", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreSearchBoxComponent.prototype, "showClear", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreSearchBoxComponent.prototype, "disabled", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreSearchBoxComponent.prototype, "onSubmit", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreSearchBoxComponent.prototype, "onClear", void 0);
    CoreSearchBoxComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-search-box',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/components/search-box/search-box.html"*/'<ion-card>\n    <form #f="ngForm" (ngSubmit)="submitForm()">\n        <ion-item>\n            <ion-input type="text" name="search" [(ngModel)]="searchText" [placeholder]="placeholder" [autocorrect]="autocorrect" [spellcheck]="spellcheck" [core-auto-focus]="autoFocus" [disabled]="disabled"></ion-input>\n            <button item-end ion-button clear icon-only type="submit" class="button-small" [attr.aria-label]="searchLabel" [disabled]="!searchText || (searchText.length < lengthCheck)" [disabled]="disabled">\n                <ion-icon name="search"></ion-icon>\n            </button>\n            <button *ngIf="showClear" item-end ion-button clear icon-only class="button-small" [attr.aria-label]="\'core.clearsearch\' | translate" [disabled]="!searched" (click)="clearForm()" [disabled]="disabled">\n                <ion-icon name="close"></ion-icon>\n            </button>\n        </ion-item>\n    </form>\n</ion-card>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/components/search-box/search-box.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], CoreSearchBoxComponent);
    return CoreSearchBoxComponent;
}());

//# sourceMappingURL=search-box.js.map

/***/ }),
/* 1059 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFileComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_events__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_filepool__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_file_helper__ = __webpack_require__(160);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_mimetype__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__core_constants__ = __webpack_require__(22);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};










/**
 * Component to handle a remote file. Shows the file name, icon (depending on mimetype) and a button
 * to download/refresh it.
 */
var CoreFileComponent = /** @class */ (function () {
    function CoreFileComponent(sitesProvider, utils, domUtils, filepoolProvider, appProvider, fileHelper, mimeUtils, eventsProvider) {
        this.sitesProvider = sitesProvider;
        this.utils = utils;
        this.domUtils = domUtils;
        this.filepoolProvider = filepoolProvider;
        this.appProvider = appProvider;
        this.fileHelper = fileHelper;
        this.mimeUtils = mimeUtils;
        this.eventsProvider = eventsProvider;
        // Use it for files that you cannot determine if they're outdated or not.
        this.canDownload = true; // Whether file can be downloaded.
        this.onDelete = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
    }
    /**
     * Component being initialized.
     */
    CoreFileComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.canDelete = this.utils.isTrueOrOne(this.canDelete);
        this.alwaysDownload = this.utils.isTrueOrOne(this.alwaysDownload);
        this.canDownload = this.utils.isTrueOrOne(this.canDownload);
        this.fileUrl = this.fileHelper.getFileUrl(this.file);
        this.timemodified = this.fileHelper.getFileTimemodified(this.file);
        this.siteId = this.sitesProvider.getCurrentSiteId();
        this.fileSize = this.file.filesize;
        this.fileName = this.file.filename;
        if (this.file.isexternalfile) {
            this.alwaysDownload = true; // Always show the download button in external files.
        }
        this.fileIcon = this.mimeUtils.getFileIcon(this.file.filename);
        if (this.canDownload) {
            this.calculateState();
            // Update state when receiving events about this file.
            this.filepoolProvider.getFileEventNameByUrl(this.siteId, this.fileUrl).then(function (eventName) {
                _this.observer = _this.eventsProvider.on(eventName, function () {
                    _this.calculateState();
                });
            });
        }
    };
    /**
     * Convenience function to get the file state and set variables based on it.
     *
     * @return {Promise<void>} Promise resolved when state has been calculated.
     */
    CoreFileComponent.prototype.calculateState = function () {
        var _this = this;
        return this.filepoolProvider.getFileStateByUrl(this.siteId, this.fileUrl, this.timemodified).then(function (state) {
            var canDownload = _this.sitesProvider.getCurrentSite().canDownloadFiles();
            _this.state = state;
            _this.isDownloaded = state === __WEBPACK_IMPORTED_MODULE_9__core_constants__["a" /* CoreConstants */].DOWNLOADED || state === __WEBPACK_IMPORTED_MODULE_9__core_constants__["a" /* CoreConstants */].OUTDATED;
            _this.isDownloading = canDownload && state === __WEBPACK_IMPORTED_MODULE_9__core_constants__["a" /* CoreConstants */].DOWNLOADING;
            _this.showDownload = canDownload && (state === __WEBPACK_IMPORTED_MODULE_9__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED || state === __WEBPACK_IMPORTED_MODULE_9__core_constants__["a" /* CoreConstants */].OUTDATED ||
                (_this.alwaysDownload && state === __WEBPACK_IMPORTED_MODULE_9__core_constants__["a" /* CoreConstants */].DOWNLOADED));
        });
    };
    /**
     * Convenience function to open a file, downloading it if needed.
     *
     * @return {Promise<string>} Promise resolved when file is opened.
     */
    CoreFileComponent.prototype.openFile = function () {
        var _this = this;
        return this.fileHelper.downloadAndOpenFile(this.file, this.component, this.componentId, this.state, function (event) {
            if (event && event.calculating) {
                // The process is calculating some data required for the download, show the spinner.
                _this.isDownloading = true;
            }
        }).catch(function (error) {
            _this.domUtils.showErrorModalDefault(error, 'core.errordownloading', true);
        });
    };
    /**
     * Download a file and, optionally, open it afterwards.
     *
     * @param {Event} e Click event.
     * @param {boolean} openAfterDownload Whether the file should be opened after download.
     */
    CoreFileComponent.prototype.download = function (e, openAfterDownload) {
        var _this = this;
        e.preventDefault();
        e.stopPropagation();
        var promise;
        if (this.isDownloading && !openAfterDownload) {
            return;
        }
        if (!this.appProvider.isOnline() && (!openAfterDownload || (openAfterDownload && !this.isDownloaded))) {
            this.domUtils.showErrorModal('core.networkerrormsg', true);
            return;
        }
        if (openAfterDownload) {
            // File needs to be opened now.
            this.openFile().catch(function (error) {
                _this.domUtils.showErrorModalDefault(error, 'core.errordownloading', true);
            });
        }
        else {
            // File doesn't need to be opened (it's a prefetch). Show confirm modal if file size is defined and it's big.
            promise = this.fileSize ? this.domUtils.confirmDownloadSize({ size: this.fileSize, total: true }) : Promise.resolve();
            promise.then(function () {
                // User confirmed, add the file to queue.
                _this.filepoolProvider.invalidateFileByUrl(_this.siteId, _this.fileUrl).finally(function () {
                    _this.isDownloading = true;
                    _this.filepoolProvider.addToQueueByUrl(_this.siteId, _this.fileUrl, _this.component, _this.componentId, _this.timemodified, undefined, undefined, 0, _this.file).catch(function (error) {
                        _this.domUtils.showErrorModalDefault(error, 'core.errordownloading', true);
                        _this.calculateState();
                    });
                });
            });
        }
    };
    /**
     * Delete the file.
     *
     * @param {Event} e Click event.
     */
    CoreFileComponent.prototype.deleteFile = function (e) {
        e.preventDefault();
        e.stopPropagation();
        if (this.canDelete) {
            this.onDelete.emit();
        }
    };
    /**
     * Component destroyed.
     */
    CoreFileComponent.prototype.ngOnDestroy = function () {
        this.observer && this.observer.off();
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreFileComponent.prototype, "file", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreFileComponent.prototype, "component", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreFileComponent.prototype, "componentId", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreFileComponent.prototype, "canDelete", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreFileComponent.prototype, "alwaysDownload", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreFileComponent.prototype, "canDownload", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreFileComponent.prototype, "onDelete", void 0);
    CoreFileComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-file',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/components/file/file.html"*/'<a ion-item text-wrap class="item-media" (click)="download($event, true)" detail-none>\n    <img [src]="fileIcon" alt="" role="presentation" item-start />\n    <p>{{fileName}}</p>\n    <div class="buttons" item-end>\n        <button ion-button clear icon-only (click)="download($event)" *ngIf="!isDownloading && showDownload" [attr.aria-label]="\'core.download\' | translate" color="dark">\n            <ion-icon [name]="isDownloaded ? \'refresh\' : \'cloud-download\'"></ion-icon>\n        </button>\n        <button ion-button clear icon-only (click)="delete($event)" *ngIf="!isDownloading && canDelete" [attr.aria-label]="\'core.delete\' | translate" color="danger">\n            <ion-icon name="trash"></ion-icon>\n        </button>\n    </div>\n    <ion-spinner *ngIf="isDownloading" item-end></ion-spinner>\n</a>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/components/file/file.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_8__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_filepool__["a" /* CoreFilepoolProvider */], __WEBPACK_IMPORTED_MODULE_1__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_file_helper__["a" /* CoreFileHelperProvider */], __WEBPACK_IMPORTED_MODULE_7__providers_utils_mimetype__["a" /* CoreMimetypeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */]])
    ], CoreFileComponent);
    return CoreFileComponent;
}());

//# sourceMappingURL=file.js.map

/***/ }),
/* 1060 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreContextMenuItemComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__context_menu__ = __webpack_require__(586);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * This directive adds a item to the Context Menu popover.
 *
 * @description
 * This directive defines and item to be added to the popover generated in CoreContextMenu.
 *
 * It is required to place this tag inside a core-context-menu tag.
 *
 * <core-context-menu>
 *     <core-context-menu-item [hidden]="showGrid" [priority]="601" [content]="'core.layoutgrid' | translate"
 *         (action)="switchGrid()" [iconAction]="'apps'"></core-context-menu-item>
 * </core-context-menu>
 */
var CoreContextMenuItemComponent = /** @class */ (function () {
    function CoreContextMenuItemComponent(ctxtMenu) {
        this.ctxtMenu = ctxtMenu;
        this.closeOnClick = true; // Whether to close the popover when the item is clicked.
        this.hasAction = false;
        this.destroyed = false;
        this.action = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
    }
    /**
     * Component being initialized.
     */
    CoreContextMenuItemComponent.prototype.ngOnInit = function () {
        // Initialize values.
        this.priority = this.priority || 1;
        this.closeOnClick = this.getBooleanValue(this.closeOnClick, true);
        this.hasAction = this.action.observers.length > 0;
        this.ariaAction = this.ariaAction || this.content;
        if (this.hasAction) {
            this.href = '';
        }
        // Navigation help if href provided.
        this.captureLink = this.href && this.captureLink ? this.captureLink : false;
        this.autoLogin = this.autoLogin || 'check';
        if (!this.destroyed) {
            this.ctxtMenu.addItem(this);
        }
    };
    /**
     * Get a boolean value from item.
     *
     * @param {any} value Value to check.
     * @param {boolean} defaultValue Value to use if undefined.
     * @return {boolean} Boolean value.
     */
    CoreContextMenuItemComponent.prototype.getBooleanValue = function (value, defaultValue) {
        if (typeof value == 'undefined') {
            return defaultValue;
        }
        return value && value !== 'false';
    };
    /**
     * Component destroyed.
     */
    CoreContextMenuItemComponent.prototype.ngOnDestroy = function () {
        this.destroyed = true;
        this.ctxtMenu.removeItem(this);
    };
    /**
     * Detect changes on input properties.
     */
    CoreContextMenuItemComponent.prototype.ngOnChanges = function (changes) {
        if (changes.hidden && !changes.hidden.firstChange) {
            this.ctxtMenu.itemsChanged();
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreContextMenuItemComponent.prototype, "content", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreContextMenuItemComponent.prototype, "iconDescription", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreContextMenuItemComponent.prototype, "iconAction", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreContextMenuItemComponent.prototype, "ariaDescription", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreContextMenuItemComponent.prototype, "ariaAction", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreContextMenuItemComponent.prototype, "href", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreContextMenuItemComponent.prototype, "captureLink", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreContextMenuItemComponent.prototype, "autoLogin", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreContextMenuItemComponent.prototype, "closeOnClick", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreContextMenuItemComponent.prototype, "priority", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreContextMenuItemComponent.prototype, "badge", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreContextMenuItemComponent.prototype, "badgeClass", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Boolean)
    ], CoreContextMenuItemComponent.prototype, "hidden", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreContextMenuItemComponent.prototype, "action", void 0);
    CoreContextMenuItemComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-context-menu-item',
            template: ''
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__context_menu__["a" /* CoreContextMenuComponent */]])
    ], CoreContextMenuItemComponent);
    return CoreContextMenuItemComponent;
}());

//# sourceMappingURL=context-menu-item.js.map

/***/ }),
/* 1061 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreChronoComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

/**
 * This component shows a chronometer in format HH:MM:SS.
 *
 * If no startTime is provided, it will start at 00:00:00.
 * If an endTime is provided, the chrono will stop and emit an event in the onEnd output when that number of milliseconds is
 * reached. E.g. if startTime=60000 and endTime=120000, the chrono will start at 00:01:00 and end when it reaches 00:02:00.
 *
 * This component has 2 boolean inputs to control the timer: running (to start and stop it) and reset.
 *
 * Example usage:
 * <core-chrono [running]="running" [reset]="reset" [endTime]="maxTime" (onEnd)="stopCapturing()"></core-chrono>
 */
var CoreChronoComponent = /** @class */ (function () {
    function CoreChronoComponent(cdr) {
        this.cdr = cdr;
        this.startTime = 0; // Number of milliseconds to put in the chrono before starting.
        this.time = 0;
        this.onEnd = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
    }
    /**
     * Component being initialized.
     */
    CoreChronoComponent.prototype.ngOnInit = function () {
        this.time = this.startTime || 0;
    };
    /**
     * Component being initialized.
     */
    CoreChronoComponent.prototype.ngOnChanges = function (changes) {
        if (changes && changes.running) {
            if (changes.running.currentValue) {
                this.start();
            }
            else {
                this.stop();
            }
        }
        if (changes && changes.reset && changes.reset.currentValue) {
            this.resetChrono();
        }
    };
    /**
     * Reset the chrono, stopping it and setting it to startTime.
     */
    CoreChronoComponent.prototype.resetChrono = function () {
        this.stop();
        this.time = this.startTime || 0;
    };
    /**
     * Start the chrono if it isn't running.
     */
    CoreChronoComponent.prototype.start = function () {
        var _this = this;
        if (this.interval) {
            // Already setup.
            return;
        }
        var lastExecTime = Date.now();
        this.interval = setInterval(function () {
            // Increase the chrono.
            _this.time += Date.now() - lastExecTime;
            lastExecTime = Date.now();
            if (typeof _this.endTime != 'undefined' && _this.time > _this.endTime) {
                // End time reached, stop the timer and call the end function.
                _this.stop();
                _this.onEnd.emit();
            }
            // Force change detection. Angular doesn't detect these async operations.
            _this.cdr.detectChanges();
        }, 200);
    };
    /**
     * Stop the chrono, leaving the same time it has.
     */
    CoreChronoComponent.prototype.stop = function () {
        clearInterval(this.interval);
        delete this.interval;
    };
    CoreChronoComponent.prototype.ngOnDestroy = function () {
        this.stop();
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Boolean)
    ], CoreChronoComponent.prototype, "running", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreChronoComponent.prototype, "startTime", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreChronoComponent.prototype, "endTime", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Boolean)
    ], CoreChronoComponent.prototype, "reset", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreChronoComponent.prototype, "onEnd", void 0);
    CoreChronoComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-chrono',
            template: '<span>{{ time / 1000 | coreSecondsToHMS }}</span>'
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["j" /* ChangeDetectorRef */]])
    ], CoreChronoComponent);
    return CoreChronoComponent;
}());

//# sourceMappingURL=chrono.js.map

/***/ }),
/* 1062 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreLocalFileComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_file__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_mimetype__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_text__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_moment__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_moment__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








/**
 * Component to handle a local file. Only files inside the app folder can be managed.
 *
 * Shows the file name, icon (depending on extension), size and time modified.
 * Also, if managing is enabled it will also show buttons to rename and delete the file.
 */
var CoreLocalFileComponent = /** @class */ (function () {
    function CoreLocalFileComponent(mimeUtils, utils, translate, textUtils, fileProvider, domUtils) {
        this.mimeUtils = mimeUtils;
        this.utils = utils;
        this.translate = translate;
        this.textUtils = textUtils;
        this.fileProvider = fileProvider;
        this.domUtils = domUtils;
        this.newFileName = '';
        this.onDelete = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
        this.onRename = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
        this.onClick = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
    }
    /**
     * Component being initialized.
     */
    CoreLocalFileComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.manage = this.utils.isTrueOrOne(this.manage);
        // Let's calculate the relative path for the file.
        this.relativePath = this.fileProvider.removeBasePath(this.file.toURL());
        if (!this.relativePath) {
            // Didn't find basePath, use fullPath but if the user tries to manage the file it'll probably fail.
            this.relativePath = this.file.fullPath;
        }
        this.loadFileBasicData();
        // Get the size and timemodified.
        this.fileProvider.getMetadata(this.file).then(function (metadata) {
            if (metadata.size >= 0) {
                _this.size = _this.textUtils.bytesToSize(metadata.size, 2);
            }
            _this.timemodified = __WEBPACK_IMPORTED_MODULE_7_moment__(metadata.modificationTime).format('LLL');
        });
    };
    /**
     * Load the basic data for the file.
     */
    CoreLocalFileComponent.prototype.loadFileBasicData = function () {
        this.fileName = this.file.name;
        this.fileIcon = this.mimeUtils.getFileIcon(this.file.name);
        this.fileExtension = this.mimeUtils.getFileExtension(this.file.name);
    };
    /**
     * File clicked.
     *
     * @param {Event} e Click event.
     */
    CoreLocalFileComponent.prototype.fileClicked = function (e) {
        e.preventDefault();
        e.stopPropagation();
        if (this.utils.isTrueOrOne(this.overrideClick) && this.onClick.observers.length) {
            this.onClick.emit();
        }
        else {
            this.utils.openFile(this.file.toURL());
        }
    };
    /**
     * Activate the edit mode.
     *
     * @param {Event} e Click event.
     */
    CoreLocalFileComponent.prototype.activateEdit = function (e) {
        e.preventDefault();
        e.stopPropagation();
        this.editMode = true;
        this.newFileName = this.file.name;
        // @todo For some reason core-auto-focus isn't working right. Focus the input manually.
        // $timeout(function() {
        //     $mmUtil.focusElement(element[0].querySelector('input'));
        // });
    };
    /**
     * Rename the file.
     *
     * @param {string} newName New name.
     */
    CoreLocalFileComponent.prototype.changeName = function (newName) {
        var _this = this;
        if (newName == this.file.name) {
            // Name hasn't changed, stop.
            this.editMode = false;
            return;
        }
        var modal = this.domUtils.showModalLoading(), fileAndDir = this.fileProvider.getFileAndDirectoryFromPath(this.relativePath), newPath = this.textUtils.concatenatePaths(fileAndDir.directory, newName);
        // Check if there's a file with this name.
        this.fileProvider.getFile(newPath).then(function () {
            // There's a file with this name, show error and stop.
            _this.domUtils.showErrorModal('core.errorfileexistssamename', true);
        }).catch(function () {
            // File doesn't exist, move it.
            return _this.fileProvider.moveFile(_this.relativePath, newPath).then(function (fileEntry) {
                _this.editMode = false;
                _this.file = fileEntry;
                _this.loadFileBasicData();
                _this.onRename.emit({ file: _this.file });
            }).catch(function () {
                _this.domUtils.showErrorModal('core.errorrenamefile', true);
            });
        }).finally(function () {
            modal.dismiss();
        });
    };
    /**
     * Delete the file.
     *
     * @param {Event} e Click event.
     */
    CoreLocalFileComponent.prototype.deleteFile = function (e) {
        var _this = this;
        e.preventDefault();
        e.stopPropagation();
        // Ask confirmation.
        this.domUtils.showConfirm(this.translate.instant('core.confirmdeletefile')).then(function () {
            var modal = _this.domUtils.showModalLoading();
            _this.fileProvider.removeFile(_this.relativePath).then(function () {
                _this.onDelete.emit();
            }).catch(function () {
                _this.domUtils.showErrorModal('core.errordeletefile', true);
            }).finally(function () {
                modal.dismiss();
            });
        }).catch(function () {
            // User cancelled.
        });
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreLocalFileComponent.prototype, "file", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreLocalFileComponent.prototype, "manage", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreLocalFileComponent.prototype, "overrideClick", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreLocalFileComponent.prototype, "onDelete", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreLocalFileComponent.prototype, "onRename", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreLocalFileComponent.prototype, "onClick", void 0);
    CoreLocalFileComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-local-file',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/components/local-file/local-file.html"*/'<a ion-item text-wrap class="item-media" (click)="fileClicked($event)" detail-none>\n    <img [src]="fileIcon" alt="{{fileExtension}}" role="presentation" item-start />\n\n    <!-- File name and edit button (if editable). -->\n    <p *ngIf="!editMode" class="core-text-with-icon-right">\n        {{fileName}}\n        <a ion-button icon-only clear *ngIf="manage" (click)="activateEdit($event)" [attr.aria-label]="\'core.edit\' | translate">\n            <ion-icon name="create" ios="md-create"></ion-icon>\n        </a>\n    </p>\n\n    <!-- Form to edit the file\'s name. -->\n    <form *ngIf="editMode" (ngSubmit)="changeName(newFileName)">\n        <ion-input type="text" name="filename" [(ngModel)]="newFileName" [placeholder]="\'core.filename\' | translate" autocapitalize="none" autocorrect="off" (click)="$event.stopPropagation()" [core-auto-focus]></ion-input>\n        <button type="submit" ion-button icon-only clear class="core-button-icon-small" [attr.aria-label]="\'core.save\' | translate">\n            <ion-icon name="checkmark"></ion-icon>\n        </button>\n    </form>\n\n    <!-- More data about the file. -->\n    <p *ngIf="size">{{ size }}</p>\n    <p *ngIf="timemodified">{{ timemodified }}</p>\n\n    <div class="buttons" item-end *ngIf="manage">\n        <button ion-button clear icon-only (click)="deleteFile($event)" [attr.aria-label]="\'core.delete\' | translate" color="danger">\n            <ion-icon name="trash"></ion-icon>\n        </button>\n    </div>\n</a>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/components/local-file/local-file.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_utils_mimetype__["a" /* CoreMimetypeUtilsProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_5__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_file__["a" /* CoreFileProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__["a" /* CoreDomUtilsProvider */]])
    ], CoreLocalFileComponent);
    return CoreLocalFileComponent;
}());

//# sourceMappingURL=local-file.js.map

/***/ }),
/* 1063 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSitePickerComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_text__ = __webpack_require__(13);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Component to display a site selector. It will display a select with the list of sites. If the selected site changes,
 * an output will be emitted with the site ID.
 *
 * Example usage:
 * <core-site-picker (siteSelected)="changeSite($event)"></core-site-picker>
 */
var CoreSitePickerComponent = /** @class */ (function () {
    function CoreSitePickerComponent(translate, sitesProvider, textUtils) {
        this.translate = translate;
        this.sitesProvider = sitesProvider;
        this.textUtils = textUtils;
        this.siteSelected = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
    }
    CoreSitePickerComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.selectedSite = this.initialSite || this.sitesProvider.getCurrentSiteId();
        // Load the sites.
        this.sitesProvider.getSites().then(function (sites) {
            var promises = [];
            sites.forEach(function (site) {
                // Format the site name.
                promises.push(_this.textUtils.formatText(site.siteName, true, true).catch(function () {
                    return site.siteName;
                }).then(function (formatted) {
                    site.fullNameAndSiteName = _this.translate.instant('core.fullnameandsitename', { fullname: site.fullName, sitename: formatted });
                }));
            });
            return Promise.all(promises).then(function () {
                _this.sites = sites;
            });
        });
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreSitePickerComponent.prototype, "initialSite", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreSitePickerComponent.prototype, "siteSelected", void 0);
    CoreSitePickerComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-site-picker',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/components/site-picker/site-picker.html"*/'<ion-item>\n    <ion-label>{{ \'core.site\' | translate }}</ion-label>\n    <ion-select [(ngModel)]="selectedSite" (ngModelChange)="siteSelected.emit(selectedSite)" interface="popover">\n        <ion-option *ngFor="let site of sites" [value]="site.id">{{ site.fullNameAndSiteName }}</ion-option>\n    </ion-select>\n</ion-item>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/components/site-picker/site-picker.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_utils_text__["a" /* CoreTextUtilsProvider */]])
    ], CoreSitePickerComponent);
    return CoreSitePickerComponent;
}());

//# sourceMappingURL=site-picker.js.map

/***/ }),
/* 1064 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreTabComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__tabs__ = __webpack_require__(588);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__ = __webpack_require__(10);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * A tab to use inside core-tabs. The content of this tab will be displayed when the tab is selected.
 *
 * You must provide either a title or an icon for the tab.
 *
 * The tab content MUST be surrounded by ng-template. This component uses ngTemplateOutlet instead of ng-content because the
 * latter executes all the code immediately. This means that all the tabs would be initialized as soon as your view is
 * loaded, leading to performance issues.
 *
 * Example usage:
 *
 * <core-tabs selectedIndex="1">
 *     <core-tab [title]="'core.courses.timeline' | translate" (ionSelect)="switchTab('timeline')">
 *         <ng-template> <!-- This ng-template is required. -->
 *             <!-- Tab contents. -->
 *         </ng-template>
 *     </core-tab>
 * </core-tabs>
 */
var CoreTabComponent = /** @class */ (function () {
    function CoreTabComponent(tabs, element, domUtils) {
        this.tabs = tabs;
        this.domUtils = domUtils;
        this.enabled = true; // Whether the tab is enabled.
        this.show = true; // Whether the tab should be shown.
        this.ionSelect = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
        this.loaded = false;
        this.element = element.nativeElement;
    }
    /**
     * Component being initialized.
     */
    CoreTabComponent.prototype.ngOnInit = function () {
        this.tabs.addTab(this);
    };
    /**
     * Component destroyed.
     */
    CoreTabComponent.prototype.ngOnDestroy = function () {
        this.tabs.removeTab(this);
    };
    /**
     * Select tab.
     */
    CoreTabComponent.prototype.selectTab = function () {
        var _this = this;
        this.element.classList.add('selected');
        this.loaded = true;
        this.ionSelect.emit(this);
        this.showHideNavBarButtons(true);
        // Setup tab scrolling.
        setTimeout(function () {
            if (_this.scroll) {
                _this.scroll.getScrollElement().onscroll = function (e) {
                    _this.tabs.showHideTabs(e);
                };
            }
        }, 1);
    };
    /**
     * Unselect tab.
     */
    CoreTabComponent.prototype.unselectTab = function () {
        this.element.classList.remove('selected');
        this.showHideNavBarButtons(false);
    };
    /**
     * Get all child core-navbar-buttons. We need to use querySelectorAll because ContentChildren doesn't work with ng-template.
     * https://github.com/angular/angular/issues/14842
     *
     * @return {CoreNavBarButtonsComponent[]} List of component instances.
     */
    CoreTabComponent.prototype.getChildrenNavBarButtons = function () {
        var elements = this.element.querySelectorAll('core-navbar-buttons'), instances = [];
        for (var i = 0; i < elements.length; i++) {
            var instance = this.domUtils.getInstanceByElement(elements[i]);
            if (instance) {
                instances.push(instance);
            }
        }
        return instances;
    };
    /**
     * Show all hide all children navbar buttons.
     *
     * @param {boolean} show Whether to show or hide the buttons.
     */
    CoreTabComponent.prototype.showHideNavBarButtons = function (show) {
        var instances = this.getChildrenNavBarButtons();
        for (var i in instances) {
            instances[i].forceHide(!show);
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreTabComponent.prototype, "title", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreTabComponent.prototype, "icon", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreTabComponent.prototype, "badge", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreTabComponent.prototype, "badgeStyle", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreTabComponent.prototype, "enabled", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreTabComponent.prototype, "show", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreTabComponent.prototype, "id", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreTabComponent.prototype, "ionSelect", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["q" /* ContentChild */])(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_6" /* TemplateRef */]),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["_6" /* TemplateRef */])
    ], CoreTabComponent.prototype, "template", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["q" /* ContentChild */])(__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["e" /* Content */]),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["e" /* Content */])
    ], CoreTabComponent.prototype, "scroll", void 0);
    CoreTabComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-tab',
            template: '<ng-container *ngIf="loaded" [ngTemplateOutlet]="template"></ng-container>'
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__tabs__["a" /* CoreTabsComponent */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__["a" /* CoreDomUtilsProvider */]])
    ], CoreTabComponent);
    return CoreTabComponent;
}());

//# sourceMappingURL=tab.js.map

/***/ }),
/* 1065 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreRichTextEditorComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__angular_forms__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ionic_native_keyboard__ = __webpack_require__(226);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Directive to display a rich text editor if enabled.
 *
 * If enabled, this directive will show a rich text editor. Otherwise it'll show a regular textarea.
 *
 * This directive requires an OBJECT model. The text written in the editor or textarea will be stored inside
 * a "text" property in that object. This is to ensure 2-way data-binding, since using a string as a model
 * could be easily broken.
 *
 * Example:
 * <core-rich-text-editor item-content [control]="control" [placeholder]="field.name"></core-rich-text-editor>
 *
 * In the example above, the text written in the editor will be stored in newpost.text.
 */
var CoreRichTextEditorComponent = /** @class */ (function () {
    function CoreRichTextEditorComponent(domUtils, keyboard) {
        this.domUtils = domUtils;
        this.keyboard = keyboard;
        // Based on: https://github.com/judgewest2000/Ionic3RichText/
        // @todo: Resize, images, anchor button, fullscreen...
        this.placeholder = ''; // Placeholder to set in textarea.
        this.rteEnabled = false;
        this.uniqueId = "rte{Math.floor(Math.random() * 1000000)}";
        this.contentChanged = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
    }
    /**
     * Init editor
     */
    CoreRichTextEditorComponent.prototype.ngAfterContentInit = function () {
        var _this = this;
        this.domUtils.isRichTextEditorEnabled().then(function (enabled) {
            _this.rteEnabled = !!enabled;
        });
        // Setup the editor.
        this.editorElement = this.editor.nativeElement;
        this.editorElement.innerHTML = this.control.value;
        this.textarea.value = this.control.value;
        this.control.setValue(this.control.value);
        this.editorElement.onchange = this.onChange.bind(this);
        this.editorElement.onkeyup = this.onChange.bind(this);
        this.editorElement.onpaste = this.onChange.bind(this);
        this.editorElement.oninput = this.onChange.bind(this);
        // Setup button actions.
        var buttons = this.decorate.nativeElement.getElementsByTagName('button');
        var _loop_1 = function (i) {
            var button = buttons[i];
            var command = button.getAttribute('data-command');
            if (command) {
                if (command.includes('|')) {
                    var parameter_1 = command.split('|')[1];
                    command = command.split('|')[0];
                    button.addEventListener('click', function ($event) {
                        _this.buttonAction($event, command, parameter_1);
                    });
                }
                else {
                    button.addEventListener('click', function ($event) {
                        _this.buttonAction($event, command);
                    });
                }
            }
        };
        for (var i = 0; i < buttons.length; i++) {
            _loop_1(i);
        }
    };
    /**
     * On change function to sync with form data.
     *
     * @param {Event} $event The event.
     */
    CoreRichTextEditorComponent.prototype.onChange = function ($event) {
        if (this.rteEnabled) {
            if (this.isNullOrWhiteSpace(this.editorElement.innerText)) {
                this.clearText();
            }
            else {
                this.control.setValue(this.editorElement.innerHTML);
            }
        }
        else {
            if (this.isNullOrWhiteSpace(this.textarea.value)) {
                this.clearText();
            }
            else {
                this.control.setValue(this.textarea.value);
            }
        }
        this.contentChanged.emit(this.control.value);
    };
    /**
     * Toggle from rte editor to textarea syncing values.
     *
     * @param {Event} $event The event.
     */
    CoreRichTextEditorComponent.prototype.toggleEditor = function ($event) {
        var _this = this;
        $event.preventDefault();
        $event.stopPropagation();
        if (this.isNullOrWhiteSpace(this.control.value)) {
            this.clearText();
        }
        else {
            this.editorElement.innerHTML = this.control.value;
            this.textarea.value = this.control.value;
        }
        this.rteEnabled = !this.rteEnabled;
        // Set focus and cursor at the end.
        setTimeout(function () {
            if (_this.rteEnabled) {
                _this.editorElement.focus();
                var range = document.createRange();
                range.selectNodeContents(_this.editorElement);
                range.collapse(false);
                var sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(range);
            }
            else {
                _this.textarea.setFocus();
            }
            setTimeout(function () {
                _this.keyboard.show();
            }, 1);
        }, 1);
    };
    /**
     * Check if text is empty.
     * @param {string} value text
     */
    CoreRichTextEditorComponent.prototype.isNullOrWhiteSpace = function (value) {
        if (value == null || typeof value == 'undefined') {
            return true;
        }
        value = value.replace(/[\n\r]/g, '');
        value = value.split(' ').join('');
        return value.length === 0;
    };
    /**
     * Clear the text.
     */
    CoreRichTextEditorComponent.prototype.clearText = function () {
        this.editorElement.innerHTML = '<p></p>';
        this.textarea.value = '';
        this.control.setValue(null);
    };
    /**
     * Execute an action over the selected text.
     *  API docs: https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand
     *
     * @param {any} $event       Event data
     * @param {string} command   Command to execute.
     * @param {any} [parameters] Parameters of the command.
     */
    CoreRichTextEditorComponent.prototype.buttonAction = function ($event, command, parameters) {
        if (parameters === void 0) { parameters = null; }
        $event.preventDefault();
        $event.stopPropagation();
        document.execCommand(command, false, parameters);
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreRichTextEditorComponent.prototype, "placeholder", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_3__angular_forms__["b" /* FormControl */])
    ], CoreRichTextEditorComponent.prototype, "control", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreRichTextEditorComponent.prototype, "contentChanged", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])('editor'),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */])
    ], CoreRichTextEditorComponent.prototype, "editor", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])('textarea'),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["q" /* TextInput */])
    ], CoreRichTextEditorComponent.prototype, "textarea", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_9" /* ViewChild */])('decorate'),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */])
    ], CoreRichTextEditorComponent.prototype, "decorate", void 0);
    CoreRichTextEditorComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-rich-text-editor',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/components/rich-text-editor/rich-text-editor.html"*/'<div [hidden]="!rteEnabled">\n    <div #editor contenteditable="true" class="core-rte-editor" tappable [attr.data-placeholder-text]="placeholder">\n    </div>\n\n    <!-- https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand -->\n    <div #decorate class="formatOptions">\n        <button data-command="bold"><strong>B</strong></button>\n        <button data-command="italic"><i>I</i></button>\n        <button data-command="underline"><u>U</u></button>\n        <button data-command="formatBlock|<p>">Normal</button>\n        <button data-command="formatBlock|<h1>">H1</button>\n        <button data-command="formatBlock|<h2>">H2</button>\n        <button data-command="formatBlock|<h3>">H3</button>\n        <button data-command="formatBlock|<pre>">Pre</button>\n        <button data-command="insertOrderedList">OL</button>\n        <button data-command="insertUnorderedList">UL</button>\n        <button data-command="removeFormat">Tx</button>\n        <button (click)="toggleEditor($event)">Toggle Editor</button>\n    </div>\n</div>\n\n<div [hidden]="rteEnabled">\n    <ion-textarea #textarea class="core-textarea" [placeholder]="placeholder" ngControl="control" (ionChange)="onChange($event)"></ion-textarea>\n    <div class="formatOptions">\n        <button tappable (click)="toggleEditor($event)">Toggle Editor</button>\n    </div>\n</div>\n\n\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/components/rich-text-editor/rich-text-editor.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_4__ionic_native_keyboard__["a" /* Keyboard */]])
    ], CoreRichTextEditorComponent);
    return CoreRichTextEditorComponent;
}());

//# sourceMappingURL=rich-text-editor.js.map

/***/ }),
/* 1066 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreNavBarButtonsComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__ = __webpack_require__(10);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Component to add buttons to the app's header without having to place them inside the header itself. This is meant for
 * pages that are loaded inside a sub ion-nav, so they don't have a header.
 *
 * If this component indicates a position (start/end), the buttons will only be added if the header has some buttons in that
 * position. If no start/end is specified, then the buttons will be added to the first <ion-buttons> found in the header.
 *
 * You can use the [hidden] input to hide all the inner buttons if a certain condition is met.
 *
 * IMPORTANT: Do not use *ngIf in the buttons inside this component, it can cause problems. Please use [hidden] instead.
 *
 * Example usage:
 *
 * <core-navbar-buttons end>
 *     <button ion-button icon-only [hidden]="!buttonShown" [attr.aria-label]="Do something" (click)="action()">
 *         <ion-icon name="funnel"></ion-icon>
 *     </button>
 * </core-navbar-buttons>
 */
var CoreNavBarButtonsComponent = /** @class */ (function () {
    function CoreNavBarButtonsComponent(element, logger, domUtils) {
        this.domUtils = domUtils;
        this.BUTTON_HIDDEN_CLASS = 'core-navbar-button-hidden';
        this.forceHidden = false;
        this.element = element.nativeElement;
        this.logger = logger.getInstance('CoreNavBarButtonsComponent');
        this.instanceId = this.domUtils.storeInstanceByElement(this.element, this);
    }
    Object.defineProperty(CoreNavBarButtonsComponent.prototype, "hidden", {
        // If the hidden input is true, hide all buttons.
        set: function (value) {
            this._hidden = value;
            this.showHideAllElements();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CoreNavBarButtonsComponent.prototype, "buttons", {
        // Get all the ion-buttons inside this directive and apply the role bar-button.
        set: function (buttons) {
            buttons.forEach(function (button) {
                button.setRole('bar-button');
            });
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Component being initialized.
     */
    CoreNavBarButtonsComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.searchHeader().then(function (header) {
            if (header) {
                // Search the right buttons container (start, end or any).
                var selector = 'ion-buttons', buttonsContainer = void 0;
                if (_this.element.hasAttribute('start')) {
                    selector += '[start]';
                }
                else if (_this.element.hasAttribute('end')) {
                    selector += '[end]';
                }
                buttonsContainer = header.querySelector(selector);
                if (buttonsContainer) {
                    _this.mergeContextMenus(buttonsContainer);
                    _this.movedChildren = _this.domUtils.moveChildren(_this.element, buttonsContainer);
                    _this.showHideAllElements();
                }
                else {
                    _this.logger.warn('The header was found, but it didn\'t have the right ion-buttons.', selector);
                }
            }
        }).catch(function () {
            // Header not found.
            _this.logger.warn('Header not found.');
        });
    };
    /**
     * Force or unforce hiding all buttons. If this is true, it will override the "hidden" input.
     *
     * @param {boolean} value The value to set.
     */
    CoreNavBarButtonsComponent.prototype.forceHide = function (value) {
        this.forceHidden = value;
        this.showHideAllElements();
    };
    /**
     * If both button containers have a context menu, merge them into a single one.
     *
     * @param {HTMLElement} buttonsContainer The container where the buttons will be moved.
     */
    CoreNavBarButtonsComponent.prototype.mergeContextMenus = function (buttonsContainer) {
        // Check if both button containers have a context menu.
        var mainContextMenu = buttonsContainer.querySelector('core-context-menu');
        if (!mainContextMenu) {
            return;
        }
        var secondaryContextMenu = this.element.querySelector('core-context-menu');
        if (!secondaryContextMenu) {
            return;
        }
        // Both containers have a context menu. Merge them to prevent having 2 menus at the same time.
        var mainContextMenuInstance = this.domUtils.getInstanceByElement(mainContextMenu), secondaryContextMenuInstance = this.domUtils.getInstanceByElement(secondaryContextMenu);
        if (mainContextMenuInstance && secondaryContextMenuInstance) {
            this.mergedContextMenu = secondaryContextMenuInstance;
            this.mergedContextMenu.mergeContextMenus(mainContextMenuInstance);
            // Remove the empty context menu from the DOM.
            secondaryContextMenu.parentElement.removeChild(secondaryContextMenu);
        }
    };
    /**
     * Search the ion-header where the buttons should be added.
     *
     * @param {number} [retries] Number of retries so far.
     * @return {Promise<HTMLElement>} Promise resolved with the header element.
     */
    CoreNavBarButtonsComponent.prototype.searchHeader = function (retries) {
        var _this = this;
        if (retries === void 0) { retries = 0; }
        var parentPage = this.element;
        while (parentPage) {
            if (!parentPage.parentElement) {
                // No parent, stop.
                break;
            }
            // Get the next parent page.
            parentPage = this.domUtils.closest(parentPage.parentElement, '.ion-page');
            if (parentPage) {
                // Check if the page has a header. If it doesn't, search the next parent page.
                var header = this.searchHeaderInPage(parentPage);
                if (header && getComputedStyle(header, null).display != 'none') {
                    return Promise.resolve(header);
                }
            }
        }
        // Header not found.
        if (retries < 5) {
            // If the component or any of its parent is inside a ng-content or similar it can be detached when it's initialized.
            // Try again after a while.
            return new Promise(function (resolve, reject) {
                setTimeout(function () {
                    _this.searchHeader(retries + 1).then(resolve, reject);
                }, 200);
            });
        }
        // We've waited enough time, reject.
        return Promise.reject(null);
    };
    /**
     * Search ion-header inside a page. The header should be a direct child.
     *
     * @param  {HTMLElement} page Page to search in.
     * @return {HTMLElement} Header element. Undefined if not found.
     */
    CoreNavBarButtonsComponent.prototype.searchHeaderInPage = function (page) {
        for (var i = 0; i < page.children.length; i++) {
            var child = page.children[i];
            if (child.tagName == 'ION-HEADER') {
                return child;
            }
        }
    };
    /**
     * Show or hide all the elements.
     */
    CoreNavBarButtonsComponent.prototype.showHideAllElements = function () {
        var _this = this;
        // Show or hide all moved children.
        if (this.movedChildren) {
            this.movedChildren.forEach(function (child) {
                _this.showHideElement(child);
            });
        }
        // Show or hide all the context menu items that were merged to another context menu.
        if (this.mergedContextMenu) {
            if (this.forceHidden || this._hidden) {
                this.mergedContextMenu.removeMergedItems();
            }
            else {
                this.mergedContextMenu.restoreMergedItems();
            }
        }
    };
    /**
     * Show or hide an element.
     *
     * @param {Node} element Element to show or hide.
     */
    CoreNavBarButtonsComponent.prototype.showHideElement = function (element) {
        // Check if it's an HTML Element
        if (element instanceof Element) {
            if (this.forceHidden || this._hidden) {
                element.classList.add(this.BUTTON_HIDDEN_CLASS);
            }
            else {
                element.classList.remove(this.BUTTON_HIDDEN_CLASS);
            }
        }
    };
    /**
     * Component destroyed.
     */
    CoreNavBarButtonsComponent.prototype.ngOnDestroy = function () {
        this.domUtils.removeInstanceById(this.instanceId);
        // This component was destroyed, remove all the buttons that were moved.
        // The buttons can be moved outside of the current page, that's why we need to manually destroy them.
        // There's no need to destroy context menu items that were merged because they weren't moved from their DOM position.
        if (this.movedChildren) {
            this.movedChildren.forEach(function (child) {
                if (child.parentElement) {
                    child.parentElement.removeChild(child);
                }
            });
        }
        if (this.mergedContextMenu) {
            this.mergedContextMenu.removeMergedItems();
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])('hidden'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], CoreNavBarButtonsComponent.prototype, "hidden", null);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["r" /* ContentChildren */])(__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["d" /* Button */]),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["T" /* QueryList */]),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["T" /* QueryList */]])
    ], CoreNavBarButtonsComponent.prototype, "buttons", null);
    CoreNavBarButtonsComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-navbar-buttons',
            template: '<ng-content></ng-content>'
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_2__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__["a" /* CoreDomUtilsProvider */]])
    ], CoreNavBarButtonsComponent);
    return CoreNavBarButtonsComponent;
}());

//# sourceMappingURL=navbar-buttons.js.map

/***/ }),
/* 1067 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSendMessageFormComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_text__ = __webpack_require__(13);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Component to display a "send message form".
 *
 * @description
 * This component will display a standalone send message form in order to have a better UX.
 *
 * Example usage:
 * <core-send-message-form (onSubmit)="sendMessage($event)" [placeholder]="'core.messages.newmessage' | translate"
 * [show-keyboard]="showKeyboard"></core-send-message-form>
 */
var CoreSendMessageFormComponent = /** @class */ (function () {
    function CoreSendMessageFormComponent(utils, textUtils) {
        this.utils = utils;
        this.textUtils = textUtils;
        this.placeholder = ''; // Placeholder for the input area.
        this.showKeyboard = false; // If keyboard is shown or not.
        this.onSubmit = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
        this.onResize = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
    }
    CoreSendMessageFormComponent.prototype.ngOnInit = function () {
        this.showKeyboard = this.utils.isTrueOrOne(this.showKeyboard);
    };
    /**
     * Form submitted.
     * @param {any} $event Form submit
     */
    CoreSendMessageFormComponent.prototype.submitForm = function ($event) {
        var value = this.message.trim();
        $event.target.reset();
        // Focus again on textarea.
        $event.target[0].focus();
        if (!value) {
            // Silent error.
            return;
        }
        value = this.textUtils.replaceNewLines(value, '<br>');
        this.onSubmit.emit(value);
    };
    /**
     * Textarea resized.
     */
    CoreSendMessageFormComponent.prototype.textareaResized = function () {
        this.onResize.emit();
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreSendMessageFormComponent.prototype, "placeholder", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreSendMessageFormComponent.prototype, "showKeyboard", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreSendMessageFormComponent.prototype, "onSubmit", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreSendMessageFormComponent.prototype, "onResize", void 0);
    CoreSendMessageFormComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-send-message-form',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/components/send-message-form/send-message-form.html"*/'<form (ngSubmit)="submitForm($event)">\n    <textarea class="core-send-message-input" [core-auto-focus]="showKeyboard" [placeholder]="placeholder" rows="1" core-auto-rows [(ngModel)]="message" name="message" (onResize)="textareaResized()"></textarea>\n    <ion-buttons end>\n        <button ion-button icon-only clear="true" type="submit" [disabled]="!message" [attr.aria-label]="\'core.send\' | translate">\n            <ion-icon name="send" color="dark"></ion-icon>\n        </button>\n    </ion-buttons>\n</form>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/components/send-message-form/send-message-form.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_text__["a" /* CoreTextUtilsProvider */]])
    ], CoreSendMessageFormComponent);
    return CoreSendMessageFormComponent;
}());

//# sourceMappingURL=send-message-form.js.map

/***/ }),
/* 1068 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseModuleComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_events__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_helper__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_module_prefetch_delegate__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__constants__ = __webpack_require__(22);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};








/**
 * Component to display a module entry in a list of modules.
 *
 * Example usage:
 *
 * <core-course-module [module]="module" [courseId]="courseId" (completionChanged)="onCompletionChange()"></core-course-module>
 */
var CoreCourseModuleComponent = /** @class */ (function () {
    function CoreCourseModuleComponent(navCtrl, prefetchDelegate, domUtils, courseHelper, eventsProvider, sitesProvider) {
        this.navCtrl = navCtrl;
        this.prefetchDelegate = prefetchDelegate;
        this.domUtils = domUtils;
        this.courseHelper = courseHelper;
        this.eventsProvider = eventsProvider;
        this.sitesProvider = sitesProvider;
        this.completionChanged = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
    }
    Object.defineProperty(CoreCourseModuleComponent.prototype, "enabled", {
        set: function (value) {
            var _this = this;
            this.downloadEnabled = value;
            if (this.module.handlerData.showDownloadButton && this.downloadEnabled && !this.statusObserver) {
                // First time that the download is enabled. Initialize the data.
                this.spinner = true; // Show spinner while calculating the status.
                this.prefetchHandler = this.prefetchDelegate.getPrefetchHandlerFor(this.module);
                // Get current status to decide which icon should be shown.
                this.prefetchDelegate.getModuleStatus(this.module, this.courseId).then(this.showStatus.bind(this));
                // Listen for changes on this module status.
                this.statusObserver = this.eventsProvider.on(__WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */].PACKAGE_STATUS_CHANGED, function (data) {
                    if (data.componentId === _this.module.id && _this.prefetchHandler &&
                        data.component === _this.prefetchHandler.component) {
                        _this.showStatus(data.status);
                    }
                }, this.sitesProvider.getCurrentSiteId());
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Component being initialized.
     */
    CoreCourseModuleComponent.prototype.ngOnInit = function () {
        // Handler data must be defined. If it isn't, set it to prevent errors.
        if (this.module && !this.module.handlerData) {
            this.module.handlerData = {};
        }
    };
    /**
     * Function called when the module is clicked.
     *
     * @param {Event} event Click event.
     */
    CoreCourseModuleComponent.prototype.moduleClicked = function (event) {
        if (this.module.uservisible !== false && this.module.handlerData.action) {
            this.module.handlerData.action(event, this.navCtrl, this.module, this.courseId);
        }
    };
    /**
     * Function called when a button is clicked.
     *
     * @param {Event} event Click event.
     * @param {CoreCourseModuleHandlerButton} button The clicked button.
     */
    CoreCourseModuleComponent.prototype.buttonClicked = function (event, button) {
        if (button && button.action) {
            event.preventDefault();
            event.stopPropagation();
            button.action(event, this.navCtrl, this.module, this.courseId);
        }
    };
    /**
     * Download the module.
     *
     * @param {Event} event Click event.
     * @param {boolean} refresh Whether it's refreshing.
     */
    CoreCourseModuleComponent.prototype.download = function (event, refresh) {
        var _this = this;
        event.preventDefault();
        event.stopPropagation();
        if (!this.prefetchHandler) {
            return;
        }
        // Show spinner since this operation might take a while.
        this.spinner = true;
        // Get download size to ask for confirm if it's high.
        this.prefetchHandler.getDownloadSize(module, this.courseId).then(function (size) {
            _this.courseHelper.prefetchModule(_this.prefetchHandler, _this.module, size, _this.courseId, refresh).catch(function (error) {
                // Error or cancelled.
                _this.spinner = false;
            });
        }).catch(function (error) {
            // Error getting download size, hide spinner.
            _this.spinner = false;
            _this.domUtils.showErrorModalDefault(error, 'core.errordownloading', true);
        });
    };
    /**
     * Show download buttons according to module status.
     *
     * @param {string} status Module status.
     */
    CoreCourseModuleComponent.prototype.showStatus = function (status) {
        if (status) {
            this.spinner = status === __WEBPACK_IMPORTED_MODULE_7__constants__["a" /* CoreConstants */].DOWNLOADING;
            this.showDownload = status === __WEBPACK_IMPORTED_MODULE_7__constants__["a" /* CoreConstants */].NOT_DOWNLOADED;
            this.showRefresh = status === __WEBPACK_IMPORTED_MODULE_7__constants__["a" /* CoreConstants */].OUTDATED ||
                (!this.prefetchDelegate.canCheckUpdates() && status === __WEBPACK_IMPORTED_MODULE_7__constants__["a" /* CoreConstants */].DOWNLOADED);
        }
    };
    /**
     * Component destroyed.
     */
    CoreCourseModuleComponent.prototype.ngOnDestroy = function () {
        this.statusObserver && this.statusObserver.off();
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreCourseModuleComponent.prototype, "module", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Number)
    ], CoreCourseModuleComponent.prototype, "courseId", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])('downloadEnabled'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], CoreCourseModuleComponent.prototype, "enabled", null);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreCourseModuleComponent.prototype, "completionChanged", void 0);
    CoreCourseModuleComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-course-module',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/core/course/components/module/module.html"*/'<a *ngIf="module && module.visibleoncoursepage !== 0" ion-item text-wrap id="core-course-module-{{module.id}}" class="core-course-module-handler {{module.handlerData.class}}" (click)="moduleClicked($event)" [ngClass]="{\'item-media\': module.handlerData.icon, \'core-not-clickable\': !module.handlerData.action || !module.uservisible === false, \'item-dimmed\': module.visible === 0 || module.uservisible === false}" title="{{ module.handlerData.title }}" detail-none>\n\n    <img item-start *ngIf="module.handlerData.icon" [src]="module.handlerData.icon" alt="" role="presentation" class="core-module-icon">\n    <div class="core-module-title">\n        <core-format-text [text]="module.handlerData.title"></core-format-text>\n\n        <!-- Buttons. -->\n        <div item-end *ngIf="module.uservisible !== false" class="buttons core-module-buttons" [ngClass]="{\'core-button-completion\': module.completionstatus}">\n            <!-- Module completion. -->\n            <core-course-module-completion *ngIf="module.completionstatus" [completion]="module.completionstatus" [moduleName]="module.name" (completionChanged)="completionChanged.emit()"></core-course-module-completion>\n\n            <div class="core-module-buttons-more">\n                <!-- Download button. -->\n                <button *ngIf="downloadEnabled && showDownload" [hidden]="spinner || module.handlerData.spinner" ion-button icon-only clear (click)="download($event, false)" color="dark" class="core-animate-show-hide" [attr.aria-label]="\'core.download\' | translate">\n                    <ion-icon name="cloud-download"></ion-icon>\n                </button>\n\n                <!-- Refresh button. -->\n                <button *ngIf="downloadEnabled && showRefresh" [hidden]="spinner || module.handlerData.spinner" ion-button icon-only clear (click)="download($event, true)" color="dark" class="core-animate-show-hide" [attr.aria-label]="\'core.refresh\' | translate">\n                    <ion-icon name="refresh"></ion-icon>\n                </button>\n\n                <!-- Buttons defined by the module handler. -->\n                <button ion-button icon-only clear *ngFor="let button of module.handlerData.buttons" [hidden]="button.hidden || spinner || module.handlerData.spinner" (click)="buttonClicked($event, button)" color="dark" class="core-animate-show-hide" [attr.aria-label]="button.label | translate">\n                    <ion-icon [name]="button.icon" [ios]="button.iosIcon || \'\'" [md]="button.mdIcon || \'\'"></ion-icon>\n                </button>\n\n                <!-- Spinner. -->\n                <ion-spinner *ngIf="spinner || module.handlerData.spinner" class="core-animate-show-hide"></ion-spinner>\n            </div>\n        </div>\n\n        <div *ngIf="module.visible === 0 || module.availabilityinfo">\n            <ion-badge item-end *ngIf="module.visible === 0">{{ \'core.course.hiddenfromstudents\' | translate }}</ion-badge>\n            <ion-badge item-end *ngIf="module.availabilityinfo"><core-format-text [text]="module.availabilityinfo"></core-format-text></ion-badge>\n        </div>\n    </div>\n    <core-format-text class="core-module-description" *ngIf="module.description" maxHeight="80" [text]="module.description"></core-format-text>\n</a>'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/core/course/components/module/module.html"*/
        }),
        __param(0, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["N" /* Optional */])()),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavController */], __WEBPACK_IMPORTED_MODULE_6__providers_module_prefetch_delegate__["a" /* CoreCourseModulePrefetchDelegate */],
            __WEBPACK_IMPORTED_MODULE_4__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_helper__["a" /* CoreCourseHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_sites__["a" /* CoreSitesProvider */]])
    ], CoreCourseModuleComponent);
    return CoreCourseModuleComponent;
}());

//# sourceMappingURL=module.js.map
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(595)(module)))

/***/ }),
/* 1069 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseModuleCompletionComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_text__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__core_user_providers_user__ = __webpack_require__(62);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






/**
 * Component to handle activity completion. It shows a checkbox with the current status, and allows manually changing
 * the completion if it's allowed.
 *
 * Example usage:
 *
 * <core-course-module-completion [completion]="module.completionstatus" [moduleName]="module.name"
 *     (completionChanged)="completionChanged()"></core-course-module-completion>
 */
var CoreCourseModuleCompletionComponent = /** @class */ (function () {
    function CoreCourseModuleCompletionComponent(textUtils, domUtils, translate, sitesProvider, userProvider) {
        this.textUtils = textUtils;
        this.domUtils = domUtils;
        this.translate = translate;
        this.sitesProvider = sitesProvider;
        this.userProvider = userProvider;
        this.completionChanged = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
    }
    /**
     * Detect changes on input properties.
     */
    CoreCourseModuleCompletionComponent.prototype.ngOnChanges = function (changes) {
        if (changes.completion && this.completion) {
            this.showStatus();
        }
    };
    /**
     * Completion clicked.
     *
     * @param {Event} e The click event.
     */
    CoreCourseModuleCompletionComponent.prototype.completionClicked = function (e) {
        var _this = this;
        if (this.completion) {
            if (typeof this.completion.cmid == 'undefined' || this.completion.tracking !== 1) {
                return;
            }
            e.preventDefault();
            e.stopPropagation();
            var modal_1 = this.domUtils.showModalLoading(), params = {
                cmid: this.completion.cmid,
                completed: this.completion.state === 1 ? 0 : 1
            }, currentSite = this.sitesProvider.getCurrentSite();
            currentSite.write('core_completion_update_activity_completion_status_manually', params).then(function (response) {
                if (!response.status) {
                    return Promise.reject(null);
                }
                _this.completionChanged.emit();
            }).catch(function (error) {
                _this.domUtils.showErrorModalDefault(error, 'core.errorchangecompletion', true);
            }).finally(function () {
                modal_1.dismiss();
            });
        }
    };
    /**
     * Set image and description to show as completion icon.
     */
    CoreCourseModuleCompletionComponent.prototype.showStatus = function () {
        var _this = this;
        var moduleName = this.moduleName || '';
        var langKey, image;
        if (this.completion.tracking === 1 && this.completion.state === 0) {
            image = 'completion-manual-n';
            langKey = 'core.completion-alt-manual-n';
        }
        else if (this.completion.tracking === 1 && this.completion.state === 1) {
            image = 'completion-manual-y';
            langKey = 'core.completion-alt-manual-y';
        }
        else if (this.completion.tracking === 2 && this.completion.state === 0) {
            image = 'completion-auto-n';
            langKey = 'core.completion-alt-auto-n';
        }
        else if (this.completion.tracking === 2 && this.completion.state === 1) {
            image = 'completion-auto-y';
            langKey = 'core.completion-alt-auto-y';
        }
        else if (this.completion.tracking === 2 && this.completion.state === 2) {
            image = 'completion-auto-pass';
            langKey = 'core.completion-alt-auto-pass';
        }
        else if (this.completion.tracking === 2 && this.completion.state === 3) {
            image = 'completion-auto-fail';
            langKey = 'core.completion-alt-auto-fail';
        }
        if (image) {
            if (this.completion.overrideby > 0) {
                image += '-override';
            }
            this.completionImage = 'assets/img/completion/' + image + '.svg';
        }
        if (moduleName) {
            this.textUtils.formatText(moduleName, true, true, 50).then(function (modNameFormatted) {
                var promise;
                if (_this.completion.overrideby > 0) {
                    langKey += '-override';
                    promise = _this.userProvider.getProfile(_this.completion.overrideby, _this.completion.courseId, true).then(function (profile) {
                        return {
                            overrideuser: profile.fullname,
                            modname: modNameFormatted
                        };
                    });
                }
                else {
                    promise = Promise.resolve(modNameFormatted);
                }
                return promise.then(function (translateParams) {
                    _this.completionDescription = _this.translate.instant(langKey, { $a: translateParams });
                });
            });
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreCourseModuleCompletionComponent.prototype, "completion", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreCourseModuleCompletionComponent.prototype, "moduleName", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreCourseModuleCompletionComponent.prototype, "completionChanged", void 0);
    CoreCourseModuleCompletionComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-course-module-completion',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/core/course/components/module-completion/module-completion.html"*/'<a *ngIf="completion" (click)="completionClicked($event)">\n    <img [src]="completionImage" [alt]="completionDescription" [title]="completionDescription">\n</a>'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/core/course/components/module-completion/module-completion.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_5__core_user_providers_user__["a" /* CoreUserProvider */]])
    ], CoreCourseModuleCompletionComponent);
    return CoreCourseModuleCompletionComponent;
}());

//# sourceMappingURL=module-completion.js.map

/***/ }),
/* 1070 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseModuleDescriptionComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

/**
 * Component to display the description of a module.
 *
 * This directive is meant to display a module description in a similar way throughout all the app.
 *
 * You can add a note at the right side of the description by using the 'note' attribute.
 *
 * You can also pass a component and componentId to be used in format-text.
 *
 * Module descriptions are shortened by default, allowing the user to see the full description by clicking in it.
 * If you want the whole description to be shown you can use the 'showFull' attribute.
 *
 * Example usage:
 *
 * <core-course-module-description [description]="myDescription"></core-course-module-description
 */
var CoreCourseModuleDescriptionComponent = /** @class */ (function () {
    function CoreCourseModuleDescriptionComponent() {
        // Nothing to do.
    }
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreCourseModuleDescriptionComponent.prototype, "description", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreCourseModuleDescriptionComponent.prototype, "note", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreCourseModuleDescriptionComponent.prototype, "component", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreCourseModuleDescriptionComponent.prototype, "componentId", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreCourseModuleDescriptionComponent.prototype, "showFull", void 0);
    CoreCourseModuleDescriptionComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-course-module-description',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/core/course/components/module-description/module-description.html"*/'<ion-card *ngIf="description">\n    <ion-item text-wrap>\n        <core-format-text [text]="description" [component]="component" [componentId]="componentId" [maxHeight]="showFull && showFull !== \'false\' ? 0 : 120" fullOnClick="true"></core-format-text>\n        <ion-note *ngIf="note" item-end>{{ note }}</ion-note>\n    </ion-item>\n</ion-card>'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/core/course/components/module-description/module-description.html"*/
        }),
        __metadata("design:paramtypes", [])
    ], CoreCourseModuleDescriptionComponent);
    return CoreCourseModuleDescriptionComponent;
}());

//# sourceMappingURL=module-description.js.map

/***/ }),
/* 1071 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModBookNavigationArrowsComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

/**
 * Component to navigate to previous or next chapter in a book.
 */
var AddonModBookNavigationArrowsComponent = /** @class */ (function () {
    function AddonModBookNavigationArrowsComponent() {
        this.action = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
    }
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], AddonModBookNavigationArrowsComponent.prototype, "previous", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], AddonModBookNavigationArrowsComponent.prototype, "next", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], AddonModBookNavigationArrowsComponent.prototype, "action", void 0);
    AddonModBookNavigationArrowsComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'addon-mod-book-navigation-arrows',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/addon/mod/book/components/navigation-arrows/navigation-arrows.html"*/'<ion-grid>\n    <ion-row>\n        <ion-col>\n            <a ion-button icon-only clear *ngIf="previous > 0" (click)="action.emit(previous)" title="{{ \'core.previous\' | translate }}">\n                <ion-icon name="arrow-back" md="ios-arrow-back"></ion-icon>\n            </a>\n        </ion-col>\n        <ion-col text-right>\n            <a ion-button icon-only clear *ngIf="next > 0" (click)="action.emit(next)" title="{{ \'core.next\' | translate }}">\n                <ion-icon name="arrow-forward" md="ios-arrow-forward"></ion-icon>\n            </a>\n        </ion-col>\n    </ion-row>\n</ion-grid>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/addon/mod/book/components/navigation-arrows/navigation-arrows.html"*/
        }),
        __metadata("design:paramtypes", [])
    ], AddonModBookNavigationArrowsComponent);
    return AddonModBookNavigationArrowsComponent;
}());

//# sourceMappingURL=navigation-arrows.js.map

/***/ }),
/* 1072 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCoursesCourseProgressComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_events__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__core_course_providers_format_delegate__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_course_providers_course__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_course_providers_helper__ = __webpack_require__(29);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};








/**
 * This component is meant to display a course for a list of courses with progress.
 *
 * Example usage:
 *
 * <core-courses-course-progress [course]="course">
 * </core-courses-course-progress>
 */
var CoreCoursesCourseProgressComponent = /** @class */ (function () {
    function CoreCoursesCourseProgressComponent(navCtrl, courseHelper, courseFormatDelegate, domUtils, courseProvider, eventsProvider, sitesProvider) {
        var _this = this;
        this.navCtrl = navCtrl;
        this.courseHelper = courseHelper;
        this.courseFormatDelegate = courseFormatDelegate;
        this.domUtils = domUtils;
        this.courseProvider = courseProvider;
        this.prefetchCourseData = {
            prefetchCourseIcon: 'spinner'
        };
        this.isDestroyed = false;
        // Listen for status change in course.
        this.courseStatusObserver = eventsProvider.on(__WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */].COURSE_STATUS_CHANGED, function (data) {
            if (data.courseId == _this.course.id) {
                _this.prefetchCourseData.prefetchCourseIcon = _this.courseHelper.getCourseStatusIconFromStatus(data.status);
            }
        }, sitesProvider.getCurrentSiteId());
    }
    /**
     * Component being initialized.
     */
    CoreCoursesCourseProgressComponent.prototype.ngOnInit = function () {
        var _this = this;
        // Determine course prefetch icon.
        this.courseHelper.getCourseStatusIcon(this.course.id).then(function (icon) {
            _this.prefetchCourseData.prefetchCourseIcon = icon;
            if (icon == 'spinner') {
                // Course is being downloaded. Get the download promise.
                var promise = _this.courseHelper.getCourseDownloadPromise(_this.course.id);
                if (promise) {
                    // There is a download promise. If it fails, show an error.
                    promise.catch(function (error) {
                        if (!_this.isDestroyed) {
                            _this.domUtils.showErrorModalDefault(error, 'core.course.errordownloadingcourse', true);
                        }
                    });
                }
                else {
                    // No download, this probably means that the app was closed while downloading. Set previous status.
                    _this.courseProvider.setCoursePreviousStatus(_this.course.id);
                }
            }
        });
    };
    /**
     * Open a course.
     *
     * @param {any} course The course to open.
     */
    CoreCoursesCourseProgressComponent.prototype.openCourse = function (course) {
        this.courseFormatDelegate.openCourse(this.navCtrl, course);
    };
    /**
     * Prefetch the course.
     *
     * @param {Event} e Click event.
     */
    CoreCoursesCourseProgressComponent.prototype.prefetchCourse = function (e) {
        var _this = this;
        e.preventDefault();
        e.stopPropagation();
        this.courseHelper.confirmAndPrefetchCourse(this.prefetchCourseData, this.course).catch(function (error) {
            if (!_this.isDestroyed) {
                _this.domUtils.showErrorModalDefault(error, 'core.course.errordownloadingcourse', true);
            }
        });
    };
    /**
     * Component destroyed.
     */
    CoreCoursesCourseProgressComponent.prototype.ngOnDestroy = function () {
        this.isDestroyed = true;
        if (this.courseStatusObserver) {
            this.courseStatusObserver.off();
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreCoursesCourseProgressComponent.prototype, "course", void 0);
    CoreCoursesCourseProgressComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-courses-course-progress',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/core/courses/components/course-progress/course-progress.html"*/'<ion-card>\n    <ion-item tappable text-wrap detail-none (click)="openCourse(course)" [title]="course.fullname" class="core-course-link">\n        <h2><core-format-text [text]="course.fullname"></core-format-text></h2>\n\n        <div class="core-button-spinner">\n            <!-- Download course. -->\n            <button *ngIf="prefetchCourseData.prefetchCourseIcon != \'spinner\'" ion-button icon-only clear color="dark" (click)="prefetchCourse($event)">\n                <ion-icon [name]="prefetchCourseData.prefetchCourseIcon"></ion-icon>\n            </button>\n            <!-- Download course spinner. -->\n            <ion-spinner *ngIf="prefetchCourseData.prefetchCourseIcon == \'spinner\'"></ion-spinner>\n        </div>\n    </ion-item>\n    <ion-item text-wrap *ngIf="course.summary && course.summary.length">\n        <p>\n            <summary>\n                <core-format-text [text]="course.summary" singleLine="true" clean="true"></core-format-text>\n            </summary>\n        </p>\n    </ion-item>\n    <ion-item *ngIf="course.progress != null && course.progress >= 0">\n        <core-progress-bar [progress]="course.progress"></core-progress-bar>\n    </ion-item>\n    <ng-content></ng-content>\n</ion-card>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/core/courses/components/course-progress/course-progress.html"*/
        }),
        __param(0, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["N" /* Optional */])()),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavController */], __WEBPACK_IMPORTED_MODULE_7__core_course_providers_helper__["a" /* CoreCourseHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_5__core_course_providers_format_delegate__["a" /* CoreCourseFormatDelegate */], __WEBPACK_IMPORTED_MODULE_4__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_6__core_course_providers_course__["a" /* CoreCourseProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_sites__["a" /* CoreSitesProvider */]])
    ], CoreCoursesCourseProgressComponent);
    return CoreCoursesCourseProgressComponent;
}());

//# sourceMappingURL=course-progress.js.map

/***/ }),
/* 1073 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCoursesCourseListItemComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_courses__ = __webpack_require__(31);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};




/**
 * This directive is meant to display an item for a list of courses.
 *
 * Example usage:
 *
 * <core-courses-course-list-item [course]="course"></core-courses-course-list-item>
 */
var CoreCoursesCourseListItemComponent = /** @class */ (function () {
    function CoreCoursesCourseListItemComponent(navCtrl, translate, coursesProvider) {
        this.navCtrl = navCtrl;
        this.translate = translate;
        this.coursesProvider = coursesProvider;
    }
    /**
     * Component being initialized.
     */
    CoreCoursesCourseListItemComponent.prototype.ngOnInit = function () {
        var _this = this;
        // Check if the user is enrolled in the course.
        this.coursesProvider.getUserCourse(this.course.id).then(function () {
            _this.course.isEnrolled = true;
        }).catch(function () {
            _this.course.isEnrolled = false;
            _this.course.enrollment = [];
            _this.course.enrollmentmethods.forEach(function (instance) {
                if (instance === 'self') {
                    _this.course.enrollment.push({
                        name: _this.translate.instant('core.courses.selfenrolment'),
                        icon: 'unlock'
                    });
                }
                else if (instance === 'guest') {
                    _this.course.enrollment.push({
                        name: _this.translate.instant('core.courses.allowguests'),
                        icon: 'person'
                    });
                }
                else if (instance === 'paypal') {
                    _this.course.enrollment.push({
                        name: _this.translate.instant('core.courses.paypalaccepted'),
                        img: 'assets/img/icons/paypal.png'
                    });
                }
            });
            if (_this.course.enrollment.length == 0) {
                _this.course.enrollment.push({
                    name: _this.translate.instant('core.courses.notenrollable'),
                    icon: 'lock'
                });
            }
        });
    };
    /**
     * Open a course.
     *
     * @param {any} course The course to open.
     */
    CoreCoursesCourseListItemComponent.prototype.openCourse = function (course) {
        this.navCtrl.push('CoreCoursesCoursePreviewPage', { course: course });
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreCoursesCourseListItemComponent.prototype, "course", void 0);
    CoreCoursesCourseListItemComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-courses-course-list-item',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/core/courses/components/course-list-item/course-list-item.html"*/'<a ion-item text-wrap (click)="openCourse(course)" [attr.disabled]="course.visible == 0 ? true : null" [attr.detail-none]="course.visible == 0 ? true : null" [title]="course.fullname">\n    <ion-icon name="ionic" item-start></ion-icon>\n    <h2><core-format-text [text]="course.fullname"></core-format-text></h2>\n    <div item-end>\n        <span *ngIf="!course.isEnrolled">\n            <span ion-button icon-only clear color="gray" *ngFor="let instance of course.enrollment" [attr.aria-label]=" instance.name | translate">\n                <ion-icon *ngIf="instance.icon" [name]="instance.icon"></ion-icon>\n                <img *ngIf="instance.img && !instance.icon" [src]="instance.img" class="core-course-enrollment-img">\n            </span>\n        </span>\n    </div>\n</a>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/core/courses/components/course-list-item/course-list-item.html"*/
        }),
        __param(0, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["N" /* Optional */])()),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavController */], __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */],
            __WEBPACK_IMPORTED_MODULE_3__providers_courses__["a" /* CoreCoursesProvider */]])
    ], CoreCoursesCourseListItemComponent);
    return CoreCoursesCourseListItemComponent;
}());

//# sourceMappingURL=course-list-item.js.map

/***/ }),
/* 1074 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCoursesOverviewEventsComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_text__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_course_providers_course__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_contentlinks_providers_helper__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_moment__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_moment__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};









/**
 * Directive to render a list of events in course overview.
 */
var CoreCoursesOverviewEventsComponent = /** @class */ (function () {
    function CoreCoursesOverviewEventsComponent(navCtrl, utils, textUtils, domUtils, sitesProvider, courseProvider, contentLinksHelper) {
        this.navCtrl = navCtrl;
        this.utils = utils;
        this.textUtils = textUtils;
        this.domUtils = domUtils;
        this.sitesProvider = sitesProvider;
        this.courseProvider = courseProvider;
        this.contentLinksHelper = contentLinksHelper;
        this.recentlyOverdue = [];
        this.today = [];
        this.next7Days = [];
        this.next30Days = [];
        this.future = [];
        this.loadMore = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */]();
    }
    /**
     * Detect changes on input properties.
     */
    CoreCoursesOverviewEventsComponent.prototype.ngOnChanges = function (changes) {
        this.showCourse = this.utils.isTrueOrOne(this.showCourse);
        if (changes.events) {
            this.updateEvents();
        }
    };
    /**
     * Filter the events by time.
     *
     * @param {number} start Number of days to start getting events from today. E.g. -1 will get events from yesterday.
     * @param {number} [end] Number of days after the start.
     * @return {any[]} Filtered events.
     */
    CoreCoursesOverviewEventsComponent.prototype.filterEventsByTime = function (start, end) {
        var _this = this;
        start = __WEBPACK_IMPORTED_MODULE_8_moment__().add(start, 'days').unix();
        end = typeof end != 'undefined' ? __WEBPACK_IMPORTED_MODULE_8_moment__().add(end, 'days').unix() : end;
        return this.events.filter(function (event) {
            if (end) {
                return start <= event.timesort && event.timesort < end;
            }
            return start <= event.timesort;
        }).map(function (event) {
            event.iconUrl = _this.courseProvider.getModuleIconSrc(event.icon.component);
            return event;
        });
    };
    /**
     * Update the events displayed.
     */
    CoreCoursesOverviewEventsComponent.prototype.updateEvents = function () {
        this.empty = !this.events || this.events.length <= 0;
        if (!this.empty) {
            this.recentlyOverdue = this.filterEventsByTime(-14, 0);
            this.today = this.filterEventsByTime(0, 1);
            this.next7Days = this.filterEventsByTime(1, 7);
            this.next30Days = this.filterEventsByTime(7, 30);
            this.future = this.filterEventsByTime(30);
        }
    };
    /**
     * Load more events clicked.
     */
    CoreCoursesOverviewEventsComponent.prototype.loadMoreEvents = function () {
        this.loadingMore = true;
        this.loadMore.emit();
    };
    /**
     * Action clicked.
     *
     * @param {Event} e Click event.
     * @param {string} url Url of the action.
     */
    CoreCoursesOverviewEventsComponent.prototype.action = function (e, url) {
        var _this = this;
        e.preventDefault();
        e.stopPropagation();
        // Fix URL format.
        url = this.textUtils.decodeHTMLEntities(url);
        var modal = this.domUtils.showModalLoading();
        this.contentLinksHelper.handleLink(url, undefined, this.navCtrl).then(function (treated) {
            if (!treated) {
                return _this.sitesProvider.getCurrentSite().openInBrowserWithAutoLoginIfSameSite(url);
            }
        }).finally(function () {
            modal.dismiss();
        });
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Array)
    ], CoreCoursesOverviewEventsComponent.prototype, "events", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreCoursesOverviewEventsComponent.prototype, "showCourse", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Boolean)
    ], CoreCoursesOverviewEventsComponent.prototype, "canLoadMore", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["O" /* Output */])(),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["v" /* EventEmitter */])
    ], CoreCoursesOverviewEventsComponent.prototype, "loadMore", void 0);
    CoreCoursesOverviewEventsComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-courses-overview-events',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/core/courses/components/overview-events/overview-events.html"*/'<ng-template #eventTemplate let-event="event">\n    <a ion-item core-link text-wrap detail-none captureLink="true" class="core-course-module-handler item-media" [href]="event.url" [title]="event.name" [class.item-badge-right-phone]="event.action && event.action.showitemcount">\n        <img item-start [src]="event.iconUrl" core-external-content alt="" role="presentation" *ngIf="event.iconUrl" class="core-module-icon">\n        <h2><core-format-text [text]="event.name"></core-format-text></h2>\n        <p>{{event.timesort * 1000 | coreFormatDate:"dfmediumdate" }} <core-format-text *ngIf="showCourse" [text]="event.course.fullnamedisplay"></core-format-text></p>\n        <button ion-button clear item-end class="hidden-phone" (click)="action($event, event.action.url)" [title]="event.action.name" [disabled]="!event.action.actionable" *ngIf="event.action">\n            {{event.action.name}}\n            <ion-badge item-end margin-left *ngIf="event.action.showitemcount">{{event.action.itemcount}}</ion-badge>\n        </button>\n        <ion-badge class="hidden-tablet" item-end *ngIf="event.action.showitemcount">{{event.action.itemcount}}</ion-badge>\n    </a>\n</ng-template>\n\n<ion-item-group *ngIf="recentlyOverdue.length > 0">\n    <ion-item-divider color="danger">{{ \'core.courses.recentlyoverdue\' | translate }}</ion-item-divider>\n    <ng-container *ngFor="let event of recentlyOverdue">\n        <ng-container *ngTemplateOutlet="eventTemplate; context: {event: event}"></ng-container>\n    </ng-container>\n</ion-item-group>\n\n<ion-item-group *ngIf="next7Days.length > 0">\n    <ion-item-divider color="light">{{ \'core.courses.next7days\' | translate }}</ion-item-divider>\n    <ng-container *ngFor="let event of next7Days">\n        <ng-container *ngTemplateOutlet="eventTemplate; context: {event: event}"></ng-container>\n    </ng-container>\n</ion-item-group>\n\n<ion-item-group *ngIf="next30Days.length > 0">\n    <ion-item-divider color="light">{{ \'core.courses.next30days\' | translate }}</ion-item-divider>\n    <ng-container *ngFor="let event of next30Days">\n        <ng-container *ngTemplateOutlet="eventTemplate; context: {event: event}"></ng-container>\n    </ng-container>\n</ion-item-group>\n\n<ion-item-group *ngIf="future.length > 0">\n    <ion-item-divider color="light">{{ \'core.courses.future\' | translate }}</ion-item-divider>\n    <ng-container *ngFor="let event of future">\n        <ng-container *ngTemplateOutlet="eventTemplate; context: {event: event}"></ng-container>\n    </ng-container>\n</ion-item-group>\n\n<div padding text-center *ngIf="canLoadMore && !empty">\n    <!-- Button and spinner to show more attempts. -->\n    <button *ngIf="!loadingMore" ion-button block (click)="loadMoreEvents()">{{ \'core.loadmore\' | translate }}</button>\n    <ion-spinner *ngIf="loadingMore"></ion-spinner>\n</div>\n\n<core-empty-box *ngIf="empty && showCourse" image="assets/img/icons/activities.svg" [message]="\'core.courses.noevents\' | translate"></core-empty-box>\n<core-empty-box *ngIf="empty && !showCourse" [message]="\'core.courses.noevents\' | translate"></core-empty-box>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/core/courses/components/overview-events/overview-events.html"*/
        }),
        __param(0, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["N" /* Optional */])()),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavController */], __WEBPACK_IMPORTED_MODULE_5__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_utils_text__["a" /* CoreTextUtilsProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_6__core_course_providers_course__["a" /* CoreCourseProvider */],
            __WEBPACK_IMPORTED_MODULE_7__core_contentlinks_providers_helper__["a" /* CoreContentLinksHelperProvider */]])
    ], CoreCoursesOverviewEventsComponent);
    return CoreCoursesOverviewEventsComponent;
}());

//# sourceMappingURL=overview-events.js.map

/***/ }),
/* 1075 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSiteHomeIndexComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_course_providers_course__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_course_providers_helper__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__core_course_providers_module_prefetch_delegate__ = __webpack_require__(55);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






/**
 * Component that displays site home index.
 */
var CoreSiteHomeIndexComponent = /** @class */ (function () {
    function CoreSiteHomeIndexComponent(domUtils, sitesProvider, courseProvider, courseHelper, prefetchDelegate) {
        this.domUtils = domUtils;
        this.sitesProvider = sitesProvider;
        this.courseProvider = courseProvider;
        this.courseHelper = courseHelper;
        this.prefetchDelegate = prefetchDelegate;
        this.items = [];
        this.siteHomeId = sitesProvider.getCurrentSite().getSiteHomeId();
    }
    /**
     * Component being initialized.
     */
    CoreSiteHomeIndexComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.loadContent().finally(function () {
            _this.dataLoaded = true;
        });
    };
    /**
     * Refresh the data.
     *
     * @param {any} refresher Refresher.
     */
    CoreSiteHomeIndexComponent.prototype.doRefresh = function (refresher) {
        var _this = this;
        var promises = [], currentSite = this.sitesProvider.getCurrentSite();
        promises.push(this.courseProvider.invalidateSections(this.siteHomeId));
        promises.push(currentSite.invalidateConfig().then(function () {
            // Config invalidated, fetch it again.
            return currentSite.getConfig().then(function (config) {
                currentSite.setConfig(config);
            });
        }));
        if (this.sectionsLoaded) {
            // Invalidate modules prefetch data.
            var modules = this.courseProvider.getSectionsModules(this.sectionsLoaded);
            promises.push(this.prefetchDelegate.invalidateModules(modules, this.siteHomeId));
        }
        Promise.all(promises).finally(function () {
            _this.loadContent().finally(function () {
                refresher.complete();
            });
        });
    };
    /**
     * Convenience function to fetch the data.
     *
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreSiteHomeIndexComponent.prototype.loadContent = function () {
        var _this = this;
        this.hasContent = false;
        var config = this.sitesProvider.getCurrentSite().getStoredConfig() || { numsections: 1 };
        if (config.frontpageloggedin) {
            // Items with index 1 and 3 were removed on 2.5 and not being supported in the app.
            var frontpageItems_1 = [
                'news',
                false,
                'categories',
                false,
                'categories',
                'enrolled-course-list',
                'all-course-list',
                'course-search' // Course search box.
            ], items = config.frontpageloggedin.split(',');
            this.items = [];
            items.forEach(function (itemNumber) {
                // Get the frontpage item "name".
                var item = frontpageItems_1[parseInt(itemNumber, 10)];
                if (!item || _this.items.indexOf(item) >= 0) {
                    return;
                }
                _this.hasContent = true;
                _this.items.push(item);
            });
        }
        return this.courseProvider.getSections(this.siteHomeId, false, true).then(function (sections) {
            _this.sectionsLoaded = Array.from(sections);
            // Check "Include a topic section" setting from numsections.
            _this.section = config.numsections && sections.length > 0 ? sections.pop() : false;
            if (_this.section) {
                _this.section.hasContent = _this.courseHelper.sectionHasContent(_this.section);
            }
            _this.block = sections.length > 0 ? sections.pop() : false;
            if (_this.block) {
                _this.block.hasContent = _this.courseHelper.sectionHasContent(_this.block);
            }
            _this.hasContent = _this.courseHelper.addHandlerDataForModules(_this.sectionsLoaded, _this.siteHomeId) || _this.hasContent;
            // Add log in Moodle.
            _this.courseProvider.logView(_this.siteHomeId);
        }).catch(function (error) {
            _this.domUtils.showErrorModalDefault(error, 'core.course.couldnotloadsectioncontent', true);
        });
    };
    CoreSiteHomeIndexComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-sitehome-index',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/core/sitehome/components/index/index.html"*/'<ion-content>\n    <ion-refresher [enabled]="dataLoaded" (ionRefresh)="doRefresh($event)">\n        <ion-refresher-content pullingText="{{ \'core.pulltorefresh\' | translate }}"></ion-refresher-content>\n    </ion-refresher>\n\n    <core-loading [hideUntil]="dataLoaded">\n\n        <ion-list>\n            <!-- Site home main contents. -->\n            <ng-container *ngIf="section && section.hasContent">\n                <ion-item text-wrap *ngIf="section.summary">\n                    <core-format-text [text]="section.summary"></core-format-text>\n                </ion-item>\n\n                <core-course-module *ngFor="let module of section.modules" [module]="module" [courseId]="siteHomeId"></core-course-module>\n            </ng-container>\n\n            <!-- Site home items: news, categories, courses, etc. -->\n            <ng-container *ngIf="items.length > 0">\n                <ion-item-divider color="light" *ngIf="section && section.hasContent"></ion-item-divider>\n                <ng-container *ngFor="let item of items">\n                    <core-sitehome-all-course-list class="item" *ngIf="item == \'all-course-list\'"></core-sitehome-all-course-list>\n                    <core-sitehome-categories  *ngIf="item == \'categories\'"></core-sitehome-categories>\n                    <core-sitehome-course-search *ngIf="item == \'course-search\'"></core-sitehome-course-search>\n                    <core-sitehome-enrolled-course-list *ngIf="item == \'enrolled-course-list\'"></core-sitehome-enrolled-course-list>\n                    <core-sitehome-news *ngIf="item == \'news\'"></core-sitehome-news>\n                </ng-container>\n            </ng-container>\n\n            <!-- Site home block. -->\n            <ng-container *ngIf="block && block.hasContent">\n                <ion-item-divider color="light" *ngIf="(section && section.hasContent) || items.length > 0"></ion-item-divider>\n                <ion-item text-wrap *ngIf="block.summary">\n                    <core-format-text [text]="block.summary"></core-format-text>\n                </ion-item>\n\n                <core-course-module *ngFor="let module of block.modules" [module]="module" [courseId]="siteHomeId"></core-course-module>\n            </ng-container>\n        </ion-list>\n\n        <core-empty-box *ngIf="!hasContent" icon="qr-scanner" [message]="\'core.course.nocontentavailable\' | translate"></core-empty-box>\n    </core-loading>\n</ion-content>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/core/sitehome/components/index/index.html"*/,
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_1__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_3__core_course_providers_course__["a" /* CoreCourseProvider */], __WEBPACK_IMPORTED_MODULE_4__core_course_providers_helper__["a" /* CoreCourseHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_5__core_course_providers_module_prefetch_delegate__["a" /* CoreCourseModulePrefetchDelegate */]])
    ], CoreSiteHomeIndexComponent);
    return CoreSiteHomeIndexComponent;
}());

//# sourceMappingURL=index.js.map

/***/ }),
/* 1076 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSiteHomeAllCourseListComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_courses_providers_courses__ = __webpack_require__(31);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Component to open the page to view the list of all courses.
 */
var CoreSiteHomeAllCourseListComponent = /** @class */ (function () {
    function CoreSiteHomeAllCourseListComponent(coursesProvider) {
        this.show = coursesProvider.isGetCoursesByFieldAvailable();
    }
    CoreSiteHomeAllCourseListComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-sitehome-all-course-list',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/core/sitehome/components/all-course-list/all-course-list.html"*/'<a *ngIf="show" ion-item text-wrap [navPush]="\'CoreCoursesAvailableCoursesPage\'">\n    <ion-icon name="ionic" item-start></ion-icon>\n    <h2>{{ \'core.courses.availablecourses\' | translate}}</h2>\n</a>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/core/sitehome/components/all-course-list/all-course-list.html"*/,
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__core_courses_providers_courses__["a" /* CoreCoursesProvider */]])
    ], CoreSiteHomeAllCourseListComponent);
    return CoreSiteHomeAllCourseListComponent;
}());

//# sourceMappingURL=all-course-list.js.map

/***/ }),
/* 1077 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSiteHomeCategoriesComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_courses_providers_courses__ = __webpack_require__(31);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Component to open the page to view the list of categories.
 */
var CoreSiteHomeCategoriesComponent = /** @class */ (function () {
    function CoreSiteHomeCategoriesComponent(coursesProvider) {
        this.show = coursesProvider.isGetCoursesByFieldAvailable();
    }
    CoreSiteHomeCategoriesComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-sitehome-categories',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/core/sitehome/components/categories/categories.html"*/'<a *ngIf="show" ion-item text-wrap [navPush]="\'CoreCoursesCategoriesPage\'">\n    <ion-icon name="folder" item-start></ion-icon>\n    <h2>{{ \'core.courses.categories\' | translate}}</h2>\n</a>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/core/sitehome/components/categories/categories.html"*/,
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__core_courses_providers_courses__["a" /* CoreCoursesProvider */]])
    ], CoreSiteHomeCategoriesComponent);
    return CoreSiteHomeCategoriesComponent;
}());

//# sourceMappingURL=categories.js.map

/***/ }),
/* 1078 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSiteHomeCourseSearchComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_courses_providers_courses__ = __webpack_require__(31);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Component to open the page to search courses.
 */
var CoreSiteHomeCourseSearchComponent = /** @class */ (function () {
    function CoreSiteHomeCourseSearchComponent(coursesProvider) {
        this.show = !coursesProvider.isSearchCoursesDisabledInSite();
    }
    CoreSiteHomeCourseSearchComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-sitehome-course-search',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/core/sitehome/components/course-search/course-search.html"*/'<a *ngIf="show" ion-item text-wrap [navPush]="\'CoreCoursesSearchPage\'">\n    <ion-icon name="search" item-start></ion-icon>\n    <h2>{{ \'core.courses.searchcourses\' | translate}}</h2>\n</a>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/core/sitehome/components/course-search/course-search.html"*/,
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__core_courses_providers_courses__["a" /* CoreCoursesProvider */]])
    ], CoreSiteHomeCourseSearchComponent);
    return CoreSiteHomeCourseSearchComponent;
}());

//# sourceMappingURL=course-search.js.map

/***/ }),
/* 1079 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSiteHomeEnrolledCourseListComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_courses_providers_courses__ = __webpack_require__(31);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Component to open the page to view the list of courses the user is enrolled in.
 */
var CoreSiteHomeEnrolledCourseListComponent = /** @class */ (function () {
    function CoreSiteHomeEnrolledCourseListComponent(coursesProvider) {
        this.coursesProvider = coursesProvider;
    }
    /**
     * Component being initialized.
     */
    CoreSiteHomeEnrolledCourseListComponent.prototype.ngOnInit = function () {
        var _this = this;
        if (this.coursesProvider.isMyCoursesDisabledInSite()) {
            this.show = false;
        }
        else {
            this.coursesProvider.getUserCourses().then(function (courses) {
                _this.show = courses.length > 0;
            });
        }
    };
    CoreSiteHomeEnrolledCourseListComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-sitehome-enrolled-course-list',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/core/sitehome/components/enrolled-course-list/enrolled-course-list.html"*/'<a *ngIf="show" ion-item text-wrap [navPush]="\'CoreCoursesMyCoursesPage\'">\n    <ion-icon name="ionic" item-start></ion-icon>\n    <h2>{{ \'core.courses.mycourses\' | translate}}</h2>\n</a>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/core/sitehome/components/enrolled-course-list/enrolled-course-list.html"*/,
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__core_courses_providers_courses__["a" /* CoreCoursesProvider */]])
    ], CoreSiteHomeEnrolledCourseListComponent);
    return CoreSiteHomeEnrolledCourseListComponent;
}());

//# sourceMappingURL=enrolled-course-list.js.map

/***/ }),
/* 1080 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSiteHomeNewsComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_sites__ = __webpack_require__(3);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Component that displays site home news.
 */
var CoreSiteHomeNewsComponent = /** @class */ (function () {
    function CoreSiteHomeNewsComponent(sitesProvider) {
        this.sitesProvider = sitesProvider;
        this.siteHomeId = sitesProvider.getCurrentSite().getSiteHomeId();
    }
    /**
     * Component being initialized.
     */
    CoreSiteHomeNewsComponent.prototype.ngOnInit = function () {
        // Get number of news items to show.
        var newsItems = this.sitesProvider.getCurrentSite().getStoredConfig('newsitems') || 0;
        if (!newsItems) {
            return;
        }
        // @todo: Implement it once forum is supported.
    };
    CoreSiteHomeNewsComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-sitehome-news',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/core/sitehome/components/news/news.html"*/'<core-course-module class="core-sitehome-news" *ngIf="show" [module]="module" [courseId]="siteHomeId"></core-course-module>'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/core/sitehome/components/news/news.html"*/,
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_sites__["a" /* CoreSitesProvider */]])
    ], CoreSiteHomeNewsComponent);
    return CoreSiteHomeNewsComponent;
}());

//# sourceMappingURL=news.js.map

/***/ }),
/* 1081 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreUserProfileFieldComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_user_profile_field_delegate__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__ = __webpack_require__(9);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Directive to render user profile field.
 */
var CoreUserProfileFieldComponent = /** @class */ (function () {
    function CoreUserProfileFieldComponent(ufDelegate, utilsProvider, injector) {
        this.ufDelegate = ufDelegate;
        this.utilsProvider = utilsProvider;
        this.injector = injector;
        this.signup = false; // True if editing the field in signup. Defaults to false.
        this.edit = false; // True if editing the field. Defaults to false.
        this.data = {}; // Data to pass to the component.
    }
    /**
     * Component being initialized.
     */
    CoreUserProfileFieldComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.ufDelegate.getComponent(this.injector, this.field, this.signup).then(function (component) {
            _this.componentClass = component;
        });
        this.data.field = this.field;
        this.data.edit = this.utilsProvider.isTrueOrOne(this.edit);
        if (this.edit) {
            this.data.signup = this.utilsProvider.isTrueOrOne(this.signup);
            this.data.disabled = this.utilsProvider.isTrueOrOne(this.field.locked);
            this.data.form = this.form;
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreUserProfileFieldComponent.prototype, "field", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreUserProfileFieldComponent.prototype, "signup", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreUserProfileFieldComponent.prototype, "edit", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreUserProfileFieldComponent.prototype, "form", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreUserProfileFieldComponent.prototype, "registerAuth", void 0);
    CoreUserProfileFieldComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({
            selector: 'core-user-profile-field',template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/core/user/components/user-profile-field/user-profile-field.html"*/'<core-dynamic-component [component]="componentClass" [data]="data"></core-dynamic-component>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/core/user/components/user-profile-field/user-profile-field.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_user_profile_field_delegate__["a" /* CoreUserProfileFieldDelegate */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_0__angular_core__["C" /* Injector */]])
    ], CoreUserProfileFieldComponent);
    return CoreUserProfileFieldComponent;
}());

//# sourceMappingURL=user-profile-field.js.map

/***/ }),
/* 1082 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCompileHtmlComponentModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__compile_html__ = __webpack_require__(606);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};



var CoreCompileHtmlComponentModule = /** @class */ (function () {
    function CoreCompileHtmlComponentModule() {
    }
    CoreCompileHtmlComponentModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_2__compile_html__["a" /* CoreCompileHtmlComponent */]
            ],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1__angular_common__["b" /* CommonModule */]
            ],
            exports: [
                __WEBPACK_IMPORTED_MODULE_2__compile_html__["a" /* CoreCompileHtmlComponent */]
            ]
        })
    ], CoreCompileHtmlComponentModule);
    return CoreCompileHtmlComponentModule;
}());

//# sourceMappingURL=compile-html.module.js.map

/***/ }),
/* 1083 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseFormatSingleActivityModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_singleactivity__ = __webpack_require__(250);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_handler__ = __webpack_require__(609);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_format_delegate__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__components_components_module__ = __webpack_require__(26);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





var CoreCourseFormatSingleActivityModule = /** @class */ (function () {
    function CoreCourseFormatSingleActivityModule(formatDelegate, handler) {
        formatDelegate.registerHandler(handler);
    }
    CoreCourseFormatSingleActivityModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_1__components_singleactivity__["a" /* CoreCourseFormatSingleActivityComponent */]
            ],
            imports: [
                __WEBPACK_IMPORTED_MODULE_4__components_components_module__["a" /* CoreComponentsModule */]
            ],
            providers: [
                __WEBPACK_IMPORTED_MODULE_2__providers_handler__["a" /* CoreCourseFormatSingleActivityHandler */]
            ],
            exports: [
                __WEBPACK_IMPORTED_MODULE_1__components_singleactivity__["a" /* CoreCourseFormatSingleActivityComponent */]
            ],
            entryComponents: [
                __WEBPACK_IMPORTED_MODULE_1__components_singleactivity__["a" /* CoreCourseFormatSingleActivityComponent */]
            ]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_format_delegate__["a" /* CoreCourseFormatDelegate */], __WEBPACK_IMPORTED_MODULE_2__providers_handler__["a" /* CoreCourseFormatSingleActivityHandler */]])
    ], CoreCourseFormatSingleActivityModule);
    return CoreCourseFormatSingleActivityModule;
}());

//# sourceMappingURL=singleactivity.module.js.map

/***/ }),
/* 1084 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseFormatSocialModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_handler__ = __webpack_require__(1085);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_format_delegate__ = __webpack_require__(79);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



var CoreCourseFormatSocialModule = /** @class */ (function () {
    function CoreCourseFormatSocialModule(formatDelegate, handler) {
        formatDelegate.registerHandler(handler);
    }
    CoreCourseFormatSocialModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [],
            providers: [
                __WEBPACK_IMPORTED_MODULE_1__providers_handler__["a" /* CoreCourseFormatSocialHandler */]
            ],
            exports: []
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_format_delegate__["a" /* CoreCourseFormatDelegate */], __WEBPACK_IMPORTED_MODULE_1__providers_handler__["a" /* CoreCourseFormatSocialHandler */]])
    ], CoreCourseFormatSocialModule);
    return CoreCourseFormatSocialModule;
}());

//# sourceMappingURL=social.module.js.map

/***/ }),
/* 1085 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseFormatSocialHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__singleactivity_providers_handler__ = __webpack_require__(609);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


/**
 * Handler to support social course format.
 * This format is like singleactivity in the mobile app, so we'll use the same implementation for both.
 */
var CoreCourseFormatSocialHandler = /** @class */ (function (_super) {
    __extends(CoreCourseFormatSocialHandler, _super);
    function CoreCourseFormatSocialHandler() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.name = 'social';
        return _this;
    }
    CoreCourseFormatSocialHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])()
    ], CoreCourseFormatSocialHandler);
    return CoreCourseFormatSocialHandler;
}(__WEBPACK_IMPORTED_MODULE_1__singleactivity_providers_handler__["a" /* CoreCourseFormatSingleActivityHandler */]));

//# sourceMappingURL=handler.js.map

/***/ }),
/* 1086 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseFormatTopicsModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_handler__ = __webpack_require__(1087);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_format_delegate__ = __webpack_require__(79);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



var CoreCourseFormatTopicsModule = /** @class */ (function () {
    function CoreCourseFormatTopicsModule(formatDelegate, handler) {
        formatDelegate.registerHandler(handler);
    }
    CoreCourseFormatTopicsModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [],
            providers: [
                __WEBPACK_IMPORTED_MODULE_1__providers_handler__["a" /* CoreCourseFormatTopicsHandler */]
            ],
            exports: []
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_format_delegate__["a" /* CoreCourseFormatDelegate */], __WEBPACK_IMPORTED_MODULE_1__providers_handler__["a" /* CoreCourseFormatTopicsHandler */]])
    ], CoreCourseFormatTopicsModule);
    return CoreCourseFormatTopicsModule;
}());

//# sourceMappingURL=topics.module.js.map

/***/ }),
/* 1087 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseFormatTopicsHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

/**
 * Handler to support topics course format.
 */
var CoreCourseFormatTopicsHandler = /** @class */ (function () {
    function CoreCourseFormatTopicsHandler() {
        this.name = 'topics';
        // Nothing to do.
    }
    /**
     * Whether or not the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} True or promise resolved with true if enabled.
     */
    CoreCourseFormatTopicsHandler.prototype.isEnabled = function () {
        return true;
    };
    CoreCourseFormatTopicsHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [])
    ], CoreCourseFormatTopicsHandler);
    return CoreCourseFormatTopicsHandler;
}());

//# sourceMappingURL=handler.js.map

/***/ }),
/* 1088 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseFormatWeeksModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_handler__ = __webpack_require__(1089);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_format_delegate__ = __webpack_require__(79);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



var CoreCourseFormatWeeksModule = /** @class */ (function () {
    function CoreCourseFormatWeeksModule(formatDelegate, handler) {
        formatDelegate.registerHandler(handler);
    }
    CoreCourseFormatWeeksModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [],
            providers: [
                __WEBPACK_IMPORTED_MODULE_1__providers_handler__["a" /* CoreCourseFormatWeeksHandler */]
            ],
            exports: []
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_format_delegate__["a" /* CoreCourseFormatDelegate */], __WEBPACK_IMPORTED_MODULE_1__providers_handler__["a" /* CoreCourseFormatWeeksHandler */]])
    ], CoreCourseFormatWeeksModule);
    return CoreCourseFormatWeeksModule;
}());

//# sourceMappingURL=weeks.module.js.map

/***/ }),
/* 1089 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseFormatWeeksHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_utils_time__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constants__ = __webpack_require__(22);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Handler to support weeks course format.
 */
var CoreCourseFormatWeeksHandler = /** @class */ (function () {
    function CoreCourseFormatWeeksHandler(timeUtils) {
        this.timeUtils = timeUtils;
        this.name = 'weeks';
    }
    /**
     * Whether or not the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} True or promise resolved with true if enabled.
     */
    CoreCourseFormatWeeksHandler.prototype.isEnabled = function () {
        return true;
    };
    /**
     * Given a list of sections, get the "current" section that should be displayed first.
     *
     * @param {any} course The course to get the title.
     * @param {any[]} sections List of sections.
     * @return {any|Promise<any>} Current section (or promise resolved with current section).
     */
    CoreCourseFormatWeeksHandler.prototype.getCurrentSection = function (course, sections) {
        var now = this.timeUtils.timestamp();
        if (now < course.startdate || (course.enddate && now > course.enddate)) {
            // Course hasn't started yet or it has ended already. Return the first section.
            return sections[1];
        }
        for (var i = 0; i < sections.length; i++) {
            var section = sections[i];
            if (typeof section.section == 'undefined' || section.section < 1) {
                continue;
            }
            var dates = this.getSectionDates(section, course.startdate);
            if ((now >= dates.start) && (now < dates.end)) {
                return section;
            }
        }
        // The section wasn't found, return the first section.
        return sections[1];
    };
    /**
     * Return the start and end date of a section.
     *
     * @param {any} section The section to treat.
     * @param {number} startDate The course start date (in seconds).
     * @return {{start: number, end: number}} An object with the start and end date of the section.
     */
    CoreCourseFormatWeeksHandler.prototype.getSectionDates = function (section, startDate) {
        // Hack alert. We add 2 hours to avoid possible DST problems. (e.g. we go into daylight savings and the date changes).
        startDate = startDate + 7200;
        var dates = {
            start: startDate + (__WEBPACK_IMPORTED_MODULE_2__constants__["a" /* CoreConstants */].SECONDS_WEEK * (section.section - 1)),
            end: 0
        };
        dates.end = dates.start + __WEBPACK_IMPORTED_MODULE_2__constants__["a" /* CoreConstants */].SECONDS_WEEK;
        return dates;
    };
    CoreCourseFormatWeeksHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_utils_time__["a" /* CoreTimeUtilsProvider */]])
    ], CoreCourseFormatWeeksHandler);
    return CoreCourseFormatWeeksHandler;
}());

//# sourceMappingURL=handler.js.map

/***/ }),
/* 1090 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCoursesMainMenuHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__courses__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_my_overview__ = __webpack_require__(180);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Handler to add My Courses or My Overview into main menu.
 */
var CoreCoursesMainMenuHandler = /** @class */ (function () {
    function CoreCoursesMainMenuHandler(coursesProvider, myOverviewProvider) {
        this.coursesProvider = coursesProvider;
        this.myOverviewProvider = myOverviewProvider;
        this.name = 'CoreCourses';
        this.priority = 1100;
    }
    /**
     * Check if the handler is enabled on a site level.
     *
     * @return {boolean | Promise<boolean>} Whether or not the handler is enabled on a site level.
     */
    CoreCoursesMainMenuHandler.prototype.isEnabled = function () {
        var _this = this;
        // Check if my overview is enabled.
        return this.myOverviewProvider.isEnabled().then(function (enabled) {
            _this.isOverviewEnabled = enabled;
            if (enabled) {
                return true;
            }
            // My overview not enabled, check if my courses is enabled.
            return !_this.coursesProvider.isMyCoursesDisabledInSite();
        });
    };
    /**
     * Returns the data needed to render the handler.
     *
     * @return {CoreMainMenuHandlerData} Data needed to render the handler.
     */
    CoreCoursesMainMenuHandler.prototype.getDisplayData = function () {
        if (this.isOverviewEnabled) {
            return {
                icon: 'home',
                title: 'core.courses.courseoverview',
                page: 'CoreCoursesMyOverviewPage',
                class: 'core-courseoverview-handler'
            };
        }
        else {
            return {
                icon: 'ionic',
                title: 'core.courses.mycourses',
                page: 'CoreCoursesMyCoursesPage',
                class: 'core-mycourses-handler'
            };
        }
    };
    CoreCoursesMainMenuHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__courses__["a" /* CoreCoursesProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_my_overview__["a" /* CoreCoursesMyOverviewProvider */]])
    ], CoreCoursesMainMenuHandler);
    return CoreCoursesMainMenuHandler;
}());

//# sourceMappingURL=mainmenu-handler.js.map

/***/ }),
/* 1091 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCoursesCourseLinkHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_contentlinks_classes_base_handler__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__core_login_providers_helper__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_course_providers_course__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__courses__ = __webpack_require__(31);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








/**
 * Handler to treat links to course view or enrol (except site home).
 */
var CoreCoursesCourseLinkHandler = /** @class */ (function (_super) {
    __extends(CoreCoursesCourseLinkHandler, _super);
    function CoreCoursesCourseLinkHandler(sitesProvider, coursesProvider, loginHelper, domUtils, translate, courseProvider) {
        var _this = _super.call(this) || this;
        _this.sitesProvider = sitesProvider;
        _this.coursesProvider = coursesProvider;
        _this.loginHelper = loginHelper;
        _this.domUtils = domUtils;
        _this.translate = translate;
        _this.courseProvider = courseProvider;
        _this.name = 'CoreCoursesCourseLinkHandler';
        _this.pattern = /((\/enrol\/index\.php)|(\/course\/enrol\.php)|(\/course\/view\.php)).*([\?\&]id=\d+)/;
        _this.waitStart = 0;
        return _this;
    }
    /**
     * Get the list of actions for a link (url).
     *
     * @param {string[]} siteIds List of sites the URL belongs to.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {CoreContentLinksAction[]|Promise<CoreContentLinksAction[]>} List of (or promise resolved with list of) actions.
     */
    CoreCoursesCourseLinkHandler.prototype.getActions = function (siteIds, url, params, courseId) {
        var _this = this;
        courseId = parseInt(params.id, 10);
        var sectionId = params.sectionid ? parseInt(params.sectionid, 10) : null, sectionNumber = typeof params.section != 'undefined' ? parseInt(params.section, 10) : NaN, pageParams = {
            course: { id: courseId },
            sectionId: sectionId || null
        };
        if (!isNaN(sectionNumber)) {
            pageParams.sectionNumber = sectionNumber;
        }
        return [{
                action: function (siteId, navCtrl) {
                    siteId = siteId || _this.sitesProvider.getCurrentSiteId();
                    if (siteId == _this.sitesProvider.getCurrentSiteId()) {
                        _this.actionEnrol(courseId, url, pageParams).catch(function () {
                            // Ignore errors.
                        });
                    }
                    else {
                        // Use redirect to make the course the new history root (to avoid "loops" in history).
                        _this.loginHelper.redirect('CoreCourseSectionPage', pageParams, siteId);
                    }
                }
            }];
    };
    /**
     * Check if the handler is enabled for a certain site (site + user) and a URL.
     * If not defined, defaults to true.
     *
     * @param {string} siteId The site ID.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {boolean|Promise<boolean>} Whether the handler is enabled for the URL and site.
     */
    CoreCoursesCourseLinkHandler.prototype.isEnabled = function (siteId, url, params, courseId) {
        courseId = parseInt(params.id, 10);
        if (!courseId) {
            return false;
        }
        // Get the course id of Site Home.
        return this.sitesProvider.getSiteHomeId(siteId).then(function (siteHomeId) {
            return courseId != siteHomeId;
        });
    };
    /**
     * Action to perform when an enrol link is clicked.
     *
     * @param {number} courseId Course ID.
     * @param {string} url Treated URL.
     * @param {any} pageParams Params to send to the new page.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreCoursesCourseLinkHandler.prototype.actionEnrol = function (courseId, url, pageParams) {
        var _this = this;
        var modal = this.domUtils.showModalLoading(), isEnrolUrl = !!url.match(/(\/enrol\/index\.php)|(\/course\/enrol\.php)/);
        // Check if user is enrolled in the course.
        return this.coursesProvider.getUserCourse(courseId).catch(function () {
            // User is not enrolled in the course. Check if can self enrol.
            return _this.canSelfEnrol(courseId).then(function () {
                modal.dismiss();
                // The user can self enrol. If it's not a enrolment URL we'll ask for confirmation.
                var promise = isEnrolUrl ? Promise.resolve() :
                    _this.domUtils.showConfirm(_this.translate.instant('core.courses.confirmselfenrol'));
                return promise.then(function () {
                    // Enrol URL or user confirmed.
                    return _this.selfEnrol(courseId).catch(function (error) {
                        if (error) {
                            _this.domUtils.showErrorModal(error);
                        }
                        return Promise.reject(null);
                    });
                }, function () {
                    // User cancelled. Check if the user can view the course contents (guest access or similar).
                    return _this.courseProvider.getSections(courseId, false, true);
                });
            }, function (error) {
                // Can't self enrol. Check if the user can view the course contents (guest access or similar).
                return _this.courseProvider.getSections(courseId, false, true).catch(function () {
                    // Error. Show error message and allow the user to open the link in browser.
                    modal.dismiss();
                    if (error) {
                        error = error.message || error.error || error.content || error.body || error;
                    }
                    if (!error) {
                        error = _this.translate.instant('core.courses.notenroled');
                    }
                    var body = _this.translate.instant('core.twoparagraphs', { p1: error, p2: _this.translate.instant('core.confirmopeninbrowser') });
                    _this.domUtils.showConfirm(body).then(function () {
                        _this.sitesProvider.getCurrentSite().openInBrowserWithAutoLogin(url);
                    }).catch(function () {
                        // User cancelled.
                    });
                    return Promise.reject(null);
                });
            });
        }).then(function () {
            modal.dismiss();
            // Use redirect to make the course the new history root (to avoid "loops" in history).
            _this.loginHelper.redirect('CoreCourseSectionPage', pageParams, _this.sitesProvider.getCurrentSiteId());
        });
    };
    /**
     * Check if a user can be "automatically" self enrolled in a course.
     *
     * @param {number} courseId Course ID.
     * @return {Promise<any>} Promise resolved if user can be enrolled in a course, rejected otherwise.
     */
    CoreCoursesCourseLinkHandler.prototype.canSelfEnrol = function (courseId) {
        // Check that the course has self enrolment enabled.
        return this.coursesProvider.getCourseEnrolmentMethods(courseId).then(function (methods) {
            var isSelfEnrolEnabled = false, instances = 0;
            methods.forEach(function (method) {
                if (method.type == 'self' && method.status) {
                    isSelfEnrolEnabled = true;
                    instances++;
                }
            });
            if (!isSelfEnrolEnabled || instances != 1) {
                // Self enrol not enabled or more than one instance.
                return Promise.reject(null);
            }
        });
    };
    /**
     * Try to self enrol a user in a course.
     *
     * @param {number} courseId Course ID.
     * @param {string} [password] Password.
     * @return {Promise<any>} Promise resolved when the user is enrolled, rejected otherwise.
     */
    CoreCoursesCourseLinkHandler.prototype.selfEnrol = function (courseId, password) {
        var _this = this;
        var modal = this.domUtils.showModalLoading();
        return this.coursesProvider.selfEnrol(courseId, password).then(function () {
            // Success self enrolling the user, invalidate the courses list.
            return _this.coursesProvider.invalidateUserCourses().catch(function () {
                // Ignore errors.
            }).then(function () {
                // Sometimes the list of enrolled courses takes a while to be updated. Wait for it.
                return _this.waitForEnrolled(courseId, true).finally(function () {
                    modal.dismiss();
                });
            });
        }).catch(function (error) {
            modal.dismiss();
            if (error && error.code === __WEBPACK_IMPORTED_MODULE_7__courses__["a" /* CoreCoursesProvider */].ENROL_INVALID_KEY) {
                // Invalid password. Allow the user to input password.
                var title = _this.translate.instant('core.courses.selfenrolment'), body = ' ', // Empty message.
                placeholder = _this.translate.instant('core.courses.password');
                if (typeof password != 'undefined') {
                    // The user attempted a password. Show an error message.
                    _this.domUtils.showErrorModal(error.message);
                }
                return _this.domUtils.showPrompt(body, title, placeholder).then(function (password) {
                    return _this.selfEnrol(courseId, password);
                });
            }
            else {
                return Promise.reject(error);
            }
        });
    };
    /**
     * Wait for the user to be enrolled in a course.
     *
     * @param {number} courseId The course ID.
     * @param {boolean} first If it's the first call (true) or it's a recursive call (false).
     * @return {Promise<any>} Promise resolved when enrolled or timeout.
     */
    CoreCoursesCourseLinkHandler.prototype.waitForEnrolled = function (courseId, first) {
        var _this = this;
        if (first) {
            this.waitStart = Date.now();
        }
        // Check if user is enrolled in the course.
        return this.coursesProvider.invalidateUserCourses().catch(function () {
            // Ignore errors.
        }).then(function () {
            return _this.coursesProvider.getUserCourse(courseId);
        }).catch(function () {
            // Not enrolled, wait a bit and try again.
            if (Date.now() - _this.waitStart > 60000) {
                // Max time reached, stop.
                return;
            }
            return new Promise(function (resolve, reject) {
                setTimeout(function () {
                    _this.waitForEnrolled(courseId).then(resolve);
                }, 5000);
            });
        });
    };
    CoreCoursesCourseLinkHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_7__courses__["a" /* CoreCoursesProvider */],
            __WEBPACK_IMPORTED_MODULE_5__core_login_providers_helper__["a" /* CoreLoginHelperProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_6__core_course_providers_course__["a" /* CoreCourseProvider */]])
    ], CoreCoursesCourseLinkHandler);
    return CoreCoursesCourseLinkHandler;
}(__WEBPACK_IMPORTED_MODULE_4__core_contentlinks_classes_base_handler__["a" /* CoreContentLinksHandlerBase */]));

//# sourceMappingURL=course-link-handler.js.map

/***/ }),
/* 1092 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCoursesIndexLinkHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_contentlinks_classes_base_handler__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_login_providers_helper__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__courses__ = __webpack_require__(31);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Handler to treat links to course index (list of courses).
 */
var CoreCoursesIndexLinkHandler = /** @class */ (function (_super) {
    __extends(CoreCoursesIndexLinkHandler, _super);
    function CoreCoursesIndexLinkHandler(coursesProvider, loginHelper) {
        var _this = _super.call(this) || this;
        _this.coursesProvider = coursesProvider;
        _this.loginHelper = loginHelper;
        _this.name = 'CoreCoursesIndexLinkHandler';
        _this.featureName = '$mmSideMenuDelegate_mmCourses';
        _this.pattern = /\/course\/?(index\.php.*)?$/;
        return _this;
    }
    /**
     * Get the list of actions for a link (url).
     *
     * @param {string[]} siteIds List of sites the URL belongs to.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {CoreContentLinksAction[] | Promise<CoreContentLinksAction[]>} List of (or promise resolved with list of) actions.
     */
    CoreCoursesIndexLinkHandler.prototype.getActions = function (siteIds, url, params, courseId) {
        var _this = this;
        return [{
                action: function (siteId, navCtrl) {
                    var page = 'CoreCoursesMyCoursesPage'; // By default, go to My Courses.
                    var pageParams = {};
                    if (_this.coursesProvider.isGetCoursesByFieldAvailable()) {
                        if (params.categoryid) {
                            page = 'CoreCoursesCategoriesPage';
                            pageParams.categoryId = parseInt(params.categoryid, 10);
                        }
                        else {
                            page = 'CoreCoursesAvailableCoursesPage';
                        }
                    }
                    // Always use redirect to make it the new history root (to avoid "loops" in history).
                    _this.loginHelper.redirect(page, pageParams, siteId);
                }
            }];
    };
    CoreCoursesIndexLinkHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__courses__["a" /* CoreCoursesProvider */], __WEBPACK_IMPORTED_MODULE_2__core_login_providers_helper__["a" /* CoreLoginHelperProvider */]])
    ], CoreCoursesIndexLinkHandler);
    return CoreCoursesIndexLinkHandler;
}(__WEBPACK_IMPORTED_MODULE_1__core_contentlinks_classes_base_handler__["a" /* CoreContentLinksHandlerBase */]));

//# sourceMappingURL=courses-index-link-handler.js.map

/***/ }),
/* 1093 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCoursesMyOverviewLinkHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_contentlinks_classes_base_handler__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_login_providers_helper__ = __webpack_require__(51);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Handler to treat links to my overview.
 */
var CoreCoursesMyOverviewLinkHandler = /** @class */ (function (_super) {
    __extends(CoreCoursesMyOverviewLinkHandler, _super);
    function CoreCoursesMyOverviewLinkHandler(loginHelper) {
        var _this = _super.call(this) || this;
        _this.loginHelper = loginHelper;
        _this.name = 'CoreCoursesMyOverviewLinkHandler';
        _this.featureName = '$mmSideMenuDelegate_mmCourses';
        _this.pattern = /\/my\/?$/;
        return _this;
    }
    /**
     * Get the list of actions for a link (url).
     *
     * @param {string[]} siteIds List of sites the URL belongs to.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {CoreContentLinksAction[]|Promise<CoreContentLinksAction[]>} List of (or promise resolved with list of) actions.
     */
    CoreCoursesMyOverviewLinkHandler.prototype.getActions = function (siteIds, url, params, courseId) {
        var _this = this;
        return [{
                action: function (siteId, navCtrl) {
                    // Always use redirect to make it the new history root (to avoid "loops" in history).
                    _this.loginHelper.redirect('CoreCoursesMyOverviewPage', undefined, siteId);
                }
            }];
    };
    CoreCoursesMyOverviewLinkHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__core_login_providers_helper__["a" /* CoreLoginHelperProvider */]])
    ], CoreCoursesMyOverviewLinkHandler);
    return CoreCoursesMyOverviewLinkHandler;
}(__WEBPACK_IMPORTED_MODULE_1__core_contentlinks_classes_base_handler__["a" /* CoreContentLinksHandlerBase */]));

//# sourceMappingURL=my-overview-link-handler.js.map

/***/ }),
/* 1094 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFileUploaderAlbumHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__helper__ = __webpack_require__(92);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Handler to upload files from the album.
 */
var CoreFileUploaderAlbumHandler = /** @class */ (function () {
    function CoreFileUploaderAlbumHandler(appProvider, utils, uploaderHelper) {
        this.appProvider = appProvider;
        this.utils = utils;
        this.uploaderHelper = uploaderHelper;
        this.name = 'CoreFileUploaderAlbum';
        this.priority = 2000;
    }
    /**
     * Whether or not the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} True or promise resolved with true if enabled.
     */
    CoreFileUploaderAlbumHandler.prototype.isEnabled = function () {
        return this.appProvider.isMobile();
    };
    /**
     * Given a list of mimetypes, return the ones that are supported by the handler.
     *
     * @param {string[]} [mimetypes] List of mimetypes.
     * @return {string[]} Supported mimetypes.
     */
    CoreFileUploaderAlbumHandler.prototype.getSupportedMimetypes = function (mimetypes) {
        // Album allows picking images and videos.
        return this.utils.filterByRegexp(mimetypes, /^(image|video)\//);
    };
    /**
     * Get the data to display the handler.
     *
     * @return {CoreFileUploaderHandlerData} Data.
     */
    CoreFileUploaderAlbumHandler.prototype.getData = function () {
        var _this = this;
        return {
            title: 'core.fileuploader.photoalbums',
            class: 'core-fileuploader-album-handler',
            icon: 'images',
            action: function (maxSize, upload, allowOffline, mimetypes) {
                return _this.uploaderHelper.uploadImage(true, maxSize, upload, mimetypes).then(function (result) {
                    return {
                        treated: true,
                        result: result
                    };
                });
            }
        };
    };
    CoreFileUploaderAlbumHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_3__helper__["a" /* CoreFileUploaderHelperProvider */]])
    ], CoreFileUploaderAlbumHandler);
    return CoreFileUploaderAlbumHandler;
}());

//# sourceMappingURL=album-handler.js.map

/***/ }),
/* 1095 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFileUploaderAudioHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__helper__ = __webpack_require__(92);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Handler to record an audio to upload it.
 */
var CoreFileUploaderAudioHandler = /** @class */ (function () {
    function CoreFileUploaderAudioHandler(appProvider, utils, platform, uploaderHelper) {
        this.appProvider = appProvider;
        this.utils = utils;
        this.platform = platform;
        this.uploaderHelper = uploaderHelper;
        this.name = 'CoreFileUploaderAudio';
        this.priority = 1600;
    }
    /**
     * Whether or not the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} True or promise resolved with true if enabled.
     */
    CoreFileUploaderAudioHandler.prototype.isEnabled = function () {
        return this.appProvider.isMobile() || (this.appProvider.canGetUserMedia() && this.appProvider.canRecordMedia());
    };
    /**
     * Given a list of mimetypes, return the ones that are supported by the handler.
     *
     * @param {string[]} [mimetypes] List of mimetypes.
     * @return {string[]} Supported mimetypes.
     */
    CoreFileUploaderAudioHandler.prototype.getSupportedMimetypes = function (mimetypes) {
        if (this.platform.is('ios')) {
            // In iOS it's recorded as WAV.
            return this.utils.filterByRegexp(mimetypes, /^audio\/wav$/);
        }
        else if (this.platform.is('android')) {
            // In Android we don't know the format the audio will be recorded, so accept any audio mimetype.
            return this.utils.filterByRegexp(mimetypes, /^audio\//);
        }
        else {
            // In desktop, support audio formats that are supported by MediaRecorder.
            var mediaRecorder_1 = window.MediaRecorder;
            if (mediaRecorder_1) {
                return mimetypes.filter(function (type) {
                    var matches = type.match(/^audio\//);
                    return matches && matches.length && mediaRecorder_1.isTypeSupported(type);
                });
            }
        }
        return [];
    };
    /**
     * Get the data to display the handler.
     *
     * @return {CoreFileUploaderHandlerData} Data.
     */
    CoreFileUploaderAudioHandler.prototype.getData = function () {
        var _this = this;
        return {
            title: 'core.fileuploader.audio',
            class: 'core-fileuploader-audio-handler',
            icon: 'microphone',
            action: function (maxSize, upload, allowOffline, mimetypes) {
                return _this.uploaderHelper.uploadAudioOrVideo(true, maxSize, upload, mimetypes).then(function (result) {
                    return {
                        treated: true,
                        result: result
                    };
                });
            }
        };
    };
    CoreFileUploaderAudioHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */],
            __WEBPACK_IMPORTED_MODULE_4__helper__["a" /* CoreFileUploaderHelperProvider */]])
    ], CoreFileUploaderAudioHandler);
    return CoreFileUploaderAudioHandler;
}());

//# sourceMappingURL=audio-handler.js.map

/***/ }),
/* 1096 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFileUploaderCameraHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__helper__ = __webpack_require__(92);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Handler to take a picture to upload it.
 */
var CoreFileUploaderCameraHandler = /** @class */ (function () {
    function CoreFileUploaderCameraHandler(appProvider, utils, uploaderHelper) {
        this.appProvider = appProvider;
        this.utils = utils;
        this.uploaderHelper = uploaderHelper;
        this.name = 'CoreFileUploaderCamera';
        this.priority = 1800;
    }
    /**
     * Whether or not the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} True or promise resolved with true if enabled.
     */
    CoreFileUploaderCameraHandler.prototype.isEnabled = function () {
        return this.appProvider.isMobile() || this.appProvider.canGetUserMedia();
    };
    /**
     * Given a list of mimetypes, return the ones that are supported by the handler.
     *
     * @param {string[]} [mimetypes] List of mimetypes.
     * @return {string[]} Supported mimetypes.
     */
    CoreFileUploaderCameraHandler.prototype.getSupportedMimetypes = function (mimetypes) {
        // Camera only supports JPEG and PNG.
        return this.utils.filterByRegexp(mimetypes, /^image\/(jpeg|png)$/);
    };
    /**
     * Get the data to display the handler.
     *
     * @return {CoreFileUploaderHandlerData} Data.
     */
    CoreFileUploaderCameraHandler.prototype.getData = function () {
        var _this = this;
        return {
            title: 'core.fileuploader.camera',
            class: 'core-fileuploader-camera-handler',
            icon: 'camera',
            action: function (maxSize, upload, allowOffline, mimetypes) {
                return _this.uploaderHelper.uploadImage(false, maxSize, upload, mimetypes).then(function (result) {
                    return {
                        treated: true,
                        result: result
                    };
                });
            }
        };
    };
    CoreFileUploaderCameraHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_3__helper__["a" /* CoreFileUploaderHelperProvider */]])
    ], CoreFileUploaderCameraHandler);
    return CoreFileUploaderCameraHandler;
}());

//# sourceMappingURL=camera-handler.js.map

/***/ }),
/* 1097 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFileUploaderFileHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_time__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__helper__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__fileuploader__ = __webpack_require__(162);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};







/**
 * Handler to upload any type of file.
 */
var CoreFileUploaderFileHandler = /** @class */ (function () {
    function CoreFileUploaderFileHandler(appProvider, platform, timeUtils, uploaderHelper, uploaderProvider, domUtils) {
        this.appProvider = appProvider;
        this.platform = platform;
        this.timeUtils = timeUtils;
        this.uploaderHelper = uploaderHelper;
        this.uploaderProvider = uploaderProvider;
        this.domUtils = domUtils;
        this.name = 'CoreFileUploaderFile';
        this.priority = 1200;
    }
    /**
     * Whether or not the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} True or promise resolved with true if enabled.
     */
    CoreFileUploaderFileHandler.prototype.isEnabled = function () {
        return this.platform.is('android') || !this.appProvider.isMobile() ||
            (this.platform.is('ios') && this.platform.version().major >= 9);
    };
    /**
     * Given a list of mimetypes, return the ones that are supported by the handler.
     *
     * @param {string[]} [mimetypes] List of mimetypes.
     * @return {string[]} Supported mimetypes.
     */
    CoreFileUploaderFileHandler.prototype.getSupportedMimetypes = function (mimetypes) {
        return mimetypes;
    };
    /**
     * Get the data to display the handler.
     *
     * @return {CoreFileUploaderHandlerData} Data.
     */
    CoreFileUploaderFileHandler.prototype.getData = function () {
        var _this = this;
        var isIOS = this.platform.is('ios');
        return {
            title: isIOS ? 'core.fileuploader.more' : 'core.fileuploader.file',
            class: 'core-fileuploader-file-handler',
            icon: isIOS ? 'more' : 'folder',
            afterRender: function (maxSize, upload, allowOffline, mimetypes) {
                // Add an invisible file input in the file handler.
                // It needs to be done like this because the action sheet items don't accept inputs.
                var element = document.querySelector('.core-fileuploader-file-handler');
                if (element) {
                    var input_1 = document.createElement('input');
                    input_1.setAttribute('type', 'file');
                    if (mimetypes && mimetypes.length && (!_this.platform.is('android') || mimetypes.length == 1)) {
                        // Don't use accept attribute in Android with several mimetypes, it's not supported.
                        input_1.setAttribute('accept', mimetypes.join(', '));
                    }
                    input_1.addEventListener('change', function (evt) {
                        var file = input_1.files[0];
                        var fileName;
                        input_1.value = ''; // Unset input.
                        if (!file) {
                            return;
                        }
                        // Verify that the mimetype of the file is supported, in case the accept attribute isn't supported.
                        var error = _this.uploaderProvider.isInvalidMimetype(mimetypes, file.name, file.type);
                        if (error) {
                            _this.domUtils.showErrorModal(error);
                            return;
                        }
                        fileName = file.name;
                        if (isIOS) {
                            // Check the name of the file and add a timestamp if needed (take picture).
                            var matches = fileName.match(/image\.(jpe?g|png)/);
                            if (matches) {
                                fileName = 'image_' + _this.timeUtils.readableTimestamp() + '.' + matches[1];
                            }
                        }
                        // Upload the picked file.
                        _this.uploaderHelper.uploadFileObject(file, maxSize, upload, allowOffline, fileName).then(function (result) {
                            _this.uploaderHelper.fileUploaded(result);
                        }).catch(function (error) {
                            if (error) {
                                _this.domUtils.showErrorModal(error);
                            }
                        });
                    });
                    element.appendChild(input_1);
                }
            }
        };
    };
    CoreFileUploaderFileHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */], __WEBPACK_IMPORTED_MODULE_4__providers_utils_time__["a" /* CoreTimeUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_5__helper__["a" /* CoreFileUploaderHelperProvider */], __WEBPACK_IMPORTED_MODULE_6__fileuploader__["a" /* CoreFileUploaderProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__["a" /* CoreDomUtilsProvider */]])
    ], CoreFileUploaderFileHandler);
    return CoreFileUploaderFileHandler;
}());

//# sourceMappingURL=file-handler.js.map

/***/ }),
/* 1098 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFileUploaderVideoHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__helper__ = __webpack_require__(92);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Handler to record a video to upload it.
 */
var CoreFileUploaderVideoHandler = /** @class */ (function () {
    function CoreFileUploaderVideoHandler(appProvider, utils, platform, uploaderHelper) {
        this.appProvider = appProvider;
        this.utils = utils;
        this.platform = platform;
        this.uploaderHelper = uploaderHelper;
        this.name = 'CoreFileUploaderVideo';
        this.priority = 1400;
    }
    /**
     * Whether or not the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} True or promise resolved with true if enabled.
     */
    CoreFileUploaderVideoHandler.prototype.isEnabled = function () {
        return this.appProvider.isMobile() || (this.appProvider.canGetUserMedia() && this.appProvider.canRecordMedia());
    };
    /**
     * Given a list of mimetypes, return the ones that are supported by the handler.
     *
     * @param {string[]} [mimetypes] List of mimetypes.
     * @return {string[]} Supported mimetypes.
     */
    CoreFileUploaderVideoHandler.prototype.getSupportedMimetypes = function (mimetypes) {
        if (this.platform.is('ios')) {
            // In iOS it's recorded as MOV.
            return this.utils.filterByRegexp(mimetypes, /^video\/quicktime$/);
        }
        else if (this.platform.is('android')) {
            // In Android we don't know the format the video will be recorded, so accept any video mimetype.
            return this.utils.filterByRegexp(mimetypes, /^video\//);
        }
        else {
            // In desktop, support video formats that are supported by MediaRecorder.
            var mediaRecorder_1 = window.MediaRecorder;
            if (mediaRecorder_1) {
                return mimetypes.filter(function (type) {
                    var matches = type.match(/^video\//);
                    return matches && matches.length && mediaRecorder_1.isTypeSupported(type);
                });
            }
        }
        return [];
    };
    /**
     * Get the data to display the handler.
     *
     * @return {CoreFileUploaderHandlerData} Data.
     */
    CoreFileUploaderVideoHandler.prototype.getData = function () {
        var _this = this;
        return {
            title: 'core.fileuploader.video',
            class: 'core-fileuploader-video-handler',
            icon: 'videocam',
            action: function (maxSize, upload, allowOffline, mimetypes) {
                return _this.uploaderHelper.uploadAudioOrVideo(false, maxSize, upload, mimetypes).then(function (result) {
                    return {
                        treated: true,
                        result: result
                    };
                });
            }
        };
    };
    CoreFileUploaderVideoHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */],
            __WEBPACK_IMPORTED_MODULE_4__helper__["a" /* CoreFileUploaderHelperProvider */]])
    ], CoreFileUploaderVideoHandler);
    return CoreFileUploaderVideoHandler;
}());

//# sourceMappingURL=video-handler.js.map

/***/ }),
/* 1099 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreGradesMainMenuHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__grades__ = __webpack_require__(78);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Handler to inject an option into main menu.
 */
var CoreGradesMainMenuHandler = /** @class */ (function () {
    function CoreGradesMainMenuHandler(gradesProvider) {
        this.gradesProvider = gradesProvider;
        this.name = 'CoreGrades';
        this.priority = 600;
    }
    /**
     * Check if the handler is enabled on a site level.
     *
     * @return {boolean | Promise<boolean>} Whether or not the handler is enabled on a site level.
     */
    CoreGradesMainMenuHandler.prototype.isEnabled = function () {
        return this.gradesProvider.isCourseGradesEnabled();
    };
    /**
     * Returns the data needed to render the handler.
     *
     * @return {CoreMainMenuHandlerData} Data needed to render the handler.
     */
    CoreGradesMainMenuHandler.prototype.getDisplayData = function () {
        return {
            icon: 'stats',
            title: 'core.grades.grades',
            page: 'CoreGradesCoursesPage',
            class: 'core-grades-coursesgrades-handler'
        };
    };
    CoreGradesMainMenuHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__grades__["a" /* CoreGradesProvider */]])
    ], CoreGradesMainMenuHandler);
    return CoreGradesMainMenuHandler;
}());

//# sourceMappingURL=mainmenu-handler.js.map

/***/ }),
/* 1100 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreGradesCourseOptionHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_course_providers_course__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__grades__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_courses_providers_courses__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__components_course_course__ = __webpack_require__(601);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Course nav handler.
 */
var CoreGradesCourseOptionHandler = /** @class */ (function () {
    function CoreGradesCourseOptionHandler(gradesProvider, coursesProvider) {
        this.gradesProvider = gradesProvider;
        this.coursesProvider = coursesProvider;
        this.name = 'CoreGrades';
        this.priority = 400;
    }
    /**
     * Should invalidate the data to determine if the handler is enabled for a certain course.
     *
     * @param {number} courseId The course ID.
     * @param {any} [navOptions] Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.
     * @param {any} [admOptions] Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreGradesCourseOptionHandler.prototype.invalidateEnabledForCourse = function (courseId, navOptions, admOptions) {
        if (navOptions && typeof navOptions.grades != 'undefined') {
            // No need to invalidate anything.
            return Promise.resolve();
        }
        return this.coursesProvider.invalidateUserCourses();
    };
    /**
     * Check if the handler is enabled on a site level.
     *
     * @return {boolean} Whether or not the handler is enabled on a site level.
     */
    CoreGradesCourseOptionHandler.prototype.isEnabled = function () {
        return true;
    };
    /**
     * Whether or not the handler is enabled for a certain course.
     *
     * @param {number} courseId The course ID.
     * @param {any} accessData Access type and data. Default, guest, ...
     * @param {any} [navOptions] Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.
     * @param {any} [admOptions] Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.
     * @return {boolean|Promise<boolean>} True or promise resolved with true if enabled.
     */
    CoreGradesCourseOptionHandler.prototype.isEnabledForCourse = function (courseId, accessData, navOptions, admOptions) {
        if (accessData && accessData.type == __WEBPACK_IMPORTED_MODULE_1__core_course_providers_course__["a" /* CoreCourseProvider */].ACCESS_GUEST) {
            return false; // Not enabled for guests.
        }
        if (navOptions && typeof navOptions.grades != 'undefined') {
            return navOptions.grades;
        }
        return this.gradesProvider.isPluginEnabledForCourse(courseId);
    };
    /**
     * Returns the data needed to render the handler.
     *
     * @param {Injector} injector Injector.
     * @param {number} courseId The course ID.
     * @return {CoreCourseOptionsHandlerData|Promise<CoreCourseOptionsHandlerData>} Data or promise resolved with the data.
     */
    CoreGradesCourseOptionHandler.prototype.getDisplayData = function (injector, courseId) {
        return {
            title: 'core.grades.grades',
            class: 'core-grades-course-handler',
            component: __WEBPACK_IMPORTED_MODULE_4__components_course_course__["a" /* CoreGradesCourseComponent */]
        };
    };
    CoreGradesCourseOptionHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__grades__["a" /* CoreGradesProvider */], __WEBPACK_IMPORTED_MODULE_3__core_courses_providers_courses__["a" /* CoreCoursesProvider */]])
    ], CoreGradesCourseOptionHandler);
    return CoreGradesCourseOptionHandler;
}());

//# sourceMappingURL=course-option-handler.js.map

/***/ }),
/* 1101 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreGradesUserLinkHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_contentlinks_classes_base_handler__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_contentlinks_providers_helper__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__grades__ = __webpack_require__(78);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Handler to treat links to user grades.
 */
var CoreGradesUserLinkHandler = /** @class */ (function (_super) {
    __extends(CoreGradesUserLinkHandler, _super);
    function CoreGradesUserLinkHandler(linkHelper, gradesProvider) {
        var _this = _super.call(this) || this;
        _this.linkHelper = linkHelper;
        _this.gradesProvider = gradesProvider;
        _this.name = 'CoreGradesUserLinkHandler';
        _this.pattern = /\/grade\/report\/user\/index.php/;
        return _this;
    }
    /**
     * Get the list of actions for a link (url).
     *
     * @param {string[]} siteIds List of sites the URL belongs to.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {CoreContentLinksAction[]|Promise<CoreContentLinksAction[]>} List of (or promise resolved with list of) actions.
     */
    CoreGradesUserLinkHandler.prototype.getActions = function (siteIds, url, params, courseId) {
        var _this = this;
        return [{
                action: function (siteId, navCtrl) {
                    var pageParams = {
                        course: { id: courseId },
                        userId: params.userid ? parseInt(params.userid, 10) : false,
                    };
                    // Always use redirect to make it the new history root (to avoid "loops" in history).
                    _this.linkHelper.goInSite(navCtrl, 'CoreGradesCoursePage', pageParams, siteId);
                }
            }];
    };
    /**
     * Check if the handler is enabled for a certain site (site + user) and a URL.
     * If not defined, defaults to true.
     *
     * @param {string} siteId The site ID.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {boolean|Promise<boolean>} Whether the handler is enabled for the URL and site.
     */
    CoreGradesUserLinkHandler.prototype.isEnabled = function (siteId, url, params, courseId) {
        if (!courseId) {
            return false;
        }
        return this.gradesProvider.isPluginEnabledForCourse(courseId, siteId);
    };
    CoreGradesUserLinkHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__core_contentlinks_providers_helper__["a" /* CoreContentLinksHelperProvider */], __WEBPACK_IMPORTED_MODULE_3__grades__["a" /* CoreGradesProvider */]])
    ], CoreGradesUserLinkHandler);
    return CoreGradesUserLinkHandler;
}(__WEBPACK_IMPORTED_MODULE_1__core_contentlinks_classes_base_handler__["a" /* CoreContentLinksHandlerBase */]));

//# sourceMappingURL=user-link-handler.js.map

/***/ }),
/* 1102 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreGradesOverviewLinkHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_contentlinks_classes_base_handler__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_contentlinks_providers_helper__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__grades__ = __webpack_require__(78);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Handler to treat links to overview courses grades.
 */
var CoreGradesOverviewLinkHandler = /** @class */ (function (_super) {
    __extends(CoreGradesOverviewLinkHandler, _super);
    function CoreGradesOverviewLinkHandler(linkHelper, gradesProvider) {
        var _this = _super.call(this) || this;
        _this.linkHelper = linkHelper;
        _this.gradesProvider = gradesProvider;
        _this.name = 'CoreGradesOverviewLinkHandler';
        _this.pattern = /\/grade\/report\/overview\/index.php/;
        return _this;
    }
    /**
     * Get the list of actions for a link (url).
     *
     * @param {string[]} siteIds List of sites the URL belongs to.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {CoreContentLinksAction[]|Promise<CoreContentLinksAction[]>} List of (or promise resolved with list of) actions.
     */
    CoreGradesOverviewLinkHandler.prototype.getActions = function (siteIds, url, params, courseId) {
        var _this = this;
        return [{
                action: function (siteId, navCtrl) {
                    // Always use redirect to make it the new history root (to avoid "loops" in history).
                    _this.linkHelper.goInSite(navCtrl, 'CoreGradesCoursesPage', undefined, siteId);
                }
            }];
    };
    /**
     * Check if the handler is enabled for a certain site (site + user) and a URL.
     * If not defined, defaults to true.
     *
     * @param {string} siteId The site ID.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {boolean|Promise<boolean>} Whether the handler is enabled for the URL and site.
     */
    CoreGradesOverviewLinkHandler.prototype.isEnabled = function (siteId, url, params, courseId) {
        return this.gradesProvider.isCourseGradesEnabled(siteId);
    };
    CoreGradesOverviewLinkHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__core_contentlinks_providers_helper__["a" /* CoreContentLinksHelperProvider */], __WEBPACK_IMPORTED_MODULE_3__grades__["a" /* CoreGradesProvider */]])
    ], CoreGradesOverviewLinkHandler);
    return CoreGradesOverviewLinkHandler;
}(__WEBPACK_IMPORTED_MODULE_1__core_contentlinks_classes_base_handler__["a" /* CoreContentLinksHandlerBase */]));

//# sourceMappingURL=overview-link-handler.js.map

/***/ }),
/* 1103 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreGradesUserHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_user_providers_user_delegate__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_contentlinks_providers_helper__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__grades__ = __webpack_require__(78);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Profile grades handler.
 */
var CoreGradesUserHandler = /** @class */ (function () {
    function CoreGradesUserHandler(linkHelper, sitesProvider, gradesProvider) {
        this.linkHelper = linkHelper;
        this.sitesProvider = sitesProvider;
        this.gradesProvider = gradesProvider;
        this.name = 'mmGrades';
        this.priority = 400;
        this.type = __WEBPACK_IMPORTED_MODULE_1__core_user_providers_user_delegate__["a" /* CoreUserDelegate */].TYPE_NEW_PAGE;
        this.viewGradesEnabledCache = {};
    }
    /**
     * Clear view grades cache.
     * If a courseId and userId are specified, it will only delete the entry for that user and course.
     *
     * @param  {number} [courseId] Course ID.
     * @param  {number} [userId]   User ID.
     */
    CoreGradesUserHandler.prototype.clearViewGradesCache = function (courseId, userId) {
        if (courseId && userId) {
            delete this.viewGradesEnabledCache[this.getCacheKey(courseId, userId)];
        }
        else {
            this.viewGradesEnabledCache = {};
        }
    };
    /**
     * Get a cache key to identify a course and a user.
     *
     * @param  {number} courseId Course ID.
     * @param  {number} userId   User ID.
     * @return {string}          Cache key.
     */
    CoreGradesUserHandler.prototype.getCacheKey = function (courseId, userId) {
        return courseId + '#' + userId;
    };
    /**
     * Check if handler is enabled.
     *
     * @return {boolean} Always enabled.
     */
    CoreGradesUserHandler.prototype.isEnabled = function () {
        return true;
    };
    /**
     * Check if handler is enabled for this user in this context.
     *
     * @param {any} user     User to check.
     * @param {number} courseId Course ID.
     * @param  {any} [navOptions] Course navigation options for current user. See $mmCourses#getUserNavigationOptions.
     * @param  {any} [admOptions] Course admin options for current user. See $mmCourses#getUserAdministrationOptions.
     * @return  {boolean|Promise<boolean>}   Promise resolved with true if enabled, resolved with false otherwise.
     */
    CoreGradesUserHandler.prototype.isEnabledForUser = function (user, courseId, navOptions, admOptions) {
        var _this = this;
        var cacheKey = this.getCacheKey(courseId, user.id), cache = this.viewGradesEnabledCache[cacheKey];
        if (typeof cache != 'undefined') {
            return cache;
        }
        return this.gradesProvider.isPluginEnabledForCourse(courseId).then(function () {
            return _this.gradesProvider.getCourseGradesTable(courseId, user.id).then(function () {
                _this.viewGradesEnabledCache[cacheKey] = true;
                return true;
            }).catch(function () {
                _this.viewGradesEnabledCache[cacheKey] = false;
                return false;
            });
        });
    };
    /**
     * Returns the data needed to render the handler.
     *
     * @return {CoreUserProfileHandlerData} Data needed to render the handler.
     */
    CoreGradesUserHandler.prototype.getDisplayData = function (user, courseId) {
        var _this = this;
        return {
            icon: 'stats',
            title: 'core.grades.grades',
            class: 'core-grades-user-handler',
            action: function (event, navCtrl, user, courseId) {
                event.preventDefault();
                event.stopPropagation();
                var pageParams = {
                    courseId: courseId,
                    userId: user.id
                };
                // Always use redirect to make it the new history root (to avoid "loops" in history).
                _this.linkHelper.goInSite(navCtrl, 'CoreGradesCoursePage', pageParams);
            }
        };
    };
    CoreGradesUserHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__core_contentlinks_providers_helper__["a" /* CoreContentLinksHelperProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_4__grades__["a" /* CoreGradesProvider */]])
    ], CoreGradesUserHandler);
    return CoreGradesUserHandler;
}());

//# sourceMappingURL=user-handler.js.map

/***/ }),
/* 1104 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSharedFilesUploadHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__helper__ = __webpack_require__(297);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Handler to upload files from the album.
 */
var CoreSharedFilesUploadHandler = /** @class */ (function () {
    function CoreSharedFilesUploadHandler(sharedFilesHelper, platform) {
        this.sharedFilesHelper = sharedFilesHelper;
        this.platform = platform;
        this.name = 'CoreSharedFilesUpload';
        this.priority = 1300;
    }
    /**
     * Whether or not the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} True or promise resolved with true if enabled.
     */
    CoreSharedFilesUploadHandler.prototype.isEnabled = function () {
        return this.platform.is('ios');
    };
    /**
     * Given a list of mimetypes, return the ones that are supported by the handler.
     *
     * @param {string[]} [mimetypes] List of mimetypes.
     * @return {string[]} Supported mimetypes.
     */
    CoreSharedFilesUploadHandler.prototype.getSupportedMimetypes = function (mimetypes) {
        return mimetypes;
    };
    /**
     * Get the data to display the handler.
     *
     * @return {CoreFileUploaderHandlerData} Data.
     */
    CoreSharedFilesUploadHandler.prototype.getData = function () {
        var _this = this;
        return {
            title: 'core.sharedfiles.sharedfiles',
            class: 'core-sharedfiles-fileuploader-handler',
            icon: 'folder',
            action: function (maxSize, upload, allowOffline, mimetypes) {
                // Don't use the params because the file won't be uploaded, it is returned to the fileuploader.
                return _this.sharedFilesHelper.pickSharedFile(mimetypes);
            }
        };
    };
    CoreSharedFilesUploadHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__helper__["a" /* CoreSharedFilesHelperProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */]])
    ], CoreSharedFilesUploadHandler);
    return CoreSharedFilesUploadHandler;
}());

//# sourceMappingURL=upload-handler.js.map

/***/ }),
/* 1105 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSiteHomeMainMenuHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__sitehome__ = __webpack_require__(138);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_courses_providers_my_overview__ = __webpack_require__(180);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Handler to add Site Home into main menu.
 */
var CoreSiteHomeMainMenuHandler = /** @class */ (function () {
    function CoreSiteHomeMainMenuHandler(siteHomeProvider, myOverviewProvider) {
        this.siteHomeProvider = siteHomeProvider;
        this.myOverviewProvider = myOverviewProvider;
        this.name = 'CoreSiteHome';
        this.priority = 1000;
    }
    /**
     * Check if the handler is enabled on a site level.
     *
     * @return {boolean} Whether or not the handler is enabled on a site level.
     */
    CoreSiteHomeMainMenuHandler.prototype.isEnabled = function () {
        var _this = this;
        // Check if my overview is enabled.
        return this.myOverviewProvider.isEnabled().then(function (enabled) {
            if (enabled) {
                // My overview is enabled, Site Home will be inside the overview page.
                return false;
            }
            // My overview not enabled, check if site home is enabled.
            return _this.siteHomeProvider.isAvailable();
        });
    };
    /**
     * Returns the data needed to render the handler.
     *
     * @return {CoreMainMenuHandlerData} Data needed to render the handler.
     */
    CoreSiteHomeMainMenuHandler.prototype.getDisplayData = function () {
        return {
            icon: 'home',
            title: 'core.sitehome.sitehome',
            page: 'CoreSiteHomeIndexPage',
            class: 'core-sitehome-handler'
        };
    };
    CoreSiteHomeMainMenuHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__sitehome__["a" /* CoreSiteHomeProvider */], __WEBPACK_IMPORTED_MODULE_2__core_courses_providers_my_overview__["a" /* CoreCoursesMyOverviewProvider */]])
    ], CoreSiteHomeMainMenuHandler);
    return CoreSiteHomeMainMenuHandler;
}());

//# sourceMappingURL=mainmenu-handler.js.map

/***/ }),
/* 1106 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSiteHomeIndexLinkHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_contentlinks_classes_base_handler__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_login_providers_helper__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__sitehome__ = __webpack_require__(138);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Handler to treat links to site home index.
 */
var CoreSiteHomeIndexLinkHandler = /** @class */ (function (_super) {
    __extends(CoreSiteHomeIndexLinkHandler, _super);
    function CoreSiteHomeIndexLinkHandler(sitesProvider, siteHomeProvider, loginHelper) {
        var _this = _super.call(this) || this;
        _this.sitesProvider = sitesProvider;
        _this.siteHomeProvider = siteHomeProvider;
        _this.loginHelper = loginHelper;
        _this.name = 'CoreSiteHomeIndexLinkHandler';
        _this.featureName = '$mmSideMenuDelegate_mmaFrontpage';
        _this.pattern = /\/course\/view\.php.*([\?\&]id=\d+)/;
        return _this;
    }
    /**
     * Get the list of actions for a link (url).
     *
     * @param {string[]} siteIds List of sites the URL belongs to.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {CoreContentLinksAction[]|Promise<CoreContentLinksAction[]>} List of (or promise resolved with list of) actions.
     */
    CoreSiteHomeIndexLinkHandler.prototype.getActions = function (siteIds, url, params, courseId) {
        var _this = this;
        return [{
                action: function (siteId, navCtrl) {
                    // Always use redirect to make it the new history root (to avoid "loops" in history).
                    _this.loginHelper.redirect('CoreSiteHomeIndexPage', undefined, siteId);
                }
            }];
    };
    /**
     * Check if the handler is enabled for a certain site (site + user) and a URL.
     * If not defined, defaults to true.
     *
     * @param {string} siteId The site ID.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {boolean|Promise<boolean>} Whether the handler is enabled for the URL and site.
     */
    CoreSiteHomeIndexLinkHandler.prototype.isEnabled = function (siteId, url, params, courseId) {
        var _this = this;
        courseId = parseInt(params.id, 10);
        if (!courseId) {
            return false;
        }
        return this.sitesProvider.getSite(siteId).then(function (site) {
            if (courseId != site.getSiteHomeId()) {
                // The course is not site home.
                return false;
            }
            return _this.siteHomeProvider.isAvailable(siteId).then(function () {
                return true;
            }).catch(function () {
                return false;
            });
        });
    };
    CoreSiteHomeIndexLinkHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_4__sitehome__["a" /* CoreSiteHomeProvider */],
            __WEBPACK_IMPORTED_MODULE_3__core_login_providers_helper__["a" /* CoreLoginHelperProvider */]])
    ], CoreSiteHomeIndexLinkHandler);
    return CoreSiteHomeIndexLinkHandler;
}(__WEBPACK_IMPORTED_MODULE_2__core_contentlinks_classes_base_handler__["a" /* CoreContentLinksHandlerBase */]));

//# sourceMappingURL=index-link-handler.js.map

/***/ }),
/* 1107 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreUserProfileMailHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__user_delegate__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(3);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Profile links email handler.
 */
var CoreUserProfileMailHandler = /** @class */ (function () {
    function CoreUserProfileMailHandler(sitesProvider) {
        this.sitesProvider = sitesProvider;
        this.name = 'mmUser';
        this.priority = 700;
        this.type = __WEBPACK_IMPORTED_MODULE_1__user_delegate__["a" /* CoreUserDelegate */].TYPE_COMMUNICATION;
    }
    /**
     * Check if handler is enabled.
     *
     * @return {boolean} Always enabled.
     */
    CoreUserProfileMailHandler.prototype.isEnabled = function () {
        return true;
    };
    /**
     * Check if handler is enabled for this user in this context.
     *
     * @param {any} user     User to check.
     * @param {number} courseId Course ID.
     * @param  {any} [navOptions] Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.
     * @param  {any} [admOptions] Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.
     * @return  {boolean|Promise<boolean>}   Promise resolved with true if enabled, resolved with false otherwise.
     */
    CoreUserProfileMailHandler.prototype.isEnabledForUser = function (user, courseId, navOptions, admOptions) {
        // Not current user required.
        return user.id != this.sitesProvider.getCurrentSite().getUserId() && user.email;
    };
    /**
     * Returns the data needed to render the handler.
     *
     * @return {CoreUserProfileHandlerData} Data needed to render the handler.
     */
    CoreUserProfileMailHandler.prototype.getDisplayData = function (user, courseId) {
        return {
            icon: 'mail',
            title: 'core.user.sendemail',
            class: 'core-user-profile-mail',
            action: function (event, navCtrl, user, courseId) {
                event.preventDefault();
                event.stopPropagation();
                window.open('mailto:' + user.email, '_blank');
            }
        };
    };
    CoreUserProfileMailHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */]])
    ], CoreUserProfileMailHandler);
    return CoreUserProfileMailHandler;
}());

//# sourceMappingURL=user-handler.js.map

/***/ }),
/* 1108 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreUserProfileLinkHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_contentlinks_classes_base_handler__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_contentlinks_providers_helper__ = __webpack_require__(45);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Handler to treat links to user profiles.
 */
var CoreUserProfileLinkHandler = /** @class */ (function (_super) {
    __extends(CoreUserProfileLinkHandler, _super);
    function CoreUserProfileLinkHandler(linkHelper) {
        var _this = _super.call(this) || this;
        _this.linkHelper = linkHelper;
        _this.name = 'CoreUserProfileLinkHandler';
        // Match user/view.php and user/profile.php but NOT grade/report/user/.
        _this.pattern = /((\/user\/view\.php)|(\/user\/profile\.php)).*([\?\&]id=\d+)/;
        return _this;
    }
    /**
     * Get the list of actions for a link (url).
     *
     * @param {string[]} siteIds List of sites the URL belongs to.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {CoreContentLinksAction[]|Promise<CoreContentLinksAction[]>} List of (or promise resolved with list of) actions.
     */
    CoreUserProfileLinkHandler.prototype.getActions = function (siteIds, url, params, courseId) {
        var _this = this;
        return [{
                action: function (siteId, navCtrl) {
                    var pageParams = {
                        courseId: params.course,
                        userId: parseInt(params.id, 10)
                    };
                    // Always use redirect to make it the new history root (to avoid "loops" in history).
                    _this.linkHelper.goInSite(navCtrl, 'CoreUserProfilePage', pageParams, siteId);
                }
            }];
    };
    /**
     * Check if the handler is enabled for a certain site (site + user) and a URL.
     * If not defined, defaults to true.
     *
     * @param {string} siteId The site ID.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {boolean|Promise<boolean>} Whether the handler is enabled for the URL and site.
     */
    CoreUserProfileLinkHandler.prototype.isEnabled = function (siteId, url, params, courseId) {
        return url.indexOf('/grade/report/') == -1;
    };
    CoreUserProfileLinkHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__core_contentlinks_providers_helper__["a" /* CoreContentLinksHelperProvider */]])
    ], CoreUserProfileLinkHandler);
    return CoreUserProfileLinkHandler;
}(__WEBPACK_IMPORTED_MODULE_1__core_contentlinks_classes_base_handler__["a" /* CoreContentLinksHandlerBase */]));

//# sourceMappingURL=user-link-handler.js.map

/***/ }),
/* 1109 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreUserParticipantsCourseOptionHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_course_providers_course__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__user__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__components_participants_participants__ = __webpack_require__(602);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Course nav handler.
 */
var CoreUserParticipantsCourseOptionHandler = /** @class */ (function () {
    function CoreUserParticipantsCourseOptionHandler(userProvider) {
        this.userProvider = userProvider;
        this.name = 'CoreUserParticipants';
        this.priority = 600;
    }
    /**
     * Should invalidate the data to determine if the handler is enabled for a certain course.
     *
     * @param {number} courseId The course ID.
     * @param {any} [navOptions] Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.
     * @param {any} [admOptions] Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreUserParticipantsCourseOptionHandler.prototype.invalidateEnabledForCourse = function (courseId, navOptions, admOptions) {
        if (navOptions && typeof navOptions.participants != 'undefined') {
            // No need to invalidate anything.
            return Promise.resolve();
        }
        return this.userProvider.invalidateParticipantsList(courseId);
    };
    /**
     * Check if the handler is enabled on a site level.
     *
     * @return {boolean} Whether or not the handler is enabled on a site level.
     */
    CoreUserParticipantsCourseOptionHandler.prototype.isEnabled = function () {
        return true;
    };
    /**
     * Whether or not the handler is enabled for a certain course.
     *
     * @param {number} courseId The course ID.
     * @param {any} accessData Access type and data. Default, guest, ...
     * @param {any} [navOptions] Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.
     * @param {any} [admOptions] Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.
     * @return {boolean|Promise<boolean>} True or promise resolved with true if enabled.
     */
    CoreUserParticipantsCourseOptionHandler.prototype.isEnabledForCourse = function (courseId, accessData, navOptions, admOptions) {
        if (accessData && accessData.type == __WEBPACK_IMPORTED_MODULE_1__core_course_providers_course__["a" /* CoreCourseProvider */].ACCESS_GUEST) {
            return false; // Not enabled for guests.
        }
        if (navOptions && typeof navOptions.participants != 'undefined') {
            return navOptions.participants;
        }
        return this.userProvider.isPluginEnabledForCourse(courseId);
    };
    /**
     * Returns the data needed to render the handler.
     *
     * @param {Injector} injector Injector.
     * @param {number} courseId The course ID.
     * @return {CoreCourseOptionsHandlerData|Promise<CoreCourseOptionsHandlerData>} Data or promise resolved with the data.
     */
    CoreUserParticipantsCourseOptionHandler.prototype.getDisplayData = function (injector, courseId) {
        return {
            title: 'core.user.participants',
            class: 'core-user-participants-handler',
            component: __WEBPACK_IMPORTED_MODULE_3__components_participants_participants__["a" /* CoreUserParticipantsComponent */]
        };
    };
    CoreUserParticipantsCourseOptionHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__user__["a" /* CoreUserProvider */]])
    ], CoreUserParticipantsCourseOptionHandler);
    return CoreUserParticipantsCourseOptionHandler;
}());

//# sourceMappingURL=course-option-handler.js.map

/***/ }),
/* 1110 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreUserParticipantsLinkHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_contentlinks_classes_base_handler__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_login_providers_helper__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__user__ = __webpack_require__(62);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Handler to treat links to user participants page.
 */
var CoreUserParticipantsLinkHandler = /** @class */ (function (_super) {
    __extends(CoreUserParticipantsLinkHandler, _super);
    function CoreUserParticipantsLinkHandler(userProvider, loginHelper) {
        var _this = _super.call(this) || this;
        _this.userProvider = userProvider;
        _this.loginHelper = loginHelper;
        _this.name = 'CoreUserParticipants';
        _this.featureName = '$mmCoursesDelegate_mmaParticipants';
        _this.pattern = /\/user\/index\.php/;
        return _this;
    }
    /**
     * Get the list of actions for a link (url).
     *
     * @param {string[]} siteIds List of sites the URL belongs to.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {CoreContentLinksAction[]|Promise<CoreContentLinksAction[]>} List of (or promise resolved with list of) actions.
     */
    CoreUserParticipantsLinkHandler.prototype.getActions = function (siteIds, url, params, courseId) {
        var _this = this;
        courseId = parseInt(params.id, 10) || courseId;
        return [{
                action: function (siteId, navCtrl) {
                    // Always use redirect to make it the new history root (to avoid "loops" in history).
                    _this.loginHelper.redirect('CoreUserParticipantsPage', { courseId: courseId }, siteId);
                }
            }];
    };
    /**
     * Check if the handler is enabled for a certain site (site + user) and a URL.
     * If not defined, defaults to true.
     *
     * @param {string} siteId The site ID.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {boolean|Promise<boolean>} Whether the handler is enabled for the URL and site.
     */
    CoreUserParticipantsLinkHandler.prototype.isEnabled = function (siteId, url, params, courseId) {
        courseId = parseInt(params.id, 10) || courseId;
        if (!courseId || url.indexOf('/grade/report/') != -1) {
            return false;
        }
        return this.userProvider.isPluginEnabledForCourse(courseId, siteId);
    };
    CoreUserParticipantsLinkHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__user__["a" /* CoreUserProvider */], __WEBPACK_IMPORTED_MODULE_2__core_login_providers_helper__["a" /* CoreLoginHelperProvider */]])
    ], CoreUserParticipantsLinkHandler);
    return CoreUserParticipantsLinkHandler;
}(__WEBPACK_IMPORTED_MODULE_1__core_contentlinks_classes_base_handler__["a" /* CoreContentLinksHandlerBase */]));

//# sourceMappingURL=participants-link-handler.js.map

/***/ }),
/* 1111 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CameraMock; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_camera__ = __webpack_require__(243);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__capture_helper__ = __webpack_require__(166);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Emulates the Cordova Camera plugin in desktop apps and in browser.
 */
var CameraMock = /** @class */ (function (_super) {
    __extends(CameraMock, _super);
    function CameraMock(captureHelper) {
        var _this = _super.call(this) || this;
        _this.captureHelper = captureHelper;
        return _this;
    }
    /**
     * Remove intermediate image files that are kept in temporary storage after calling camera.getPicture.
     *
     * @return {Promise<any>} Promise resolved when done.
     */
    CameraMock.prototype.cleanup = function () {
        // This function is iOS only, nothing to do.
        return Promise.resolve();
    };
    /**
     * Take a picture.
     *
     * @param {CameraOptions} options Options that you want to pass to the camera.
     * @return {Promise<any>} Promise resolved when captured.
     */
    CameraMock.prototype.getPicture = function (options) {
        return this.captureHelper.captureMedia('image', options);
    };
    CameraMock = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__capture_helper__["a" /* CoreEmulatorCaptureHelperProvider */]])
    ], CameraMock);
    return CameraMock;
}(__WEBPACK_IMPORTED_MODULE_1__ionic_native_camera__["a" /* Camera */]));

//# sourceMappingURL=camera.js.map

/***/ }),
/* 1112 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ClipboardMock; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_clipboard__ = __webpack_require__(228);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(12);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Emulates the Cordova Clipboard plugin in desktop apps and in browser.
 */
var ClipboardMock = /** @class */ (function (_super) {
    __extends(ClipboardMock, _super);
    function ClipboardMock(appProvider) {
        var _this = _super.call(this) || this;
        _this.isDesktop = appProvider.isDesktop();
        if (_this.isDesktop) {
            _this.clipboard = __webpack_require__(167).clipboard;
        }
        else {
            // In browser the text must be selected in order to copy it. Create a hidden textarea to put the text in it.
            _this.copyTextarea = document.createElement('textarea');
            _this.copyTextarea.className = 'core-browser-copy-area';
            _this.copyTextarea.setAttribute('aria-hidden', 'true');
            document.body.appendChild(_this.copyTextarea);
        }
        return _this;
    }
    /**
     * Copy some text to the clipboard.
     *
     * @param {string} text The text to copy.
     * @return {Promise<any>} Promise resolved when copied.
     */
    ClipboardMock.prototype.copy = function (text) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (_this.isDesktop) {
                _this.clipboard.writeText(text);
                resolve();
            }
            else {
                // Put the text in the hidden textarea and select it.
                _this.copyTextarea.innerHTML = text;
                _this.copyTextarea.select();
                try {
                    if (document.execCommand('copy')) {
                        resolve();
                    }
                    else {
                        reject();
                    }
                }
                catch (err) {
                    reject();
                }
                _this.copyTextarea.innerHTML = '';
            }
        });
    };
    /*
     * Get the text stored in the clipboard.
     *
     * @return {Promise<any>} Promise resolved with the text.
     */
    ClipboardMock.prototype.paste = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (_this.isDesktop) {
                resolve(_this.clipboard.readText());
            }
            else {
                // Paste the text in the hidden textarea and get it.
                _this.copyTextarea.innerHTML = '';
                _this.copyTextarea.select();
                try {
                    if (document.execCommand('paste')) {
                        resolve(_this.copyTextarea.innerHTML);
                    }
                    else {
                        reject();
                    }
                }
                catch (err) {
                    reject();
                }
                _this.copyTextarea.innerHTML = '';
            }
        });
    };
    ClipboardMock = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */]])
    ], ClipboardMock);
    return ClipboardMock;
}(__WEBPACK_IMPORTED_MODULE_1__ionic_native_clipboard__["a" /* Clipboard */]));

//# sourceMappingURL=clipboard.js.map

/***/ }),
/* 1113 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FileMock; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_file__ = __webpack_require__(128);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_text__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__configconstants__ = __webpack_require__(50);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Emulates the Cordova File plugin in desktop apps and in browser.
 * Most of the code is extracted from the File class of Ionic Native.
 */
var FileMock = /** @class */ (function (_super) {
    __extends(FileMock, _super);
    function FileMock(appProvider, textUtils) {
        var _this = _super.call(this) || this;
        _this.appProvider = appProvider;
        _this.textUtils = textUtils;
        return _this;
    }
    /**
     * Check if a directory exists in a certain path, directory.
     *
     * @param {string} path Base FileSystem.
     * @param {string} dir Name of directory to check
     * @returns {Promise<boolean>} Returns a Promise that resolves to true if the directory exists or rejects with an error.
     */
    FileMock.prototype.checkDir = function (path, dir) {
        var fullPath = this.textUtils.concatenatePaths(path, dir);
        return this.resolveDirectoryUrl(fullPath).then(function () {
            return true;
        });
    };
    /**
     * Check if a file exists in a certain path, directory.
     *
     * @param {string} path Base FileSystem.
     * @param {string} file Name of file to check.
     * @returns {Promise<boolean>} Returns a Promise that resolves with a boolean or rejects with an error.
     */
    FileMock.prototype.checkFile = function (path, file) {
        return this.resolveLocalFilesystemUrl(this.textUtils.concatenatePaths(path, file)).then(function (fse) {
            if (fse.isFile) {
                return true;
            }
            else {
                var err = new __WEBPACK_IMPORTED_MODULE_1__ionic_native_file__["FileError"](13);
                err.message = 'input is not a file';
                return Promise.reject(err);
            }
        });
    };
    /**
     * Copy a file or directory.
     *
     * @param {Entry} srce The Entry to copy.
     * @param {DirectoryEntry} destDir The directory where to put the copy.
     * @param {string} newName New name of the file/dir.
     * @returns {Promise<Entry>} Returns a Promise that resolves to the new Entry object or rejects with an error.
     */
    FileMock.prototype.copyMock = function (srce, destDir, newName) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            srce.copyTo(destDir, newName, function (deste) {
                resolve(deste);
            }, function (err) {
                _this.fillErrorMessageMock(err);
                reject(err);
            });
        });
    };
    /**
     * Copy a directory in various methods. If destination directory exists, will fail to copy.
     *
     * @param {string} path Base FileSystem. Please refer to the iOS and Android filesystems above.
     * @param {string} dirName Name of directory to copy.
     * @param {string} newPath Base FileSystem of new location.
     * @param {string} newDirName New name of directory to copy to (leave blank to remain the same).
     * @returns {Promise<Entry>} Returns a Promise that resolves to the new Entry object or rejects with an error.
     */
    FileMock.prototype.copyDir = function (path, dirName, newPath, newDirName) {
        var _this = this;
        return this.resolveDirectoryUrl(path).then(function (fse) {
            return _this.getDirectory(fse, dirName, { create: false });
        }).then(function (srcde) {
            return _this.resolveDirectoryUrl(newPath).then(function (deste) {
                return _this.copyMock(srcde, deste, newDirName);
            });
        });
    };
    /**
     * Copy a file in various methods. If file exists, will fail to copy.
     *
     * @param {string} path Base FileSystem. Please refer to the iOS and Android filesystems above
     * @param {string} fileName Name of file to copy
     * @param {string} newPath Base FileSystem of new location
     * @param {string} newFileName New name of file to copy to (leave blank to remain the same)
     * @returns {Promise<Entry>} Returns a Promise that resolves to an Entry or rejects with an error.
     */
    FileMock.prototype.copyFile = function (path, fileName, newPath, newFileName) {
        var _this = this;
        newFileName = newFileName || fileName;
        return this.resolveDirectoryUrl(path).then(function (fse) {
            return _this.getFile(fse, fileName, { create: false });
        }).then(function (srcfe) {
            return _this.resolveDirectoryUrl(newPath).then(function (deste) {
                return _this.copyMock(srcfe, deste, newFileName);
            });
        });
    };
    /**
     * Creates a new directory in the specific path.
     * The replace boolean value determines whether to replace an existing directory with the same name.
     * If an existing directory exists and the replace value is false, the promise will fail and return an error.
     *
     * @param {string} path Base FileSystem.
     * @param {string} dirName Name of directory to create
     * @param {boolean} replace If true, replaces file with same name. If false returns error
     * @returns {Promise<DirectoryEntry>} Returns a Promise that resolves with a DirectoryEntry or rejects with an error.
     */
    FileMock.prototype.createDir = function (path, dirName, replace) {
        var _this = this;
        var options = {
            create: true
        };
        if (!replace) {
            options.exclusive = true;
        }
        return this.resolveDirectoryUrl(path).then(function (fse) {
            return _this.getDirectory(fse, dirName, options);
        });
    };
    /**
     * Creates a new file in the specific path.
     * The replace boolean value determines whether to replace an existing file with the same name.
     * If an existing file exists and the replace value is false, the promise will fail and return an error.
     *
     * @param {string} path  Base FileSystem.
     * @param {string} fileName Name of file to create.
     * @param {boolean} replace If true, replaces file with same name. If false returns error.
     * @returns {Promise<FileEntry>} Returns a Promise that resolves to a FileEntry or rejects with an error.
     */
    FileMock.prototype.createFile = function (path, fileName, replace) {
        var _this = this;
        var options = {
            create: true
        };
        if (!replace) {
            options.exclusive = true;
        }
        return this.resolveDirectoryUrl(path).then(function (fse) {
            return _this.getFile(fse, fileName, options);
        });
    };
    /**
     * Create a file writer for a certain file.
     *
     * @param {FileEntry} fe File entry object.
     * @returns {Promise<FileWriter>} Promise resolved with the FileWriter.
     */
    FileMock.prototype.createWriterMock = function (fe) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            fe.createWriter(function (writer) {
                resolve(writer);
            }, function (err) {
                _this.fillErrorMessageMock(err);
                reject(err);
            });
        });
    };
    /**
     * Fill the message for an error.
     *
     * @param {any} err Error.
     */
    FileMock.prototype.fillErrorMessageMock = function (err) {
        try {
            err.message = this.cordovaFileError[err.code];
        }
        catch (e) {
            // Ignore errors.
        }
    };
    /**
     * Get a directory.
     *
     * @param directoryEntry {DirectoryEntry} Directory entry, obtained by resolveDirectoryUrl method
     * @param directoryName {string} Directory name
     * @param flags {Flags} Options
     * @returns {Promise<DirectoryEntry>}
     */
    FileMock.prototype.getDirectory = function (directoryEntry, directoryName, flags) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            try {
                directoryEntry.getDirectory(directoryName, flags, function (de) {
                    resolve(de);
                }, function (err) {
                    _this.fillErrorMessageMock(err);
                    reject(err);
                });
            }
            catch (xc) {
                _this.fillErrorMessageMock(xc);
                reject(xc);
            }
        });
    };
    /**
     * Get a file
     * @param directoryEntry {DirectoryEntry} Directory entry, obtained by resolveDirectoryUrl method
     * @param fileName {string} File name
     * @param flags {Flags} Options
     * @returns {Promise<FileEntry>}
     */
    FileMock.prototype.getFile = function (directoryEntry, fileName, flags) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            try {
                directoryEntry.getFile(fileName, flags, resolve, function (err) {
                    _this.fillErrorMessageMock(err);
                    reject(err);
                });
            }
            catch (xc) {
                _this.fillErrorMessageMock(xc);
                reject(xc);
            }
        });
    };
    /**
     * Get free disk space.
     *
     * @return {Promise<number>} Promise resolved with the free space.
     */
    FileMock.prototype.getFreeDiskSpace = function () {
        // FRequest a file system instance with a minimum size until we get an error.
        if (window.requestFileSystem) {
            return new Promise(function (resolve, reject) {
                var iterations = 0, maxIterations = 50;
                var calculateByRequest = function (size, ratio) {
                    return new Promise(function (resolve, reject) {
                        window.requestFileSystem(LocalFileSystem.PERSISTENT, size, function () {
                            iterations++;
                            if (iterations > maxIterations) {
                                resolve(size);
                                return;
                            }
                            calculateByRequest(size * ratio, ratio).then(resolve);
                        }, function () {
                            resolve(size / ratio);
                        });
                    });
                };
                // General calculation, base 1MB and increasing factor 1.3.
                calculateByRequest(1048576, 1.3).then(function (size) {
                    iterations = 0;
                    maxIterations = 10;
                    // More accurate. Factor is 1.1.
                    calculateByRequest(size, 1.1).then(function (size) {
                        return size / 1024; // Return size in KB.
                    });
                });
            });
        }
        else {
            return Promise.reject(null);
        }
    };
    /**
     * List files and directory from a given path.
     *
     * @param {string} path Base FileSystem. Please refer to the iOS and Android filesystems above
     * @param {string} dirName Name of directory
     * @returns {Promise<Entry[]>} Returns a Promise that resolves to an array of Entry objects or rejects with an error.
     */
    FileMock.prototype.listDir = function (path, dirName) {
        var _this = this;
        return this.resolveDirectoryUrl(path).then(function (fse) {
            return _this.getDirectory(fse, dirName, { create: false, exclusive: false });
        }).then(function (de) {
            var reader = de.createReader();
            return _this.readEntriesMock(reader);
        });
    };
    /**
     * Loads an initialize the API for browser and desktop.
     *
     * @return {Promise<any>} Promise resolved when loaded.
     */
    FileMock.prototype.load = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var win = window; // Convert to <any> to be able to use non-standard properties.
            var basePath;
            if (typeof win.requestFileSystem == 'undefined') {
                win.requestFileSystem = win.webkitRequestFileSystem;
            }
            if (typeof win.resolveLocalFileSystemURL == 'undefined') {
                win.resolveLocalFileSystemURL = win.webkitResolveLocalFileSystemURL;
            }
            win.LocalFileSystem = {
                PERSISTENT: 1
            };
            if (_this.appProvider.isDesktop()) {
                var fs = __webpack_require__(1114), app = __webpack_require__(167).remote.app;
                // @todo emulateCordovaFileForDesktop(fs);
                // Initialize File System. Get the path to use.
                basePath = app.getPath('documents') || app.getPath('home');
                if (!basePath) {
                    reject('Cannot calculate base path for file system.');
                    return;
                }
                basePath = _this.textUtils.concatenatePaths(basePath.replace(/\\/g, '/'), __WEBPACK_IMPORTED_MODULE_4__configconstants__["a" /* CoreConfigConstants */].app_id) + '/';
                // Create the folder if needed.
                fs.mkdir(basePath, function (e) {
                    if (!e || (e && e.code === 'EEXIST')) {
                        // Create successful or it already exists. Resolve.
                        // @todo this.fileProvider.setHTMLBasePath(basePath);
                        resolve(basePath);
                    }
                    else {
                        reject('Error creating base path.');
                    }
                });
            }
            else {
                // It's browser, request a quota to use. Request 500MB.
                navigator.webkitPersistentStorage.requestQuota(500 * 1024 * 1024, function (granted) {
                    window.requestFileSystem(LocalFileSystem.PERSISTENT, granted, function (entry) {
                        basePath = entry.root.toURL();
                        resolve(basePath);
                    }, reject);
                }, reject);
            }
        });
    };
    /**
     * Move a file or directory.
     *
     * @param {Entry} srce The Entry to copy.
     * @param {DirectoryEntry} destDir The directory where to move the file/dir.
     * @param {string} newName New name of the file/dir.
     * @returns {Promise<Entry>} Returns a Promise that resolves to the new Entry object or rejects with an error.
     */
    FileMock.prototype.moveMock = function (srce, destDir, newName) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            srce.moveTo(destDir, newName, function (deste) {
                resolve(deste);
            }, function (err) {
                _this.fillErrorMessageMock(err);
                reject(err);
            });
        });
    };
    /**
     * Move a directory to a given path.
     *
     * @param {string} path The source path to the directory.
     * @param {string} dirName The source directory name.
     * @param {string} newPath The destionation path to the directory.
     * @param {string} newDirName The destination directory name.
     * @returns {Promise<DirectoryEntry|Entry>} Returns a Promise that resolves to the new DirectoryEntry object or rejects with
     *                                          an error.
     */
    FileMock.prototype.moveDir = function (path, dirName, newPath, newDirName) {
        var _this = this;
        return this.resolveDirectoryUrl(path).then(function (fse) {
            return _this.getDirectory(fse, dirName, { create: false });
        }).then(function (srcde) {
            return _this.resolveDirectoryUrl(newPath).then(function (deste) {
                return _this.moveMock(srcde, deste, newDirName);
            });
        });
    };
    /**
     * Move a file to a given path.
     *
     * @param {string} path Base FileSystem. Please refer to the iOS and Android filesystems above
     * @param {string} fileName Name of file to move
     * @param {string} newPath Base FileSystem of new location
     * @param {string} newFileName New name of file to move to (leave blank to remain the same)
     * @returns {Promise<Entry>} Returns a Promise that resolves to the new Entry or rejects with an error.
     */
    FileMock.prototype.moveFile = function (path, fileName, newPath, newFileName) {
        var _this = this;
        newFileName = newFileName || fileName;
        return this.resolveDirectoryUrl(path).then(function (fse) {
            return _this.getFile(fse, fileName, { create: false });
        }).then(function (srcfe) {
            return _this.resolveDirectoryUrl(newPath).then(function (deste) {
                return _this.moveMock(srcfe, deste, newFileName);
            });
        });
    };
    /**
     * Read file and return data as an ArrayBuffer.
     * @param {string} path Base FileSystem.
     * @param {string} file Name of file, relative to path.
     * @returns {Promise<ArrayBuffer>} Returns a Promise that resolves with the contents of the file as ArrayBuffer or rejects
     *                                 with an error.
     */
    FileMock.prototype.readAsArrayBuffer = function (path, file) {
        return this.readFileMock(path, file, 'ArrayBuffer');
    };
    /**
     * Read file and return data as a binary data.
     * @param {string} path Base FileSystem.
     * @param {string} file Name of file, relative to path.
     * @returns {Promise<string>} Returns a Promise that resolves with the contents of the file as string rejects with an error.
     */
    FileMock.prototype.readAsBinaryString = function (path, file) {
        return this.readFileMock(path, file, 'BinaryString');
    };
    /**
     * Read file and return data as a base64 encoded data url.
     * A data url is of the form:
     *      data: [<mediatype>][;base64],<data>
     * @param {string} path Base FileSystem.
     * @param {string} file Name of file, relative to path.
     * @returns {Promise<string>} Returns a Promise that resolves with the contents of the file as data URL or rejects
     *                            with an error.
     */
    FileMock.prototype.readAsDataURL = function (path, file) {
        return this.readFileMock(path, file, 'DataURL');
    };
    /**
     * Read the contents of a file as text.
     *
     * @param {string} path Base FileSystem.
     * @param {string} file Name of file, relative to path.
     * @returns {Promise<string>} Returns a Promise that resolves with the contents of the file as string or rejects with an error.
     */
    FileMock.prototype.readAsText = function (path, file) {
        return this.readFileMock(path, file, 'Text');
    };
    /**
     * Read all the files and directories inside a directory.
     *
     * @param {DirectoryReader} dr The directory reader.
     * @return {Promise<Entry[]>} Promise resolved with the list of files/dirs.
     */
    FileMock.prototype.readEntriesMock = function (dr) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            dr.readEntries(function (entries) {
                resolve(entries);
            }, function (err) {
                _this.fillErrorMessageMock(err);
                reject(err);
            });
        });
    };
    /**
     * Read the contents of a file.
     *
     * @param {string} path Base FileSystem.
     * @param {string} file Name of file, relative to path.
     * @param {string} readAs Format to read as.
     * @returns {Promise<string>} Returns a Promise that resolves with the contents of the file or rejects with an error.
     */
    FileMock.prototype.readFileMock = function (path, file, readAs) {
        var _this = this;
        return this.resolveDirectoryUrl(path).then(function (directoryEntry) {
            return _this.getFile(directoryEntry, file, { create: false });
        }).then(function (fileEntry) {
            var reader = new FileReader();
            return new Promise(function (resolve, reject) {
                reader.onloadend = function () {
                    if (reader.result !== undefined || reader.result !== null) {
                        resolve(reader.result);
                    }
                    else if (reader.error !== undefined || reader.error !== null) {
                        reject(reader.error);
                    }
                    else {
                        reject({ code: null, message: 'READER_ONLOADEND_ERR' });
                    }
                };
                fileEntry.file(function (file) {
                    reader["readAs" + readAs].call(reader, file);
                }, function (error) {
                    reject(error);
                });
            });
        });
    };
    /**
     * Delete a file.
     *
     * @param {Entry} fe The file to remove.
     * @return {Promise<any>} Promise resolved when done.
     */
    FileMock.prototype.removeMock = function (fe) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            fe.remove(function () {
                resolve({ success: true, fileRemoved: fe });
            }, function (err) {
                _this.fillErrorMessageMock(err);
                reject(err);
            });
        });
    };
    /**
     * Remove a directory at a given path.
     *
     * @param {string} path The path to the directory.
     * @param {string} dirName The directory name.
     * @returns {Promise<RemoveResult>} Returns a Promise that resolves to a RemoveResult or rejects with an error.
     */
    FileMock.prototype.removeDir = function (path, dirName) {
        var _this = this;
        return this.resolveDirectoryUrl(path).then(function (fse) {
            return _this.getDirectory(fse, dirName, { create: false });
        }).then(function (de) {
            return _this.removeMock(de);
        });
    };
    /**
     * Removes a file from a desired location.
     *
     * @param {string} path  Base FileSystem.
     * @param {string} fileName Name of file to remove.
     * @returns {Promise<RemoveResult>} Returns a Promise that resolves to a RemoveResult or rejects with an error.
     */
    FileMock.prototype.removeFile = function (path, fileName) {
        var _this = this;
        return this.resolveDirectoryUrl(path).then(function (fse) {
            return _this.getFile(fse, fileName, { create: false });
        }).then(function (fe) {
            return _this.removeMock(fe);
        });
    };
    /**
     * Removes all files and the directory from a desired location.
     *
     * @param {string} path Base FileSystem. Please refer to the iOS and Android filesystems above
     * @param {string} dirName Name of directory
     * @returns {Promise<RemoveResult>} Returns a Promise that resolves with a RemoveResult or rejects with an error.
     */
    FileMock.prototype.removeRecursively = function (path, dirName) {
        var _this = this;
        return this.resolveDirectoryUrl(path).then(function (fse) {
            return _this.getDirectory(fse, dirName, { create: false });
        }).then(function (de) {
            return _this.rimrafMock(de);
        });
    };
    /**
     * Resolves a local directory url
     * @param directoryUrl {string} directory system url
     * @returns {Promise<DirectoryEntry>}
     */
    FileMock.prototype.resolveDirectoryUrl = function (directoryUrl) {
        return this.resolveLocalFilesystemUrl(directoryUrl).then(function (de) {
            if (de.isDirectory) {
                return de;
            }
            else {
                var err = new __WEBPACK_IMPORTED_MODULE_1__ionic_native_file__["FileError"](13);
                err.message = 'input is not a directory';
                return Promise.reject(err);
            }
        });
    };
    /**
     * Resolves a local file system URL
     * @param fileUrl {string} file system url
     * @returns {Promise<Entry>}
     */
    FileMock.prototype.resolveLocalFilesystemUrl = function (fileUrl) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            try {
                window.resolveLocalFileSystemURL(fileUrl, function (entry) {
                    resolve(entry);
                }, function (err) {
                    _this.fillErrorMessageMock(err);
                    reject(err);
                });
            }
            catch (xc) {
                _this.fillErrorMessageMock(xc);
                reject(xc);
            }
        });
    };
    /**
     * Remove a directory and all its contents.
     *
     * @param {DirectoryEntry} de Directory to remove.
     * @return {Promise<any>} Promise resolved when done.
     */
    FileMock.prototype.rimrafMock = function (de) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            de.removeRecursively(function () {
                resolve({ success: true, fileRemoved: de });
            }, function (err) {
                _this.fillErrorMessageMock(err);
                reject(err);
            });
        });
    };
    /**
     * Write some data in a file.
     *
     * @param {FileWriter} writer File writer.
     * @param {any} data The data to write.
     * @return {Promise<any>} Promise resolved when done.
     */
    FileMock.prototype.writeMock = function (writer, data) {
        if (data instanceof Blob) {
            return this.writeFileInChunksMock(writer, data);
        }
        return new Promise(function (resolve, reject) {
            writer.onwriteend = function (evt) {
                if (writer.error) {
                    reject(writer.error);
                }
                else {
                    resolve(evt);
                }
            };
            writer.write(data);
        });
    };
    /**
     * Write to an existing file.
     *
     * @param {string} path Base FileSystem.
     * @param {string} fileName path relative to base path.
     * @param {string | Blob} text content or blob to write.
     * @returns {Promise<void>} Returns a Promise that resolves or rejects with an error.
     */
    FileMock.prototype.writeExistingFile = function (path, fileName, text) {
        return this.writeFile(path, fileName, text, { replace: true });
    };
    /**
     * Write a new file to the desired location.
     *
     * @param {string} path Base FileSystem. Please refer to the iOS and Android filesystems above
     * @param {string} fileName path relative to base path
     * @param {string | Blob} text content or blob to write
     * @param {any} options replace file if set to true. See WriteOptions for more information.
     * @returns {Promise<any>} Returns a Promise that resolves to updated file entry or rejects with an error.
     */
    FileMock.prototype.writeFile = function (path, fileName, text, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var getFileOpts = {
            create: !options.append,
            exclusive: !options.replace
        };
        return this.resolveDirectoryUrl(path).then(function (directoryEntry) {
            return _this.getFile(directoryEntry, fileName, getFileOpts);
        }).then(function (fileEntry) {
            return _this.writeFileEntryMock(fileEntry, text, options);
        });
    };
    /**
     * Write content to FileEntry.
     *
     * @param {FileEntry} fe File entry object.
     * @param {string | Blob} text Content or blob to write.
     * @param {IWriteOptions} options replace file if set to true. See WriteOptions for more information.
     * @returns {Promise<FileEntry>} Returns a Promise that resolves to updated file entry or rejects with an error.
     */
    FileMock.prototype.writeFileEntryMock = function (fe, text, options) {
        var _this = this;
        return this.createWriterMock(fe).then(function (writer) {
            if (options.append) {
                writer.seek(writer.length);
            }
            if (options.truncate) {
                writer.truncate(options.truncate);
            }
            return _this.writeMock(writer, text);
        }).then(function () { return fe; });
    };
    /**
     * Write a file in chunks.
     *
     * @param {FileWriter} writer File writer.
     * @param {Blob} data Data to write.
     * @return {Promise<any>} Promise resolved when done.
     */
    FileMock.prototype.writeFileInChunksMock = function (writer, data) {
        var writtenSize = 0;
        var BLOCK_SIZE = 1024 * 1024, writeNextChunk = function () {
            var size = Math.min(BLOCK_SIZE, data.size - writtenSize);
            var chunk = data.slice(writtenSize, writtenSize + size);
            writtenSize += size;
            writer.write(chunk);
        };
        return new Promise(function (resolve, reject) {
            writer.onerror = reject;
            writer.onwrite = function () {
                if (writtenSize < data.size) {
                    writeNextChunk();
                }
                else {
                    resolve();
                }
            };
            writeNextChunk();
        });
    };
    FileMock = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_text__["a" /* CoreTextUtilsProvider */]])
    ], FileMock);
    return FileMock;
}(__WEBPACK_IMPORTED_MODULE_1__ionic_native_file__["a" /* File */]));

//# sourceMappingURL=file.js.map

/***/ }),
/* 1114 */,
/* 1115 */,
/* 1116 */,
/* 1117 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GlobalizationMock; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_globalization__ = __webpack_require__(224);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(12);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Emulates the Cordova Globalization plugin in desktop apps and in browser.
 */
var GlobalizationMock = /** @class */ (function (_super) {
    __extends(GlobalizationMock, _super);
    function GlobalizationMock(appProvider) {
        var _this = _super.call(this) || this;
        _this.appProvider = appProvider;
        return _this;
    }
    /**
     * Get the current locale.
     *
     * @return {string} Locale name.
     */
    GlobalizationMock.prototype.getCurrentlocale = function () {
        // Get browser language.
        var navLang = navigator.userLanguage || navigator.language;
        try {
            if (this.appProvider.isDesktop()) {
                return __webpack_require__(167).remote.app.getLocale() || navLang;
            }
            else {
                return navLang;
            }
        }
        catch (ex) {
            // Something went wrong, return browser language.
            return navLang;
        }
    };
    /**
     * Get the current locale name.
     *
     * @return {Promise<{value: string}>} Promise resolved with an object with the language string.
     */
    GlobalizationMock.prototype.getLocaleName = function () {
        var locale = this.getCurrentlocale();
        if (locale) {
            return Promise.resolve({ value: locale });
        }
        else {
            var error = { code: GlobalizationError.UNKNOWN_ERROR, message: 'Cannot get language' };
            return Promise.reject(error);
        }
    };
    /*
     * Get the current preferred language.
     *
     * @return {Promise<{value: string}>} Promise resolved with an object with the language string.
     */
    GlobalizationMock.prototype.getPreferredLanguage = function () {
        return this.getLocaleName();
    };
    GlobalizationMock = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */]])
    ], GlobalizationMock);
    return GlobalizationMock;
}(__WEBPACK_IMPORTED_MODULE_1__ionic_native_globalization__["a" /* Globalization */]));

//# sourceMappingURL=globalization.js.map

/***/ }),
/* 1118 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return InAppBrowserMock; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_in_app_browser__ = __webpack_require__(152);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_file__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_url__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__classes_inappbrowserobject__ = __webpack_require__(1119);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






/**
 * Emulates the Cordova InAppBrowser plugin in desktop apps.
 */
var InAppBrowserMock = /** @class */ (function (_super) {
    __extends(InAppBrowserMock, _super);
    function InAppBrowserMock(appProvider, fileProvider, urlUtils) {
        var _this = _super.call(this) || this;
        _this.appProvider = appProvider;
        _this.fileProvider = fileProvider;
        _this.urlUtils = urlUtils;
        return _this;
    }
    /**
     * Opens a URL in a new InAppBrowser instance, the current browser instance, or the system browser.
     *
     * @param {string} url The URL to load.
     * @param {string} [target] The target in which to load the URL, an optional parameter that defaults to _self.
     * @param {string} [options] Options for the InAppBrowser.
     * @return {InAppBrowserObject} The new instance.
     */
    InAppBrowserMock.prototype.create = function (url, target, options) {
        if (options === void 0) { options = ''; }
        if (!this.appProvider.isDesktop()) {
            return _super.prototype.create.call(this, url, target, options);
        }
        return new __WEBPACK_IMPORTED_MODULE_5__classes_inappbrowserobject__["a" /* InAppBrowserObjectMock */](this.appProvider, this.fileProvider, this.urlUtils, url, target, options);
    };
    InAppBrowserMock = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_file__["a" /* CoreFileProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_utils_url__["a" /* CoreUrlUtilsProvider */]])
    ], InAppBrowserMock);
    return InAppBrowserMock;
}(__WEBPACK_IMPORTED_MODULE_1__ionic_native_in_app_browser__["a" /* InAppBrowser */]));

//# sourceMappingURL=inappbrowser.js.map

/***/ }),
/* 1119 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return InAppBrowserObjectMock; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_in_app_browser__ = __webpack_require__(152);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


/**
 * Emulates the Cordova InAppBrowserObject in desktop apps.
 */
var InAppBrowserObjectMock = /** @class */ (function (_super) {
    __extends(InAppBrowserObjectMock, _super);
    function InAppBrowserObjectMock(appProvider, fileProvider, urlUtils, url, target, options) {
        if (options === void 0) { options = ''; }
        var _this = _super.call(this, url, target, options) || this;
        _this.fileProvider = fileProvider;
        _this.urlUtils = urlUtils;
        _this.url = url;
        if (!appProvider.isDesktop()) {
            return _this;
        }
        _this.browserWindow = __webpack_require__(623).remote.BrowserWindow;
        _this.screen = __webpack_require__(623).screen;
        _this.isSSO = !!(url && url.match(/\/launch\.php\?service=.+&passport=/));
        _this.isLinux = appProvider.isLinux();
        var width = 800, height = 600, display;
        var bwOptions = {};
        if (screen) {
            display = _this.screen.getPrimaryDisplay();
            if (display && display.workArea) {
                width = display.workArea.width || width;
                height = display.workArea.height || height;
            }
        }
        // Create the BrowserWindow options based on the received options.
        bwOptions.width = width;
        bwOptions.height = height;
        if (options.indexOf('hidden=yes') != -1) {
            bwOptions.show = false;
        }
        if (options.indexOf('location=no') != -1) {
            bwOptions.frame = false;
        }
        if (options.indexOf('fullscreen=yes') != -1) {
            bwOptions.fullscreen = true;
        }
        _this.window = new _this.browserWindow(bwOptions);
        _this.window.loadURL(url);
        if (_this.isLinux && _this.isSSO) {
            // SSO in Linux. Simulate it's an iOS device so we can retrieve the launch URL.
            // This is needed because custom URL scheme is not supported in Linux.
            var userAgent = 'Mozilla/5.0 (iPad) AppleWebKit/603.3.8 (KHTML, like Gecko) Mobile/14G60';
            _this.window.webContents.setUserAgent(userAgent);
        }
        return _this;
    }
    /**
     * Close the window.
     */
    InAppBrowserObjectMock.prototype.close = function () {
        this.window.close();
    };
    /**
     * Execute a JS script.
     *
     * @param {any} details Details of the script to run, specifying either a file or code key.
     * @return {Promise<any>} Promise resolved when done.
     */
    InAppBrowserObjectMock.prototype.executeScript = function (details) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (details.code) {
                _this.window.webContents.executeJavaScript(details.code, false, resolve);
            }
            else if (details.file) {
                _this.fileProvider.readFile(details.file).then(function (code) {
                    _this.window.webContents.executeJavaScript(code, false, resolve);
                }).catch(reject);
            }
            else {
                reject('executeScript requires exactly one of code or file to be specified');
            }
        });
    };
    /**
     * Recursive function to get the launch URL from the contents of a BrowserWindow.
     *
     * @param {number} [retry=0] Retry number.
     * @return {Promise<string>} Promise resolved with the launch URL.
     */
    InAppBrowserObjectMock.prototype.getLaunchUrl = function (retry) {
        var _this = this;
        if (retry === void 0) { retry = 0; }
        return new Promise(function (resolve, reject) {
            // Execute Javascript to retrieve the launch link.
            var jsCode = 'var el = document.querySelector("#launchapp"); el && el.href;';
            var found = false;
            _this.window.webContents.executeJavaScript(jsCode).then(function (launchUrl) {
                found = true;
                resolve(launchUrl);
            });
            setTimeout(function () {
                if (found) {
                    // URL found, stop.
                }
                else if (retry > 5) {
                    // Waited enough, stop.
                    reject();
                }
                else {
                    _this.getLaunchUrl(retry + 1).then(resolve, reject);
                }
            }, 300);
        });
    };
    /**
     * Hide the window.
     */
    InAppBrowserObjectMock.prototype.hide = function () {
        this.window.hide();
    };
    /**
     * Insert CSS.
     *
     * @param {any} details Details of the CSS to insert, specifying either a file or code key.
     * @return {Promise<any>} Promise resolved when done.
     */
    InAppBrowserObjectMock.prototype.insertCSS = function (details) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (details.code) {
                _this.window.webContents.insertCSS(details.code);
                resolve();
            }
            else if (details.file) {
                _this.fileProvider.readFile(details.file).then(function (code) {
                    _this.window.webContents.insertCSS(code);
                    resolve();
                }).catch(reject);
            }
            else {
                reject('insertCSS requires exactly one of code or file to be specified');
            }
        });
    };
    /**
     * Listen to events happening.
     *
     * @param {string} name Name of the event.
     * @return {Observable<InAppBrowserEvent>} Observable that will listen to the event on subscribe, and will stop listening
     *                                         to the event on unsubscribe.
     */
    InAppBrowserObjectMock.prototype.on = function (name) {
        var _this = this;
        // Create the observable.
        return new __WEBPACK_IMPORTED_MODULE_0_rxjs__["Observable"](function (observer) {
            // Helper functions to handle events.
            var received = function (event, url) {
                try {
                    event.url = url || _this.window.getURL();
                    event.type = name;
                    observer.next(event);
                }
                catch (ex) {
                    // Ignore errors.
                }
            }, finishLoad = function (event) {
                // Check if user is back to launch page.
                if (_this.urlUtils.removeUrlParams(_this.url) == _this.urlUtils.removeUrlParams(_this.window.getURL())) {
                    // The launch page was loaded. Search for the launch link.
                    _this.getLaunchUrl().then(function (launchUrl) {
                        if (launchUrl) {
                            // Launch URL retrieved, send it and stop listening.
                            received(event, launchUrl);
                        }
                    });
                }
            };
            switch (name) {
                case 'loadstart':
                    _this.window.webContents.on('did-start-loading', received);
                    if (_this.isLinux && _this.isSSO) {
                        // Linux doesn't support custom URL Schemes. Check if launch page is loaded.
                        _this.window.webContents.on('did-finish-load', finishLoad);
                    }
                    break;
                case 'loadstop':
                    _this.window.webContents.on('did-finish-load', received);
                    break;
                case 'loaderror':
                    _this.window.webContents.on('did-fail-load', received);
                    break;
                case 'exit':
                    _this.window.on('close', received);
                    break;
                default:
            }
            return function () {
                // Unsubscribing. We need to remove the listeners.
                switch (name) {
                    case 'loadstart':
                        _this.window.webContents.removeListener('did-start-loading', received);
                        _this.window.webContents.removeListener('did-finish-load', finishLoad);
                        break;
                    case 'loadstop':
                        _this.window.webContents.removeListener('did-finish-load', received);
                        break;
                    case 'loaderror':
                        _this.window.webContents.removeListener('did-fail-load', received);
                        break;
                    case 'exit':
                        _this.window.removeListener('close', received);
                        break;
                    default:
                }
            };
        });
    };
    /**
     * Show the window.
     */
    InAppBrowserObjectMock.prototype.show = function () {
        this.window.show();
    };
    return InAppBrowserObjectMock;
}(__WEBPACK_IMPORTED_MODULE_1__ionic_native_in_app_browser__["b" /* InAppBrowserObject */]));

//# sourceMappingURL=inappbrowserobject.js.map

/***/ }),
/* 1120 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LocalNotificationsMock; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_local_notifications__ = __webpack_require__(161);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_constants__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__configconstants__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_moment__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_moment__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};







/**
 * Emulates the Cordova Globalization plugin in desktop apps and in browser.
 */
var LocalNotificationsMock = /** @class */ (function (_super) {
    __extends(LocalNotificationsMock, _super);
    function LocalNotificationsMock(appProvider, utils) {
        var _this = _super.call(this) || this;
        _this.appProvider = appProvider;
        _this.utils = utils;
        // Templates for Windows ToastNotifications and TileNotifications.
        _this.toastTemplate = '<toast><visual><binding template="ToastText02"><text id="1" hint-wrap="true">%s</text>' +
            '<text id="2" hint-wrap="true">%s</text></binding></visual></toast>';
        _this.tileBindingTemplate = '<text hint-style="base" hint-wrap="true">%s</text>' +
            '<text hint-style="captionSubtle" hint-wrap="true">%s</text>';
        _this.tileTemplate = '<tile><visual branding="nameAndLogo">' +
            '<binding template="TileMedium">' + _this.tileBindingTemplate + '</binding>' +
            '<binding template="TileWide">' + _this.tileBindingTemplate + '</binding>' +
            '<binding template="TileLarge">' + _this.tileBindingTemplate + '</binding>' +
            '</visual></tile>';
        // Variables for database.
        _this.DESKTOP_NOTIFS_TABLE = 'desktop_local_notifications';
        _this.tableSchema = {
            name: _this.DESKTOP_NOTIFS_TABLE,
            columns: [
                {
                    name: 'id',
                    type: 'INTEGER',
                    primaryKey: true
                },
                {
                    name: 'triggered',
                    type: 'INTEGER'
                }
            ]
        };
        _this.scheduled = {};
        _this.triggered = {};
        _this.defaults = {
            text: '',
            title: '',
            sound: '',
            badge: 0,
            id: 0,
            data: undefined,
            every: undefined,
            at: undefined
        };
        _this.appDB = appProvider.getDB();
        _this.appDB.createTableFromSchema(_this.tableSchema);
        // Initialize observers.
        _this.observers = {
            schedule: [],
            trigger: [],
            click: [],
            update: [],
            clear: [],
            clearall: [],
            cancel: [],
            cancelall: []
        };
        return _this;
    }
    /**
     * Cancels single or multiple notifications
     * @param notificationId {any} A single notification id, or an array of notification ids.
     * @returns {Promise<any>} Returns a promise when the notification is canceled
     */
    LocalNotificationsMock.prototype.cancel = function (notificationId) {
        var _this = this;
        var promises = [];
        notificationId = Array.isArray(notificationId) ? notificationId : [notificationId];
        notificationId = this.convertIds(notificationId);
        // Cancel the notifications.
        notificationId.forEach(function (id) {
            if (_this.scheduled[id]) {
                promises.push(_this.cancelNotification(id, false, 'cancel'));
            }
        });
        return Promise.all(promises);
    };
    /**
     * Cancels all notifications.
     *
     * @returns {Promise<any>} Returns a promise when all notifications are canceled.
     */
    LocalNotificationsMock.prototype.cancelAll = function () {
        var _this = this;
        return this.cancel(Object.keys(this.scheduled)).then(function () {
            _this.triggerEvent('cancelall', 'foreground');
        });
    };
    /**
     * Cancel a local notification.
     *
     * @param {number} id Notification ID.
     * @param {boolean} omitEvent If true, the clear/cancel event won't be triggered.
     * @param {string} eventName Name of the event to trigger.
     * @return {Void}
     */
    LocalNotificationsMock.prototype.cancelNotification = function (id, omitEvent, eventName) {
        var notification = this.scheduled[id].notification;
        clearTimeout(this.scheduled[id].timeout);
        clearInterval(this.scheduled[id].interval);
        delete this.scheduled[id];
        delete this.triggered[id];
        this.removeNotification(id);
        if (!omitEvent) {
            this.triggerEvent(eventName, notification, 'foreground');
        }
    };
    /**
     * Clears single or multiple notifications.
     *
     * @param {any} notificationId A single notification id, or an array of notification ids.
     * @returns {Promise<any>} Returns a promise when the notification had been cleared.
     */
    LocalNotificationsMock.prototype.clear = function (notificationId) {
        var _this = this;
        var promises = [];
        notificationId = Array.isArray(notificationId) ? notificationId : [notificationId];
        notificationId = this.convertIds(notificationId);
        // Clear the notifications.
        notificationId.forEach(function (id) {
            // Cancel only the notifications that aren't repeating.
            if (_this.scheduled[id] && _this.scheduled[id].notification && !_this.scheduled[id].notification.every) {
                promises.push(_this.cancelNotification(id, false, 'clear'));
            }
        });
        return Promise.all(promises);
    };
    /**
     * Clears all notifications.
     *
     * @returns {Promise<any>} Returns a promise when all notifications have cleared
     */
    LocalNotificationsMock.prototype.clearAll = function () {
        var _this = this;
        return this.clear(Object.keys(this.scheduled)).then(function () {
            _this.triggerEvent('clearall', 'foreground');
        });
    };
    /**
     * Convert a list of IDs to numbers.
     * Code extracted from the Cordova plugin.
     *
     * @param {any[]} ids List of IDs.
     * @return {number[]} List of IDs as numbers.
     */
    LocalNotificationsMock.prototype.convertIds = function (ids) {
        var convertedIds = [];
        for (var i = 0; i < ids.length; i++) {
            convertedIds.push(Number(ids[i]));
        }
        return convertedIds;
    };
    /**
     * Convert the notification options to their required type.
     * Code extracted from the Cordova plugin.
     *
     * @param {ILocalNotification} notification Notification.
     * @return {ILocalNotification} Converted notification.
     */
    LocalNotificationsMock.prototype.convertProperties = function (notification) {
        if (notification.id) {
            if (isNaN(notification.id)) {
                notification.id = this.defaults.id;
            }
            else {
                notification.id = Number(notification.id);
            }
        }
        if (notification.title) {
            notification.title = notification.title.toString();
        }
        if (notification.text) {
            notification.text = notification.text.toString();
        }
        if (notification.badge) {
            if (isNaN(notification.badge)) {
                notification.badge = this.defaults.badge;
            }
            else {
                notification.badge = Number(notification.badge);
            }
        }
        if (notification.at) {
            if (typeof notification.at == 'object') {
                notification.at = notification.at.getTime();
            }
            notification.at = Math.round(notification.at / 1000);
        }
        if (typeof notification.data == 'object') {
            notification.data = JSON.stringify(notification.data);
        }
        return notification;
    };
    /**
     * Get a notification object.
     *
     * @param {any} notificationId The id of the notification to get.
     * @returns {Promise<ILocalNotification>}
     */
    LocalNotificationsMock.prototype.get = function (notificationId) {
        return Promise.resolve(this.getNotifications([Number(notificationId)], true, true)[0]);
    };
    /**
     * Get all notification objects.
     *
     * @returns {Promise<Array<ILocalNotification>>}
     */
    LocalNotificationsMock.prototype.getAll = function () {
        return Promise.resolve(this.getNotifications(undefined, true, true));
    };
    /**
     * Get all the notification ids.
     *
     * @returns {Promise<Array<number>>}
     */
    LocalNotificationsMock.prototype.getAllIds = function () {
        var ids = this.utils.mergeArraysWithoutDuplicates(Object.keys(this.scheduled), Object.keys(this.triggered));
        ids = ids.map(function (id) {
            return Number(id);
        });
        return Promise.resolve(ids);
    };
    /**
     * Get all the notification stored in local DB.
     *
     * @return {Promise<any>} Promise resolved with the notifications.
     */
    LocalNotificationsMock.prototype.getAllNotifications = function () {
        return this.appDB.getAllRecords(this.DESKTOP_NOTIFS_TABLE);
    };
    /**
     * Get all scheduled notification objects.
     *
     * @returns {Promise<Array<ILocalNotification>>}
     */
    LocalNotificationsMock.prototype.getAllScheduled = function () {
        return Promise.resolve(this.getNotifications(undefined, true, false));
    };
    /**
     * Get all triggered notification objects.
     *
     * @returns {Promise<Array<ILocalNotification>>}
     */
    LocalNotificationsMock.prototype.getAllTriggered = function () {
        return Promise.resolve(this.getNotifications(undefined, false, true));
    };
    /**
     * Get a set of notifications. If ids isn't specified, return all the notifications.
     *
     * @param {Number[]} [ids] Ids of notifications to get. If not specified, get all notifications.
     * @param {boolean} [getScheduled] Get scheduled notifications.
     * @param {boolean} [getTriggered] Get triggered notifications.
     * @return {ILocalNotification[]} List of notifications.
     */
    LocalNotificationsMock.prototype.getNotifications = function (ids, getScheduled, getTriggered) {
        var notifications = [];
        if (getScheduled) {
            for (var id in this.scheduled) {
                if (!ids || ids.indexOf(Number(id)) != -1) {
                    notifications.push(this.scheduled[id].notification);
                }
            }
        }
        if (getTriggered) {
            for (var id in this.triggered) {
                if ((!getScheduled || !this.scheduled[id]) && (!ids || ids.indexOf(Number(id)) != -1)) {
                    notifications.push(this.triggered[id].notification);
                }
            }
        }
        return notifications;
    };
    /**
     * Get a scheduled notification object.
     *
     * @param {any} notificationId The id of the notification to ge.
     * @returns {Promise<ILocalNotification>}
     */
    LocalNotificationsMock.prototype.getScheduled = function (notificationId) {
        return Promise.resolve(this.getNotifications([Number(notificationId)], true, false)[0]);
    };
    /**
     * Get the ids of scheduled notifications.
     *
     * @returns {Promise<Array<number>>} Returns a promise
     */
    LocalNotificationsMock.prototype.getScheduledIds = function () {
        var ids = Object.keys(this.scheduled).map(function (id) {
            return Number(id);
        });
        return Promise.resolve(ids);
    };
    /**
     * Get a triggered notification object.
     *
     * @param {any} notificationId The id of the notification to get.
     * @returns {Promise<ILocalNotification>}
     */
    LocalNotificationsMock.prototype.getTriggered = function (notificationId) {
        return Promise.resolve(this.getNotifications([Number(notificationId)], false, true)[0]);
    };
    /**
     * Get the ids of triggered notifications.
     *
     * @returns {Promise<Array<number>>}
     */
    LocalNotificationsMock.prototype.getTriggeredIds = function () {
        var ids = Object.keys(this.triggered).map(function (id) {
            return Number(id);
        });
        return Promise.resolve(ids);
    };
    /**
     * Given an object of options and a list of properties, return the first property that exists.
     * Code extracted from the Cordova plugin.
     *
     * @param {ILocalNotification} notification Notification.
     * @param {any} ...args List of keys to check.
     * @return {any} First value found.
     */
    LocalNotificationsMock.prototype.getValueFor = function (notification) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        for (var i in args) {
            var key = args[i];
            if (notification.hasOwnProperty(key)) {
                return notification[key];
            }
        }
    };
    /**
     * Informs if the app has the permission to show notifications.
     *
     * @returns {Promise<boolean>}
     */
    LocalNotificationsMock.prototype.hasPermission = function () {
        return Promise.resolve(true);
    };
    /**
     * Checks presence of a notification.
     *
     * @param {number} notificationId Notification ID.
     * @returns {Promise<boolean>}
     */
    LocalNotificationsMock.prototype.isPresent = function (notificationId) {
        return Promise.resolve(!!this.scheduled[notificationId] || !!this.triggered[notificationId]);
    };
    /**
     * Checks is a notification is scheduled.
     *
     * @param {number} notificationId Notification ID.
     * @returns {Promise<boolean>}
     */
    LocalNotificationsMock.prototype.isScheduled = function (notificationId) {
        return Promise.resolve(!!this.scheduled[notificationId]);
    };
    /**
     * Checks if a notification is triggered.
     *
     * @param {number} notificationId Notification ID.
     * @returns {Promise<boolean>}
     */
    LocalNotificationsMock.prototype.isTriggered = function (notificationId) {
        return Promise.resolve(!!this.triggered[notificationId]);
    };
    /**
     * Loads an initialize the API for desktop.
     *
     * @return {Promise<any>} Promise resolved when done.
     */
    LocalNotificationsMock.prototype.load = function () {
        var _this = this;
        if (!this.appProvider.isDesktop()) {
            return Promise.resolve();
        }
        if (this.appProvider.isWindows()) {
            try {
                this.winNotif = __webpack_require__(1121);
            }
            catch (ex) {
                // Ignore errors.
            }
        }
        // App is being loaded, re-schedule all the notifications that were scheduled before.
        return this.getAllNotifications().catch(function () {
            return [];
        }).then(function (notifications) {
            notifications.forEach(function (notification) {
                if (notification.triggered) {
                    // Notification was triggered already, store it in memory but don't schedule it again.
                    delete notification.triggered;
                    _this.scheduled[notification.id] = {
                        notification: notification
                    };
                    _this.triggered[notification.id] = notification;
                }
                else {
                    // Schedule the notification again unless it should have been triggered more than an hour ago.
                    delete notification.triggered;
                    notification.at = notification.at * 1000;
                    if (notification.at - Date.now() > -__WEBPACK_IMPORTED_MODULE_4__core_constants__["a" /* CoreConstants */].SECONDS_HOUR * 1000) {
                        _this.schedule(notification);
                    }
                }
            });
        });
    };
    /**
     * Merge notification options with default values.
     * Code extracted from the Cordova plugin.
     *
     * @param {ILocalNotification} notification Notification.
     * @return {ILocalNotification} Treated notification.
     */
    LocalNotificationsMock.prototype.mergeWithDefaults = function (notification) {
        notification.at = this.getValueFor(notification, 'at', 'firstAt', 'date');
        notification.text = this.getValueFor(notification, 'text', 'message');
        notification.data = this.getValueFor(notification, 'data', 'json');
        if (notification.at === undefined || notification.at === null) {
            notification.at = new Date();
        }
        for (var key in this.defaults) {
            if (notification[key] === null || notification[key] === undefined) {
                if (notification.hasOwnProperty(key) && ['data', 'sound'].indexOf(key) > -1) {
                    notification[key] = undefined;
                }
                else {
                    notification[key] = this.defaults[key];
                }
            }
        }
        for (var key in notification) {
            if (!this.defaults.hasOwnProperty(key)) {
                delete notification[key];
            }
        }
        return notification;
    };
    /**
     * Function called when a notification is clicked.
     *
     * @param {ILocalNotification} notification Clicked notification.
     */
    LocalNotificationsMock.prototype.notificationClicked = function (notification) {
        this.triggerEvent('click', notification, 'foreground');
        // Focus the app.
        __webpack_require__(167).ipcRenderer.send('focusApp');
    };
    /**
     * Sets a callback for a specific event.
     *
     * @param {string} eventName Name of the event. Events: schedule, trigger, click, update, clear, clearall, cancel, cancelall
     * @param {any} callback Call back function.
     */
    LocalNotificationsMock.prototype.on = function (eventName, callback) {
        if (!this.observers[eventName] || typeof callback != 'function') {
            // Event not supported, stop.
            return;
        }
        this.observers[eventName].push(callback);
    };
    /**
     * Parse a interval and convert it to a number of milliseconds (0 if not valid).
     * Code extracted from the Cordova plugin.
     *
     * @param {string} every Interval to convert.
     * @return {number} Number of milliseconds of the interval-
     */
    LocalNotificationsMock.prototype.parseInterval = function (every) {
        var interval;
        every = String(every).toLowerCase();
        if (!every || every == 'undefined') {
            interval = 0;
        }
        else if (every == 'second') {
            interval = 1000;
        }
        else if (every == 'minute') {
            interval = __WEBPACK_IMPORTED_MODULE_4__core_constants__["a" /* CoreConstants */].SECONDS_MINUTE * 1000;
        }
        else if (every == 'hour') {
            interval = __WEBPACK_IMPORTED_MODULE_4__core_constants__["a" /* CoreConstants */].SECONDS_HOUR * 1000;
        }
        else if (every == 'day') {
            interval = __WEBPACK_IMPORTED_MODULE_4__core_constants__["a" /* CoreConstants */].SECONDS_DAY * 1000;
        }
        else if (every == 'week') {
            interval = __WEBPACK_IMPORTED_MODULE_4__core_constants__["a" /* CoreConstants */].SECONDS_DAY * 7 * 1000;
        }
        else if (every == 'month') {
            interval = __WEBPACK_IMPORTED_MODULE_4__core_constants__["a" /* CoreConstants */].SECONDS_DAY * 31 * 1000;
        }
        else if (every == 'quarter') {
            interval = __WEBPACK_IMPORTED_MODULE_4__core_constants__["a" /* CoreConstants */].SECONDS_HOUR * 2190 * 1000;
        }
        else if (every == 'year') {
            interval = __WEBPACK_IMPORTED_MODULE_4__core_constants__["a" /* CoreConstants */].SECONDS_YEAR * 1000;
        }
        else {
            interval = parseInt(every, 10);
            if (isNaN(interval)) {
                interval = 0;
            }
            else {
                interval *= 60000;
            }
        }
        return interval;
    };
    /**
     * Register permission to show notifications if not already granted.
     *
     * @returns {Promise<boolean>}
     */
    LocalNotificationsMock.prototype.registerPermission = function () {
        return Promise.resolve(true);
    };
    /**
     * Remove a notification from local DB.
     *
     * @param {number} id ID of the notification.
     * @return {Promise<any>} Promise resolved when done.
     */
    LocalNotificationsMock.prototype.removeNotification = function (id) {
        return this.appDB.deleteRecords(this.DESKTOP_NOTIFS_TABLE, { id: id });
    };
    /**
     * Schedules a single or multiple notifications.
     *
     * @param {ILocalNotification | Array<ILocalNotification>} [options] Notification or notifications.
     */
    LocalNotificationsMock.prototype.schedule = function (options) {
        this.scheduleOrUpdate(options);
    };
    /**
     * Schedules or updates a single or multiple notifications.
     *
     * @param {ILocalNotification | Array<ILocalNotification>} [options] Notification or notifications.
     * @param {string} [eventName] Name of the event: schedule or update.
     */
    LocalNotificationsMock.prototype.scheduleOrUpdate = function (options, eventName) {
        var _this = this;
        if (eventName === void 0) { eventName = 'schedule'; }
        options = Array.isArray(options) ? options : [options];
        options.forEach(function (notification) {
            _this.mergeWithDefaults(notification);
            _this.convertProperties(notification);
            // Cancel current notification if exists.
            _this.cancelNotification(notification.id, true, 'cancel');
            // Store the notification in the scheduled list and in the DB.
            _this.scheduled[notification.id] = {
                notification: notification
            };
            _this.storeNotification(notification, false);
            if (Math.abs(__WEBPACK_IMPORTED_MODULE_6_moment__().diff(notification.at * 1000, 'days')) > 15) {
                // Notification should trigger more than 15 days from now, don't schedule it.
                return;
            }
            // Schedule the notification.
            var toTriggerTime = notification.at * 1000 - Date.now(), trigger = function () {
                // Trigger the notification.
                _this.triggerNotification(notification);
                // Store the notification as triggered. Don't remove it from scheduled, it's how the plugin works.
                _this.triggered[notification.id] = notification;
                _this.storeNotification(notification, true);
                // Launch the trigger event.
                _this.triggerEvent('trigger', notification, 'foreground');
                if (notification.every && _this.scheduled[notification.id] && !_this.scheduled[notification.id].interval) {
                    var interval = _this.parseInterval(notification.every);
                    if (interval > 0) {
                        _this.scheduled[notification.id].interval = setInterval(trigger, interval);
                    }
                }
            };
            _this.scheduled[notification.id].timeout = setTimeout(trigger, toTriggerTime);
            // Launch the scheduled/update event.
            _this.triggerEvent(eventName, notification, 'foreground');
        });
    };
    /**
     * Store a notification in local DB.
     *
     * @param {any} notification Notification to store.
     * @param {boolean} triggered Whether the notification has been triggered.
     * @return {Promise<any>} Promise resolved when stored.
     */
    LocalNotificationsMock.prototype.storeNotification = function (notification, triggered) {
        notification = Object.assign({}, notification); // Clone the object.
        notification.triggered = !!triggered;
        return this.appDB.insertOrUpdateRecord(this.DESKTOP_NOTIFS_TABLE, notification, { id: notification.id });
    };
    /**
     * Trigger an event.
     *
     * @param {string} eventName Event name.
     * @param {any[]} ...args List of parameters to pass.
     */
    LocalNotificationsMock.prototype.triggerEvent = function (eventName) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (this.observers[eventName]) {
            this.observers[eventName].forEach(function (callback) {
                callback.apply(null, args);
            });
        }
    };
    /**
     * Trigger a notification, using the best method depending on the OS.
     *
     * @param {ILocalNotification} notification Notification to trigger.
     */
    LocalNotificationsMock.prototype.triggerNotification = function (notification) {
        var _this = this;
        if (this.winNotif) {
            // Use Windows notifications.
            var notifInstance = new this.winNotif.ToastNotification({
                appId: __WEBPACK_IMPORTED_MODULE_5__configconstants__["a" /* CoreConfigConstants */].app_id,
                template: this.toastTemplate,
                strings: [notification.title, notification.text]
            });
            // Listen for click events.
            notifInstance.on('activated', function () {
                _this.notificationClicked(notification);
            });
            notifInstance.show();
            try {
                // Show it in Tile too.
                var tileNotif = new this.winNotif.TileNotification({
                    tag: notification.id + '',
                    template: this.tileTemplate,
                    strings: [notification.title, notification.text, notification.title, notification.text, notification.title,
                        notification.text],
                    expirationTime: new Date(Date.now() + __WEBPACK_IMPORTED_MODULE_4__core_constants__["a" /* CoreConstants */].SECONDS_HOUR * 1000) // Expire in 1 hour.
                });
                tileNotif.show();
            }
            catch (ex) {
                // tslint:disable-next-line
                console.warn('Error showing TileNotification. Please notice they only work with the app installed.', ex);
            }
        }
        else {
            // Use Electron default notifications.
            var notifInstance = new Notification(notification.title, {
                body: notification.text
            });
            // Listen for click events.
            notifInstance.onclick = function () {
                _this.notificationClicked(notification);
            };
        }
    };
    /**
     * Removes a callback of a specific event.
     *
     * @param {string} eventName Name of the event. Events: schedule, trigger, click, update, clear, clearall, cancel, cancelall
     * @param {any} callback Call back function.
     */
    LocalNotificationsMock.prototype.un = function (eventName, callback) {
        if (this.observers[eventName] && this.observers[eventName].length) {
            for (var i = 0; i < this.observers[eventName].length; i++) {
                if (this.observers[eventName][i] == callback) {
                    this.observers[eventName].splice(i, 1);
                    break;
                }
            }
        }
    };
    /**
     * Updates a previously scheduled notification. Must include the id in the options parameter.
     *
     * @param {ILocalNotification} [options] Notification.
     */
    LocalNotificationsMock.prototype.update = function (options) {
        return this.scheduleOrUpdate(options, 'update');
    };
    LocalNotificationsMock = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_app__["a" /* CoreAppProvider */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__["a" /* CoreUtilsProvider */]])
    ], LocalNotificationsMock);
    return LocalNotificationsMock;
}(__WEBPACK_IMPORTED_MODULE_1__ionic_native_local_notifications__["a" /* LocalNotifications */]));

//# sourceMappingURL=local-notifications.js.map

/***/ }),
/* 1121 */,
/* 1122 */,
/* 1123 */,
/* 1124 */,
/* 1125 */,
/* 1126 */,
/* 1127 */,
/* 1128 */,
/* 1129 */,
/* 1130 */,
/* 1131 */,
/* 1132 */,
/* 1133 */,
/* 1134 */,
/* 1135 */,
/* 1136 */,
/* 1137 */,
/* 1138 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MediaCaptureMock; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_media_capture__ = __webpack_require__(242);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__capture_helper__ = __webpack_require__(166);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Emulates the Cordova MediaCapture plugin in desktop apps and in browser.
 */
var MediaCaptureMock = /** @class */ (function (_super) {
    __extends(MediaCaptureMock, _super);
    function MediaCaptureMock(captureHelper) {
        var _this = _super.call(this) || this;
        _this.captureHelper = captureHelper;
        return _this;
    }
    /**
     * Start the audio recorder application and return information about captured audio clip files.
     *
     * @param {CaptureAudioOptions} options Options.
     * @return {Promise<any>} Promise resolved when captured.
     */
    MediaCaptureMock.prototype.captureAudio = function (options) {
        return this.captureHelper.captureMedia('audio', options);
    };
    /**
     * Start the camera application and return information about captured image files.
     *
     * @param {CaptureImageOptions} options Options.
     * @return {Promise<any>} Promise resolved when captured.
     */
    MediaCaptureMock.prototype.captureImage = function (options) {
        return this.captureHelper.captureMedia('captureimage', options);
    };
    /**
     * Start the video recorder application and return information about captured video clip files.
     *
     * @param {CaptureVideoOptions} options Options.
     * @return {Promise<any>} Promise resolved when captured.
     */
    MediaCaptureMock.prototype.captureVideo = function (options) {
        return this.captureHelper.captureMedia('video', options);
    };
    MediaCaptureMock = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__capture_helper__["a" /* CoreEmulatorCaptureHelperProvider */]])
    ], MediaCaptureMock);
    return MediaCaptureMock;
}(__WEBPACK_IMPORTED_MODULE_1__ionic_native_media_capture__["a" /* MediaCapture */]));

//# sourceMappingURL=media-capture.js.map

/***/ }),
/* 1139 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return NetworkMock; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_network__ = __webpack_require__(103);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_rxjs__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Emulates the Cordova Globalization plugin in desktop apps and in browser.
 */
var NetworkMock = /** @class */ (function (_super) {
    __extends(NetworkMock, _super);
    function NetworkMock() {
        var _this = _super.call(this) || this;
        window.Connection = {
            UNKNOWN: 'unknown',
            ETHERNET: 'ethernet',
            WIFI: 'wifi',
            CELL_2G: '2g',
            CELL_3G: '3g',
            CELL_4G: '4g',
            CELL: 'cellular',
            NONE: 'none'
        };
        return _this;
    }
    /**
     * Returns an observable to watch connection changes.
     *
     * @return {Observable<any>} Observable.
     */
    NetworkMock.prototype.onchange = function () {
        return __WEBPACK_IMPORTED_MODULE_2_rxjs__["Observable"].merge(this.onConnect(), this.onDisconnect());
    };
    /**
     * Returns an observable to notify when the app is connected.
     *
     * @return {Observable<any>} Observable.
     */
    NetworkMock.prototype.onConnect = function () {
        var observable = new __WEBPACK_IMPORTED_MODULE_2_rxjs__["Subject"]();
        window.addEventListener('online', function (ev) {
            observable.next(ev);
        }, false);
        return observable;
    };
    /**
     * Returns an observable to notify when the app is disconnected.
     *
     * @return {Observable<any>} Observable.
     */
    NetworkMock.prototype.onDisconnect = function () {
        var observable = new __WEBPACK_IMPORTED_MODULE_2_rxjs__["Subject"]();
        window.addEventListener('offline', function (ev) {
            observable.next(ev);
        }, false);
        return observable;
    };
    NetworkMock = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [])
    ], NetworkMock);
    return NetworkMock;
}(__WEBPACK_IMPORTED_MODULE_1__ionic_native_network__["a" /* Network */]));

//# sourceMappingURL=network.js.map

/***/ }),
/* 1140 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ZipMock; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_zip__ = __webpack_require__(239);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_jszip__ = __webpack_require__(1141);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_jszip___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_jszip__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_file__ = __webpack_require__(128);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_mimetype__ = __webpack_require__(44);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Emulates the Cordova Zip plugin in desktop apps and in browser.
 */
var ZipMock = /** @class */ (function (_super) {
    __extends(ZipMock, _super);
    function ZipMock(file, mimeUtils) {
        var _this = _super.call(this) || this;
        _this.file = file;
        _this.mimeUtils = mimeUtils;
        return _this;
    }
    /**
     * Extracts files from a ZIP archive.
     *
     * @param {string} source Path to the source ZIP file.
     * @param {string} destination Destination folder.
     * @param {Function} [onProgress] Optional callback to be called on progress update
     * @return {Promise<number>} Promise that resolves with a number. 0 is success, -1 is error.
     */
    ZipMock.prototype.unzip = function (source, destination, onProgress) {
        var _this = this;
        // Replace all %20 with spaces.
        source = source.replace(/%20/g, ' ');
        destination = destination.replace(/%20/g, ' ');
        var sourceDir = source.substring(0, source.lastIndexOf('/')), sourceName = source.substr(source.lastIndexOf('/') + 1);
        return this.file.readAsArrayBuffer(sourceDir, sourceName).then(function (data) {
            var zip = new __WEBPACK_IMPORTED_MODULE_2_jszip__["JSZip"](data), promises = [], total = Object.keys(zip.files).length;
            var loaded = 0;
            if (!zip.files || !zip.files.length) {
                // Nothing to extract.
                return 0;
            }
            zip.files.forEach(function (file, name) {
                var type, promise;
                if (!file.dir) {
                    // It's a file. Get the mimetype and write the file.
                    type = _this.mimeUtils.getMimeType(_this.mimeUtils.getFileExtension(name));
                    promise = _this.file.writeFile(destination, name, new Blob([file.asArrayBuffer()], { type: type }));
                }
                else {
                    // It's a folder, create it if it doesn't exist.
                    promise = _this.file.createDir(destination, name, false);
                }
                promises.push(promise.then(function () {
                    // File unzipped, call the progress.
                    loaded++;
                    onProgress && onProgress({ loaded: loaded, total: total });
                }));
            });
            return Promise.all(promises).then(function () {
                return 0;
            });
        }).catch(function () {
            // Error.
            return -1;
        });
    };
    ZipMock = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__ionic_native_file__["a" /* File */], __WEBPACK_IMPORTED_MODULE_4__providers_utils_mimetype__["a" /* CoreMimetypeUtilsProvider */]])
    ], ZipMock);
    return ZipMock;
}(__WEBPACK_IMPORTED_MODULE_1__ionic_native_zip__["a" /* Zip */]));

//# sourceMappingURL=zip.js.map

/***/ }),
/* 1141 */,
/* 1142 */,
/* 1143 */,
/* 1144 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 1145 */,
/* 1146 */,
/* 1147 */,
/* 1148 */,
/* 1149 */,
/* 1150 */,
/* 1151 */,
/* 1152 */,
/* 1153 */,
/* 1154 */,
/* 1155 */,
/* 1156 */,
/* 1157 */,
/* 1158 */,
/* 1159 */,
/* 1160 */,
/* 1161 */,
/* 1162 */,
/* 1163 */,
/* 1164 */,
/* 1165 */,
/* 1166 */,
/* 1167 */,
/* 1168 */,
/* 1169 */,
/* 1170 */,
/* 1171 */,
/* 1172 */,
/* 1173 */,
/* 1174 */,
/* 1175 */,
/* 1176 */,
/* 1177 */,
/* 1178 */,
/* 1179 */,
/* 1180 */,
/* 1181 */,
/* 1182 */,
/* 1183 */,
/* 1184 */,
/* 1185 */,
/* 1186 */,
/* 1187 */,
/* 1188 */,
/* 1189 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreEmulatorHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_file__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_file__ = __webpack_require__(128);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ionic_native_local_notifications__ = __webpack_require__(161);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_init__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__file_transfer__ = __webpack_require__(621);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__capture_helper__ = __webpack_require__(166);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








/**
 * Helper service for the emulator feature. It also acts as an init handler.
 */
var CoreEmulatorHelperProvider = /** @class */ (function () {
    function CoreEmulatorHelperProvider(file, fileProvider, utils, initDelegate, localNotif, captureHelper) {
        this.file = file;
        this.fileProvider = fileProvider;
        this.utils = utils;
        this.localNotif = localNotif;
        this.captureHelper = captureHelper;
        this.name = 'CoreEmulator';
        this.priority = __WEBPACK_IMPORTED_MODULE_5__providers_init__["a" /* CoreInitDelegate */].MAX_RECOMMENDED_PRIORITY + 500;
        this.blocking = true;
    }
    /**
     * Load the Mocks that need it.
     *
     * @return {Promise<void>} Promise resolved when loaded.
     */
    CoreEmulatorHelperProvider.prototype.load = function () {
        var _this = this;
        var promises = [];
        promises.push(this.file.load().then(function (basePath) {
            _this.fileProvider.setHTMLBasePath(basePath);
        }));
        promises.push(this.localNotif.load());
        promises.push(this.captureHelper.load());
        window.FileTransferError = __WEBPACK_IMPORTED_MODULE_6__file_transfer__["a" /* FileTransferErrorMock */];
        return this.utils.allPromises(promises);
    };
    CoreEmulatorHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__ionic_native_file__["a" /* File */], __WEBPACK_IMPORTED_MODULE_1__providers_file__["a" /* CoreFileProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_5__providers_init__["a" /* CoreInitDelegate */], __WEBPACK_IMPORTED_MODULE_4__ionic_native_local_notifications__["a" /* LocalNotifications */],
            __WEBPACK_IMPORTED_MODULE_7__capture_helper__["a" /* CoreEmulatorCaptureHelperProvider */]])
    ], CoreEmulatorHelperProvider);
    return CoreEmulatorHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),
/* 1190 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 1191 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreContentLinksModuleGradeHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__base_handler__ = __webpack_require__(43);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

/**
 * Handler to handle URLs pointing to the grade of a module.
 */
var CoreContentLinksModuleGradeHandler = /** @class */ (function (_super) {
    __extends(CoreContentLinksModuleGradeHandler, _super);
    /**
     * Construct the handler.
     *
     * @param {CoreCourseHelperProvider} courseHelper The CoreCourseHelperProvider instance.
     * @param {CoreDomUtilsProvider} domUtils The CoreDomUtilsProvider instance.
     * @param {CoreSitesProvider} sitesProvider The CoreSitesProvider instance.
     * @param {string} addon Name of the addon as it's registered in course delegate. It'll be used to check if it's disabled.
     * @param {string} modName Name of the module (assign, book, ...).
     */
    function CoreContentLinksModuleGradeHandler(courseHelper, domUtils, sitesProvider, addon, modName) {
        var _this = _super.call(this) || this;
        _this.courseHelper = courseHelper;
        _this.domUtils = domUtils;
        _this.sitesProvider = sitesProvider;
        _this.addon = addon;
        _this.modName = modName;
        // Match the grade.php URL with an id param.
        _this.pattern = new RegExp('\/mod\/' + modName + '\/grade\.php.*([\&\?]id=\\d+)');
        _this.featureName = '$mmCourseDelegate_' + addon;
        return _this;
    }
    /**
     * Get the list of actions for a link (url).
     *
     * @param {string[]} siteIds List of sites the URL belongs to.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {CoreContentLinksAction[]|Promise<CoreContentLinksAction[]>} List of (or promise resolved with list of) actions.
     */
    CoreContentLinksModuleGradeHandler.prototype.getActions = function (siteIds, url, params, courseId) {
        var _this = this;
        courseId = courseId || params.courseid || params.cid;
        return [{
                action: function (siteId, navCtrl) {
                    // Check if userid is the site's current user.
                    var modal = _this.domUtils.showModalLoading();
                    _this.sitesProvider.getSite(siteId).then(function (site) {
                        if (!params.userid || params.userid == site.getUserId()) {
                            // No user specified or current user. Navigate to module.
                            _this.courseHelper.navigateToModule(parseInt(params.id, 10), siteId, courseId);
                        }
                        else if (_this.canReview) {
                            // Use the goToReview function.
                            _this.goToReview(url, params, courseId, siteId, navCtrl);
                        }
                        else {
                            // Not current user and cannot review it in the app, open it in browser.
                            site.openInBrowserWithAutoLogin(url);
                        }
                    }).finally(function () {
                        modal.dismiss();
                    });
                }
            }];
    };
    /**
     * Go to the page to review.
     *
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} courseId Course ID related to the URL.
     * @param {string} siteId Site to use.
     * @param {NavController} [navCtrl] Nav Controller to use to navigate.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreContentLinksModuleGradeHandler.prototype.goToReview = function (url, params, courseId, siteId, navCtrl) {
        // This function should be overridden.
        return Promise.resolve();
    };
    return CoreContentLinksModuleGradeHandler;
}(__WEBPACK_IMPORTED_MODULE_0__base_handler__["a" /* CoreContentLinksHandlerBase */]));

//# sourceMappingURL=module-grade-handler.js.map

/***/ }),
/* 1192 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseDirectivesModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__download_module_main_file__ = __webpack_require__(1193);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


var CoreCourseDirectivesModule = /** @class */ (function () {
    function CoreCourseDirectivesModule() {
    }
    CoreCourseDirectivesModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_1__download_module_main_file__["a" /* CoreCourseDownloadModuleMainFileDirective */]
            ],
            imports: [],
            exports: [
                __WEBPACK_IMPORTED_MODULE_1__download_module_main_file__["a" /* CoreCourseDownloadModuleMainFileDirective */]
            ]
        })
    ], CoreCourseDirectivesModule);
    return CoreCourseDirectivesModule;
}());

//# sourceMappingURL=directives.module.js.map

/***/ }),
/* 1193 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCourseDownloadModuleMainFileDirective; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_course__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_helper__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__ = __webpack_require__(10);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Directive to allow downloading and open the main file of a module.
 * When the item with this directive is clicked, the module will be downloaded (if needed) and opened.
 * This is meant for modules like mod_resource.
 *
 * This directive must receive either a module or a moduleId. If no files are provided, it will use module.contents.
 */
var CoreCourseDownloadModuleMainFileDirective = /** @class */ (function () {
    function CoreCourseDownloadModuleMainFileDirective(element, domUtils, courseHelper, courseProvider) {
        this.domUtils = domUtils;
        this.courseHelper = courseHelper;
        this.courseProvider = courseProvider;
        this.element = element.nativeElement || element;
    }
    /**
     * Component being initialized.
     */
    CoreCourseDownloadModuleMainFileDirective.prototype.ngOnInit = function () {
        var _this = this;
        this.element.addEventListener('click', function (ev) {
            if (!_this.module && !_this.moduleId) {
                return;
            }
            ev.preventDefault();
            ev.stopPropagation();
            var modal = _this.domUtils.showModalLoading(), courseId = typeof _this.courseId == 'string' ? parseInt(_this.courseId, 10) : _this.courseId;
            var promise;
            if (_this.module) {
                // We already have the module.
                promise = Promise.resolve(module);
            }
            else {
                // Try to get the module from cache.
                _this.moduleId = typeof _this.moduleId == 'string' ? parseInt(_this.moduleId, 10) : _this.moduleId;
                promise = _this.courseProvider.getModule(_this.moduleId, courseId);
            }
            promise.then(function (module) {
                var componentId = _this.componentId || module.id;
                return _this.courseHelper.downloadModuleAndOpenFile(module, courseId, _this.component, componentId, _this.files);
            }).catch(function (error) {
                _this.domUtils.showErrorModalDefault(error, 'core.errordownloading', true);
            }).finally(function () {
                modal.dismiss();
            });
        });
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreCourseDownloadModuleMainFileDirective.prototype, "module", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreCourseDownloadModuleMainFileDirective.prototype, "moduleId", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreCourseDownloadModuleMainFileDirective.prototype, "courseId", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreCourseDownloadModuleMainFileDirective.prototype, "component", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreCourseDownloadModuleMainFileDirective.prototype, "componentId", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Array)
    ], CoreCourseDownloadModuleMainFileDirective.prototype, "files", void 0);
    CoreCourseDownloadModuleMainFileDirective = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["s" /* Directive */])({
            selector: '[core-course-download-module-main-file]'
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_helper__["a" /* CoreCourseHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_1__providers_course__["a" /* CoreCourseProvider */]])
    ], CoreCourseDownloadModuleMainFileDirective);
    return CoreCourseDownloadModuleMainFileDirective;
}());

//# sourceMappingURL=download-module-main-file.js.map
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(595)(module)))

/***/ }),
/* 1194 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSitePluginsDirectivesModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__call_ws__ = __webpack_require__(1195);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__call_ws_new_content__ = __webpack_require__(1196);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__call_ws_on_load__ = __webpack_require__(1197);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__new_content__ = __webpack_require__(1198);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};





var CoreSitePluginsDirectivesModule = /** @class */ (function () {
    function CoreSitePluginsDirectivesModule() {
    }
    CoreSitePluginsDirectivesModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_1__call_ws__["a" /* CoreSitePluginsCallWSDirective */],
                __WEBPACK_IMPORTED_MODULE_2__call_ws_new_content__["a" /* CoreSitePluginsCallWSNewContentDirective */],
                __WEBPACK_IMPORTED_MODULE_3__call_ws_on_load__["a" /* CoreSitePluginsCallWSOnLoadDirective */],
                __WEBPACK_IMPORTED_MODULE_4__new_content__["a" /* CoreSitePluginsNewContentDirective */]
            ],
            imports: [],
            exports: [
                __WEBPACK_IMPORTED_MODULE_1__call_ws__["a" /* CoreSitePluginsCallWSDirective */],
                __WEBPACK_IMPORTED_MODULE_2__call_ws_new_content__["a" /* CoreSitePluginsCallWSNewContentDirective */],
                __WEBPACK_IMPORTED_MODULE_3__call_ws_on_load__["a" /* CoreSitePluginsCallWSOnLoadDirective */],
                __WEBPACK_IMPORTED_MODULE_4__new_content__["a" /* CoreSitePluginsNewContentDirective */]
            ]
        })
    ], CoreSitePluginsDirectivesModule);
    return CoreSitePluginsDirectivesModule;
}());

//# sourceMappingURL=directives.module.js.map

/***/ }),
/* 1195 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSitePluginsCallWSDirective; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_siteplugins__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__classes_call_ws_click_directive__ = __webpack_require__(654);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__components_plugin_content_plugin_content__ = __webpack_require__(81);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};








/**
 * Directive to call a WS when the element is clicked. The action to do when the WS call is successful depends on the input data:
 * display a message, go back or refresh current view.
 *
 * If you want to load a new content when the WS call is done, @see CoreSitePluginsCallWSNewContentDirective.
 *
 * @see CoreSitePluginsCallWSOnClickBaseDirective.
 *
 * Example usages:
 *
 * A button to send some data to the server without using cache, displaying default messages and refreshing on success:
 *
 * <button ion-button core-site-plugins-call-ws name="mod_certificate_view_certificate"
 *             [params]="{certificateid: <% certificate.id %>}" [preSets]="{getFromCache: 0, saveToCache: 0}" confirmMessage
 *             successMessage refreshOnSuccess="true">
 *     {{ 'plugin.mod_certificate_coursecertificate.senddata' | translate }}
 * </button>
 *
 * A button to send some data to the server using cache, without confirm, going back on success and using userid from otherdata:
 *
 * <button ion-button core-site-plugins-call-ws name="mod_certificate_view_certificate"
 *             [params]="{certificateid: <% certificate.id %>}" goBackOnSuccess="true" [useOtherData]="['userid']">
 *     {{ 'plugin.mod_certificate_coursecertificate.senddata' | translate }}
 * </button>
 */
var CoreSitePluginsCallWSDirective = /** @class */ (function (_super) {
    __extends(CoreSitePluginsCallWSDirective, _super);
    function CoreSitePluginsCallWSDirective(element, translate, domUtils, sitePluginsProvider, parentContent, utils, navCtrl) {
        var _this = _super.call(this, element, translate, domUtils, sitePluginsProvider, parentContent) || this;
        _this.utils = utils;
        _this.navCtrl = navCtrl;
        return _this;
    }
    /**
     * Function called when the WS call is successful.
     *
     * @param {any} result Result of the WS call.
     */
    CoreSitePluginsCallWSDirective.prototype.wsCallSuccess = function (result) {
        if (typeof this.successMessage != 'undefined') {
            // Display the success message.
            this.domUtils.showToast(this.successMessage || this.translate.instant('core.success'));
        }
        if (this.utils.isTrueOrOne(this.goBackOnSuccess)) {
            this.navCtrl.pop();
        }
        else if (this.utils.isTrueOrOne(this.refreshOnSuccess) && this.parentContent) {
            this.parentContent.refreshData(true);
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreSitePluginsCallWSDirective.prototype, "successMessage", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreSitePluginsCallWSDirective.prototype, "goBackOnSuccess", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreSitePluginsCallWSDirective.prototype, "refreshOnSuccess", void 0);
    CoreSitePluginsCallWSDirective = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["s" /* Directive */])({
            selector: '[core-site-plugins-call-ws]'
        }),
        __param(4, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["N" /* Optional */])()),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_5__providers_siteplugins__["a" /* CoreSitePluginsProvider */], __WEBPACK_IMPORTED_MODULE_7__components_plugin_content_plugin_content__["a" /* CoreSitePluginsPluginContentComponent */],
            __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavController */]])
    ], CoreSitePluginsCallWSDirective);
    return CoreSitePluginsCallWSDirective;
}(__WEBPACK_IMPORTED_MODULE_6__classes_call_ws_click_directive__["a" /* CoreSitePluginsCallWSOnClickBaseDirective */]));

//# sourceMappingURL=call-ws.js.map

/***/ }),
/* 1196 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSitePluginsCallWSNewContentDirective; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_siteplugins__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__classes_call_ws_click_directive__ = __webpack_require__(654);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__components_plugin_content_plugin_content__ = __webpack_require__(81);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};








/**
 * Directive to call a WS when the element is clicked and load a new content passing the WS result as args. This new content
 * can be displayed in a new page or in the same page (only if current page is already displaying a site plugin content).
 *
 * If you don't need to load some new content when done, @see CoreSitePluginsCallWSDirective.
 *
 * @see CoreSitePluginsCallWSOnClickBaseDirective.
 *
 * Example usages:
 *
 * A button to get some data from the server without using cache, showing default confirm and displaying a new page:
 *
 * <button ion-button core-site-plugins-call-ws-new-content name="mod_certificate_get_issued_certificates"
 *             [params]="{certificateid: <% certificate.id %>}" [preSets]="{getFromCache: 0, saveToCache: 0}" confirmMessage
 *             title="<% certificate.name %>" component="mod_certificate" method="mobile_issues_view"
 *             [args]="{cmid: <% cmid %>, courseid: <% courseid %>}">
 *     {{ 'plugin.mod_certificate_coursecertificate.getissued' | translate }}
 * </button>
 *
 * A button to get some data from the server using cache, without confirm, displaying new content in same page and using
 * userid from otherdata:
 *
 * <button ion-button core-site-plugins-call-ws-new-content name="mod_certificate_get_issued_certificates"
 *             [params]="{certificateid: <% certificate.id %>}" component="mod_certificate" method="mobile_issues_view"
 *             [args]="{cmid: <% cmid %>, courseid: <% courseid %>}" samePage="true" [useOtherData]="['userid']">
 *     {{ 'plugin.mod_certificate_coursecertificate.getissued' | translate }}
 * </button>
 */
var CoreSitePluginsCallWSNewContentDirective = /** @class */ (function (_super) {
    __extends(CoreSitePluginsCallWSNewContentDirective, _super);
    function CoreSitePluginsCallWSNewContentDirective(element, translate, domUtils, sitePluginsProvider, parentContent, utils, navCtrl) {
        var _this = _super.call(this, element, translate, domUtils, sitePluginsProvider, parentContent) || this;
        _this.utils = utils;
        _this.navCtrl = navCtrl;
        return _this;
    }
    /**
     * Function called when the WS call is successful.
     *
     * @param {any} result Result of the WS call.
     */
    CoreSitePluginsCallWSNewContentDirective.prototype.wsCallSuccess = function (result) {
        var args = this.args || {};
        if (this.parentContent) {
            args = this.sitePluginsProvider.loadOtherDataInArgs(this.args, this.parentContent.otherData, this.useOtherData);
        }
        // Add the properties from the WS call result to the args.
        args = Object.assign(args, result);
        if (this.utils.isTrueOrOne(this.samePage)) {
            // Update the parent content (if it exists).
            if (this.parentContent) {
                this.parentContent.updateContent(this.component, this.method, args);
            }
        }
        else {
            this.navCtrl.push('CoreSitePluginsPluginPage', {
                title: this.title,
                component: this.component,
                method: this.method,
                args: args,
                bootstrapResult: this.parentContent && this.parentContent.bootstrapResult
            });
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreSitePluginsCallWSNewContentDirective.prototype, "component", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreSitePluginsCallWSNewContentDirective.prototype, "method", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreSitePluginsCallWSNewContentDirective.prototype, "args", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreSitePluginsCallWSNewContentDirective.prototype, "title", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreSitePluginsCallWSNewContentDirective.prototype, "samePage", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Array)
    ], CoreSitePluginsCallWSNewContentDirective.prototype, "useOtherData", void 0);
    CoreSitePluginsCallWSNewContentDirective = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["s" /* Directive */])({
            selector: '[core-site-plugins-call-ws-new-content]'
        }),
        __param(4, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["N" /* Optional */])()),
        __param(6, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["N" /* Optional */])()),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_5__providers_siteplugins__["a" /* CoreSitePluginsProvider */], __WEBPACK_IMPORTED_MODULE_7__components_plugin_content_plugin_content__["a" /* CoreSitePluginsPluginContentComponent */],
            __WEBPACK_IMPORTED_MODULE_4__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavController */]])
    ], CoreSitePluginsCallWSNewContentDirective);
    return CoreSitePluginsCallWSNewContentDirective;
}(__WEBPACK_IMPORTED_MODULE_6__classes_call_ws_click_directive__["a" /* CoreSitePluginsCallWSOnClickBaseDirective */]));

//# sourceMappingURL=call-ws-new-content.js.map

/***/ }),
/* 1197 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSitePluginsCallWSOnLoadDirective; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_siteplugins__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__classes_call_ws_directive__ = __webpack_require__(655);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__components_plugin_content_plugin_content__ = __webpack_require__(81);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};






/**
 * Directive to call a WS as soon as its loaded.
 * This directive is meant for actions to do in the background, like calling logging WebServices.
 *
 * If you want to call a WS when the user clicks on a certain element, @see CoreSitePluginsCallWSDirective.
 *
 * @see CoreSitePluginsCallWSBaseDirective.
 *
 * Example usage:
 *
 * <span core-site-plugins-call-ws-on-load name="mod_certificate_view_certificate" [params]="{certificateid: <% certificate.id %>}"
 *     [preSets]="{getFromCache: 0, saveToCache: 0}"></span>
 */
var CoreSitePluginsCallWSOnLoadDirective = /** @class */ (function (_super) {
    __extends(CoreSitePluginsCallWSOnLoadDirective, _super);
    function CoreSitePluginsCallWSOnLoadDirective(element, translate, domUtils, sitePluginsProvider, parentContent) {
        return _super.call(this, element, translate, domUtils, sitePluginsProvider, parentContent) || this;
    }
    /**
     * Component being initialized.
     */
    CoreSitePluginsCallWSOnLoadDirective.prototype.ngOnInit = function () {
        _super.prototype.ngOnInit.call(this);
        // Call the WS immediately.
        this.callWS().catch(function () {
            // Ignore errors.
        });
    };
    CoreSitePluginsCallWSOnLoadDirective = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["s" /* Directive */])({
            selector: '[core-site-plugins-call-ws-on-load]'
        }),
        __param(4, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["N" /* Optional */])()),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_siteplugins__["a" /* CoreSitePluginsProvider */], __WEBPACK_IMPORTED_MODULE_5__components_plugin_content_plugin_content__["a" /* CoreSitePluginsPluginContentComponent */]])
    ], CoreSitePluginsCallWSOnLoadDirective);
    return CoreSitePluginsCallWSOnLoadDirective;
}(__WEBPACK_IMPORTED_MODULE_4__classes_call_ws_directive__["a" /* CoreSitePluginsCallWSBaseDirective */]));

//# sourceMappingURL=call-ws-on-load.js.map

/***/ }),
/* 1198 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSitePluginsNewContentDirective; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_siteplugins__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__components_plugin_content_plugin_content__ = __webpack_require__(81);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};






/**
 * Directive to display a new site plugin content when clicked. This new content can be displayed in a new page or in the
 * current page (only if the current page is already displaying a site plugin content).
 *
 * Example usages:
 *
 * A button to go to a new content page:
 *
 * <button ion-button core-site-plugins-new-content title="<% certificate.name %>" component="mod_certificate"
 *             method="mobile_issues_view" [args]="{cmid: <% cmid %>, courseid: <% courseid %>}">
 *     {{ 'plugin.mod_certificate_coursecertificate.viewissued' | translate }}
 * </button>
 *
 * A button to load new content in current page using a param from otherdata:
 *
 * <button ion-button core-site-plugins-new-content component="mod_certificate" method="mobile_issues_view"
 *         [args]="{cmid: <% cmid %>, courseid: <% courseid %>}" samePage="true" [useOtherData]="['userid']">
 *     {{ 'plugin.mod_certificate_coursecertificate.viewissued' | translate }}
 * </button>
 */
var CoreSitePluginsNewContentDirective = /** @class */ (function () {
    function CoreSitePluginsNewContentDirective(element, utils, navCtrl, parentContent, domUtils, sitePluginsProvider) {
        this.utils = utils;
        this.navCtrl = navCtrl;
        this.parentContent = parentContent;
        this.domUtils = domUtils;
        this.sitePluginsProvider = sitePluginsProvider;
        this.element = element.nativeElement || element;
    }
    /**
     * Component being initialized.
     */
    CoreSitePluginsNewContentDirective.prototype.ngOnInit = function () {
        var _this = this;
        this.element.addEventListener('click', function (ev) {
            ev.preventDefault();
            ev.stopPropagation();
            var args = _this.args || {};
            if (_this.parentContent) {
                args = _this.sitePluginsProvider.loadOtherDataInArgs(_this.args, _this.parentContent.otherData, _this.useOtherData);
            }
            if (_this.form && document.forms[_this.form]) {
                args = Object.assign(args, _this.domUtils.getDataFromForm(document.forms[_this.form]));
            }
            if (_this.utils.isTrueOrOne(_this.samePage)) {
                // Update the parent content (if it exists).
                if (_this.parentContent) {
                    _this.parentContent.updateContent(_this.component, _this.method, args);
                }
            }
            else {
                _this.navCtrl.push('CoreSitePluginsPluginPage', {
                    title: _this.title,
                    component: _this.component,
                    method: _this.method,
                    args: args,
                    bootstrapResult: _this.parentContent && _this.parentContent.bootstrapResult
                });
            }
        });
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreSitePluginsNewContentDirective.prototype, "component", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreSitePluginsNewContentDirective.prototype, "method", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreSitePluginsNewContentDirective.prototype, "args", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreSitePluginsNewContentDirective.prototype, "title", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Object)
    ], CoreSitePluginsNewContentDirective.prototype, "samePage", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", Array)
    ], CoreSitePluginsNewContentDirective.prototype, "useOtherData", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["D" /* Input */])(),
        __metadata("design:type", String)
    ], CoreSitePluginsNewContentDirective.prototype, "form", void 0);
    CoreSitePluginsNewContentDirective = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["s" /* Directive */])({
            selector: '[core-site-plugins-new-content]'
        }),
        __param(2, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["N" /* Optional */])()),
        __param(3, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["N" /* Optional */])()),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["t" /* ElementRef */], __WEBPACK_IMPORTED_MODULE_3__providers_utils_utils__["a" /* CoreUtilsProvider */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavController */],
            __WEBPACK_IMPORTED_MODULE_5__components_plugin_content_plugin_content__["a" /* CoreSitePluginsPluginContentComponent */], __WEBPACK_IMPORTED_MODULE_2__providers_utils_dom__["a" /* CoreDomUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_siteplugins__["a" /* CoreSitePluginsProvider */]])
    ], CoreSitePluginsNewContentDirective);
    return CoreSitePluginsNewContentDirective;
}());

//# sourceMappingURL=new-content.js.map

/***/ }),
/* 1199 */,
/* 1200 */,
/* 1201 */,
/* 1202 */,
/* 1203 */,
/* 1204 */,
/* 1205 */,
/* 1206 */,
/* 1207 */,
/* 1208 */,
/* 1209 */,
/* 1210 */,
/* 1211 */,
/* 1212 */,
/* 1213 */,
/* 1214 */,
/* 1215 */,
/* 1216 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MoodleMobileApp; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_status_bar__ = __webpack_require__(620);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_splash_screen__ = __webpack_require__(619);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_events__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_login_providers_helper__ = __webpack_require__(51);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








var MoodleMobileApp = /** @class */ (function () {
    function MoodleMobileApp(platform, statusBar, splashScreen, logger, eventsProvider, loginHelper, appProvider) {
        this.platform = platform;
        this.eventsProvider = eventsProvider;
        this.loginHelper = loginHelper;
        this.appProvider = appProvider;
        // Use page name (string) because the page is lazy loaded (Ionic feature). That way we can load pages without importing them.
        // The downside is that each page needs to implement a ngModule.
        this.rootPage = 'CoreLoginInitPage';
        this.lastUrls = {};
        this.logger = logger.getInstance('AppComponent');
        platform.ready().then(function () {
            // Okay, so the platform is ready and our plugins are available.
            // Here you can do any higher level native things you might need.
            statusBar.styleDefault();
            splashScreen.hide();
        });
    }
    /**
     * Component being initialized.
     */
    MoodleMobileApp.prototype.ngOnInit = function () {
        var _this = this;
        // Go to sites page when user is logged out.
        this.eventsProvider.on(__WEBPACK_IMPORTED_MODULE_5__providers_events__["a" /* CoreEventsProvider */].LOGOUT, function () {
            _this.appProvider.getRootNavController().setRoot('CoreLoginSitesPage');
        });
        // Listen for session expired events.
        this.eventsProvider.on(__WEBPACK_IMPORTED_MODULE_5__providers_events__["a" /* CoreEventsProvider */].SESSION_EXPIRED, function (data) {
            _this.loginHelper.sessionExpired(data);
        });
        // Listen for passwordchange and usernotfullysetup events to open InAppBrowser.
        this.eventsProvider.on(__WEBPACK_IMPORTED_MODULE_5__providers_events__["a" /* CoreEventsProvider */].PASSWORD_CHANGE_FORCED, function (data) {
            _this.loginHelper.openInAppForEdit(data.siteId, '/login/change_password.php', 'core.forcepasswordchangenotice', true);
        });
        this.eventsProvider.on(__WEBPACK_IMPORTED_MODULE_5__providers_events__["a" /* CoreEventsProvider */].USER_NOT_FULLY_SETUP, function (data) {
            _this.loginHelper.openInAppForEdit(data.siteId, '/user/edit.php', 'core.usernotfullysetup');
        });
        // Listen for sitepolicynotagreed event to accept the site policy.
        this.eventsProvider.on(__WEBPACK_IMPORTED_MODULE_5__providers_events__["a" /* CoreEventsProvider */].SITE_POLICY_NOT_AGREED, function (data) {
            _this.loginHelper.sitePolicyNotAgreed(data.siteId);
        });
        // Check URLs loaded in any InAppBrowser.
        this.eventsProvider.on(__WEBPACK_IMPORTED_MODULE_5__providers_events__["a" /* CoreEventsProvider */].IAB_LOAD_START, function (event) {
            _this.loginHelper.inAppBrowserLoadStart(event.url);
        });
        // Check InAppBrowser closed.
        this.eventsProvider.on(__WEBPACK_IMPORTED_MODULE_5__providers_events__["a" /* CoreEventsProvider */].IAB_EXIT, function () {
            _this.loginHelper.waitingForBrowser = false;
            _this.loginHelper.lastInAppUrl = '';
            _this.loginHelper.checkLogout();
        });
        this.platform.resume.subscribe(function () {
            // Wait a second before setting it to false since in iOS there could be some frozen WS calls.
            setTimeout(function () {
                _this.loginHelper.waitingForBrowser = false;
                _this.loginHelper.checkLogout();
            }, 1000);
        });
        // Handle app launched with a certain URL (custom URL scheme).
        window.handleOpenURL = function (url) {
            // First check that the URL hasn't been treated a few seconds ago. Sometimes this function is called more than once.
            if (_this.lastUrls[url] && Date.now() - _this.lastUrls[url] < 3000) {
                // Function called more than once, stop.
                return;
            }
            _this.logger.debug('App launched by URL ', url);
            _this.lastUrls[url] = Date.now();
            _this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_5__providers_events__["a" /* CoreEventsProvider */].APP_LAUNCHED_URL, url);
        };
        // Listen for app launched URLs. If we receive one, check if it's a SSO authentication.
        this.eventsProvider.on(__WEBPACK_IMPORTED_MODULE_5__providers_events__["a" /* CoreEventsProvider */].APP_LAUNCHED_URL, function (url) {
            _this.loginHelper.appLaunchedByURL(url);
        });
    };
    MoodleMobileApp = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["m" /* Component */])({template:/*ion-inline-start:"/ionic-projects/moodlemobile2/src/app/app.html"*/'<ion-nav [root]="rootPage"></ion-nav>\n'/*ion-inline-end:"/ionic-projects/moodlemobile2/src/app/app.html"*/
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */], __WEBPACK_IMPORTED_MODULE_2__ionic_native_status_bar__["a" /* StatusBar */], __WEBPACK_IMPORTED_MODULE_3__ionic_native_splash_screen__["a" /* SplashScreen */], __WEBPACK_IMPORTED_MODULE_6__providers_logger__["a" /* CoreLoggerProvider */],
            __WEBPACK_IMPORTED_MODULE_5__providers_events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_7__core_login_providers_helper__["a" /* CoreLoginHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_app__["a" /* CoreAppProvider */]])
    ], MoodleMobileApp);
    return MoodleMobileApp;
}());

//# sourceMappingURL=app.component.js.map

/***/ }),
/* 1217 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreFileSessionProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__sites__ = __webpack_require__(3);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Helper to store some temporary data for file submission.
 *
 * It uses siteId and component name to index the files.
 * Every component can provide a File area identifier to indentify every file list on the session.
 * This value can be the activity id or a mix of name and numbers.
 */
var CoreFileSessionProvider = /** @class */ (function () {
    function CoreFileSessionProvider(sitesProvider) {
        this.sitesProvider = sitesProvider;
        this.files = {};
    }
    /**
     * Add a file to the session.
     *
     * @param {string} component Component Name.
     * @param {string|number} id File area identifier.
     * @param {any} file File to add.
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    CoreFileSessionProvider.prototype.addFile = function (component, id, file, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        this.initFileArea(component, id, siteId);
        this.files[siteId][component][id].push(file);
    };
    /**
     * Clear files stored in session.
     *
     * @param {string} component Component Name.
     * @param {string|number} id File area identifier.
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    CoreFileSessionProvider.prototype.clearFiles = function (component, id, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (this.files[siteId] && this.files[siteId][component] && this.files[siteId][component][id]) {
            this.files[siteId][component][id] = [];
        }
    };
    /**
     * Get files stored in session.
     *
     * @param {string} component Component Name.
     * @param {string|number} id File area identifier.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {any[]} Array of files in session.
     */
    CoreFileSessionProvider.prototype.getFiles = function (component, id, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (this.files[siteId] && this.files[siteId][component] && this.files[siteId][component][id]) {
            return this.files[siteId][component][id];
        }
        return [];
    };
    /**
     * Initializes the filearea to store the file.
     *
     * @param {string} component Component Name.
     * @param {string|number} id File area identifier.
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    CoreFileSessionProvider.prototype.initFileArea = function (component, id, siteId) {
        if (!this.files[siteId]) {
            this.files[siteId] = {};
        }
        if (!this.files[siteId][component]) {
            this.files[siteId][component] = {};
        }
        if (!this.files[siteId][component][id]) {
            this.files[siteId][component][id] = [];
        }
    };
    /**
     * Remove a file stored in session.
     *
     * @param {string} component Component Name.
     * @param {string|number} id File area identifier.
     * @param {any} file File to remove. The instance should be exactly the same as the one stored in session.
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    CoreFileSessionProvider.prototype.removeFile = function (component, id, file, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (this.files[siteId] && this.files[siteId][component] && this.files[siteId][component][id]) {
            var position = this.files[siteId][component][id].indexOf(file);
            if (position != -1) {
                this.files[siteId][component][id].splice(position, 1);
            }
        }
    };
    /**
     * Remove a file stored in session.
     *
     * @param {string} component Component Name.
     * @param {string|number} id File area identifier.
     * @param {number} index Position of the file to remove.
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    CoreFileSessionProvider.prototype.removeFileByIndex = function (component, id, index, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (this.files[siteId] && this.files[siteId][component] && this.files[siteId][component][id] && index >= 0 &&
            index < this.files[siteId][component][id].length) {
            this.files[siteId][component][id].splice(index, 1);
        }
    };
    /**
     * Set a group of files in the session.
     *
     * @param {string} component Component Name.
     * @param {string|number} id File area identifier.
     * @param {any[]} newFiles Files to set.
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    CoreFileSessionProvider.prototype.setFiles = function (component, id, newFiles, siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        this.initFileArea(component, id, siteId);
        this.files[siteId][component][id] = newFiles;
    };
    CoreFileSessionProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__sites__["a" /* CoreSitesProvider */]])
    ], CoreFileSessionProvider);
    return CoreFileSessionProvider;
}());

//# sourceMappingURL=file-session.js.map

/***/ }),
/* 1218 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreUpdateManagerProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__config__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__filepool__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__init__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__local_notifications__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__configconstants__ = __webpack_require__(50);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








/**
 * Factory to handle app updates. This factory shouldn't be used outside of core.
 *
 * This service handles processes that need to be run when updating the app, like migrate Ionic 1 database data to Ionic 3.
 */
var CoreUpdateManagerProvider = /** @class */ (function () {
    function CoreUpdateManagerProvider(logger, configProvider, sitesProvider, filepoolProvider, notifProvider) {
        this.configProvider = configProvider;
        this.sitesProvider = sitesProvider;
        this.filepoolProvider = filepoolProvider;
        this.notifProvider = notifProvider;
        // Data for init delegate.
        this.name = 'CoreUpdateManager';
        this.priority = __WEBPACK_IMPORTED_MODULE_3__init__["a" /* CoreInitDelegate */].MAX_RECOMMENDED_PRIORITY + 300;
        this.blocking = true;
        this.VERSION_APPLIED = 'version_applied';
        this.logger = logger.getInstance('CoreUpdateManagerProvider');
    }
    /**
     * Check if the app has been updated and performs the needed processes.
     * This function shouldn't be used outside of core.
     *
     * @return {Promise<any>} Promise resolved when the update process finishes.
     */
    CoreUpdateManagerProvider.prototype.load = function () {
        var _this = this;
        var promises = [], versionCode = __WEBPACK_IMPORTED_MODULE_7__configconstants__["a" /* CoreConfigConstants */].versioncode;
        return this.configProvider.get(this.VERSION_APPLIED, 0).then(function (versionApplied) {
            // @todo: Migrate all data from ydn-db to SQLite if there is no versionApplied.
            if (versionCode >= 2013 && versionApplied < 2013) {
                promises.push(_this.migrateFileExtensions());
            }
            if (versionCode >= 2017 && versionApplied < 2017) {
                promises.push(_this.setCalendarDefaultNotifTime());
                promises.push(_this.setSitesConfig());
            }
            if (versionCode >= 2018 && versionApplied < 2018) {
                promises.push(_this.adaptForumOfflineStores());
            }
            return Promise.all(promises).then(function () {
                return _this.configProvider.set(_this.VERSION_APPLIED, versionCode);
            }).catch(function (error) {
                _this.logger.error("Error applying update from " + versionApplied + " to " + versionCode, error);
            });
        });
    };
    /**
     * Migrates files filling extensions.
     *
     * @return {Promise<any>} Promise resolved when the site migration is finished.
     */
    CoreUpdateManagerProvider.prototype.migrateFileExtensions = function () {
        var _this = this;
        return this.sitesProvider.getSitesIds().then(function (sites) {
            var promises = [];
            sites.forEach(function (siteId) {
                promises.push(_this.filepoolProvider.fillMissingExtensionInFiles(siteId));
            });
            promises.push(_this.filepoolProvider.treatExtensionInQueue());
            return Promise.all(promises);
        });
    };
    /**
     * Calendar default notification time is configurable from version 3.2.1, and a new option "Default" is added.
     * All events that were configured to use the fixed default time should now be configured to use "Default" option.
     *
     * @return {Promise<any>} Promise resolved when the events are configured.
     */
    CoreUpdateManagerProvider.prototype.setCalendarDefaultNotifTime = function () {
        if (!this.notifProvider.isAvailable()) {
            // Local notifications not available, nothing to do.
            return Promise.resolve();
        }
        // @todo: Implement it once Calendar addon is implemented.
        return Promise.resolve();
    };
    /**
     * In version 3.2.1 we want the site config to be stored in each site if available.
     * Since it can be slow, we'll only block retrieving the config of current site, the rest will be in background.
     *
     * @return {Promise<any>} Promise resolved when the config is loaded for the current site (if any).
     */
    CoreUpdateManagerProvider.prototype.setSitesConfig = function () {
        var _this = this;
        return this.sitesProvider.getSitesIds().then(function (siteIds) {
            return _this.sitesProvider.getStoredCurrentSiteId().catch(function () {
                // Error getting current site.
            }).then(function (currentSiteId) {
                var promise;
                // Load the config of current site first.
                if (currentSiteId) {
                    promise = _this.setSiteConfig(currentSiteId);
                }
                else {
                    promise = Promise.resolve();
                }
                // Load the config of rest of sites in background.
                siteIds.forEach(function (siteId) {
                    if (siteId != currentSiteId) {
                        _this.setSiteConfig(siteId);
                    }
                });
                return promise;
            });
        });
    };
    /**
     * Store the config of a site.
     *
     * @param {String} siteId Site ID.
     * @return {Promise<any>} Promise resolved when the config is loaded for the site.
     */
    CoreUpdateManagerProvider.prototype.setSiteConfig = function (siteId) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            if (site.getStoredConfig() || !site.wsAvailable('tool_mobile_get_config')) {
                // Site already has the config or it cannot be retrieved. Stop.
                return;
            }
            // Get the site config.
            return site.getConfig().then(function (config) {
                return _this.sitesProvider.addSite(site.getId(), site.getURL(), site.getToken(), site.getInfo(), site.getPrivateToken(), config);
            }).catch(function () {
                // Ignore errors.
            });
        });
    };
    /**
     * The data stored for offline discussions and posts changed its format. Adapt the entries already stored.
     * Since it can be slow, we'll only block migrating the db of current site, the rest will be in background.
     *
     * @return {Promise<any>} Promise resolved when the db is migrated.
     */
    CoreUpdateManagerProvider.prototype.adaptForumOfflineStores = function () {
        // @todo: Implement it once Forum addon is implemented.
        return Promise.resolve();
    };
    CoreUpdateManagerProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_1__config__["a" /* CoreConfigProvider */], __WEBPACK_IMPORTED_MODULE_6__sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_2__filepool__["a" /* CoreFilepoolProvider */], __WEBPACK_IMPORTED_MODULE_4__local_notifications__["a" /* CoreLocalNotificationsProvider */]])
    ], CoreUpdateManagerProvider);
    return CoreUpdateManagerProvider;
}());

//# sourceMappingURL=update-manager.js.map

/***/ }),
/* 1219 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSettingsModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_delegate__ = __webpack_require__(298);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


var CoreSettingsModule = /** @class */ (function () {
    function CoreSettingsModule() {
    }
    CoreSettingsModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [],
            providers: [
                __WEBPACK_IMPORTED_MODULE_1__providers_delegate__["a" /* CoreSettingsDelegate */]
            ]
        })
    ], CoreSettingsModule);
    return CoreSettingsModule;
}());

//# sourceMappingURL=settings.module.js.map

/***/ }),
/* 1220 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export CORE_SITEPLUGINS_PROVIDERS */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSitePluginsModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_siteplugins__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_helper__ = __webpack_require__(1221);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__components_components_module__ = __webpack_require__(718);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




// List of providers.
var CORE_SITEPLUGINS_PROVIDERS = [
    __WEBPACK_IMPORTED_MODULE_1__providers_siteplugins__["a" /* CoreSitePluginsProvider */],
    __WEBPACK_IMPORTED_MODULE_2__providers_helper__["a" /* CoreSitePluginsHelperProvider */]
];
var CoreSitePluginsModule = /** @class */ (function () {
    function CoreSitePluginsModule(helper) {
        // Inject the helper even if it isn't used so it's instantiated.
    }
    CoreSitePluginsModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [
                __WEBPACK_IMPORTED_MODULE_3__components_components_module__["a" /* CoreSitePluginsComponentsModule */]
            ],
            providers: CORE_SITEPLUGINS_PROVIDERS
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_helper__["a" /* CoreSitePluginsHelperProvider */]])
    ], CoreSitePluginsModule);
    return CoreSitePluginsModule;
}());

//# sourceMappingURL=siteplugins.module.js.map

/***/ }),
/* 1221 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSitePluginsHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_events__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_lang__ = __webpack_require__(96);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_text__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__siteplugins__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__core_compile_providers_compile__ = __webpack_require__(249);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__core_mainmenu_providers_delegate__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__core_course_providers_module_delegate__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__core_course_providers_module_prefetch_delegate__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__core_course_providers_options_delegate__ = __webpack_require__(100);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__core_course_providers_format_delegate__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__core_user_providers_user_delegate__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__core_user_providers_user_profile_field_delegate__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__classes_course_format_handler__ = __webpack_require__(1222);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__classes_course_option_handler__ = __webpack_require__(1223);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__classes_module_handler__ = __webpack_require__(1224);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__classes_module_prefetch_handler__ = __webpack_require__(1225);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__classes_main_menu_handler__ = __webpack_require__(1226);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__classes_user_handler__ = __webpack_require__(1227);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__classes_user_profile_field_handler__ = __webpack_require__(1228);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};









// Delegates







// Handler classes.







/**
 * Helper service to provide functionalities regarding site plugins. It basically has the features to load and register site
 * plugin.
 *
 * This code is split from CoreSitePluginsProvider to prevent circular dependencies.
 *
 * @todo: Support ViewChild and similar in site plugins. Possible solution: make components and directives inject the instance
 * inside the host DOM element?
 */
var CoreSitePluginsHelperProvider = /** @class */ (function () {
    function CoreSitePluginsHelperProvider(logger, sitesProvider, injector, mainMenuDelegate, moduleDelegate, userDelegate, langProvider, sitePluginsProvider, prefetchDelegate, compileProvider, utils, courseOptionsDelegate, eventsProvider, courseFormatDelegate, profileFieldDelegate, textUtils) {
        var _this = this;
        this.sitesProvider = sitesProvider;
        this.injector = injector;
        this.mainMenuDelegate = mainMenuDelegate;
        this.moduleDelegate = moduleDelegate;
        this.userDelegate = userDelegate;
        this.langProvider = langProvider;
        this.sitePluginsProvider = sitePluginsProvider;
        this.prefetchDelegate = prefetchDelegate;
        this.compileProvider = compileProvider;
        this.utils = utils;
        this.courseOptionsDelegate = courseOptionsDelegate;
        this.courseFormatDelegate = courseFormatDelegate;
        this.profileFieldDelegate = profileFieldDelegate;
        this.textUtils = textUtils;
        this.logger = logger.getInstance('CoreSitePluginsHelperProvider');
        // Fetch the plugins on login.
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_1__providers_events__["a" /* CoreEventsProvider */].LOGIN, function () {
            var siteId = _this.sitesProvider.getCurrentSiteId();
            _this.fetchSitePlugins(siteId).then(function (plugins) {
                // Plugins fetched, check that site hasn't changed.
                if (siteId == _this.sitesProvider.getCurrentSiteId() && plugins.length) {
                    // Site is still the same. Load the plugins and trigger the event.
                    _this.loadSitePlugins(plugins).then(function () {
                        eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_1__providers_events__["a" /* CoreEventsProvider */].SITE_PLUGINS_LOADED, {}, siteId);
                    });
                }
            });
        });
        // Unload plugins on logout if any.
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_1__providers_events__["a" /* CoreEventsProvider */].LOGOUT, function () {
            if (_this.sitePluginsProvider.hasSitePluginsLoaded) {
                // Temporary fix. Reload the page to unload all plugins.
                window.location.reload();
            }
        });
    }
    /**
     * Bootstrap a handler if it has some bootstrap method.
     *
     * @param {any} plugin Data of the plugin.
     * @param {any} handlerSchema Data about the handler.
     * @return {Promise<any>} Promise resolved when done. It returns the results of the getContent call and the data returned by
     *                        the bootstrap JS (if any).
     */
    CoreSitePluginsHelperProvider.prototype.bootstrapHandler = function (plugin, handlerSchema) {
        if (!handlerSchema.bootstrap) {
            return Promise.resolve({});
        }
        return this.executeMethodAndJS(plugin, handlerSchema.bootstrap);
    };
    /**
     * Execute a get_content method and run its javascript (if any).
     *
     * @param {any} plugin Data of the plugin.
     * @param {string} method The method to call.
     * @return {Promise<any>} Promise resolved when done. It returns the results of the getContent call and the data returned by
     *                        the JS (if any).
     */
    CoreSitePluginsHelperProvider.prototype.executeMethodAndJS = function (plugin, method) {
        var _this = this;
        var siteId = this.sitesProvider.getCurrentSiteId(), preSets = { getFromCache: false }; // Try to ignore cache.
        return this.sitePluginsProvider.getContent(plugin.component, method, {}, preSets).then(function (result) {
            if (!result.javascript || _this.sitesProvider.getCurrentSiteId() != siteId) {
                // No javascript or site has changed, stop.
                return result;
            }
            // Create a "fake" instance to hold all the libraries.
            var instance = {};
            _this.compileProvider.injectLibraries(instance);
            // Add some data of the WS call result.
            var jsData = _this.sitePluginsProvider.createDataForJS(result);
            for (var name_1 in jsData) {
                instance[name_1] = jsData[name_1];
            }
            // Now execute the javascript using this instance.
            result.jsResult = _this.compileProvider.executeJavascript(instance, result.javascript);
            return result;
        });
    };
    /**
     * Fetch site plugins.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<any[]>} Promise resolved when done. Returns the list of plugins to load.
     */
    CoreSitePluginsHelperProvider.prototype.fetchSitePlugins = function (siteId) {
        var _this = this;
        var plugins = [];
        return this.sitesProvider.getSite(siteId).then(function (site) {
            if (!_this.sitePluginsProvider.isGetContentAvailable(site)) {
                // Cannot load site plugins, so there's no point to fetch them.
                return plugins;
            }
            // Get the list of plugins. Try not to use cache.
            return site.read('tool_mobile_get_plugins_supporting_mobile', {}, { getFromCache: false }).then(function (data) {
                data.plugins.forEach(function (plugin) {
                    // Check if it's a site plugin and it's enabled.
                    if (_this.isSitePluginEnabled(plugin, site)) {
                        plugins.push(plugin);
                    }
                });
                return plugins;
            });
        });
    };
    /**
     * Given an addon name, return the prefix to add to its string keys.
     *
     * @param {string} addon Name of the addon (plugin.addon).
     * @return {string} Prefix.
     */
    CoreSitePluginsHelperProvider.prototype.getPrefixForStrings = function (addon) {
        if (addon) {
            return 'plugin.' + addon + '.';
        }
        return '';
    };
    /**
     * Given an addon name and the key of a string, return the full string key (prefixed).
     *
     * @param {string} addon Name of the addon (plugin.addon).
     * @param {string} key The key of the string.
     * @return {string} Full string key.
     */
    CoreSitePluginsHelperProvider.prototype.getPrefixedString = function (addon, key) {
        return this.getPrefixForStrings(addon) + key;
    };
    /**
     * Check if a certain plugin is a site plugin and it's enabled in a certain site.
     *
     * @param {any} plugin Data of the plugin.
     * @param {CoreSite} site Site affected.
     * @return {boolean} Whether it's a site plugin and it's enabled.
     */
    CoreSitePluginsHelperProvider.prototype.isSitePluginEnabled = function (plugin, site) {
        if (!site.isFeatureDisabled('sitePlugin_' + plugin.component + '_' + plugin.addon) && plugin.handlers) {
            // Site plugin not disabled. Check if it has handlers.
            if (!plugin.parsedHandlers) {
                plugin.parsedHandlers = this.textUtils.parseJSON(plugin.handlers, null, this.logger.error.bind(this.logger, 'Error parsing site plugin handlers'));
            }
            return !!(plugin.parsedHandlers && Object.keys(plugin.parsedHandlers).length);
        }
        return false;
    };
    /**
     * Load the lang strings for a plugin.
     *
     * @param {any} plugin Data of the plugin.
     */
    CoreSitePluginsHelperProvider.prototype.loadLangStrings = function (plugin) {
        if (!plugin.parsedLang) {
            return;
        }
        for (var lang in plugin.parsedLang) {
            var prefix = this.getPrefixForStrings(plugin.addon);
            this.langProvider.addSitePluginsStrings(lang, plugin.parsedLang[lang], prefix);
        }
    };
    /**
     * Load a site plugin.
     *
     * @param {any} plugin Data of the plugin.
     * @return {Promise<any>} Promise resolved when loaded.
     */
    CoreSitePluginsHelperProvider.prototype.loadSitePlugin = function (plugin) {
        var promises = [];
        this.logger.debug('Load site plugin:', plugin);
        if (!plugin.parsedHandlers) {
            plugin.parsedHandlers = this.textUtils.parseJSON(plugin.handlers, null, this.logger.error.bind(this.logger, 'Error parsing site plugin handlers'));
        }
        if (!plugin.parsedLang && plugin.lang) {
            plugin.parsedLang = this.textUtils.parseJSON(plugin.lang, null, this.logger.error.bind(this.logger, 'Error parsing site plugin lang'));
        }
        this.sitePluginsProvider.hasSitePluginsLoaded = true;
        // Register lang strings.
        this.loadLangStrings(plugin);
        // Register all the handlers.
        for (var name_2 in plugin.parsedHandlers) {
            promises.push(this.registerHandler(plugin, name_2, plugin.parsedHandlers[name_2]));
        }
        return this.utils.allPromises(promises);
    };
    /**
     * Load site plugins.
     *
     * @param {any[]} plugins The plugins to load.
     * @return {Promise<any>} Promise resolved when loaded.
     */
    CoreSitePluginsHelperProvider.prototype.loadSitePlugins = function (plugins) {
        var _this = this;
        var promises = [];
        plugins.forEach(function (plugin) {
            promises.push(_this.loadSitePlugin(plugin));
        });
        return this.utils.allPromises(promises);
    };
    /**
     * Register a site plugin handler in the right delegate.
     *
     * @param {any} plugin Data of the plugin.
     * @param {string} handlerName Name of the handler in the plugin.
     * @param {any} handlerSchema Data about the handler.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreSitePluginsHelperProvider.prototype.registerHandler = function (plugin, handlerName, handlerSchema) {
        var _this = this;
        // Wait for the bootstrap JS to be executed.
        return this.bootstrapHandler(plugin, handlerSchema).then(function (result) {
            var promise;
            switch (handlerSchema.delegate) {
                case 'CoreMainMenuDelegate':
                    promise = Promise.resolve(_this.registerMainMenuHandler(plugin, handlerName, handlerSchema, result));
                    break;
                case 'CoreCourseModuleDelegate':
                    promise = Promise.resolve(_this.registerModuleHandler(plugin, handlerName, handlerSchema, result));
                    break;
                case 'CoreUserDelegate':
                    promise = Promise.resolve(_this.registerUserProfileHandler(plugin, handlerName, handlerSchema, result));
                    break;
                case 'CoreCourseOptionsDelegate':
                    promise = Promise.resolve(_this.registerCourseOptionHandler(plugin, handlerName, handlerSchema, result));
                    break;
                case 'CoreCourseFormatDelegate':
                    promise = Promise.resolve(_this.registerCourseFormatHandler(plugin, handlerName, handlerSchema, result));
                    break;
                case 'CoreUserProfileFieldDelegate':
                    promise = Promise.resolve(_this.registerUserProfileFieldHandler(plugin, handlerName, handlerSchema, result));
                    break;
                default:
                    // Nothing to do.
                    promise = Promise.resolve();
            }
            return promise.then(function (uniqueName) {
                if (uniqueName) {
                    // Store the handler data.
                    _this.sitePluginsProvider.setSitePluginHandler(uniqueName, {
                        plugin: plugin,
                        handlerName: handlerName,
                        handlerSchema: handlerSchema,
                        bootstrapResult: result
                    });
                }
            });
        }).catch(function (err) {
            _this.logger.error('Error executing bootstrap method', handlerSchema.bootstrap, err);
        });
    };
    /**
     * Given a handler in a plugin, register it in the course format delegate.
     *
     * @param {any} plugin Data of the plugin.
     * @param {string} handlerName Name of the handler in the plugin.
     * @param {any} handlerSchema Data about the handler.
     * @param {any} bootstrapResult Result of the bootstrap WS call.
     * @return {string} A string to identify the handler.
     */
    CoreSitePluginsHelperProvider.prototype.registerCourseFormatHandler = function (plugin, handlerName, handlerSchema, bootstrapResult) {
        this.logger.debug('Register site plugin in course format delegate:', plugin, handlerSchema, bootstrapResult);
        // Create and register the handler.
        var formatName = plugin.component.replace('format_', '');
        this.courseFormatDelegate.registerHandler(new __WEBPACK_IMPORTED_MODULE_16__classes_course_format_handler__["a" /* CoreSitePluginsCourseFormatHandler */](formatName, handlerSchema));
        return formatName;
    };
    /**
     * Given a handler in an plugin, register it in the course options delegate.
     *
     * @param {any} plugin Data of the plugin.
     * @param {string} handlerName Name of the handler in the plugin.
     * @param {any} handlerSchema Data about the handler.
     * @param {any} bootstrapResult Result of the bootstrap WS call.
     * @return {string} A string to identify the handler.
     */
    CoreSitePluginsHelperProvider.prototype.registerCourseOptionHandler = function (plugin, handlerName, handlerSchema, bootstrapResult) {
        if (!handlerSchema.displaydata) {
            // Required data not provided, stop.
            this.logger.warn('Ignore site plugin because it doesn\'t provide displaydata', plugin, handlerSchema);
            return;
        }
        this.logger.debug('Register site plugin in course option delegate:', plugin, handlerSchema, bootstrapResult);
        // Create and register the handler.
        var uniqueName = this.sitePluginsProvider.getHandlerUniqueName(plugin, handlerName), prefixedTitle = this.getPrefixedString(plugin.addon, handlerSchema.displaydata.title);
        this.courseOptionsDelegate.registerHandler(new __WEBPACK_IMPORTED_MODULE_17__classes_course_option_handler__["a" /* CoreSitePluginsCourseOptionHandler */](uniqueName, prefixedTitle, plugin, handlerSchema, bootstrapResult, this.sitePluginsProvider));
        return uniqueName;
    };
    /**
     * Given a handler in an plugin, register it in the main menu delegate.
     *
     * @param {any} plugin Data of the plugin.
     * @param {string} handlerName Name of the handler in the plugin.
     * @param {any} handlerSchema Data about the handler.
     * @param {any} bootstrapResult Result of the bootstrap WS call.
     * @return {string} A string to identify the handler.
     */
    CoreSitePluginsHelperProvider.prototype.registerMainMenuHandler = function (plugin, handlerName, handlerSchema, bootstrapResult) {
        if (!handlerSchema.displaydata) {
            // Required data not provided, stop.
            this.logger.warn('Ignore site plugin because it doesn\'t provide displaydata', plugin, handlerSchema);
            return;
        }
        this.logger.debug('Register site plugin in main menu delegate:', plugin, handlerSchema, bootstrapResult);
        // Create and register the handler.
        var uniqueName = this.sitePluginsProvider.getHandlerUniqueName(plugin, handlerName), prefixedTitle = this.getPrefixedString(plugin.addon, handlerSchema.displaydata.title);
        this.mainMenuDelegate.registerHandler(new __WEBPACK_IMPORTED_MODULE_20__classes_main_menu_handler__["a" /* CoreSitePluginsMainMenuHandler */](uniqueName, prefixedTitle, plugin, handlerSchema, bootstrapResult));
        return uniqueName;
    };
    /**
     * Given a handler in an plugin, register it in the module delegate.
     *
     * @param {any} plugin Data of the plugin.
     * @param {string} handlerName Name of the handler in the plugin.
     * @param {any} handlerSchema Data about the handler.
     * @param {any} bootstrapResult Result of the bootstrap WS call.
     * @return {string} A string to identify the handler.
     */
    CoreSitePluginsHelperProvider.prototype.registerModuleHandler = function (plugin, handlerName, handlerSchema, bootstrapResult) {
        if (!handlerSchema.displaydata) {
            // Required data not provided, stop.
            this.logger.warn('Ignore site plugin because it doesn\'t provide displaydata', plugin, handlerSchema);
            return;
        }
        this.logger.debug('Register site plugin in module delegate:', plugin, handlerSchema, bootstrapResult);
        // Create and register the handler.
        var modName = plugin.component.replace('mod_', '');
        this.moduleDelegate.registerHandler(new __WEBPACK_IMPORTED_MODULE_18__classes_module_handler__["a" /* CoreSitePluginsModuleHandler */](modName, handlerSchema));
        if (handlerSchema.offlinefunctions && Object.keys(handlerSchema.offlinefunctions).length) {
            // Register the prefetch handler.
            this.prefetchDelegate.registerHandler(new __WEBPACK_IMPORTED_MODULE_19__classes_module_prefetch_handler__["a" /* CoreSitePluginsModulePrefetchHandler */](this.injector, this.sitePluginsProvider, plugin.component, modName, handlerSchema));
        }
        return modName;
    };
    /**
     * Given a handler in an plugin, register it in the user profile delegate.
     *
     * @param {any} plugin Data of the plugin.
     * @param {string} handlerName Name of the handler in the plugin.
     * @param {any} handlerSchema Data about the handler.
     * @param {any} bootstrapResult Result of the bootstrap WS call.
     * @return {string} A string to identify the handler.
     */
    CoreSitePluginsHelperProvider.prototype.registerUserProfileHandler = function (plugin, handlerName, handlerSchema, bootstrapResult) {
        if (!handlerSchema.displaydata) {
            // Required data not provided, stop.
            this.logger.warn('Ignore site plugin because it doesn\'t provide displaydata', plugin, handlerSchema);
            return;
        }
        this.logger.debug('Register site plugin in user profile delegate:', plugin, handlerSchema, bootstrapResult);
        // Create and register the handler.
        var uniqueName = this.sitePluginsProvider.getHandlerUniqueName(plugin, handlerName), prefixedTitle = this.getPrefixedString(plugin.addon, handlerSchema.displaydata.title);
        this.userDelegate.registerHandler(new __WEBPACK_IMPORTED_MODULE_21__classes_user_handler__["a" /* CoreSitePluginsUserProfileHandler */](uniqueName, prefixedTitle, plugin, handlerSchema, bootstrapResult, this.sitePluginsProvider));
        return uniqueName;
    };
    /**
     * Given a handler in an plugin, register it in the user profile field delegate.
     *
     * @param {any} plugin Data of the plugin.
     * @param {string} handlerName Name of the handler in the plugin.
     * @param {any} handlerSchema Data about the handler.
     * @param {any} bootstrapResult Result of the bootstrap WS call.
     * @return {string|Promise<string>} A string (or a promise resolved with a string) to identify the handler.
     */
    CoreSitePluginsHelperProvider.prototype.registerUserProfileFieldHandler = function (plugin, handlerName, handlerSchema, bootstrapResult) {
        var _this = this;
        if (!handlerSchema.method) {
            // Required data not provided, stop.
            this.logger.warn('Ignore site plugin because it doesn\'t provide method', plugin, handlerSchema);
            return;
        }
        this.logger.debug('Register site plugin in user profile field delegate:', plugin, handlerSchema, bootstrapResult);
        // Execute the main method and its JS. The template returned will be used in the profile field component.
        return this.executeMethodAndJS(plugin, handlerSchema.method).then(function (result) {
            // Create and register the handler.
            var fieldType = plugin.component.replace('profilefield_', ''), fieldHandler = new __WEBPACK_IMPORTED_MODULE_22__classes_user_profile_field_handler__["a" /* CoreSitePluginsUserProfileFieldHandler */](fieldType);
            // Store in handlerSchema some data required by the component.
            handlerSchema.methodTemplates = result.templates;
            handlerSchema.methodJSResult = result.jsResult;
            if (result && result.jsResult) {
                // Override default handler functions with the result of the method JS.
                for (var property in fieldHandler) {
                    if (property != 'constructor' && typeof fieldHandler[property] == 'function' &&
                        typeof result.jsResult[property] == 'function') {
                        fieldHandler[property] = result.jsResult[property].bind(fieldHandler);
                    }
                }
            }
            _this.profileFieldDelegate.registerHandler(fieldHandler);
            return fieldType;
        }).catch(function (err) {
            _this.logger.error('Error executing main method', handlerSchema.method, err);
        });
    };
    CoreSitePluginsHelperProvider = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["C" /* Injector */],
            __WEBPACK_IMPORTED_MODULE_9__core_mainmenu_providers_delegate__["a" /* CoreMainMenuDelegate */], __WEBPACK_IMPORTED_MODULE_10__core_course_providers_module_delegate__["a" /* CoreCourseModuleDelegate */],
            __WEBPACK_IMPORTED_MODULE_14__core_user_providers_user_delegate__["a" /* CoreUserDelegate */], __WEBPACK_IMPORTED_MODULE_2__providers_lang__["a" /* CoreLangProvider */],
            __WEBPACK_IMPORTED_MODULE_7__siteplugins__["a" /* CoreSitePluginsProvider */], __WEBPACK_IMPORTED_MODULE_11__core_course_providers_module_prefetch_delegate__["a" /* CoreCourseModulePrefetchDelegate */],
            __WEBPACK_IMPORTED_MODULE_8__core_compile_providers_compile__["a" /* CoreCompileProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_12__core_course_providers_options_delegate__["a" /* CoreCourseOptionsDelegate */], __WEBPACK_IMPORTED_MODULE_1__providers_events__["a" /* CoreEventsProvider */],
            __WEBPACK_IMPORTED_MODULE_13__core_course_providers_format_delegate__["a" /* CoreCourseFormatDelegate */], __WEBPACK_IMPORTED_MODULE_15__core_user_providers_user_profile_field_delegate__["a" /* CoreUserProfileFieldDelegate */],
            __WEBPACK_IMPORTED_MODULE_5__providers_utils_text__["a" /* CoreTextUtilsProvider */]])
    ], CoreSitePluginsHelperProvider);
    return CoreSitePluginsHelperProvider;
}());

//# sourceMappingURL=helper.js.map

/***/ }),
/* 1222 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSitePluginsCourseFormatHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__base_handler__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_course_format_course_format__ = __webpack_require__(260);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


/**
 * Handler to support a course format using a site plugin.
 */
var CoreSitePluginsCourseFormatHandler = /** @class */ (function (_super) {
    __extends(CoreSitePluginsCourseFormatHandler, _super);
    function CoreSitePluginsCourseFormatHandler(name, handlerSchema) {
        var _this = _super.call(this, name) || this;
        _this.handlerSchema = handlerSchema;
        return _this;
    }
    /**
     * Whether it allows seeing all sections at the same time. Defaults to true.
     *
     * @param {any} course The course to check.
     * @type {boolean} Whether it can view all sections.
     */
    CoreSitePluginsCourseFormatHandler.prototype.canViewAllSections = function (course) {
        return typeof this.handlerSchema.canviewallsections != 'undefined' ? this.handlerSchema.canviewallsections : true;
    };
    /**
     * Whether the option to enable section/module download should be displayed. Defaults to true.
     *
     * @param {any} course The course to check.
     * @type {boolean} Whether the option to enable section/module download should be displayed.
     */
    CoreSitePluginsCourseFormatHandler.prototype.displayEnableDownload = function (course) {
        return typeof this.handlerSchema.displayenabledownload != 'undefined' ? this.handlerSchema.displayenabledownload : true;
    };
    /**
     * Whether the default section selector should be displayed. Defaults to true.
     *
     * @param {any} course The course to check.
     * @type {boolean} Whether the default section selector should be displayed.
     */
    CoreSitePluginsCourseFormatHandler.prototype.displaySectionSelector = function (course) {
        return typeof this.handlerSchema.displaysectionselector != 'undefined' ? this.handlerSchema.displaysectionselector : true;
    };
    /**
     * Return the Component to use to display the course format instead of using the default one.
     * Use it if you want to display a format completely different from the default one.
     * If you want to customize the default format there are several methods to customize parts of it.
     * It's recommended to return the class of the component, but you can also return an instance of the component.
     *
     * @param {Injector} injector Injector.
     * @param {any} course The course to render.
     * @return {any|Promise<any>} The component (or promise resolved with component) to use, undefined if not found.
     */
    CoreSitePluginsCourseFormatHandler.prototype.getCourseFormatComponent = function (injector, course) {
        if (this.handlerSchema.method) {
            return __WEBPACK_IMPORTED_MODULE_1__components_course_format_course_format__["a" /* CoreSitePluginsCourseFormatComponent */];
        }
    };
    return CoreSitePluginsCourseFormatHandler;
}(__WEBPACK_IMPORTED_MODULE_0__base_handler__["a" /* CoreSitePluginsBaseHandler */]));

//# sourceMappingURL=course-format-handler.js.map

/***/ }),
/* 1223 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSitePluginsCourseOptionHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__base_handler__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_course_option_course_option__ = __webpack_require__(259);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


/**
 * Handler to display a site plugin in course options.
 */
var CoreSitePluginsCourseOptionHandler = /** @class */ (function (_super) {
    __extends(CoreSitePluginsCourseOptionHandler, _super);
    function CoreSitePluginsCourseOptionHandler(name, title, plugin, handlerSchema, bootstrapResult, sitePluginsProvider) {
        var _this = _super.call(this, name) || this;
        _this.title = title;
        _this.plugin = plugin;
        _this.handlerSchema = handlerSchema;
        _this.bootstrapResult = bootstrapResult;
        _this.sitePluginsProvider = sitePluginsProvider;
        _this.priority = handlerSchema.priority;
        return _this;
    }
    /**
     * Whether or not the handler is enabled for a certain course.
     *
     * @param {number} courseId The course ID.
     * @param {any} accessData Access type and data. Default, guest, ...
     * @param {any} [navOptions] Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.
     * @param {any} [admOptions] Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.
     * @return {boolean|Promise<boolean>} True or promise resolved with true if enabled.
     */
    CoreSitePluginsCourseOptionHandler.prototype.isEnabledForCourse = function (courseId, accessData, navOptions, admOptions) {
        return this.sitePluginsProvider.isHandlerEnabledForCourse(courseId, this.handlerSchema.restricttoenrolledcourses, this.bootstrapResult.restrict);
    };
    /**
     * Returns the data needed to render the handler.
     *
     * @param {Injector} injector Injector.
     * @param {number} courseId The course ID.
     * @return {CoreCourseOptionsHandlerData|Promise<CoreCourseOptionsHandlerData>} Data or promise resolved with the data.
     */
    CoreSitePluginsCourseOptionHandler.prototype.getDisplayData = function (injector, courseId) {
        return {
            title: this.title,
            class: this.handlerSchema.displaydata.class,
            component: __WEBPACK_IMPORTED_MODULE_1__components_course_option_course_option__["a" /* CoreSitePluginsCourseOptionComponent */],
            componentData: {
                handlerUniqueName: this.name
            }
        };
    };
    /**
     * Called when a course is downloaded. It should prefetch all the data to be able to see the plugin in offline.
     *
     * @param {any} course The course.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreSitePluginsCourseOptionHandler.prototype.prefetch = function (course) {
        var args = {
            courseid: course.id,
        }, component = this.plugin.component;
        return this.sitePluginsProvider.prefetchFunctions(component, args, this.handlerSchema, course.id, undefined, true);
    };
    return CoreSitePluginsCourseOptionHandler;
}(__WEBPACK_IMPORTED_MODULE_0__base_handler__["a" /* CoreSitePluginsBaseHandler */]));

//# sourceMappingURL=course-option-handler.js.map

/***/ }),
/* 1224 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSitePluginsModuleHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__base_handler__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_module_index_module_index__ = __webpack_require__(181);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


/**
 * Handler to support a module using a site plugin.
 */
var CoreSitePluginsModuleHandler = /** @class */ (function (_super) {
    __extends(CoreSitePluginsModuleHandler, _super);
    function CoreSitePluginsModuleHandler(name, handlerSchema) {
        var _this = _super.call(this, name) || this;
        _this.handlerSchema = handlerSchema;
        return _this;
    }
    /**
     * Get the data required to display the module in the course contents view.
     *
     * @param {any} module The module object.
     * @param {number} courseId The course ID.
     * @param {number} sectionId The section ID.
     * @return {CoreCourseModuleHandlerData} Data to render the module.
     */
    CoreSitePluginsModuleHandler.prototype.getData = function (module, courseId, sectionId) {
        var hasOffline = !!(this.handlerSchema.offlinefunctions && Object.keys(this.handlerSchema.offlinefunctions).length), showDowloadButton = this.handlerSchema.downloadbutton;
        return {
            title: module.name,
            icon: this.handlerSchema.displaydata.icon,
            class: this.handlerSchema.displaydata.class,
            showDownloadButton: typeof showDowloadButton != 'undefined' ? showDowloadButton : hasOffline,
            action: function (event, navCtrl, module, courseId, options) {
                event.preventDefault();
                event.stopPropagation();
                navCtrl.push('CoreSitePluginsModuleIndexPage', {
                    title: module.name,
                    module: module,
                    courseId: courseId
                }, options);
            }
        };
    };
    /**
     * Get the component to render the module. This is needed to support singleactivity course format.
     * The component returned must implement CoreCourseModuleMainComponent.
     * It's recommended to return the class of the component, but you can also return an instance of the component.
     *
     * @param {Injector} injector Injector.
     * @param {any} course The course object.
     * @param {any} module The module object.
     * @return {any|Promise<any>} The component (or promise resolved with component) to use, undefined if not found.
     */
    CoreSitePluginsModuleHandler.prototype.getMainComponent = function (injector, course, module) {
        return __WEBPACK_IMPORTED_MODULE_1__components_module_index_module_index__["a" /* CoreSitePluginsModuleIndexComponent */];
    };
    return CoreSitePluginsModuleHandler;
}(__WEBPACK_IMPORTED_MODULE_0__base_handler__["a" /* CoreSitePluginsBaseHandler */]));

//# sourceMappingURL=module-handler.js.map

/***/ }),
/* 1225 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSitePluginsModulePrefetchHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_course_classes_module_prefetch_handler__ = __webpack_require__(106);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

/**
 * Handler to prefetch a module site plugin.
 */
var CoreSitePluginsModulePrefetchHandler = /** @class */ (function (_super) {
    __extends(CoreSitePluginsModulePrefetchHandler, _super);
    function CoreSitePluginsModulePrefetchHandler(injector, sitePluginsProvider, component, modName, handlerSchema) {
        var _this = _super.call(this, injector) || this;
        _this.sitePluginsProvider = sitePluginsProvider;
        _this.handlerSchema = handlerSchema;
        _this.ROOT_CACHE_KEY = 'CoreSitePluginsModulePrefetchHandler:';
        _this.component = component;
        _this.name = modName;
        _this.isResource = handlerSchema.isresource;
        if (handlerSchema.updatesnames) {
            try {
                _this.updatesNames = new RegExp(handlerSchema.updatesnames);
            }
            catch (ex) {
                // Ignore errors.
            }
        }
        return _this;
    }
    /**
     * Download or prefetch the content.
     *
     * @param {any} module The module object returned by WS.
     * @param {number} courseId Course ID.
     * @param {boolean} [prefetch] True to prefetch, false to download right away.
     * @param {string} [dirPath] Path of the directory where to store all the content files. This is to keep the files
     *                           relative paths and make the package work in an iframe. Undefined to download the files
     *                           in the filepool root folder.
     * @return {Promise<any>} Promise resolved when all content is downloaded. Data returned is not reliable.
     */
    CoreSitePluginsModulePrefetchHandler.prototype.downloadOrPrefetch = function (module, courseId, prefetch, dirPath) {
        return this.prefetchPackage(module, courseId, false, this.downloadPrefetchPlugin.bind(this), undefined, prefetch, dirPath);
    };
    /**
     * Download or prefetch the plugin, downloading the files and calling the needed WS.
     *
     * @param {any} module The module object returned by WS.
     * @param {number} courseId Course ID.
     * @param {boolean} [single] True if we're downloading a single module, false if we're downloading a whole section.
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {boolean} [prefetch] True to prefetch, false to download right away.
     * @param {string} [dirPath] Path of the directory where to store all the content files. @see downloadOrPrefetch.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreSitePluginsModulePrefetchHandler.prototype.downloadPrefetchPlugin = function (module, courseId, single, siteId, prefetch, dirPath) {
        var _this = this;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var promises = [], args = {
                courseid: courseId,
                cmid: module.id,
                userid: site.getUserId()
            };
            // Download the files (if any).
            promises.push(_this.downloadOrPrefetchFiles(site.id, module, courseId, prefetch, dirPath));
            // Call all the offline functions.
            promises.push(_this.sitePluginsProvider.prefetchFunctions(_this.component, args, _this.handlerSchema, courseId, module, prefetch, dirPath, site));
            return Promise.all(promises);
        });
    };
    /**
     * Download or prefetch the plugin files.
     *
     * @param {any} module The module object returned by WS.
     * @param {number} courseId Course ID.
     * @param {boolean} [prefetch] True to prefetch, false to download right away.
     * @param {string} [dirPath] Path of the directory where to store all the content files. @see downloadOrPrefetch.
     * @return {Promise<any>} Promise resolved when done.
     */
    CoreSitePluginsModulePrefetchHandler.prototype.downloadOrPrefetchFiles = function (siteId, module, courseId, prefetch, dirPath) {
        var _this = this;
        // Load module contents (ignore cache so we always have the latest data).
        return this.loadContents(module, courseId, true).then(function () {
            // Get the intro files.
            return _this.getIntroFiles(module, courseId);
        }).then(function (introFiles) {
            var contentFiles = _this.getContentDownloadableFiles(module), promises = [];
            if (dirPath) {
                // Download intro files in filepool root folder.
                promises.push(_this.filepoolProvider.downloadOrPrefetchFiles(siteId, introFiles, prefetch, false, _this.component, module.id));
                // Download content files inside dirPath.
                promises.push(_this.filepoolProvider.downloadOrPrefetchFiles(siteId, contentFiles, prefetch, false, _this.component, module.id, dirPath));
            }
            else {
                // No dirPath, download everything in filepool root folder.
                var files = introFiles.concat(contentFiles);
                promises.push(_this.filepoolProvider.downloadOrPrefetchFiles(siteId, files, prefetch, false, _this.component, module.id));
            }
            return Promise.all(promises);
        });
    };
    /**
     * Invalidate the prefetched content.
     *
     * @param {number} moduleId The module ID.
     * @param {number} courseId Course ID the module belongs to.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    CoreSitePluginsModulePrefetchHandler.prototype.invalidateContent = function (moduleId, courseId) {
        var promises = [], currentSite = this.sitesProvider.getCurrentSite(), siteId = currentSite.getId(), args = {
            courseid: courseId,
            cmid: moduleId,
            userid: currentSite.getUserId()
        };
        // Invalidate files and the module.
        promises.push(this.filepoolProvider.invalidateFilesByComponent(siteId, this.component, moduleId));
        promises.push(this.courseProvider.invalidateModule(moduleId, siteId));
        // Also invalidate all the WS calls.
        for (var method in this.handlerSchema.offlinefunctions) {
            if (currentSite.wsAvailable(method)) {
                // The method is a WS.
                promises.push(currentSite.invalidateWsCacheForKey(this.sitePluginsProvider.getCallWSCacheKey(method, args)));
            }
            else {
                // It's a method to get content.
                promises.push(this.sitePluginsProvider.invalidateContent(this.component, method, args));
            }
        }
        return this.utils.allPromises(promises);
    };
    /**
     * Whether or not the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} A boolean, or a promise resolved with a boolean, indicating if the handler is enabled.
     */
    CoreSitePluginsModulePrefetchHandler.prototype.isEnabled = function () {
        return true;
    };
    return CoreSitePluginsModulePrefetchHandler;
}(__WEBPACK_IMPORTED_MODULE_0__core_course_classes_module_prefetch_handler__["a" /* CoreCourseModulePrefetchHandlerBase */]));

//# sourceMappingURL=module-prefetch-handler.js.map

/***/ }),
/* 1226 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSitePluginsMainMenuHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__base_handler__ = __webpack_require__(111);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

/**
 * Handler to display a site plugin in the main menu.
 */
var CoreSitePluginsMainMenuHandler = /** @class */ (function (_super) {
    __extends(CoreSitePluginsMainMenuHandler, _super);
    function CoreSitePluginsMainMenuHandler(name, title, plugin, handlerSchema, bootstrapResult) {
        var _this = _super.call(this, name) || this;
        _this.title = title;
        _this.plugin = plugin;
        _this.handlerSchema = handlerSchema;
        _this.bootstrapResult = bootstrapResult;
        _this.priority = handlerSchema.priority;
        return _this;
    }
    /**
     * Returns the data needed to render the handler.
     *
     * @return {CoreMainMenuHandlerData} Data.
     */
    CoreSitePluginsMainMenuHandler.prototype.getDisplayData = function () {
        return {
            title: this.title,
            icon: this.handlerSchema.displaydata.icon,
            class: this.handlerSchema.displaydata.class,
            page: 'CoreSitePluginsPluginPage',
            pageParams: {
                title: this.title,
                component: this.plugin.component,
                method: this.handlerSchema.method,
                bootstrapResult: this.bootstrapResult
            }
        };
    };
    return CoreSitePluginsMainMenuHandler;
}(__WEBPACK_IMPORTED_MODULE_0__base_handler__["a" /* CoreSitePluginsBaseHandler */]));

//# sourceMappingURL=main-menu-handler.js.map

/***/ }),
/* 1227 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSitePluginsUserProfileHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_user_providers_user_delegate__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__base_handler__ = __webpack_require__(111);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


/**
 * Handler to display a site plugin in the user profile.
 */
var CoreSitePluginsUserProfileHandler = /** @class */ (function (_super) {
    __extends(CoreSitePluginsUserProfileHandler, _super);
    function CoreSitePluginsUserProfileHandler(name, title, plugin, handlerSchema, bootstrapResult, sitePluginsProvider) {
        var _this = _super.call(this, name) || this;
        _this.title = title;
        _this.plugin = plugin;
        _this.handlerSchema = handlerSchema;
        _this.bootstrapResult = bootstrapResult;
        _this.sitePluginsProvider = sitePluginsProvider;
        _this.priority = handlerSchema.priority;
        // Only support TYPE_COMMUNICATION and TYPE_NEW_PAGE.
        _this.type = handlerSchema.type != __WEBPACK_IMPORTED_MODULE_0__core_user_providers_user_delegate__["a" /* CoreUserDelegate */].TYPE_COMMUNICATION ?
            __WEBPACK_IMPORTED_MODULE_0__core_user_providers_user_delegate__["a" /* CoreUserDelegate */].TYPE_NEW_PAGE : __WEBPACK_IMPORTED_MODULE_0__core_user_providers_user_delegate__["a" /* CoreUserDelegate */].TYPE_COMMUNICATION;
        return _this;
    }
    /**
     * Whether or not the handler is enabled for a user.
     * @param  {any}     user       User object.
     * @param  {number}  courseId   Course ID where to show.
     * @param  {any}     [navOptions] Navigation options for the course.
     * @param  {any}     [admOptions] Admin options for the course.
     * @return {boolean|Promise<boolean>}            Whether or not the handler is enabled for a user.
     */
    CoreSitePluginsUserProfileHandler.prototype.isEnabledForUser = function (user, courseId, navOptions, admOptions) {
        // First check if it's enabled for the user.
        var enabledForUser = this.sitePluginsProvider.isHandlerEnabledForUser(user.id, this.handlerSchema.restricttocurrentuser, this.bootstrapResult.restrict);
        if (!enabledForUser) {
            return false;
        }
        // Enabled for user, check if it's enabled for the course.
        return this.sitePluginsProvider.isHandlerEnabledForCourse(courseId, this.handlerSchema.restricttoenrolledcourses, this.bootstrapResult.restrict);
    };
    /**
     * Returns the data needed to render the handler.
     * @param  {any}     user       User object.
     * @param  {number}  courseId   Course ID where to show.
     * @return {CoreUserProfileHandlerData}    Data to be shown.
     */
    CoreSitePluginsUserProfileHandler.prototype.getDisplayData = function (user, courseId) {
        var _this = this;
        return {
            title: this.title,
            icon: this.handlerSchema.displaydata.icon,
            class: this.handlerSchema.displaydata.class,
            action: function (event, navCtrl, user, courseId) {
                event.preventDefault();
                event.stopPropagation();
                navCtrl.push('CoreSitePluginsPluginPage', {
                    title: _this.title,
                    component: _this.plugin.component,
                    method: _this.handlerSchema.method,
                    args: {
                        courseid: courseId,
                        userid: user.id
                    },
                    bootstrapResult: _this.bootstrapResult
                });
            }
        };
    };
    return CoreSitePluginsUserProfileHandler;
}(__WEBPACK_IMPORTED_MODULE_1__base_handler__["a" /* CoreSitePluginsBaseHandler */]));

//# sourceMappingURL=user-handler.js.map

/***/ }),
/* 1228 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreSitePluginsUserProfileFieldHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__base_handler__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_user_profile_field_user_profile_field__ = __webpack_require__(656);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


/**
 * Handler to display a site plugin in the user profile.
 */
var CoreSitePluginsUserProfileFieldHandler = /** @class */ (function (_super) {
    __extends(CoreSitePluginsUserProfileFieldHandler, _super);
    function CoreSitePluginsUserProfileFieldHandler(name) {
        return _super.call(this, name) || this;
    }
    /**
     * Return the Component to use to display the user profile field.
     * It's recommended to return the class of the component, but you can also return an instance of the component.
     *
     * @param {Injector} injector Injector.
     * @return {any|Promise<any>} The component (or promise resolved with component) to use, undefined if not found.
     */
    CoreSitePluginsUserProfileFieldHandler.prototype.getComponent = function (injector) {
        return __WEBPACK_IMPORTED_MODULE_1__components_user_profile_field_user_profile_field__["a" /* CoreSitePluginsUserProfileFieldComponent */];
    };
    /**
     * Get the data to send for the field based on the input data.
     * @param  {any}     field          User field to get the data for.
     * @param  {boolean} signup         True if user is in signup page.
     * @param  {string}  [registerAuth] Register auth method. E.g. 'email'.
     * @param  {any}     formValues     Form Values.
     * @return {Promise<CoreUserProfileFieldHandlerData>|CoreUserProfileFieldHandlerData}  Data to send for the field.
     */
    CoreSitePluginsUserProfileFieldHandler.prototype.getData = function (field, signup, registerAuth, formValues) {
        // No getData function implemented, use a default behaviour.
        var name = 'profile_field_' + field.shortname;
        return {
            type: field.type || field.datatype,
            name: name,
            value: formValues[name]
        };
    };
    return CoreSitePluginsUserProfileFieldHandler;
}(__WEBPACK_IMPORTED_MODULE_0__base_handler__["a" /* CoreSitePluginsBaseHandler */]));

//# sourceMappingURL=user-profile-field-handler.js.map

/***/ }),
/* 1229 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreCompileModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_compile__ = __webpack_require__(249);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


var CoreCompileModule = /** @class */ (function () {
    function CoreCompileModule() {
    }
    CoreCompileModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [],
            providers: [
                __WEBPACK_IMPORTED_MODULE_1__providers_compile__["a" /* CoreCompileProvider */]
            ]
        })
    ], CoreCompileModule);
    return CoreCompileModule;
}());

//# sourceMappingURL=compile.module.js.map

/***/ }),
/* 1230 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonBadgesModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_badges__ = __webpack_require__(135);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_user_handler__ = __webpack_require__(1231);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_mybadges_link_handler__ = __webpack_require__(1232);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_badge_link_handler__ = __webpack_require__(1233);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__core_contentlinks_providers_delegate__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_user_providers_user_delegate__ = __webpack_require__(47);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};







var AddonBadgesModule = /** @class */ (function () {
    function AddonBadgesModule(userDelegate, userHandler, contentLinksDelegate, myBadgesLinkHandler, badgeLinkHandler) {
        userDelegate.registerHandler(userHandler);
        contentLinksDelegate.registerHandler(myBadgesLinkHandler);
        contentLinksDelegate.registerHandler(badgeLinkHandler);
    }
    AddonBadgesModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [],
            providers: [
                __WEBPACK_IMPORTED_MODULE_1__providers_badges__["a" /* AddonBadgesProvider */],
                __WEBPACK_IMPORTED_MODULE_2__providers_user_handler__["a" /* AddonBadgesUserHandler */],
                __WEBPACK_IMPORTED_MODULE_3__providers_mybadges_link_handler__["a" /* AddonBadgesMyBadgesLinkHandler */],
                __WEBPACK_IMPORTED_MODULE_4__providers_badge_link_handler__["a" /* AddonBadgesBadgeLinkHandler */]
            ]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__core_user_providers_user_delegate__["a" /* CoreUserDelegate */], __WEBPACK_IMPORTED_MODULE_2__providers_user_handler__["a" /* AddonBadgesUserHandler */],
            __WEBPACK_IMPORTED_MODULE_5__core_contentlinks_providers_delegate__["a" /* CoreContentLinksDelegate */], __WEBPACK_IMPORTED_MODULE_3__providers_mybadges_link_handler__["a" /* AddonBadgesMyBadgesLinkHandler */],
            __WEBPACK_IMPORTED_MODULE_4__providers_badge_link_handler__["a" /* AddonBadgesBadgeLinkHandler */]])
    ], AddonBadgesModule);
    return AddonBadgesModule;
}());

//# sourceMappingURL=badges.module.js.map

/***/ }),
/* 1231 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonBadgesUserHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_user_providers_user_delegate__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__badges__ = __webpack_require__(135);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Profile badges handler.
 */
var AddonBadgesUserHandler = /** @class */ (function () {
    function AddonBadgesUserHandler(badgesProvider) {
        this.badgesProvider = badgesProvider;
        this.name = 'mmaBadges';
        this.priority = 50;
        this.type = __WEBPACK_IMPORTED_MODULE_1__core_user_providers_user_delegate__["a" /* CoreUserDelegate */].TYPE_NEW_PAGE;
    }
    /**
     * Check if handler is enabled.
     *
     * @return {Promise<boolean>} Always enabled.
     */
    AddonBadgesUserHandler.prototype.isEnabled = function () {
        return this.badgesProvider.isPluginEnabled();
    };
    /**
     * Check if handler is enabled for this user in this context.
     *
     * @param {any} user     User to check.
     * @param {number} courseId Course ID.
     * @param  {any} [navOptions] Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.
     * @param  {any} [admOptions] Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.
     * @return  {boolean}   True if enabled, false otherwise.
     */
    AddonBadgesUserHandler.prototype.isEnabledForUser = function (user, courseId, navOptions, admOptions) {
        if (navOptions && typeof navOptions.badges != 'undefined') {
            return navOptions.badges;
        }
        // If we reach here, it means we are opening the user site profile.
        return true;
    };
    /**
     * Returns the data needed to render the handler.
     *
     * @return {CoreUserProfileHandlerData} Data needed to render the handler.
     */
    AddonBadgesUserHandler.prototype.getDisplayData = function (user, courseId) {
        return {
            icon: 'trophy',
            title: 'addon.badges.badges',
            class: '',
            action: function (event, navCtrl, user, courseId) {
                event.preventDefault();
                event.stopPropagation();
                navCtrl.push('AddonBadgesUserBadgesPage', { courseId: courseId, userId: user.id });
            }
        };
    };
    AddonBadgesUserHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__badges__["a" /* AddonBadgesProvider */]])
    ], AddonBadgesUserHandler);
    return AddonBadgesUserHandler;
}());

//# sourceMappingURL=user-handler.js.map

/***/ }),
/* 1232 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonBadgesMyBadgesLinkHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_contentlinks_classes_base_handler__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_login_providers_helper__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__badges__ = __webpack_require__(135);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Handler to treat links to user participants page.
 */
var AddonBadgesMyBadgesLinkHandler = /** @class */ (function (_super) {
    __extends(AddonBadgesMyBadgesLinkHandler, _super);
    function AddonBadgesMyBadgesLinkHandler(badgesProvider, loginHelper) {
        var _this = _super.call(this) || this;
        _this.badgesProvider = badgesProvider;
        _this.loginHelper = loginHelper;
        _this.name = 'AddonBadgesMyBadgesLinkHandler';
        _this.featureName = '$mmUserDelegate_mmaBadges';
        _this.pattern = /\/badges\/mybadges\.php/;
        return _this;
    }
    /**
     * Get the list of actions for a link (url).
     *
     * @param {string[]} siteIds List of sites the URL belongs to.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {CoreContentLinksAction[]|Promise<CoreContentLinksAction[]>} List of (or promise resolved with list of) actions.
     */
    AddonBadgesMyBadgesLinkHandler.prototype.getActions = function (siteIds, url, params, courseId) {
        var _this = this;
        return [{
                action: function (siteId, navCtrl) {
                    // Always use redirect to make it the new history root (to avoid "loops" in history).
                    _this.loginHelper.redirect('AddonBadgesUserBadgesPage', {}, siteId);
                }
            }];
    };
    /**
     * Check if the handler is enabled for a certain site (site + user) and a URL.
     * If not defined, defaults to true.
     *
     * @param {string} siteId The site ID.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {boolean|Promise<boolean>} Whether the handler is enabled for the URL and site.
     */
    AddonBadgesMyBadgesLinkHandler.prototype.isEnabled = function (siteId, url, params, courseId) {
        return this.badgesProvider.isPluginEnabled(siteId);
    };
    AddonBadgesMyBadgesLinkHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__badges__["a" /* AddonBadgesProvider */], __WEBPACK_IMPORTED_MODULE_2__core_login_providers_helper__["a" /* CoreLoginHelperProvider */]])
    ], AddonBadgesMyBadgesLinkHandler);
    return AddonBadgesMyBadgesLinkHandler;
}(__WEBPACK_IMPORTED_MODULE_1__core_contentlinks_classes_base_handler__["a" /* CoreContentLinksHandlerBase */]));

//# sourceMappingURL=mybadges-link-handler.js.map

/***/ }),
/* 1233 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonBadgesBadgeLinkHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_contentlinks_classes_base_handler__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_login_providers_helper__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__badges__ = __webpack_require__(135);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Handler to treat links to user participants page.
 */
var AddonBadgesBadgeLinkHandler = /** @class */ (function (_super) {
    __extends(AddonBadgesBadgeLinkHandler, _super);
    function AddonBadgesBadgeLinkHandler(badgesProvider, loginHelper) {
        var _this = _super.call(this) || this;
        _this.badgesProvider = badgesProvider;
        _this.loginHelper = loginHelper;
        _this.name = 'AddonBadgesBadgeLinkHandler';
        _this.pattern = /\/badges\/badge\.php.*([\?\&]hash=)/;
        return _this;
    }
    /**
     * Get the list of actions for a link (url).
     *
     * @param {string[]} siteIds List of sites the URL belongs to.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {CoreContentLinksAction[]|Promise<CoreContentLinksAction[]>} List of (or promise resolved with list of) actions.
     */
    AddonBadgesBadgeLinkHandler.prototype.getActions = function (siteIds, url, params, courseId) {
        var _this = this;
        return [{
                action: function (siteId, navCtrl) {
                    // Always use redirect to make it the new history root (to avoid "loops" in history).
                    _this.loginHelper.redirect('AddonBadgesIssuedBadgePage', { courseId: 0, badgeHash: params.hash }, siteId);
                }
            }];
    };
    /**
     * Check if the handler is enabled for a certain site (site + user) and a URL.
     * If not defined, defaults to true.
     *
     * @param {string} siteId The site ID.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {boolean|Promise<boolean>} Whether the handler is enabled for the URL and site.
     */
    AddonBadgesBadgeLinkHandler.prototype.isEnabled = function (siteId, url, params, courseId) {
        return this.badgesProvider.isPluginEnabled(siteId);
    };
    AddonBadgesBadgeLinkHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__badges__["a" /* AddonBadgesProvider */], __WEBPACK_IMPORTED_MODULE_2__core_login_providers_helper__["a" /* CoreLoginHelperProvider */]])
    ], AddonBadgesBadgeLinkHandler);
    return AddonBadgesBadgeLinkHandler;
}(__WEBPACK_IMPORTED_MODULE_1__core_contentlinks_classes_base_handler__["a" /* CoreContentLinksHandlerBase */]));

//# sourceMappingURL=badge-link-handler.js.map

/***/ }),
/* 1234 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonCalendarModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_calendar__ = __webpack_require__(285);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_helper__ = __webpack_require__(714);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_mainmenu_handler__ = __webpack_require__(1235);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_mainmenu_providers_delegate__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_init__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_local_notifications__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_login_providers_helper__ = __webpack_require__(51);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








var AddonCalendarModule = /** @class */ (function () {
    function AddonCalendarModule(mainMenuDelegate, calendarHandler, initDelegate, calendarProvider, loginHelper, localNotificationsProvider) {
        mainMenuDelegate.registerHandler(calendarHandler);
        initDelegate.ready().then(function () {
            calendarProvider.scheduleAllSitesEventsNotifications();
        });
        localNotificationsProvider.registerClick(__WEBPACK_IMPORTED_MODULE_1__providers_calendar__["a" /* AddonCalendarProvider */].COMPONENT, function (data) {
            if (data.eventid) {
                initDelegate.ready().then(function () {
                    calendarProvider.isDisabled(data.siteId).then(function (disabled) {
                        if (disabled) {
                            // The calendar is disabled in the site, don't open it.
                            return;
                        }
                        loginHelper.redirect('AddonCalendarListPage', { eventid: data.eventid }, data.siteId);
                    });
                });
            }
        });
    }
    AddonCalendarModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [],
            providers: [
                __WEBPACK_IMPORTED_MODULE_1__providers_calendar__["a" /* AddonCalendarProvider */],
                __WEBPACK_IMPORTED_MODULE_2__providers_helper__["a" /* AddonCalendarHelperProvider */],
                __WEBPACK_IMPORTED_MODULE_3__providers_mainmenu_handler__["a" /* AddonCalendarMainMenuHandler */]
            ]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__core_mainmenu_providers_delegate__["a" /* CoreMainMenuDelegate */], __WEBPACK_IMPORTED_MODULE_3__providers_mainmenu_handler__["a" /* AddonCalendarMainMenuHandler */],
            __WEBPACK_IMPORTED_MODULE_5__providers_init__["a" /* CoreInitDelegate */], __WEBPACK_IMPORTED_MODULE_1__providers_calendar__["a" /* AddonCalendarProvider */], __WEBPACK_IMPORTED_MODULE_7__core_login_providers_helper__["a" /* CoreLoginHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_6__providers_local_notifications__["a" /* CoreLocalNotificationsProvider */]])
    ], AddonCalendarModule);
    return AddonCalendarModule;
}());

//# sourceMappingURL=calendar.module.js.map

/***/ }),
/* 1235 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonCalendarMainMenuHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__calendar__ = __webpack_require__(285);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Handler to inject an option into main menu.
 */
var AddonCalendarMainMenuHandler = /** @class */ (function () {
    function AddonCalendarMainMenuHandler(calendarProvider) {
        this.calendarProvider = calendarProvider;
        this.name = 'AddonCalendar';
        this.priority = 900;
    }
    /**
     * Check if the handler is enabled on a site level.
     *
     * @return {boolean} Whether or not the handler is enabled on a site level.
     */
    AddonCalendarMainMenuHandler.prototype.isEnabled = function () {
        return !this.calendarProvider.isCalendarDisabledInSite();
    };
    /**
     * Returns the data needed to render the handler.
     *
     * @return {CoreMainMenuHandlerData} Data needed to render the handler.
     */
    AddonCalendarMainMenuHandler.prototype.getDisplayData = function () {
        return {
            icon: 'calendar',
            title: 'addon.calendar.calendar',
            page: 'AddonCalendarListPage',
            class: 'addon-calendar-handler'
        };
    };
    AddonCalendarMainMenuHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__calendar__["a" /* AddonCalendarProvider */]])
    ], AddonCalendarMainMenuHandler);
    return AddonCalendarMainMenuHandler;
}());

//# sourceMappingURL=mainmenu-handler.js.map

/***/ }),
/* 1236 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonCompetencyModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_competency__ = __webpack_require__(112);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_helper__ = __webpack_require__(288);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_course_option_handler__ = __webpack_require__(1237);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_mainmenu_handler__ = __webpack_require__(1238);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_user_handler__ = __webpack_require__(1239);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__components_components_module__ = __webpack_require__(722);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_course_providers_options_delegate__ = __webpack_require__(100);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__core_mainmenu_providers_delegate__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__core_user_providers_user_delegate__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__core_user_providers_user__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_events__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__core_courses_providers_courses__ = __webpack_require__(31);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};














var AddonCompetencyModule = /** @class */ (function () {
    function AddonCompetencyModule(mainMenuDelegate, mainMenuHandler, courseOptionsDelegate, courseOptionHandler, userDelegate, userHandler, eventsProvider, sitesProvider) {
        mainMenuDelegate.registerHandler(mainMenuHandler);
        courseOptionsDelegate.registerHandler(courseOptionHandler);
        userDelegate.registerHandler(userHandler);
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_11__providers_events__["a" /* CoreEventsProvider */].LOGOUT, function () {
            courseOptionHandler.clearCoursesNavCache();
            userHandler.clearUsersNavCache();
        }, sitesProvider.getCurrentSiteId());
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_13__core_courses_providers_courses__["a" /* CoreCoursesProvider */].EVENT_MY_COURSES_REFRESHED, function () {
            courseOptionHandler.clearCoursesNavCache();
        }, sitesProvider.getCurrentSiteId());
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_10__core_user_providers_user__["a" /* CoreUserProvider */].PROFILE_REFRESHED, function () {
            userHandler.clearUsersNavCache();
        }, sitesProvider.getCurrentSiteId());
    }
    AddonCompetencyModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [
                __WEBPACK_IMPORTED_MODULE_6__components_components_module__["a" /* AddonCompetencyComponentsModule */]
            ],
            providers: [
                __WEBPACK_IMPORTED_MODULE_1__providers_competency__["a" /* AddonCompetencyProvider */],
                __WEBPACK_IMPORTED_MODULE_2__providers_helper__["a" /* AddonCompetencyHelperProvider */],
                __WEBPACK_IMPORTED_MODULE_3__providers_course_option_handler__["a" /* AddonCompetencyCourseOptionHandler */],
                __WEBPACK_IMPORTED_MODULE_4__providers_mainmenu_handler__["a" /* AddonCompetencyMainMenuHandler */],
                __WEBPACK_IMPORTED_MODULE_5__providers_user_handler__["a" /* AddonCompetencyUserHandler */]
            ]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_8__core_mainmenu_providers_delegate__["a" /* CoreMainMenuDelegate */], __WEBPACK_IMPORTED_MODULE_4__providers_mainmenu_handler__["a" /* AddonCompetencyMainMenuHandler */],
            __WEBPACK_IMPORTED_MODULE_7__core_course_providers_options_delegate__["a" /* CoreCourseOptionsDelegate */], __WEBPACK_IMPORTED_MODULE_3__providers_course_option_handler__["a" /* AddonCompetencyCourseOptionHandler */],
            __WEBPACK_IMPORTED_MODULE_9__core_user_providers_user_delegate__["a" /* CoreUserDelegate */], __WEBPACK_IMPORTED_MODULE_5__providers_user_handler__["a" /* AddonCompetencyUserHandler */],
            __WEBPACK_IMPORTED_MODULE_11__providers_events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_12__providers_sites__["a" /* CoreSitesProvider */]])
    ], AddonCompetencyModule);
    return AddonCompetencyModule;
}());

//# sourceMappingURL=competency.module.js.map

/***/ }),
/* 1237 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonCompetencyCourseOptionHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_course_providers_course__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__components_course_course__ = __webpack_require__(590);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_competency__ = __webpack_require__(112);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Course nav handler.
 */
var AddonCompetencyCourseOptionHandler = /** @class */ (function () {
    function AddonCompetencyCourseOptionHandler(competencyProvider) {
        this.competencyProvider = competencyProvider;
        this.name = 'AddonCompetency';
        this.priority = 700;
        this.coursesNavEnabledCache = {};
    }
    /**
     * Clear courses nav cache.
     */
    AddonCompetencyCourseOptionHandler.prototype.clearCoursesNavCache = function () {
        this.coursesNavEnabledCache = {};
    };
    /**
     * Whether or not the handler is enabled ona site level.
     * @return {boolean|Promise<boolean>} Whether or not the handler is enabled on a site level.
     */
    AddonCompetencyCourseOptionHandler.prototype.isEnabled = function () {
        return true;
    };
    /**
     * Whether or not the handler is enabled for a certain course.
     *
     * @param {number} courseId The course ID.
     * @param {any} accessData Access type and data. Default, guest, ...
     * @param {any} [navOptions] Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.
     * @param {any} [admOptions] Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.
     * @return {boolean|Promise<boolean>} True or promise resolved with true if enabled.
     */
    AddonCompetencyCourseOptionHandler.prototype.isEnabledForCourse = function (courseId, accessData, navOptions, admOptions) {
        var _this = this;
        if (accessData && accessData.type == __WEBPACK_IMPORTED_MODULE_1__core_course_providers_course__["a" /* CoreCourseProvider */].ACCESS_GUEST) {
            return false; // Not enabled for guests.
        }
        if (navOptions && typeof navOptions.competencies != 'undefined') {
            return navOptions.competencies;
        }
        if (typeof this.coursesNavEnabledCache[courseId] != 'undefined') {
            return this.coursesNavEnabledCache[courseId];
        }
        return this.competencyProvider.isPluginForCourseEnabled(courseId).then(function (competencies) {
            var enabled = competencies ? !competencies.canmanagecoursecompetencies : false;
            _this.coursesNavEnabledCache[courseId] = enabled;
            return enabled;
        });
    };
    /**
     * Returns the data needed to render the handler.
     *
     * @param {Injector} injector Injector.
     * @param {number} courseId The course ID.
     * @return {CoreCourseOptionsHandlerData|Promise<CoreCourseOptionsHandlerData>} Data or promise resolved with the data.
     */
    AddonCompetencyCourseOptionHandler.prototype.getDisplayData = function (injector, courseId) {
        return {
            title: 'addon.competency.competencies',
            class: 'addon-competency-course-handler',
            component: __WEBPACK_IMPORTED_MODULE_2__components_course_course__["a" /* AddonCompetencyCourseComponent */]
        };
    };
    /**
     * Should invalidate the data to determine if the handler is enabled for a certain course.
     *
     * @param {number} courseId The course ID.
     * @param {any} [navOptions] Course navigation options for current user. See CoreCoursesProvider.getUserNavigationOptions.
     * @param {any} [admOptions] Course admin options for current user. See CoreCoursesProvider.getUserAdministrationOptions.
     * @return {Promise<any>} Promise resolved when done.
     */
    AddonCompetencyCourseOptionHandler.prototype.invalidateEnabledForCourse = function (courseId, navOptions, admOptions) {
        if (navOptions && typeof navOptions.competencies != 'undefined') {
            // No need to invalidate anything.
            return Promise.resolve();
        }
        return this.competencyProvider.invalidateCourseCompetencies(courseId);
    };
    AddonCompetencyCourseOptionHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_competency__["a" /* AddonCompetencyProvider */]])
    ], AddonCompetencyCourseOptionHandler);
    return AddonCompetencyCourseOptionHandler;
}());

//# sourceMappingURL=course-option-handler.js.map

/***/ }),
/* 1238 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonCompetencyMainMenuHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__competency__ = __webpack_require__(112);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Handler to inject an option into main menu.
 */
var AddonCompetencyMainMenuHandler = /** @class */ (function () {
    function AddonCompetencyMainMenuHandler(competencyProvider) {
        this.competencyProvider = competencyProvider;
        this.name = 'AddonCompetency';
        this.priority = 500;
    }
    /**
     * Check if the handler is enabled on a site level.
     *
     * @return {boolean} Whether or not the handler is enabled on a site level.
     */
    AddonCompetencyMainMenuHandler.prototype.isEnabled = function () {
        // Check the user has at least one learn plan available.
        return this.competencyProvider.getLearningPlans().then(function (plans) {
            return plans.length > 0;
        });
    };
    /**
     * Returns the data needed to render the handler.
     *
     * @return {CoreMainMenuHandlerData} Data needed to render the handler.
     */
    AddonCompetencyMainMenuHandler.prototype.getDisplayData = function () {
        return {
            icon: 'map',
            title: 'addon.competency.myplans',
            page: 'AddonCompetencyPlanListPage',
            class: 'addon-competency-handler'
        };
    };
    AddonCompetencyMainMenuHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__competency__["a" /* AddonCompetencyProvider */]])
    ], AddonCompetencyMainMenuHandler);
    return AddonCompetencyMainMenuHandler;
}());

//# sourceMappingURL=mainmenu-handler.js.map

/***/ }),
/* 1239 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonCompetencyUserHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_user_providers_user_delegate__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_contentlinks_providers_helper__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__competency__ = __webpack_require__(112);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Profile competencies handler.
 */
var AddonCompetencyUserHandler = /** @class */ (function () {
    function AddonCompetencyUserHandler(linkHelper, sitesProvider, competencyProvider) {
        this.linkHelper = linkHelper;
        this.sitesProvider = sitesProvider;
        this.competencyProvider = competencyProvider;
        this.name = 'AddonCompetency';
        this.priority = 900;
        this.type = __WEBPACK_IMPORTED_MODULE_1__core_user_providers_user_delegate__["a" /* CoreUserDelegate */].TYPE_NEW_PAGE;
        this.participantsNavEnabledCache = {};
        this.usersNavEnabledCache = {};
    }
    /**
     * Clear users nav cache.
     */
    AddonCompetencyUserHandler.prototype.clearUsersNavCache = function () {
        this.participantsNavEnabledCache = {};
        this.usersNavEnabledCache = {};
    };
    /**
     * Whether or not the handler is enabled on a site level.
     * @return {boolean|Promise<boolean>} Whether or not the handler is enabled on a site level.
     */
    AddonCompetencyUserHandler.prototype.isEnabled = function () {
        return true;
    };
    /**
     * Check if handler is enabled for this user in this context.
     *
     * @param {any} user     User to check.
     * @param {number} courseId Course ID.
     * @param  {any} [navOptions] Course navigation options for current user. See $mmCourses#getUserNavigationOptions.
     * @param  {any} [admOptions] Course admin options for current user. See $mmCourses#getUserAdministrationOptions.
     * @return  {boolean|Promise<boolean>}   Promise resolved with true if enabled, resolved with false otherwise.
     */
    AddonCompetencyUserHandler.prototype.isEnabledForUser = function (user, courseId, navOptions, admOptions) {
        var _this = this;
        if (courseId) {
            var cacheKey_1 = courseId + '.' + user.id;
            // Link on a user course profile.
            if (typeof this.participantsNavEnabledCache[cacheKey_1] != 'undefined') {
                return this.participantsNavEnabledCache[cacheKey_1];
            }
            return this.competencyProvider.getCourseCompetencies(courseId, user.id).then(function (response) {
                var enabled = response.competencies.length > 0;
                _this.participantsNavEnabledCache[cacheKey_1] = enabled;
                return enabled;
            }).catch(function (message) {
                _this.participantsNavEnabledCache[cacheKey_1] = false;
                return false;
            });
        }
        else {
            // Link on a user site profile.
            if (typeof this.usersNavEnabledCache[user.id] != 'undefined') {
                return this.usersNavEnabledCache[user.id];
            }
            return this.competencyProvider.getLearningPlans(user.id).then(function (plans) {
                // Check the user has at least one learn plan available.
                var enabled = plans.length > 0;
                _this.usersNavEnabledCache[user.id] = enabled;
                return enabled;
            });
        }
    };
    /**
     * Returns the data needed to render the handler.
     *
     * @return {CoreUserProfileHandlerData} Data needed to render the handler.
     */
    AddonCompetencyUserHandler.prototype.getDisplayData = function (user, courseId) {
        var _this = this;
        if (courseId) {
            return {
                icon: 'ribbon',
                title: 'addon.competency.competencies',
                class: 'addon-competency-handler',
                action: function (event, navCtrl, user, courseId) {
                    event.preventDefault();
                    event.stopPropagation();
                    // Always use redirect to make it the new history root (to avoid "loops" in history).
                    _this.linkHelper.goInSite(navCtrl, 'AddonCompetencyCourseCompetenciesPage', { courseId: courseId, userId: user.id });
                }
            };
        }
        else {
            return {
                icon: 'map',
                title: 'addon.competency.learningplans',
                class: 'addon-competency-handler',
                action: function (event, navCtrl, user, courseId) {
                    event.preventDefault();
                    event.stopPropagation();
                    // Always use redirect to make it the new history root (to avoid "loops" in history).
                    _this.linkHelper.goInSite(navCtrl, 'AddonCompetencyPlanListPage', { userId: user.id });
                }
            };
        }
    };
    AddonCompetencyUserHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__core_contentlinks_providers_helper__["a" /* CoreContentLinksHelperProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_4__competency__["a" /* AddonCompetencyProvider */]])
    ], AddonCompetencyUserHandler);
    return AddonCompetencyUserHandler;
}());

//# sourceMappingURL=user-handler.js.map

/***/ }),
/* 1240 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonUserProfileFieldModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__checkbox_checkbox_module__ = __webpack_require__(1241);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__datetime_datetime_module__ = __webpack_require__(1243);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__menu_menu_module__ = __webpack_require__(1245);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__text_text_module__ = __webpack_require__(1247);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__textarea_textarea_module__ = __webpack_require__(1249);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.






var AddonUserProfileFieldModule = /** @class */ (function () {
    function AddonUserProfileFieldModule() {
    }
    AddonUserProfileFieldModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1__checkbox_checkbox_module__["a" /* AddonUserProfileFieldCheckboxModule */],
                __WEBPACK_IMPORTED_MODULE_2__datetime_datetime_module__["a" /* AddonUserProfileFieldDatetimeModule */],
                __WEBPACK_IMPORTED_MODULE_3__menu_menu_module__["a" /* AddonUserProfileFieldMenuModule */],
                __WEBPACK_IMPORTED_MODULE_4__text_text_module__["a" /* AddonUserProfileFieldTextModule */],
                __WEBPACK_IMPORTED_MODULE_5__textarea_textarea_module__["a" /* AddonUserProfileFieldTextareaModule */]
            ],
            providers: [],
            exports: []
        })
    ], AddonUserProfileFieldModule);
    return AddonUserProfileFieldModule;
}());

//# sourceMappingURL=userprofilefield.module.js.map

/***/ }),
/* 1241 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonUserProfileFieldCheckboxModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_handler__ = __webpack_require__(1242);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_user_providers_user_profile_field_delegate__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__component_checkbox__ = __webpack_require__(697);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__components_components_module__ = __webpack_require__(26);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};







var AddonUserProfileFieldCheckboxModule = /** @class */ (function () {
    function AddonUserProfileFieldCheckboxModule(userProfileFieldDelegate, handler) {
        userProfileFieldDelegate.registerHandler(handler);
    }
    AddonUserProfileFieldCheckboxModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_5__component_checkbox__["a" /* AddonUserProfileFieldCheckboxComponent */]
            ],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["g" /* IonicModule */],
                __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["b" /* TranslateModule */].forChild(),
                __WEBPACK_IMPORTED_MODULE_6__components_components_module__["a" /* CoreComponentsModule */]
            ],
            providers: [
                __WEBPACK_IMPORTED_MODULE_3__providers_handler__["a" /* AddonUserProfileFieldCheckboxHandler */]
            ],
            exports: [
                __WEBPACK_IMPORTED_MODULE_5__component_checkbox__["a" /* AddonUserProfileFieldCheckboxComponent */]
            ],
            entryComponents: [
                __WEBPACK_IMPORTED_MODULE_5__component_checkbox__["a" /* AddonUserProfileFieldCheckboxComponent */]
            ]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__core_user_providers_user_profile_field_delegate__["a" /* CoreUserProfileFieldDelegate */], __WEBPACK_IMPORTED_MODULE_3__providers_handler__["a" /* AddonUserProfileFieldCheckboxHandler */]])
    ], AddonUserProfileFieldCheckboxModule);
    return AddonUserProfileFieldCheckboxModule;
}());

//# sourceMappingURL=checkbox.module.js.map

/***/ }),
/* 1242 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonUserProfileFieldCheckboxHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__component_checkbox__ = __webpack_require__(697);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


/**
 * Checkbox user profile field handlers.
 */
var AddonUserProfileFieldCheckboxHandler = /** @class */ (function () {
    function AddonUserProfileFieldCheckboxHandler() {
        this.name = 'checkbox';
        // Nothing to do.
    }
    /**
     * Whether or not the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} True or promise resolved with true if enabled.
     */
    AddonUserProfileFieldCheckboxHandler.prototype.isEnabled = function () {
        return true;
    };
    /**
     * Get the data to send for the field based on the input data.
     *
     * @param  {any}     field          User field to get the data for.
     * @param  {boolean} signup         True if user is in signup page.
     * @param  {string}  [registerAuth] Register auth method. E.g. 'email'.
     * @param  {any}     formValues     Form Values.
     * @return {CoreUserProfileFieldHandlerData}  Data to send for the field.
     */
    AddonUserProfileFieldCheckboxHandler.prototype.getData = function (field, signup, registerAuth, formValues) {
        var name = 'profile_field_' + field.shortname;
        if (typeof formValues[name] != 'undefined') {
            return {
                type: 'checkbox',
                name: name,
                value: formValues[name] ? 1 : 0
            };
        }
    };
    /**
     * Return the Component to use to display the user profile field.
     * It's recommended to return the class of the component, but you can also return an instance of the component.
     *
     * @param {Injector} injector Injector.
     * @return {any|Promise<any>} The component (or promise resolved with component) to use, undefined if not found.
     */
    AddonUserProfileFieldCheckboxHandler.prototype.getComponent = function (injector) {
        return __WEBPACK_IMPORTED_MODULE_1__component_checkbox__["a" /* AddonUserProfileFieldCheckboxComponent */];
    };
    AddonUserProfileFieldCheckboxHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [])
    ], AddonUserProfileFieldCheckboxHandler);
    return AddonUserProfileFieldCheckboxHandler;
}());

//# sourceMappingURL=handler.js.map

/***/ }),
/* 1243 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonUserProfileFieldDatetimeModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_handler__ = __webpack_require__(1244);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_user_providers_user_profile_field_delegate__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__component_datetime__ = __webpack_require__(698);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__components_components_module__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__pipes_pipes_module__ = __webpack_require__(90);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








var AddonUserProfileFieldDatetimeModule = /** @class */ (function () {
    function AddonUserProfileFieldDatetimeModule(userProfileFieldDelegate, handler) {
        userProfileFieldDelegate.registerHandler(handler);
    }
    AddonUserProfileFieldDatetimeModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_5__component_datetime__["a" /* AddonUserProfileFieldDatetimeComponent */]
            ],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["g" /* IonicModule */],
                __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["b" /* TranslateModule */].forChild(),
                __WEBPACK_IMPORTED_MODULE_6__components_components_module__["a" /* CoreComponentsModule */],
                __WEBPACK_IMPORTED_MODULE_7__pipes_pipes_module__["a" /* CorePipesModule */]
            ],
            providers: [
                __WEBPACK_IMPORTED_MODULE_3__providers_handler__["a" /* AddonUserProfileFieldDatetimeHandler */]
            ],
            exports: [
                __WEBPACK_IMPORTED_MODULE_5__component_datetime__["a" /* AddonUserProfileFieldDatetimeComponent */]
            ],
            entryComponents: [
                __WEBPACK_IMPORTED_MODULE_5__component_datetime__["a" /* AddonUserProfileFieldDatetimeComponent */]
            ]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__core_user_providers_user_profile_field_delegate__["a" /* CoreUserProfileFieldDelegate */], __WEBPACK_IMPORTED_MODULE_3__providers_handler__["a" /* AddonUserProfileFieldDatetimeHandler */]])
    ], AddonUserProfileFieldDatetimeModule);
    return AddonUserProfileFieldDatetimeModule;
}());

//# sourceMappingURL=datetime.module.js.map

/***/ }),
/* 1244 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonUserProfileFieldDatetimeHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__component_datetime__ = __webpack_require__(698);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


/**
 * Datetime user profile field handlers.
 */
var AddonUserProfileFieldDatetimeHandler = /** @class */ (function () {
    function AddonUserProfileFieldDatetimeHandler() {
        this.name = 'datetime';
        // Nothing to do.
    }
    /**
     * Whether or not the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} True or promise resolved with true if enabled.
     */
    AddonUserProfileFieldDatetimeHandler.prototype.isEnabled = function () {
        return true;
    };
    /**
     * Get the data to send for the field based on the input data.
     *
     * @param  {any}     field          User field to get the data for.
     * @param  {boolean} signup         True if user is in signup page.
     * @param  {string}  [registerAuth] Register auth method. E.g. 'email'.
     * @param  {any}     formValues     Form Values.
     * @return {CoreUserProfileFieldHandlerData}  Data to send for the field.
     */
    AddonUserProfileFieldDatetimeHandler.prototype.getData = function (field, signup, registerAuth, formValues) {
        var name = 'profile_field_' + field.shortname;
        if (formValues[name]) {
            var milliseconds = new Date(formValues[name]).getTime();
            return {
                type: 'datetime',
                name: 'profile_field_' + field.shortname,
                value: Math.round(milliseconds / 1000)
            };
        }
    };
    /**
     * Return the Component to use to display the user profile field.
     * It's recommended to return the class of the component, but you can also return an instance of the component.
     *
     * @param {Injector} injector Injector.
     * @return {any|Promise<any>} The component (or promise resolved with component) to use, undefined if not found.
     */
    AddonUserProfileFieldDatetimeHandler.prototype.getComponent = function (injector) {
        return __WEBPACK_IMPORTED_MODULE_1__component_datetime__["a" /* AddonUserProfileFieldDatetimeComponent */];
    };
    AddonUserProfileFieldDatetimeHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [])
    ], AddonUserProfileFieldDatetimeHandler);
    return AddonUserProfileFieldDatetimeHandler;
}());

//# sourceMappingURL=handler.js.map

/***/ }),
/* 1245 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonUserProfileFieldMenuModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_handler__ = __webpack_require__(1246);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_user_providers_user_profile_field_delegate__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__component_menu__ = __webpack_require__(699);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__components_components_module__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__directives_directives_module__ = __webpack_require__(40);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








var AddonUserProfileFieldMenuModule = /** @class */ (function () {
    function AddonUserProfileFieldMenuModule(userProfileFieldDelegate, handler) {
        userProfileFieldDelegate.registerHandler(handler);
    }
    AddonUserProfileFieldMenuModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_5__component_menu__["a" /* AddonUserProfileFieldMenuComponent */]
            ],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["g" /* IonicModule */],
                __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["b" /* TranslateModule */].forChild(),
                __WEBPACK_IMPORTED_MODULE_6__components_components_module__["a" /* CoreComponentsModule */],
                __WEBPACK_IMPORTED_MODULE_7__directives_directives_module__["a" /* CoreDirectivesModule */]
            ],
            providers: [
                __WEBPACK_IMPORTED_MODULE_3__providers_handler__["a" /* AddonUserProfileFieldMenuHandler */]
            ],
            exports: [
                __WEBPACK_IMPORTED_MODULE_5__component_menu__["a" /* AddonUserProfileFieldMenuComponent */]
            ],
            entryComponents: [
                __WEBPACK_IMPORTED_MODULE_5__component_menu__["a" /* AddonUserProfileFieldMenuComponent */]
            ]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__core_user_providers_user_profile_field_delegate__["a" /* CoreUserProfileFieldDelegate */], __WEBPACK_IMPORTED_MODULE_3__providers_handler__["a" /* AddonUserProfileFieldMenuHandler */]])
    ], AddonUserProfileFieldMenuModule);
    return AddonUserProfileFieldMenuModule;
}());

//# sourceMappingURL=menu.module.js.map

/***/ }),
/* 1246 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonUserProfileFieldMenuHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__component_menu__ = __webpack_require__(699);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


/**
 * Menu user profile field handlers.
 */
var AddonUserProfileFieldMenuHandler = /** @class */ (function () {
    function AddonUserProfileFieldMenuHandler() {
        this.name = 'menu';
        // Nothing to do.
    }
    /**
     * Whether or not the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} True or promise resolved with true if enabled.
     */
    AddonUserProfileFieldMenuHandler.prototype.isEnabled = function () {
        return true;
    };
    /**
     * Get the data to send for the field based on the input data.
     *
     * @param  {any}     field          User field to get the data for.
     * @param  {boolean} signup         True if user is in signup page.
     * @param  {string}  [registerAuth] Register auth method. E.g. 'email'.
     * @param  {any}     formValues     Form Values.
     * @return {CoreUserProfileFieldHandlerData}  Data to send for the field.
     */
    AddonUserProfileFieldMenuHandler.prototype.getData = function (field, signup, registerAuth, formValues) {
        var name = 'profile_field_' + field.shortname;
        if (formValues[name]) {
            return {
                type: 'menu',
                name: name,
                value: formValues[name]
            };
        }
    };
    /**
     * Return the Component to use to display the user profile field.
     * It's recommended to return the class of the component, but you can also return an instance of the component.
     *
     * @param {Injector} injector Injector.
     * @return {any|Promise<any>} The component (or promise resolved with component) to use, undefined if not found.
     */
    AddonUserProfileFieldMenuHandler.prototype.getComponent = function (injector) {
        return __WEBPACK_IMPORTED_MODULE_1__component_menu__["a" /* AddonUserProfileFieldMenuComponent */];
    };
    AddonUserProfileFieldMenuHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [])
    ], AddonUserProfileFieldMenuHandler);
    return AddonUserProfileFieldMenuHandler;
}());

//# sourceMappingURL=handler.js.map

/***/ }),
/* 1247 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonUserProfileFieldTextModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_handler__ = __webpack_require__(1248);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_user_providers_user_profile_field_delegate__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__component_text__ = __webpack_require__(700);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__components_components_module__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__directives_directives_module__ = __webpack_require__(40);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








var AddonUserProfileFieldTextModule = /** @class */ (function () {
    function AddonUserProfileFieldTextModule(userProfileFieldDelegate, handler) {
        userProfileFieldDelegate.registerHandler(handler);
    }
    AddonUserProfileFieldTextModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_5__component_text__["a" /* AddonUserProfileFieldTextComponent */]
            ],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["g" /* IonicModule */],
                __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["b" /* TranslateModule */].forChild(),
                __WEBPACK_IMPORTED_MODULE_6__components_components_module__["a" /* CoreComponentsModule */],
                __WEBPACK_IMPORTED_MODULE_7__directives_directives_module__["a" /* CoreDirectivesModule */]
            ],
            providers: [
                __WEBPACK_IMPORTED_MODULE_3__providers_handler__["a" /* AddonUserProfileFieldTextHandler */]
            ],
            exports: [
                __WEBPACK_IMPORTED_MODULE_5__component_text__["a" /* AddonUserProfileFieldTextComponent */]
            ],
            entryComponents: [
                __WEBPACK_IMPORTED_MODULE_5__component_text__["a" /* AddonUserProfileFieldTextComponent */]
            ]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__core_user_providers_user_profile_field_delegate__["a" /* CoreUserProfileFieldDelegate */], __WEBPACK_IMPORTED_MODULE_3__providers_handler__["a" /* AddonUserProfileFieldTextHandler */]])
    ], AddonUserProfileFieldTextModule);
    return AddonUserProfileFieldTextModule;
}());

//# sourceMappingURL=text.module.js.map

/***/ }),
/* 1248 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonUserProfileFieldTextHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__component_text__ = __webpack_require__(700);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_text__ = __webpack_require__(13);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.



/**
 * Text user profile field handlers.
 */
var AddonUserProfileFieldTextHandler = /** @class */ (function () {
    function AddonUserProfileFieldTextHandler(textUtils) {
        this.textUtils = textUtils;
        this.name = 'text';
    }
    /**
     * Whether or not the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} True or promise resolved with true if enabled.
     */
    AddonUserProfileFieldTextHandler.prototype.isEnabled = function () {
        return true;
    };
    /**
     * Get the data to send for the field based on the input data.
     *
     * @param  {any}     field          User field to get the data for.
     * @param  {boolean} signup         True if user is in signup page.
     * @param  {string}  [registerAuth] Register auth method. E.g. 'email'.
     * @param  {any}     formValues     Form Values.
     * @return {CoreUserProfileFieldHandlerData}  Data to send for the field.
     */
    AddonUserProfileFieldTextHandler.prototype.getData = function (field, signup, registerAuth, formValues) {
        var name = 'profile_field_' + field.shortname;
        return {
            type: 'text',
            name: name,
            value: this.textUtils.cleanTags(formValues[name])
        };
    };
    /**
     * Return the Component to use to display the user profile field.
     * It's recommended to return the class of the component, but you can also return an instance of the component.
     *
     * @param {Injector} injector Injector.
     * @return {any|Promise<any>} The component (or promise resolved with component) to use, undefined if not found.
     */
    AddonUserProfileFieldTextHandler.prototype.getComponent = function (injector) {
        return __WEBPACK_IMPORTED_MODULE_1__component_text__["a" /* AddonUserProfileFieldTextComponent */];
    };
    AddonUserProfileFieldTextHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_utils_text__["a" /* CoreTextUtilsProvider */]])
    ], AddonUserProfileFieldTextHandler);
    return AddonUserProfileFieldTextHandler;
}());

//# sourceMappingURL=handler.js.map

/***/ }),
/* 1249 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonUserProfileFieldTextareaModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_handler__ = __webpack_require__(1250);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_user_providers_user_profile_field_delegate__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__component_textarea__ = __webpack_require__(701);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__components_components_module__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__directives_directives_module__ = __webpack_require__(40);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








var AddonUserProfileFieldTextareaModule = /** @class */ (function () {
    function AddonUserProfileFieldTextareaModule(userProfileFieldDelegate, handler) {
        userProfileFieldDelegate.registerHandler(handler);
    }
    AddonUserProfileFieldTextareaModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_5__component_textarea__["a" /* AddonUserProfileFieldTextareaComponent */]
            ],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["g" /* IonicModule */],
                __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["b" /* TranslateModule */].forChild(),
                __WEBPACK_IMPORTED_MODULE_6__components_components_module__["a" /* CoreComponentsModule */],
                __WEBPACK_IMPORTED_MODULE_7__directives_directives_module__["a" /* CoreDirectivesModule */]
            ],
            providers: [
                __WEBPACK_IMPORTED_MODULE_3__providers_handler__["a" /* AddonUserProfileFieldTextareaHandler */]
            ],
            exports: [
                __WEBPACK_IMPORTED_MODULE_5__component_textarea__["a" /* AddonUserProfileFieldTextareaComponent */]
            ],
            entryComponents: [
                __WEBPACK_IMPORTED_MODULE_5__component_textarea__["a" /* AddonUserProfileFieldTextareaComponent */]
            ]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__core_user_providers_user_profile_field_delegate__["a" /* CoreUserProfileFieldDelegate */], __WEBPACK_IMPORTED_MODULE_3__providers_handler__["a" /* AddonUserProfileFieldTextareaHandler */]])
    ], AddonUserProfileFieldTextareaModule);
    return AddonUserProfileFieldTextareaModule;
}());

//# sourceMappingURL=textarea.module.js.map

/***/ }),
/* 1250 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonUserProfileFieldTextareaHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__component_textarea__ = __webpack_require__(701);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_utils_text__ = __webpack_require__(13);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.



/**
 * Textarea user profile field handlers.
 */
var AddonUserProfileFieldTextareaHandler = /** @class */ (function () {
    function AddonUserProfileFieldTextareaHandler(textUtils) {
        this.textUtils = textUtils;
        this.name = 'textarea';
    }
    /**
     * Whether or not the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} True or promise resolved with true if enabled.
     */
    AddonUserProfileFieldTextareaHandler.prototype.isEnabled = function () {
        return true;
    };
    /**
     * Get the data to send for the field based on the input data.
     *
     * @param  {any}     field          User field to get the data for.
     * @param  {boolean} signup         True if user is in signup page.
     * @param  {string}  [registerAuth] Register auth method. E.g. 'email'.
     * @param  {any}     formValues     Form Values.
     * @return {CoreUserProfileFieldHandlerData}  Data to send for the field.
     */
    AddonUserProfileFieldTextareaHandler.prototype.getData = function (field, signup, registerAuth, formValues) {
        var name = 'profile_field_' + field.shortname;
        if (formValues[name]) {
            var text = formValues[name] || '';
            // Add some HTML to the message in case the user edited with textarea.
            text = this.textUtils.formatHtmlLines(text);
            return {
                type: 'textarea',
                name: name,
                value: JSON.stringify({
                    text: text,
                    format: 1 // Always send this format.
                })
            };
        }
    };
    /**
     * Return the Component to use to display the user profile field.
     * It's recommended to return the class of the component, but you can also return an instance of the component.
     *
     * @param {Injector} injector Injector.
     * @return {any|Promise<any>} The component (or promise resolved with component) to use, undefined if not found.
     */
    AddonUserProfileFieldTextareaHandler.prototype.getComponent = function (injector) {
        return __WEBPACK_IMPORTED_MODULE_1__component_textarea__["a" /* AddonUserProfileFieldTextareaComponent */];
    };
    AddonUserProfileFieldTextareaHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_utils_text__["a" /* CoreTextUtilsProvider */]])
    ], AddonUserProfileFieldTextareaHandler);
    return AddonUserProfileFieldTextareaHandler;
}());

//# sourceMappingURL=handler.js.map

/***/ }),
/* 1251 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonFilesModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_files__ = __webpack_require__(179);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_helper__ = __webpack_require__(723);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_mainmenu_handler__ = __webpack_require__(1252);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_mainmenu_providers_delegate__ = __webpack_require__(71);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





var AddonFilesModule = /** @class */ (function () {
    function AddonFilesModule(mainMenuDelegate, filesHandler) {
        mainMenuDelegate.registerHandler(filesHandler);
    }
    AddonFilesModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [],
            providers: [
                __WEBPACK_IMPORTED_MODULE_1__providers_files__["a" /* AddonFilesProvider */],
                __WEBPACK_IMPORTED_MODULE_2__providers_helper__["a" /* AddonFilesHelperProvider */],
                __WEBPACK_IMPORTED_MODULE_3__providers_mainmenu_handler__["a" /* AddonFilesMainMenuHandler */]
            ]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__core_mainmenu_providers_delegate__["a" /* CoreMainMenuDelegate */], __WEBPACK_IMPORTED_MODULE_3__providers_mainmenu_handler__["a" /* AddonFilesMainMenuHandler */]])
    ], AddonFilesModule);
    return AddonFilesModule;
}());

//# sourceMappingURL=files.module.js.map

/***/ }),
/* 1252 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonFilesMainMenuHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__files__ = __webpack_require__(179);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Handler to inject an option into main menu.
 */
var AddonFilesMainMenuHandler = /** @class */ (function () {
    function AddonFilesMainMenuHandler(filesProvider) {
        this.filesProvider = filesProvider;
        this.name = 'AddonFiles';
        this.priority = 400;
    }
    /**
     * Check if the handler is enabled on a site level.
     *
     * @return {boolean} Whether or not the handler is enabled on a site level.
     */
    AddonFilesMainMenuHandler.prototype.isEnabled = function () {
        return this.filesProvider.isPluginEnabled();
    };
    /**
     * Returns the data needed to render the handler.
     *
     * @return {CoreMainMenuHandlerData} Data needed to render the handler.
     */
    AddonFilesMainMenuHandler.prototype.getDisplayData = function () {
        return {
            icon: 'folder',
            title: 'addon.files.files',
            page: 'AddonFilesListPage',
            class: 'addon-files-handler'
        };
    };
    AddonFilesMainMenuHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__files__["a" /* AddonFilesProvider */]])
    ], AddonFilesMainMenuHandler);
    return AddonFilesMainMenuHandler;
}());

//# sourceMappingURL=mainmenu-handler.js.map

/***/ }),
/* 1253 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModBookModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_components_module__ = __webpack_require__(724);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_book__ = __webpack_require__(131);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_module_handler__ = __webpack_require__(1254);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_link_handler__ = __webpack_require__(1255);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_prefetch_handler__ = __webpack_require__(596);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_course_providers_module_delegate__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_contentlinks_providers_delegate__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__core_course_providers_module_prefetch_delegate__ = __webpack_require__(55);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};









var AddonModBookModule = /** @class */ (function () {
    function AddonModBookModule(moduleDelegate, moduleHandler, contentLinksDelegate, linkHandler, prefetchDelegate, prefetchHandler) {
        moduleDelegate.registerHandler(moduleHandler);
        contentLinksDelegate.registerHandler(linkHandler);
        prefetchDelegate.registerHandler(prefetchHandler);
    }
    AddonModBookModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1__components_components_module__["a" /* AddonModBookComponentsModule */]
            ],
            providers: [
                __WEBPACK_IMPORTED_MODULE_2__providers_book__["a" /* AddonModBookProvider */],
                __WEBPACK_IMPORTED_MODULE_3__providers_module_handler__["a" /* AddonModBookModuleHandler */],
                __WEBPACK_IMPORTED_MODULE_4__providers_link_handler__["a" /* AddonModBookLinkHandler */],
                __WEBPACK_IMPORTED_MODULE_5__providers_prefetch_handler__["a" /* AddonModBookPrefetchHandler */]
            ]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__core_course_providers_module_delegate__["a" /* CoreCourseModuleDelegate */], __WEBPACK_IMPORTED_MODULE_3__providers_module_handler__["a" /* AddonModBookModuleHandler */],
            __WEBPACK_IMPORTED_MODULE_7__core_contentlinks_providers_delegate__["a" /* CoreContentLinksDelegate */], __WEBPACK_IMPORTED_MODULE_4__providers_link_handler__["a" /* AddonModBookLinkHandler */],
            __WEBPACK_IMPORTED_MODULE_8__core_course_providers_module_prefetch_delegate__["a" /* CoreCourseModulePrefetchDelegate */], __WEBPACK_IMPORTED_MODULE_5__providers_prefetch_handler__["a" /* AddonModBookPrefetchHandler */]])
    ], AddonModBookModule);
    return AddonModBookModule;
}());

//# sourceMappingURL=book.module.js.map

/***/ }),
/* 1254 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModBookModuleHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__book__ = __webpack_require__(131);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__components_index_index__ = __webpack_require__(290);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_course_providers_course__ = __webpack_require__(14);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Handler to support book modules.
 */
var AddonModBookModuleHandler = /** @class */ (function () {
    function AddonModBookModuleHandler(bookProvider, courseProvider) {
        this.bookProvider = bookProvider;
        this.courseProvider = courseProvider;
        this.name = 'book';
    }
    /**
     * Check if the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} Whether or not the handler is enabled on a site level.
     */
    AddonModBookModuleHandler.prototype.isEnabled = function () {
        return this.bookProvider.isPluginEnabled();
    };
    /**
     * Get the data required to display the module in the course contents view.
     *
     * @param {any} module The module object.
     * @param {number} courseId The course ID.
     * @param {number} sectionId The section ID.
     * @return {CoreCourseModuleHandlerData} Data to render the module.
     */
    AddonModBookModuleHandler.prototype.getData = function (module, courseId, sectionId) {
        return {
            icon: this.courseProvider.getModuleIconSrc('book'),
            title: module.name,
            class: 'addon-mod_book-handler',
            showDownloadButton: true,
            action: function (event, navCtrl, module, courseId, options) {
                navCtrl.push('AddonModBookIndexPage', { module: module, courseId: courseId }, options);
            }
        };
    };
    /**
     * Get the component to render the module. This is needed to support singleactivity course format.
     * The component returned must implement CoreCourseModuleMainComponent.
     * It's recommended to return the class of the component, but you can also return an instance of the component.
     *
     * @param {Injector} injector Injector.
     * @param {any} course The course object.
     * @param {any} module The module object.
     * @return {any|Promise<any>} The component (or promise resolved with component) to use, undefined if not found.
     */
    AddonModBookModuleHandler.prototype.getMainComponent = function (injector, course, module) {
        return __WEBPACK_IMPORTED_MODULE_2__components_index_index__["a" /* AddonModBookIndexComponent */];
    };
    AddonModBookModuleHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__book__["a" /* AddonModBookProvider */], __WEBPACK_IMPORTED_MODULE_3__core_course_providers_course__["a" /* CoreCourseProvider */]])
    ], AddonModBookModuleHandler);
    return AddonModBookModuleHandler;
}());

//# sourceMappingURL=module-handler.js.map

/***/ }),
/* 1255 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModBookLinkHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_contentlinks_classes_module_index_handler__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_course_providers_helper__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__book__ = __webpack_require__(131);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Handler to treat links to book.
 */
var AddonModBookLinkHandler = /** @class */ (function (_super) {
    __extends(AddonModBookLinkHandler, _super);
    function AddonModBookLinkHandler(courseHelper) {
        var _this = _super.call(this, courseHelper, __WEBPACK_IMPORTED_MODULE_3__book__["a" /* AddonModBookProvider */].COMPONENT, 'book') || this;
        _this.name = 'AddonModBookLinkHandler';
        return _this;
    }
    AddonModBookLinkHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__core_course_providers_helper__["a" /* CoreCourseHelperProvider */]])
    ], AddonModBookLinkHandler);
    return AddonModBookLinkHandler;
}(__WEBPACK_IMPORTED_MODULE_1__core_contentlinks_classes_module_index_handler__["a" /* CoreContentLinksModuleIndexHandler */]));

//# sourceMappingURL=link-handler.js.map

/***/ }),
/* 1256 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModLabelModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_module_handler__ = __webpack_require__(1257);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_link_handler__ = __webpack_require__(1258);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_course_providers_module_delegate__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_contentlinks_providers_delegate__ = __webpack_require__(46);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





var AddonModLabelModule = /** @class */ (function () {
    function AddonModLabelModule(moduleDelegate, moduleHandler, contentLinksDelegate, linkHandler) {
        moduleDelegate.registerHandler(moduleHandler);
        contentLinksDelegate.registerHandler(linkHandler);
    }
    AddonModLabelModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [],
            providers: [
                __WEBPACK_IMPORTED_MODULE_1__providers_module_handler__["a" /* AddonModLabelModuleHandler */],
                __WEBPACK_IMPORTED_MODULE_2__providers_link_handler__["a" /* AddonModLabelLinkHandler */]
            ]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__core_course_providers_module_delegate__["a" /* CoreCourseModuleDelegate */], __WEBPACK_IMPORTED_MODULE_1__providers_module_handler__["a" /* AddonModLabelModuleHandler */],
            __WEBPACK_IMPORTED_MODULE_4__core_contentlinks_providers_delegate__["a" /* CoreContentLinksDelegate */], __WEBPACK_IMPORTED_MODULE_2__providers_link_handler__["a" /* AddonModLabelLinkHandler */]])
    ], AddonModLabelModule);
    return AddonModLabelModule;
}());

//# sourceMappingURL=label.module.js.map

/***/ }),
/* 1257 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModLabelModuleHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

/**
 * Handler to support label modules.
 */
var AddonModLabelModuleHandler = /** @class */ (function () {
    function AddonModLabelModuleHandler() {
        this.name = 'label';
        // Nothing to do.
    }
    /**
     * Check if the handler is enabled on a site level.
     *
     * @return {boolean} Whether or not the handler is enabled on a site level.
     */
    AddonModLabelModuleHandler.prototype.isEnabled = function () {
        return true;
    };
    /**
     * Get the data required to display the module in the course contents view.
     *
     * @param {any} module The module object.
     * @param {number} courseId The course ID.
     * @param {number} sectionId The section ID.
     * @return {CoreCourseModuleHandlerData} Data to render the module.
     */
    AddonModLabelModuleHandler.prototype.getData = function (module, courseId, sectionId) {
        // Remove the description from the module so it isn't rendered twice.
        var title = module.description;
        module.description = '';
        return {
            icon: '',
            title: title,
            class: 'addon-mod-label-handler'
        };
    };
    /**
     * Get the component to render the module. This is needed to support singleactivity course format.
     * The component returned must implement CoreCourseModuleMainComponent.
     * It's recommended to return the class of the component, but you can also return an instance of the component.
     *
     * @param {Injector} injector Injector.
     * @param {any} course The course object.
     * @param {any} module The module object.
     * @return {any|Promise<any>} The component (or promise resolved with component) to use, undefined if not found.
     */
    AddonModLabelModuleHandler.prototype.getMainComponent = function (injector, course, module) {
        // There's no need to implement this because label cannot be used in singleactivity course format.
    };
    AddonModLabelModuleHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [])
    ], AddonModLabelModuleHandler);
    return AddonModLabelModuleHandler;
}());

//# sourceMappingURL=module-handler.js.map

/***/ }),
/* 1258 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModLabelLinkHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_contentlinks_classes_module_index_handler__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_course_providers_helper__ = __webpack_require__(29);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Handler to treat links to label.
 */
var AddonModLabelLinkHandler = /** @class */ (function (_super) {
    __extends(AddonModLabelLinkHandler, _super);
    function AddonModLabelLinkHandler(courseHelper) {
        var _this = _super.call(this, courseHelper, 'mmaModLabel', 'label') || this;
        _this.name = 'AddonModLabelLinkHandler';
        return _this;
    }
    AddonModLabelLinkHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__core_course_providers_helper__["a" /* CoreCourseHelperProvider */]])
    ], AddonModLabelLinkHandler);
    return AddonModLabelLinkHandler;
}(__WEBPACK_IMPORTED_MODULE_1__core_contentlinks_classes_module_index_handler__["a" /* CoreContentLinksModuleIndexHandler */]));

//# sourceMappingURL=link-handler.js.map

/***/ }),
/* 1259 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModResourceModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_components_module__ = __webpack_require__(728);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_module_handler__ = __webpack_require__(1260);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_resource__ = __webpack_require__(108);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_prefetch_handler__ = __webpack_require__(600);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_link_handler__ = __webpack_require__(1261);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_pluginfile_handler__ = __webpack_require__(1262);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_helper__ = __webpack_require__(164);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__core_contentlinks_providers_delegate__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__core_course_providers_module_delegate__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__core_course_providers_module_prefetch_delegate__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_plugin_file_delegate__ = __webpack_require__(129);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};












var AddonModResourceModule = /** @class */ (function () {
    function AddonModResourceModule(moduleDelegate, moduleHandler, prefetchDelegate, prefetchHandler, contentLinksDelegate, linkHandler, pluginfileDelegate, pluginfileHandler) {
        moduleDelegate.registerHandler(moduleHandler);
        prefetchDelegate.registerHandler(prefetchHandler);
        contentLinksDelegate.registerHandler(linkHandler);
        pluginfileDelegate.registerHandler(pluginfileHandler);
    }
    AddonModResourceModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1__components_components_module__["a" /* AddonModResourceComponentsModule */]
            ],
            providers: [
                __WEBPACK_IMPORTED_MODULE_3__providers_resource__["a" /* AddonModResourceProvider */],
                __WEBPACK_IMPORTED_MODULE_2__providers_module_handler__["a" /* AddonModResourceModuleHandler */],
                __WEBPACK_IMPORTED_MODULE_7__providers_helper__["a" /* AddonModResourceHelperProvider */],
                __WEBPACK_IMPORTED_MODULE_4__providers_prefetch_handler__["a" /* AddonModResourcePrefetchHandler */],
                __WEBPACK_IMPORTED_MODULE_5__providers_link_handler__["a" /* AddonModResourceLinkHandler */],
                __WEBPACK_IMPORTED_MODULE_6__providers_pluginfile_handler__["a" /* AddonModResourcePluginFileHandler */]
            ]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_9__core_course_providers_module_delegate__["a" /* CoreCourseModuleDelegate */], __WEBPACK_IMPORTED_MODULE_2__providers_module_handler__["a" /* AddonModResourceModuleHandler */],
            __WEBPACK_IMPORTED_MODULE_10__core_course_providers_module_prefetch_delegate__["a" /* CoreCourseModulePrefetchDelegate */], __WEBPACK_IMPORTED_MODULE_4__providers_prefetch_handler__["a" /* AddonModResourcePrefetchHandler */],
            __WEBPACK_IMPORTED_MODULE_8__core_contentlinks_providers_delegate__["a" /* CoreContentLinksDelegate */], __WEBPACK_IMPORTED_MODULE_5__providers_link_handler__["a" /* AddonModResourceLinkHandler */],
            __WEBPACK_IMPORTED_MODULE_11__providers_plugin_file_delegate__["a" /* CorePluginFileDelegate */], __WEBPACK_IMPORTED_MODULE_6__providers_pluginfile_handler__["a" /* AddonModResourcePluginFileHandler */]])
    ], AddonModResourceModule);
    return AddonModResourceModule;
}());

//# sourceMappingURL=resource.module.js.map

/***/ }),
/* 1260 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModResourceModuleHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__resource__ = __webpack_require__(108);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__helper__ = __webpack_require__(164);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__components_index_index__ = __webpack_require__(293);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_course_providers_course__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_mimetype__ = __webpack_require__(44);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






/**
 * Handler to support resource modules.
 */
var AddonModResourceModuleHandler = /** @class */ (function () {
    function AddonModResourceModuleHandler(resourceProvider, courseProvider, mimetypeUtils, resourceHelper) {
        this.resourceProvider = resourceProvider;
        this.courseProvider = courseProvider;
        this.mimetypeUtils = mimetypeUtils;
        this.resourceHelper = resourceHelper;
        this.name = 'resource';
    }
    /**
     * Check if the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} Whether or not the handler is enabled on a site level.
     */
    AddonModResourceModuleHandler.prototype.isEnabled = function () {
        return this.resourceProvider.isPluginEnabled();
    };
    /**
     * Get the data required to display the module in the course contents view.
     *
     * @param {any} module The module object.
     * @param {number} courseId The course ID.
     * @param {number} sectionId The section ID.
     * @return {CoreCourseModuleHandlerData} Data to render the module.
     */
    AddonModResourceModuleHandler.prototype.getData = function (module, courseId, sectionId) {
        var _this = this;
        var handlerData = {
            icon: this.courseProvider.getModuleIconSrc('resource'),
            title: module.name,
            class: 'addon-mod_resource-handler',
            showDownloadButton: true,
            action: function (event, navCtrl, module, courseId, options) {
                navCtrl.push('AddonModResourceIndexPage', { module: module, courseId: courseId }, options);
            },
            buttons: [{
                    hidden: !this.resourceHelper.isDisplayedInIframe(module),
                    icon: 'document',
                    label: 'addon.mod_resource.openthefile',
                    action: function (event, navCtrl, module, courseId) {
                        _this.hideOpenButton(module, courseId).then(function (hide) {
                            if (!hide) {
                                _this.resourceHelper.openModuleFile(module, courseId);
                            }
                        });
                    }
                }]
        };
        this.getIcon(module, courseId).then(function (icon) {
            handlerData.icon = icon;
        });
        this.hideOpenButton(module, courseId).then(function (hideOpenButton) {
            handlerData.buttons[0].hidden = hideOpenButton;
        });
        return handlerData;
    };
    /**
     * Returns if contents are loaded to show open button.
     *
     * @param {any} module The module object.
     * @param {number} courseId The course ID.
     * @return {Promise<boolean>} Resolved when done.
     */
    AddonModResourceModuleHandler.prototype.hideOpenButton = function (module, courseId) {
        var _this = this;
        return this.courseProvider.loadModuleContents(module, courseId).then(function () {
            return _this.resourceHelper.isDisplayedInIframe(module);
        });
    };
    /**
     * Returns the activity icon.
     *
     * @param {any} module        The module object.
     * @param {number} courseId   The course ID.
     * @return {Promise<string>}  Icon URL.
     */
    AddonModResourceModuleHandler.prototype.getIcon = function (module, courseId) {
        var _this = this;
        return this.courseProvider.loadModuleContents(module, courseId).then(function () {
            if (module.contents.length) {
                var filename = module.contents[0].filename, extension = _this.mimetypeUtils.getFileExtension(filename);
                if (module.contents.length == 1 || (extension != 'html' && extension != 'htm')) {
                    return _this.mimetypeUtils.getFileIcon(filename);
                }
            }
            return _this.courseProvider.getModuleIconSrc('resource');
        });
    };
    /**
     * Get the component to render the module. This is needed to support singleactivity course format.
     * The component returned must implement CoreCourseModuleMainComponent.
     *
     * @param {any} course The course object.
     * @param {any} module The module object.
     * @return {any} The component to use, undefined if not found.
     */
    AddonModResourceModuleHandler.prototype.getMainComponent = function (course, module) {
        return __WEBPACK_IMPORTED_MODULE_3__components_index_index__["a" /* AddonModResourceIndexComponent */];
    };
    AddonModResourceModuleHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__resource__["a" /* AddonModResourceProvider */], __WEBPACK_IMPORTED_MODULE_4__core_course_providers_course__["a" /* CoreCourseProvider */],
            __WEBPACK_IMPORTED_MODULE_5__providers_utils_mimetype__["a" /* CoreMimetypeUtilsProvider */], __WEBPACK_IMPORTED_MODULE_2__helper__["a" /* AddonModResourceHelperProvider */]])
    ], AddonModResourceModuleHandler);
    return AddonModResourceModuleHandler;
}());

//# sourceMappingURL=module-handler.js.map

/***/ }),
/* 1261 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModResourceLinkHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_contentlinks_classes_module_index_handler__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_course_providers_helper__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__resource__ = __webpack_require__(108);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Handler to treat links to resource.
 */
var AddonModResourceLinkHandler = /** @class */ (function (_super) {
    __extends(AddonModResourceLinkHandler, _super);
    function AddonModResourceLinkHandler(courseHelper) {
        var _this = _super.call(this, courseHelper, __WEBPACK_IMPORTED_MODULE_3__resource__["a" /* AddonModResourceProvider */].COMPONENT, 'resource') || this;
        _this.name = 'AddonModResourceLinkHandler';
        return _this;
    }
    AddonModResourceLinkHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__core_course_providers_helper__["a" /* CoreCourseHelperProvider */]])
    ], AddonModResourceLinkHandler);
    return AddonModResourceLinkHandler;
}(__WEBPACK_IMPORTED_MODULE_1__core_contentlinks_classes_module_index_handler__["a" /* CoreContentLinksModuleIndexHandler */]));

//# sourceMappingURL=link-handler.js.map

/***/ }),
/* 1262 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModResourcePluginFileHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

/**
 * Handler to treat links to resource.
 */
var AddonModResourcePluginFileHandler = /** @class */ (function () {
    function AddonModResourcePluginFileHandler() {
        this.name = 'AddonModResourcePluginFileHandler';
    }
    /**
     * Return the RegExp to match the revision on pluginfile URLs.
     *
     * @param {string[]} args Arguments of the pluginfile URL defining component and filearea at least.
     * @return {RegExp} RegExp to match the revision on pluginfile URLs.
     */
    AddonModResourcePluginFileHandler.prototype.getComponentRevisionRegExp = function (args) {
        // Check filearea.
        if (args[2] == 'content') {
            // Component + Filearea + Revision
            return new RegExp('/mod_resource/content/([0-9]+)/');
        }
    };
    /**
     * Should return the string to remove the revision on pluginfile url.
     *
     * @param {string[]} args Arguments of the pluginfile URL defining component and filearea at least.
     * @return {string} String to remove the revision on pluginfile url.
     */
    AddonModResourcePluginFileHandler.prototype.getComponentRevisionReplace = function (args) {
        // Component + Filearea + Revision
        return '/mod_resource/content/0/';
    };
    AddonModResourcePluginFileHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])()
    ], AddonModResourcePluginFileHandler);
    return AddonModResourcePluginFileHandler;
}());

//# sourceMappingURL=pluginfile-handler.js.map

/***/ }),
/* 1263 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModFolderModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_folder__ = __webpack_require__(163);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_helper__ = __webpack_require__(598);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_module_handler__ = __webpack_require__(1264);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_course_providers_module_delegate__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__components_components_module__ = __webpack_require__(726);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_prefetch_handler__ = __webpack_require__(1265);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_link_handler__ = __webpack_require__(1266);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_pluginfile_handler__ = __webpack_require__(1267);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__core_contentlinks_providers_delegate__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__core_course_providers_module_prefetch_delegate__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_plugin_file_delegate__ = __webpack_require__(129);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};












var AddonModFolderModule = /** @class */ (function () {
    function AddonModFolderModule(moduleDelegate, moduleHandler, prefetchDelegate, prefetchHandler, contentLinksDelegate, linkHandler, pluginfileDelegate, pluginfileHandler) {
        moduleDelegate.registerHandler(moduleHandler);
        prefetchDelegate.registerHandler(prefetchHandler);
        contentLinksDelegate.registerHandler(linkHandler);
        pluginfileDelegate.registerHandler(pluginfileHandler);
    }
    AddonModFolderModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [
                __WEBPACK_IMPORTED_MODULE_5__components_components_module__["a" /* AddonModFolderComponentsModule */]
            ],
            providers: [
                __WEBPACK_IMPORTED_MODULE_1__providers_folder__["a" /* AddonModFolderProvider */],
                __WEBPACK_IMPORTED_MODULE_2__providers_helper__["a" /* AddonModFolderHelperProvider */],
                __WEBPACK_IMPORTED_MODULE_3__providers_module_handler__["a" /* AddonModFolderModuleHandler */],
                __WEBPACK_IMPORTED_MODULE_6__providers_prefetch_handler__["a" /* AddonModFolderPrefetchHandler */],
                __WEBPACK_IMPORTED_MODULE_7__providers_link_handler__["a" /* AddonModFolderLinkHandler */],
                __WEBPACK_IMPORTED_MODULE_8__providers_pluginfile_handler__["a" /* AddonModFolderPluginFileHandler */]
            ]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__core_course_providers_module_delegate__["a" /* CoreCourseModuleDelegate */], __WEBPACK_IMPORTED_MODULE_3__providers_module_handler__["a" /* AddonModFolderModuleHandler */],
            __WEBPACK_IMPORTED_MODULE_10__core_course_providers_module_prefetch_delegate__["a" /* CoreCourseModulePrefetchDelegate */], __WEBPACK_IMPORTED_MODULE_6__providers_prefetch_handler__["a" /* AddonModFolderPrefetchHandler */],
            __WEBPACK_IMPORTED_MODULE_9__core_contentlinks_providers_delegate__["a" /* CoreContentLinksDelegate */], __WEBPACK_IMPORTED_MODULE_7__providers_link_handler__["a" /* AddonModFolderLinkHandler */],
            __WEBPACK_IMPORTED_MODULE_11__providers_plugin_file_delegate__["a" /* CorePluginFileDelegate */], __WEBPACK_IMPORTED_MODULE_8__providers_pluginfile_handler__["a" /* AddonModFolderPluginFileHandler */]])
    ], AddonModFolderModule);
    return AddonModFolderModule;
}());

//# sourceMappingURL=folder.module.js.map

/***/ }),
/* 1264 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModFolderModuleHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_index_index__ = __webpack_require__(291);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_course_providers_course__ = __webpack_require__(14);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Handler to support folder modules.
 */
var AddonModFolderModuleHandler = /** @class */ (function () {
    function AddonModFolderModuleHandler(courseProvider) {
        this.courseProvider = courseProvider;
        this.name = 'folder';
    }
    /**
     * Check if the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} Whether or not the handler is enabled on a site level.
     */
    AddonModFolderModuleHandler.prototype.isEnabled = function () {
        return true;
    };
    /**
     * Get the data required to display the module in the course contents view.
     *
     * @param {any} module The module object.
     * @param {number} courseId The course ID.
     * @param {number} sectionId The section ID.
     * @return {CoreCourseModuleHandlerData} Data to render the module.
     */
    AddonModFolderModuleHandler.prototype.getData = function (module, courseId, sectionId) {
        return {
            icon: this.courseProvider.getModuleIconSrc('folder'),
            title: module.name,
            class: 'addon-mod_folder-handler',
            showDownloadButton: true,
            action: function (event, navCtrl, module, courseId, options) {
                navCtrl.push('AddonModFolderIndexPage', { module: module, courseId: courseId }, options);
            }
        };
    };
    /**
     * Get the component to render the module. This is needed to support singleactivity course format.
     * The component returned must implement CoreCourseModuleMainComponent.
     *
     * @param {any} course The course object.
     * @param {any} module The module object.
     * @return {any} The component to use, undefined if not found.
     */
    AddonModFolderModuleHandler.prototype.getMainComponent = function (course, module) {
        return __WEBPACK_IMPORTED_MODULE_1__components_index_index__["a" /* AddonModFolderIndexComponent */];
    };
    AddonModFolderModuleHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__core_course_providers_course__["a" /* CoreCourseProvider */]])
    ], AddonModFolderModuleHandler);
    return AddonModFolderModuleHandler;
}());

//# sourceMappingURL=module-handler.js.map

/***/ }),
/* 1265 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModFolderPrefetchHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_course_classes_module_prefetch_handler__ = __webpack_require__(106);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__folder__ = __webpack_require__(163);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



/**
 * Handler to prefetch folders.
 */
var AddonModFolderPrefetchHandler = /** @class */ (function (_super) {
    __extends(AddonModFolderPrefetchHandler, _super);
    function AddonModFolderPrefetchHandler(injector, folderProvider) {
        var _this = _super.call(this, injector) || this;
        _this.folderProvider = folderProvider;
        _this.name = 'folder';
        _this.component = __WEBPACK_IMPORTED_MODULE_2__folder__["a" /* AddonModFolderProvider */].COMPONENT;
        _this.isResource = true;
        return _this;
    }
    /**
     * Download or prefetch the content.
     *
     * @param {any} module The module object returned by WS.
     * @param {number} courseId Course ID.
     * @param {boolean} [prefetch] True to prefetch, false to download right away.
     * @param {string} [dirPath] Path of the directory where to store all the content files. This is to keep the files
     *                           relative paths and make the package work in an iframe. Undefined to download the files
     *                           in the filepool root folder.
     * @return {Promise<any>} Promise resolved when all content is downloaded. Data returned is not reliable.
     */
    AddonModFolderPrefetchHandler.prototype.downloadOrPrefetch = function (module, courseId, prefetch, dirPath) {
        var promises = [];
        promises.push(_super.prototype.downloadOrPrefetch.call(this, module, courseId, prefetch));
        if (this.folderProvider.isGetFolderWSAvailable()) {
            promises.push(this.folderProvider.getFolder(courseId, module.id));
        }
        return Promise.all(promises);
    };
    /**
     * Invalidate the prefetched content.
     *
     * @param {number} moduleId The module ID.
     * @param {number} courseId Course ID the module belongs to.
     * @return {Promise<any>} Promise resolved when the data is invalidated.
     */
    AddonModFolderPrefetchHandler.prototype.invalidateContent = function (moduleId, courseId) {
        return this.folderProvider.invalidateContent(moduleId, courseId);
    };
    /**
     * Invalidate WS calls needed to determine module status.
     *
     * @param {any} module Module.
     * @param {number} courseId Course ID the module belongs to.
     * @return {Promise<any>} Promise resolved when invalidated.
     */
    AddonModFolderPrefetchHandler.prototype.invalidateModule = function (module, courseId) {
        var promises = [];
        promises.push(this.folderProvider.invalidateFolderData(courseId));
        promises.push(this.courseProvider.invalidateModule(module.id));
        return Promise.all(promises);
    };
    AddonModFolderPrefetchHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["C" /* Injector */], __WEBPACK_IMPORTED_MODULE_2__folder__["a" /* AddonModFolderProvider */]])
    ], AddonModFolderPrefetchHandler);
    return AddonModFolderPrefetchHandler;
}(__WEBPACK_IMPORTED_MODULE_1__core_course_classes_module_prefetch_handler__["a" /* CoreCourseModulePrefetchHandlerBase */]));

//# sourceMappingURL=prefetch-handler.js.map

/***/ }),
/* 1266 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModFolderLinkHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_contentlinks_classes_module_index_handler__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_course_providers_helper__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__folder__ = __webpack_require__(163);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Handler to treat links to resource.
 */
var AddonModFolderLinkHandler = /** @class */ (function (_super) {
    __extends(AddonModFolderLinkHandler, _super);
    function AddonModFolderLinkHandler(courseHelper) {
        var _this = _super.call(this, courseHelper, __WEBPACK_IMPORTED_MODULE_3__folder__["a" /* AddonModFolderProvider */].COMPONENT, 'folder') || this;
        _this.name = 'AddonModFolderLinkHandler';
        return _this;
    }
    AddonModFolderLinkHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__core_course_providers_helper__["a" /* CoreCourseHelperProvider */]])
    ], AddonModFolderLinkHandler);
    return AddonModFolderLinkHandler;
}(__WEBPACK_IMPORTED_MODULE_1__core_contentlinks_classes_module_index_handler__["a" /* CoreContentLinksModuleIndexHandler */]));

//# sourceMappingURL=link-handler.js.map

/***/ }),
/* 1267 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModFolderPluginFileHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

/**
 * Handler to treat links to folder.
 */
var AddonModFolderPluginFileHandler = /** @class */ (function () {
    function AddonModFolderPluginFileHandler() {
        this.name = 'AddonModFolderPluginFileHandler';
    }
    /**
     * Return the RegExp to match the revision on pluginfile URLs.
     *
     * @param {string[]} args Arguments of the pluginfile URL defining component and filearea at least.
     * @return {RegExp} RegExp to match the revision on pluginfile URLs.
     */
    AddonModFolderPluginFileHandler.prototype.getComponentRevisionRegExp = function (args) {
        // Check filearea.
        if (args[2] == 'content') {
            // Component + Filearea + Revision
            return new RegExp('/mod_folder/content/([0-9]+)/');
        }
    };
    /**
     * Should return the string to remove the revision on pluginfile url.
     *
     * @param {string[]} args Arguments of the pluginfile URL defining component and filearea at least.
     * @return {string} String to remove the revision on pluginfile url.
     */
    AddonModFolderPluginFileHandler.prototype.getComponentRevisionReplace = function (args) {
        // Component + Filearea + Revision
        return '/mod_folder/content/0/';
    };
    AddonModFolderPluginFileHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])()
    ], AddonModFolderPluginFileHandler);
    return AddonModFolderPluginFileHandler;
}());

//# sourceMappingURL=pluginfile-handler.js.map

/***/ }),
/* 1268 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModPageModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_components_module__ = __webpack_require__(727);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_module_handler__ = __webpack_require__(1269);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_page__ = __webpack_require__(107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_prefetch_handler__ = __webpack_require__(599);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_link_handler__ = __webpack_require__(1270);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_pluginfile_handler__ = __webpack_require__(1271);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_helper__ = __webpack_require__(247);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__core_contentlinks_providers_delegate__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__core_course_providers_module_delegate__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__core_course_providers_module_prefetch_delegate__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_plugin_file_delegate__ = __webpack_require__(129);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};












var AddonModPageModule = /** @class */ (function () {
    function AddonModPageModule(moduleDelegate, moduleHandler, prefetchDelegate, prefetchHandler, contentLinksDelegate, linkHandler, pluginfileDelegate, pluginfileHandler) {
        moduleDelegate.registerHandler(moduleHandler);
        prefetchDelegate.registerHandler(prefetchHandler);
        contentLinksDelegate.registerHandler(linkHandler);
        pluginfileDelegate.registerHandler(pluginfileHandler);
    }
    AddonModPageModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1__components_components_module__["a" /* AddonModPageComponentsModule */]
            ],
            providers: [
                __WEBPACK_IMPORTED_MODULE_3__providers_page__["a" /* AddonModPageProvider */],
                __WEBPACK_IMPORTED_MODULE_2__providers_module_handler__["a" /* AddonModPageModuleHandler */],
                __WEBPACK_IMPORTED_MODULE_7__providers_helper__["a" /* AddonModPageHelperProvider */],
                __WEBPACK_IMPORTED_MODULE_4__providers_prefetch_handler__["a" /* AddonModPagePrefetchHandler */],
                __WEBPACK_IMPORTED_MODULE_5__providers_link_handler__["a" /* AddonModPageLinkHandler */],
                __WEBPACK_IMPORTED_MODULE_6__providers_pluginfile_handler__["a" /* AddonModPagePluginFileHandler */]
            ]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_9__core_course_providers_module_delegate__["a" /* CoreCourseModuleDelegate */], __WEBPACK_IMPORTED_MODULE_2__providers_module_handler__["a" /* AddonModPageModuleHandler */],
            __WEBPACK_IMPORTED_MODULE_10__core_course_providers_module_prefetch_delegate__["a" /* CoreCourseModulePrefetchDelegate */], __WEBPACK_IMPORTED_MODULE_4__providers_prefetch_handler__["a" /* AddonModPagePrefetchHandler */],
            __WEBPACK_IMPORTED_MODULE_8__core_contentlinks_providers_delegate__["a" /* CoreContentLinksDelegate */], __WEBPACK_IMPORTED_MODULE_5__providers_link_handler__["a" /* AddonModPageLinkHandler */],
            __WEBPACK_IMPORTED_MODULE_11__providers_plugin_file_delegate__["a" /* CorePluginFileDelegate */], __WEBPACK_IMPORTED_MODULE_6__providers_pluginfile_handler__["a" /* AddonModPagePluginFileHandler */]])
    ], AddonModPageModule);
    return AddonModPageModule;
}());

//# sourceMappingURL=page.module.js.map

/***/ }),
/* 1269 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModPageModuleHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__page__ = __webpack_require__(107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__components_index_index__ = __webpack_require__(292);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_course_providers_course__ = __webpack_require__(14);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Handler to support page modules.
 */
var AddonModPageModuleHandler = /** @class */ (function () {
    function AddonModPageModuleHandler(courseProvider, pageProvider) {
        this.courseProvider = courseProvider;
        this.pageProvider = pageProvider;
        this.name = 'page';
    }
    /**
     * Check if the handler is enabled on a site level.
     *
     * @return {boolean|Promise<boolean>} Whether or not the handler is enabled on a site level.
     */
    AddonModPageModuleHandler.prototype.isEnabled = function () {
        return this.pageProvider.isPluginEnabled();
    };
    /**
     * Get the data required to display the module in the course contents view.
     *
     * @param {any} module The module object.
     * @param {number} courseId The course ID.
     * @param {number} sectionId The section ID.
     * @return {CoreCourseModuleHandlerData} Data to render the module.
     */
    AddonModPageModuleHandler.prototype.getData = function (module, courseId, sectionId) {
        return {
            icon: this.courseProvider.getModuleIconSrc('page'),
            title: module.name,
            class: 'addon-mod_page-handler',
            showDownloadButton: true,
            action: function (event, navCtrl, module, courseId, options) {
                navCtrl.push('AddonModPageIndexPage', { module: module, courseId: courseId }, options);
            }
        };
    };
    /**
     * Get the component to render the module. This is needed to support singleactivity course format.
     * The component returned must implement CoreCourseModuleMainComponent.
     *
     * @param {any} course The course object.
     * @param {any} module The module object.
     * @return {any} The component to use, undefined if not found.
     */
    AddonModPageModuleHandler.prototype.getMainComponent = function (course, module) {
        return __WEBPACK_IMPORTED_MODULE_2__components_index_index__["a" /* AddonModPageIndexComponent */];
    };
    AddonModPageModuleHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__core_course_providers_course__["a" /* CoreCourseProvider */], __WEBPACK_IMPORTED_MODULE_1__page__["a" /* AddonModPageProvider */]])
    ], AddonModPageModuleHandler);
    return AddonModPageModuleHandler;
}());

//# sourceMappingURL=module-handler.js.map

/***/ }),
/* 1270 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModPageLinkHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_contentlinks_classes_module_index_handler__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_course_providers_helper__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__page__ = __webpack_require__(107);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Handler to treat links to resource.
 */
var AddonModPageLinkHandler = /** @class */ (function (_super) {
    __extends(AddonModPageLinkHandler, _super);
    function AddonModPageLinkHandler(courseHelper) {
        var _this = _super.call(this, courseHelper, __WEBPACK_IMPORTED_MODULE_3__page__["a" /* AddonModPageProvider */].COMPONENT, 'page') || this;
        _this.name = 'AddonModPageLinkHandler';
        return _this;
    }
    AddonModPageLinkHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__core_course_providers_helper__["a" /* CoreCourseHelperProvider */]])
    ], AddonModPageLinkHandler);
    return AddonModPageLinkHandler;
}(__WEBPACK_IMPORTED_MODULE_1__core_contentlinks_classes_module_index_handler__["a" /* CoreContentLinksModuleIndexHandler */]));

//# sourceMappingURL=link-handler.js.map

/***/ }),
/* 1271 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModPagePluginFileHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

/**
 * Handler to treat links to page.
 */
var AddonModPagePluginFileHandler = /** @class */ (function () {
    function AddonModPagePluginFileHandler() {
        this.name = 'AddonModPagePluginFileHandler';
    }
    /**
     * Return the RegExp to match the revision on pluginfile URLs.
     *
     * @param {string[]} args Arguments of the pluginfile URL defining component and filearea at least.
     * @return {RegExp} RegExp to match the revision on pluginfile URLs.
     */
    AddonModPagePluginFileHandler.prototype.getComponentRevisionRegExp = function (args) {
        // Check filearea.
        if (args[2] == 'content') {
            // Component + Filearea + Revision
            return new RegExp('/mod_page/content/([0-9]+)/');
        }
    };
    /**
     * Should return the string to remove the revision on pluginfile url.
     *
     * @param {string[]} args Arguments of the pluginfile URL defining component and filearea at least.
     * @return {string} String to remove the revision on pluginfile url.
     */
    AddonModPagePluginFileHandler.prototype.getComponentRevisionReplace = function (args) {
        // Component + Filearea + Revision
        return '/mod_page/content/0/';
    };
    AddonModPagePluginFileHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])()
    ], AddonModPagePluginFileHandler);
    return AddonModPagePluginFileHandler;
}());

//# sourceMappingURL=pluginfile-handler.js.map

/***/ }),
/* 1272 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModUrlModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_components_module__ = __webpack_require__(729);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_module_handler__ = __webpack_require__(1273);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_url__ = __webpack_require__(165);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_link_handler__ = __webpack_require__(1274);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_helper__ = __webpack_require__(248);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_contentlinks_providers_delegate__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_course_providers_module_delegate__ = __webpack_require__(61);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








var AddonModUrlModule = /** @class */ (function () {
    function AddonModUrlModule(moduleDelegate, moduleHandler, contentLinksDelegate, linkHandler) {
        moduleDelegate.registerHandler(moduleHandler);
        contentLinksDelegate.registerHandler(linkHandler);
    }
    AddonModUrlModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1__components_components_module__["a" /* AddonModUrlComponentsModule */]
            ],
            providers: [
                __WEBPACK_IMPORTED_MODULE_3__providers_url__["a" /* AddonModUrlProvider */],
                __WEBPACK_IMPORTED_MODULE_2__providers_module_handler__["a" /* AddonModUrlModuleHandler */],
                __WEBPACK_IMPORTED_MODULE_5__providers_helper__["a" /* AddonModUrlHelperProvider */],
                __WEBPACK_IMPORTED_MODULE_4__providers_link_handler__["a" /* AddonModUrlLinkHandler */]
            ]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_7__core_course_providers_module_delegate__["a" /* CoreCourseModuleDelegate */], __WEBPACK_IMPORTED_MODULE_2__providers_module_handler__["a" /* AddonModUrlModuleHandler */],
            __WEBPACK_IMPORTED_MODULE_6__core_contentlinks_providers_delegate__["a" /* CoreContentLinksDelegate */], __WEBPACK_IMPORTED_MODULE_4__providers_link_handler__["a" /* AddonModUrlLinkHandler */]])
    ], AddonModUrlModule);
    return AddonModUrlModule;
}());

//# sourceMappingURL=url.module.js.map

/***/ }),
/* 1273 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModUrlModuleHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_index_index__ = __webpack_require__(294);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_course_providers_course__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__url__ = __webpack_require__(165);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__helper__ = __webpack_require__(248);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Handler to support url modules.
 */
var AddonModUrlModuleHandler = /** @class */ (function () {
    function AddonModUrlModuleHandler(courseProvider, urlProvider, urlHelper) {
        this.courseProvider = courseProvider;
        this.urlProvider = urlProvider;
        this.urlHelper = urlHelper;
        this.name = 'url';
    }
    /**
     * Check if the handler is enabled on a site level.
     *
     * @return {boolean} Whether or not the handler is enabled on a site level.
     */
    AddonModUrlModuleHandler.prototype.isEnabled = function () {
        return true;
    };
    /**
     * Get the data required to display the module in the course contents view.
     *
     * @param {any} module The module object.
     * @param {number} courseId The course ID.
     * @param {number} sectionId The section ID.
     * @return {CoreCourseModuleHandlerData} Data to render the module.
     */
    AddonModUrlModuleHandler.prototype.getData = function (module, courseId, sectionId) {
        var _this = this;
        var handlerData = {
            icon: this.courseProvider.getModuleIconSrc('url'),
            title: module.name,
            class: 'addon-mod_url-handler',
            showDownloadButton: false,
            action: function (event, navCtrl, module, courseId, options) {
                navCtrl.push('AddonModUrlIndexPage', { module: module, courseId: courseId }, options);
            },
            buttons: [{
                    hidden: !(module.contents && module.contents[0] && module.contents[0].fileurl),
                    icon: 'link',
                    label: 'core.openinbrowser',
                    action: function (event, navCtrl, module, courseId) {
                        _this.hideLinkButton(module, courseId).then(function (hide) {
                            if (!hide) {
                                _this.urlProvider.logView(module.instance).then(function () {
                                    _this.courseProvider.checkModuleCompletion(courseId, module.completionstatus);
                                });
                                _this.urlHelper.open(module.contents[0].fileurl);
                            }
                        });
                    }
                }]
        };
        this.hideLinkButton(module, courseId).then(function (hideButton) {
            handlerData.buttons[0].hidden = hideButton;
        });
        return handlerData;
    };
    /**
     * Returns if contents are loaded to show link button.
     *
     * @param {any} module The module object.
     * @param {number} courseId The course ID.
     * @return {Promise<boolean>} Resolved when done.
     */
    AddonModUrlModuleHandler.prototype.hideLinkButton = function (module, courseId) {
        return this.courseProvider.loadModuleContents(module, courseId).then(function () {
            return !(module.contents && module.contents[0] && module.contents[0].fileurl);
        });
    };
    /**
     * Get the component to render the module. This is needed to support singleactivity course format.
     * The component returned must implement CoreCourseModuleMainComponent.
     *
     * @param {any} course The course object.
     * @param {any} module The module object.
     * @return {any} The component to use, undefined if not found.
     */
    AddonModUrlModuleHandler.prototype.getMainComponent = function (course, module) {
        return __WEBPACK_IMPORTED_MODULE_1__components_index_index__["a" /* AddonModUrlIndexComponent */];
    };
    AddonModUrlModuleHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__core_course_providers_course__["a" /* CoreCourseProvider */], __WEBPACK_IMPORTED_MODULE_3__url__["a" /* AddonModUrlProvider */],
            __WEBPACK_IMPORTED_MODULE_4__helper__["a" /* AddonModUrlHelperProvider */]])
    ], AddonModUrlModuleHandler);
    return AddonModUrlModuleHandler;
}());

//# sourceMappingURL=module-handler.js.map

/***/ }),
/* 1274 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonModUrlLinkHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_contentlinks_classes_module_index_handler__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_course_providers_helper__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__url__ = __webpack_require__(165);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Handler to treat links to url.
 */
var AddonModUrlLinkHandler = /** @class */ (function (_super) {
    __extends(AddonModUrlLinkHandler, _super);
    function AddonModUrlLinkHandler(courseHelper) {
        var _this = _super.call(this, courseHelper, __WEBPACK_IMPORTED_MODULE_3__url__["a" /* AddonModUrlProvider */].COMPONENT, 'url') || this;
        _this.name = 'AddonModUrlLinkHandler';
        return _this;
    }
    AddonModUrlLinkHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__core_course_providers_helper__["a" /* CoreCourseHelperProvider */]])
    ], AddonModUrlLinkHandler);
    return AddonModUrlLinkHandler;
}(__WEBPACK_IMPORTED_MODULE_1__core_contentlinks_classes_module_index_handler__["a" /* CoreContentLinksModuleIndexHandler */]));

//# sourceMappingURL=link-handler.js.map

/***/ }),
/* 1275 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonMessagesModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_network__ = __webpack_require__(103);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_messages__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_messages_offline__ = __webpack_require__(245);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_sync__ = __webpack_require__(289);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_mainmenu_handler__ = __webpack_require__(1276);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_mainmenu_providers_delegate__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_contentlinks_providers_delegate__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__core_user_providers_user_delegate__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_cron__ = __webpack_require__(696);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_user_send_message_handler__ = __webpack_require__(1277);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_user_add_contact_handler__ = __webpack_require__(702);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_user_block_contact_handler__ = __webpack_require__(703);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_discussion_link_handler__ = __webpack_require__(1278);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_index_link_handler__ = __webpack_require__(1279);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_sync_cron_handler__ = __webpack_require__(1280);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__providers_local_notifications__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__core_contentlinks_providers_helper__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__core_settings_providers_delegate__ = __webpack_require__(298);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__providers_settings_handler__ = __webpack_require__(1281);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__addon_pushnotifications_providers_delegate__ = __webpack_require__(136);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__providers_utils_utils__ = __webpack_require__(9);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
























var AddonMessagesModule = /** @class */ (function () {
    function AddonMessagesModule(mainMenuDelegate, mainmenuHandler, contentLinksDelegate, indexLinkHandler, discussionLinkHandler, sendMessageHandler, userDelegate, cronDelegate, syncHandler, network, messagesSync, appProvider, localNotifications, messagesProvider, sitesProvider, linkHelper, settingsHandler, settingsDelegate, pushNotificationsDelegate, utils, addContactHandler, blockContactHandler) {
        // Register handlers.
        mainMenuDelegate.registerHandler(mainmenuHandler);
        contentLinksDelegate.registerHandler(indexLinkHandler);
        contentLinksDelegate.registerHandler(discussionLinkHandler);
        userDelegate.registerHandler(sendMessageHandler);
        userDelegate.registerHandler(addContactHandler);
        userDelegate.registerHandler(blockContactHandler);
        cronDelegate.register(syncHandler);
        cronDelegate.register(mainmenuHandler);
        settingsDelegate.registerHandler(settingsHandler);
        // Sync some discussions when device goes online.
        network.onConnect().subscribe(function () {
            messagesSync.syncAllDiscussions(undefined, true);
        });
        var notificationClicked = function (notification) {
            messagesProvider.isMessagingEnabledForSite(notification.site).then(function () {
                sitesProvider.isFeatureDisabled('$mmSideMenuDelegate_mmaMessages', notification.site).then(function (disabled) {
                    if (disabled) {
                        // Messages are disabled, stop.
                        return;
                    }
                    messagesProvider.invalidateDiscussionsCache().finally(function () {
                        linkHelper.goInSite(undefined, 'AddonMessagesIndexPage', undefined, notification.site);
                    });
                });
            });
        };
        if (appProvider.isDesktop()) {
            // Listen for clicks in simulated push notifications.
            localNotifications.registerClick(__WEBPACK_IMPORTED_MODULE_2__providers_messages__["a" /* AddonMessagesProvider */].PUSH_SIMULATION_COMPONENT, notificationClicked);
        }
        // Register push notification clicks.
        pushNotificationsDelegate.on('click').subscribe(function (notification) {
            if (utils.isFalseOrZero(notification.notif)) {
                notificationClicked(notification);
                return true;
            }
        });
    }
    AddonMessagesModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [],
            providers: [
                __WEBPACK_IMPORTED_MODULE_2__providers_messages__["a" /* AddonMessagesProvider */],
                __WEBPACK_IMPORTED_MODULE_3__providers_messages_offline__["a" /* AddonMessagesOfflineProvider */],
                __WEBPACK_IMPORTED_MODULE_4__providers_sync__["a" /* AddonMessagesSyncProvider */],
                __WEBPACK_IMPORTED_MODULE_5__providers_mainmenu_handler__["a" /* AddonMessagesMainMenuHandler */],
                __WEBPACK_IMPORTED_MODULE_10__providers_user_send_message_handler__["a" /* AddonMessagesSendMessageUserHandler */],
                __WEBPACK_IMPORTED_MODULE_11__providers_user_add_contact_handler__["a" /* AddonMessagesAddContactUserHandler */],
                __WEBPACK_IMPORTED_MODULE_12__providers_user_block_contact_handler__["a" /* AddonMessagesBlockContactUserHandler */],
                __WEBPACK_IMPORTED_MODULE_13__providers_discussion_link_handler__["a" /* AddonMessagesDiscussionLinkHandler */],
                __WEBPACK_IMPORTED_MODULE_14__providers_index_link_handler__["a" /* AddonMessagesIndexLinkHandler */],
                __WEBPACK_IMPORTED_MODULE_15__providers_sync_cron_handler__["a" /* AddonMessagesSyncCronHandler */],
                __WEBPACK_IMPORTED_MODULE_21__providers_settings_handler__["a" /* AddonMessagesSettingsHandler */]
            ]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__core_mainmenu_providers_delegate__["a" /* CoreMainMenuDelegate */], __WEBPACK_IMPORTED_MODULE_5__providers_mainmenu_handler__["a" /* AddonMessagesMainMenuHandler */],
            __WEBPACK_IMPORTED_MODULE_7__core_contentlinks_providers_delegate__["a" /* CoreContentLinksDelegate */], __WEBPACK_IMPORTED_MODULE_14__providers_index_link_handler__["a" /* AddonMessagesIndexLinkHandler */],
            __WEBPACK_IMPORTED_MODULE_13__providers_discussion_link_handler__["a" /* AddonMessagesDiscussionLinkHandler */], __WEBPACK_IMPORTED_MODULE_10__providers_user_send_message_handler__["a" /* AddonMessagesSendMessageUserHandler */],
            __WEBPACK_IMPORTED_MODULE_8__core_user_providers_user_delegate__["a" /* CoreUserDelegate */], __WEBPACK_IMPORTED_MODULE_9__providers_cron__["a" /* CoreCronDelegate */], __WEBPACK_IMPORTED_MODULE_15__providers_sync_cron_handler__["a" /* AddonMessagesSyncCronHandler */],
            __WEBPACK_IMPORTED_MODULE_1__ionic_native_network__["a" /* Network */], __WEBPACK_IMPORTED_MODULE_4__providers_sync__["a" /* AddonMessagesSyncProvider */], __WEBPACK_IMPORTED_MODULE_16__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_18__providers_local_notifications__["a" /* CoreLocalNotificationsProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_messages__["a" /* AddonMessagesProvider */],
            __WEBPACK_IMPORTED_MODULE_17__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_19__core_contentlinks_providers_helper__["a" /* CoreContentLinksHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_21__providers_settings_handler__["a" /* AddonMessagesSettingsHandler */], __WEBPACK_IMPORTED_MODULE_20__core_settings_providers_delegate__["a" /* CoreSettingsDelegate */],
            __WEBPACK_IMPORTED_MODULE_22__addon_pushnotifications_providers_delegate__["a" /* AddonPushNotificationsDelegate */], __WEBPACK_IMPORTED_MODULE_23__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_11__providers_user_add_contact_handler__["a" /* AddonMessagesAddContactUserHandler */], __WEBPACK_IMPORTED_MODULE_12__providers_user_block_contact_handler__["a" /* AddonMessagesBlockContactUserHandler */]])
    ], AddonMessagesModule);
    return AddonMessagesModule;
}());

//# sourceMappingURL=messages.module.js.map

/***/ }),
/* 1276 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonMessagesMainMenuHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__messages__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_events__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_app__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_utils_text__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_local_notifications__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__addon_pushnotifications_providers_pushnotifications__ = __webpack_require__(295);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__addon_pushnotifications_providers_delegate__ = __webpack_require__(136);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};










/**
 * Handler to inject an option into main menu.
 */
var AddonMessagesMainMenuHandler = /** @class */ (function () {
    function AddonMessagesMainMenuHandler(messagesProvider, sitesProvider, eventsProvider, appProvider, localNotificationsProvider, textUtils, pushNotificationsProvider, utils, pushNotificationsDelegate) {
        var _this = this;
        this.messagesProvider = messagesProvider;
        this.sitesProvider = sitesProvider;
        this.eventsProvider = eventsProvider;
        this.appProvider = appProvider;
        this.localNotificationsProvider = localNotificationsProvider;
        this.textUtils = textUtils;
        this.pushNotificationsProvider = pushNotificationsProvider;
        this.name = 'AddonMessages';
        this.priority = 800;
        this.handler = {
            icon: 'chatbubbles',
            title: 'addon.messages.messages',
            page: 'AddonMessagesIndexPage',
            class: 'addon-messages-handler',
            showBadge: true,
            badge: '',
            loading: true
        };
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_1__messages__["a" /* AddonMessagesProvider */].READ_CHANGED_EVENT, function (data) {
            _this.updateBadge(data.siteId);
        });
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_1__messages__["a" /* AddonMessagesProvider */].READ_CRON_EVENT, function (data) {
            _this.updateBadge(data.siteId);
        });
        // Reset info on logout.
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_3__providers_events__["a" /* CoreEventsProvider */].LOGOUT, function (data) {
            _this.handler.badge = '';
            _this.handler.loading = true;
        });
        // If a message push notification is received, refresh the count.
        pushNotificationsDelegate.on('receive').subscribe(function (notification) {
            // New message received. If it's from current site, refresh the data.
            if (utils.isFalseOrZero(notification.notif) && _this.sitesProvider.isCurrentSite(notification.site)) {
                _this.updateBadge(notification.site);
            }
        });
        // Register Badge counter.
        pushNotificationsDelegate.registerCounterHandler('AddonMessages');
    }
    /**
     * Check if the handler is enabled on a site level.
     *
     * @return {boolean} Whether or not the handler is enabled on a site level.
     */
    AddonMessagesMainMenuHandler.prototype.isEnabled = function () {
        return this.messagesProvider.isPluginEnabled();
    };
    /**
     * Returns the data needed to render the handler.
     *
     * @return {CoreMainMenuHandlerToDisplay} Data needed to render the handler.
     */
    AddonMessagesMainMenuHandler.prototype.getDisplayData = function () {
        if (this.handler.loading) {
            this.updateBadge();
        }
        return this.handler;
    };
    /**
     * Triggers an update for the badge number and loading status. Mandatory if showBadge is enabled.
     *
     * @param {string} siteId Site ID or current Site if undefined.
     */
    AddonMessagesMainMenuHandler.prototype.updateBadge = function (siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (!siteId) {
            return;
        }
        this.messagesProvider.getUnreadConversationsCount(undefined, siteId).then(function (unread) {
            // Leave badge enter if there is a 0+ or a 0.
            _this.handler.badge = parseInt(unread, 10) > 0 ? unread : '';
            // Update badge.
            _this.pushNotificationsProvider.updateAddonCounter('AddonMessages', unread, siteId);
        }).catch(function () {
            _this.handler.badge = '';
        }).finally(function () {
            _this.handler.loading = false;
        });
    };
    /**
     * Execute the process.
     * Receives the ID of the site affected, undefined for all sites.
     *
     * @param  {string} [siteId] ID of the site affected, undefined for all sites.
     * @return {Promise<any>}         Promise resolved when done, rejected if failure.
     */
    AddonMessagesMainMenuHandler.prototype.execute = function (siteId) {
        if (this.sitesProvider.isCurrentSite(siteId)) {
            this.eventsProvider.trigger(__WEBPACK_IMPORTED_MODULE_1__messages__["a" /* AddonMessagesProvider */].READ_CRON_EVENT, undefined, siteId);
        }
        if (this.appProvider.isDesktop() && this.localNotificationsProvider.isAvailable()) {
            // @todo
            /*$mmEmulatorHelper.checkNewNotifications(
                    AddonMessagesProvider.PUSH_SIMULATION_COMPONENT, this.fetchMessages, this.getTitleAndText, siteId);*/
        }
        return Promise.resolve();
    };
    /**
     * Get the time between consecutive executions.
     *
     * @return {number} Time between consecutive executions (in ms).
     */
    AddonMessagesMainMenuHandler.prototype.getInterval = function () {
        return this.appProvider.isDesktop() ? 60000 : 600000; // 1 or 10 minutes.
    };
    /**
     * Whether it's a synchronization process or not.
     *
     * @return {boolean} True if is a sync process, false otherwise.
     */
    AddonMessagesMainMenuHandler.prototype.isSync = function () {
        // This is done to use only wifi if using the fallback function.
        // In desktop it is always sync, since it fetches messages to see if there's a new one.
        return !this.messagesProvider.isMessageCountEnabled() || this.appProvider.isDesktop();
    };
    /**
     * Whether the process should be executed during a manual sync.
     *
     * @return {boolean} True if is a manual sync process, false otherwise.
     */
    AddonMessagesMainMenuHandler.prototype.canManualSync = function () {
        return true;
    };
    /**
     * Get the latest unread received messages from a site.
     *
     * @param  {string} [siteId] Site ID. Default current.
     * @return {Promise<any>}    Promise resolved with the notifications.
     */
    AddonMessagesMainMenuHandler.prototype.fetchMessages = function (siteId) {
        return this.messagesProvider.getUnreadReceivedMessages(true, false, true, siteId).then(function (response) {
            return response.messages;
        });
    };
    /**
     * Given a message, return the title and the text for the message.
     *
     * @param  {any} message Message.
     * @return {Promise<any>}        Promise resolved with an object with title and text.
     */
    AddonMessagesMainMenuHandler.prototype.getTitleAndText = function (message) {
        var data = {
            title: message.userfromfullname,
        };
        return this.textUtils.formatText(message.text, true, true).catch(function () {
            return message.text;
        }).then(function (formattedText) {
            data['text'] = formattedText;
            return data;
        });
    };
    AddonMessagesMainMenuHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__messages__["a" /* AddonMessagesProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_events__["a" /* CoreEventsProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_app__["a" /* CoreAppProvider */],
            __WEBPACK_IMPORTED_MODULE_7__providers_local_notifications__["a" /* CoreLocalNotificationsProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_utils_text__["a" /* CoreTextUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_8__addon_pushnotifications_providers_pushnotifications__["a" /* AddonPushNotificationsProvider */], __WEBPACK_IMPORTED_MODULE_6__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_9__addon_pushnotifications_providers_delegate__["a" /* AddonPushNotificationsDelegate */]])
    ], AddonMessagesMainMenuHandler);
    return AddonMessagesMainMenuHandler;
}());

//# sourceMappingURL=mainmenu-handler.js.map

/***/ }),
/* 1277 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonMessagesSendMessageUserHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_user_providers_user_delegate__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_contentlinks_providers_helper__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__messages__ = __webpack_require__(70);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Profile send message handler.
 */
var AddonMessagesSendMessageUserHandler = /** @class */ (function () {
    function AddonMessagesSendMessageUserHandler(linkHelper, sitesProvider, messagesProvider) {
        this.linkHelper = linkHelper;
        this.sitesProvider = sitesProvider;
        this.messagesProvider = messagesProvider;
        this.name = 'AddonMessages:sendMessage';
        this.priority = 1000;
        this.type = __WEBPACK_IMPORTED_MODULE_1__core_user_providers_user_delegate__["a" /* CoreUserDelegate */].TYPE_COMMUNICATION;
    }
    /**
     * Check if handler is enabled.
     *
     * @return {Promise<any>} Promise resolved with true if enabled, rejected or resolved with false otherwise.
     */
    AddonMessagesSendMessageUserHandler.prototype.isEnabled = function () {
        return this.messagesProvider.isPluginEnabled();
    };
    /**
     * Check if handler is enabled for this user in this context.
     *
     * @param {any} user          User to check.
     * @param {number} courseId   Course ID.
     * @param  {any} [navOptions] Course navigation options for current user. See $mmCourses#getUserNavigationOptions.
     * @param  {any} [admOptions] Course admin options for current user. See $mmCourses#getUserAdministrationOptions.
     * @return  {boolean|Promise<boolean>}   Promise resolved with true if enabled, resolved with false otherwise.
     */
    AddonMessagesSendMessageUserHandler.prototype.isEnabledForUser = function (user, courseId, navOptions, admOptions) {
        return user.id != this.sitesProvider.getCurrentSiteUserId();
    };
    /**
     * Returns the data needed to render the handler.
     *
     * @return {CoreUserProfileHandlerData} Data needed to render the handler.
     */
    AddonMessagesSendMessageUserHandler.prototype.getDisplayData = function (user, courseId) {
        var _this = this;
        return {
            icon: 'send',
            title: 'addon.messages.message',
            class: 'addon-messages-send-message-handler',
            action: function (event, navCtrl, user, courseId) {
                event.preventDefault();
                event.stopPropagation();
                var pageParams = {
                    showKeyboard: true,
                    userId: user.id
                };
                // Always use redirect to make it the new history root (to avoid "loops" in history).
                _this.linkHelper.goInSite(navCtrl, 'AddonMessagesDiscussionPage', pageParams);
            }
        };
    };
    AddonMessagesSendMessageUserHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__core_contentlinks_providers_helper__["a" /* CoreContentLinksHelperProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_sites__["a" /* CoreSitesProvider */],
            __WEBPACK_IMPORTED_MODULE_4__messages__["a" /* AddonMessagesProvider */]])
    ], AddonMessagesSendMessageUserHandler);
    return AddonMessagesSendMessageUserHandler;
}());

//# sourceMappingURL=user-send-message-handler.js.map

/***/ }),
/* 1278 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonMessagesDiscussionLinkHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_contentlinks_classes_base_handler__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_contentlinks_providers_helper__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__messages__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_sites__ = __webpack_require__(3);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





/**
 * Content links handler for a discussion.
 * Match message index URL with params id, user1 or user2.
 */
var AddonMessagesDiscussionLinkHandler = /** @class */ (function (_super) {
    __extends(AddonMessagesDiscussionLinkHandler, _super);
    function AddonMessagesDiscussionLinkHandler(linkHelper, messagesProvider, sitesProvider) {
        var _this = _super.call(this) || this;
        _this.linkHelper = linkHelper;
        _this.messagesProvider = messagesProvider;
        _this.sitesProvider = sitesProvider;
        _this.name = 'AddonMessagesDiscussionLinkHandler';
        _this.pattern = /\/message\/index\.php.*([\?\&](id|user1|user2)=\d+)/;
        return _this;
    }
    /**
     * Get the list of actions for a link (url).
     *
     * @param {string[]} siteIds List of sites the URL belongs to.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {CoreContentLinksAction[]|Promise<CoreContentLinksAction[]>} List of (or promise resolved with list of) actions.
     */
    AddonMessagesDiscussionLinkHandler.prototype.getActions = function (siteIds, url, params, courseId) {
        var _this = this;
        return [{
                action: function (siteId, navCtrl) {
                    var stateParams = {
                        userId: parseInt(params.id || params.user2, 10)
                    };
                    // Always use redirect to make it the new history root (to avoid "loops" in history).
                    _this.linkHelper.goInSite(navCtrl, 'AddonMessagesDiscussionPage', stateParams, siteId);
                }
            }];
    };
    /**
     * Check if the handler is enabled for a certain site (site + user) and a URL.
     * If not defined, defaults to true.
     *
     * @param {string} siteId The site ID.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {boolean|Promise<boolean>} Whether the handler is enabled for the URL and site.
     */
    AddonMessagesDiscussionLinkHandler.prototype.isEnabled = function (siteId, url, params, courseId) {
        var _this = this;
        return this.messagesProvider.isPluginEnabled(siteId).then(function (enabled) {
            if (!enabled) {
                return false;
            }
            if (typeof params.id == 'undefined' && typeof params.user2 == 'undefined') {
                // Other user not defined, cannot treat the URL.
                return false;
            }
            if (typeof params.user1 != 'undefined') {
                // Check if user1 is the current user, since the app only supports current user.
                return _this.sitesProvider.getSite(siteId).then(function (site) {
                    return parseInt(params.user1, 10) == site.getUserId();
                });
            }
            return true;
        });
    };
    AddonMessagesDiscussionLinkHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__core_contentlinks_providers_helper__["a" /* CoreContentLinksHelperProvider */], __WEBPACK_IMPORTED_MODULE_3__messages__["a" /* AddonMessagesProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_sites__["a" /* CoreSitesProvider */]])
    ], AddonMessagesDiscussionLinkHandler);
    return AddonMessagesDiscussionLinkHandler;
}(__WEBPACK_IMPORTED_MODULE_1__core_contentlinks_classes_base_handler__["a" /* CoreContentLinksHandlerBase */]));

//# sourceMappingURL=discussion-link-handler.js.map

/***/ }),
/* 1279 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonMessagesIndexLinkHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_contentlinks_classes_base_handler__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_contentlinks_providers_helper__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__messages__ = __webpack_require__(70);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/**
 * Content links handler for messaging index.
 * Match message index URL without params id, user1 or user2.
 */
var AddonMessagesIndexLinkHandler = /** @class */ (function (_super) {
    __extends(AddonMessagesIndexLinkHandler, _super);
    function AddonMessagesIndexLinkHandler(linkHelper, messagesProvider) {
        var _this = _super.call(this) || this;
        _this.linkHelper = linkHelper;
        _this.messagesProvider = messagesProvider;
        _this.name = 'AddonMessagesIndexLinkHandler';
        _this.pattern = /\/message\/index\.php((?![\?\&](id|user1|user2)=\d+).)*$/;
        return _this;
    }
    /**
     * Get the list of actions for a link (url).
     *
     * @param {string[]} siteIds List of sites the URL belongs to.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {CoreContentLinksAction[]|Promise<CoreContentLinksAction[]>} List of (or promise resolved with list of) actions.
     */
    AddonMessagesIndexLinkHandler.prototype.getActions = function (siteIds, url, params, courseId) {
        var _this = this;
        return [{
                action: function (siteId, navCtrl) {
                    // Always use redirect to make it the new history root (to avoid "loops" in history).
                    _this.linkHelper.goInSite(navCtrl, 'AddonMessagesIndexPage', undefined, siteId);
                }
            }];
    };
    /**
     * Check if the handler is enabled for a certain site (site + user) and a URL.
     * If not defined, defaults to true.
     *
     * @param {string} siteId The site ID.
     * @param {string} url The URL to treat.
     * @param {any} params The params of the URL. E.g. 'mysite.com?id=1' -> {id: 1}
     * @param {number} [courseId] Course ID related to the URL. Optional but recommended.
     * @return {boolean|Promise<boolean>} Whether the handler is enabled for the URL and site.
     */
    AddonMessagesIndexLinkHandler.prototype.isEnabled = function (siteId, url, params, courseId) {
        return this.messagesProvider.isPluginEnabled(siteId);
    };
    AddonMessagesIndexLinkHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__core_contentlinks_providers_helper__["a" /* CoreContentLinksHelperProvider */], __WEBPACK_IMPORTED_MODULE_3__messages__["a" /* AddonMessagesProvider */]])
    ], AddonMessagesIndexLinkHandler);
    return AddonMessagesIndexLinkHandler;
}(__WEBPACK_IMPORTED_MODULE_1__core_contentlinks_classes_base_handler__["a" /* CoreContentLinksHandlerBase */]));

//# sourceMappingURL=index-link-handler.js.map

/***/ }),
/* 1280 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonMessagesSyncCronHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__sync__ = __webpack_require__(289);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Synchronization cron handler.
 */
var AddonMessagesSyncCronHandler = /** @class */ (function () {
    function AddonMessagesSyncCronHandler(messagesSync) {
        this.messagesSync = messagesSync;
        this.name = 'AddonMessagesSyncCronHandler';
    }
    /**
     * Execute the process.
     * Receives the ID of the site affected, undefined for all sites.
     *
     * @param  {string} [siteId] ID of the site affected, undefined for all sites.
     * @return {Promise<any>}         Promise resolved when done, rejected if failure.
     */
    AddonMessagesSyncCronHandler.prototype.execute = function (siteId) {
        return this.messagesSync.syncAllDiscussions(siteId);
    };
    /**
     * Get the time between consecutive executions.
     *
     * @return {number} Time between consecutive executions (in ms).
     */
    AddonMessagesSyncCronHandler.prototype.getInterval = function () {
        return 300000; // 5 minutes.
    };
    AddonMessagesSyncCronHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__sync__["a" /* AddonMessagesSyncProvider */]])
    ], AddonMessagesSyncCronHandler);
    return AddonMessagesSyncCronHandler;
}());

//# sourceMappingURL=sync-cron-handler.js.map

/***/ }),
/* 1281 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonMessagesSettingsHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__messages__ = __webpack_require__(70);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * Message settings handler.
 */
var AddonMessagesSettingsHandler = /** @class */ (function () {
    function AddonMessagesSettingsHandler(messagesProvider) {
        this.messagesProvider = messagesProvider;
        this.name = 'AddonMessages';
        this.priority = 600;
    }
    /**
     * Check if the handler is enabled on a site level.
     *
     * @return {boolean | Promise<boolean>} Whether or not the handler is enabled on a site level.
     */
    AddonMessagesSettingsHandler.prototype.isEnabled = function () {
        return this.messagesProvider.isMessagePreferencesEnabled();
    };
    /**
     * Returns the data needed to render the handler.
     *
     * @return {CoreSettingsHandlerData} Data needed to render the handler.
     */
    AddonMessagesSettingsHandler.prototype.getDisplayData = function () {
        return {
            icon: 'chatbubbles',
            title: 'addon.messages.messagepreferences',
            page: 'AddonMessagesSettingsPage',
            class: 'addon-messages-settings-handler'
        };
    };
    AddonMessagesSettingsHandler = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__messages__["a" /* AddonMessagesProvider */]])
    ], AddonMessagesSettingsHandler);
    return AddonMessagesSettingsHandler;
}());

//# sourceMappingURL=settings-handler.js.map

/***/ }),
/* 1282 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonPushNotificationsModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_pushnotifications__ = __webpack_require__(295);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_delegate__ = __webpack_require__(136);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_events__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_local_notifications__ = __webpack_require__(77);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};







var AddonPushNotificationsModule = /** @class */ (function () {
    function AddonPushNotificationsModule(platform, pushNotificationsProvider, eventsProvider, localNotificationsProvider, loggerProvider) {
        var logger = loggerProvider.getInstance('AddonPushNotificationsModule');
        // Register device on GCM or APNS server.
        platform.ready().then(function () {
            pushNotificationsProvider.registerDevice();
        });
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_4__providers_events__["a" /* CoreEventsProvider */].NOTIFICATION_SOUND_CHANGED, function () {
            // Notification sound has changed, register the device again to update the sound setting.
            pushNotificationsProvider.registerDevice();
        });
        // Register device on Moodle site when login.
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_4__providers_events__["a" /* CoreEventsProvider */].LOGIN, function () {
            pushNotificationsProvider.registerDeviceOnMoodle().catch(function (error) {
                logger.warn('Can\'t register device', error);
            });
        });
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_4__providers_events__["a" /* CoreEventsProvider */].SITE_DELETED, function (site) {
            pushNotificationsProvider.unregisterDeviceOnMoodle(site).catch(function (error) {
                logger.warn('Can\'t unregister device', error);
            });
            pushNotificationsProvider.cleanSiteCounters(site.id);
        });
        // Listen for local notification clicks (generated by the app).
        localNotificationsProvider.registerClick(__WEBPACK_IMPORTED_MODULE_2__providers_pushnotifications__["a" /* AddonPushNotificationsProvider */].COMPONENT, pushNotificationsProvider.notificationClicked);
    }
    AddonPushNotificationsModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [],
            providers: [
                __WEBPACK_IMPORTED_MODULE_2__providers_pushnotifications__["a" /* AddonPushNotificationsProvider */],
                __WEBPACK_IMPORTED_MODULE_3__providers_delegate__["a" /* AddonPushNotificationsDelegate */]
            ]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */], __WEBPACK_IMPORTED_MODULE_2__providers_pushnotifications__["a" /* AddonPushNotificationsProvider */], __WEBPACK_IMPORTED_MODULE_4__providers_events__["a" /* CoreEventsProvider */],
            __WEBPACK_IMPORTED_MODULE_6__providers_local_notifications__["a" /* CoreLocalNotificationsProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_logger__["a" /* CoreLoggerProvider */]])
    ], AddonPushNotificationsModule);
    return AddonPushNotificationsModule;
}());

//# sourceMappingURL=pushnotifications.module.js.map

/***/ }),
/* 1283 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonRemoteThemesModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_remotethemes__ = __webpack_require__(1284);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_events__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_init__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_sites__ = __webpack_require__(3);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





var AddonRemoteThemesModule = /** @class */ (function () {
    function AddonRemoteThemesModule(initDelegate, remoteThemesProvider, eventsProvider, sitesProvider) {
        // Preload the current site styles.
        initDelegate.registerProcess({
            name: 'AddonRemoteThemesPreloadCurrent',
            priority: __WEBPACK_IMPORTED_MODULE_3__providers_init__["a" /* CoreInitDelegate */].MAX_RECOMMENDED_PRIORITY + 250,
            blocking: true,
            load: remoteThemesProvider.preloadCurrentSite.bind(remoteThemesProvider)
        });
        // Preload the styles of the rest of sites.
        initDelegate.registerProcess({
            name: 'AddonRemoteThemesPreload',
            blocking: true,
            load: remoteThemesProvider.preloadSites.bind(remoteThemesProvider)
        });
        var addingSite, unloadTmpStyles;
        // When a new site is added to the app, add its styles.
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */].SITE_ADDED, function (data) {
            addingSite = data.siteId;
            remoteThemesProvider.addSite(data.siteId).finally(function () {
                if (addingSite == data.siteId) {
                    addingSite = false;
                }
                if (unloadTmpStyles == data.siteId) {
                    // This site had some tmp styles loaded, unload them.
                    remoteThemesProvider.unloadTmpStyles();
                }
            });
        });
        // Update styles when current site is updated.
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */].SITE_UPDATED, function (data) {
            if (data.siteId === sitesProvider.getCurrentSiteId()) {
                remoteThemesProvider.load(data.siteId);
            }
        });
        // Enable styles of current site on login.
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */].LOGIN, function (data) {
            remoteThemesProvider.enable(data.siteId);
        });
        // Disable added styles on logout.
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */].LOGOUT, function (data) {
            remoteThemesProvider.clear();
        });
        // Remove site styles when a site is deleted.
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */].SITE_DELETED, function (site) {
            remoteThemesProvider.removeSite(site.id);
        });
        // Load temporary styles when site config is checked in login.
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */].LOGIN_SITE_CHECKED, function (data) {
            remoteThemesProvider.loadTmpStyles(data.config.mobilecssurl);
        });
        // Unload temporary styles when site config is "unchecked" in login.
        eventsProvider.on(__WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */].LOGIN_SITE_UNCHECKED, function (data) {
            if (data.siteId && data.siteid == addingSite) {
                // The tmp styles are from a site that is being added permanently.
                // Wait for the final site styles to be loaded before removing the tmp styles so there is no blink effect.
                unloadTmpStyles = data.siteId;
            }
            else {
                // The tmp styles are from a site that wasn't added in the end. Just remove them.
                remoteThemesProvider.unloadTmpStyles();
            }
        });
    }
    AddonRemoteThemesModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["I" /* NgModule */])({
            declarations: [],
            imports: [],
            providers: [
                __WEBPACK_IMPORTED_MODULE_1__providers_remotethemes__["a" /* AddonRemoteThemesProvider */]
            ]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_init__["a" /* CoreInitDelegate */], __WEBPACK_IMPORTED_MODULE_1__providers_remotethemes__["a" /* AddonRemoteThemesProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_events__["a" /* CoreEventsProvider */],
            __WEBPACK_IMPORTED_MODULE_4__providers_sites__["a" /* CoreSitesProvider */]])
    ], AddonRemoteThemesModule);
    return AddonRemoteThemesModule;
}());

//# sourceMappingURL=remotethemes.module.js.map

/***/ }),
/* 1284 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddonRemoteThemesProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_http__ = __webpack_require__(105);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_file__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_filepool__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_sites__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_utils_dom__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_utils_text__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_utils_utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__core_constants__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_ts_md5_dist_md5__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_ts_md5_dist_md5___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_ts_md5_dist_md5__);
// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};











/**
 * Service to handle remote themes. A remote theme is a CSS sheet stored in the site that allows customising the Mobile app.
 */
var AddonRemoteThemesProvider = /** @class */ (function () {
    function AddonRemoteThemesProvider(logger, sitesProvider, fileProvider, filepoolProvider, http, utils, domUtils, textUtils) {
        this.sitesProvider = sitesProvider;
        this.fileProvider = fileProvider;
        this.filepoolProvider = filepoolProvider;
        this.http = http;
        this.utils = utils;
        this.domUtils = domUtils;
        this.textUtils = textUtils;
        this.SEPARATOR_35 = /\/\*\*? *3\.5(\.0)? *styles? *\*\//i; // A comment like "/* 3.5 styles */".
        this.stylesEls = {};
        this.logger = logger.getInstance('AddonRemoteThemesProvider');
    }
    AddonRemoteThemesProvider_1 = AddonRemoteThemesProvider;
    /**
     * Add a style element for a site and load the styles for that element. The style will be disabled.
     *
     * @param {string} siteId Site ID.
     * @return {Promise<any>} Promise resolved when added and loaded.
     */
    AddonRemoteThemesProvider.prototype.addSite = function (siteId) {
        if (!siteId || this.stylesEls[siteId]) {
            // Invalid site ID or style already added.
            return Promise.resolve();
        }
        // Create the style and add it to the header.
        var styleEl = document.createElement('style');
        styleEl.setAttribute('id', 'mobilecssurl-' + siteId);
        this.disableElement(styleEl, true);
        document.head.appendChild(styleEl);
        this.stylesEls[siteId] = {
            element: styleEl,
            hash: ''
        };
        return this.load(siteId, true);
    };
    /**
     * Clear styles added to the DOM, disabling them all.
     */
    AddonRemoteThemesProvider.prototype.clear = function () {
        var _this = this;
        // Disable all the styles.
        var styles = Array.from(document.querySelectorAll('style[id*=mobilecssurl]'));
        styles.forEach(function (style) {
            _this.disableElement(style, true);
        });
    };
    /**
     * Enabled or disable a certain style element.
     *
     * @param {HTMLStyleElement} element The element to enable or disable.
     * @param {boolean} disable Whether to disable or enable the element.
     */
    AddonRemoteThemesProvider.prototype.disableElement = function (element, disable) {
        // Setting disabled should be enough, but we also set the attribute so it can be seen in the DOM which ones are disabled.
        if (disable) {
            element.disabled = true;
            element.setAttribute('disabled', 'disabled');
        }
        else {
            element.disabled = false;
            element.removeAttribute('disabled');
        }
    };
    /**
     * Downloads a CSS file and remove old files if needed.
     *
     * @param {string} siteId Site ID.
     * @param {string} url File URL.
     * @return {Promise<any>} Promise resolved when the file is downloaded.
     */
    AddonRemoteThemesProvider.prototype.downloadFileAndRemoveOld = function (siteId, url) {
        var _this = this;
        // Check if the file is downloaded.
        return this.filepoolProvider.getFileStateByUrl(siteId, url).then(function (state) {
            return state !== __WEBPACK_IMPORTED_MODULE_9__core_constants__["a" /* CoreConstants */].NOT_DOWNLOADED;
        }).catch(function () {
            return true; // An error occurred while getting state (shouldn't happen). Don't delete downloaded file.
        }).then(function (isDownloaded) {
            if (!isDownloaded) {
                // File not downloaded, URL has changed or first time. Delete downloaded CSS files.
                return _this.filepoolProvider.removeFilesByComponent(siteId, AddonRemoteThemesProvider_1.COMPONENT, 1);
            }
        }).then(function () {
            return _this.filepoolProvider.downloadUrl(siteId, url, false, AddonRemoteThemesProvider_1.COMPONENT, 1);
        });
    };
    /**
     * Enable the styles of a certain site.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     */
    AddonRemoteThemesProvider.prototype.enable = function (siteId) {
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        if (this.stylesEls[siteId]) {
            this.disableElement(this.stylesEls[siteId].element, false);
        }
    };
    /**
     * Get remote styles of a certain site.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @return {Promise<{fileUrl: string, styles: string}>} Promise resolved with the styles and the URL of the CSS file.
     */
    AddonRemoteThemesProvider.prototype.get = function (siteId) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        var fileUrl;
        return this.sitesProvider.getSite(siteId).then(function (site) {
            var infos = site.getInfo();
            if (infos && infos.mobilecssurl) {
                fileUrl = infos.mobilecssurl;
                if (_this.fileProvider.isAvailable()) {
                    // The file system is available. Download the file and remove old CSS files if needed.
                    return _this.downloadFileAndRemoveOld(siteId, fileUrl);
                }
                else {
                    // Return the online URL.
                    return fileUrl;
                }
            }
            else {
                if (infos && infos.mobilecssurl === '') {
                    // CSS URL is empty. Delete downloaded files (if any).
                    _this.filepoolProvider.removeFilesByComponent(siteId, AddonRemoteThemesProvider_1.COMPONENT, 1);
                }
                return Promise.reject(null);
            }
        }).then(function (url) {
            _this.logger.debug('Loading styles from: ', url);
            // Get the CSS content using HTTP because we will treat the styles before saving them in the file.
            return _this.http.get(url).toPromise();
        }).then(function (response) {
            var text = response && response.text();
            if (typeof text == 'string') {
                return { fileUrl: fileUrl, styles: _this.get35Styles(text) };
            }
            else {
                return Promise.reject(null);
            }
        });
    };
    /**
     * Check if the CSS code has a separator for 3.5 styles. If it does, get only the styles after the separator.
     *
     * @param {string} cssCode The CSS code to check.
     * @return {string} The filtered styles.
     */
    AddonRemoteThemesProvider.prototype.get35Styles = function (cssCode) {
        var separatorPos = cssCode.search(this.SEPARATOR_35);
        if (separatorPos > -1) {
            return cssCode.substr(separatorPos).replace(this.SEPARATOR_35, '');
        }
        return cssCode;
    };
    /**
     * Load styles for a certain site.
     *
     * @param {string} [siteId] Site ID. If not defined, current site.
     * @param {boolean} [disabled] Whether loaded styles should be disabled.
     * @return {Promise<any>} Promise resolved when styles are loaded.
     */
    AddonRemoteThemesProvider.prototype.load = function (siteId, disabled) {
        var _this = this;
        siteId = siteId || this.sitesProvider.getCurrentSiteId();
        disabled = !!disabled;
        this.logger.debug('Load site', siteId, disabled);
        if (siteId && this.stylesEls[siteId]) {
            // Enable or disable the styles.
            this.disableElement(this.stylesEls[siteId].element, disabled);
            return this.get(siteId).then(function (data) {
                var hash = __WEBPACK_IMPORTED_MODULE_10_ts_md5_dist_md5__["Md5"].hashAsciiStr(data.styles);
                // Update the styles only if they have changed.
                if (_this.stylesEls[siteId].hash !== hash) {
                    _this.stylesEls[siteId].element.innerHTML = data.styles;
                    _this.stylesEls[siteId].hash = hash;
                    // Adding styles to a style element automatically enables it. Disable it again.
                    if (disabled) {
                        _this.disableElement(_this.stylesEls[siteId].element, true);
                    }
                }
                // Styles have been loaded, now treat the CSS.
                _this.treatCSSCode(siteId, data.fileUrl, data.styles).catch(function () {
                    // Ignore errors.
                });
            });
        }
        return Promise.reject(null);
    };
    /**
     * Load styles for a temporary site. These styles aren't prefetched.
     *
     * @param {string} url URL to get the styles from.
     * @return {Promise<any>} Promise resolved when loaded.
     */
    AddonRemoteThemesProvider.prototype.loadTmpStyles = function (url) {
        var _this = this;
        if (!url) {
            return Promise.resolve();
        }
        return this.http.get(url).toPromise().then(function (response) {
            var text = response && response.text();
            if (typeof text == 'string') {
                text = _this.get35Styles(text);
                var styleEl = document.createElement('style');
                styleEl.setAttribute('id', 'mobilecssurl-tmpsite');
                styleEl.innerHTML = text;
                document.head.appendChild(styleEl);
                _this.stylesEls.tmpsite = {
                    element: styleEl,
                    hash: ''
                };
            }
            else {
                return Promise.reject(null);
            }
        });
    };
    /**
     * Preload the styles of the current site (stored in DB).
     *
     * @return {Promise<any>} Promise resolved when loaded.
     */
    AddonRemoteThemesProvider.prototype.preloadCurrentSite = function () {
        var _this = this;
        return this.sitesProvider.getStoredCurrentSiteId().then(function (siteId) {
            return _this.addSite(siteId);
        });
    };
    /**
     * Preload the styles of all the stored sites.
     *
     * @return {Promise<any>} Promise resolved when loaded.
     */
    AddonRemoteThemesProvider.prototype.preloadSites = function () {
        var _this = this;
        return this.sitesProvider.getSitesIds().then(function (ids) {
            var promises = [];
            ids.forEach(function (siteId) {
                promises.push(_this.addSite(siteId));
            });
            return _this.utils.allPromises(promises);
        });
    };
    /**
     * Remove the styles of a certain site.
     *
     * @param {string} siteId Site ID.
     */
    AddonRemoteThemesProvider.prototype.removeSite = function (siteId) {
        if (siteId && this.stylesEls[siteId]) {
            document.head.removeChild(this.stylesEls[siteId].element);
            delete this.stylesEls[siteId];
        }
    };
    /**
     * Search for files in a CSS code and try to download them. Once downloaded, replace their URLs
     * and store the result in the CSS file.
     *
     * @param {string} siteId  Site ID.
     * @param {string} fileUrl CSS file URL.
     * @param {string} cssCode CSS code.
     * @return {Promise<string>} Promise resolved with the CSS code.
     */
    AddonRemoteThemesProvider.prototype.treatCSSCode = function (siteId, fileUrl, cssCode) {
        var _this = this;
        if (!this.fileProvider.isAvailable()) {
            return Promise.reject(null);
        }
        var urls = this.domUtils.extractUrlsFromCSS(cssCode), promises = [];
        var filePath, updated = false;
        // Get the path of the CSS file.
        promises.push(this.filepoolProvider.getFilePathByUrl(siteId, fileUrl).then(function (path) {
            filePath = path;
        }));
        urls.forEach(function (url) {
            // Download the file only if it's an online URL.
            if (url.indexOf('http') == 0) {
                promises.push(_this.filepoolProvider.downloadUrl(siteId, url, false, AddonRemoteThemesProvider_1.COMPONENT, 2)
                    .then(function (fileUrl) {
                    if (fileUrl != url) {
                        cssCode = cssCode.replace(new RegExp(_this.textUtils.escapeForRegex(url), 'g'), fileUrl);
                        updated = true;
                    }
                }).catch(function (error) {
                    // It shouldn't happen. Ignore errors.
                    _this.logger.warn('Error treating file ', url, error);
                }));
            }
        });
        return Promise.all(promises).then(function () {
            // All files downloaded. Store the result if it has changed.
            if (updated) {
                return _this.fileProvider.writeFile(filePath, cssCode);
            }
        }).then(function () {
            return cssCode;
        });
    };
    /**
     * Unload styles for a temporary site.
     */
    AddonRemoteThemesProvider.prototype.unloadTmpStyles = function () {
        return this.removeSite('tmpsite');
    };
    AddonRemoteThemesProvider.COMPONENT = 'mmaRemoteStyles';
    AddonRemoteThemesProvider = AddonRemoteThemesProvider_1 = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* Injectable */])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_logger__["a" /* CoreLoggerProvider */], __WEBPACK_IMPORTED_MODULE_5__providers_sites__["a" /* CoreSitesProvider */], __WEBPACK_IMPORTED_MODULE_2__providers_file__["a" /* CoreFileProvider */],
            __WEBPACK_IMPORTED_MODULE_3__providers_filepool__["a" /* CoreFilepoolProvider */], __WEBPACK_IMPORTED_MODULE_1__angular_http__["a" /* Http */], __WEBPACK_IMPORTED_MODULE_8__providers_utils_utils__["a" /* CoreUtilsProvider */],
            __WEBPACK_IMPORTED_MODULE_6__providers_utils_dom__["a" /* CoreDomUtilsProvider */], __WEBPACK_IMPORTED_MODULE_7__providers_utils_text__["a" /* CoreTextUtilsProvider */]])
    ], AddonRemoteThemesProvider);
    return AddonRemoteThemesProvider;
    var AddonRemoteThemesProvider_1;
}());

//# sourceMappingURL=remotethemes.js.map

/***/ })
],[730]);
//# sourceMappingURL=main.js.map