// (C) Copyright 2015 Martin Dougiamas
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

angular.module('mm', ['ionic', 'mm.core', 'mm.core.comments', 'mm.core.contentlinks', 'mm.core.course', 'mm.core.courses', 'mm.core.fileuploader', 'mm.core.grades', 'mm.core.login', 'mm.core.question', 'mm.core.settings', 'mm.core.sharedfiles', 'mm.core.sidemenu', 'mm.core.textviewer', 'mm.core.user', 'mm.addons.badges', 'mm.addons.calendar', 'mm.addons.competency', 'mm.addons.coursecompletion', 'mm.addons.files', 'mm.addons.frontpage', 'mm.addons.grades', 'mm.addons.messageoutput', 'mm.addons.messages', 'mm.addons.notes', 'mm.addons.notifications', 'mm.addons.participants', 'mm.addons.pushnotifications', 'mm.addons.remotestyles', 'mm.addons.messageoutput_airnotifier', 'mm.addons.mod_book', 'mm.addons.mod_assign', 'mm.addons.mod_chat', 'mm.addons.mod_choice', 'mm.addons.mod_folder', 'mm.addons.mod_forum', 'mm.addons.mod_glossary', 'mm.addons.mod_imscp', 'mm.addons.mod_label', 'mm.addons.mod_lti', 'mm.addons.mod_page', 'mm.addons.mod_quiz', 'mm.addons.mod_resource', 'mm.addons.mod_scorm', 'mm.addons.mod_survey', 'mm.addons.mod_url', 'mm.addons.mod_wiki', 'mm.addons.qbehaviour_adaptive', 'mm.addons.qbehaviour_adaptivenopenalty', 'mm.addons.qbehaviour_deferredfeedback', 'mm.addons.qbehaviour_deferredcbm', 'mm.addons.qbehaviour_immediatecbm', 'mm.addons.qbehaviour_immediatefeedback', 'mm.addons.qbehaviour_informationitem', 'mm.addons.qbehaviour_interactive', 'mm.addons.qbehaviour_interactivecountback', 'mm.addons.qbehaviour_manualgraded', 'mm.addons.qtype_calculated', 'mm.addons.qtype_calculatedsimple', 'mm.addons.qtype_calculatedmulti', 'mm.addons.qtype_ddimageortext', 'mm.addons.qtype_ddmarker', 'mm.addons.qtype_ddwtos', 'mm.addons.qtype_description', 'mm.addons.qtype_essay', 'mm.addons.qtype_gapselect', 'mm.addons.qtype_match', 'mm.addons.qtype_multianswer', 'mm.addons.qtype_numerical', 'mm.addons.qtype_multichoice', 'mm.addons.qtype_randomsamatch', 'mm.addons.qtype_shortanswer', 'mm.addons.qtype_truefalse', 'mm.addons.userprofilefield_checkbox', 'mm.addons.userprofilefield_datetime', 'mm.addons.userprofilefield_menu', 'mm.addons.userprofilefield_text', 'mm.addons.userprofilefield_textarea', 'ngCordova', 'angular-md5', 'pascalprecht.translate', 'ngAria', 'oc.lazyLoad', 'ckeditor',
            'ngMessages'])
.run(["$ionicPlatform", function($ionicPlatform) {
    $ionicPlatform.ready(function() {
        if (window.cordova && window.cordova.plugins && window.cordova.plugins.Keyboard) {
            window.cordova.plugins.Keyboard.hideKeyboardAccessoryBar(false);
            window.cordova.plugins.Keyboard.disableScroll(true);
        }
        if (window.StatusBar) {
            StatusBar.styleDefault();
        }
    });
}]);

angular.module('mm.core', ['pascalprecht.translate'])
.constant('mmCoreSessionExpired', 'mmCoreSessionExpired')
.constant('mmCoreUserDeleted', 'mmCoreUserDeleted')
.constant('mmCoreUserPasswordChangeForced', 'mmCoreUserPasswordChangeForced')
.constant('mmCoreUserNotFullySetup', 'mmCoreUserNotFullySetup')
.constant('mmCoreSitePolicyNotAgreed', 'mmCoreSitePolicyNotAgreed')
.constant('mmCoreUnicodeNotSupported', 'mmCoreUnicodeNotSupported')
.constant('mmCoreSecondsYear', 31536000)
.constant('mmCoreSecondsDay', 86400)
.constant('mmCoreSecondsHour', 3600)
.constant('mmCoreSecondsMinute', 60)
.constant('mmCoreDownloaded', 'downloaded')
.constant('mmCoreDownloading', 'downloading')
.constant('mmCoreNotDownloaded', 'notdownloaded')
.constant('mmCoreOutdated', 'outdated')
.constant('mmCoreNotDownloadable', 'notdownloadable')
.constant('mmCoreWifiDownloadThreshold', 104857600)
.constant('mmCoreDownloadThreshold', 10485760)
.config(["$stateProvider", "$provide", "$ionicConfigProvider", "$httpProvider", "$mmUtilProvider", "$mmLogProvider", "$compileProvider", "$mmInitDelegateProvider", "mmInitDelegateMaxAddonPriority", function($stateProvider, $provide, $ionicConfigProvider, $httpProvider, $mmUtilProvider,
        $mmLogProvider, $compileProvider, $mmInitDelegateProvider, mmInitDelegateMaxAddonPriority) {
    $ionicConfigProvider.platform.android.tabs.position('bottom');
    $ionicConfigProvider.form.checkbox('circle');
    $ionicConfigProvider.scrolling.jsScrolling(true);
    if (!ionic.Platform.isAndroid()) {
        $ionicConfigProvider.backButton.text("{{'mm.core.back' | translate}}");
    }
    $provide.decorator('$ionicPlatform', ['$delegate', '$window', function($delegate, $window) {
        $delegate.isTablet = function() {
            var mq = 'only screen and (min-width: 768px) and (-webkit-min-device-pixel-ratio: 1)';
            return $window.matchMedia(mq).matches;
        };
        return $delegate;
    }]);
    $provide.decorator('ionRadioDirective', ['$delegate', function($delegate) {
        var directive = $delegate[0];
        transcludeRegex = /ng-transclude/
        directive.template =  directive.template.replace(transcludeRegex, 'ng-transclude data-tap-disabled="true"');
        return $delegate;
    }]);
    $provide.decorator('ionCheckboxDirective', ['$delegate', function($delegate) {
        var directive = $delegate[0];
        transcludeRegex = /ng-transclude/
        directive.template =  directive.template.replace(transcludeRegex, 'ng-transclude data-tap-disabled="true"');
        return $delegate;
    }]);
        $provide.decorator('$log', ['$delegate', $mmLogProvider.logDecorator]);
    $stateProvider
        .state('redirect', {
            url: '/redirect',
            params: {
                siteid: null,
                state: null,
                params: null
            },
            cache: false,
            template: '<ion-view><ion-content mm-state-class><mm-loading class="mm-loading-center"></mm-loading></ion-content></ion-view>',
            controller: ["$scope", "$state", "$stateParams", "$mmSite", "$mmSitesManager", "$ionicHistory", "$mmAddonManager", "$mmApp", "$mmLoginHelper", function($scope, $state, $stateParams, $mmSite, $mmSitesManager, $ionicHistory, $mmAddonManager, $mmApp,
                        $mmLoginHelper) {
                $ionicHistory.nextViewOptions({disableBack: true});
                function loadSiteAndGo() {
                    $mmSitesManager.loadSite($stateParams.siteid).then(function() {
                        if (!$mmLoginHelper.isSiteLoggedOut($stateParams.state, $stateParams.params)) {
                            $state.go($stateParams.state, $stateParams.params);
                        }
                    }, function() {
                        $state.go('mm_login.sites');
                    });
                }
                $scope.$on('$ionicView.enter', function() {
                    if ($mmSite.isLoggedIn()) {
                        if ($stateParams.siteid && $stateParams.siteid != $mmSite.getId()) {
                            if ($mmAddonManager.hasRemoteAddonsLoaded()) {
                                $mmApp.storeRedirect($stateParams.siteid, $stateParams.state, $stateParams.params);
                                $mmSitesManager.logout();
                            } else {
                                $mmSitesManager.logout().then(function() {
                                    loadSiteAndGo();
                                });
                            }
                        } else {
                            $state.go($stateParams.state, $stateParams.params);
                        }
                    } else {
                        if ($stateParams.siteid) {
                            loadSiteAndGo();
                        } else {
                            $state.go('mm_login.sites');
                        }
                    }
                });
            }]
        });
    $httpProvider.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded;charset=utf-8';
    $httpProvider.defaults.transformRequest = [function(data) {
        return angular.isObject(data) && String(data) !== '[object File]' ? $mmUtilProvider.param(data) : data;
    }];
    function addProtocolIfMissing(list, protocol) {
        if (list.indexOf(protocol) == -1) {
            list = list.replace('https?', 'https?|' + protocol);
        }
        return list;
    }
    var hreflist = $compileProvider.aHrefSanitizationWhitelist().source,
        imglist = $compileProvider.imgSrcSanitizationWhitelist().source;
    hreflist = addProtocolIfMissing(hreflist, 'file');
    hreflist = addProtocolIfMissing(hreflist, 'tel');
    hreflist = addProtocolIfMissing(hreflist, 'mailto');
    hreflist = addProtocolIfMissing(hreflist, 'geo');
    hreflist = addProtocolIfMissing(hreflist, 'filesystem');
    imglist = addProtocolIfMissing(imglist, 'filesystem');
    imglist = addProtocolIfMissing(imglist, 'file');
    imglist = addProtocolIfMissing(imglist, 'cdvfile');
    moment.relativeTimeThreshold('M', 12);
    moment.relativeTimeThreshold('d', 31);
    moment.relativeTimeThreshold('h', 24);
    moment.relativeTimeThreshold('m', 60);
    moment.relativeTimeThreshold('s', 60);
    $compileProvider.aHrefSanitizationWhitelist(hreflist);
    $compileProvider.imgSrcSanitizationWhitelist(imglist);
    $mmInitDelegateProvider.registerProcess('mmAppInit', '$mmApp.initProcess', mmInitDelegateMaxAddonPriority + 400, true);
    $mmInitDelegateProvider.registerProcess('mmUpdateManager', '$mmUpdateManager.check', mmInitDelegateMaxAddonPriority + 300, true);
    $mmInitDelegateProvider.registerProcess('mmFSClearTmp', '$mmFS.clearTmpFolder', mmInitDelegateMaxAddonPriority + 150, false);
}])
.run(["$ionicPlatform", "$ionicBody", "$window", "$mmEvents", "$mmInitDelegate", "mmCoreEventKeyboardShow", "mmCoreEventKeyboardHide", "$mmApp", "$timeout", "mmCoreEventOnline", "mmCoreEventOnlineStatusChanged", "$mmUtil", "$ionicScrollDelegate", function($ionicPlatform, $ionicBody, $window, $mmEvents, $mmInitDelegate, mmCoreEventKeyboardShow, mmCoreEventKeyboardHide,
        $mmApp, $timeout, mmCoreEventOnline, mmCoreEventOnlineStatusChanged, $mmUtil, $ionicScrollDelegate) {
    $mmInitDelegate.executeInitProcesses();
    $ionicPlatform.ready(function() {
        var checkTablet = function() {
            $ionicBody.enableClass($ionicPlatform.isTablet(), 'tablet');
        };
        ionic.on('resize', checkTablet, $window);
        checkTablet();
        $window.addEventListener('native.keyboardshow', function(e) {
            $mmEvents.trigger(mmCoreEventKeyboardShow, e);
            if (ionic.Platform.isIOS()) {
                ionic.trigger('resize');
            }
            if (ionic.Platform.isIOS() && document.activeElement && document.activeElement.tagName != 'BODY') {
                if ($mmUtil.closest(document.activeElement, 'ion-footer-bar[keyboard-attach]')) {
                    return;
                }
                if ($mmUtil.isElementOutsideOfScreen(document.activeElement)) {
                    var position = $mmUtil.getElementXY(document.activeElement),
                        delegateHandle = $mmUtil.closest(document.activeElement, '*[delegate-handle]'),
                        scrollView;
                    if (position) {
                        if ($window && $window.innerHeight) {
                            position[1] = position[1] - $window.innerHeight * 0.5;
                        }
                        delegateHandle = delegateHandle && delegateHandle.getAttribute('delegate-handle');
                        scrollView = typeof delegateHandle == 'string' ?
                                $ionicScrollDelegate.$getByHandle(delegateHandle) : $ionicScrollDelegate;
                        $ionicScrollDelegate.scrollTo(position[0], position[1]);
                    }
                }
            }
        });
        $window.addEventListener('native.keyboardhide', function(e) {
            $mmEvents.trigger(mmCoreEventKeyboardHide, e);
            if (ionic.Platform.isIOS()) {
                ionic.trigger('resize');
            }
        });
    });
    var lastExecution = 0;
    $mmApp.ready().then(function() {
        document.addEventListener('online', function() { sendOnlineEvent(true); }, false);
        window.addEventListener('online', function() { sendOnlineEvent(true); }, false);
        document.addEventListener('offline', function() { sendOnlineEvent(false); }, false);
        window.addEventListener('offline', function() { sendOnlineEvent(false); }, false);
    });
    function sendOnlineEvent(online) {
        var now = new Date().getTime();
        if (now - lastExecution < 5000) {
            return;
        }
        lastExecution = now;
        $timeout(function() {
            if (online) {
                $mmEvents.trigger(mmCoreEventOnline);
            }
            $mmEvents.trigger(mmCoreEventOnlineStatusChanged, online);
        }, 1000);
    }
}]);

angular.module('mm.core')
.constant('mmAddonManagerComponent', 'mmAddonManager')
.factory('$mmAddonManager', ["$log", "$injector", "$ocLazyLoad", "$mmFilepool", "$mmSite", "$mmFS", "$mmLang", "$mmSitesManager", "$q", "$mmUtil", "$mmApp", "mmAddonManagerComponent", "mmCoreNotDownloaded", function($log, $injector, $ocLazyLoad, $mmFilepool, $mmSite, $mmFS, $mmLang, $mmSitesManager, $q,
            $mmUtil, $mmApp, mmAddonManagerComponent, mmCoreNotDownloaded) {
    $log = $log.getInstance('$mmAddonManager');
    var self = {},
        instances = {},
        remoteAddonsFolderName = 'remoteaddons',
        remoteAddonFilename = 'addon.js',
        remoteAddonCssFilename = 'styles.css',
        pathWildcardRegex = /\$ADDONPATH\$/g,
        headEl = angular.element(document.querySelector('head')),
        loadedAddons = [],
        loadedModules = [];
        self.downloadRemoteAddon = function(addon, siteId) {
        siteId = siteId || $mmSite.getId();
        var name = self.getRemoteAddonName(addon),
            dirPath = self.getRemoteAddonDirectoryPath(addon),
            revision = addon.filehash,
            file = {
                filename: name + '.zip',
                fileurl: addon.fileurl
            };
        return $mmFilepool.getPackageStatus(siteId, mmAddonManagerComponent, name, revision, 0).then(function(status) {
            if (status !== $mmFilepool.FILEDOWNLOADED) {
                return $mmFilepool.downloadPackage(siteId, [file], mmAddonManagerComponent, name, revision, 0).then(function() {
                    return $mmFS.removeDir(dirPath).catch(function() {});
                }).then(function() {
                    return $mmFilepool.getFilePathByUrl(siteId, addon.fileurl);
                }).then(function(zipPath) {
                    return $mmFS.unzipFile(zipPath, dirPath).then(function() {
                        return $mmFilepool.removeFileByUrl(siteId, addon.fileurl).catch(function() {});
                    });
                }).then(function() {
                    return $mmFS.getDir(dirPath);
                }).then(function(dir) {
                    var absoluteDirPath = $mmFS.getInternalURL(dir);
                    if (absoluteDirPath.slice(-1) == '/') {
                        absoluteDirPath = absoluteDirPath.substring(0, absoluteDirPath.length - 1);
                    }
                    var addonMainFile = $mmFS.concatenatePaths(dirPath, remoteAddonFilename);
                    return $mmFS.replaceInFile(addonMainFile, pathWildcardRegex, absoluteDirPath);
                }).catch(function() {
                    return self.setRemoteAddonStatus(addon, status).then(function() {
                        return $q.reject();
                    });
                });
            }
        });
    };
        self.downloadRemoteAddons = function(siteId) {
        siteId = siteId || $mmSite.getId();
        var downloaded = {},
            preSets = {};
        return $mmSitesManager.getSite(siteId).then(function(site) {
            preSets.getFromCache = 0;
            return site.read('tool_mobile_get_plugins_supporting_mobile', {}, preSets).then(function(data) {
                var promises = [];
                angular.forEach(data.plugins, function(addon) {
                    if (site.isFeatureDisabled('remoteAddOn_' + addon.component + '_' + addon.addon)) {
                        return;
                    }
                    promises.push(self.downloadRemoteAddon(addon, siteId).then(function() {
                        downloaded[addon.addon]= addon;
                    }));
                });
                return $mmUtil.allPromises(promises).then(function() {
                    return downloaded;
                }).catch(function() {
                    return downloaded;
                });
            });
        });
    };
        self.get = function(name) {
        if (self.isAvailable(name)) {
            return instances[name];
        }
    };
        self.getRemoteAddonDirectoryPath = function(addon, siteId) {
        siteId = siteId || $mmSite.getId();
        var subPath = remoteAddonsFolderName + '/' + self.getRemoteAddonName(addon);
        return $mmFS.concatenatePaths($mmFilepool.getFilepoolFolderPath(siteId), subPath);
    };
        self.getRemoteAddonName = function(addon) {
        return addon.component + '_' + addon.addon;
    };
        self.hasRemoteAddonsLoaded = function() {
        return loadedAddons.length;
    };
        self.isAvailable = function(name) {
        if (!name) {
            return false;
        }
        if (instances[name]) {
            return true;
        }
        try {
            instances[name] = $injector.get(name);
            return true;
        } catch(ex) {
            $log.warn('Service not available: '+name);
            return false;
        }
    };
        self.loadRemoteAddon = function(addon) {
        var dirPath = self.getRemoteAddonDirectoryPath(addon),
            absoluteDirPath;
        return $mmFS.getDir(dirPath).then(function(dir) {
            absoluteDirPath = $mmFS.getInternalURL(dir);
            return $mmFS.getDir($mmFS.concatenatePaths(dirPath, 'lang')).then(function() {
                return $mmLang.registerLanguageFolder($mmFS.concatenatePaths(absoluteDirPath, 'lang'));
            }).catch(function() {
            }).then(function() {
                return $ocLazyLoad.load($mmFS.concatenatePaths(absoluteDirPath, remoteAddonFilename));
            }).then(function() {
                loadedAddons.push(addon);
                $mmApp.trustResources($mmFS.concatenatePaths(absoluteDirPath, '**'));
                return $mmFS.getFile($mmFS.concatenatePaths(dirPath, remoteAddonCssFilename)).then(function(file) {
                    headEl.append('<link class="remoteaddonstyles" rel="stylesheet" href="' + $mmFS.getInternalURL(file) + '">');
                }).catch(function() {});
            });
        }, function() {
            return self.setRemoteAddonStatus(addon, mmCoreNotDownloaded).then(function() {
                return $q.reject();
            });
        });
    };
        self.loadRemoteAddons = function(addons) {
        var promises = [];
        loadedModules = $ocLazyLoad.getModules();
        angular.forEach(addons, function(addon) {
            self.setRemoteAddonLoadPromise(addons, addon);
            if (addon.loadPromise) {
                promises.push(addon.loadPromise);
            }
        });
        return $mmUtil.allPromises(promises);
    };
        self.setRemoteAddonLoadPromise = function(addons, addon, dependants) {
        if (typeof addon.loadPromise != 'undefined') {
            return;
        }
        dependants = dependants || [];
        var promises = [],
            stop = false;
        angular.forEach(addon.dependencies, function(dependency) {
            if (stop) {
                return;
            }
            if (dependency == addon.addon) {
                return;
            }
            if (dependants.indexOf(dependency) != -1) {
                stop = true;
                return;
            }
            if (!addons[dependency]) {
                if (dependency.indexOf('mm.addons.') == -1) {
                    dependency = 'mm.addons.' + dependency;
                }
                if (loadedModules.indexOf(dependency) == -1) {
                    stop = true;
                }
            } else {
                self.setRemoteAddonLoadPromise(addons, addons[dependency], dependants.concat(addon.addon));
                if (!addons[dependency].loadPromise) {
                    stop = true;
                } else {
                    promises.push(addons[dependency].loadPromise);
                }
            }
        });
        if (!stop) {
            addon.loadPromise = $q.all(promises).then(function() {
                return self.loadRemoteAddon(addon);
            });
        } else {
            addon.loadPromise = false;
        }
    };
        self.setRemoteAddonStatus = function(addon, status, siteId) {
        siteId = siteId || $mmSite.getId();
        var name = self.getRemoteAddonName(addon),
            revision = addon.filehash;
        return $mmFilepool.storePackageStatus(siteId, mmAddonManagerComponent, name, status, revision, 0);
    };
    return self;
}])
.run(["$mmAddonManager", "$mmEvents", "mmCoreEventLogin", "mmCoreEventLogout", "mmCoreEventRemoteAddonsLoaded", "$mmSite", "$window", function($mmAddonManager, $mmEvents, mmCoreEventLogin, mmCoreEventLogout, mmCoreEventRemoteAddonsLoaded, $mmSite, $window) {
    $mmEvents.on(mmCoreEventLogin, function() {
        var siteId = $mmSite.getId();
        $mmAddonManager.downloadRemoteAddons(siteId).then(function(addons) {
            return $mmAddonManager.loadRemoteAddons(addons).finally(function() {
                if ($mmSite.getId() == siteId && $mmAddonManager.hasRemoteAddonsLoaded()) {
                    $mmEvents.trigger(mmCoreEventRemoteAddonsLoaded);
                }
            });
        });
    });
    $mmEvents.on(mmCoreEventLogout, function() {
        if ($mmAddonManager.hasRemoteAddonsLoaded()) {
            $window.location.reload();
        }
    });
}]);

angular.module('mm.core')
.provider('$mmApp', ["$stateProvider", "$sceDelegateProvider", function($stateProvider, $sceDelegateProvider) {
        var DBNAME = 'MoodleMobile',
        dbschema = {
            stores: []
        },
        dboptions = {
            autoSchema: true
        };
        this.registerStore = function(store) {
        if (typeof(store.name) === 'undefined') {
            console.log('$mmApp: Error: store name is undefined.');
            return;
        } else if (storeExists(store.name)) {
            console.log('$mmApp: Error: store ' + store.name + ' is already defined.');
            return;
        }
        dbschema.stores.push(store);
    };
        this.registerStores = function(stores) {
        var self = this;
        angular.forEach(stores, function(store) {
            self.registerStore(store);
        });
    };
        function storeExists(name) {
        var exists = false;
        angular.forEach(dbschema.stores, function(store) {
            if (store.name === name) {
                exists = true;
            }
        });
        return exists;
    }
    this.$get = ["$mmDB", "$cordovaNetwork", "$log", "$injector", "$ionicPlatform", "$timeout", "$q", function($mmDB, $cordovaNetwork, $log, $injector, $ionicPlatform, $timeout, $q) {
        $log = $log.getInstance('$mmApp');
        var db,
            self = {},
            ssoAuthenticationDeferred;
                self.createState = function(name, config) {
            $log.debug('Adding new state: '+name);
            $stateProvider.state(name, config);
        };
                self.closeKeyboard = function() {
            if (typeof cordova != 'undefined' && cordova.plugins && cordova.plugins.Keyboard && cordova.plugins.Keyboard.close) {
                cordova.plugins.Keyboard.close();
                return true;
            }
            return false;
        };
                self.getDB = function() {
            if (typeof db == 'undefined') {
                db = $mmDB.getDB(DBNAME, dbschema, dboptions);
            }
            return db;
        };
                self.getSchema = function() {
            return dbschema;
        };
                self.initProcess = function() {
            return $ionicPlatform.ready();
        };
                self.isDevice = function() {
            return !!window.device;
        };
                self.isKeyboardVisible = function() {
            if (typeof cordova != 'undefined' && cordova.plugins && cordova.plugins.Keyboard) {
                return cordova.plugins.Keyboard.isVisible;
            }
            return false;
        };
                self.isOnline = function() {
            var online = typeof navigator.connection === 'undefined' || $cordovaNetwork.isOnline();
            if (!online && navigator.onLine) {
                online = true;
            }
            return online;
        };
                self.isNetworkAccessLimited = function() {
            if (typeof navigator.connection === 'undefined') {
                return false;
            }
            var type = $cordovaNetwork.getNetwork();
            var limited = [Connection.CELL_2G, Connection.CELL_3G, Connection.CELL_4G, Connection.CELL];
            return limited.indexOf(type) > -1;
        };
                self.isReady = function() {
            var promise = $injector.get('$mmInitDelegate').ready();
            return promise.$$state.status === 1;
        };
                self.openKeyboard = function() {
            if (typeof cordova != 'undefined' && cordova.plugins && cordova.plugins.Keyboard && cordova.plugins.Keyboard.show) {
                cordova.plugins.Keyboard.show();
                return true;
            }
            return false;
        };
                self.ready = function() {
            return $injector.get('$mmInitDelegate').ready();
        };
                self.startSSOAuthentication = function() {
            var cancelPromise;
            ssoAuthenticationDeferred = $q.defer();
            cancelPromise = $timeout(function() {
                self.finishSSOAuthentication();
            }, 10000);
            ssoAuthenticationDeferred.promise.finally(function() {
                $timeout.cancel(cancelPromise);
            });
        };
                self.finishSSOAuthentication = function() {
            ssoAuthenticationDeferred && ssoAuthenticationDeferred.resolve();
            ssoAuthenticationDeferred = undefined;
        };
                self.isSSOAuthenticationOngoing = function() {
            return !!ssoAuthenticationDeferred;
        };
                self.waitForSSOAuthentication = function() {
            if (ssoAuthenticationDeferred) {
                return ssoAuthenticationDeferred.promise;
            }
            return $q.when();
        };
                self.getRedirect = function() {
            if (localStorage && localStorage.getItem) {
                try {
                    var data = {
                        siteid: localStorage.getItem('mmCoreRedirectSiteId'),
                        state: localStorage.getItem('mmCoreRedirectState'),
                        params: localStorage.getItem('mmCoreRedirectParams'),
                        timemodified: localStorage.getItem('mmCoreRedirectTime')
                    };
                    if (data.params) {
                        data.params = JSON.parse(data.params);
                    }
                    return data;
                } catch(ex) {
                    $log.error('Error loading redirect data:', ex);
                }
            }
            return {};
        };
                self.storeRedirect = function(siteId, state, params) {
            if (localStorage && localStorage.setItem) {
                try {
                    localStorage.setItem('mmCoreRedirectSiteId', siteId);
                    localStorage.setItem('mmCoreRedirectState', state);
                    localStorage.setItem('mmCoreRedirectParams', JSON.stringify(params));
                    localStorage.setItem('mmCoreRedirectTime', new Date().getTime());
                } catch(ex) {}
            }
        };
                self.trustResources = function(wildcard) {
            var currentList = $sceDelegateProvider.resourceUrlWhitelist();
            if (currentList.indexOf(wildcard) == -1) {
                currentList.push(wildcard);
                $sceDelegateProvider.resourceUrlWhitelist(currentList);
            }
        };
        return self;
    }];
}]);

angular.module('mm.core')
.constant('mmCoreConfigStore', 'config')
.config(["$mmAppProvider", "mmCoreConfigStore", function($mmAppProvider, mmCoreConfigStore) {
    var stores = [
        {
            name: mmCoreConfigStore,
            keyPath: 'name'
        }
    ];
    $mmAppProvider.registerStores(stores);
}])
.factory('$mmConfig', ["$q", "$log", "$mmApp", "mmCoreConfigStore", function($q, $log, $mmApp, mmCoreConfigStore) {
    $log = $log.getInstance('$mmConfig');
    var self = {};
        self.get = function(name, defaultValue) {
        return $mmApp.getDB().get(mmCoreConfigStore, name).then(function(entry) {
            return entry.value;
        }).catch(function() {
            if (typeof defaultValue != 'undefined') {
                return defaultValue;
            } else {
                return $q.reject();
            }
        });
    };
        self.set = function(name, value) {
        return $mmApp.getDB().insert(mmCoreConfigStore, {name: name, value: value});
    };
        self.delete = function(name) {
        return $mmApp.getDB().remove(mmCoreConfigStore, name);
    };
    return self;
}]);

angular.module('mm.core')
.constant('mmCoreCronInterval', 3600000)
.constant('mmCoreCronMinInterval', 300000)
.constant('mmCoreCronMaxTimeProcess', 120000)
.constant('mmCoreCronStore', 'cron')
.config(["$mmAppProvider", "mmCoreCronStore", function($mmAppProvider, mmCoreCronStore) {
    var stores = [
        {
            name: mmCoreCronStore,
            keyPath: 'id'
        }
    ];
    $mmAppProvider.registerStores(stores);
}])
.factory('$mmCronDelegate', ["$log", "$mmConfig", "$mmApp", "$timeout", "$q", "$mmUtil", "mmCoreCronInterval", "mmCoreCronStore", "mmCoreSettingsSyncOnlyOnWifi", "mmCoreCronMinInterval", "mmCoreCronMaxTimeProcess", function($log, $mmConfig, $mmApp, $timeout, $q, $mmUtil, mmCoreCronInterval, mmCoreCronStore,
            mmCoreSettingsSyncOnlyOnWifi, mmCoreCronMinInterval, mmCoreCronMaxTimeProcess) {
    $log = $log.getInstance('$mmCronDelegate');
    var hooks = {},
        self = {},
        queuePromise = $q.when();
        self._executeHook = function(name, force, siteId) {
        if (!hooks[name] || !hooks[name].instance || !angular.isFunction(hooks[name].instance.execute)) {
            $log.debug('Cannot execute hook because is invalid: ' + name);
            return $q.reject();
        }
        var usesNetwork = self._hookUsesNetwork(name),
            isSync = !force && self._isHookSync(name),
            promise;
        if (usesNetwork && !$mmApp.isOnline()) {
            $log.debug('Cannot execute hook because device is offline: ' + name);
            self._stopHook(name);
            return $q.reject();
        }
        if (isSync) {
            promise = $mmConfig.get(mmCoreSettingsSyncOnlyOnWifi, false).catch(function() {
                return false;
            }).then(function(syncOnlyOnWifi) {
                return !syncOnlyOnWifi || !$mmApp.isNetworkAccessLimited();
            });
        } else {
            promise = $q.when(true);
        }
        return promise.then(function(execute) {
            if (!execute) {
                $log.debug('Cannot execute hook because device is using limited connection: ' + name);
                scheduleNextExecution(name, mmCoreCronMinInterval);
                return $q.reject();
            }
            queuePromise = queuePromise.catch(function() {
            }).then(function() {
                return executeHook(name, siteId).then(function() {
                    $log.debug('Execution of hook \'' + name + '\' was a success.');
                    return self._setHookLastExecutionTime(name, new Date().getTime()).then(function() {
                        scheduleNextExecution(name);
                    });
                }, function() {
                    $log.debug('Execution of hook \'' + name + '\' failed.');
                    scheduleNextExecution(name, mmCoreCronMinInterval);
                    return $q.reject();
                });
            });
            return queuePromise;
        });
    };
        function executeHook(name, siteId) {
        var deferred = $q.defer(),
            cancelPromise;
        $log.debug('Executing hook: ' + name);
        $q.when(hooks[name].instance.execute(siteId)).then(function() {
            deferred.resolve();
        }).catch(function() {
            deferred.reject();
        }).finally(function() {
            $timeout.cancel(cancelPromise);
        });
        cancelPromise = $timeout(function() {
            $log.debug('Resolving execution of hook \'' + name + '\' because it took too long.');
            deferred.resolve();
        }, mmCoreCronMaxTimeProcess);
        return deferred.promise;
    }
        self.forceSyncExecution = function(siteId) {
        var promises = [];
        angular.forEach(hooks, function(hook, name) {
            if (self._isHookManualSync(name)) {
                hook.running = true;
                $timeout.cancel(hook.timeout);
                promises.push(self._executeHook(name, true, siteId));
            }
        });
        return $mmUtil.allPromises(promises);
    };
        self._getHookInterval = function(name) {
        if (!hooks[name] || !hooks[name].instance || !angular.isFunction(hooks[name].instance.getInterval)) {
            return mmCoreCronInterval;
        }
        return Math.max(mmCoreCronMinInterval, parseInt(hooks[name].instance.getInterval(), 10));
    };
        self._getHookLastExecutionId = function(name) {
        return 'last_execution_'+name;
    };
        self._getHookLastExecutionTime = function(name) {
        var id = self._getHookLastExecutionId(name);
        return $mmApp.getDB().get(mmCoreCronStore, id).then(function(entry) {
            var time = parseInt(entry.value);
            return isNaN(time) ? 0 : time;
        }).catch(function() {
            return 0;
        });
    };
        self.hasSyncHooks = function() {
        for (var name in hooks) {
            if (self._isHookSync(name)) {
                return true;
            }
        }
        return false;
    };
        self.hasManualSyncHooks = function() {
        for (var name in hooks) {
            if (self._isHookManualSync(name)) {
                return true;
            }
        }
        return false;
    };
        self._hookUsesNetwork = function(name) {
        if (!hooks[name] || !hooks[name].instance || !angular.isFunction(hooks[name].instance.usesNetwork)) {
            return true;
        }
        return hooks[name].instance.usesNetwork();
    };
        self._isHookSync = function(name) {
        if (!hooks[name] || !hooks[name].instance || !angular.isFunction(hooks[name].instance.isSync)) {
            return true;
        }
        return hooks[name].instance.isSync();
    };
        self._isHookManualSync = function(name) {
        if (!hooks[name] || !hooks[name].instance || !angular.isFunction(hooks[name].instance.canManualSync)) {
            return self._isHookSync(name);
        }
        return hooks[name].instance.canManualSync();
    };
        self.register = function(name, handler) {
        if (typeof hooks[name] != 'undefined') {
            $log.debug('The cron hook \''+name+'\' is already registered.');
            return;
        }
        $log.debug('Register hook \''+name+'\' in cron.');
        hooks[name] = {
            name: name,
            handler: handler,
            instance: $mmUtil.resolveObject(handler, true),
            running: false
        };
        if (!hooks[name].instance) {
            $log.error('The cron hook \''+name+'\' has an invalid instance, deleting.');
            delete hooks[name];
            return;
        }
        self._startHook(name);
    };
        function scheduleNextExecution(name, time) {
        if (!hooks[name]) {
            return;
        }
        if (hooks[name].timeout && hooks[name].timeout.$$state && hooks[name].timeout.$$state.status === 0) {
            return;
        }
        var promise;
        time = parseInt(time, 10);
        if (time) {
            promise = $q.when(time);
        } else {
            promise = self._getHookLastExecutionTime(name).then(function(lastExecution) {
                var interval = self._getHookInterval(name),
                    nextExecution = lastExecution + interval,
                    now = new Date().getTime();
                return nextExecution - now;
            });
        }
        promise.then(function(nextExecution) {
            $log.debug('Scheduling next execution of hook \'' + name + '\' in: ' + nextExecution + 'ms');
            if (nextExecution < 0) {
                nextExecution = 0;
            }
            hooks[name].timeout = $timeout(function() {
                self._executeHook(name);
            }, nextExecution);
        });
    }
        self._setHookLastExecutionTime = function(name, time) {
        var id = self._getHookLastExecutionId(name),
            entry = {
                id: id,
                value: parseInt(time, 10)
            };
        return $mmApp.getDB().insert(mmCoreCronStore, entry);
    };
        self.startNetworkHooks = function() {
        angular.forEach(hooks, function(hook) {
            if (self._hookUsesNetwork(hook.name)) {
                self._startHook(hook.name);
            }
        });
    };
        self._startHook = function(name) {
        if (!hooks[name]) {
            $log.debug('Cannot start hook \''+name+'\', is invalid.');
            return;
        }
        if (hooks[name].running) {
            $log.debug('Hook \''+name+'\' is already running.');
            return;
        }
        hooks[name].running = true;
        scheduleNextExecution(name);
    };
        self._stopHook = function(name) {
        if (!hooks[name]) {
            $log.debug('Cannot stop hook \''+name+'\', is invalid.');
            return;
        }
        if (!hooks[name].running) {
            $log.debug('Cannot stop hook \''+name+'\', it\'s not running.');
            return;
        }
        hooks[name].running = false;
        $timeout.cancel(hooks[name].timeout);
    };
    return self;
}])
.run(["$mmEvents", "$mmCronDelegate", "mmCoreEventOnlineStatusChanged", function($mmEvents, $mmCronDelegate, mmCoreEventOnlineStatusChanged) {
    $mmEvents.on(mmCoreEventOnlineStatusChanged, function(online) {
        if (online) {
            $mmCronDelegate.startNetworkHooks();
        }
    });
}]);

angular.module('mm.core')
.factory('$mmDB', ["$q", "$log", function($q, $log) {
    $log = $log.getInstance('$mmDB');
    var self = {},
        dbInstances = {};
        function applyOrder(query, order, reverse) {
        if (order) {
            query = query.order(order);
            if (reverse) {
                query = query.reverse();
            }
        }
        return query;
    }
        function applyWhere(query, where) {
        if (where && where.length > 0) {
            query = query.where.apply(query, where);
        }
        return query;
    }
        function callDBFunction(db, func) {
        if (typeof db == 'undefined') {
            return $q.reject();
        }
        var deferred = $q.defer();
        try {
            db[func].apply(db, Array.prototype.slice.call(arguments, 2)).then(function(result) {
                if (typeof result == 'undefined') {
                    deferred.reject();
                } else {
                    deferred.resolve(result);
                }
            }, deferred.reject);
        } catch(ex) {
            $log.error('Error executing function ' + func + ' to DB ' + db.getName());
            $log.error(ex.name + ': ' + ex.message);
            deferred.reject();
        }
        return deferred.promise;
    }
        function callCount(db, store, where) {
        if (typeof db == 'undefined') {
            return $q.reject();
        }
        var deferred = $q.defer();
        try {
            var query = db.from(store);
            query = applyWhere(query, where);
            query.count().then(deferred.resolve, deferred.reject);
        } catch(ex) {
            var promise;
            if (where[1] == '=') {
                promise = callWhereEqualFallBack(db, store, where[0], where[2]).then(function(list) {
                    deferred.resolve(list.length);
                });
            } else {
                promise = $q.reject();
            }
            promise.catch(function () {
                $log.error('Error counting on db ' + db.getName() + '. ' + ex.name + ': ' + ex.message);
                deferred.reject();
            });
        }
        return deferred.promise;
    }
        function callWhere(db, store, field_name, op, value, op2, value2) {
        if (typeof db == 'undefined') {
            return $q.reject();
        }
        var deferred = $q.defer();
        try {
            db.from(store).where(field_name, op, value, op2, value2).list().then(deferred.resolve, deferred.reject);
        } catch(ex) {
            var promise;
            if (op == '=') {
                promise = callWhereEqualFallBack(db, store, field_name, value).then(deferred.resolve).catch(deferred.reject);
            } else {
                promise = $q.reject();
            }
            promise.catch(function () {
                $log.error('Error getting where from db ' + db.getName() + '. ' + ex.name+': ' + ex.message);
                deferred.reject();
            });
        }
        return deferred.promise;
    }
        function callWhereEqual(db, store, field_name, value) {
        if (typeof db == 'undefined') {
            return $q.reject();
        }
        var deferred = $q.defer();
        try {
            db.from(store).where(field_name, '=', value).list().then(deferred.resolve, deferred.reject);
        } catch(ex) {
            callWhereEqualFallBack(db, store, field_name, value).then(deferred.resolve).catch(function () {
                $log.error('Error getting where equal from db ' + db.getName() + '. ' + ex.name + ': ' + ex.message);
                deferred.reject();
            });
        }
        return deferred.promise;
    }
    function callWhereEqualFallBack(db, store, field_name, values) {
        var fields = getCompoundIndex(db, store, field_name);
        if (!fields) {
            return $q.reject();
        }
        if (typeof fields == "string") {
            fields = [fields];
        }
        var deferred = $q.defer();
        try {
            db.from(store).where(fields[0], '=', values[0]).list().then(function(list) {
                var results = filterWhereList(list, fields, values, 1);
                deferred.resolve(results);
            }, deferred.reject);
        } catch(ex) {
            deferred.reject();
        }
        return deferred.promise;
    }
        function getCompoundIndex(db, storeName, index) {
        var stores = db.getSchema().stores;
        for (var x in stores) {
            if (stores[x].name == storeName) {
                var indexes = stores[x].indexes;
                for (var y in indexes) {
                    if (indexes[y].name == index) {
                        return indexes[y].keyPath;
                    }
                }
                return false;
            }
        }
        return false;
    }
        function filterWhereList(list, fields, values, indexNum) {
        if (list.length == 0 || fields.length < indexNum || values.length < indexNum) {
            return list;
        }
        var field = fields[indexNum],
            value = values[indexNum];
        list = list.filter(function (item) {
            return item[field] == value;
        });
        return filterWhereList(list, fields, values, indexNum + 1);
    }
        function callEach(db, store, callback) {
        var deferred = $q.defer();
        callDBFunction(db, 'values', store, undefined, 99999999).then(function(entries) {
            for (var i = 0; i < entries.length; i++) {
                callback(entries[i]);
            }
            deferred.resolve();
        }, deferred.reject);
        return deferred.promise;
    }
        function doQuery(db, store, where, order, reverse, limit) {
        if (typeof db == 'undefined') {
            return $q.reject();
        }
        var deferred = $q.defer(),
            query;
        try {
            query = db.from(store);
            query = applyWhere(query, where);
            query = applyOrder(query, order, reverse);
            query.list(limit).then(deferred.resolve, deferred.reject);
        } catch(ex) {
            $log.error('Error querying ' + store + ' on ' + db.getName() + '. ' + ex.name + ': ' + ex.message);
            deferred.reject();
        }
        return deferred.promise;
    }
        function doUpdate(db, store, values, where) {
        if (typeof db == 'undefined') {
            return $q.reject();
        }
        var deferred = $q.defer(),
            query;
        try {
            query = db.from(store);
            query = applyWhere(query, where);
            query.patch(values).then(deferred.resolve, deferred.reject);
        } catch(ex) {
            $log.error('Error updating ' + store + ' on ' + db.getName() + '. ' + ex.name + ': ' + ex.message);
            deferred.reject();
        }
        return deferred.promise;
    }
        self.getDB = function(name, schema, options, forceNew) {
        if (typeof dbInstances[name] === 'undefined' || forceNew) {
            var isSafari = !ionic.Platform.isIOS() && !ionic.Platform.isAndroid() && navigator.userAgent.indexOf('Safari') != -1 &&
                            navigator.userAgent.indexOf('Chrome') == -1 && navigator.userAgent.indexOf('Firefox') == -1;
            if (typeof IDBObjectStore == 'undefined' || typeof IDBObjectStore.prototype.count == 'undefined' || isSafari) {
                if (typeof options.mechanisms == 'undefined') {
                    options.mechanisms = ['websql', 'sqlite', 'localstorage', 'sessionstorage', 'userdata', 'memory'];
                } else {
                    var position = options.mechanisms.indexOf('indexeddb');
                    if (position != -1) {
                        options.mechanisms.splice(position, 1);
                    }
                }
            }
            var db = new ydn.db.Storage(name, schema, options);
            dbInstances[name] = {
                                getName: function() {
                    return db.getName();
                },
                                get: function(store, id) {
                    return callDBFunction(db, 'get', store, id);
                },
                                getAll: function(store) {
                    return callDBFunction(db, 'values', store, undefined, 99999999);
                },
                                count: function(store, where) {
                    return callCount(db, store, where);
                },
                                insert: function(store, value, id) {
                    return callDBFunction(db, 'put', store, value, id);
                },
                                insertSync: function(store, value) {
                    if (db) {
                        try {
                            db.put(store, value);
                            return true;
                        } catch(ex) {
                            $log.error('Error executing function sync put to DB '+db.getName());
                            $log.error(ex.name+': '+ex.message);
                        }
                    }
                    return false;
                },
                                query: function(store, where, order, reverse, limit) {
                    return doQuery(db, store, where, order, reverse, limit);
                },
                                remove: function(store, id) {
                    return callDBFunction(db, 'remove', store, id);
                },
                                removeAll: function(store) {
                    return callDBFunction(db, 'clear', store);
                },
                                update: function(store, values, where) {
                    return doUpdate(db, store, values, where);
                },
                                where: function(store, field_name, op, value, op2, value2) {
                    return callWhere(db, store, field_name, op, value, op2, value2);
                },
                                whereEqual: function(store, field_name, value) {
                    return callWhereEqual(db, store, field_name, value);
                },
                                each: function(store, callback) {
                    return callEach(db, store, callback);
                },
                                close: function() {
                    db.close();
                    db = undefined;
                },
                                onReady: function(cb) {
                    db.onReady(cb);
                },
                                getType: function() {
                    return db.getType();
                }
            };
        }
        return dbInstances[name];
    };
        self.deleteDB = function(name) {
        var deferred = $q.defer();
        function deleteDB() {
            var type = dbInstances[name].getType();
            $q.when(ydn.db.deleteDatabase(name, type).then(function() {
                delete dbInstances[name];
                deferred.resolve();
            }, deferred.reject));
        }
        if (typeof dbInstances[name] != 'undefined') {
            dbInstances[name].onReady(deleteDB);
        } else {
            deleteDB();
        }
        return deferred.promise;
    };
    return self;
}]);

angular.module('mm.core')
.factory('$mmEmulatorManager', ["$log", "$q", "$http", "$mmFS", "$window", function($log, $q, $http, $mmFS, $window) {
    $log = $log.getInstance('$mmEmulatorManager');
    var self = {};
        self.loadHTMLAPI = function() {
        if ($mmFS.isAvailable()) {
            $log.debug('Stop loading HTML API, it was already loaded or the environment doesn\'t need it.');
            return $q.when();
        }
        var deferred = $q.defer(),
            basePath;
        $log.debug('Loading HTML API.');
        $window.requestFileSystem  = $window.requestFileSystem || $window.webkitRequestFileSystem;
        $window.resolveLocalFileSystemURL = $window.resolveLocalFileSystemURL || $window.webkitResolveLocalFileSystemURL;
        $window.LocalFileSystem = {
            PERSISTENT: 1
        };
        $window.FileTransfer = function() {};
        $window.FileTransfer.prototype.download = function(url, filePath, successCallback, errorCallback) {
            $http.get(url, {responseType: 'blob'}).then(function(data) {
                if (!data || !data.data) {
                    errorCallback();
                } else {
                    filePath = filePath.replace(basePath, '');
                    filePath = filePath.replace(/%20/g, ' ');
                    $mmFS.writeFile(filePath, data.data).then(function(e) {
                        successCallback(e);
                    }).catch(function(error) {
                        errorCallback(error);
                    });
                }
            }).catch(function(error) {
                errorCallback(error);
            });
        };
        $window.zip = {
            unzip: function(source, destination, callback, progressCallback) {
                source = source.replace(basePath, '');
                source = source.replace(/%20/g, ' ');
                destination = destination.replace(basePath, '');
                destination = destination.replace(/%20/g, ' ');
                $mmFS.readFile(source, $mmFS.FORMATARRAYBUFFER).then(function(data) {
                    var zip = new JSZip(data),
                        promises = [];
                    angular.forEach(zip.files, function(file, name) {
                        var filepath = $mmFS.concatenatePaths(destination, name),
                            type;
                        if (!file.dir) {
                            type = $mmFS.getMimeType($mmFS.getFileExtension(name));
                            promises.push($mmFS.writeFile(filepath, new Blob([file.asArrayBuffer()], {type: type})));
                        } else {
                            promises.push($mmFS.createDir(filepath));
                        }
                    });
                    return $q.all(promises).then(function() {
                        callback(0);
                    });
                }).catch(function() {
                    callback(-1);
                });
            }
        };
        $window.webkitStorageInfo.requestQuota(PERSISTENT, 500 * 1024 * 1024, function(granted) {
            $window.requestFileSystem(PERSISTENT, granted, function(entry) {
                basePath = entry.root.toURL();
                $mmFS.setHTMLBasePath(basePath);
                deferred.resolve();
            }, deferred.reject);
        }, deferred.reject);
        return deferred.promise;
    };
    return self;
}])
.config(["$mmInitDelegateProvider", "mmInitDelegateMaxAddonPriority", function($mmInitDelegateProvider, mmInitDelegateMaxAddonPriority) {
    if (!ionic.Platform.isWebView()) {
        $mmInitDelegateProvider.registerProcess('mmEmulator', '$mmEmulatorManager.loadHTMLAPI',
                mmInitDelegateMaxAddonPriority + 500, true);
    }
}]);

angular.module('mm.core')
.constant('mmCoreEventKeyboardShow', 'keyboard_show')
.constant('mmCoreEventKeyboardHide', 'keyboard_hide')
.constant('mmCoreEventSessionExpired', 'session_expired')
.constant('mmCoreEventPasswordChangeForced', 'password_change_forced')
.constant('mmCoreEventUserNotFullySetup', 'user_not_fully_setup')
.constant('mmCoreEventSitePolicyNotAgreed', 'site_policy_not_agreed')
.constant('mmCoreEventLogin', 'login')
.constant('mmCoreEventLogout', 'logout')
.constant('mmCoreEventLanguageChanged', 'language_changed')
.constant('mmCoreEventSiteAdded', 'site_added')
.constant('mmCoreEventSiteUpdated', 'site_updated')
.constant('mmCoreEventSiteDeleted', 'site_deleted')
.constant('mmCoreEventQueueEmpty', 'filepool_queue_empty')
.constant('mmCoreEventCompletionModuleViewed', 'completion_module_viewed')
.constant('mmCoreEventUserDeleted', 'user_deleted')
.constant('mmCoreEventPackageStatusChanged', 'filepool_package_status_changed')
.constant('mmCoreEventSectionStatusChanged', 'section_status_changed')
.constant('mmCoreEventRemoteAddonsLoaded', 'remote_addons_loaded')
.constant('mmCoreEventOnline', 'online')
.constant('mmCoreEventOnlineStatusChanged', 'online_status_changed')
.factory('$mmEvents', ["$log", "md5", function($log, md5) {
    $log = $log.getInstance('$mmEvents');
    var self = {},
        observers = {},
        uniqueEvents = {},
        uniqueEventsData = {};
        self.on = function(eventName, callBack) {
        if (uniqueEvents[eventName]) {
            callBack(uniqueEventsData[eventName]);
            return {
                id: -1,
                off: function() {}
            };
        }
        var observerID;
        if (typeof(observers[eventName]) === 'undefined') {
            observers[eventName] = {};
        }
        while (typeof(observerID) === 'undefined') {
            var candidateID = md5.createHash(Math.random().toString());
            if (typeof(observers[eventName][candidateID]) === 'undefined') {
                observerID = candidateID;
            }
        }
        $log.debug('Observer ' + observerID + ' listening to event '+eventName);
        observers[eventName][observerID] = callBack;
        var observer = {
            id: observerID,
            off: function() {
                $log.debug('Disable observer ' + observerID + ' for event '+eventName);
                delete observers[eventName][observerID];
            }
        };
        return observer;
    };
        self.trigger = function(eventName, data) {
        $log.debug('Event ' + eventName + ' triggered.');
        var affected = observers[eventName];
        for (var observerName in affected) {
            if (typeof(affected[observerName]) === 'function') {
                affected[observerName](data);
            }
        }
    };
        self.triggerUnique = function(eventName, data) {
        if (uniqueEvents[eventName]) {
            $log.debug('Unique event ' + eventName + ' ignored because it was already triggered.');
        } else {
            $log.debug('Unique event ' + eventName + ' triggered.');
            uniqueEvents[eventName] = true;
            uniqueEventsData[eventName] = data;
            var affected = observers[eventName];
            angular.forEach(affected, function(callBack) {
                if (typeof callBack === 'function') {
                    callBack(data);
                }
            });
        }
    };
    return self;
}]);

angular.module('mm.core')
.constant('mmFilepoolQueueProcessInterval', 0)
.constant('mmFilepoolFolder', 'filepool')
.constant('mmFilepoolStore', 'filepool')
.constant('mmFilepoolQueueStore', 'files_queue')
.constant('mmFilepoolLinksStore', 'files_links')
.constant('mmFilepoolPackagesStore', 'filepool_packages')
.constant('mmFilepoolWifiDownloadThreshold', 20971520)
.constant('mmFilepoolDownloadThreshold', 2097152)
.config(["$mmAppProvider", "$mmSitesFactoryProvider", "mmFilepoolStore", "mmFilepoolLinksStore", "mmFilepoolQueueStore", "mmFilepoolPackagesStore", function($mmAppProvider, $mmSitesFactoryProvider, mmFilepoolStore, mmFilepoolLinksStore, mmFilepoolQueueStore,
            mmFilepoolPackagesStore) {
    var siteStores = [
        {
            name: mmFilepoolStore,
            keyPath: 'fileId',
            indexes: []
        },
        {
            name: mmFilepoolLinksStore,
            keyPath: ['fileId', 'component', 'componentId'],
            indexes: [
                {
                    name: 'fileId',
                },
                {
                    name: 'component',
                },
                {
                    name: 'componentAndId',
                    keyPath: ['component', 'componentId']
                }
            ]
        },
        {
            name: mmFilepoolPackagesStore,
            keyPath: 'id',
            indexes: [
                {
                    name: 'component',
                },
                {
                    name: 'componentId',
                },
                {
                    name: 'status',
                }
            ]
        }
    ];
    var appStores = [
        {
            name: mmFilepoolQueueStore,
            keyPath: ['siteId', 'fileId'],
            indexes: [
                {
                    name: 'siteId',
                },
                {
                    name: 'sortorder',
                    generator: function(obj) {
                        var sortorder = parseInt(obj.added, 10),
                            priority = 999 - Math.max(0, Math.min(parseInt(obj.priority || 0, 10), 999)),
                            padding = "000";
                        sortorder = "" + sortorder;
                        priority = "" + priority;
                        priority = padding.substring(0, padding.length - priority.length) + priority;
                        sortorder = priority + '-' + sortorder;
                        return sortorder;
                    }
                }
            ]
        }
    ];
    $mmAppProvider.registerStores(appStores);
    $mmSitesFactoryProvider.registerStores(siteStores);
}])
.factory('$mmFilepool', ["$q", "$log", "$timeout", "$mmApp", "$mmFS", "$mmWS", "$mmSitesManager", "$mmEvents", "md5", "mmFilepoolStore", "mmFilepoolLinksStore", "mmFilepoolQueueStore", "mmFilepoolFolder", "mmFilepoolQueueProcessInterval", "mmCoreEventQueueEmpty", "mmCoreDownloaded", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", "mmCoreNotDownloadable", "mmFilepoolPackagesStore", "mmCoreEventPackageStatusChanged", "$mmText", "$mmUtil", "mmFilepoolWifiDownloadThreshold", "mmFilepoolDownloadThreshold", function($q, $log, $timeout, $mmApp, $mmFS, $mmWS, $mmSitesManager, $mmEvents, md5, mmFilepoolStore,
        mmFilepoolLinksStore, mmFilepoolQueueStore, mmFilepoolFolder, mmFilepoolQueueProcessInterval, mmCoreEventQueueEmpty,
        mmCoreDownloaded, mmCoreDownloading, mmCoreNotDownloaded, mmCoreOutdated, mmCoreNotDownloadable, mmFilepoolPackagesStore,
        mmCoreEventPackageStatusChanged, $mmText, $mmUtil, mmFilepoolWifiDownloadThreshold, mmFilepoolDownloadThreshold) {
    $log = $log.getInstance('$mmFilepool');
    var self = {},
        tokenRegex = new RegExp('(\\?|&)token=([A-Za-z0-9]+)'),
        queueState,
        urlAttributes = [
            tokenRegex,
            new RegExp('(\\?|&)forcedownload=[0-1]')
        ],
        revisionRegex = new RegExp('/content/([0-9]+)/'),
        queueDeferreds = {},
        packagesPromises = {},
        filePromises = {},
        sizeCache = {};
    var QUEUE_RUNNING = 'mmFilepool:QUEUE_RUNNING',
        QUEUE_PAUSED = 'mmFilepool:QUEUE_PAUSED';
    var ERR_QUEUE_IS_EMPTY = 'mmFilepoolError:ERR_QUEUE_IS_EMPTY',
        ERR_FS_OR_NETWORK_UNAVAILABLE = 'mmFilepoolError:ERR_FS_OR_NETWORK_UNAVAILABLE',
        ERR_QUEUE_ON_PAUSE = 'mmFilepoolError:ERR_QUEUE_ON_PAUSE';
        self.FILEDOWNLOADED = 'downloaded';
    self.FILEDOWNLOADING = 'downloading';
    self.FILENOTDOWNLOADED = 'notdownloaded';
    self.FILEOUTDATED = 'outdated';
        function getSiteDb(siteId) {
        return $mmSitesManager.getSiteDb(siteId);
    }
        self._addFileLink = function(siteId, fileId, component, componentId) {
        if (!component) {
            return $q.reject();
        }
        componentId = self._fixComponentId(componentId);
        return getSiteDb(siteId).then(function(db) {
            return db.insert(mmFilepoolLinksStore, {
                fileId: fileId,
                component: component,
                componentId: componentId
            });
        });
    };
        self.addFileLinkByUrl = function(siteId, fileUrl, component, componentId) {
        return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
            var fileId = self._getFileIdByUrl(fileUrl);
            return self._addFileLink(siteId, fileId, component, componentId);
        });
    };
        self._addFileLinks = function(siteId, fileId, links) {
        var promises = [];
        angular.forEach(links, function(link) {
            promises.push(self._addFileLink(siteId, fileId, link.component, link.componentId));
        });
        return $q.all(promises);
    };
        self._addFileToPool = function(siteId, fileId, data) {
        var values = angular.copy(data) || {};
        values.fileId = fileId;
        return getSiteDb(siteId).then(function(db) {
            return db.insert(mmFilepoolStore, values);
        });
    };
        self.addToQueueByUrl = function(siteId, fileUrl, component, componentId, timemodified, filePath, priority) {
        var db = $mmApp.getDB(),
            fileId,
            now = new Date(),
            link,
            revision,
            queueDeferred;
        if (!$mmFS.isAvailable()) {
            return $q.reject();
        }
        return $mmSitesManager.getSite(siteId).then(function(site) {
            if (!site.canDownloadFiles()) {
                return $q.reject();
            }
            return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
                timemodified = timemodified || 0;
                revision = self.getRevisionFromUrl(fileUrl);
                fileId = self._getFileIdByUrl(fileUrl);
                priority = priority || 0;
                if (typeof component !== 'undefined') {
                    link = {
                        component: component,
                        componentId: self._fixComponentId(componentId)
                    };
                }
                queueDeferred = self._getQueueDeferred(siteId, fileId, false);
                return db.get(mmFilepoolQueueStore, [siteId, fileId]).then(function(fileObject) {
                    var foundLink = false,
                        update = false;
                    if (fileObject) {
                        if (fileObject.priority < priority) {
                            update = true;
                            fileObject.priority = priority;
                        }
                        if (revision && fileObject.revision !== revision) {
                            update = true;
                            fileObject.revision = revision;
                        }
                        if (timemodified && fileObject.timemodified !== timemodified) {
                            update = true;
                            fileObject.timemodified = timemodified;
                        }
                        if (filePath && fileObject.path !== filePath) {
                            update = true;
                            fileObject.path = filePath;
                        }
                        if (link) {
                            angular.forEach(fileObject.links, function(fileLink) {
                                if (fileLink.component == link.component && fileLink.componentId == link.componentId) {
                                    foundLink = true;
                                }
                            });
                            if (!foundLink) {
                                update = true;
                                fileObject.links.push(link);
                            }
                        }
                        if (update) {
                            $log.debug('Updating file ' + fileId + ' which is already in queue');
                            return db.insert(mmFilepoolQueueStore, fileObject).then(function() {
                                return self._getQueuePromise(siteId, fileId);
                            });
                        }
                        $log.debug('File ' + fileId + ' already in queue and does not require update');
                        if (queueDeferred) {
                            return queueDeferred.promise;
                        } else {
                            return self._getQueuePromise(siteId, fileId);
                        }
                    } else {
                        return addToQueue();
                    }
                }, function() {
                    return addToQueue();
                });
                function addToQueue() {
                    $log.debug('Adding ' + fileId + ' to the queue');
                    return db.insert(mmFilepoolQueueStore, {
                        siteId: siteId,
                        fileId: fileId,
                        added: now.getTime(),
                        priority: priority,
                        url: fileUrl,
                        revision: revision,
                        timemodified: timemodified,
                        path: filePath,
                        links: link ? [link] : []
                    }).then(function() {
                        self.checkQueueProcessing();
                        self._notifyFileDownloading(siteId, fileId);
                        return self._getQueuePromise(siteId, fileId);
                    });
                }
            });
        });
    };
        self.checkQueueProcessing = function() {
        if (!$mmFS.isAvailable() || !$mmApp.isOnline()) {
            queueState = QUEUE_PAUSED;
            return;
        } else if (queueState === QUEUE_RUNNING) {
            return;
        }
        queueState = QUEUE_RUNNING;
        self._processQueue();
    };
        self.clearAllPackagesStatus = function(siteId) {
        var promises = [];
        $log.debug('Clear all packages status for site ' + siteId);
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var db = site.getDb();
            return db.getAll(mmFilepoolPackagesStore).then(function(entries) {
                angular.forEach(entries, function(entry) {
                    promises.push(db.remove(mmFilepoolPackagesStore, entry.id).then(function() {
                        self._triggerPackageStatusChanged(siteId, entry.component, entry.componentId, mmCoreNotDownloaded);
                    }));
                });
                return $q.all(promises);
            });
        });
    };
        self.clearFilepool = function(siteId) {
        return getSiteDb(siteId).then(function(db) {
            return db.removeAll(mmFilepoolStore);
        });
    };
        self.componentHasFiles = function(siteId, component, componentId) {
        return getSiteDb(siteId).then(function(db) {
            var where;
            if (typeof componentId !== 'undefined') {
                where = ['componentAndId', '=', [component, self._fixComponentId(componentId)]];
            } else {
                where = ['component', '=', component];
            }
            return db.count(mmFilepoolLinksStore, where).then(function(count) {
                if (count > 0) {
                    return true;
                }
                return $q.reject();
            });
        });
    };
        self.determinePackagesStatus = function(current, packagestatus) {
        if (!current) {
            current = mmCoreNotDownloadable;
        }
        if (packagestatus === mmCoreNotDownloaded) {
            return mmCoreNotDownloaded;
        } else if (packagestatus === mmCoreDownloaded && current === mmCoreNotDownloadable) {
            return mmCoreDownloaded;
        } else if (packagestatus === mmCoreDownloading && (current === mmCoreNotDownloadable || current === mmCoreDownloaded)) {
            return mmCoreDownloading;
        } else if (packagestatus === mmCoreOutdated && current !== mmCoreNotDownloaded) {
            return mmCoreOutdated;
        }
        return current;
    };
        self._downloadOrPrefetchPackage = function(siteId, fileList, prefetch, component, componentId, revision, timemod, dirPath) {
        var packageId = self.getPackageId(component, componentId);
        if (packagesPromises[siteId] && packagesPromises[siteId][packageId]) {
            return packagesPromises[siteId][packageId];
        } else if (!packagesPromises[siteId]) {
            packagesPromises[siteId] = {};
        }
        revision = revision || self.getRevisionFromFileList(fileList);
        timemod = timemod || self.getTimemodifiedFromFileList(fileList);
        var dwnPromise,
            deleted = false;
        dwnPromise = self.storePackageStatus(siteId, component, componentId, mmCoreDownloading).then(function() {
            var promises = [],
                deferred = $q.defer(),
                packageLoaded = 0;
            angular.forEach(fileList, function(file) {
                var path,
                    promise,
                    fileLoaded = 0;
                if (dirPath) {
                    path = file.filename;
                    if (file.filepath !== '/') {
                        path = file.filepath.substr(1) + path;
                    }
                    path = $mmFS.concatenatePaths(dirPath, path);
                }
                if (prefetch) {
                    promise = self.addToQueueByUrl(siteId, file.fileurl, component, componentId, file.timemodified, path);
                } else {
                    promise = self.downloadUrl(siteId, file.fileurl, false, component, componentId, file.timemodified, path);
                }
                promises.push(promise.then(undefined, undefined, function(progress) {
                    if (progress && progress.loaded) {
                        packageLoaded = packageLoaded + (progress.loaded - fileLoaded);
                        fileLoaded = progress.loaded;
                        deferred.notify({
                            packageDownload: true,
                            loaded: packageLoaded,
                            fileProgress: progress
                        });
                    }
                }));
            });
            $q.all(promises).then(function() {
                return self.storePackageStatus(siteId, component, componentId, mmCoreDownloaded, revision, timemod);
            }).catch(function() {
                return self.setPackagePreviousStatus(siteId, component, componentId).then(function() {
                    return $q.reject();
                });
            }).then(deferred.resolve, deferred.reject);
            return deferred.promise;
        }).finally(function() {
            delete packagesPromises[siteId][packageId];
            deleted = true;
        });
        if (!deleted) {
            packagesPromises[siteId][packageId] = dwnPromise;
        }
        return dwnPromise;
    };
        self.downloadPackage = function(siteId, fileList, component, componentId, revision, timemodified, dirPath) {
        return self._downloadOrPrefetchPackage(siteId, fileList, false, component, componentId, revision, timemodified, dirPath);
    };
        self.downloadUrl = function(siteId, fileUrl, ignoreStale, component, componentId, timemodified, filePath) {
        var fileId,
            revision,
            promise;
        if ($mmFS.isAvailable()) {
            return self._fixPluginfileURL(siteId, fileUrl).then(function(fixedUrl) {
                fileUrl = fixedUrl;
                timemodified = timemodified || 0;
                revision = self.getRevisionFromUrl(fileUrl);
                fileId = self._getFileIdByUrl(fileUrl);
                return self._restoreOldFileIfNeeded(siteId, fileId, fileUrl, filePath);
            }).then(function() {
                return self._hasFileInPool(siteId, fileId).then(function(fileObject) {
                    if (typeof fileObject === 'undefined') {
                        self._notifyFileDownloading(siteId, fileId);
                        return self._downloadForPoolByUrl(siteId, fileUrl, revision, timemodified, filePath);
                    } else if (self._isFileOutdated(fileObject, revision, timemodified) && $mmApp.isOnline() && !ignoreStale) {
                        self._notifyFileDownloading(siteId, fileId);
                        return self._downloadForPoolByUrl(siteId, fileUrl, revision, timemodified, filePath, fileObject);
                    }
                    if (filePath) {
                        promise = self._getInternalUrlByPath(filePath);
                    } else {
                        promise = self._getInternalUrlById(siteId, fileId);
                    }
                    return promise.then(function(response) {
                        return response;
                    }, function() {
                        self._notifyFileDownloading(siteId, fileId);
                        return self._downloadForPoolByUrl(siteId, fileUrl, revision, timemodified, filePath, fileObject);
                    });
                }, function() {
                    self._notifyFileDownloading(siteId, fileId);
                    return self._downloadForPoolByUrl(siteId, fileUrl, revision, timemodified, filePath);
                })
                .then(function(response) {
                    if (typeof component !== 'undefined') {
                        self._addFileLink(siteId, fileId, component, componentId);
                    }
                    self._notifyFileDownloaded(siteId, fileId);
                    return response;
                }, function(err) {
                    self._notifyFileDownloadError(siteId, fileId);
                    return $q.reject(err);
                });
            });
        } else {
            return $q.reject();
        }
    };
        self._downloadForPoolByUrl = function(siteId, fileUrl, revision, timemodified, filePath, poolFileObject) {
        var fileId = self._getFileIdByUrl(fileUrl),
            extension = $mmFS.guessExtensionFromUrl(fileUrl),
            addExtension = typeof filePath == "undefined",
            pathPromise = filePath ? filePath : self._getFilePath(siteId, fileId, extension);
        return $q.when(pathPromise).then(function(filePath) {
            if (poolFileObject && poolFileObject.fileId !== fileId) {
                $log.error('Invalid object to update passed');
                return $q.reject();
            }
            var downloadId = self.getFileDownloadId(fileUrl, filePath),
                deleted = false,
                promise;
            if (filePromises[siteId] && filePromises[siteId][downloadId]) {
                return filePromises[siteId][downloadId];
            } else if (!filePromises[siteId]) {
                filePromises[siteId] = {};
            }
            promise = $mmSitesManager.getSite(siteId).then(function(site) {
                if (!site.canDownloadFiles()) {
                    return $q.reject();
                }
                return $mmWS.downloadFile(fileUrl, filePath, addExtension).then(function(fileEntry) {
                    var now = new Date(),
                        data = poolFileObject || {};
                    data.downloaded = now.getTime();
                    data.stale = false;
                    data.url = fileUrl;
                    data.revision = revision;
                    data.timemodified = timemodified;
                    data.path = fileEntry.path;
                    data.extension = fileEntry.extension;
                    return self._addFileToPool(siteId, fileId, data).then(function() {
                        return fileEntry.toURL();
                    });
                });
            }).finally(function() {
                delete filePromises[siteId][downloadId];
                deleted = true;
            });
            if (!deleted) {
                filePromises[siteId][downloadId] = promise;
            }
            return promise;
        });
    };
        self._fixComponentId = function(componentId) {
        var id = parseInt(componentId, 10);
        if (isNaN(id)) {
            if (typeof componentId == 'undefined' || componentId === null) {
                return -1;
            } else {
                return componentId;
            }
        }
        return id;
    };
        self._fixPluginfileURL = function(siteId, fileUrl) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.fixPluginfileURL(fileUrl);
        });
    };
        self._getFileLinks = function(siteId, fileId) {
        return getSiteDb(siteId).then(function(db) {
            return db.whereEqual(mmFilepoolLinksStore, 'fileId', fileId);
        });
    };
        self.getFileDownloadId = function(fileUrl, filePath) {
        return md5.createHash(fileUrl + '###' + filePath);
    };
        self._getFileEventName = function(siteId, fileId) {
        return 'mmFilepoolFile:'+siteId+':'+fileId;
    };
        self.getFileEventNameByUrl = function(siteId, fileUrl) {
        return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
            var fileId = self._getFileIdByUrl(fileUrl);
            return self._getFileEventName(siteId, fileId);
        });
    };
        self.getPackageDownloadPromise = function(siteId, component, componentId) {
        var packageId = self.getPackageId(component, componentId);
        if (packagesPromises[siteId] && packagesPromises[siteId][packageId]) {
            return packagesPromises[siteId][packageId];
        }
    };
        self.getPackageId = function(component, componentId) {
        return md5.createHash(component + '#' + self._fixComponentId(componentId));
    };
        self.getPackageData = function(siteId, component, componentId) {
        componentId = self._fixComponentId(componentId);
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var db = site.getDb(),
                packageId = self.getPackageId(component, componentId);
            return db.get(mmFilepoolPackagesStore, packageId).then(function(entry) {
                if (!entry) {
                    return $q.reject();
                }
                return entry;
            });
        });
    };
        self.getPackagePreviousStatus = function(siteId, component, componentId) {
        return self.getPackageData(siteId, component, componentId).then(function(entry) {
            return entry.previous || mmCoreNotDownloaded;
        }).catch(function() {
            return mmCoreNotDownloaded;
        });
    };
        self.getPackageCurrentStatus = function(siteId, component, componentId) {
        return self.getPackageData(siteId, component, componentId).then(function(entry) {
            return entry.status || mmCoreNotDownloaded;
        }).catch(function() {
            return mmCoreNotDownloaded;
        });
    };
        self.getPackageStatus = function(siteId, component, componentId, revision, timemodified) {
        revision = revision || 0;
        timemodified = timemodified || 0;
        componentId = self._fixComponentId(componentId);
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var db = site.getDb(),
                packageId = self.getPackageId(component, componentId);
            return db.get(mmFilepoolPackagesStore, packageId).then(function(entry) {
                if (entry.status === mmCoreDownloaded) {
                    if (revision != entry.revision || timemodified > entry.timemodified) {
                        entry.status = mmCoreOutdated;
                        entry.updated = new Date().getTime();
                        db.insert(mmFilepoolPackagesStore, entry).then(function() {
                            self._triggerPackageStatusChanged(siteId, component, componentId, mmCoreOutdated);
                        });
                    }
                } else if (entry.status === mmCoreOutdated) {
                    if (revision === entry.revision && timemodified === entry.timemodified) {
                        entry.status = mmCoreDownloaded;
                        entry.updated = new Date().getTime();
                        db.insert(mmFilepoolPackagesStore, entry).then(function() {
                            self._triggerPackageStatusChanged(siteId, component, componentId, mmCoreDownloaded);
                        });
                    }
                }
                return entry.status;
            }, function() {
                return mmCoreNotDownloaded;
            });
        });
    };
        self.getPackageRevision = function(siteId, component, componentId) {
        return self.getPackageData(siteId, component, componentId).then(function(entry) {
            return entry.revision;
        });
    };
        self.getPackageTimemodified = function(siteId, component, componentId) {
        return self.getPackageData(siteId, component, componentId).then(function(entry) {
            return entry.timemodified;
        }).catch(function() {
            return -1;
        });
    };
        self._getQueueDeferred = function(siteId, fileId, create) {
        if (typeof create == 'undefined') {
            create = true;
        }
        if (!queueDeferreds[siteId]) {
            if (!create) {
                return;
            }
            queueDeferreds[siteId] = {};
        }
        if (!queueDeferreds[siteId][fileId]) {
            if (!create) {
                return;
            }
            queueDeferreds[siteId][fileId] = $q.defer();
        }
        return queueDeferreds[siteId][fileId];
    };
        self._getQueuePromise = function(siteId, fileId, create) {
        return self._getQueueDeferred(siteId, fileId, create).promise;
    };
        self._hasFileInPool = function(siteId, fileId) {
        return getSiteDb(siteId).then(function(db) {
            return db.get(mmFilepoolStore, fileId).then(function(fileObject) {
                if (typeof fileObject === 'undefined') {
                    return $q.reject();
                }
                return fileObject;
            });
        });
    };
        self._hasFileInQueue = function(siteId, fileId) {
        return $mmApp.getDB().get(mmFilepoolQueueStore, [siteId, fileId]).then(function(fileObject) {
            if (typeof fileObject === 'undefined') {
                return $q.reject();
            }
            return fileObject;
        });
    };
        self.getDirectoryUrlByUrl = function(siteId, fileUrl) {
        if ($mmFS.isAvailable()) {
            return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
                var fileId = self._getFileIdByUrl(fileUrl);
                return $mmFS.getDir(self._getFilePath(siteId, fileId, false)).then(function(dirEntry) {
                    return dirEntry.toURL();
                });
            });
        }
        return $q.reject();
    };
        self._getFileIdByUrl = function(fileUrl) {
        var url = self._removeRevisionFromUrl(fileUrl),
            filename;
        url = $mmText.decodeHTML($mmText.decodeURIComponent(url));
        if (url.indexOf('/webservice/pluginfile') !== -1) {
            angular.forEach(urlAttributes, function(regex) {
                url = url.replace(regex, '');
            });
        }
        filename = self._guessFilenameFromUrl(url);
        return filename + '_' + md5.createHash('url:' + url);
    };
        self._getNonReadableFileIdByUrl = function(fileUrl) {
        var url = self._removeRevisionFromUrl(fileUrl),
            candidate,
            extension = '';
        if (url.indexOf('/webservice/pluginfile') !== -1) {
            angular.forEach(urlAttributes, function(regex) {
                url = url.replace(regex, '');
            });
            candidate = $mmFS.guessExtensionFromUrl(url);
            if (candidate && candidate !== 'php') {
                extension = '.' + candidate;
            }
        }
        return md5.createHash('url:' + url) + extension;
    };
        self._getFileUrlByUrl = function(siteId, fileUrl, mode, component, componentId, timemodified, checkSize, downloadUnknown) {
        var fileId,
            revision;
        if (typeof checkSize == 'undefined') {
            checkSize = true;
        }
        return self._fixPluginfileURL(siteId, fileUrl).then(function(fixedUrl) {
            fileUrl = fixedUrl;
            timemodified = timemodified || 0;
            revision = self.getRevisionFromUrl(fileUrl);
            fileId = self._getFileIdByUrl(fileUrl);
            return self._restoreOldFileIfNeeded(siteId, fileId, fileUrl);
        }).then(function() {
            return self._hasFileInPool(siteId, fileId).then(function(fileObject) {
                var response,
                    fn;
                if (typeof fileObject === 'undefined') {
                    addToQueueIfNeeded();
                    response = fileUrl;
                } else if (self._isFileOutdated(fileObject, revision, timemodified) && $mmApp.isOnline()) {
                    addToQueueIfNeeded();
                    response = fileUrl;
                } else {
                    if (mode === 'src') {
                        fn = self._getInternalSrcById;
                    } else {
                        fn = self._getInternalUrlById;
                    }
                    response = fn(siteId, fileId).then(function(internalUrl) {
                        return internalUrl;
                    }, function() {
                        $log.debug('File ' + fileId + ' not found on disk');
                        self._removeFileById(siteId, fileId);
                        addToQueueIfNeeded();
                        if ($mmApp.isOnline()) {
                            return fileUrl;
                        }
                        return $q.reject();
                    });
                }
                return response;
            }, function() {
                addToQueueIfNeeded();
                return fileUrl;
            });
        });
        function addToQueueIfNeeded() {
            var promise;
            if (checkSize) {
                if (!$mmApp.isOnline()) {
                    return;
                }
                if (typeof sizeCache[fileUrl] != 'undefined') {
                    promise = $q.when(sizeCache[fileUrl]);
                } else {
                    promise = $mmWS.getRemoteFileSize(fileUrl);
                }
                promise.then(function(size) {
                    var isWifi = !$mmApp.isNetworkAccessLimited(),
                        sizeUnknown = size <= 0;
                    if (!sizeUnknown) {
                        sizeCache[fileUrl] = size;
                    }
                    if (sizeUnknown) {
                        if (downloadUnknown && isWifi) {
                            self.addToQueueByUrl(siteId, fileUrl, component, componentId, timemodified);
                        }
                    } else if (size <= mmFilepoolDownloadThreshold || (isWifi && size <= mmFilepoolWifiDownloadThreshold)) {
                        self.addToQueueByUrl(siteId, fileUrl, component, componentId, timemodified);
                    }
                });
            } else {
                self.addToQueueByUrl(siteId, fileUrl, component, componentId, timemodified);
            }
        }
    };
        self.getFilepoolFolderPath = function(siteId) {
        return $mmFS.getSiteFolder(siteId) + '/' + mmFilepoolFolder;
    };
        self._getFilePath = function(siteId, fileId, extension) {
        var path = $mmFS.getSiteFolder(siteId) + '/' + mmFilepoolFolder + '/' + fileId;
        if (typeof extension == 'undefined') {
            return self._hasFileInPool(siteId, fileId).then(function(fileObject) {
                if (fileObject.extension) {
                    path += '.' + fileObject.extension;
                }
                return path;
            }).catch(function() {
                return path;
            });
        } else {
            if (extension) {
                path += '.' + extension;
            }
            return path;
        }
    };
        self.getFilePathByUrl = function(siteId, fileUrl) {
        return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
            var fileId = self._getFileIdByUrl(fileUrl);
            return self._getFilePath(siteId, fileId);
        });
    };
    function getComponentFiles(db, component, componentId) {
        var fieldName, where;
        if (typeof componentId !== 'undefined') {
            fieldName = 'componentAndId';
            where = [component, self._fixComponentId(componentId)];
        } else {
            fieldName = 'component';
            where = component;
        }
        return db.whereEqual(mmFilepoolLinksStore, fieldName, where);
    }
        self.getFilesByComponent = function(siteId, component, componentId) {
        return getSiteDb(siteId).then(function(db) {
            return getComponentFiles(db, component, componentId).then(function(items) {
                var promises = [],
                    files = [];
                angular.forEach(items, function(item) {
                    promises.push(db.get(mmFilepoolStore, item.fileId).then(function(fileEntry) {
                        if (!fileEntry) {
                            return;
                        }
                        files.push({
                            url: fileEntry.url,
                            path: fileEntry.path,
                            extension: fileEntry.extension,
                            revision: fileEntry.revision,
                            timemodified: fileEntry.timemodified
                        });
                    }));
                });
                return $q.all(promises).then(function() {
                    return files;
                });
            });
        });
    };
        self.getFilesSizeByComponent = function(siteId, component, componentId) {
        return self.getFilesByComponent(siteId, component, componentId).then(function(files) {
            var promises = [],
                size = 0;
            angular.forEach(files, function(file) {
                promises.push($mmFS.getFileSize(file.path).then(function(fs) {
                    size += fs;
                }).catch(function() {
                }));
            });
            return $q.all(promises).then(function() {
                return size;
            });
        });
    };
        self.getFileStateByUrl = function(siteId, fileUrl, timemodified, filePath) {
        var fileId,
            revision;
        return self._fixPluginfileURL(siteId, fileUrl).then(function(fixedUrl) {
            fileUrl = fixedUrl;
            timemodified = timemodified || 0;
            revision = self.getRevisionFromUrl(fileUrl);
            fileId = self._getFileIdByUrl(fileUrl);
            return self._restoreOldFileIfNeeded(siteId, fileId, fileUrl);
        }).then(function() {
            return self._hasFileInQueue(siteId, fileId).then(function() {
                return mmCoreDownloading;
            }, function() {
                var extension = $mmFS.guessExtensionFromUrl(fileUrl),
                    pathPromise = filePath ? filePath : self._getFilePath(siteId, fileId, extension);
                return $q.when(pathPromise).then(function(filePath) {
                    var downloadId = self.getFileDownloadId(fileUrl, filePath);
                    if (filePromises[siteId] && filePromises[siteId][downloadId]) {
                        return mmCoreDownloading;
                    }
                    return self._hasFileInPool(siteId, fileId).then(function(fileObject) {
                        if (self._isFileOutdated(fileObject, revision, timemodified)) {
                            return mmCoreOutdated;
                        } else {
                            return mmCoreDownloaded;
                        }
                    }, function() {
                        return mmCoreNotDownloaded;
                    });
                });
            });
        });
    };
        self._getInternalSrcById = function(siteId, fileId) {
        if ($mmFS.isAvailable()) {
            return self._getFilePath(siteId, fileId).then(function(path) {
                return $mmFS.getFile(path).then(function(fileEntry) {
                    return $mmFS.getInternalURL(fileEntry);
                });
            });
        }
        return $q.reject();
    };
        self._getInternalUrlById = function(siteId, fileId) {
        if ($mmFS.isAvailable()) {
            return self._getFilePath(siteId, fileId).then(function(path) {
                return $mmFS.getFile(path).then(function(fileEntry) {
                    return fileEntry.toURL();
                });
            });
        }
        return $q.reject();
    };
        self._getInternalUrlByPath = function(filePath) {
        if ($mmFS.isAvailable()) {
            return $mmFS.getFile(filePath).then(function(fileEntry) {
                return fileEntry.toURL();
            });
        }
        return $q.reject();
    };
        self.getInternalUrlByUrl = function(siteId, fileUrl) {
        if ($mmFS.isAvailable()) {
            return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
                var fileId = self._getFileIdByUrl(fileUrl);
                return self._getInternalUrlById(siteId, fileId);
            });
        }
        return $q.reject();
    };
        self.getPackageDirPathByUrl = function(siteId, url) {
        return self._fixPluginfileURL(siteId, url).then(function(fixedUrl) {
            var fileId = self._getNonReadableFileIdByUrl(fixedUrl);
            return self._getFilePath(siteId, fileId, false);
        });
    };
        self.getPackageDirUrlByUrl = function(siteId, url) {
        if ($mmFS.isAvailable()) {
            return self._fixPluginfileURL(siteId, url).then(function(fixedUrl) {
                var fileId = self._getNonReadableFileIdByUrl(fixedUrl);
                return $mmFS.getDir(self._getFilePath(siteId, fileId, false)).then(function(dirEntry) {
                    return dirEntry.toURL();
                });
            });
        }
        return $q.reject();
    };
        self.getRevisionFromFileList = function(files) {
        var revision = 0;
        angular.forEach(files, function(file) {
            if (file.fileurl) {
                var r = self.getRevisionFromUrl(file.fileurl);
                if (r > revision) {
                    revision = r;
                }
            }
        });
        return revision;
    };
        self.getRevisionFromUrl = function(url) {
        var matches = url.match(revisionRegex);
        if (matches && typeof matches[1] != 'undefined') {
            return parseInt(matches[1]);
        }
    };
        self.getSrcByUrl = function(siteId, fileUrl, component, componentId, timemodified, checkSize, downloadUnknown) {
        return self._getFileUrlByUrl(siteId, fileUrl, 'src', component, componentId, timemodified, checkSize, downloadUnknown);
    };
        self.getTimemodifiedFromFileList = function(files) {
        var timemod = 0;
        angular.forEach(files, function(file) {
            if (file.timemodified > timemod) {
                timemod = file.timemodified;
            }
        });
        return timemod;
    };
        self.getUrlByUrl = function(siteId, fileUrl, component, componentId, timemodified, checkSize, downloadUnknown) {
        return self._getFileUrlByUrl(siteId, fileUrl, 'url', component, componentId, timemodified, checkSize, downloadUnknown);
    };
        self._guessFilenameFromUrl = function(fileUrl) {
        var filename = '';
        if (fileUrl.indexOf('/webservice/pluginfile') !== -1) {
            var params = $mmUtil.extractUrlParams(fileUrl);
            if (params.file) {
                filename = params.file.substr(params.file.lastIndexOf('/') + 1);
            } else {
                filename = $mmText.getLastFileWithoutParams(fileUrl);
            }
        } else if ($mmUtil.isGravatarUrl(fileUrl)) {
            filename = 'gravatar_' + $mmText.getLastFileWithoutParams(fileUrl);
        } else if ($mmUtil.isThemeImageUrl(fileUrl)) {
            var matches = fileUrl.match(/clean\/core\/([^\/]*)\//);
            if (matches && matches[1]) {
                filename = matches[1];
            }
            filename = 'default_' + filename + '_' + $mmText.getLastFileWithoutParams(fileUrl);
        } else {
            filename = $mmText.getLastFileWithoutParams(fileUrl);
        }
        filename = $mmFS.removeExtension(filename);
        return $mmText.removeSpecialCharactersForFiles(filename);
    };
        self.invalidateAllFiles = function(siteId) {
        return getSiteDb(siteId).then(function(db) {
            return db.getAll(mmFilepoolStore).then(function(items) {
                var promises = [];
                angular.forEach(items, function(item) {
                    item.stale = true;
                    promises.push(db.insert(mmFilepoolStore, item));
                });
                return $q.all(promises);
            });
        });
    };
        self.invalidateFileByUrl = function(siteId, fileUrl) {
        return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
            var fileId = self._getFileIdByUrl(fileUrl);
            return getSiteDb(siteId).then(function(db) {
                return db.get(mmFilepoolStore, fileId).then(function(fileObject) {
                    if (!fileObject) {
                        return;
                    }
                    fileObject.stale = true;
                    return db.insert(mmFilepoolStore, fileObject);
                });
            });
        });
    };
        self.invalidateFilesByComponent = function(siteId, component, componentId) {
        return getSiteDb(siteId).then(function(db) {
            return getComponentFiles(db, component, componentId).then(function(items) {
                var promise,
                    promises = [];
                angular.forEach(items, function(item) {
                    promise = db.get(mmFilepoolStore, item.fileId).then(function(fileEntry) {
                        if (!fileEntry) {
                            return;
                        }
                        fileEntry.stale = true;
                        return db.insert(mmFilepoolStore, fileEntry);
                    });
                    promises.push(promise);
                });
                return $q.all(promises);
            });
        });
    };
        self.isFileDownloadingByUrl = function(siteId, fileUrl) {
        return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
            fileId = self._getFileIdByUrl(fileUrl);
            return self._hasFileInQueue(siteId, fileId);
        });
    };
        self._isFileOutdated = function(fileObject, revision, timemodified) {
        return fileObject.stale || revision > fileObject.revision || timemodified > fileObject.timemodified;
    };
        self._notifyFileDeleted = function(siteId, fileId) {
        $mmEvents.trigger(self._getFileEventName(siteId, fileId), {action: 'deleted'});
    };
        self._notifyFileDownloaded = function(siteId, fileId) {
        $mmEvents.trigger(self._getFileEventName(siteId, fileId), {action: 'download', success: true});
    };
        self._notifyFileDownloadError = function(siteId, fileId) {
        $mmEvents.trigger(self._getFileEventName(siteId, fileId), {action: 'download', success: false});
    };
        self._notifyFileDownloading = function(siteId, fileId) {
        $mmEvents.trigger(self._getFileEventName(siteId, fileId), {action: 'downloading'});
    };
        self._notifyFileOutdated = function(siteId, fileId) {
        $mmEvents.trigger(self._getFileEventName(siteId, fileId), {action: 'outdated'});
    };
        self.prefetchPackage = function(siteId, fileList, component, componentId, revision, timemodified, dirPath) {
        return self._downloadOrPrefetchPackage(siteId, fileList, true, component, componentId, revision, timemodified, dirPath);
    };
        self._processQueue = function() {
        var deferred = $q.defer(),
            promise;
        if (queueState !== QUEUE_RUNNING) {
            deferred.reject(ERR_QUEUE_ON_PAUSE);
            promise = deferred.promise;
        } else if (!$mmFS.isAvailable() || !$mmApp.isOnline()) {
            deferred.reject(ERR_FS_OR_NETWORK_UNAVAILABLE);
            promise = deferred.promise;
        } else {
            promise = self._processImportantQueueItem();
        }
        promise.then(function() {
            $timeout(self._processQueue, mmFilepoolQueueProcessInterval);
        }, function(error) {
            if (error === ERR_FS_OR_NETWORK_UNAVAILABLE) {
                $log.debug('Filesysem or network unavailable, pausing queue processing.');
            } else if (error === ERR_QUEUE_IS_EMPTY) {
                $log.debug('Queue is empty, pausing queue processing.');
                $mmEvents.trigger(mmCoreEventQueueEmpty);
            }
            queueState = QUEUE_PAUSED;
        });
    };
        self._processImportantQueueItem = function() {
        return $mmApp.getDB().query(mmFilepoolQueueStore, undefined, 'sortorder', undefined, 1)
        .then(function(items) {
            var item = items.pop();
            if (!item) {
                return $q.reject(ERR_QUEUE_IS_EMPTY);
            }
            return self._processQueueItem(item);
        }, function() {
            return $q.reject(ERR_QUEUE_IS_EMPTY);
        });
    };
        self._processQueueItem = function(item) {
        var siteId = item.siteId,
            fileId = item.fileId,
            fileUrl = item.url,
            revision = item.revision,
            timemodified = item.timemodified,
            filePath = item.path,
            links = item.links || [];
        $log.debug('Processing queue item: ' + siteId + ', ' + fileId);
        return getSiteDb(siteId).then(function(db) {
            return db.get(mmFilepoolStore, fileId).then(function(fileObject) {
                if (fileObject && !self._isFileOutdated(fileObject, revision, timemodified)) {
                    $log.debug('Queued file already in store, ignoring...');
                    self._addFileLinks(siteId, fileId, links);
                    self._removeFromQueue(siteId, fileId).finally(function() {
                        self._treatQueueDeferred(siteId, fileId, true);
                    });
                    self._notifyFileDownloaded(siteId, fileId);
                    return;
                }
                return download(siteId, fileUrl, fileObject, links);
            }, function() {
                return download(siteId, fileUrl, undefined, links);
            });
        }, function() {
            $log.debug('Item dropped from queue due to site DB not retrieved: ' + fileUrl);
            return self._removeFromQueue(siteId, fileId).catch(function() {}).finally(function() {
                self._treatQueueDeferred(siteId, fileId, false);
                self._notifyFileDownloadError(siteId, fileId);
            });
        });
                function download(siteId, fileUrl, fileObject, links) {
            return self._restoreOldFileIfNeeded(siteId, fileId, fileUrl, filePath).then(function() {
                return self._downloadForPoolByUrl(siteId, fileUrl, revision, timemodified, filePath, fileObject).then(function() {
                    var promise;
                    self._addFileLinks(siteId, fileId, links);
                    promise = self._removeFromQueue(siteId, fileId);
                    self._treatQueueDeferred(siteId, fileId, true);
                    self._notifyFileDownloaded(siteId, fileId);
                    return promise.catch(function() {});
                }, function(errorObject) {
                    var dropFromQueue = false;
                    if (typeof errorObject !== 'undefined' && errorObject.source === fileUrl) {
                        if (errorObject.code === 1) {
                            dropFromQueue = true;
                        } else if (errorObject.code === 2) {
                            dropFromQueue = true;
                        } else if (errorObject.code === 3) {
                            dropFromQueue = true;
                        } else if (errorObject.code === 4) {
                        } else if (errorObject.code === 5) {
                            dropFromQueue = true;
                        } else {
                            dropFromQueue = true;
                        }
                    } else {
                        dropFromQueue = true;
                    }
                    if (dropFromQueue) {
                        var promise;
                        $log.debug('Item dropped from queue due to error: ' + fileUrl);
                        promise = self._removeFromQueue(siteId, fileId);
                        return promise.catch(function() {}).finally(function() {
                            self._treatQueueDeferred(siteId, fileId, false);
                            self._notifyFileDownloadError(siteId, fileId);
                        });
                    } else {
                        self._treatQueueDeferred(siteId, fileId, false);
                        self._notifyFileDownloadError(siteId, fileId);
                        return $q.reject();
                    }
                }, function(progress) {
                    if (queueDeferreds[siteId] && queueDeferreds[siteId][fileId]) {
                        queueDeferreds[siteId][fileId].notify(progress);
                    }
                });
            });
        }
    };
        self._removeFromQueue = function(siteId, fileId) {
        return $mmApp.getDB().remove(mmFilepoolQueueStore, [siteId, fileId]);
    };
        self._removeFileById = function(siteId, fileId) {
        return getSiteDb(siteId).then(function(db) {
            return self._getFilePath(siteId, fileId).then(function(path) {
                var promises = [];
                promises.push(db.remove(mmFilepoolStore, fileId));
                promises.push(db.whereEqual(mmFilepoolLinksStore, 'fileId', fileId).then(function(entries) {
                    return $q.all(entries.map(function(entry) {
                        return db.remove(mmFilepoolLinksStore, [entry.fileId, entry.component, entry.componentId]);
                    }));
                }));
                if ($mmFS.isAvailable()) {
                    promises.push($mmFS.removeFile(path).catch(function(error) {
                        if (error && error.code == 1) {
                        } else {
                            return $q.reject(error);
                        }
                    }));
                }
                return $q.all(promises).then(function() {
                    self._notifyFileDeleted(siteId, fileId);
                });
            });
        });
    };
        self.removeFilesByComponent = function(siteId, component, componentId) {
        return getSiteDb(siteId).then(function(db) {
            return getComponentFiles(db, component, componentId);
        }).then(function(items) {
            return $q.all(items.map(function(item) {
                return self._removeFileById(siteId, item.fileId);
            }));
        });
    };
        self.removeFileByUrl = function(siteId, fileUrl) {
        return self._fixPluginfileURL(siteId, fileUrl).then(function(fileUrl) {
            var fileId = self._getFileIdByUrl(fileUrl);
            return self._restoreOldFileIfNeeded(siteId, fileId, fileUrl).then(function() {
                return self._removeFileById(siteId, fileId);
            });
        });
    };
        self._removeRevisionFromUrl = function(url) {
        return url.replace(revisionRegex, '/content/0/');
    };
        self._fillExtensionInFile = function(fileObject, siteId) {
        var extension;
        if (typeof fileObject.extension != 'undefined') {
            return;
        }
        return getSiteDb(siteId).then(function(db) {
            extension = $mmFS.getFileExtension(fileObject.path);
            if (!extension) {
                fileObject.stale = true;
                $log.debug('Staled file with no extension ' + fileObject.fileId);
                return db.insert(mmFilepoolStore, fileObject);
            }
            var fileId = fileObject.fileId;
            fileObject.fileId = $mmFS.removeExtension(fileId);
            fileObject.extension = extension;
            return db.insert(mmFilepoolStore, fileObject).then(function() {
                if (fileObject.fileId == fileId) {
                    $log.debug('Removed extesion ' + extension + ' from file ' + fileObject.fileId);
                    return $q.when();
                }
                return db.whereEqual(mmFilepoolLinksStore, 'fileId', fileId).then(function(entries) {
                    return $q.all(entries.map(function(linkEntry) {
                        linkEntry.fileId = fileObject.fileId;
                        return db.insert(mmFilepoolLinksStore, linkEntry).then(function() {
                            $log.debug('Removed extesion ' + extension + ' from file links ' + linkEntry.fileId);
                            return db.remove(mmFilepoolLinksStore, [fileId, linkEntry.component, linkEntry.componentId]);
                        });
                    }));
                }).finally(function() {
                    $log.debug('Removed extesion ' + extension + ' from file ' + fileObject.fileId);
                    return db.remove(mmFilepoolStore, fileId);
                });
            });
        });
    };
        self.fillMissingExtensionInFiles = function(siteId) {
        $log.debug('Fill missing extensions in files of ' + siteId);
        return getSiteDb(siteId).then(function(db) {
            return db.getAll(mmFilepoolStore).then(function(fileObjects) {
                var promises = [];
                angular.forEach(fileObjects, function(fileObject) {
                    promises.push(self._fillExtensionInFile(fileObject, siteId));
                });
                return $q.all(promises);
            });
        });
    };
        self.treatExtensionInQueue = function() {
        var appDB;
        $log.debug('Treat extensions in queue');
        appDB = $mmApp.getDB();
        return appDB.getAll(mmFilepoolQueueStore).then(function(fileObjects) {
            var promises = [];
            angular.forEach(fileObjects, function(fileObject) {
                var fileId = fileObject.fileId;
                fileObject.fileId = $mmFS.removeExtension(fileId);
                if (fileId == fileObject.fileId) {
                    return;
                }
                promises.push(appDB.insert(mmFilepoolQueueStore, fileObject).then(function() {
                    $log.debug('Removed extesion from queued file ' + fileObject.fileId);
                    return self._removeFromQueue(fileObject.siteId, fileId);
                }));
            });
            return $q.all(promises);
        });
    };
        self._restoreOldFileIfNeeded = function(siteId, fileId, fileUrl, filePath) {
        var fileObject,
            oldFileId = self._getNonReadableFileIdByUrl(fileUrl);
        if (fileId == oldFileId) {
            return $q.when();
        }
        return self._hasFileInPool(siteId, fileId).catch(function() {
            return self._hasFileInPool(siteId, oldFileId).then(function(entry) {
                fileObject = entry;
                if (filePath) {
                    return $q.when();
                } else {
                    return self._getFilePath(siteId, oldFileId).then(function(oldPath) {
                        return self._getFilePath(siteId, fileId).then(function(newPath) {
                            return $mmFS.copyFile(oldPath, newPath);
                        });
                    });
                }
            }).then(function() {
                return self._addFileToPool(siteId, fileId, fileObject);
            }).then(function() {
                return self._getFileLinks(siteId, fileId).then(function(links) {
                    var promises = [];
                    angular.forEach(links, function(link) {
                        promises.push(self._addFileLink(siteId, fileId, link.component, link.componentId));
                    });
                    return $q.all(promises);
                });
            }).then(function() {
                return self._removeFileById(siteId, oldFileId);
            }).catch(function() {
            });
        });
    };
        self.setPackagePreviousStatus = function(siteId, component, componentId) {
        $log.debug('Set previous status for package ' + component + ' ' + componentId);
        componentId = self._fixComponentId(componentId);
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var db = site.getDb(),
                packageId = self.getPackageId(component, componentId);
            return db.get(mmFilepoolPackagesStore, packageId).then(function(entry) {
                if (entry.status == mmCoreDownloading) {
                    entry.downloadtime = entry.previousdownloadtime;
                }
                entry.status = entry.previous || mmCoreNotDownloaded;
                entry.updated = new Date().getTime();
                $log.debug('Set status \'' + entry.status + '\' for package ' + component + ' ' + componentId);
                return db.insert(mmFilepoolPackagesStore, entry).then(function() {
                    self._triggerPackageStatusChanged(siteId, component, componentId, entry.status);
                    return entry.status;
                });
            });
        });
    };
        self.shouldDownloadBeforeOpen = function(url, size) {
        if (size >= 0 && size <= mmFilepoolDownloadThreshold) {
            return $q.when();
        }
        return $mmUtil.getMimeType(url).then(function(mimetype) {
            if (mimetype.indexOf('video') != -1 || mimetype.indexOf('audio') != -1) {
                return $q.reject();
            }
        });
    };
        self.storePackageStatus = function(siteId, component, componentId, status, revision, timemodified) {
        $log.debug('Set status \'' + status + '\' for package ' + component + ' ' + componentId);
        componentId = self._fixComponentId(componentId);
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var db = site.getDb(),
                packageId = self.getPackageId(component, componentId),
                downloadTime,
                previousDownloadTime;
            if (status == mmCoreDownloading) {
                downloadTime = $mmUtil.timestamp();
            }
            return db.get(mmFilepoolPackagesStore, packageId).then(function(entry) {
                if (typeof revision == 'undefined') {
                    revision = entry.revision;
                }
                if (typeof timemodified == 'undefined') {
                    timemodified = entry.timemodified;
                }
                if (typeof downloadTime == 'undefined') {
                    downloadTime = entry.downloadtime;
                    previousDownloadTime = entry.previousdownloadtime;
                } else {
                    previousDownloadTime = entry.downloadTime;
                }
                return entry.status;
            }).catch(function() {
                return undefined;
            }).then(function(previousStatus) {
                revision = revision || 0;
                timemodified = timemodified || 0;
                var promise;
                if (previousStatus === status) {
                    promise = $q.when();
                } else {
                    promise = db.insert(mmFilepoolPackagesStore, {
                        id: packageId,
                        component: component,
                        componentId: componentId,
                        status: status,
                        previous: previousStatus,
                        revision: revision,
                        timemodified: timemodified,
                        updated: new Date().getTime(),
                        downloadtime: downloadTime,
                        previousdownloadtime: previousDownloadTime
                    });
                }
                return promise.then(function() {
                    self._triggerPackageStatusChanged(siteId, component, componentId, status);
                });
            });
        });
    };
        self._treatQueueDeferred = function(siteId, fileId, resolve) {
        if (queueDeferreds[siteId] && queueDeferreds[siteId][fileId]) {
            if (resolve) {
                queueDeferreds[siteId][fileId].resolve();
            } else {
                queueDeferreds[siteId][fileId].reject();
            }
            delete queueDeferreds[siteId][fileId];
        }
    };
        self._triggerPackageStatusChanged = function(siteId, component, componentId, status) {
        var data = {
            siteid: siteId,
            component: component,
            componentId: self._fixComponentId(componentId),
            status: status
        };
        $mmEvents.trigger(mmCoreEventPackageStatusChanged, data);
    };
    return self;
}])
.run(["$ionicPlatform", "$timeout", "$mmFilepool", "$mmEvents", "mmCoreEventOnlineStatusChanged", function($ionicPlatform, $timeout, $mmFilepool, $mmEvents, mmCoreEventOnlineStatusChanged) {
    $ionicPlatform.ready(function() {
        $timeout($mmFilepool.checkQueueProcessing, 1000);
        $mmEvents.on(mmCoreEventOnlineStatusChanged, function(online) {
            if (online) {
                $mmFilepool.checkQueueProcessing();
            }
        });
    });
}]);

angular.module('mm.core')
.constant('mmFsSitesFolder', 'sites')
.constant('mmFsTmpFolder', 'tmp')
.factory('$mmFS', ["$ionicPlatform", "$cordovaFile", "$log", "$q", "$http", "$cordovaZip", "$mmText", "mmFsSitesFolder", "mmFsTmpFolder", function($ionicPlatform, $cordovaFile, $log, $q, $http, $cordovaZip, $mmText, mmFsSitesFolder, mmFsTmpFolder) {
    $log = $log.getInstance('$mmFS');
    var self = {},
        initialized = false,
        basePath = '',
        isHTMLAPI = false,
        extToMime = {},
        mimeToExt = {},
        extensionRegex = new RegExp('^[a-z0-9]+$');
    $http.get('core/assets/mimetypes.json').then(function(response) {
        extToMime = response.data;
    }, function() {
    });
    $http.get('core/assets/mimetoext.json').then(function(response) {
        mimeToExt = response.data;
    }, function() {
    });
    self.FORMATTEXT         = 0;
    self.FORMATDATAURL      = 1;
    self.FORMATBINARYSTRING = 2;
    self.FORMATARRAYBUFFER  = 3;
        self.setHTMLBasePath = function(path) {
        isHTMLAPI = true;
        basePath = path;
    };
        self.usesHTMLAPI = function() {
        return isHTMLAPI;
    };
        self.init = function() {
        var deferred = $q.defer();
        if (initialized) {
            deferred.resolve();
            return deferred.promise;
        }
        $ionicPlatform.ready(function() {
            if (ionic.Platform.isAndroid()) {
                basePath = cordova.file.externalApplicationStorageDirectory;
            } else if (ionic.Platform.isIOS()) {
                basePath = cordova.file.documentsDirectory;
            } else if (!self.isAvailable() || basePath === '') {
                $log.error('Error getting device OS.');
                deferred.reject();
                return;
            }
            initialized = true;
            $log.debug('FS initialized: '+basePath);
            deferred.resolve();
        });
        return deferred.promise;
    };
        self.isAvailable = function() {
        return typeof window.resolveLocalFileSystemURL !== 'undefined' && typeof FileTransfer !== 'undefined';
    };
        self.getFile = function(path) {
        path = self.removeStartingSlash(path.replace(basePath, ''));
        return self.init().then(function() {
            $log.debug('Get file: ' + path);
            return $cordovaFile.checkFile(basePath, path);
        });
    };
        self.getDir = function(path) {
        path = self.removeStartingSlash(path.replace(basePath, ''));
        return self.init().then(function() {
            $log.debug('Get directory: '+path);
            return $cordovaFile.checkDir(basePath, path);
        });
    };
        self.getSiteFolder = function(siteId) {
        return mmFsSitesFolder + '/' + siteId;
    };
        function create(isDirectory, path, failIfExists, base) {
        path = self.removeStartingSlash(path.replace(basePath, ''));
        return self.init().then(function() {
            base = base || basePath;
            if (path.indexOf('/') == -1) {
                if (isDirectory) {
                    $log.debug('Create dir ' + path + ' in ' + base);
                    return $cordovaFile.createDir(base, path, !failIfExists);
                } else {
                    $log.debug('Create file ' + path + ' in ' + base);
                    return $cordovaFile.createFile(base, path, !failIfExists);
                }
            } else {
                var firstDir = path.substr(0, path.indexOf('/'));
                var restOfPath = path.substr(path.indexOf('/') + 1);
                $log.debug('Create dir ' + firstDir + ' in ' + base);
                return $cordovaFile.createDir(base, firstDir, true).then(function(newDirEntry) {
                    return create(isDirectory, restOfPath, failIfExists, newDirEntry.toURL());
                }, function(error) {
                    $log.error('Error creating directory ' + firstDir + ' in ' + base);
                    return $q.reject(error);
                });
            }
        });
    }
        self.createDir = function(path, failIfExists) {
        failIfExists = failIfExists || false;
        return create(true, path, failIfExists);
    };
        self.createFile = function(path, failIfExists) {
        failIfExists = failIfExists || false;
        return create(false, path, failIfExists);
    };
        self.removeDir = function(path) {
        path = self.removeStartingSlash(path.replace(basePath, ''));
        return self.init().then(function() {
            $log.debug('Remove directory: ' + path);
            return $cordovaFile.removeRecursively(basePath, path);
        });
    };
        self.removeFile = function(path) {
        path = self.removeStartingSlash(path.replace(basePath, ''));
        return self.init().then(function() {
            $log.debug('Remove file: ' + path);
            return $cordovaFile.removeFile(basePath, path);
        });
    };
        self.removeFileByFileEntry = function(fileEntry) {
        var deferred = $q.defer();
        fileEntry.remove(deferred.resolve, deferred.reject);
        return deferred.promise;
    };
        self.getDirectoryContents = function(path) {
        path = self.removeStartingSlash(path.replace(basePath, ''));
        $log.debug('Get contents of dir: ' + path);
        return self.getDir(path).then(function(dirEntry) {
            var deferred = $q.defer();
            var directoryReader = dirEntry.createReader();
            directoryReader.readEntries(deferred.resolve, deferred.reject);
            return deferred.promise;
        });
    };
        function getSize(entry) {
        var deferred = $q.defer();
        if (entry.isDirectory) {
            var directoryReader = entry.createReader();
            directoryReader.readEntries(function(entries) {
                var promises = [];
                for (var i = 0; i < entries.length; i++) {
                    promises.push(getSize(entries[i]));
                }
                $q.all(promises).then(function(sizes) {
                    var directorySize = 0;
                    for (var i = 0; i < sizes.length; i++) {
                        var fileSize = parseInt(sizes[i]);
                        if (isNaN(fileSize)) {
                            deferred.reject();
                            return;
                        }
                        directorySize += fileSize;
                    }
                    deferred.resolve(directorySize);
                }, deferred.reject);
            }, deferred.reject);
        } else if (entry.isFile) {
            entry.file(function(file) {
                deferred.resolve(file.size);
            }, deferred.reject);
        }
        return deferred.promise;
    }
        self.getDirectorySize = function(path) {
        path = self.removeStartingSlash(path.replace(basePath, ''));
        $log.debug('Get size of dir: ' + path);
        return self.getDir(path).then(function(dirEntry) {
           return getSize(dirEntry);
        });
    };
        self.getFileSize = function(path) {
        path = self.removeStartingSlash(path.replace(basePath, ''));
        $log.debug('Get size of file: ' + path);
        return self.getFile(path).then(function(fileEntry) {
           return getSize(fileEntry);
        });
    };
        self.getFileObjectFromFileEntry = function(entry) {
        $log.debug('Get file object of: ' + entry.fullPath);
        var deferred = $q.defer();
        entry.file(function(file) {
            deferred.resolve(file);
        }, deferred.reject);
        return deferred.promise;
    };
        self.calculateFreeSpace = function() {
        if (ionic.Platform.isIOS() || isHTMLAPI) {
            if (window.requestFileSystem) {
                var iterations = 0,
                    maxIterations = 50,
                    deferred = $q.defer();
                function calculateByRequest(size, ratio) {
                    var deferred = $q.defer();
                    window.requestFileSystem(LocalFileSystem.PERSISTENT, size, function() {
                        iterations++;
                        if (iterations > maxIterations) {
                            deferred.resolve(size);
                            return;
                        }
                        calculateByRequest(size * ratio, ratio).then(deferred.resolve);
                    }, function() {
                        deferred.resolve(size / ratio);
                    });
                    return deferred.promise;
                }
                calculateByRequest(1048576, 1.3).then(function(size) {
                    iterations = 0;
                    maxIterations = 10;
                    calculateByRequest(size, 1.1).then(deferred.resolve);
                });
                return deferred.promise;
            } else {
                return $q.reject();
            }
        } else {
            return $cordovaFile.getFreeDiskSpace().then(function(size) {
                return size * 1024;
            });
        }
    };
        self.normalizeFileName = function(filename) {
        filename = $mmText.decodeURIComponent(filename);
        return filename;
    };
        self.readFile = function(path, format) {
        path = self.removeStartingSlash(path.replace(basePath, ''));
        format = format || self.FORMATTEXT;
        $log.debug('Read file ' + path + ' with format '+format);
        switch (format) {
            case self.FORMATDATAURL:
                return $cordovaFile.readAsDataURL(basePath, path);
            case self.FORMATBINARYSTRING:
                return $cordovaFile.readAsBinaryString(basePath, path);
            case self.FORMATARRAYBUFFER:
                return $cordovaFile.readAsArrayBuffer(basePath, path);
            default:
                return $cordovaFile.readAsText(basePath, path);
        }
    };
        self.readFileData = function(fileData, format) {
        format = format || self.FORMATTEXT;
        $log.debug('Read file from file data with format '+format);
        var deferred = $q.defer();
        var reader = new FileReader();
        reader.onloadend = function(evt) {
            if (evt.target.result !== undefined || evt.target.result !== null) {
                deferred.resolve(evt.target.result);
            } else if (evt.target.error !== undefined || evt.target.error !== null) {
                deferred.reject(evt.target.error);
            } else {
                deferred.reject({code: null, message: 'READER_ONLOADEND_ERR'});
            }
        };
        switch (format) {
            case self.FORMATDATAURL:
                reader.readAsDataURL(fileData);
                break;
            case self.FORMATBINARYSTRING:
                reader.readAsBinaryString(fileData);
                break;
            case self.FORMATARRAYBUFFER:
                reader.readAsArrayBuffer(fileData);
                break;
            default:
                reader.readAsText(fileData);
        }
        return deferred.promise;
    };
        self.writeFile = function(path, data) {
        path = self.removeStartingSlash(path.replace(basePath, ''));
        $log.debug('Write file: ' + path);
        return self.init().then(function() {
            return self.createFile(path).then(function(fileEntry) {
                if (isHTMLAPI && typeof data == 'string') {
                    var type = self.getMimeType(self.getFileExtension(path));
                    data = new Blob([data], {type: type || 'text/plain'});
                }
                return $cordovaFile.writeFile(basePath, path, data, true).then(function() {
                    return fileEntry;
                });
            });
        });
    };
        self.getExternalFile = function(fullPath) {
        return $cordovaFile.checkFile(fullPath, '');
    };
        self.removeExternalFile = function(fullPath) {
        var directory = fullPath.substring(0, fullPath.lastIndexOf('/') );
        var filename = fullPath.substr(fullPath.lastIndexOf('/') + 1);
        return $cordovaFile.removeFile(directory, filename);
    };
        self.getBasePath = function() {
        return self.init().then(function() {
            if (basePath.slice(-1) == '/') {
                return basePath;
            } else {
                return basePath + '/';
            }
        });
    };
        self.getBasePathToDownload = function() {
        return self.init().then(function() {
            if (ionic.Platform.isIOS()) {
                return $cordovaFile.checkDir(basePath, '').then(function(dirEntry) {
                    return dirEntry.toInternalURL();
                });
            } else {
                return basePath;
            }
        });
    };
        self.getTmpFolder = function() {
        return mmFsTmpFolder;
    };
        self.moveFile = function(originalPath, newPath) {
        originalPath = self.removeStartingSlash(originalPath.replace(basePath, ''));
        newPath = self.removeStartingSlash(newPath.replace(basePath, ''));
        return self.init().then(function() {
            if (isHTMLAPI) {
                var commonPath = basePath,
                    dirsA = originalPath.split('/'),
                    dirsB = newPath.split('/');
                for (var i = 0; i < dirsA.length; i++) {
                    var dir = dirsA[i];
                    if (dirsB[i] === dir) {
                        dir = dir + '/';
                        commonPath = self.concatenatePaths(commonPath, dir);
                        originalPath = originalPath.replace(dir, '');
                        newPath = newPath.replace(dir, '');
                    } else {
                        break;
                    }
                }
                return $cordovaFile.moveFile(commonPath, originalPath, commonPath, newPath);
            } else {
                return $cordovaFile.moveFile(basePath, originalPath, basePath, newPath);
            }
        });
    };
        self.copyFile = function(from, to) {
        from = self.removeStartingSlash(from.replace(basePath, ''));
        to = self.removeStartingSlash(to.replace(basePath, ''));
        return self.init().then(function() {
            if (isHTMLAPI) {
                var commonPath = basePath,
                    dirsA = from.split('/'),
                    dirsB = to.split('/');
                for (var i = 0; i < dirsA.length; i++) {
                    var dir = dirsA[i];
                    if (dirsB[i] === dir) {
                        dir = dir + '/';
                        commonPath = self.concatenatePaths(commonPath, dir);
                        from = from.replace(dir, '');
                        to = to.replace(dir, '');
                    } else {
                        break;
                    }
                }
                return $cordovaFile.copyFile(commonPath, from, commonPath, to);
            } else {
                var toFile = self.getFileAndDirectoryFromPath(to);
                if (toFile.directory == '') {
                    return $cordovaFile.copyFile(basePath, from, basePath, to);
                } else {
                    return self.createDir(toFile.directory).then(function() {
                        return $cordovaFile.copyFile(basePath, from, basePath, to);
                    });
                }
            }
        });
    };
        self.getFileAndDirectoryFromPath = function(path) {
        var file = {
            directory: '',
            name: ''
        };
        file.directory = path.substring(0, path.lastIndexOf('/') );
        file.name = path.substr(path.lastIndexOf('/') + 1);
        return file;
    };
        self.concatenatePaths = function(leftPath, rightPath) {
        if (!leftPath) {
            return rightPath;
        } else if (!rightPath) {
            return leftPath;
        }
        var lastCharLeft = leftPath.slice(-1),
            firstCharRight = rightPath.charAt(0);
        if (lastCharLeft === '/' && firstCharRight === '/') {
            return leftPath + rightPath.substr(1);
        } else if(lastCharLeft !== '/' && firstCharRight !== '/') {
            return leftPath + '/' + rightPath;
        } else {
            return leftPath + rightPath;
        }
    };
        self.getInternalURL = function(fileEntry) {
        if (isHTMLAPI) {
            return fileEntry.toURL();
        }
        return fileEntry.toInternalURL();
    };
        self.getFileIcon = function(filename) {
        var ext = self.getFileExtension(filename),
            icon = 'unknown';
        if (ext && extToMime[ext]) {
            if (extToMime[ext].icon) {
                icon = extToMime[ext].icon;
            } else {
                var type = extToMime[ext].type.split('/')[0];
                if (type == 'video' || type == 'text' || type == 'image' || type == 'document' || type == 'audio') {
                    icon = type;
                }
            }
        }
        return 'img/files/' + icon + '-64.png';
    };
        self.getFolderIcon = function() {
        return 'img/files/folder-64.png';
    };
        self.getFileExtension = function(filename) {
        var dot = filename.lastIndexOf("."),
            ext;
        if (dot > -1) {
            ext = filename.substr(dot + 1).toLowerCase();
            ext = ext.replace(/_.{32}$/, '');
            if (typeof self.getMimeType(ext) == 'undefined') {
                $log.debug('Get file extension: Not valid extension ' + ext);
                return;
            }
        }
        return ext;
    };
        self.getMimeType = function(extension) {
        if (extToMime[extension] && extToMime[extension].type) {
            return extToMime[extension].type;
        }
    };
        self.guessExtensionFromUrl = function(fileUrl) {
        var split = fileUrl.split('.'),
            candidate,
            extension,
            position;
        if (split.length > 1) {
            candidate = split.pop().toLowerCase();
            position = candidate.indexOf('?');
            if (position > -1) {
                candidate = candidate.substr(0, position);
            }
            if (extensionRegex.test(candidate)) {
                extension = candidate;
            }
        }
        if (extension && typeof self.getMimeType(extension) == 'undefined') {
            $log.debug('Guess file extension: Not valid extension ' + extension);
            return;
        }
        return extension;
    };
        self.getExtension = function(mimetype, url) {
        if (mimetype == 'application/x-forcedownload' || mimetype == 'application/forcedownload') {
            return self.guessExtensionFromUrl(url);
        }
        var extensions = mimeToExt[mimetype];
        if (extensions && extensions.length) {
            if (extensions.length > 1 && url) {
                var candidate = self.guessExtensionFromUrl(url);
                if (extensions.indexOf(candidate) != -1) {
                    return candidate;
                }
            }
            return extensions[0];
        }
        return undefined;
    };
        self.removeExtension = function(path) {
        var extension,
            position = path.lastIndexOf('.');
        if (position > -1) {
            extension = path.substr(position + 1);
            if (typeof self.getMimeType(extension) != 'undefined') {
                return path.substr(0, position);
            }
        }
        return path;
    };
        self.addBasePathIfNeeded = function(path) {
        if (path.indexOf(basePath) > -1) {
            return path;
        } else {
            return self.concatenatePaths(basePath, path);
        }
    };
        self.removeBasePath = function(path) {
        if (path.indexOf(basePath) > -1) {
            return path.replace(basePath, '');
        } else {
            return false;
        }
    };
        self.unzipFile = function(path, destFolder) {
        path = self.removeStartingSlash(path.replace(basePath, ''));
        return self.getFile(path).then(function(fileEntry) {
            destFolder = self.addBasePathIfNeeded(destFolder || self.removeExtension(path));
            return $cordovaZip.unzip(fileEntry.toURL(), destFolder);
        });
    };
        self.replaceInFile = function(path, search, newValue) {
        return self.readFile(path).then(function(content) {
            if (typeof content == 'undefined' || content === null || !content.replace) {
                return $q.reject();
            }
            if (content.match(search)) {
                content = content.replace(search, newValue);
                return self.writeFile(path, content);
            }
        });
    };
        self.getMetadata = function(fileEntry) {
        if (!fileEntry || !fileEntry.getMetadata) {
            return $q.reject();
        }
        var deferred = $q.defer();
        fileEntry.getMetadata(deferred.resolve, deferred.reject);
        return deferred.promise;
    };
        self.getMetadataFromPath = function(path, isDir) {
        path = self.removeStartingSlash(path.replace(basePath, ''));
        var fn = isDir ? self.getDir : self.getFile;
        return fn(path).then(function(entry) {
            return self.getMetadata(entry);
        });
    };
        self.removeStartingSlash = function(path) {
        if (path[0] == '/') {
            return path.substr(1);
        }
        return path;
    };
        function copyOrMoveExternalFile(from, to, copy) {
        return self.getExternalFile(from).then(function(fileEntry) {
            var dirAndFile = self.getFileAndDirectoryFromPath(to);
            return self.createDir(dirAndFile.directory).then(function(dirEntry) {
                var deferred = $q.defer();
                if (copy) {
                    fileEntry.copyTo(dirEntry, dirAndFile.name, deferred.resolve, deferred.reject);
                } else {
                    fileEntry.moveTo(dirEntry, dirAndFile.name, deferred.resolve, deferred.reject);
                }
                return deferred.promise;
            });
        });
    }
        self.copyExternalFile = function(from, to) {
        return copyOrMoveExternalFile(from, to, true);
    };
        self.moveExternalFile = function(from, to) {
        return copyOrMoveExternalFile(from, to, false);
    };
        self.getUniqueNameInFolder = function(dirPath, fileName, defaultExt) {
        return self.getDirectoryContents(dirPath).then(function(entries) {
            var files = {},
                fileNameWithoutExtension = self.removeExtension(fileName),
                extension = self.getFileExtension(fileName) || defaultExt,
                newName,
                number = 1;
            fileNameWithoutExtension = $mmText.removeSpecialCharactersForFiles($mmText.decodeURIComponent(fileNameWithoutExtension));
            angular.forEach(entries, function(entry) {
                files[entry.name] = entry;
            });
            if (extension) {
                extension = '.' + extension;
            } else {
                extension = '';
            }
            newName = fileNameWithoutExtension + extension;
            if (typeof files[newName] == 'undefined') {
                return newName;
            } else {
                do {
                    newName = fileNameWithoutExtension + '(' + number + ')' + extension;
                    number++;
                } while (typeof files[newName] != 'undefined');
                return newName;
            }
        }).catch(function() {
            return $mmText.removeSpecialCharactersForFiles($mmText.decodeURIComponent(fileName));
        });
    };
        self.clearTmpFolder = function() {
        return self.removeDir(mmFsTmpFolder);
    };
        self.removeUnusedFiles = function(dirPath, files) {
        return self.getDirectoryContents(dirPath).then(function(contents) {
            if (!contents.length) {
                return;
            }
            var filesMap = {},
                promises = [];
            angular.forEach(files, function(file) {
                if (file.fullPath) {
                    filesMap[file.fullPath] = file;
                }
            });
            angular.forEach(contents, function(file) {
                if (!filesMap[file.fullPath]) {
                    promises.push(self.removeFileByFileEntry(file));
                }
            });
            return $q.all(promises);
        }).catch(function() {
        });
    };
    return self;
}]);

angular.module('mm.core')
.factory('$mmGroups', ["$log", "$q", "$mmSite", "$mmSitesManager", function($log, $q, $mmSite, $mmSitesManager) {
    $log = $log.getInstance('$mmGroups');
    var self = {};
    self.NOGROUPS       = 0;
    self.SEPARATEGROUPS = 1;
    self.VISIBLEGROUPS  = 2;
        self.canGetActivityGroupMode = function() {
        return $mmSite.wsAvailable('core_group_get_activity_groupmode');
    };
        self.getActivityAllowedGroups = function(cmId, userId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            var params = {
                    cmid: cmId,
                    userid: userId
                },
                preSets = {
                    cacheKey: getActivityAllowedGroupsCacheKey(cmId, userId)
                };
            return site.read('core_group_get_activity_allowed_groups', params, preSets).then(function(response) {
                if (!response || !response.groups) {
                    return $q.reject();
                }
                return response.groups;
            });
        });
    };
        function getActivityAllowedGroupsCacheKey(cmId, userId) {
        return 'mmGroups:allowedgroups:' + cmId + ':' + userId;
    }
        self.getActivityGroupMode = function(cmId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    cmid: cmId
                },
                preSets = {
                    cacheKey: getActivityGroupModeCacheKey(cmId)
                };
            return site.read('core_group_get_activity_groupmode', params, preSets).then(function(response) {
                if (!response || typeof response.groupmode == 'undefined') {
                    return $q.reject();
                }
                return response.groupmode;
            });
        });
    };
        self.activityHasGroups = function(cmId, siteId) {
        return self.getActivityGroupMode(cmId, siteId).then(function(groupmode) {
            return groupmode === self.SEPARATEGROUPS || groupmode === self.VISIBLEGROUPS;
        }).catch(function() {
            return false;
        });
    };
        self.getActivityAllowedGroupsIfEnabled = function(cmId, userId, siteId) {
        siteId = siteId || $mmSite.getId();
        return self.activityHasGroups(cmId, siteId).then(function(hasGroups) {
            if (hasGroups) {
                return self.getActivityAllowedGroups(cmId, userId, siteId);
            }
            return [];
        });
    };
        function getActivityGroupModeCacheKey(cmid) {
        return 'mmGroups:groupmode:' + cmid;
    }
        self.getUserGroups = function(courses, refresh, siteid, userid) {
        var promises = [],
            groups = [],
            deferred = $q.defer();
        angular.forEach(courses, function(course) {
            var courseid;
            if (typeof course == 'object') {
                courseid = course.id;
            } else {
                courseid = course;
            }
            var promise = self.getUserGroupsInCourse(courseid, refresh, siteid, userid).then(function(coursegroups) {
                groups = groups.concat(coursegroups);
            });
            promises.push(promise);
        });
        $q.all(promises).finally(function() {
            deferred.resolve(groups);
        });
        return deferred.promise;
    };
        self.getUserGroupsInCourse = function(courseid, refresh, siteid, userid) {
        return $mmSitesManager.getSite(siteid).then(function(site) {
            var presets = {},
                data = {
                    userid: userid || site.getUserId(),
                    courseid: courseid
                };
            if (refresh) {
                presets.getFromCache = false;
            }
            return site.read('core_group_get_course_user_groups', data, presets).then(function(response) {
                if (response && response.groups) {
                    return response.groups;
                } else {
                    return $q.reject();
                }
            });
        });
    };
        self.invalidateActivityAllowedGroups = function(cmid, userid) {
        userid = userid || $mmSite.getUserId();
        return $mmSite.invalidateWsCacheForKey(getActivityAllowedGroupsCacheKey(cmid, userid));
    };
        self.invalidateActivityGroupMode = function(cmid) {
        return $mmSite.invalidateWsCacheForKey(getActivityGroupModeCacheKey(cmid));
    };
    return self;
}]);

angular.module('mm.core')
.constant('mmInitDelegateDefaultPriority', 100)
.constant('mmInitDelegateMaxAddonPriority', 599)
.provider('$mmInitDelegate', ["mmInitDelegateDefaultPriority", function(mmInitDelegateDefaultPriority) {
    var initProcesses = {},
        self = {};
        self.registerProcess = function(name, callable, priority, blocking) {
        priority = typeof priority === 'undefined' ? mmInitDelegateDefaultPriority : priority;
        if (typeof initProcesses[name] !== 'undefined') {
            console.log('$mmInitDelegateProvider: Process \'' + name + '\' already defined.');
            return;
        }
        console.log('$mmInitDelegateProvider: Registered process \'' + name + '\'.');
        initProcesses[name] = {
            blocking: blocking,
            callable: callable,
            name: name,
            priority: priority
        };
    };
    self.$get = ["$q", "$log", "$injector", "$mmUtil", function($q, $log, $injector, $mmUtil) {
        $log = $log.getInstance('$mmInitDelegate');
        var self = {},
            readiness;
                function prepareProcess(data) {
            return function() {
                var promise,
                    fn;
                $log.debug('Executing init process \'' + data.name + '\'');
                try {
                    fn = $mmUtil.resolveObject(data.callable);
                } catch (e) {
                    $log.error('Could not resolve object of init process \'' + data.name + '\'. ' + e);
                    return;
                }
                try {
                    promise = fn($injector);
                } catch (e) {
                    $log.error('Error while calling the init process \'' + data.name + '\'. ' + e);
                    return;
                }
                return promise;
            };
        }
                self.executeInitProcesses = function() {
            var ordered = [],
                promises = [],
                dependency = $q.when();
            if (typeof readiness === 'undefined') {
                readiness = $q.defer();
            }
            angular.forEach(initProcesses, function(data) {
                ordered.push(data);
            });
            ordered.sort(function(a, b) {
                return b.priority - a.priority;
            });
            angular.forEach(ordered, function(data) {
                var promise;
                promise = dependency.finally(prepareProcess(data));
                promises.push(promise);
                if (data.blocking) {
                    dependency = promise;
                }
            });
            $mmUtil.allPromises(promises).finally(readiness.resolve);
        };
                self.ready = function() {
            if (typeof readiness === 'undefined') {
                readiness = $q.defer();
            }
            return readiness.promise;
        };
        return self;
    }];
    return self;
}]);

angular.module('mm.core')
.factory('$mmLang', ["$translate", "$translatePartialLoader", "$mmConfig", "$cordovaGlobalization", "$q", "mmCoreConfigConstants", function($translate, $translatePartialLoader, $mmConfig, $cordovaGlobalization, $q, mmCoreConfigConstants) {
    var self = {},
        fallbackLanguage = mmCoreConfigConstants.default_lang || 'en',
        currentLanguage,
        customStrings = {},
        customStringsRaw;
        self.changeCurrentLanguage = function(language) {
        var p1 = $translate.use(language),
            p2 = $mmConfig.set('current_language', language);
        moment.locale(language);
        currentLanguage = language;
        return $q.all([p1, p2]);
    };
        self.clearCustomStrings = function() {
        customStrings = {};
        customStringsRaw = '';
    };
        self.getAllCustomStrings = function() {
        return customStrings;
    };
        self.getCurrentLanguage = function() {
        if (typeof currentLanguage != 'undefined') {
            return $q.when(currentLanguage);
        }
        return $mmConfig.get('current_language').then(function(language) {
            return language;
        }, function() {
            if (mmCoreConfigConstants.forcedefaultlanguage && mmCoreConfigConstants.forcedefaultlanguage !== 'false') {
                return mmCoreConfigConstants.default_lang;
            }
            try {
                return $cordovaGlobalization.getPreferredLanguage().then(function(result) {
                    var language = result.value.toLowerCase();
                    if (language.indexOf('-') > -1) {
                        if (mmCoreConfigConstants.languages && typeof mmCoreConfigConstants.languages[language] == 'undefined') {
                            language = language.substr(0, language.indexOf('-'));
                        }
                    }
                    return language;
                }, function() {
                    return fallbackLanguage;
                });
            } catch(err) {
                return fallbackLanguage;
            }
        }).then(function(language) {
            currentLanguage = language;
            return language;
        });
    };
        self.getCustomStrings = function(lang) {
        lang = lang || currentLanguage;
        return customStrings[lang];
    };
        self.loadCustomStrings = function(strings) {
        if (strings == customStringsRaw) {
            return;
        }
        self.clearCustomStrings();
        if (!strings || typeof strings != 'string') {
            return;
        }
        var list = strings.split(/(?:\r\n|\r|\n)/);
        angular.forEach(list, function(entry) {
            var values = entry.split('|'),
                lang;
            if (values.length < 3) {
                return;
            }
            lang = values[2];
            if (!customStrings[lang]) {
                customStrings[lang] = {};
            }
            customStrings[lang][values[0]] = values[1];
        });
    };
        self.registerLanguageFolder = function(path) {
        $translatePartialLoader.addPart(path);
        var promises = [];
        promises.push($translate.refresh(currentLanguage));
        if (currentLanguage !== fallbackLanguage) {
            promises.push($translate.refresh(fallbackLanguage));
        }
        return $q.all(promises);
    };
        self.translateAndReject = function(errorkey, translateParams) {
        return $translate(errorkey, translateParams).then(function(errorMessage) {
            return $q.reject(errorMessage);
        }, function() {
            return $q.reject(errorkey);
        });
    };
        self.translateAndRejectDeferred = function(deferred, errorkey) {
        $translate(errorkey).then(function(errorMessage) {
            deferred.reject(errorMessage);
        }, function() {
            deferred.reject(errorkey);
        });
    };
    return self;
}])
.config(["$translateProvider", "$translatePartialLoaderProvider", "mmCoreConfigConstants", function($translateProvider, $translatePartialLoaderProvider, mmCoreConfigConstants) {
    $translateProvider.useLoader('$translatePartialLoader', {
        urlTemplate: '{part}/{lang}.json'
    });
    $translatePartialLoaderProvider.addPart('build/lang');
    var lang = mmCoreConfigConstants.default_lang || 'en';
    $translateProvider.fallbackLanguage(lang);
    $translateProvider.preferredLanguage(lang);
}])
.config(["$provide", function($provide) {
    $provide.decorator('$translate', ['$delegate', '$q', '$injector', function($delegate, $q, $injector) {
        var $mmLang;
        var newTranslate = function(translationId, interpolateParams, interpolationId, defaultTranslationText, forceLanguage) {
            var value = getCustomString(translationId, forceLanguage);
            if (value !== false) {
                return $q.when(value);
            }
            return $delegate(translationId, interpolateParams, interpolationId, defaultTranslationText, forceLanguage);
        };
        newTranslate.instant = function(translationId, interpolateParams, interpolationId, forceLanguage, sanitizeStrategy) {
            var value = getCustomString(translationId, forceLanguage);
            if (value !== false) {
                return value;
            }
            return $delegate.instant(translationId, interpolateParams, interpolationId, forceLanguage, sanitizeStrategy);
        };
        for (var name in $delegate) {
            if (name != 'instant') {
                newTranslate[name] = $delegate[name];
            }
        }
        return newTranslate;
        function getCustomString(translationId, forceLanguage) {
            if (!$mmLang) {
                $mmLang = $injector.get('$mmLang');
            }
            var customStrings = $mmLang.getCustomStrings(forceLanguage);
            if (customStrings && typeof customStrings[translationId] != 'undefined') {
                return customStrings[translationId];
            }
            return false;
        }
    }]);
}])
.run(["$ionicPlatform", "$translate", "$mmLang", "$mmSite", "$mmEvents", "mmCoreEventLogin", "mmCoreEventSiteUpdated", "mmCoreEventLogout", function($ionicPlatform, $translate, $mmLang, $mmSite, $mmEvents, mmCoreEventLogin, mmCoreEventSiteUpdated,
            mmCoreEventLogout) {
    $ionicPlatform.ready(function() {
        $mmLang.getCurrentLanguage().then(function(language) {
            $translate.use(language);
            moment.locale(language);
        });
    });
    $mmEvents.on(mmCoreEventLogin, loadCustomStrings);
    $mmEvents.on(mmCoreEventSiteUpdated, function(siteId) {
        if (siteId == $mmSite.getId()) {
            loadCustomStrings();
        }
    });
    $mmEvents.on(mmCoreEventLogout, function() {
        $mmLang.clearCustomStrings();
    });
    function loadCustomStrings() {
        var customStrings = $mmSite.getStoredConfig('tool_mobile_customlangstrings');
        if (typeof customStrings != 'undefined') {
            $mmLang.loadCustomStrings(customStrings);
        }
    }
}]);
angular.module('mm.core')
.constant('mmCoreNotificationsSitesStore', 'notification_sites')
.constant('mmCoreNotificationsComponentsStore', 'notification_components')
.constant('mmCoreNotificationsTriggeredStore', 'notifications_triggered')
.config(["$mmAppProvider", "mmCoreNotificationsSitesStore", "mmCoreNotificationsComponentsStore", "mmCoreNotificationsTriggeredStore", function($mmAppProvider, mmCoreNotificationsSitesStore, mmCoreNotificationsComponentsStore,
        mmCoreNotificationsTriggeredStore) {
    var stores = [
        {
            name: mmCoreNotificationsSitesStore,
            keyPath: 'id',
            indexes: [
                {
                    name: 'code',
                }
            ]
        },
        {
            name: mmCoreNotificationsComponentsStore,
            keyPath: 'id',
            indexes: [
                {
                    name: 'code',
                }
            ]
        },
        {
            name: mmCoreNotificationsTriggeredStore,
            keyPath: 'id',
            indexes: []
        }
    ];
    $mmAppProvider.registerStores(stores);
}])
.factory('$mmLocalNotifications', ["$log", "$cordovaLocalNotification", "$mmApp", "$q", "$rootScope", "$ionicPopover", "$timeout", "mmCoreNotificationsSitesStore", "mmCoreNotificationsComponentsStore", "mmCoreNotificationsTriggeredStore", function($log, $cordovaLocalNotification, $mmApp, $q, $rootScope, $ionicPopover, $timeout,
        mmCoreNotificationsSitesStore, mmCoreNotificationsComponentsStore, mmCoreNotificationsTriggeredStore) {
    $log = $log.getInstance('$mmLocalNotifications');
    var self = {},
        observers = {},
        codes = {},
        scope,
        hidePopoverTimeout;
    scope = $rootScope.$new();
    $ionicPopover.fromTemplateUrl('core/templates/notificationpopover.html', {
        scope: scope,
    }).then(function(popover) {
        popover.viewType = 'mm-inappnotif-popover';
        angular.element(popover.el).removeClass('popover-backdrop').addClass('mm-inapp-notification-backdrop');
        scope.popover = popover;
        scope.hide = function() {
            scope.popover.hide();
            $timeout.cancel(hidePopoverTimeout);
        };
    });
    var codeRequestsQueue = {};
        function getCode(store, id) {
        var db = $mmApp.getDB(),
            key = store + '#' + id;
        if (typeof codes[key] != 'undefined') {
            return $q.when(codes[key]);
        }
        return db.get(store, id).then(function(entry) {
            var code = parseInt(entry.code);
            codes[key] = code;
            return code;
        }, function() {
            return db.query(store, undefined, 'code', true).then(function(entries) {
                var newCode = 0;
                if (entries.length > 0) {
                    newCode = parseInt(entries[0].code) + 1;
                }
                return db.insert(store, {id: id, code: newCode}).then(function() {
                    codes[key] = newCode;
                    return newCode;
                });
            });
        });
    }
        function getSiteCode(siteid) {
        return requestCode(mmCoreNotificationsSitesStore, siteid);
    }
        function getComponentCode(component) {
        return requestCode(mmCoreNotificationsComponentsStore, component);
    }
        function getUniqueNotificationId(notificationid, component, siteid) {
        if (!siteid || !component) {
            return $q.reject();
        }
        return getSiteCode(siteid).then(function(sitecode) {
            return getComponentCode(component).then(function(componentcode) {
                return (sitecode * 100000000 + componentcode * 10000000 + parseInt(notificationid)) % 2147483647;
            });
        });
    }
        function processNextRequest() {
        var nextKey = Object.keys(codeRequestsQueue)[0],
            request,
            promise;
        if (typeof nextKey == 'undefined') {
            return;
        }
        request = codeRequestsQueue[nextKey];
        if (angular.isObject(request) && typeof request.store != 'undefined' && typeof request.id != 'undefined') {
            promise = getCode(request.store, request.id).then(function(code) {
                angular.forEach(request.promises, function(p) {
                    p.resolve(code);
                });
            }, function(error) {
                angular.forEach(request.promises, function(p) {
                    p.reject(error);
                });
            });
        } else {
            promise = $q.when();
        }
        promise.finally(function() {
            delete codeRequestsQueue[nextKey];
            processNextRequest();
        });
    }
        function requestCode(store, id) {
        var deferred = $q.defer(),
            key = store+'#'+id,
            isQueueEmpty = Object.keys(codeRequestsQueue).length == 0;
        if (typeof codeRequestsQueue[key] != 'undefined') {
            codeRequestsQueue[key].promises.push(deferred);
        } else {
            codeRequestsQueue[key] = {
                store: store,
                id: id,
                promises: [deferred]
            };
        }
        if (isQueueEmpty) {
            processNextRequest();
        }
        return deferred.promise;
    }
        self.cancel = function(id, component, siteid) {
        return getUniqueNotificationId(id, component, siteid).then(function(uniqueId) {
            return $cordovaLocalNotification.cancel(uniqueId);
        });
    };
        self.cancelSiteNotifications = function(siteid) {
        if (!self.isAvailable()) {
            return $q.when();
        } else if (!siteid) {
            return $q.reject();
        }
        return $cordovaLocalNotification.getAllScheduled().then(function(scheduled) {
            var ids = [];
            angular.forEach(scheduled, function(notif) {
                if (typeof notif.data == 'string') {
                    notif.data = JSON.parse(notif.data);
                }
                if (typeof notif.data == 'object' && notif.data.siteid === siteid) {
                    ids.push(notif.id);
                }
            });
            return $cordovaLocalNotification.cancel(ids);
        });
    };
        self.isAvailable = function() {
        return window.plugin && window.plugin.notification && window.plugin.notification.local ? true: false;
    };
        self.isTriggered = function(notification) {
        return $mmApp.getDB().get(mmCoreNotificationsTriggeredStore, notification.id).then(function(stored) {
            var notifTime = notification.at.getTime() / 1000;
            return stored.at === notifTime;
        }, function() {
            return false;
        });
    };
        self.notifyClick = function(data) {
        var component = data.component;
        if (component) {
            var callback = observers[component];
            if (typeof callback == 'function') {
                callback(data);
            }
        }
    };
        self.registerClick = function(component, callback) {
        $log.debug("Register observer '"+component+"' for notification click.");
        observers[component] = callback;
    };
        self.removeTriggered = function(id) {
        return $mmApp.getDB().remove(mmCoreNotificationsTriggeredStore, id);
    };
        self.schedule = function(notification, component, siteid) {
        return getUniqueNotificationId(notification.id, component, siteid).then(function(uniqueId) {
            notification.id = uniqueId;
            notification.data = notification.data || {};
            notification.data.component = component;
            notification.data.siteid = siteid;
            if (ionic.Platform.isAndroid()) {
                notification.icon = notification.icon || 'res://icon';
                notification.smallIcon = notification.smallIcon || 'res://icon';
                notification.led = notification.led || 'FF9900';
                notification.ledOnTime = notification.ledOnTime || 1000;
                notification.ledOffTime = notification.ledOffTime || 1000;
            }
            return self.isTriggered(notification).then(function(triggered) {
                if (!triggered) {
                    self.removeTriggered(notification.id);
                    return $cordovaLocalNotification.schedule(notification);
                }
            });
        });
    };
        self.showNotificationPopover = function(notification) {
        if (!scope || !scope.popover) {
            return;
        }
        if (!notification || !notification.title || !notification.text) {
            return;
        }
        var isShown = scope.popover.isShown();
        setData(isShown);
        if (isShown) {
            $timeout.cancel(hidePopoverTimeout);
        } else {
            scope.popover.show(document.querySelector('ion-nav-bar'));
        }
        hidePopoverTimeout = $timeout(function() {
            scope.popover.hide();
        }, 4000);
        function setData(isShown) {
            $timeout(function() {
                if (isShown && scope.title == notification.title) {
                    if (scope.ids.indexOf(notification.id) != -1) {
                        return;
                    }
                    scope.texts.push(notification.text);
                    scope.ids.push(notification.id);
                    if (scope.texts.length > 3) {
                        scope.texts.shift();
                        scope.ids.shift();
                    }
                } else {
                    scope.title = notification.title;
                    scope.texts = [notification.text];
                    scope.ids = [notification.id];
                }
            });
        }
    };
        self.trigger = function(notification) {
        if (ionic.Platform.isIOS() && parseInt(ionic.Platform.version(), 10) >= 10) {
            self.showNotificationPopover(notification);
        }
        var id = parseInt(notification.id);
        if (!isNaN(id)) {
            return $mmApp.getDB().insert(mmCoreNotificationsTriggeredStore, {
                id: id,
                at: parseInt(notification.at)
            });
        } else {
            return $q.reject();
        }
    };
    return self;
}])
.run(["$rootScope", "$log", "$mmLocalNotifications", "$mmEvents", "mmCoreEventSiteDeleted", function($rootScope, $log, $mmLocalNotifications, $mmEvents, mmCoreEventSiteDeleted) {
    $log = $log.getInstance('$mmLocalNotifications');
    $rootScope.$on('$cordovaLocalNotification:trigger', function(e, notification, state) {
        $mmLocalNotifications.trigger(notification);
    });
    $rootScope.$on('$cordovaLocalNotification:click', function(e, notification, state) {
        if (notification && notification.data) {
            $log.debug('Notification clicked: '+notification.data);
            var data = JSON.parse(notification.data);
            $mmLocalNotifications.notifyClick(data);
        }
    });
    $mmEvents.on(mmCoreEventSiteDeleted, function(site) {
        if (site) {
            $mmLocalNotifications.cancelSiteNotifications(site.id);
        }
    });
}]);

angular.module('mm.core')
.constant('mmCoreLogEnabledDefault', true)
.constant('mmCoreLogEnabledConfigName', 'debug_enabled')
.provider('$mmLog', ["mmCoreLogEnabledDefault", function(mmCoreLogEnabledDefault) {
    var isEnabled = mmCoreLogEnabledDefault,
        self = this;
    function prepareLogFn(logFn, className) {
        className = className || '';
        var enhancedLogFn = function() {
            if (isEnabled) {
                var args = Array.prototype.slice.call(arguments),
                    now  = moment().format('l LTS');
                args[0] = now + ' ' + className + ': ' + args[0];
                logFn.apply(null, args);
            }
        };
        enhancedLogFn.logs = [];
        return enhancedLogFn;
    }
        self.logDecorator = function($log) {
        var _$log = (function($log) {
            return {
                log   : $log.log,
                info  : $log.info,
                warn  : $log.warn,
                debug : $log.debug,
                error : $log.error
            };
        })($log);
        var getInstance = function(className) {
            return {
                log   : prepareLogFn(_$log.log, className),
                info  : prepareLogFn(_$log.info, className),
                warn  : prepareLogFn(_$log.warn, className),
                debug : prepareLogFn(_$log.debug, className),
                error : prepareLogFn(_$log.error, className)
            };
        };
        $log.log   = prepareLogFn($log.log);
        $log.info  = prepareLogFn($log.info);
        $log.warn  = prepareLogFn($log.warn);
        $log.debug = prepareLogFn($log.debug);
        $log.error = prepareLogFn($log.error);
        $log.getInstance = getInstance;
        return $log;
    };
    this.$get = ["$mmConfig", "mmCoreLogEnabledDefault", "mmCoreLogEnabledConfigName", function($mmConfig, mmCoreLogEnabledDefault, mmCoreLogEnabledConfigName) {
        var self = {};
                self.init = function() {
            $mmConfig.get(mmCoreLogEnabledConfigName).then(function(enabled) {
                isEnabled = enabled;
            }, function() {
                isEnabled = mmCoreLogEnabledDefault;
            });
        }
                self.enabled = function(flag) {
            $mmConfig.set(mmCoreLogEnabledConfigName, flag);
            isEnabled = flag;
        };
                self.isEnabled = function() {
            return isEnabled;
        };
        return self;
    }];
}])
.run(["$mmLog", function($mmLog) {
    $mmLog.init();
}]);

angular.module('mm.core')
.factory('$mmSite', ["$mmSitesManager", "$mmSitesFactory", function($mmSitesManager, $mmSitesFactory) {
    var self = {},
        siteMethods = $mmSitesFactory.getSiteMethods();
    angular.forEach(siteMethods, function(method) {
        self[method] = function() {
            var currentSite = $mmSitesManager.getCurrentSite();
            if (typeof currentSite == 'undefined') {
                return undefined;
            } else {
                return currentSite[method].apply(currentSite, arguments);
            }
        };
    });
        self.isLoggedIn = function() {
        var currentSite = $mmSitesManager.getCurrentSite();
        return typeof currentSite != 'undefined' && typeof currentSite.token != 'undefined' && currentSite.token != '';
    };
    return self;
}]);

angular.module('mm.core')
.value('mmCoreWSPrefix', 'local_mobile_')
.constant('mmCoreWSCacheStore', 'wscache')
.config(["$mmSitesFactoryProvider", "mmCoreWSCacheStore", function($mmSitesFactoryProvider, mmCoreWSCacheStore) {
    var stores = [
        {
            name: mmCoreWSCacheStore,
            keyPath: 'id',
            indexes: [
                {
                    name: 'key'
                }
            ]
        }
    ];
    $mmSitesFactoryProvider.registerStores(stores);
}])
.provider('$mmSitesFactory', function() {
        var siteSchema = {
            stores: []
        },
        dboptions = {
            autoSchema: true
        },
        supportWhereEqual;
        this.registerStore = function(store) {
        if (typeof(store.name) === 'undefined') {
            console.log('$mmSite: Error: store name is undefined.');
            return;
        } else if (storeExists(store.name)) {
            console.log('$mmSite: Error: store ' + store.name + ' is already defined.');
            return;
        }
        store.indexes = getIndexes(store.indexes);
        siteSchema.stores.push(store);
    };
        function getIndexes(indexes) {
        if (!isWhereEqualSupported()) {
            var neededIndexes = {},
                uniqueIndexes = {};
            angular.forEach(indexes, function(index) {
                if (index.keyPath) {
                    angular.forEach(index.keyPath, function(keyName) {
                        neededIndexes[keyName] = keyName;
                    });
                } else {
                    uniqueIndexes[index.name] = true;
                }
            });
            angular.forEach(neededIndexes, function(index) {
                if (typeof uniqueIndexes[index] == "undefined") {
                    indexes.push({
                        name: index
                    });
                    uniqueIndexes[index] = true;
                }
            });
        } else {
            angular.forEach(indexes, function(index) {
                if (index.keyPath) {
                    var path = index.keyPath;
                    index.generator = function(obj) {
                        var arr = [];
                        angular.forEach(path, function(keyName) {
                            arr.push(obj[keyName]);
                        });
                        return arr;
                    };
                    delete index.keyPath;
                }
            });
        }
        return indexes;
    }
        function isWhereEqualSupported() {
        if (typeof supportWhereEqual != "undefined") {
            return supportWhereEqual;
        }
        if (ionic.Platform.isIOS()) {
            supportWhereEqual = true;
            return true;
        }
        var isSafari = !ionic.Platform.isIOS() && !ionic.Platform.isAndroid() && navigator.userAgent.indexOf('Safari') != -1 &&
                            navigator.userAgent.indexOf('Chrome') == -1 && navigator.userAgent.indexOf('Firefox') == -1;
        supportWhereEqual = typeof IDBObjectStore != 'undefined' && typeof IDBObjectStore.prototype.count != 'undefined' &&
                            !isSafari;
        return supportWhereEqual;
    }
        this.registerStores = function(stores) {
        var self = this;
        angular.forEach(stores, function(store) {
            self.registerStore(store);
        });
    };
        function storeExists(name) {
        var exists = false;
        angular.forEach(siteSchema.stores, function(store) {
            if (store.name === name) {
                exists = true;
            }
        });
        return exists;
    }
    this.$get = ["$http", "$q", "$mmWS", "$mmDB", "$log", "md5", "$mmApp", "$mmLang", "$mmUtil", "$mmFS", "mmCoreWSCacheStore", "mmCoreWSPrefix", "mmCoreSessionExpired", "$mmEvents", "mmCoreEventSessionExpired", "mmCoreUserDeleted", "mmCoreEventUserDeleted", "$mmText", "$translate", "mmCoreConfigConstants", "mmCoreUserPasswordChangeForced", "mmCoreEventPasswordChangeForced", "mmCoreLoginTokenChangePassword", "mmCoreSecondsMinute", "mmCoreUserNotFullySetup", "mmCoreEventUserNotFullySetup", "mmCoreSitePolicyNotAgreed", "mmCoreEventSitePolicyNotAgreed", "mmCoreUnicodeNotSupported", function($http, $q, $mmWS, $mmDB, $log, md5, $mmApp, $mmLang, $mmUtil, $mmFS, mmCoreWSCacheStore,
            mmCoreWSPrefix, mmCoreSessionExpired, $mmEvents, mmCoreEventSessionExpired, mmCoreUserDeleted, mmCoreEventUserDeleted,
            $mmText, $translate, mmCoreConfigConstants, mmCoreUserPasswordChangeForced, mmCoreEventPasswordChangeForced,
            mmCoreLoginTokenChangePassword, mmCoreSecondsMinute, mmCoreUserNotFullySetup, mmCoreEventUserNotFullySetup,
            mmCoreSitePolicyNotAgreed, mmCoreEventSitePolicyNotAgreed, mmCoreUnicodeNotSupported) {
        $log = $log.getInstance('$mmSite');
                var deprecatedFunctions = {
            "core_grade_get_definitions": "core_grading_get_definitions",
            "moodle_course_create_courses": "core_course_create_courses",
            "moodle_course_get_courses": "core_course_get_courses",
            "moodle_enrol_get_users_courses": "core_enrol_get_users_courses",
            "moodle_file_get_files": "core_files_get_files",
            "moodle_file_upload": "core_files_upload",
            "moodle_group_add_groupmembers": "core_group_add_group_members",
            "moodle_group_create_groups": "core_group_create_groups",
            "moodle_group_delete_groupmembers": "core_group_delete_group_members",
            "moodle_group_delete_groups": "core_group_delete_groups",
            "moodle_group_get_course_groups": "core_group_get_course_groups",
            "moodle_group_get_groupmembers": "core_group_get_group_members",
            "moodle_group_get_groups": "core_group_get_groups",
            "moodle_message_send_instantmessages": "core_message_send_instant_messages",
            "moodle_notes_create_notes": "core_notes_create_notes",
            "moodle_role_assign": "core_role_assign_role",
            "moodle_role_unassign": "core_role_unassign_role",
            "moodle_user_create_users": "core_user_create_users",
            "moodle_user_delete_users": "core_user_delete_users",
            "moodle_user_get_course_participants_by_id": "core_user_get_course_user_profiles",
            "moodle_user_get_users_by_courseid": "core_enrol_get_enrolled_users",
            "moodle_user_get_users_by_id": "core_user_get_users_by_id",
            "moodle_user_update_users": "core_user_update_users",
            "moodle_webservice_get_siteinfo": "core_webservice_get_site_info",
        };
        var self = {},
            moodleReleases = {
                '2.4': 2012120300,
                '2.5': 2013051400,
                '2.6': 2013111800,
                '2.7': 2014051200,
                '2.8': 2014111000,
                '2.9': 2015051100,
                '3.0': 2015111600,
                '3.1': 2016052300,
                '3.2': 2016120500
            };
                function Site(id, siteurl, token, infos, privateToken, config, loggedOut) {
            this.id = id;
            this.siteurl = siteurl;
            this.token = token;
            this.infos = infos;
            this.privateToken = privateToken;
            this.config = config;
            this.loggedOut = !!loggedOut;
            this.cleanUnicode = false;
            if (this.id) {
                this.db = $mmDB.getDB('Site-' + this.id, siteSchema, dboptions);
            }
        }
                Site.prototype.getId = function() {
            return this.id;
        };
                Site.prototype.getURL = function() {
            return this.siteurl;
        };
                Site.prototype.getToken = function() {
            return this.token;
        };
                Site.prototype.getInfo = function() {
            return this.infos;
        };
                Site.prototype.getPrivateToken = function() {
            return this.privateToken;
        };
                Site.prototype.getDb = function() {
            return this.db;
        };
                Site.prototype.reloadDb = function() {
            if (this.db) {
                this.db = $mmDB.getDB('Site-' + this.id, siteSchema, dboptions, true);
            }
        };
                Site.prototype.getUserId = function() {
            if (typeof this.infos != 'undefined' && typeof this.infos.userid != 'undefined') {
                return this.infos.userid;
            } else {
                return undefined;
            }
        };
                Site.prototype.getSiteHomeId = function() {
            return this.infos && this.infos.siteid || 1;
        };
                Site.prototype.setId = function(id) {
            this.id = id;
            this.db = $mmDB.getDB('Site-' + this.id, siteSchema, dboptions);
        };
                Site.prototype.setToken = function(token) {
            this.token = token;
        };
                Site.prototype.setPrivateToken = function(privateToken) {
            this.privateToken = privateToken;
        };
                Site.prototype.isTokenExpired = function() {
            return this.token == mmCoreLoginTokenChangePassword;
        };
                Site.prototype.isLoggedOut = function() {
            return !!this.loggedOut;
        };
                Site.prototype.setInfo = function(infos) {
            this.infos = infos;
        };
                Site.prototype.setConfig = function(config) {
            this.config = config;
        };
                Site.prototype.setLoggedOut = function(loggedOut) {
            this.loggedOut = !!loggedOut;
        };
                Site.prototype.canAccessMyFiles = function() {
            var infos = this.getInfo();
            return infos && (typeof infos.usercanmanageownfiles === 'undefined' || infos.usercanmanageownfiles);
        };
                Site.prototype.canDownloadFiles = function() {
            var infos = this.getInfo();
            return infos && infos.downloadfiles;
        };
                Site.prototype.canUseAdvancedFeature = function(feature, whenUndefined) {
            var infos = this.getInfo(),
                canUse = true;
            whenUndefined = (typeof whenUndefined === 'undefined') ? true : whenUndefined;
            if (typeof infos.advancedfeatures === 'undefined') {
                canUse = whenUndefined;
            } else {
                angular.forEach(infos.advancedfeatures, function(item) {
                    if (item.name === feature && parseInt(item.value, 10) === 0) {
                        canUse = false;
                    }
                });
            }
            return canUse;
        };
                Site.prototype.canUploadFiles = function() {
            var infos = this.getInfo();
            return infos && infos.uploadfiles;
        };
                Site.prototype.fetchSiteInfo = function() {
            var deferred = $q.defer(),
                site = this;
            var preSets = {
                getFromCache: 0,
                saveToCache: 0
            };
            site.cleanUnicode = false;
            site.read('core_webservice_get_site_info', {}, preSets).then(deferred.resolve, function(error) {
                site.read('moodle_webservice_get_siteinfo', {}, preSets).then(deferred.resolve, function(error) {
                    deferred.reject(error);
                });
            });
            return deferred.promise;
        };
                Site.prototype.read = function(method, data, preSets) {
            preSets = preSets || {};
            if (typeof(preSets.getFromCache) === 'undefined') {
                preSets.getFromCache = 1;
            }
            if (typeof(preSets.saveToCache) === 'undefined') {
                preSets.saveToCache = 1;
            }
            if (typeof(preSets.sync) === 'undefined') {
                preSets.sync = 0;
            }
            return this.request(method, data, preSets);
        };
                Site.prototype.write = function(method, data, preSets) {
            preSets = preSets || {};
            if (typeof(preSets.getFromCache) === 'undefined') {
                preSets.getFromCache = 0;
            }
            if (typeof(preSets.saveToCache) === 'undefined') {
                preSets.saveToCache = 0;
            }
            if (typeof(preSets.sync) === 'undefined') {
                preSets.sync = 0;
            }
            if (typeof(preSets.emergencyCache) === 'undefined') {
                preSets.emergencyCache = 0;
            }
            return this.request(method, data, preSets);
        };
                Site.prototype.request = function(method, data, preSets, retrying) {
            var site = this,
                initialToken = site.token;
            data = data || {};
            method = site.getCompatibleFunction(method);
            if (site.getInfo() && !site.wsAvailable(method, false)) {
                if (site.wsAvailable(mmCoreWSPrefix + method, false)) {
                    $log.info("Using compatibility WS method '" + mmCoreWSPrefix + method + "'");
                    method = mmCoreWSPrefix + method;
                } else {
                    $log.error("WS function '" + method + "' is not available, even in compatibility mode.");
                    return $mmLang.translateAndReject('mm.core.wsfunctionnotavailable');
                }
            }
            preSets = angular.copy(preSets) || {};
            preSets.wstoken = site.token;
            preSets.siteurl = site.siteurl;
            preSets.cleanUnicode = site.cleanUnicode;
            if (preSets.cleanUnicode && $mmText.hasUnicodeData(data)) {
                $mmUtil.showToast('mm.core.unicodenotsupported', true, 3000);
            } else {
                preSets.cleanUnicode = false;
            }
            data.moodlewssettingfilter = preSets.filter === false ? false : true;
            data.moodlewssettingfileurl = preSets.rewriteurls === false ? false : true;
            return getFromCache(site, method, data, preSets).catch(function() {
                var wsPreSets = angular.copy(preSets);
                delete wsPreSets.getFromCache;
                delete wsPreSets.saveToCache;
                delete wsPreSets.omitExpires;
                delete wsPreSets.cacheKey;
                delete wsPreSets.emergencyCache;
                delete wsPreSets.getCacheUsingCacheKey;
                delete wsPreSets.getEmergencyCacheUsingCacheKey;
                delete wsPreSets.uniqueCacheKey;
                return $mmWS.call(method, data, wsPreSets).then(function(response) {
                    if (preSets.saveToCache) {
                        saveToCache(site, method, data, response, preSets);
                    }
                    return angular.copy(response);
                }).catch(function(error) {
                    if (error === mmCoreSessionExpired) {
                        if (initialToken !== site.token && !retrying) {
                            return site.request(method, data, preSets, true);
                        } else if ($mmApp.isSSOAuthenticationOngoing()) {
                            return $mmApp.waitForSSOAuthentication().then(function() {
                                return site.request(method, data, preSets, true);
                            });
                        }
                        $mmEvents.trigger(mmCoreEventSessionExpired, {siteid: site.id});
                        error = $translate.instant('mm.core.lostconnection');
                    } else if (error === mmCoreUserDeleted) {
                        $mmEvents.trigger(mmCoreEventUserDeleted, {siteid: site.id, params: data});
                        return $mmLang.translateAndReject('mm.core.userdeleted');
                    } else if (error === mmCoreUserPasswordChangeForced) {
                        $mmEvents.trigger(mmCoreEventPasswordChangeForced, site.id);
                        return $mmLang.translateAndReject('mm.core.forcepasswordchangenotice');
                    } else if (error === mmCoreUserNotFullySetup) {
                        $mmEvents.trigger(mmCoreEventUserNotFullySetup, site.id);
                        return $mmLang.translateAndReject('mm.core.usernotfullysetup');
                    } else if (error === mmCoreSitePolicyNotAgreed) {
                        $mmEvents.trigger(mmCoreEventSitePolicyNotAgreed, site.id);
                        return $mmLang.translateAndReject('mm.login.sitepolicynotagreederror');
                    } else if (error === mmCoreUnicodeNotSupported) {
                        if (!site.cleanUnicode) {
                            site.cleanUnicode = true;
                            return site.request(method, data, preSets);
                        }
                        return $mmLang.translateAndReject('mm.core.unicodenotsupported');
                    } else if (typeof preSets.emergencyCache !== 'undefined' && !preSets.emergencyCache) {
                        $log.debug('WS call ' + method + ' failed. Emergency cache is forbidden, rejecting.');
                        return $q.reject(error);
                    }
                    $log.debug('WS call ' + method + ' failed. Trying to use the emergency cache.');
                    preSets.omitExpires = true;
                    preSets.getFromCache = true;
                    return getFromCache(site, method, data, preSets, true).catch(function() {
                        return $q.reject(error);
                    });
                });
            });
        };
                Site.prototype.wsAvailable = function(method, checkPrefix) {
            checkPrefix = (typeof checkPrefix === 'undefined') ? true : checkPrefix;
            if (typeof this.infos == 'undefined') {
                return false;
            }
            for (var i = 0; i < this.infos.functions.length; i++) {
                var f = this.infos.functions[i];
                if (f.name == method) {
                    return true;
                }
            }
            if (checkPrefix) {
                return this.wsAvailable(mmCoreWSPrefix + method, false);
            }
            return false;
        };
                Site.prototype.uploadFile = function(uri, options) {
            if (!options.fileArea) {
                if (this.isVersionGreaterEqualThan('3.1')) {
                    options.fileArea = 'draft';
                } else {
                    options.fileArea = 'private';
                }
            }
            return $mmWS.uploadFile(uri, options, {
                siteurl: this.siteurl,
                token: this.token
            });
        };
                Site.prototype.invalidateWsCache = function() {
            var db = this.db;
            if (!db) {
                return $q.reject();
            }
            $log.debug('Invalidate all the cache for site: '+ this.id);
            return db.getAll(mmCoreWSCacheStore).then(function(entries) {
                if (entries && entries.length > 0) {
                    return invalidateWsCacheEntries(db, entries);
                }
            });
        };
                Site.prototype.invalidateWsCacheForKey = function(key) {
            var db = this.db;
            if (!db || !key) {
                return $q.reject();
            }
            $log.debug('Invalidate cache for key: '+key);
            return db.whereEqual(mmCoreWSCacheStore, 'key', key).then(function(entries) {
                if (entries && entries.length > 0) {
                    return invalidateWsCacheEntries(db, entries);
                }
            });
        };
                Site.prototype.invalidateMultipleWsCacheForKey = function(keys) {
            var db = this.db;
            if (!db) {
                return $q.reject();
            }
            var allEntries = [],
                promises = [];
            $log.debug('Invalidating multiple cache keys');
            angular.forEach(keys, function(key) {
                if (key) {
                    promises.push(db.whereEqual(mmCoreWSCacheStore, 'key', key).then(function(entries) {
                        if (entries && entries.length > 0) {
                            allEntries.concat(entries);
                        }
                    }));
                }
            });
            return $q.all(promises).then(function() {
                return invalidateWsCacheEntries(db, allEntries);
            });
        };
                Site.prototype.invalidateWsCacheForKeyStartingWith = function(key) {
            var db = this.db;
            if (!db || !key) {
                return $q.reject();
            }
            $log.debug('Invalidate cache for key starting with: '+key);
            return db.where(mmCoreWSCacheStore, 'key', '^', key).then(function(entries) {
                if (entries && entries.length > 0) {
                    return invalidateWsCacheEntries(db, entries);
                }
            });
        };
                Site.prototype.fixPluginfileURL = function(url) {
            return $mmUtil.fixPluginfileURL(url, this.token);
        };
                Site.prototype.deleteDB = function() {
            return $mmDB.deleteDB('Site-' + this.id);
        };
                Site.prototype.deleteFolder = function() {
            if ($mmFS.isAvailable()) {
                var siteFolder = $mmFS.getSiteFolder(this.id);
                return $mmFS.removeDir(siteFolder).catch(function() {
                });
            } else {
                return $q.when();
            }
        };
                Site.prototype.getSpaceUsage = function() {
            if ($mmFS.isAvailable()) {
                var siteFolderPath = $mmFS.getSiteFolder(this.id);
                return $mmFS.getDirectorySize(siteFolderPath).catch(function() {
                    return 0;
                });
            } else {
                return $q.when(0);
            }
        };
                Site.prototype.getDocsUrl = function(page) {
            var release = this.infos.release ? this.infos.release : undefined;
            return $mmUtil.getDocsUrl(release, page);
        };
                Site.prototype.checkLocalMobilePlugin = function(retrying) {
            var siteurl = this.siteurl,
                self = this,
                service = mmCoreConfigConstants.wsextservice;
            if (!service) {
                return $q.when({code: 0});
            }
            return $http.post(siteurl + '/local/mobile/check.php', {service: service}).then(function(response) {
                var data = response.data;
                if (typeof data != 'undefined' && data.errorcode === 'requirecorrectaccess') {
                    if (!retrying) {
                        self.siteurl = $mmText.addOrRemoveWWW(siteurl);
                        return self.checkLocalMobilePlugin(true);
                    } else {
                        return $q.reject(data.error);
                    }
                } else if (typeof data == 'undefined' || typeof data.code == 'undefined') {
                    return {code: 0, warning: 'mm.login.localmobileunexpectedresponse'};
                }
                var code = parseInt(data.code, 10);
                if (data.error) {
                    switch (code) {
                        case 1:
                            return $mmLang.translateAndReject('mm.login.siteinmaintenance');
                        case 2:
                            return $mmLang.translateAndReject('mm.login.webservicesnotenabled');
                        case 3:
                            return {code: 0};
                        case 4:
                            return $mmLang.translateAndReject('mm.login.mobileservicesnotenabled');
                        default:
                            return $mmLang.translateAndReject('mm.core.unexpectederror');
                    }
                } else {
                    return {code: code, service: service, coresupported: !!data.coresupported};
                }
            }, function() {
                return {code: 0};
            });
        };
                Site.prototype.checkIfAppUsesLocalMobile = function() {
            var appUsesLocalMobile = false;
            angular.forEach(this.infos.functions, function(func) {
                if (func.name.indexOf(mmCoreWSPrefix) != -1) {
                    appUsesLocalMobile = true;
                }
            });
            return appUsesLocalMobile;
        };
                Site.prototype.checkIfLocalMobileInstalledAndNotUsed = function() {
            var appUsesLocalMobile = this.checkIfAppUsesLocalMobile();
            if (appUsesLocalMobile) {
                return $q.reject();
            }
            return this.checkLocalMobilePlugin().then(function(data) {
                if (typeof data.service == 'undefined') {
                    return $q.reject();
                }
                return data;
            });
        };
                Site.prototype.containsUrl = function(url) {
            if (!url) {
                return false;
            }
            var siteurl = $mmText.removeProtocolAndWWW(this.siteurl);
            url = $mmText.removeProtocolAndWWW(url);
            return url.indexOf(siteurl) == 0;
        };
                Site.prototype.getPublicConfig = function() {
            var that = this;
            return $mmWS.callAjax('tool_mobile_get_public_config', {}, {siteurl: this.siteurl}).then(function(config) {
                if (config.httpswwwroot) {
                    that.siteurl = config.httpswwwroot;
                }
                return config;
            });
        };
                Site.prototype.openInBrowserWithAutoLogin = function(url, alertMessage) {
            return this.openWithAutoLogin(false, url, undefined, alertMessage);
        };
                Site.prototype.openInBrowserWithAutoLoginIfSameSite = function(url, alertMessage) {
            return this.openWithAutoLoginIfSameSite(false, url, undefined, alertMessage);
        };
                Site.prototype.openInAppWithAutoLogin = function(url, options, alertMessage) {
            return this.openWithAutoLogin(true, url, options, alertMessage);
        };
                Site.prototype.openInAppWithAutoLoginIfSameSite = function(url, options, alertMessage) {
            return this.openWithAutoLoginIfSameSite(true, url, options, alertMessage);
        };
                Site.prototype.openWithAutoLogin = function(inApp, url, options, alertMessage) {
            if (!this.privateToken || !this.wsAvailable('tool_mobile_get_autologin_key') ||
                    (this.lastAutoLogin && $mmUtil.timestamp() - this.lastAutoLogin < 6 * mmCoreSecondsMinute)) {
                return open(url);
            }
            var that = this,
                userId = that.getUserId(),
                params = {
                    privatetoken: that.privateToken
                },
                modal = $mmUtil.showModalLoading();
            return that.write('tool_mobile_get_autologin_key', params).then(function(data) {
                if (!data.autologinurl || !data.key) {
                    return open(url);
                }
                that.lastAutoLogin = $mmUtil.timestamp();
                return open(data.autologinurl + '?userid=' + userId + '&key=' + data.key + '&urltogo=' + url);
            }).catch(function() {
                return open(url);
            });
            function open(url) {
                if (modal) {
                    modal.dismiss();
                }
                var promise;
                if (alertMessage) {
                    promise = $mmUtil.showModal('mm.core.notice', alertMessage, 3000);
                } else {
                    promise = $q.when();
                }
                return promise.finally(function() {
                    if (inApp) {
                        $mmUtil.openInApp(url, options);
                    } else {
                        $mmUtil.openInBrowser(url);
                    }
                });
            }
        };
                Site.prototype.openWithAutoLoginIfSameSite = function(inApp, url, options, alertMessage) {
            if (this.containsUrl(url)) {
                return this.openWithAutoLogin(inApp, url, options, alertMessage);
            } else {
                if (inApp) {
                    $mmUtil.openInApp(url, options);
                } else {
                    $mmUtil.openInBrowser(url);
                }
                return $q.when();
            }
        };
                Site.prototype.getConfig = function(name, ignoreCache) {
            var site = this;
            var preSets = {
                cacheKey: getConfigCacheKey()
            };
            if (ignoreCache) {
                preSets.getFromCache = 0;
                preSets.emergencyCache = 0;
            }
            return site.read('tool_mobile_get_config', {}, preSets).then(function(config) {
                if (name) {
                    for (var x in config.settings) {
                        if (config.settings[x].name == name) {
                            return config.settings[x].value;
                        }
                    }
                    return $q.reject();
                } else {
                    var settings = {};
                    angular.forEach(config.settings, function(setting) {
                        settings[setting.name] = setting.value;
                    });
                    return settings;
                }
            });
        };
                Site.prototype.invalidateConfig = function() {
            var site = this;
            return site.invalidateWsCacheForKey(getConfigCacheKey());
        };
                function getConfigCacheKey() {
            return 'tool_mobile_get_config';
        }
                Site.prototype.getStoredConfig = function(name) {
            if (!this.config) {
                return;
            }
            if (name) {
                return this.config[name];
            } else {
                return this.config;
            }
        };
                Site.prototype.isFeatureDisabled = function(name) {
            var disabledFeatures = this.getStoredConfig('tool_mobile_disabledfeatures');
            if (!disabledFeatures) {
                return false;
            }
            var regEx = new RegExp('(,|^)' + $mmText.escapeForRegex(name) + '(,|$)', 'g');
            return !!disabledFeatures.match(regEx);
        };
                function invalidateWsCacheEntries(db, entries) {
            var promises = [];
            angular.forEach(entries, function(entry) {
                if (entry.expirationtime > 0) {
                    entry.expirationtime = 0;
                    promises.push(db.insert(mmCoreWSCacheStore, entry));
                }
            });
            return $q.all(promises);
        }
                Site.prototype.getCompatibleFunction = function(method) {
            if (typeof deprecatedFunctions[method] !== "undefined") {
                if (this.wsAvailable(deprecatedFunctions[method])) {
                    $log.warn("You are using deprecated Web Services: " + method +
                        " you must replace it with the newer function: " + deprecatedFunctions[method]);
                    return deprecatedFunctions[method];
                } else {
                    $log.warn("You are using deprecated Web Services. " +
                        "Your remote site seems to be outdated, consider upgrade it to the latest Moodle version.");
                }
            } else if (!this.wsAvailable(method)) {
                for (var oldFunc in deprecatedFunctions) {
                    if (deprecatedFunctions[oldFunc] === method && this.wsAvailable(oldFunc)) {
                        $log.warn("Your remote site doesn't support the function " + method +
                            ", it seems to be outdated, consider upgrade it to the latest Moodle version.");
                        return oldFunc;
                    }
                }
            }
            return method;
        };
                Site.prototype.isVersionGreaterEqualThan = function(versions) {
            var siteVersion = parseInt(this.getInfo().version, 10);
            if (angular.isArray(versions)) {
                if (!versions.length) {
                    return false;
                }
                for (var i = 0; i < versions.length; i++) {
                    var versionNumber = getVersionNumber(versions[i]);
                    if (i == versions.length - 1) {
                        return siteVersion >= versionNumber;
                    } else {
                        if (siteVersion >= versionNumber && siteVersion < getNextMajorVersionNumber(versions[i])) {
                            return true;
                        }
                    }
                }
            } else if (typeof versions == 'string') {
                return siteVersion >= getVersionNumber(versions);
            }
            return false;
        };
                function getVersionNumber(version) {
            var data = getMajorAndMinor(version);
            if (!data) {
                return 0;
            }
            if (typeof moodleReleases[data.major] == 'undefined') {
                data.major = Object.keys(moodleReleases).slice(-1);
            }
            return moodleReleases[data.major] + data.minor;
        }
                function getMajorAndMinor(version) {
            var match = version.match(/(\d)+(?:\.(\d)+)?(?:\.(\d)+)?/);
            if (!match || !match[1]) {
                return false;
            }
            return {
                major: match[1] + '.' + (match[2] || '0'),
                minor: parseInt(match[3] || 0, 10)
            };
        }
                function getNextMajorVersionNumber(version) {
            var data = getMajorAndMinor(version),
                position,
                releases = Object.keys(moodleReleases);
            if (!data) {
                return 0;
            }
            position = releases.indexOf(data.major);
            if (position == -1 || position == releases.length -1) {
                return moodleReleases[releases[position]];
            }
            return moodleReleases[releases[position + 1]];
        }
                function getCacheId(method, data) {
            return md5.createHash(method + ':' + JSON.stringify(data));
        }
                function getFromCache(site, method, data, preSets, emergency) {
            var db = site.db,
                id = getCacheId(method, data),
                promise;
            if (!db || !preSets.getFromCache) {
                return $q.reject();
            }
            if (preSets.getCacheUsingCacheKey || (emergency && preSets.getEmergencyCacheUsingCacheKey)) {
                promise = db.whereEqual(mmCoreWSCacheStore, 'key', preSets.cacheKey).then(function(entries) {
                    if (!entries.length) {
                        return db.get(mmCoreWSCacheStore, id);
                    } else if (entries.length > 1) {
                        for (var i = 0, len = entries.length; i < len; i++) {
                            var entry = entries[i];
                            if (entry.id == id) {
                                return entry;
                            }
                        }
                    }
                    return entries[0];
                });
            } else {
                promise = db.get(mmCoreWSCacheStore, id);
            }
            return promise.then(function(entry) {
                var now = new Date().getTime();
                preSets.omitExpires = preSets.omitExpires || !$mmApp.isOnline();
                if (!preSets.omitExpires) {
                    if (now > entry.expirationtime) {
                        $log.debug('Cached element found, but it is expired');
                        return $q.reject();
                    }
                }
                if (typeof entry != 'undefined' && typeof entry.data != 'undefined') {
                    var expires = (entry.expirationtime - now) / 1000;
                    $log.info('Cached element found, id: ' + id + ' expires in ' + expires + ' seconds');
                    return entry.data;
                }
                return $q.reject();
            });
        }
                function saveToCache(site, method, data, response, preSets) {
            var db = site.db,
                id = getCacheId(method, data),
                cacheExpirationTime = mmCoreConfigConstants.cache_expiration_time,
                promise,
                entry = {
                    id: id,
                    data: response
                };
            if (!db) {
                return $q.reject();
            } else {
                if (preSets.uniqueCacheKey) {
                    promise = deleteFromCache(site, method, data, preSets, true).catch(function() {
                    });
                } else {
                    promise = $q.when();
                }
                return promise.then(function() {
                    cacheExpirationTime = isNaN(cacheExpirationTime) ? 300000 : cacheExpirationTime;
                    entry.expirationtime = new Date().getTime() + cacheExpirationTime;
                    if (preSets.cacheKey) {
                        entry.key = preSets.cacheKey;
                    }
                    return db.insert(mmCoreWSCacheStore, entry);
                });
            }
        }
                function deleteFromCache(site, method, data, preSets, allCacheKey) {
            var db = site.db,
                id = getCacheId(method, data);
            if (!db) {
                return $q.reject();
            } else {
                if (allCacheKey) {
                    return db.whereEqual(mmCoreWSCacheStore, 'key', preSets.cacheKey).then(function(entries) {
                        var promises = [];
                        angular.forEach(entries, function(entry) {
                            promises.push(db.remove(mmCoreWSCacheStore, entry.id));
                        });
                        return $q.all(promises);
                    });
                } else {
                    return db.remove(mmCoreWSCacheStore, id);
                }
            }
        }
                self.makeSite = function(id, siteurl, token, infos, privateToken, config, loggedOut) {
            return new Site(id, siteurl, token, infos, privateToken, config, loggedOut);
        };
                self.getSiteMethods = function() {
            var methods = [];
            for (var name in Site.prototype) {
                methods.push(name);
            }
            return methods;
        };
        return self;
    }];
});

angular.module('mm.core')
.constant('mmCoreSitesStore', 'sites')
.constant('mmCoreCurrentSiteStore', 'current_site')
.config(["$mmAppProvider", "mmCoreSitesStore", "mmCoreCurrentSiteStore", function($mmAppProvider, mmCoreSitesStore, mmCoreCurrentSiteStore) {
    var stores = [
        {
            name: mmCoreSitesStore,
            keyPath: 'id'
        },
        {
            name: mmCoreCurrentSiteStore,
            keyPath: 'id'
        }
    ];
    $mmAppProvider.registerStores(stores);
}])
.factory('$mmSitesManager', ["$http", "$q", "$mmSitesFactory", "md5", "$mmLang", "$mmApp", "$mmUtil", "$mmEvents", "$translate", "mmCoreSitesStore", "mmCoreCurrentSiteStore", "mmCoreEventLogin", "mmCoreEventLogout", "$log", "mmCoreWSPrefix", "mmCoreEventSiteUpdated", "mmCoreEventSiteAdded", "mmCoreEventSessionExpired", "mmCoreEventSiteDeleted", "$mmText", "mmCoreConfigConstants", "mmLoginSSOCode", "mmLoginSSOInAppCode", function($http, $q, $mmSitesFactory, md5, $mmLang, $mmApp, $mmUtil, $mmEvents,
            $translate, mmCoreSitesStore, mmCoreCurrentSiteStore, mmCoreEventLogin, mmCoreEventLogout, $log, mmCoreWSPrefix,
            mmCoreEventSiteUpdated, mmCoreEventSiteAdded, mmCoreEventSessionExpired, mmCoreEventSiteDeleted, $mmText,
            mmCoreConfigConstants, mmLoginSSOCode, mmLoginSSOInAppCode) {
    $log = $log.getInstance('$mmSitesManager');
    var self = {},
        services = {},
        sessionRestored = false,
        currentSite,
        sites = {};
        self.getDemoSiteData = function(siteurl) {
        var demoSites = mmCoreConfigConstants.demo_sites;
        if (typeof demoSites != 'undefined' && typeof demoSites[siteurl] != 'undefined') {
            return demoSites[siteurl];
        }
    };
        self.checkSite = function(siteurl, protocol) {
        siteurl = $mmUtil.formatURL(siteurl);
        if (!$mmUtil.isValidURL(siteurl)) {
            return $mmLang.translateAndReject('mm.login.invalidsite');
        } else if (!$mmApp.isOnline()) {
            return $mmLang.translateAndReject('mm.core.networkerrormsg');
        } else {
            protocol = protocol || 'https://';
            return checkSite(siteurl, protocol).catch(function(error) {
                if (error.critical) {
                    return $q.reject(error.error);
                }
                protocol = protocol == 'https://' ? 'http://' : 'https://';
                return checkSite(siteurl, protocol).catch(function(secondError){
                    if (secondError.error) {
                        return $q.reject(secondError.error);
                    } else if (error.error) {
                        return $q.reject(error.error);
                    }
                    return $mmLang.translateAndReject('mm.login.checksiteversion');
                });
            });
        }
    };
        function checkSite(siteurl, protocol) {
        siteurl = siteurl.replace(/^http(s)?\:\/\//i, protocol);
        return self.siteExists(siteurl).catch(function(error) {
            if (error.errorcode && error.errorcode == 'enablewsdescription') {
                return rejectWithCriticalError(error.error, error.errorcode);
            }
            var treatedUrl = $mmText.addOrRemoveWWW(siteurl);
            return self.siteExists(treatedUrl).then(function() {
                siteurl = treatedUrl;
            }).catch(function(secondError) {
                if (secondError.errorcode && secondError.errorcode == 'enablewsdescription') {
                    return rejectWithCriticalError(secondError.error, secondError.errorcode);
                }
                error = secondError || error;
                return $q.reject({error: typeof error == 'object' ? error.error : error});
            });
        }).then(function() {
            var temporarySite = $mmSitesFactory.makeSite(undefined, siteurl);
            return temporarySite.checkLocalMobilePlugin().then(function(data) {
                data.service = data.service || mmCoreConfigConstants.wsservice;
                services[siteurl] = data.service;
                if (data.coresupported || (data.code != mmLoginSSOCode && data.code != mmLoginSSOInAppCode)) {
                    return temporarySite.getPublicConfig().then(function(config) {
                        if (!config.enablewebservices) {
                            return rejectWithCriticalError($translate.instant('mm.login.webservicesnotenabled'));
                        } else if (!config.enablemobilewebservice) {
                            return rejectWithCriticalError($translate.instant('mm.login.mobileservicesnotenabled'));
                        } else if (config.maintenanceenabled) {
                            var message = $translate.instant('mm.core.sitemaintenance');
                            if (config.maintenancemessage) {
                                message += config.maintenancemessage;
                            }
                            return rejectWithCriticalError(message);
                        }
                        if (data.code === 0) {
                            data.code = config.typeoflogin;
                        }
                        data.config = config;
                        return data;
                    }, function(error) {
                        if (error.available === 1) {
                            return $q.reject({error: error.error});
                        }
                        return data;
                    });
                }
                return data;
            }).then(function(data) {
                siteurl = temporarySite.getURL();
                return {siteurl: siteurl, code: data.code, warning: data.warning, service: data.service, config: data.config};
            });
        });
        function rejectWithCriticalError(message, errorCode) {
            return $q.reject({
                error: message,
                errorcode: errorCode,
                critical: true
            });
        }
    }
        self.siteExists = function(siteurl) {
        var data = {};
        if (!ionic.Platform.isWebView()) {
            data.username = 'a';
            data.password = 'b';
            data.service = 'c';
        }
        return $http.post(siteurl + '/login/token.php', data, {timeout: 30000, responseType: 'json'}).then(function(data) {
            data = data.data;
            if (data.errorcode && (data.errorcode == 'enablewsdescription' || data.errorcode == 'requirecorrectaccess')) {
                return $q.reject({errorcode: data.errorcode, error: data.error});
            } else if (data.error && data.error == 'Web services must be enabled in Advanced features.') {
                return $q.reject({errorcode: 'enablewsdescription', error: data.error});
            }
            return $q.when();
        });
    };
        self.getUserToken = function(siteurl, username, password, service, retry) {
        retry = retry || false;
        if (!$mmApp.isOnline()) {
            return $mmLang.translateAndReject('mm.core.networkerrormsg');
        }
        if (!service) {
            service = self.determineService(siteurl);
        }
        var loginurl = siteurl + '/login/token.php';
        var data = {
            username: username,
            password: password,
            service: service
        };
        return $http.post(loginurl, data).then(function(response) {
            var data = response.data;
            if (typeof data == 'undefined') {
                return $mmLang.translateAndReject('mm.core.cannotconnect');
            } else {
                if (typeof data.token != 'undefined') {
                    return {token: data.token, siteurl: siteurl, privatetoken: data.privatetoken};
                } else {
                    if (typeof data.error != 'undefined') {
                        if (!retry && data.errorcode == "requirecorrectaccess") {
                            siteurl = $mmText.addOrRemoveWWW(siteurl);
                            return self.getUserToken(siteurl, username, password, service, true);
                        } else if (typeof data.errorcode != 'undefined') {
                            return $q.reject({error: data.error, errorcode: data.errorcode});
                        } else {
                            return $q.reject(data.error);
                        }
                    } else {
                        return $mmLang.translateAndReject('mm.login.invalidaccount');
                    }
                }
            }
        }, function() {
            return $mmLang.translateAndReject('mm.core.cannotconnect');
        });
    };
        self.newSite = function(siteurl, token, privateToken) {
        privateToken = privateToken || '';
        var candidateSite = $mmSitesFactory.makeSite(undefined, siteurl, token, undefined, privateToken);
        return candidateSite.fetchSiteInfo().then(function(infos) {
            if (isValidMoodleVersion(infos)) {
                var siteId = self.createSiteID(infos.siteurl, infos.username);
                candidateSite.setId(siteId);
                candidateSite.setInfo(infos);
                return getSiteConfig(candidateSite).then(function(config) {
                    candidateSite.setConfig(config);
                    self.addSite(siteId, siteurl, token, infos, privateToken, config);
                    currentSite = candidateSite;
                    self.login(siteId);
                    $mmEvents.trigger(mmCoreEventSiteAdded, siteId);
                });
            } else {
                return $mmLang.translateAndReject('mm.login.invalidmoodleversion');
            }
        });
    };
        self.createSiteID = function(siteurl, username) {
        return md5.createHash(siteurl + username);
    };
        self.determineService = function(siteurl) {
        siteurl = siteurl.replace("https://", "http://");
        if (services[siteurl]) {
            return services[siteurl];
        }
        siteurl = siteurl.replace("http://", "https://");
        if (services[siteurl]) {
            return services[siteurl];
        }
        return mmCoreConfigConstants.wsservice;
    };
        function isValidMoodleVersion(infos) {
        if (!infos) {
            return false;
        }
        var minVersion = 2012120300,
            minRelease = "2.4";
        if (infos.version) {
            var version = parseInt(infos.version);
            if (!isNaN(version)) {
                return version >= minVersion;
            }
        }
        if (infos.release) {
            var matches = infos.release.match(/^([\d|\.]*)/);
            if (matches && matches.length > 1) {
                return matches[1] >= minRelease;
            }
        }
        var appUsesLocalMobile = false;
        angular.forEach(infos.functions, function(func) {
            if (func.name.indexOf(mmCoreWSPrefix) != -1) {
                appUsesLocalMobile = true;
            }
        });
        return appUsesLocalMobile;
    }
        function validateSiteInfo(infos) {
        if (!infos.firstname || !infos.lastname) {
            var moodleLink = '<a mm-link href="' + infos.siteurl + '">' + infos.siteurl + '</a>';
            return {error: 'mm.core.requireduserdatamissing', params: {'$a': moodleLink}};
        }
        return true;
    }
        self.addSite = function(id, siteurl, token, infos, privateToken, config) {
        privateToken = privateToken || '';
        return $mmApp.getDB().insert(mmCoreSitesStore, {
            id: id,
            siteurl: siteurl,
            token: token,
            infos: infos,
            privatetoken: privateToken,
            config: config,
            loggedout: 0
        });
    };
        self.loadSite = function(siteId) {
        $log.debug('Load site ' + siteId);
        return self.getSite(siteId).then(function(site) {
            currentSite = site;
            self.login(siteId);
            if (site.isLoggedOut()) {
                return;
            }
            return site.checkIfLocalMobileInstalledAndNotUsed().then(function() {
                $mmEvents.trigger(mmCoreEventSessionExpired, {siteid: siteId});
            }, function() {
                self.updateSiteInfo(siteId);
            });
        });
    };
        self.getCurrentSite = function() {
        return currentSite;
    };
        self.deleteSite = function(siteid) {
        $log.debug('Delete site '+siteid);
        if (typeof currentSite != 'undefined' && currentSite.id == siteid) {
            self.logout();
        }
        return self.getSite(siteid).then(function(site) {
            return site.deleteDB().then(function() {
                delete sites[siteid];
                return $mmApp.getDB().remove(mmCoreSitesStore, siteid).then(function() {
                    return site.deleteFolder();
                }, function() {
                    return site.deleteFolder();
                }).then(function() {
                    $mmEvents.trigger(mmCoreEventSiteDeleted, site);
                });
            });
        });
    };
        self.hasNoSites = function() {
        return $mmApp.getDB().count(mmCoreSitesStore).then(function(count) {
            if (count > 0) {
                return $q.reject();
            }
        });
    };
        self.hasSites = function() {
        return $mmApp.getDB().count(mmCoreSitesStore).then(function(count) {
            if (count == 0) {
                return $q.reject();
            }
        });
    };
        self.getSite = function(siteId) {
        if (!siteId) {
            return currentSite ? $q.when(currentSite) : $q.reject();
        } else if (currentSite && currentSite.getId() === siteId) {
            return $q.when(currentSite);
        } else if (typeof sites[siteId] != 'undefined') {
            return $q.when(sites[siteId]);
        } else {
            return $mmApp.getDB().get(mmCoreSitesStore, siteId).then(function(data) {
                var site = $mmSitesFactory.makeSite(siteId, data.siteurl, data.token,
                        data.infos, data.privatetoken, data.config, data.loggedout);
                sites[siteId] = site;
                return site;
            });
        }
    };
        self.isCurrentSite = function(site) {
        if (!site || !currentSite) {
            return !!currentSite;
        }
        var siteId = typeof site == 'object' ? site.getId() : site;
        return currentSite.getId() === siteId;
    };
        self.getSiteDb = function(siteId) {
        return self.getSite(siteId).then(function(site) {
            return site.getDb();
        });
    };
        self.getSiteHomeId = function(siteId) {
        return self.getSite(siteId).then(function(site) {
            return site.getSiteHomeId();
        });
    };
        self.getSites = function(ids) {
        return $mmApp.getDB().getAll(mmCoreSitesStore).then(function(sites) {
            var formattedSites = [];
            angular.forEach(sites, function(site) {
                if (!ids || ids.indexOf(site.id) > -1) {
                    formattedSites.push({
                        id: site.id,
                        siteurl: site.siteurl,
                        fullname: site.infos.fullname,
                        sitename: site.infos.sitename,
                        avatar: site.infos.userpictureurl
                    });
                }
            });
            return formattedSites;
        });
    };
        self.getSitesIds = function() {
        return $mmApp.getDB().getAll(mmCoreSitesStore).then(function(sites) {
            var ids = [];
            angular.forEach(sites, function(site) {
                ids.push(site.id);
            });
            return ids;
        });
    };
        self.login = function(siteid) {
        return $mmApp.getDB().insert(mmCoreCurrentSiteStore, {
            id: 1,
            siteid: siteid
        }).then(function() {
            $mmEvents.trigger(mmCoreEventLogin);
        });
    };
        self.logout = function() {
        if (!currentSite) {
            return $q.when();
        }
        var siteId = currentSite.getId(),
            siteConfig = currentSite.getStoredConfig(),
            promises = [];
        currentSite = undefined;
        if (siteConfig && siteConfig.tool_mobile_forcelogout == "1") {
            promises.push(self.setSiteLoggedOut(siteId, true));
        }
        promises.push($mmApp.getDB().remove(mmCoreCurrentSiteStore, 1));
        return $q.all(promises).finally(function() {
            $mmEvents.trigger(mmCoreEventLogout, siteId);
        });
    };
        self.restoreSession = function() {
        if (sessionRestored) {
            return $q.reject();
        }
        sessionRestored = true;
        return $mmApp.getDB().get(mmCoreCurrentSiteStore, 1).then(function(current_site) {
            var siteid = current_site.siteid;
            $log.debug('Restore session in site '+siteid);
            return self.loadSite(siteid);
        }, function() {
            return $q.reject();
        });
    };
        self.setSiteLoggedOut = function(siteId, loggedOut) {
        return self.getSite(siteId).then(function(site) {
            site.setLoggedOut(loggedOut);
            return $mmApp.getDB().insert(mmCoreSitesStore, {
                id: siteId,
                siteurl: site.getURL(),
                token: site.getToken(),
                infos: site.getInfo(),
                privatetoken: site.getPrivateToken(),
                config: site.getStoredConfig(),
                loggedout: loggedOut ? 1 : 0
            });
        });
    };
        self.updateSiteToken = function(siteUrl, username, token, privateToken) {
        var siteId = self.createSiteID(siteUrl, username);
        return self.updateSiteTokenBySiteId(siteId, token, privateToken);
    };
        self.updateSiteTokenBySiteId = function(siteId, token, privateToken) {
        privateToken = privateToken || '';
        return self.getSite(siteId).then(function(site) {
            site.token = token;
            site.privateToken = privateToken;
            site.setLoggedOut(false);
            return $mmApp.getDB().insert(mmCoreSitesStore, {
                id: siteId,
                siteurl: site.getURL(),
                token: token,
                infos: site.getInfo(),
                privatetoken: privateToken,
                config: site.getStoredConfig(),
                loggedout: 0
            });
        });
    };
        self.updateSiteInfo = function(siteid) {
        return self.getSite(siteid).then(function(site) {
            return site.fetchSiteInfo().then(function(infos) {
                site.setInfo(infos);
                return getSiteConfig(site).catch(function() {
                    return site.getStoredConfig();
                }).then(function(config) {
                    site.setConfig(config);
                    return $mmApp.getDB().insert(mmCoreSitesStore, {
                        id: siteid,
                        siteurl: site.getURL(),
                        token: site.getToken(),
                        infos: infos,
                        privatetoken: site.getPrivateToken(),
                        config: config,
                        loggedout: site.isLoggedOut() ? 1 : 0
                    }).finally(function() {
                        $mmEvents.trigger(mmCoreEventSiteUpdated, siteid);
                    });
                });
            });
        });
    };
        self.updateSiteInfoByUrl = function(siteurl, username) {
        var siteid = self.createSiteID(siteurl, username);
        return self.updateSiteInfo(siteid);
    };
        self.getSiteIdsFromUrl = function(url, prioritize, username) {
        if (prioritize && currentSite && currentSite.containsUrl(url)) {
            if (!username || currentSite.getInfo().username == username) {
                return $q.when([currentSite.getId()]);
            }
        }
        if (!url.match(/^https?:\/\//i)) {
            if (url.match(/^[^:]{2,10}:\/\//i)) {
                return $q.when([]);
            } else {
                if (currentSite) {
                    return $q.when([currentSite.getId()]);
                } else {
                    return $q.when([]);
                }
            }
        }
        return $mmApp.getDB().getAll(mmCoreSitesStore).then(function(sites) {
            var ids = [];
            angular.forEach(sites, function(site) {
                if (!sites[site.id]) {
                    sites[site.id] = $mmSitesFactory.makeSite(
                            site.id, site.siteurl, site.token, site.infos, site.privatetoken, site.config, site.loggedout);
                }
                if (sites[site.id].containsUrl(url)) {
                    if (!username || sites[site.id].getInfo().username == username) {
                        ids.push(site.id);
                    }
                }
            });
            return ids;
        }).catch(function() {
            return [];
        });
    };
        self.getStoredCurrentSiteId = function() {
        return $mmApp.getDB().get(mmCoreCurrentSiteStore, 1).then(function(current_site) {
            return current_site.siteid;
        });
    };
        self.getSitePublicConfig = function(siteUrl) {
        var temporarySite = $mmSitesFactory.makeSite(undefined, siteUrl);
        return temporarySite.getPublicConfig();
    };
        function getSiteConfig(site) {
        if (!site.wsAvailable('tool_mobile_get_config')) {
            return $q.when();
        }
        return site.getConfig(false, true);
    }
        self.isFeatureDisabled = function(name, siteId) {
        return self.getSite(siteId).then(function(site) {
            return site.isFeatureDisabled(name);
        });
    };
    return self;
}]);

angular.module('mm.core')
.constant('mmCoreSynchronizationStore', 'sync')
.constant('mmCoreSynchronizationWarningsStore', 'sync_warnings')
.config(["$mmSitesFactoryProvider", "mmCoreSynchronizationStore", "mmCoreSynchronizationWarningsStore", function($mmSitesFactoryProvider, mmCoreSynchronizationStore, mmCoreSynchronizationWarningsStore) {
    var stores = [
        {
            name: mmCoreSynchronizationStore,
            keyPath: ['component', 'id'],
            indexes: []
        },
        {
            name: mmCoreSynchronizationWarningsStore,
            keyPath: ['component', 'id'],
            indexes: []
        }
    ];
    $mmSitesFactoryProvider.registerStores(stores);
}])
.factory('$mmSync', ["$q", "$log", "$mmSitesManager", "$mmSite", "mmCoreSynchronizationStore", "mmCoreSynchronizationWarningsStore", function($q, $log, $mmSitesManager, $mmSite, mmCoreSynchronizationStore, mmCoreSynchronizationWarningsStore) {
    $log = $log.getInstance('$mmSync');
    var self = {},
        mmSync = (function () {
            var syncPromises = {};
            this.component = 'core';
            this.syncInterval = 300000;
                        this.getSyncTime = function(id, siteId) {
                siteId = siteId || $mmSite.getId();
                var that = this;
                return $mmSitesManager.getSiteDb(siteId).then(function(db) {
                    return db.get(mmCoreSynchronizationStore, [that.component, id]).then(function(entry) {
                        return entry.time;
                    }).catch(function() {
                        return 0;
                    });
                });
            };
                        this.setSyncTime = function(id, siteId, time) {
                siteId = siteId || $mmSite.getId();
                var that = this;
                return $mmSitesManager.getSiteDb(siteId).then(function(db) {
                    var entry = {
                            id: id,
                            component: that.component,
                            time: typeof time != 'undefined' ? time : new Date().getTime()
                        };
                    return db.insert(mmCoreSynchronizationStore, entry);
                });
            };
                        this.isSyncNeeded = function(id, siteId) {
                siteId = siteId || $mmSite.getId();
                var that = this;
                return this.getSyncTime(id, siteId).then(function(time) {
                    return new Date().getTime() - that.syncInterval >= time;
                });
            };
                        this.isSyncing = function(id, siteId) {
                siteId = siteId || $mmSite.getId();
                var uniqueId = this.getUniqueSyncId(id);
                return !!(syncPromises[siteId] && syncPromises[siteId][uniqueId]);
            };
                        this.waitForSync = function(id, siteId) {
                siteId = siteId || $mmSite.getId();
                if (this.isSyncing(id, siteId)) {
                    var uniqueId = this.getUniqueSyncId(id);
                    return syncPromises[siteId][uniqueId].catch(function() {});
                }
                return $q.when();
            };
                        this.getOngoingSync = function (id, siteId) {
                siteId = siteId || $mmSite.getId();
                if (this.isSyncing(id, siteId)) {
                    var uniqueId = this.getUniqueSyncId(id);
                    return syncPromises[siteId][uniqueId];
                }
                return false;
            };
                        this.addOngoingSync = function (id, promise, siteId) {
                var uniqueId = this.getUniqueSyncId(id);
                siteId = siteId || $mmSite.getId();
                if (!syncPromises[siteId]) {
                    syncPromises[siteId] = {};
                }
                syncPromises[siteId][uniqueId] = promise;
                return promise.finally(function() {
                    delete syncPromises[siteId][uniqueId];
                });
            };
            this.getUniqueSyncId = function(id) {
                return this.component + '#' + id;
            };
                        this.getSyncWarnings = function(id, siteId) {
                siteId = siteId || $mmSite.getId();
                var that = this;
                return $mmSitesManager.getSiteDb(siteId).then(function(db) {
                    return db.get(mmCoreSynchronizationWarningsStore, [that.component, id]).then(function(entry) {
                        return entry.warnings;
                    }).catch(function() {
                        return [];
                    });
                });
            };
                        this.setSyncWarnings = function(id, warnings, siteId) {
                siteId = siteId || $mmSite.getId();
                var that = this;
                return $mmSitesManager.getSiteDb(siteId).then(function(db) {
                    var entry = {
                        id: id,
                        component: that.component,
                        warnings: typeof warnings != 'undefined' ? warnings : []
                    };
                    return db.insert(mmCoreSynchronizationWarningsStore, entry);
                });
            };
            return this;
        }());
        self.createChild = function(component, syncInterval) {
        var child = Object.create(mmSync);
        child.component = component;
        if (typeof syncInterval != 'undefined') {
            child.syncInterval = syncInterval;
        }
        return child;
    };
    return self;
}]);
angular.module('mm.core')
.factory('$mmSyncBlock', ["$log", "$mmSite", function($log, $mmSite) {
    $log = $log.getInstance('$mmSyncBlock');
    var self = {
        blockedItems: {}
    };
        self.isBlocked = function(component, id, siteId) {
        siteId = siteId || $mmSite.getId();
        var uniqueId = getUniqueSyncBlockId(component, id);
        if (!self.blockedItems[siteId]) {
            return false;
        }
        if (!self.blockedItems[siteId][uniqueId]) {
            return false;
        }
        return Object.keys(self.blockedItems[siteId][uniqueId]).length > 0;
    };
        self.blockOperation = function(component, id, operation, siteId) {
        siteId = siteId || $mmSite.getId();
        var uniqueId = getUniqueSyncBlockId(component, id);
        if (!self.blockedItems[siteId]) {
            self.blockedItems[siteId] = {};
        }
        if (!self.blockedItems[siteId][uniqueId]) {
            self.blockedItems[siteId][uniqueId] = {};
        }
        operation = operation || '-';
        self.blockedItems[siteId][uniqueId][operation] = true;
    };
        self.unblockOperation = function(component, id, operation, siteId) {
        siteId = siteId || $mmSite.getId();
        var uniqueId = getUniqueSyncBlockId(component, id);
        if (self.blockedItems[siteId]) {
            if (self.blockedItems[siteId][uniqueId]) {
                operation = operation || '-';
                delete self.blockedItems[siteId][uniqueId][operation];
            }
        }
    };
        self.clearBlock = function(component, id, iteId) {
        siteId = siteId || $mmSite.getId();
        var uniqueId = getUniqueSyncBlockId(component, id);
        if (self.blockedItems[siteId]) {
            delete self.blockedItems[siteId][uniqueId];
        }
    };
        self.clearAllBlocks = function(siteId) {
        if (siteId) {
            delete self.blockedItems[siteId];
        } else {
            self.blockedItems = {};
        }
    };
    function getUniqueSyncBlockId(component, id) {
        return component + '#' + id;
    }
    return self;
}])
.run(["$mmSyncBlock", "$mmEvents", "mmCoreEventLogout", function($mmSyncBlock, $mmEvents, mmCoreEventLogout) {
    $mmEvents.on(mmCoreEventLogout, function(siteId) {
        $mmSyncBlock.clearAllBlocks(siteId);
    });
}]);
angular.module('mm.core')
.factory('$mmText', ["$q", "$mmLang", "$translate", "$state", function($q, $mmLang, $translate, $state) {
    var self = {},
        element = document.createElement('div');
        self.buildMessage = function(messages) {
        var result = '';
        angular.forEach(messages, function(message) {
            if (message) {
                result = result + '<p>' + message + '</p>';
            }
        });
        return result;
    };
        self.bytesToSize = function(bytes, precision) {
        if (typeof bytes == 'undefined' || bytes < 0) {
            return $translate.instant('mm.core.notapplicable');
        }
        if (typeof precision == 'undefined' || precision < 0) {
            precision = 2;
        }
        var keys = ['mm.core.sizeb', 'mm.core.sizekb', 'mm.core.sizemb', 'mm.core.sizegb', 'mm.core.sizetb'];
        var units = $translate.instant(keys);
        var posttxt = 0;
        if (bytes >= 1024) {
            while (bytes >= 1024) {
                posttxt++;
                bytes = bytes / 1024;
            }
            bytes = Number(Math.round(bytes+'e+'+precision) + 'e-'+precision);
        }
        return $translate.instant('mm.core.humanreadablesize', {size: Number(bytes), unit: units[keys[posttxt]]});
    };
        self.cleanTags = function(text, singleLine) {
        if (!text) {
            return '';
        }
        text = text.replace(/(<([^>]+)>)/ig,"");
        text = angular.element('<p>').html(text).text();
        text = self.replaceNewLines(text, singleLine ? ' ' : '<br>');
        return text;
    };
        self.replaceNewLines = function(text, newValue) {
        return text.replace(/(?:\r\n|\r|\n)/g, newValue);
    };
        self.formatText = function(text, clean, singleLine, shortenLength) {
        return self.treatMultilangTags(text).then(function(formatted) {
            if (clean) {
                formatted = self.cleanTags(formatted, singleLine);
            }
            if (shortenLength && parseInt(shortenLength) > 0) {
                formatted = self.shortenText(formatted, parseInt(shortenLength));
            }
            return formatted;
        });
    };
        self.formatHtmlLines = function(text) {
        var hasHTMLTags = self.hasHTMLTags(text);
        if (text.indexOf('<p>') == -1) {
            text = '<p>' + text + '</p>';
        }
        if (!hasHTMLTags) {
            return self.replaceNewLines(text, '<br>');
        }
        return text;
    };
        self.shortenText = function(text, length) {
        if (text.length > length) {
            text = text.substr(0, length);
            var lastWordPos = text.lastIndexOf(' ');
            if (lastWordPos > 0) {
                text = text.substr(0, lastWordPos);
            }
            text += '&hellip;';
        }
        return text;
    };
        self.expandText = function(title, text, replaceLineBreaks, component, componentId) {
        if (text.length > 0) {
            $state.go('site.mm_textviewer', {
                title: title,
                content: text,
                replacelinebreaks: replaceLineBreaks,
                component: component,
                componentId: componentId
            });
        }
    };
        self.treatMultilangTags = function(text) {
        if (!text) {
            return $q.when('');
        }
        return $mmLang.getCurrentLanguage().then(function(language) {
            var currentLangRe = new RegExp('<(?:lang|span)[^>]+lang="' + language + '"[^>]*>(.*?)<\/(?:lang|span)>', 'g'),
                anyLangRE = /<(?:lang|span)[^>]+lang="[a-zA-Z0-9_-]+"[^>]*>(.*?)<\/(?:lang|span)>/g;
            if (!text.match(currentLangRe)) {
                var matches = text.match(anyLangRE);
                if (matches && matches[0]) {
                    language = matches[0].match(/lang="([a-zA-Z0-9_-]+)"/)[1];
                    currentLangRe = new RegExp('<(?:lang|span)[^>]+lang="' + language + '"[^>]*>(.*?)<\/(?:lang|span)>', 'g');
                } else {
                    return text;
                }
            }
            text = text.replace(currentLangRe, '$1');
            text = text.replace(anyLangRE, '');
            return text;
        });
    };
        self.escapeHTML = function(text) {
        if (typeof text == 'undefined' || text === null || (typeof text == 'number' && isNaN(text))) {
            return '';
        } else if (typeof text != 'string') {
            return '' + text;
        }
        return text
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    };
        self.decodeHTML = function(text) {
        if (typeof text == 'undefined' || text === null || (typeof text == 'number' && isNaN(text))) {
            return '';
        } else if (typeof text != 'string') {
            return '' + text;
        }
        return text
            .replace(/&amp;/g, '&')
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&quot;/g, '"')
            .replace(/&#039;/g, "'")
            .replace(/&nbsp;/g, ' ');
    };
        self.decodeHTMLEntities = function(text) {
        if (text && typeof text === 'string') {
            element.innerHTML = text;
            text = element.textContent;
            element.textContent = '';
        }
        return text;
    };
        self.addOrRemoveWWW = function(url) {
        if (typeof url == 'string') {
            if (url.match(/http(s)?:\/\/www\./)) {
                url = url.replace('www.', '');
            } else {
                url = url.replace('https://', 'https://www.');
                url = url.replace('http://', 'http://www.');
            }
        }
        return url;
    };
        self.removeProtocolAndWWW = function(url) {
        url = url.replace(/.*?:\/\//g, '');
        url = url.replace(/^www./, '');
        return url;
    };
        self.getUsernameFromUrl = function(url) {
        if (url.indexOf('@') > -1) {
            var withoutProtocol = url.replace(/.*?:\/\//, ''),
                matches = withoutProtocol.match(/[^@]*/);
            if (matches && matches.length && !matches[0].match(/[\/|?]/)) {
                return matches[0];
            }
        }
    };
        self.removeSpecialCharactersForFiles = function(text) {
        return text.replace(/[#:\/\?\\]+/g, '_');
    };
        self.getLastFileWithoutParams = function(url) {
        var filename = url.substr(url.lastIndexOf('/') + 1);
        if (filename.indexOf('?') != -1) {
            filename = filename.substr(0, filename.indexOf('?'));
        }
        return filename;
    };
        self.twoDigits = function(num) {
        if (num < 10) {
            return '0' + num;
        } else {
            return '' + num;
        }
    };
        self.escapeForRegex = function(text) {
        if (!text || !text.replace) {
            return '';
        }
        return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    };
        self.countWords = function(text) {
        text = text.replace(/<script[^>]*>([\S\s]*?)<\/script>/gmi, '');
        text = text.replace(/<\/?(?!\!)[^>]*>/gi, '');
        text = self.decodeHTMLEntities(text);
        text = text.replace(/_/gi, " ");
        text = text.replace(/[\'"’-]/gi, "");
        text = text.replace(/([0-9])[.,]([0-9])/gi, '$1$2');
        return text.split(/\w\b/gi).length - 1;
    };
        self.getTextPluginfileUrl = function(files) {
        if (files && files.length) {
            var fileURL = files[0].fileurl;
            return fileURL.substr(0, Math.max(fileURL.lastIndexOf('/'), fileURL.lastIndexOf('%2F')));
        }
        return false;
    };
        self.replacePluginfileUrls = function(text, files) {
        if (text) {
            var fileURL = self.getTextPluginfileUrl(files);
            if (fileURL) {
                return text.replace(/@@PLUGINFILE@@/g, fileURL);
            }
        }
        return text;
    };
        self.restorePluginfileUrls = function(text, files) {
        if (text) {
            var fileURL = self.getTextPluginfileUrl(files);
            if (fileURL) {
                return text.replace(new RegExp(self.escapeForRegex(fileURL), 'g'), '@@PLUGINFILE@@');
            }
        }
        return text;
    };
        self.getUrlProtocol = function(url) {
        if (!url) {
            return;
        }
        var matches = url.match(/^([^\/:\.\?]*):\/\//);
        if (matches && matches[1]) {
            return matches[1];
        }
    };
        self.getUrlScheme = function(url) {
        if (!url) {
            return;
        }
        var matches = url.match(/^([a-z][a-z0-9+\-.]*):/);
        if (matches && matches[1]) {
            return matches[1];
        }
    };
        self.hasHTMLTags = function(text) {
        return /<[a-z][\s\S]*>/i.test(text);
    };
        self.hasUnicode = function(text) {
        for (var x = 0; x < text.length; x++) {
            if (text.charCodeAt(x) > 55295) {
                return true;
            }
        }
        return false;
    };
        self.hasUnicodeData = function(data) {
        for (var el in data) {
            if (angular.isObject(data[el])) {
                if (self.hasUnicodeData(data[el])) {
                    return true;
                }
            } else if (typeof data[el] == "string" && self.hasUnicode(data[el])) {
                return true;
            }
        }
        return false;
    };
        self.stripUnicode = function(text) {
        var stripped = "";
        for (var x = 0; x < text.length; x++) {
            if (text.charCodeAt(x) <= 55295){
                stripped += text.charAt(x);
            }
        }
        return stripped;
    };
        self.decodeURI = function(uri) {
        try {
            return decodeURI(uri);
        } catch(ex) {
        }
        return uri;
    };
        self.decodeURIComponent = function(uri) {
        try {
            return decodeURIComponent(uri);
        } catch(ex) {
        }
        return uri;
    };
    return self;
}]);

angular.module('mm.core')
.constant('mmCoreVersionApplied', 'version_applied')
.factory('$mmUpdateManager', ["$log", "$q", "$mmConfig", "$mmSitesManager", "$mmFS", "$cordovaLocalNotification", "$mmLocalNotifications", "$mmApp", "$mmEvents", "mmCoreSitesStore", "mmCoreVersionApplied", "mmCoreEventSiteAdded", "mmCoreEventSiteUpdated", "mmCoreEventSiteDeleted", "$injector", "$mmFilepool", "mmCoreCourseModulesStore", "mmFilepoolLinksStore", "$mmAddonManager", "mmFilepoolPackagesStore", "mmCoreConfigConstants", function($log, $q, $mmConfig, $mmSitesManager, $mmFS, $cordovaLocalNotification, $mmLocalNotifications,
            $mmApp, $mmEvents, mmCoreSitesStore, mmCoreVersionApplied, mmCoreEventSiteAdded, mmCoreEventSiteUpdated,
            mmCoreEventSiteDeleted, $injector, $mmFilepool, mmCoreCourseModulesStore, mmFilepoolLinksStore, $mmAddonManager,
            mmFilepoolPackagesStore, mmCoreConfigConstants) {
    $log = $log.getInstance('$mmUpdateManager');
    var self = {},
        sitesFilePath = 'migration/sites.json';
        self.check = function() {
        var promises = [],
            versionCode = mmCoreConfigConstants.versioncode;
        return $mmConfig.get(mmCoreVersionApplied, 0).then(function(versionApplied) {
            if (versionCode >= 391 && versionApplied < 391) {
                promises.push(migrateMM1Sites());
                promises.push(clearAppFolder().catch(function() {}));
            }
            if (versionCode >= 2003 && versionApplied < 2003) {
                promises.push(cancelAndroidNotifications());
            }
            if (versionCode >= 2003) {
                setStoreSitesInFile();
            }
            if (versionCode >= 2007 && versionApplied < 2007) {
                promises.push(migrateModulesStatus());
            }
            if (versionCode >= 2013 && versionApplied < 2013) {
                promises.push(migrateFileExtensions());
            }
            if (versionCode >= 2017 && versionApplied < 2017) {
                promises.push(setCalendarDefaultNotifTime());
                promises.push(setSitesConfig());
                promises.push(migrateWikiNewPagesStore());
            }
            return $q.all(promises).then(function() {
                return $mmConfig.set(mmCoreVersionApplied, versionCode);
            }).catch(function() {
                $log.error('Error applying update from ' + versionApplied + ' to ' + versionCode);
            });
        });
    };
        function clearAppFolder() {
        if ($mmFS.isAvailable()) {
            return $mmFS.getDirectoryContents('').then(function(entries) {
                var promises = [];
                angular.forEach(entries, function(entry) {
                    var canDeleteAndroid = ionic.Platform.isAndroid() && entry.name !== 'cache' && entry.name !== 'files';
                    var canDeleteIOS = ionic.Platform.isIOS() && entry.name !== 'NoCloud';
                    if (canDeleteIOS || canDeleteAndroid) {
                        promises.push($mmFS.removeDir(entry.name));
                    }
                });
                return $q.all(promises);
            });
        } else {
            return $q.when();
        }
    }
        function migrateMM1Sites() {
        var sites = localStorage.getItem('sites'),
            promises = [];
        if (sites) {
            sites = sites.split(',');
            angular.forEach(sites, function(siteid) {
                if (!siteid) {
                    return;
                }
                $log.debug('Migrating site from MoodleMobile 1: ' + siteid);
                var site = localStorage.getItem('sites-'+siteid),
                    infos;
                if (site) {
                    try {
                        site = JSON.parse(site);
                    } catch(ex) {
                        $log.warn('Site ' + siteid + ' data is invalid. Ignoring.');
                        return;
                    }
                    infos = angular.copy(site);
                    delete infos.id;
                    delete infos.token;
                    promises.push($mmSitesManager.addSite(site.id, site.siteurl, site.token, infos));
                } else {
                    $log.warn('Site ' + siteid + ' not found in local storage. Ignoring.');
                }
            });
        }
        return $q.all(promises).then(function() {
            if (sites) {
                localStorage.clear();
            }
        });
    }
        function cancelAndroidNotifications() {
        if ($mmLocalNotifications.isAvailable() && ionic.Platform.isAndroid()) {
            return $cordovaLocalNotification.cancelAll().catch(function() {
                $log.error('Error cancelling Android notifications.');
            });
        }
        return $q.when();
    }
        function setStoreSitesInFile() {
        $mmEvents.on(mmCoreEventSiteAdded, storeSitesInFile);
        $mmEvents.on(mmCoreEventSiteUpdated, storeSitesInFile);
        $mmEvents.on(mmCoreEventSiteDeleted, storeSitesInFile);
        storeSitesInFile();
    }
        function getSitesStoredInFile() {
        if ($mmFS.isAvailable()) {
            return $mmFS.readFile(sitesFilePath).then(function(sites) {
                try {
                    sites = JSON.parse(sites);
                } catch (ex) {
                    sites = [];
                }
                return sites;
            }).catch(function() {
                return [];
            });
        } else {
            return $q.when([]);
        }
    }
        function storeSitesInFile() {
        if ($mmFS.isAvailable()) {
            return $mmApp.getDB().getAll(mmCoreSitesStore).then(function(sites) {
                angular.forEach(sites, function(site) {
                    site.token = 'private';
                });
                return $mmFS.writeFile(sitesFilePath, JSON.stringify(sites));
            });
        } else {
            return $q.when();
        }
    }
        function deleteSitesFile() {
        if ($mmFS.isAvailable()) {
            return $mmFS.removeFile(sitesFilePath);
        } else {
            return $q.when();
        }
    }
        function migrateModulesStatus() {
        var components = [];
        components.push($injector.get('mmaModBookComponent'));
        components.push($injector.get('mmaModImscpComponent'));
        components.push($injector.get('mmaModPageComponent'));
        components.push($injector.get('mmaModResourceComponent'));
        return $mmSitesManager.getSitesIds().then(function(sites) {
            var promises = [];
            angular.forEach(sites, function(siteId) {
                promises.push(migrateSiteModulesStatus(siteId, components));
            });
            return $q.all(promises);
        });
    }
        function migrateSiteModulesStatus(siteId, components) {
        $log.debug('Migrate site modules status from site ' + siteId);
        return $mmSitesManager.getSiteDb(siteId).then(function(db) {
            return db.getAll(mmCoreCourseModulesStore).then(function(entries) {
                var promises = [];
                angular.forEach(entries, function(entry) {
                    if (!parseInt(entry.id)) {
                        return;
                    }
                    promises.push(determineComponent(db, entry.id, components).then(function(component) {
                        if (component) {
                            entry.component = component;
                            entry.componentId = entry.id;
                            entry.id = $mmFilepool.getPackageId(component, entry.id);
                            promises.push(db.insert(mmFilepoolPackagesStore, entry));
                        }
                    }));
                });
                return $q.all(promises).then(function() {
                    return db.removeAll(mmCoreCourseModulesStore).catch(function() {
                    });
                });
            });
        });
    }
        function migrateFileExtensions() {
        return $mmSitesManager.getSitesIds().then(function(sites) {
            var promises = [];
            angular.forEach(sites, function(siteId) {
                promises.push($mmFilepool.fillMissingExtensionInFiles(siteId));
            });
            promises.push($mmFilepool.treatExtensionInQueue());
            return $q.all(promises);
        });
    }
        function determineComponent(db, componentId, components) {
        var promises = [],
            component;
        angular.forEach(components, function(c) {
            if (c) {
                promises.push(db.whereEqual(mmFilepoolLinksStore, 'componentAndId', [c, componentId]).then(function(items) {
                    if (items.length) {
                        component = c;
                    }
                }).catch(function() {
                }));
            }
        });
        return $q.all(promises).then(function() {
            return component;
        });
    }
        function setCalendarDefaultNotifTime() {
        if (!$mmLocalNotifications.isAvailable()) {
            return $q.when();
        }
        var $mmaCalendar = $mmAddonManager.get('$mmaCalendar'),
            mmaCalendarDefaultNotifTime = $mmAddonManager.get('mmaCalendarDefaultNotifTime');
        if (!$mmaCalendar || typeof mmaCalendarDefaultNotifTime == 'undefined') {
            return $q.when();
        }
        return $mmSitesManager.getSitesIds().then(function(siteIds) {
            var promises = [];
            angular.forEach(siteIds, function(siteId) {
                promises.push($mmaCalendar.getAllEventsFromLocalDb(siteId).then(function(events) {
                    var eventPromises = [];
                    angular.forEach(events, function(event) {
                        if (event.notificationtime == mmaCalendarDefaultNotifTime) {
                            event.notificationtime = -1;
                            eventPromises.push($mmaCalendar.storeEventInLocalDb(event, siteId));
                        }
                    });
                    return $q.all(eventPromises);
                }));
            });
            return $q.all(promises);
        });
    }
        function setSitesConfig() {
        return $mmSitesManager.getSitesIds().then(function(siteIds) {
            return $mmSitesManager.getStoredCurrentSiteId().catch(function() {
            }).then(function(currentSiteId) {
                var promise;
                if (currentSiteId) {
                    promise = setSiteConfig(currentSiteId);
                } else {
                    promise = $q.when();
                }
                angular.forEach(siteIds, function(siteId) {
                    if (siteId != currentSiteId) {
                        setSiteConfig(siteId);
                    }
                });
                return promise;
            });
        });
    }
        function setSiteConfig(siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            if (site.getStoredConfig() || !site.wsAvailable('tool_mobile_get_config')) {
                return;
            }
            return site.getConfig().then(function(config) {
                return $mmSitesManager.addSite(site.getId(), site.getURL(),
                        site.getToken(), site.getInfo(), site.getPrivateToken(), config);
            }).catch(function() {
            });
        });
    }
        function migrateWikiNewPagesStore() {
        return $mmSitesManager.getSitesIds().then(function(siteIds) {
            return $mmSitesManager.getStoredCurrentSiteId().catch(function() {
            }).then(function(currentSiteId) {
                var promise;
                if (currentSiteId) {
                    promise = migrateWikiNewPagesSiteStore(currentSiteId);
                } else {
                    promise = $q.when();
                }
                angular.forEach(siteIds, function(siteId) {
                    if (siteId != currentSiteId) {
                        migrateWikiNewPagesSiteStore(siteId);
                    }
                });
                return promise;
            });
        });
    }
        function migrateWikiNewPagesSiteStore(siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var $mmaModWikiOffline = $injector.get('$mmaModWikiOffline'),
                oldStorageName = 'mma_mod_wiki_new_pages',
                db = site.getDb();
            try {
                return db.getAll(oldStorageName).then(function(pages) {
                    if (pages.length > 0) {
                        $log.debug('Found ' + pages.length + ' new wiki pages from old store to migrate on site' + siteId);
                        var promises = [];
                        angular.forEach(pages, function(page) {
                            if (page.subwikiid > 0) {
                                promises.push($mmaModWikiOffline.saveNewPage(page.title, page.cachedcontent, page.subwikiid, 0, 0,
                                    0, siteId));
                            }
                        });
                        return $q.all(promises).finally(function() {
                            db.removeAll(oldStorageName);
                        });
                    }
                }).catch(function() {
                    return $q.when();
                });
            } catch (e) {
            }
            return $q.when();
        });
    }
    return self;
}]);

angular.module('mm.core')
.factory('$mmURLDelegate', ["$log", function($log) {
    $log = $log.getInstance('$mmURLDelegate');
    var observers = {},
        self = {};
        self.register = function(name, callback) {
        $log.debug("Register observer '"+name+"' for custom URL.");
        observers[name] = callback;
    };
        self.notify = function(url) {
        var treated = false;
        angular.forEach(observers, function(callback, name) {
            if (!treated && typeof(callback) === 'function') {
                treated = callback(url);
            }
        });
    };
    return self;
}])
.run(["$mmURLDelegate", "$log", function($mmURLDelegate, $log) {
    window.handleOpenURL = function(url) {
        $log.debug('App launched by URL.');
        $mmURLDelegate.notify(url);
    };
}]);

angular.module('mm.core')
.provider('$mmUtil', ["mmCoreSecondsYear", "mmCoreSecondsDay", "mmCoreSecondsHour", "mmCoreSecondsMinute", function(mmCoreSecondsYear, mmCoreSecondsDay, mmCoreSecondsHour, mmCoreSecondsMinute) {
    var self = this,
        provider = this;
        self.param = function(obj, addNull) {
        var query = '', name, value, fullSubName, subName, subValue, innerObj, i;
        for (name in obj) {
            value = obj[name];
            if (value instanceof Array) {
                for (i = 0; i < value.length; ++i) {
                    subValue = value[i];
                    fullSubName = name + '[' + i + ']';
                    innerObj = {};
                    innerObj[fullSubName] = subValue;
                    query += self.param(innerObj) + '&';
                }
            } else if (value instanceof Object) {
                for (subName in value) {
                    subValue = value[subName];
                    fullSubName = name + '[' + subName + ']';
                    innerObj = {};
                    innerObj[fullSubName] = subValue;
                    query += self.param(innerObj) + '&';
                }
            } else if (addNull || (value !== undefined && value !== null)) {
                query += encodeURIComponent(name) + '=' + encodeURIComponent(value) + '&';
            }
        }
        return query.length ? query.substr(0, query.length - 1) : query;
    };
    this.$get = ["$ionicLoading", "$ionicPopup", "$injector", "$translate", "$http", "$log", "$q", "$mmLang", "$mmFS", "$timeout", "$mmApp", "$mmText", "mmCoreWifiDownloadThreshold", "mmCoreDownloadThreshold", "$ionicScrollDelegate", "$mmWS", "$cordovaInAppBrowser", "$mmConfig", "mmCoreSettingsRichTextEditor", "$rootScope", "$ionicPlatform", "$ionicHistory", "mmCoreSplitViewBlock", "$state", "$window", "$cordovaClipboard", function($ionicLoading, $ionicPopup, $injector, $translate, $http, $log, $q, $mmLang, $mmFS, $timeout, $mmApp,
                $mmText, mmCoreWifiDownloadThreshold, mmCoreDownloadThreshold, $ionicScrollDelegate, $mmWS, $cordovaInAppBrowser,
                $mmConfig, mmCoreSettingsRichTextEditor, $rootScope, $ionicPlatform, $ionicHistory, mmCoreSplitViewBlock, $state,
                $window, $cordovaClipboard) {
        $log = $log.getInstance('$mmUtil');
        var self = {},
            matchesFn,
            inputSupportKeyboard = ['date', 'datetime', 'datetime-local', 'email', 'month', 'number', 'password',
                'search', 'tel', 'text', 'time', 'url', 'week'],
            originalBackFunction = $rootScope.$ionicGoBack,
            backFunctionsStack = [originalBackFunction],
            toastPromise;
                self.formatURL = function(url) {
            url = url.trim();
            if (! /^http(s)?\:\/\/.*/i.test(url)) {
                url = "https://" + url;
            }
            url = url.replace(/^http/i, 'http');
            url = url.replace(/^https/i, 'https');
            url = url.replace(/\/$/, "");
            return url;
        };
                self.resolveObject = function(object, instantiate) {
            var toInject,
                resolved;
            instantiate = angular.isUndefined(instantiate) ? false : instantiate;
            if (angular.isFunction(object) || angular.isObject(object)) {
                resolved = object;
            } else if (angular.isString(object)) {
                toInject = object.split('.');
                resolved = $injector.get(toInject[0]);
                if (toInject.length > 1) {
                    resolved = resolved[toInject[1]];
                }
            }
            if (angular.isFunction(resolved) && instantiate) {
                resolved = resolved();
            }
            if (typeof resolved === 'undefined') {
                throw new Error('Unexpected argument object passed');
            }
            return resolved;
        };
                self.isDownloadableUrl = function(url) {
            return self.isPluginFileUrl(url) || self.isThemeImageUrl(url) || self.isGravatarUrl(url);
        };
                self.isGravatarUrl = function(url) {
            return url && url.indexOf('gravatar.com/avatar') !== -1;
        };
                self.isPluginFileUrl = function(url) {
            return url && url.indexOf('/pluginfile.php') !== -1;
        };
                self.isThemeImageUrl = function(url) {
            return url && url.indexOf('/theme/image.php') !== -1;
        };
                self.isValidURL = function(url) {
            return /^http(s)?\:\/\/.+/i.test(url);
        };
                self.fixPluginfileURL = function(url, token) {
            if (!url) {
                return '';
            }
            if (url.indexOf('token=') != -1) {
                return url;
            }
            if (url.indexOf('pluginfile') == -1) {
                return url;
            }
            if (!token) {
                return '';
            }
            if (url.indexOf('?file=') != -1 || url.indexOf('?forcedownload=') != -1 || url.indexOf('?rev=') != -1) {
                url += '&';
            } else {
                url += '?';
            }
            url += 'token=' + token;
            if (url.indexOf('/webservice/pluginfile') == -1) {
                url = url.replace('/pluginfile', '/webservice/pluginfile');
            }
            return url;
        };
                self.openFile = function(path) {
            var deferred = $q.defer();
            if (window.plugins) {
                var extension = $mmFS.getFileExtension(path),
                    mimetype = $mmFS.getMimeType(extension);
                if (ionic.Platform.isAndroid() && window.plugins.webintent) {
                    var iParams = {
                        action: "android.intent.action.VIEW",
                        url: path,
                        type: mimetype
                    };
                    window.plugins.webintent.startActivity(
                        iParams,
                        function() {
                            $log.debug('Intent launched');
                            deferred.resolve();
                        },
                        function() {
                            $log.debug('Intent launching failed.');
                            $log.debug('action: ' + iParams.action);
                            $log.debug('url: ' + iParams.url);
                            $log.debug('type: ' + iParams.type);
                            if (!extension || extension.indexOf('/') > -1 || extension.indexOf('\\') > -1) {
                                $mmLang.translateAndRejectDeferred(deferred, 'mm.core.erroropenfilenoextension');
                            } else {
                                $mmLang.translateAndRejectDeferred(deferred, 'mm.core.erroropenfilenoapp');
                            }
                        }
                    );
                } else if (ionic.Platform.isIOS() && typeof handleDocumentWithURL == 'function') {
                    $mmFS.getBasePath().then(function(fsRoot) {
                        if (path.indexOf(fsRoot > -1)) {
                            path = path.replace(fsRoot, "");
                            path = encodeURIComponent($mmText.decodeURIComponent(path));
                            path = fsRoot + path;
                        }
                        handleDocumentWithURL(
                            function() {
                                $log.debug('File opened with handleDocumentWithURL' + path);
                                deferred.resolve();
                            },
                            function(error) {
                                $log.debug('Error opening with handleDocumentWithURL' + path);
                                if(error == 53) {
                                    $log.error('No app that handles this file type.');
                                }
                                self.openInBrowser(path);
                                deferred.resolve();
                            },
                            path
                        );
                    }, deferred.reject);
                } else {
                    self.openInBrowser(path);
                    deferred.resolve();
                }
            } else {
                $log.debug('Opening external file using window.open()');
                window.open(path, '_blank');
                deferred.resolve();
            }
            return deferred.promise;
        };
                self.openInBrowser = function(url) {
            window.open(url, '_system');
        };
                self.openInApp = function(url, options) {
            if (!url) {
                return;
            }
            options = options || {};
            if (!options.enableViewPortScale) {
                options.enableViewPortScale = 'yes';
            }
            if (!options.location && ionic.Platform.isIOS() && url.indexOf('file://') === 0) {
                options.location = 'no';
            }
            $cordovaInAppBrowser.open(url, '_blank', options);
        };
                self.closeInAppBrowser = function() {
            $cordovaInAppBrowser.close();
        };
                self.openOnlineFile = function(url) {
            var deferred = $q.defer();
            if (ionic.Platform.isAndroid() && window.plugins && window.plugins.webintent) {
                var extension,
                    iParams;
                $mmWS.getRemoteFileMimeType(url).then(function(mimetype) {
                    if (!mimetype) {
                        extension = $mmFS.guessExtensionFromUrl(url);
                        mimetype = $mmFS.getMimeType(extension);
                    }
                    iParams = {
                        action: "android.intent.action.VIEW",
                        url: url,
                        type: mimetype
                    };
                    window.plugins.webintent.startActivity(
                        iParams,
                        function() {
                            $log.debug('Intent launched');
                            deferred.resolve();
                        },
                        function() {
                            $log.debug('Intent launching failed.');
                            $log.debug('action: ' + iParams.action);
                            $log.debug('url: ' + iParams.url);
                            $log.debug('type: ' + iParams.type);
                            if (!extension || extension.indexOf('/') > -1 || extension.indexOf('\\') > -1) {
                                $mmLang.translateAndRejectDeferred(deferred, 'mm.core.erroropenfilenoextension');
                            } else {
                                $mmLang.translateAndRejectDeferred(deferred, 'mm.core.erroropenfilenoapp');
                            }
                        }
                    );
                });
            } else {
                $log.debug('Opening remote file using window.open()');
                window.open(url, '_blank');
                deferred.resolve();
            }
            return deferred.promise;
        };
                self.getMimeType = function(url) {
            return $mmWS.getRemoteFileMimeType(url).then(function(mimetype) {
                if (!mimetype) {
                    extension = $mmFS.guessExtensionFromUrl(url);
                    mimetype = $mmFS.getMimeType(extension);
                }
                return mimetype || '';
            });
        };
                self.showModalLoading = function(text, needsTranslate) {
            var modalClosed = false,
                modalShown = false,
                showModalPromise;
            if (!modalClosed) {
                if (!text) {
                    text = $translate.instant('mm.core.loading');
                } else if (needsTranslate) {
                    text = $translate.instant(text);
                }
                showModalPromise = $ionicLoading.show({
                    template:   '<ion-spinner></ion-spinner>' +
                                '<p>' + addFormatTextIfNeeded(text) + '</p>'
                }).then(function() {
                    showModalPromise = null;
                    if (!modalClosed) {
                        modalShown = true;
                    }
                });
            }
            return {
                dismiss: function() {
                    modalClosed = true;
                    if (showModalPromise) {
                        showModalPromise.finally(function() {
                            $ionicLoading.hide();
                        });
                    } else if (modalShown) {
                        $ionicLoading.hide();
                    }
                }
            };
        };
                self.showToast = function(text, needsTranslate, duration) {
            duration = duration || 2000;
            if (needsTranslate) {
                text = $translate.instant(text);
            }
            return $ionicLoading.show({
                template: text,
                duration: duration,
                noBackdrop: true,
                hideOnStateChange: true
            }).then(function() {
                var container = angular.element(document.querySelector(".loading-container.visible")).addClass('mm-toast');
                $timeout.cancel(toastPromise);
                toastPromise = $timeout(function() {
                    container.removeClass('mm-toast');
                }, duration);
            });
        };
                self.copyToClipboard = function(text) {
            return $cordovaClipboard.copy(text).then(function() {
                return self.showToast('mm.core.copiedtoclipboard', true);
            }).catch(function () {
            });
        };
                self.showModalLoadingWithTemplate = function(template, options) {
            options = options || {};
            if (!template) {
                template = "<ion-spinner></ion-spinner><p>{{'mm.core.loading' | translate}}</p>";
            }
            options.template = addFormatTextIfNeeded(template);
            $ionicLoading.show(options);
            return {
                dismiss: function() {
                    $ionicLoading.hide();
                }
            };
        };
                self.showErrorModal = function(errorMessage, needsTranslate, autocloseTime) {
            if (angular.isObject(errorMessage)) {
                if (typeof errorMessage.content != 'undefined') {
                    errorMessage = errorMessage.content;
                } else if (typeof errorMessage.body != 'undefined') {
                    errorMessage = errorMessage.body;
                } else if (typeof errorMessage.message != 'undefined') {
                    errorMessage = errorMessage.message;
                } else if (typeof errorMessage.error != 'undefined') {
                    errorMessage = errorMessage.error;
                } else {
                    errorMessage = JSON.stringify(errorMessage);
                }
                var matches = errorMessage.match(/token"?[=|:]"?(\w*)/, '');
                if (matches && matches[1]) {
                    errorMessage = errorMessage.replace(new RegExp(matches[1], 'g'), 'secret');
                }
            }
            var message = $mmText.decodeHTML(needsTranslate ? $translate.instant(errorMessage) : errorMessage),
                popup = $ionicPopup.alert({
                    title: getErrorTitle(message),
                    template: addFormatTextIfNeeded(message)
                });
            if (typeof autocloseTime != 'undefined' && !isNaN(parseInt(autocloseTime))) {
                $timeout(function() {
                    popup.close();
                }, parseInt(autocloseTime));
            }
        };
        function getErrorTitle(message) {
            if (message == $translate.instant('mm.core.networkerrormsg')) {
                return '<span class="mm-icon-with-badge"><i class="icon ion-wifi"></i>\
                    <i class="icon ion-alert-circled mm-icon-badge"></i></span>';
            }
            return $mmText.decodeHTML($translate.instant('mm.core.error'));
        }
                self.showErrorModalDefault = function(errorMessage, defaultError, needsTranslate, autocloseTime) {
            errorMessage = typeof errorMessage == 'string' ? errorMessage : defaultError;
            return self.showErrorModal(errorMessage, needsTranslate, autocloseTime);
        };
                self.showModal = function(title, message, autocloseTime) {
            title = $translate.instant(title);
            message = $translate.instant(message);
            autocloseTime = parseInt(autocloseTime);
            var popup = $ionicPopup.alert({
                title: title,
                template: addFormatTextIfNeeded(message)
            });
            if (autocloseTime > 0) {
                $timeout(function() {
                    popup.close();
                }, autocloseTime);
            }
            return popup;
        };
                self.showConfirm = function(template, title, options) {
            options = options || {};
            options.template = addFormatTextIfNeeded(template);
            options.title = title;
            if (!title) {
                options.cssClass = 'mm-nohead';
            }
            return $ionicPopup.confirm(options).then(function(confirmed) {
                if (!confirmed) {
                    return $q.reject();
                }
            });
        };
                self.showPrompt = function(body, title, inputPlaceholder, inputType) {
            inputType = inputType || 'password';
            var options = {
                template: addFormatTextIfNeeded(body),
                title: title,
                inputPlaceholder: inputPlaceholder,
                inputType: inputType
            };
            return $ionicPopup.prompt(options).then(function(data) {
                if (typeof data == 'undefined') {
                    return $q.reject();
                }
                return data;
            });
        };
                function addFormatTextIfNeeded(message) {
            if ($mmText.hasHTMLTags(message)) {
                return '<mm-format-text watch="true">' + message + '</mm-format-text>';
            }
            return message;
        }
                self.readJSONFile = function(path) {
            return $http.get(path).then(function(response) {
                return response.data;
            });
        };
                self.getCountryName = function(code) {
            var countryKey = 'mm.core.country-' + code,
                countryName = $translate.instant(countryKey);
            return countryName !== countryKey ? countryName : code;
        };
                self.getCountryList = function() {
            var table = $translate.getTranslationTable(),
                countries = {};
            angular.forEach(table, function(value, name) {
                if (name.indexOf('mm.core.country-') === 0) {
                    name = name.replace('mm.core.country-', '');
                    countries[name] = value;
                }
            });
            return countries;
        };
                self.getDocsUrl = function(release, page) {
            page = page || 'Mobile_app';
            var docsurl = 'https://docs.moodle.org/en/' + page;
            if (typeof release != 'undefined') {
                var version = release.substr(0, 3).replace(".", "");
                if (parseInt(version) >= 24) {
                    docsurl = docsurl.replace('https://docs.moodle.org/', 'https://docs.moodle.org/' + version + '/');
                }
            }
            return $mmLang.getCurrentLanguage().then(function(lang) {
                return docsurl.replace('/en/', '/' + lang + '/');
            }, function() {
                return docsurl;
            });
        };
                self.timestamp = function() {
            return Math.round(Date.now() / 1000);
        };
                self.readableTimestamp = function() {
            return moment(Date.now()).format('YYYYMMDDHHmmSS');
        };
                self.isFalseOrZero = function(value) {
            return typeof value != 'undefined' && (value === false || value === "false" || parseInt(value) === 0);
        };
                self.isTrueOrOne = function(value) {
            return typeof value != 'undefined' && (value === true || value === "true" || parseInt(value) === 1);
        };
                self.formatTime = function(seconds) {
            var langKeys = ['mm.core.day', 'mm.core.days', 'mm.core.hour', 'mm.core.hours', 'mm.core.min', 'mm.core.mins',
                            'mm.core.sec', 'mm.core.secs', 'mm.core.year', 'mm.core.years', 'mm.core.now'];
            return $translate(langKeys).then(function(translations) {
                totalSecs = Math.abs(seconds);
                var years     = Math.floor(totalSecs / mmCoreSecondsYear);
                var remainder = totalSecs - (years * mmCoreSecondsYear);
                var days      = Math.floor(remainder / mmCoreSecondsDay);
                remainder = totalSecs - (days * mmCoreSecondsDay);
                var hours     = Math.floor(remainder / mmCoreSecondsHour);
                remainder = remainder - (hours * mmCoreSecondsHour);
                var mins      = Math.floor(remainder / mmCoreSecondsMinute);
                var secs      = remainder - (mins * mmCoreSecondsMinute);
                var ss = (secs == 1)  ? translations['mm.core.sec']  : translations['mm.core.secs'];
                var sm = (mins == 1)  ? translations['mm.core.min']  : translations['mm.core.mins'];
                var sh = (hours == 1) ? translations['mm.core.hour'] : translations['mm.core.hours'];
                var sd = (days == 1)  ? translations['mm.core.day']  : translations['mm.core.days'];
                var sy = (years == 1) ? translations['mm.core.year'] : translations['mm.core.years'];
                var oyears = '',
                    odays = '',
                    ohours = '',
                    omins = '',
                    osecs = '';
                if (years) {
                    oyears  = years + ' ' + sy;
                }
                if (days) {
                    odays  = days + ' ' + sd;
                }
                if (hours) {
                    ohours = hours + ' ' + sh;
                }
                if (mins) {
                    omins  = mins + ' ' + sm;
                }
                if (secs) {
                    osecs  = secs + ' ' + ss;
                }
                if (years) {
                    return oyears + ' ' + odays;
                }
                if (days) {
                    return odays + ' ' + ohours;
                }
                if (hours) {
                    return ohours + ' ' + omins;
                }
                if (mins) {
                    return omins + ' ' + osecs;
                }
                if (secs) {
                    return osecs;
                }
                return translations['mm.core.now'];
            });
        };
                self.formatDuration = function(duration, precission) {
            eventDuration = moment.duration(duration, 'seconds');
            if (!precission) {
                precission = 5;
            }
            durationString = "";
            if (precission && eventDuration.years() > 0) {
                durationString += " " + moment.duration(eventDuration.years(), 'years').humanize();
                precission--;
            }
            if (precission && eventDuration.months() > 0) {
                durationString += " " + moment.duration(eventDuration.months(), 'months').humanize();
                precission--;
            }
            if (precission && eventDuration.days() > 0) {
                durationString += " " + moment.duration(eventDuration.days(), 'days').humanize();
                precission--;
            }
            if (precission && eventDuration.hours() > 0) {
                durationString += " " + moment.duration(eventDuration.hours(), 'hours').humanize();
                precission--;
            }
            if (precission && eventDuration.minutes() > 0) {
                durationString += " " + moment.duration(eventDuration.minutes(), 'minutes').humanize();
                precission--;
            }
            return durationString.trim();
        };
                self.formatTree = function(list, parentFieldName, idFieldName, rootParentId, maxDepth) {
            var map = {},
                mapDepth = {},
                parent, id,
                tree = [];
            parentFieldName = parentFieldName || 'parent';
            idFieldName = idFieldName || 'id';
            rootParentId = rootParentId || 0;
            maxDepth = maxDepth || 5;
            angular.forEach(list, function(node, index) {
                id = node[idFieldName];
                parent = node[parentFieldName];
                node.children = [];
                map[id] = index;
                if (parent != rootParentId) {
                    var parentNode = list[map[parent]];
                    if (parentNode) {
                        if (mapDepth[parent] == maxDepth) {
                            var parentOfParent = parentNode[parentFieldName];
                            if (parentOfParent) {
                                list[map[parentOfParent]].children.push(node);
                                mapDepth[id] = mapDepth[parent];
                                node.parent = parentOfParent;
                            }
                        } else {
                            parentNode.children.push(node);
                            mapDepth[id] = mapDepth[parent] + 1;
                        }
                    }
                } else {
                    tree.push(node);
                    mapDepth[id] = 1;
                }
            });
            return tree;
        };
                self.emptyArray = function(array) {
            array.length = 0;
        };
                self.emptyObject = function(object) {
            for (var key in object) {
                if (object.hasOwnProperty(key)) {
                    delete object[key];
                }
            }
        };
                self.allPromises = function(promises) {
            if (!promises || !promises.length) {
                return $q.when();
            }
            var count = 0,
                failed = false,
                deferred = $q.defer();
            angular.forEach(promises, function(promise) {
                promise.catch(function() {
                    failed = true;
                }).finally(function() {
                    count++;
                    if (count === promises.length) {
                        if (failed) {
                            deferred.reject();
                        } else {
                            deferred.resolve();
                        }
                    }
                });
            });
            return deferred.promise;
        };
                self.promiseWorks = function(promise) {
            return promise.then(function() {
                return true;
            }).catch(function() {
                return false;
            });
        };
                self.promiseFails = function(promise) {
            return promise.then(function() {
                return false;
            }).catch(function() {
                return true;
            });
        };
                self.basicLeftCompare = function(itemA, itemB, maxLevels, level, undefinedIsNull) {
            level = level || 0;
            maxLevels = maxLevels || 0;
            undefinedIsNull = typeof undefinedIsNull == 'undefined' ? true : undefinedIsNull;
            if (angular.isFunction(itemA) || angular.isFunction(itemB)) {
                return true;
            } else if (angular.isObject(itemA) && angular.isObject(itemB)) {
                if (level >= maxLevels) {
                    return true;
                }
                var equal = true;
                angular.forEach(itemA, function(value, name) {
                    if (!self.basicLeftCompare(value, itemB[name], maxLevels, level + 1)) {
                        equal = false;
                    }
                });
                return equal;
            } else {
                if (undefinedIsNull && (
                        (typeof itemA == 'undefined' && itemB === null) || (itemA === null && typeof itemB == 'undefined'))) {
                    return true;
                }
                var floatA = parseFloat(itemA),
                    floatB = parseFloat(itemB);
                if (!isNaN(floatA) && !isNaN(floatB)) {
                    return floatA == floatB;
                }
                return itemA === itemB;
            }
        };
                self.confirmDownloadSize = function(sizeCalc, message, unknownsizemessage, wifiThreshold, limitedThreshold) {
            wifiThreshold = typeof wifiThreshold == 'undefined' ? mmCoreWifiDownloadThreshold : wifiThreshold;
            limitedThreshold = typeof limitedThreshold == 'undefined' ? mmCoreDownloadThreshold : limitedThreshold;
            if (typeof sizeCalc == 'number') {
                sizeCalc = {size: sizeCalc, total: false};
            }
            if (sizeCalc.size < 0 || (sizeCalc.size == 0 && !sizeCalc.total)) {
                unknownsizemessage = unknownsizemessage || 'mm.course.confirmdownloadunknownsize';
                return self.showConfirm($translate(unknownsizemessage));
            } else if (!sizeCalc.total) {
                var readableSize = $mmText.bytesToSize(sizeCalc.size, 2);
                return self.showConfirm($translate('mm.course.confirmpartialdownloadsize', {size: readableSize}));
            } else if (sizeCalc.size >= wifiThreshold || ($mmApp.isNetworkAccessLimited() && sizeCalc.size >= limitedThreshold)) {
                message = message || 'mm.course.confirmdownload';
                var readableSize = $mmText.bytesToSize(sizeCalc.size, 2);
                return self.showConfirm($translate(message, {size: readableSize}));
            }
            return $q.when();
        };
                self.sumFileSizes = function(files) {
            var results = {
                size: 0,
                total: true
            };
            angular.forEach(files, function(file) {
                if (typeof file.filesize == 'undefined') {
                    results.total = false;
                } else {
                    results.size += file.filesize;
                }
            });
            return results;
        };
                self.formatPixelsSize = function(size) {
            if (typeof size == 'string' && (size.indexOf('px') > -1 || size.indexOf('%') > -1)) {
                return size;
            }
            size = parseInt(size, 10);
            if (!isNaN(size)) {
                return size + 'px';
            }
            return '';
        };
                self.formatFloat = function(float) {
            if (typeof float == "undefined") {
                return '';
            }
            var localeSeparator = $translate.instant('mm.core.decsep');
            float += '';
            return float.replace('.', localeSeparator);
        };
                self.unformatFloat = function(localeFloat) {
            if (typeof localeFloat == "undefined") {
                return false;
            }
            if (localeFloat == null) {
                return "";
            }
            localeFloat += '';
            localeFloat = localeFloat.trim();
            if (localeFloat == "") {
                return "";
            }
            var localeSeparator = $translate.instant('mm.core.decsep');
            localeFloat = localeFloat.replace(' ', '');
            localeFloat = localeFloat.replace(localeSeparator, '.');
            localeFloat = parseFloat(localeFloat);
            if (isNaN(localeFloat)) {
                return false;
            }
            return localeFloat;
        };
                self.param = function(obj) {
            return provider.param(obj);
        };
                self.roundToDecimals = function(number, decimals) {
            if (typeof decimals == 'undefined') {
                decimals = 2;
            }
            var multiplier = Math.pow(10, decimals);
            return Math.round(parseFloat(number) * multiplier) / multiplier;
        };
                self.extractUrlParams = function(url) {
            var regex = /[?&]+([^=&]+)=?([^&]*)?/gi,
                params = {};
            url.replace(regex, function(match, key, value) {
                params[key] = value !== undefined ? value : '';
            });
            return params;
        };
                self.restoreSourcesInHtml = function(html, paths, anchorFn) {
            var div = angular.element('<div>'),
                media;
            div.html(html);
            media = div[0].querySelectorAll('img, video, audio, source, track');
            angular.forEach(media, function(el) {
                var src = paths[$mmText.decodeURIComponent(el.getAttribute('src'))];
                if (typeof src !== 'undefined') {
                    el.setAttribute('src', src);
                }
                if (el.tagName == 'VIDEO' && el.getAttribute('poster')) {
                    src = paths[$mmText.decodeURIComponent(el.getAttribute('poster'))];
                    if (typeof src !== 'undefined') {
                        el.setAttribute('poster', src);
                    }
                }
            });
            angular.forEach(div.find('a'), function(anchor) {
                var href = $mmText.decodeURIComponent(anchor.getAttribute('href')),
                    url = paths[href];
                if (typeof url !== 'undefined') {
                    anchor.setAttribute('href', url);
                    if (angular.isFunction(anchorFn)) {
                        anchorFn(anchor, href);
                    }
                }
            });
            return div.html();
        };
                self.scrollToElement = function(container, selector, scrollDelegate, scrollParentClass) {
            var position;
            if (!scrollDelegate) {
                scrollDelegate = $ionicScrollDelegate;
            }
            position = self.getElementXY(container, selector, scrollParentClass);
            if (!position) {
                return false;
            }
            scrollDelegate.scrollTo(position[0], position[1]);
            return true;
        };
                self.scrollToInputError = function(container, scrollDelegate, scrollParentClass) {
            return $timeout(function() {
                if (!scrollDelegate) {
                    scrollDelegate = $ionicScrollDelegate;
                }
                scrollDelegate.resize();
                return self.scrollToElement(container, '.mm-input-has-errors', scrollDelegate, scrollParentClass);
            }, 100);
        };
                self.getElementXY = function(container, selector, positionParentClass) {
            var element = selector ? container.querySelector(selector) : container,
                offsetElement,
                positionTop = 0,
                positionLeft = 0;
            if (!positionParentClass) {
                positionParentClass = 'scroll-content';
            }
            if (!element) {
                return false;
            }
            while (element) {
                positionLeft += (element.offsetLeft - element.scrollLeft + element.clientLeft);
                positionTop += (element.offsetTop - element.scrollTop + element.clientTop);
                offsetElement = element.offsetParent;
                element = element.parentElement;
                while (offsetElement != element && element) {
                    if (angular.element(element).hasClass(positionParentClass)) {
                        element = false;
                    } else {
                        element = element.parentElement;
                    }
                }
                if (angular.element(element).hasClass(positionParentClass)) {
                    element = false;
                }
            }
            return [positionLeft, positionTop];
        };
                self.extractUrlsFromCSS = function(code) {
            var urls = [],
                matches = code.match(/url\(\s*["']?(?!data:)([^)]+)\)/igm);
            angular.forEach(matches, function(match) {
                var submatches = match.match(/url\(\s*['"]?([^'"]*)['"]?\s*\)/im);
                if (submatches && submatches[1]) {
                    urls.push(submatches[1]);
                }
            });
            return urls;
        };
                self.getContentsOfElement = function(element, selector) {
            if (element) {
                var el = element[0] || element,
                    selected = el.querySelector(selector);
                if (selected) {
                    return selected.innerHTML;
                }
            }
        };
                self.removeElement = function(element, selector) {
            if (element) {
                var el = element[0] || element,
                    selected = el.querySelector(selector);
                if (selected) {
                    angular.element(selected).remove();
                }
            }
        };
                self.removeElementFromHtml = function(html, selector, removeAll) {
            var div = document.createElement('div'),
                selected;
            div.innerHTML = html;
            if (removeAll) {
                selected = div.querySelectorAll(selector);
                angular.forEach(selected, function(el) {
                    angular.element(el).remove();
                });
            } else {
                selected = div.querySelector(selector);
                if (selected) {
                    angular.element(selected).remove();
                }
            }
            return div.innerHTML;
        };
                self.replaceClassesInElement = function(element, map) {
            element = element[0] || element;
            angular.forEach(map, function(newValue, toReplace) {
                var matches = element.querySelectorAll('.' + toReplace);
                angular.forEach(matches, function(element) {
                    element.className = element.className.replace(toReplace, newValue);
                });
            });
        };
                self.closest = function(element, selector) {
            if (typeof element.closest == 'function') {
                return element.closest(selector);
            }
            if (!matchesFn) {
                ['matches','webkitMatchesSelector','mozMatchesSelector','msMatchesSelector','oMatchesSelector'].some(function(fn) {
                    if (typeof document.body[fn] == 'function') {
                        matchesFn = fn;
                        return true;
                    }
                    return false;
                });
                if (!matchesFn) {
                    return;
                }
            }
            while (element) {
                if (element[matchesFn](selector)) {
                    return element;
                }
                element = element.parentElement;
            }
        };
                self.extractDownloadableFilesFromHtml = function(html) {
            var div = document.createElement('div'),
                elements,
                urls = [];
            div.innerHTML = html;
            elements = div.querySelectorAll('a, img, audio, video, source, track');
            angular.forEach(elements, function(element) {
                var url = element.tagName === 'A' ? element.href : element.src;
                if (url && self.isDownloadableUrl(url) && urls.indexOf(url) == -1) {
                    urls.push(url);
                }
                if (element.tagName == 'VIDEO' && element.getAttribute('poster')) {
                    url = element.getAttribute('poster');
                    if (url && self.isDownloadableUrl(url) && urls.indexOf(url) == -1) {
                        urls.push(url);
                    }
                }
            });
            return urls;
        };
                self.extractDownloadableFilesFromHtmlAsFakeFileObjects = function(html) {
            var urls = self.extractDownloadableFilesFromHtml(html);
            return urls.map(function(url) {
                return {
                    fileurl: url
                };
            });
        };
                self.objectToArrayOfObjects = function(obj, keyName, valueName, sort) {
            var keys = Object.keys(obj);
            if (sort) {
                keys = keys.sort();
            }
            return keys.map(function(key) {
                var entry = {};
                entry[keyName] = key;
                entry[valueName] = obj[key];
                return entry;
            });
        };
                self.objectToArray = function(obj) {
            return Object.keys(obj).map(function(key) {
                return obj[key];
            });
        };
                self.sameAtKeyMissingIsBlank = function(obj1, obj2, key) {
            var value1 = typeof obj1[key] != 'undefined' ? obj1[key] : '',
                value2 = typeof obj2[key] != 'undefined' ? obj2[key] : '';
            if (typeof value1 == 'number' || typeof value1 == 'boolean') {
                value1 = '' + value1;
            }
            if (typeof value2 == 'number' || typeof value2 == 'boolean') {
                value2 = '' + value2;
            }
            return value1 === value2;
        };
                self.mergeArraysWithoutDuplicates = function(array1, array2) {
            return self.uniqueArray(array1.concat(array2));
        };
                self.uniqueArray = function(array) {
            var unique = [],
                len = array.length;
            for (var i = 0; i < len; i++) {
                var value = array[i];
                if (unique.indexOf(value) == -1) {
                    unique.push(value);
                }
            }
            return unique;
        };
                self.isWebServiceError = function(error) {
            var localErrors = [
                $translate.instant('mm.core.wsfunctionnotavailable'),
                $translate.instant('mm.core.lostconnection'),
                $translate.instant('mm.core.userdeleted'),
                $translate.instant('mm.core.unexpectederror'),
                $translate.instant('mm.core.networkerrormsg'),
                $translate.instant('mm.core.serverconnection'),
                $translate.instant('mm.core.errorinvalidresponse'),
                $translate.instant('mm.core.sitemaintenance'),
                $translate.instant('mm.core.upgraderunning'),
                $translate.instant('mm.core.nopasswordchangeforced'),
                $translate.instant('mm.core.unicodenotsupported')
            ];
            return error && localErrors.indexOf(error) == -1;
        };
                self.focusElement = function(el) {
            if (el && el.focus) {
                el.focus();
                if (ionic.Platform.isAndroid() && self.supportsInputKeyboard(el)) {
                    $mmApp.openKeyboard();
                }
            }
        };
                self.supportsInputKeyboard = function(el) {
            return el && !el.disabled && (el.tagName.toLowerCase() == 'textarea' ||
                (el.tagName.toLowerCase() == 'input' && inputSupportKeyboard.indexOf(el.type) != -1));
        };
                self.isRichTextEditorSupported = function() {
            if (!ionic.Platform.isIOS() && !ionic.Platform.isAndroid()) {
                return true;
            }
            if (ionic.Platform.isAndroid() && ionic.Platform.version() >= 4.4) {
                return true;
            }
            return false;
        };
                self.isRichTextEditorEnabled = function() {
            if (self.isRichTextEditorSupported()) {
                return $mmConfig.get(mmCoreSettingsRichTextEditor, true);
            }
            return $q.when(false);
        };
                self.hasRepeatedFilenames = function(files) {
            if (!files || !files.length) {
                return false;
            }
            var names = [];
            for (var i = 0; i < files.length; i++) {
                var name = files[i].filename || files[i].name;
                if (names.indexOf(name) > -1) {
                    return $translate.instant('mm.core.filenameexist', {$a: name});
                } else {
                    names.push(name);
                }
            }
            return false;
        };
                self.blockLeaveView = function(scope, canLeaveFn, currentView) {
            currentView = currentView || $ionicHistory.currentView();
            var unregisterHardwareBack,
                leaving = false,
                hasSplitView = $ionicPlatform.isTablet() && $state.current.name.split('.').length == 3,
                skipSplitViewLeave = false;
            $rootScope.$ionicGoBack = goBack;
            unregisterHardwareBack = $ionicPlatform.registerBackButtonAction(goBack, 101);
            backFunctionsStack.push(goBack);
            if (hasSplitView) {
                blockSplitView(true);
            }
            scope.$on('$destroy', unblock);
            return {
                back: originalBackFunction,
                unblock: unblock
            };
            function goBack() {
                if ($ionicHistory.currentView() !== currentView) {
                    originalBackFunction();
                    return;
                }
                if (leaving) {
                    return;
                }
                leaving = true;
                canLeaveFn().then(function() {
                    skipSplitViewLeave = hasSplitView;
                    originalBackFunction();
                }).finally(function() {
                    leaving = false;
                });
            }
            function leaveViewInSplitView() {
                if (skipSplitViewLeave) {
                    skipSplitViewLeave = false;
                    return $q.when();
                }
                return canLeaveFn();
            }
            function unblock() {
                unregisterHardwareBack();
                if (hasSplitView) {
                    blockSplitView(false);
                }
                var position = backFunctionsStack.indexOf(goBack);
                if (position > -1) {
                    backFunctionsStack.splice(position, 1);
                }
                if ($rootScope.$ionicGoBack === goBack) {
                    if (!backFunctionsStack.length) {
                        backFunctionsStack = [originalBackFunction];
                        $rootScope.$ionicGoBack = originalBackFunction;
                    } else {
                        $rootScope.$ionicGoBack = backFunctionsStack[backFunctionsStack.length - 1];
                    }
                }
            }
            function blockSplitView(block) {
                $rootScope.$broadcast(mmCoreSplitViewBlock, {
                    block: block,
                    blockFunction: leaveViewInSplitView,
                    state: currentView.stateName,
                    stateParams: currentView.stateParams
                });
            }
        };
                self.isElementOutsideOfScreen = function(element, scrollSelector) {
            scrollSelector = scrollSelector || '.scroll-content';
            var elementRect = element.getBoundingClientRect(),
                elementMidPoint,
                scrollEl = self.closest(element, scrollSelector),
                scrollElRect,
                scrollTopPos = 0;
            if (!elementRect) {
                return false;
            }
            elementMidPoint = Math.round((elementRect.bottom + elementRect.top) / 2);
            if (scrollEl) {
                scrollElRect = scrollEl.getBoundingClientRect();
                scrollTopPos = (scrollElRect && scrollElRect.top) || 0;
            }
            return elementMidPoint > $window.innerHeight || elementMidPoint < scrollTopPos;
        };
                self.copyProperties = function(from, to) {
            angular.forEach(from, function(value, name) {
                to[name] = angular.copy(value);
            });
        };
                self.filterEnabledSites = function(siteIds, isEnabledFn, checkAll) {
            var promises = [],
                enabledSites = [],
                extraParams = Array.prototype.slice.call(arguments, 3);
            angular.forEach(siteIds, function(siteId) {
                if (checkAll || !promises.length) {
                    promises.push($q.when(isEnabledFn.apply(isEnabledFn, [siteId].concat(extraParams))).then(function(enabled) {
                        if (enabled) {
                            enabledSites.push(siteId);
                        }
                    }));
                }
            });
            return self.allPromises(promises).catch(function() {
            }).then(function() {
                if (!checkAll) {
                    return enabledSites.length ? siteIds : [];
                } else {
                    return enabledSites;
                }
            });
        };
                self.getElementHeight = function(element, usePadding, useMargin, useBorder, innerMeasure) {
            var measure = element.offsetHeight || element.height || element.clientHeight || 0;
            if (measure <= 0) {
                var angElement = angular.element(element);
                if (angElement.css('display') == '') {
                    angElement.css('display', 'inline-block');
                    measure = element.offsetHeight || element.height || element.clientHeight || 0;
                    angElement.css('display', '');
                }
            }
            if (usePadding || useMargin || useBorder) {
                var surround = 0,
                    cs = getComputedStyle(element);
                if (usePadding) {
                    surround += parseInt(cs.paddingTop, 10) + parseInt(cs.paddingBottom, 10);
                }
                if (useMargin) {
                    surround += parseInt(cs.marginTop, 10) + parseInt(cs.marginBottom, 10);
                }
                if (useBorder) {
                    surround += parseInt(cs.borderTop, 10) + parseInt(cs.borderBottom, 10);
                }
                if (innerMeasure) {
                    measure = measure > surround ? measure - surround : 0;
                } else {
                    measure += surround;
                }
            }
            return measure;
        };
                self.getElementWidth = function(element, usePadding, useMargin, useBorder, innerMeasure) {
            var measure = element.offsetWidth || element.width || element.clientWidth || 0;
            if (measure <= 0) {
                var angElement = angular.element(element);
                if (angElement.css('display') == '') {
                    angElement.css('display', 'inline-block');
                    measure = element.offsetWidth || element.width || element.clientWidth || 0;
                    angElement.css('display', '');
                }
            }
            if (usePadding || useMargin || useBorder) {
                var surround = 0,
                    cs = getComputedStyle(element);
                if (usePadding) {
                    surround += parseInt(cs.paddingLeft, 10) + parseInt(cs.paddingRight, 10);
                }
                if (useMargin) {
                    surround += parseInt(cs.marginLeft, 10) + parseInt(cs.marginRight, 10);
                }
                if (useBorder) {
                    surround += parseInt(cs.borderLeft, 10) + parseInt(cs.borderRight, 10);
                }
                if (innerMeasure) {
                    measure = measure > surround ? measure - surround : 0;
                } else {
                    measure += surround;
                }
            }
            return measure;
        };
        return self;
    }];
}]);

angular.module('mm.core')
.factory('$mmWebWorkers', ["$injector", "$q", "$log", "$window", "md5", function($injector, $q, $log, $window, md5) {
    $log = $log.getInstance('$mmWebWorkers');
    var self = {},
        workers = {};
        function createWorker(name, path) {
        try {
            if (typeof workers[name] == 'undefined') {
                workers[name] = {
                    path: path,
                    worker: new Worker(path)
                };
            } else {
                $log.warn('There\'s already a worker with this name: ' + name);
            }
            return true;
        } catch(ex) {
            return false;
        }
    }
        self.isSupportedByDevice = function() {
        return !!$window.Worker && !!$window.URL;
    };
        self.isSupportedInSite = function(site) {
        if (!site) {
            site = $injector.get('$mmSite');
            if (!site || !site.isLoggedIn()) {
                return false;
            }
        }
        return site.isVersionGreaterEqualThan('2.8');
    };
        self.startWorker = function(name, path, params) {
        if (typeof workers[name] == 'undefined') {
            if (!createWorker(name, path)) {
                return $q.reject();
            }
        } else if (workers[name].path != path) {
            $log.warn('The path of the worker to call doesn\t match the path passed as parameter: ', name, path);
            return $q.reject();
        }
        var deferred = $q.defer(),
            id = md5.createHash(JSON.stringify(params)),
            worker = workers[name].worker;
        worker.addEventListener('message', onMessage, false);
        worker.addEventListener('error', onError, false);
        params.workerId = id;
        worker.postMessage(params);
        return deferred.promise;
        function onMessage(e) {
            if (e && e.data) {
                if (e.data.workerId == id) {
                    delete e.data.workerId;
                    if (e.data.notify) {
                        deferred.notify(e.data);
                    } else {
                        worker.removeEventListener('message', onMessage, false);
                        worker.removeEventListener('error', onError, false);
                        deferred.resolve(e.data);
                    }
                }
            } else {
                deferred.reject();
            }
        }
        function onError() {
            worker.removeEventListener('message', onMessage, false);
            worker.removeEventListener('error', onError, false);
            delete workers[name];
            deferred.reject();
        }
    };
    return self;
}]);

angular.module('mm.core')
.constant('mmWSTimeout', 30000)
.factory('$mmWS', ["$http", "$q", "$log", "$mmLang", "$cordovaFileTransfer", "$mmApp", "$mmFS", "mmCoreSessionExpired", "$translate", "$window", "mmCoreUserDeleted", "md5", "$timeout", "mmWSTimeout", "mmCoreUserPasswordChangeForced", "mmCoreUserNotFullySetup", "$mmText", "mmCoreSitePolicyNotAgreed", "mmCoreUnicodeNotSupported", function($http, $q, $log, $mmLang, $cordovaFileTransfer, $mmApp, $mmFS, mmCoreSessionExpired, $translate, $window,
            mmCoreUserDeleted, md5, $timeout, mmWSTimeout, mmCoreUserPasswordChangeForced, mmCoreUserNotFullySetup, $mmText,
            mmCoreSitePolicyNotAgreed, mmCoreUnicodeNotSupported) {
    $log = $log.getInstance('$mmWS');
    var self = {},
        mimeTypeCache = {},
        ongoingCalls = {},
        retryCalls = [],
        retryTimeout = 0;
        self.call = function(method, data, preSets) {
        var siteurl;
        if (typeof preSets == 'undefined' || preSets === null ||
                typeof preSets.wstoken == 'undefined' || typeof preSets.siteurl == 'undefined') {
            return $mmLang.translateAndReject('mm.core.unexpectederror');
        } else if (!$mmApp.isOnline()) {
            return $mmLang.translateAndReject('mm.core.networkerrormsg');
        }
        preSets.typeExpected = preSets.typeExpected || 'object';
        if (typeof preSets.responseExpected == 'undefined') {
            preSets.responseExpected = true;
        }
        try {
            data = convertValuesToString(data, preSets.cleanUnicode);
        } catch (e) {
           return $mmLang.translateAndReject('mm.core.unicodenotsupportedcleanerror');
        }
        data.wsfunction = method;
        data.wstoken = preSets.wstoken;
        siteurl = preSets.siteurl + '/webservice/rest/server.php?moodlewsrestformat=json';
        var ajaxData = data;
        var promise = getPromiseHttp('post', preSets.siteurl, ajaxData);
        if (!promise) {
            if (retryCalls.length > 0) {
                $log.warn('Calls locked, trying later...');
                promise = addToRetryQueue(method, siteurl, ajaxData, preSets);
            } else {
                promise = performPost(method, siteurl, ajaxData, preSets);
            }
        }
        return promise;
    };
        function performPost(method, siteurl, ajaxData, preSets) {
        var promise = $http.post(siteurl, ajaxData, {timeout: mmWSTimeout}).then(function(data) {
            if ((!data || !data.data) && !preSets.responseExpected) {
                data = {};
            } else {
                data = data.data;
            }
            if (!data) {
                return $mmLang.translateAndReject('mm.core.serverconnection');
            } else if (typeof data != preSets.typeExpected) {
                $log.warn('Response of type "' + typeof data + '" received, expecting "' + preSets.typeExpected + '"');
                return $mmLang.translateAndReject('mm.core.errorinvalidresponse');
            }
            if (typeof(data.exception) !== 'undefined') {
                if (data.errorcode == 'invalidtoken' ||
                        (data.errorcode == 'accessexception' && data.message.indexOf('Invalid token - token expired') > -1)) {
                    $log.error("Critical error: " + JSON.stringify(data));
                    return $q.reject(mmCoreSessionExpired);
                } else if (data.errorcode === 'userdeleted') {
                    return $q.reject(mmCoreUserDeleted);
                } else if (data.errorcode === 'sitemaintenance' || data.errorcode === 'upgraderunning') {
                    return $mmLang.translateAndReject('mm.core.' + data.errorcode);
                } else if (data.errorcode === 'forcepasswordchangenotice') {
                    return $q.reject(mmCoreUserPasswordChangeForced);
                } else if (data.errorcode === 'usernotfullysetup') {
                    return $q.reject(mmCoreUserNotFullySetup);
                } else if (data.errorcode === 'sitepolicynotagreed') {
                    return $q.reject(mmCoreSitePolicyNotAgreed);
                } else if (data.errorcode === 'dmlwriteexception' && $mmText.hasUnicodeData(ajaxData)) {
                    return $q.reject(mmCoreUnicodeNotSupported);
                } else {
                    return $q.reject(data.message);
                }
            }
            if (typeof(data.debuginfo) != 'undefined') {
                return $q.reject('Error. ' + data.message);
            }
            $log.info('WS: Data received from WS ' + typeof(data));
            if (typeof(data) == 'object' && typeof(data.length) != 'undefined') {
                $log.info('WS: Data number of elements '+ data.length);
            }
            return data;
        }, function(data) {
            if (data.status == 429) {
                var retryPromise = addToRetryQueue(method, siteurl, ajaxData, preSets);
                if (retryTimeout == 0) {
                    retryTimeout = parseInt(data.headers('Retry-After'), 10) || 5;
                    $log.warn(data.statusText + '. Retrying in ' + retryTimeout + ' seconds. ' + retryCalls.length + ' calls left.');
                    $timeout(function() {
                        $log.warn('Retrying now with ' + retryCalls.length + ' calls to process.');
                        retryTimeout = 0;
                        processRetryQueue();
                    }, retryTimeout * 1000);
                } else {
                    $log.warn('Calls locked, trying later...');
                }
                return retryPromise;
            }
            return $mmLang.translateAndReject('mm.core.serverconnection');
        });
        setPromiseHttp(promise, 'post', preSets.siteurl, ajaxData);
        return promise;
    }
        function processRetryQueue() {
        if (retryCalls.length > 0 && retryTimeout == 0) {
            var call = retryCalls.shift();
            $timeout(function() {
                call.deferred.resolve(performPost(call.method, call.siteurl, call.ajaxData, call.preSets));
                processRetryQueue();
            }, 200);
        } else {
            $log.warn('Retry queue has stopped with ' + retryCalls.length + ' calls and ' + retryTimeout + ' timeout seconds.');
        }
    }
        function addToRetryQueue(method, siteurl, ajaxData, preSets) {
        var call = {
            method: method,
            siteurl: siteurl,
            ajaxData: ajaxData,
            preSets: preSets,
            deferred: $q.defer()
        };
        retryCalls.push(call);
        return call.deferred.promise;
    }
        function setPromiseHttp(promise, method, url, params) {
        var deletePromise,
            queueItemId = getQueueItemId(method, url, params);
        ongoingCalls[queueItemId] = promise;
        deletePromise = $timeout(function() {
            delete ongoingCalls[queueItemId];
        }, mmWSTimeout);
        ongoingCalls[queueItemId].finally(function() {
            delete ongoingCalls[queueItemId];
            $timeout.cancel(deletePromise);
        });
    }
        function getPromiseHttp(method, url, params) {
        var queueItemId = getQueueItemId(method, url, params);
        if (typeof ongoingCalls[queueItemId] != 'undefined') {
            return ongoingCalls[queueItemId];
        }
        return false;
    }
        function getQueueItemId(method, url, params) {
        if (params) {
            url += '###' + serializeParams(params);
        }
        return method + '#' + md5.createHash(url);
    }
        function convertValuesToString(data, stripUnicode) {
        var result = [];
        if (!angular.isArray(data) && angular.isObject(data)) {
            result = {};
        }
        for (var el in data) {
            if (angular.isObject(data[el])) {
                result[el] = convertValuesToString(data[el], stripUnicode);
            } else {
                if (typeof data[el] == "string") {
                    result[el] = stripUnicode ? $mmText.stripUnicode(data[el]) : data[el];
                    if (stripUnicode && data[el] != result[el] && result[el].trim().length == 0) {
                        throw new Exception();
                    }
                } else {
                    result[el] = data[el] + '';
                }
            }
        }
        return result;
    }
        self.downloadFile = function(url, path, addExtension) {
        $log.debug('Downloading file ' + url, path, addExtension);
        var tmpPath = path + '.tmp';
        return $mmFS.createFile(tmpPath).then(function(fileEntry) {
            return $cordovaFileTransfer.download(url, fileEntry.toURL(), { encodeURI: false }, true).then(function() {
                var promise;
                if (addExtension) {
                    ext = $mmFS.getFileExtension(path);
                    if (!ext) {
                        promise = self.getRemoteFileMimeType(url).then(function(mime) {
                            var ext;
                            if (mime) {
                                ext = $mmFS.getExtension(mime, url);
                                if (ext) {
                                    path += '.' + ext;
                                }
                                return ext;
                            }
                            return false;
                        });
                    } else {
                        promise = $q.when(ext);
                    }
                } else {
                    promise = $q.when("");
                }
                return promise.then(function(extension) {
                    return $mmFS.moveFile(tmpPath, path).then(function(movedEntry) {
                        movedEntry.extension = extension;
                        movedEntry.path = path;
                        $log.debug('Success downloading file ' + url + ' to ' + path + ' with extension ' + extension);
                        return movedEntry;
                    });
                });
            });
        }).catch(function(err) {
            $log.error('Error downloading ' + url + ' to ' + path);
            $log.error(JSON.stringify(err));
            return $q.reject(err);
        });
    };
        self.uploadFile = function(uri, options, preSets) {
        $log.debug('Trying to upload file: ' + uri);
        if (!uri || !options || !preSets) {
            return $q.reject();
        }
        var ftOptions = {},
            uploadUrl = preSets.siteurl + '/webservice/upload.php';
        ftOptions.fileKey = options.fileKey;
        ftOptions.fileName = options.fileName;
        ftOptions.httpMethod = 'POST';
        ftOptions.mimeType = options.mimeType;
        ftOptions.params = {
            token: preSets.token,
            filearea: options.fileArea || 'draft',
            itemid: options.itemId || 0
        };
        ftOptions.chunkedMode = false;
        ftOptions.headers = {
            Connection: "close"
        };
        $log.debug('Initializing upload');
        return $cordovaFileTransfer.upload(uploadUrl, uri, ftOptions, true).then(function(success) {
            var data = success.response;
            try {
                data = JSON.parse(data);
            } catch(err) {
                $log.error('Error parsing response:', err, data);
                return $mmLang.translateAndReject('mm.core.errorinvalidresponse');
            }
            if (!data) {
                return $mmLang.translateAndReject('mm.core.serverconnection');
            } else if (typeof data != 'object') {
                $log.warn('Upload file: Response of type "' + typeof data + '" received, expecting "object"');
                return $mmLang.translateAndReject('mm.core.errorinvalidresponse');
            }
            if (typeof data.exception !== 'undefined') {
                return $q.reject(data.message);
            } else if (data && typeof data.error !== 'undefined') {
                return $q.reject(data.error);
            } else if (data[0] && typeof data[0].error !== 'undefined') {
                return $q.reject(data[0].error);
            }
            $log.debug('Successfully uploaded file');
            return data[0];
        }, function(error) {
            $log.error('Error while uploading file', error.exception);
            return $mmLang.translateAndReject('mm.core.serverconnection');
        });
    };
        self.getRemoteFileSize = function(url) {
        var promise = getPromiseHttp('head', url);
        if (!promise) {
            promise = $http.head(url, {timeout: mmWSTimeout}).then(function(data) {
                var size = parseInt(data.headers('Content-Length'), 10);
                if (size) {
                    return size;
                }
                return -1;
            }).catch(function() {
                return -1;
            });
            setPromiseHttp(promise, 'head', url);
        }
        return promise;
    };
        self.getRemoteFileMimeType = function(url, ignoreCache) {
        if (mimeTypeCache[url] && !ignoreCache) {
            return $q.when(mimeTypeCache[url]);
        }
        var promise = getPromiseHttp('head', url);
        if (!promise) {
            promise = $http.head(url, {timeout: mmWSTimeout}).then(function(data) {
                var mimeType = data.headers('Content-Type');
                if (mimeType) {
                    mimeType = mimeType.split(';')[0];
                }
                mimeTypeCache[url] = mimeType;
                return mimeType || '';
            }).catch(function() {
                return '';
            });
            setPromiseHttp(promise, 'head', url);
        }
        return promise;
    };
        self.syncCall = function(method, data, preSets) {
        var siteurl,
            xhr,
            errorResponse = {
                error: true,
                message: ''
            };
        data = convertValuesToString(data);
        if (typeof preSets == 'undefined' || preSets === null ||
                typeof preSets.wstoken == 'undefined' || typeof preSets.siteurl == 'undefined') {
            errorResponse.message = $translate.instant('mm.core.unexpectederror');
            return errorResponse;
        } else if (!$mmApp.isOnline()) {
            errorResponse.message = $translate.instant('mm.core.networkerrormsg');
            return errorResponse;
        }
        preSets.typeExpected = preSets.typeExpected || 'object';
        if (typeof preSets.responseExpected == 'undefined') {
            preSets.responseExpected = true;
        }
        data.wsfunction = method;
        data.wstoken = preSets.wstoken;
        siteurl = preSets.siteurl + '/webservice/rest/server.php?moodlewsrestformat=json';
        data = serializeParams(data);
        xhr = new $window.XMLHttpRequest();
        xhr.open('post', siteurl, false);
        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded;charset=utf-8');
        xhr.send(data);
        data = ('response' in xhr) ? xhr.response : xhr.responseText;
        xhr.status = Math.max(xhr.status === 1223 ? 204 : xhr.status, 0);
        if (xhr.status < 200 || xhr.status >= 300) {
            errorResponse.message = data;
            return errorResponse;
        }
        try {
            data = JSON.parse(data);
        } catch(ex) {}
        if ((!data || !data.data) && !preSets.responseExpected) {
            data = {};
        }
        if (!data) {
            errorResponse.message = $translate.instant('mm.core.serverconnection');
        } else if (typeof data != preSets.typeExpected) {
            $log.warn('Response of type "' + typeof data + '" received, expecting "' + preSets.typeExpected + '"');
            errorResponse.message = $translate.instant('mm.core.errorinvalidresponse');
        }
        if (typeof data.exception != 'undefined' || typeof data.debuginfo != 'undefined') {
            errorResponse.message = data.message;
        }
        if (errorResponse.message !== '') {
            return errorResponse;
        }
        $log.info('Synchronous: Data received from WS ' + typeof data);
        if (typeof(data) == 'object' && typeof(data.length) != 'undefined') {
            $log.info('Synchronous: Data number of elements '+ data.length);
        }
        return data;
    };
        function serializeParams(obj) {
        var query = '', name, value, fullSubName, subName, subValue, innerObj, i;
        for (name in obj) {
            value = obj[name];
            if (value instanceof Array) {
                for (i = 0; i < value.length; ++i) {
                    subValue = value[i];
                    fullSubName = name + '[' + i + ']';
                    innerObj = {};
                    innerObj[fullSubName] = subValue;
                    query += serializeParams(innerObj) + '&';
                }
            }
            else if (value instanceof Object) {
                for (subName in value) {
                    subValue = value[subName];
                    fullSubName = name + '[' + subName + ']';
                    innerObj = {};
                    innerObj[fullSubName] = subValue;
                    query += serializeParams(innerObj) + '&';
                }
            }
            else if (value !== undefined && value !== null) query += encodeURIComponent(name) + '=' + encodeURIComponent(value) + '&';
        }
        return query.length ? query.substr(0, query.length - 1) : query;
    }
        self.callAjax = function(method, data, preSets) {
        var siteurl,
            ajaxData;
        if (typeof preSets.siteurl == 'undefined') {
            return rejectWithError($translate.instant('mm.core.unexpectederror'));
        } else if (!$mmApp.isOnline()) {
            return rejectWithError($translate.instant('mm.core.networkerrormsg'));
        }
        if (typeof preSets.responseExpected == 'undefined') {
            preSets.responseExpected = true;
        }
        ajaxData = [{
            index: 0,
            methodname: method,
            args: convertValuesToString(data)
        }];
        siteurl = preSets.siteurl + '/lib/ajax/service.php';
        return $http.post(siteurl, JSON.stringify(ajaxData), {timeout: mmWSTimeout}).then(function(data) {
            if ((!data || !data.data) && !preSets.responseExpected) {
                data = [{}];
            } else {
                data = data.data;
            }
            if (!data || typeof data != 'object') {
                return rejectWithError($translate.instant('mm.core.serverconnection'));
            } else if (data.error) {
                return rejectWithError(data.error, data.errorcode);
            }
            data = data[0];
            if (data.error) {
                return rejectWithError(data.exception.message, data.exception.errorcode);
            }
            return data.data;
        }, function(data) {
            var available = data.status == 404 ? -1 : 0;
            return rejectWithError($translate.instant('mm.core.serverconnection'), '', available);
        });
        function rejectWithError(message, code, available) {
            if (typeof available == 'undefined') {
                if (code) {
                    available = code == 'invalidrecord' ? -1 : 1;
                } else {
                    available = 0;
                }
            }
            return $q.reject({
                error: message,
                errorcode: code,
                available: available
            });
        }
    };
    return self;
}]);

angular.module('mm.core')
.filter('mmBytesToSize', ["$mmText", function($mmText) {
    return function(text) {
        return $mmText.bytesToSize(text);
    };
}]);
angular.module('mm.core')
.filter('mmCreateLinks', function() {
    var replacePattern = /(\b(https?|ftp):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])(?![^<]*>|[^<>]*<\/)/gim;
    return function(text) {
        return text.replace(replacePattern, '<a href="$1">$1</a>');
    };
});
angular.module('mm.core')
.filter('mmDateDayOrTime', ["$translate", function($translate) {
    return function(timestamp) {
        return moment(timestamp * 1000).calendar(null, {
            sameDay: $translate.instant('mm.core.dftimedate'),
            lastDay: $translate.instant('mm.core.dflastweekdate'),
            lastWeek: $translate.instant('mm.core.dflastweekdate')
        });
    };
}]);

angular.module('mm.core')
.filter('mmDuration', function() {
    return function(timestamp) {
        return moment.duration(timestamp * 1000).humanize();
    };
});

angular.module('mm.core')
.filter('mmFormatDate', ["$translate", function($translate) {
    return function(timestamp, format) {
        if (format.indexOf('.') == -1) {
            format = 'mm.core.' + format;
        }
        return moment(timestamp).format($translate.instant(format));
    };
}]);

angular.module('mm.core')
.filter('mmNoTags', function() {
    return function(text) {
        return String(text).replace(/(<([^>]+)>)/ig, '');
    }
});
angular.module('mm.core')
.filter('mmSecondsToHMS', ["$mmText", "mmCoreSecondsHour", "mmCoreSecondsMinute", function($mmText, mmCoreSecondsHour, mmCoreSecondsMinute) {
    return function(seconds) {
        var hours,
            minutes;
        if (typeof seconds == 'undefined' || seconds < 0) {
            seconds = 0;
        }
        hours = Math.floor(seconds / mmCoreSecondsHour);
        seconds -= hours * mmCoreSecondsHour;
        minutes = Math.floor(seconds / mmCoreSecondsMinute);
        seconds -= minutes * mmCoreSecondsMinute;
        return $mmText.twoDigits(hours) + ':' + $mmText.twoDigits(minutes) + ':' + $mmText.twoDigits(seconds);
    };
}]);

angular.module('mm.core')
.filter('mmTimeAgo', function() {
    return function(timestamp) {
        return moment(timestamp * 1000).fromNow(true);
    };
});

angular.module('mm.core')
.filter('mmToLocaleString', function() {
    return function(text) {
        var timestamp = parseInt(text);
        if (isNaN(timestamp) || timestamp < 0) {
            return '';
        }
        if (timestamp < 100000000000) {
            timestamp = timestamp * 1000;
        }
        return new Date(timestamp).toLocaleString();
    };
});

angular.module('mm.core')
.directive('mmAttachments', ["$mmText", "$translate", "$ionicScrollDelegate", "$mmUtil", "$mmApp", "$mmFileUploaderHelper", "$q", function($mmText, $translate, $ionicScrollDelegate, $mmUtil, $mmApp, $mmFileUploaderHelper, $q) {
    return {
        restrict: 'E',
        priority: 100,
        templateUrl: 'core/templates/attachments.html',
        scope: {
            files: '=',
            maxSize: '@?',
            maxSubmissions: '@?',
            component: '@?',
            componentId: '@?',
            allowOffline: '@?'
        },
        link: function(scope) {
            var allowOffline = scope.allowOffline && scope.allowOffline !== 'false';
                maxSize = parseInt(scope.maxSize, 10);
            maxSize = !isNaN(maxSize) && maxSize > 0 ? maxSize : -1;
            if (maxSize == -1) {
                scope.maxSizeReadable = $translate.instant('mm.core.unknown');
            } else {
                scope.maxSizeReadable = $mmText.bytesToSize(maxSize, 2);
            }
            if (typeof scope.maxSubmissions == 'undefined' || scope.maxSubmissions < 0) {
                scope.maxSubmissions = $translate.instant('mm.core.unknown');
                scope.unlimitedFiles = true;
            }
            scope.add = function() {
                if (!allowOffline && !$mmApp.isOnline()) {
                    $mmUtil.showErrorModal('mm.fileuploader.errormustbeonlinetoupload', true);
                } else {
                    return $mmFileUploaderHelper.selectFile(maxSize, allowOffline).then(function(result) {
                        scope.files.push(result);
                    });
                }
            };
            scope.delete = function(index, askConfirm) {
                var promise;
                if (askConfirm) {
                    promise = $mmUtil.showConfirm($translate.instant('mm.core.confirmdeletefile'));
                } else {
                    promise = $q.when();
                }
                promise.then(function() {
                    scope.files.splice(index, 1);
                    $ionicScrollDelegate.resize();
                });
            };
            scope.renamed = function(index, file) {
                scope.files[index] = file;
            };
        }
    };
}]);

angular.module('mm.core')
.directive('mmAutoFocus', ["$mmUtil", function($mmUtil) {
    return {
        restrict: 'A',
        link: function(scope, el, attrs) {
            var unregister = scope.$watch(function() {
                return ionic.transition.isActive;
            }, function(isActive) {
                var showKeyboard = typeof attrs.mmAutoFocus == 'undefined' ||
                    (attrs.mmAutoFocus !== false && attrs.mmAutoFocus !== 'false' && attrs.mmAutoFocus !== '0');
                if (!isActive && showKeyboard) {
                    $mmUtil.focusElement(el[0]);
                    unregister();
                }
            });
        }
    };
}]);

angular.module('mm.core')
.directive('mmAutoRows', ["$mmUtil", function($mmUtil) {
        function calculateRows(element, attrs) {
        var currentRows = parseInt(element.attr('rows'), 10) || 1,
            maxRows = parseInt(attrs.mmMaxRows, 10) || 5,
            computedStyle = getComputedStyle(element[0]),
            padding = (parseInt(computedStyle.paddingBottom, 10) || 0) + (parseInt(computedStyle.paddingTop, 10) || 0),
            height = $mmUtil.getElementHeight(element[0]) - padding,
            scrollHeight,
            rows;
        if (height <= 0) {
            return 1;
        }
        element.css('height', '1px');
        scrollHeight = element[0].scrollHeight;
        rows = Math.ceil((scrollHeight - padding) / (height / currentRows));
        element.css('height', '');
        if (maxRows && rows >= maxRows) {
            return maxRows;
        } else {
            return rows;
        }
    }
    return {
        restrict: 'A',
        link: function(scope, element, attrs) {
            var lastModelChange;
            if (attrs.ngModel) {
                scope.$watch(attrs.ngModel, function(newValue) {
                    if (typeof newValue != 'undefined') {
                        lastModelChange = Date.now();
                        valueChanged();
                    }
                });
            }
            element.on('input propertychange', function() {
                if (lastModelChange && Date.now() - lastModelChange <= 20) {
                    lastModelChange = 0;
                } else {
                    valueChanged();
                }
            });
            function valueChanged() {
                var currentRows = element.attr('rows'),
                    rows = calculateRows(element, attrs);
                if (rows != currentRows) {
                    element.attr('rows', rows);
                }
            }
        }
    };
}]);

angular.module('mm.core')
.directive('mmCompletion', ["$mmSite", "$mmUtil", "$mmText", "$translate", "$q", function($mmSite, $mmUtil, $mmText, $translate, $q) {
    function showStatus(scope) {
        var langKey,
            moduleName = scope.moduleName || '';
        if (scope.completion.tracking === 1 && scope.completion.state === 0) {
            scope.completionImage = 'img/completion/completion-manual-n.svg';
            langKey = 'mm.core.completion-alt-manual-n';
        } else if(scope.completion.tracking === 1 && scope.completion.state === 1) {
            scope.completionImage = 'img/completion/completion-manual-y.svg';
            langKey = 'mm.core.completion-alt-manual-y';
        } else if(scope.completion.tracking === 2 && scope.completion.state === 0) {
            scope.completionImage = 'img/completion/completion-auto-n.svg';
            langKey = 'mm.core.completion-alt-auto-n';
        } else if(scope.completion.tracking === 2 && scope.completion.state === 1) {
            scope.completionImage = 'img/completion/completion-auto-y.svg';
            langKey = 'mm.core.completion-alt-auto-y';
        } else if(scope.completion.tracking === 2 && scope.completion.state === 2) {
            scope.completionImage = 'img/completion/completion-auto-pass.svg';
            langKey = 'mm.core.completion-alt-auto-pass';
        } else if(scope.completion.tracking === 2 && scope.completion.state === 3) {
            scope.completionImage = 'img/completion/completion-auto-fail.svg';
            langKey = 'mm.core.completion-alt-auto-fail';
        }
        if (moduleName) {
            $mmText.formatText(moduleName, true, true, 50).then(function(formatted) {
                $translate(langKey, {$a: formatted}).then(function(translated) {
                    scope.completionDescription = translated;
                });
            });
        }
    }
    return {
        restrict: 'E',
        priority: 100,
        scope: {
            completion: '=',
            afterChange: '=',
            moduleName: '=?'
        },
        templateUrl: 'core/templates/completion.html',
        link: function(scope, element, attrs) {
            if (scope.completion) {
                showStatus(scope);
                element.on('click', function(e) {
                    if (typeof scope.completion.cmid == 'undefined' || scope.completion.tracking !== 1) {
                        return;
                    }
                    e.preventDefault();
                    e.stopPropagation();
                    var modal = $mmUtil.showModalLoading(),
                        params = {
                            cmid: scope.completion.cmid,
                            completed: scope.completion.state === 1 ? 0 : 1
                        };
                    $mmSite.write('core_completion_update_activity_completion_status_manually', params).then(function(response) {
                        if (!response.status) {
                            return $q.reject();
                        }
                        if (angular.isFunction(scope.afterChange)) {
                            scope.afterChange();
                        }
                    }).catch(function(error) {
                        $mmUtil.showErrorModalDefault(error, 'mm.core.errorchangecompletion', true);
                    }).finally(function() {
                        modal.dismiss();
                    });
                });
            }
        }
    };
}]);

angular.module('mm.core')
.controller('mmContextMenu', ["$scope", "$ionicPopover", "$q", "$timeout", function($scope, $ionicPopover, $q, $timeout) {
    var items = $scope.ctxtMenuItems = [];
        this.addContextMenuItem = function(item) {
        if (!item.$$destroyed) {
            items.push(item);
            item.$on('$destroy', function() {
                var index = items.indexOf(item);
                items.splice(index, 1);
            });
        }
    };
        this.shouldMerge = function() {
        return !!($scope.merge && $scope.merge !== 'false');
    };
        $scope.contextMenuItemClicked = function($event, item) {
        if (typeof item.action == 'function') {
            $event.preventDefault();
            $event.stopPropagation();
            if (!item.iconAction || item.iconAction == 'spinner') {
                return false;
            }
            hideContextMenu(item.closeOnClick);
            return $q.when(item.action()).finally(function() {
                if (!item.closeOnClick) {
                    hideContextMenu(item.closeWhenDone);
                }
            });
        } else if (item.href) {
            hideContextMenu(item.closeOnClick);
        }
        return true;
    };
        $scope.showContextMenu = function($event) {
        $scope.contextMenuPopover.show($event);
    };
        function hideContextMenu(close) {
        if (close) {
            $scope.contextMenuPopover.hide();
        }
    }
    $ionicPopover.fromTemplateUrl('core/templates/contextmenu.html', {
        scope: $scope
    }).then(function(popover) {
        $scope.contextMenuPopover = popover;
    });
    $scope.$on('$destroy', function() {
        if ($scope.contextMenuPopover) {
            $scope.contextMenuPopover.remove();
        } else {
            $timeout(function() {
                $scope.contextMenuPopover && $scope.contextMenuPopover.remove();
            }, 200);
        }
    });
}])
.directive('mmContextMenu', ["$translate", function($translate) {
    return {
        restrict: 'E',
        scope: {
            icon: '@?',
            title: '@?',
            merge: '@?'
        },
        transclude: true,
        templateUrl: 'core/templates/contextmenuicon.html',
        controller: 'mmContextMenu',
        link: function(scope, element) {
            scope.contextMenuIcon = scope.icon || 'ion-android-more-vertical';
            scope.contextMenuAria = scope.title || $translate.instant('mm.core.info');
            scope.filterNgShow = function(value) {
                return value && value.ngShow;
            };
            var div = element[0].querySelector('div[ng-transclude]');
            if (div && div.removeAttribute) {
                div.removeAttribute('ng-transclude');
            }
        }
    };
}])
.directive('mmContextMenuItem', ["$mmUtil", "$timeout", "$ionicPlatform", function($mmUtil, $timeout, $ionicPlatform) {
        function getBooleanValue(value, defaultValue) {
        if (typeof value == 'undefined') {
            return defaultValue;
        }
        return !!(value && value !== "false");
    }
        function getOuterContextMenuController() {
        var menus = document.querySelectorAll('ion-header-bar mm-context-menu'),
            outerContextMenu;
        angular.forEach(menus, function(menu) {
            var div = $mmUtil.closest(menu, '.buttons-left, .buttons-right');
            if (div && angular.element(div).css('opacity') !== '0') {
                outerContextMenu = menu;
            }
        });
        if (outerContextMenu) {
            return angular.element(outerContextMenu).controller('mmContextMenu');
        }
    }
    return {
        require: '^^mmContextMenu',
        restrict: 'E',
        scope: {
            content: '=',
            iconAction: '=?',
            iconDescription: '=?',
            ariaAction: '=?',
            ariaDescription: '=?',
            action: '&?',
            href: '=?',
            captureLink: '=?',
            autoLogin: '=?',
            closeOnClick: '=?',
            closeWhenDone: '=?',
            priority: '=?',
            ngShow: '=?'
        },
        link: function(scope, element, attrs, CtxtMenuCtrl) {
            scope.priority = scope.priority || 1;
            scope.closeOnClick = getBooleanValue(scope.closeOnClick, true);
            scope.closeWhenDone = getBooleanValue(scope.closeWhenDone, false);
            if (typeof attrs.ngShow == 'undefined') {
                scope.ngShow = true;
            }
            if (scope.action) {
                scope.href = "";
            } else if (scope.href) {
                scope.action = false;
            }
            scope.captureLink = scope.href && scope.captureLink ? scope.captureLink : "false";
            scope.autoLogin = scope.autoLogin || 'check';
            if (CtxtMenuCtrl.shouldMerge() && $ionicPlatform.isTablet()) {
                $timeout(function() {
                    if (!scope.$$destroyed) {
                        var ctrl = getOuterContextMenuController();
                        if (ctrl) {
                            CtxtMenuCtrl = ctrl;
                        }
                        CtxtMenuCtrl.addContextMenuItem(scope);
                    }
                });
            } else {
                CtxtMenuCtrl.addContextMenuItem(scope);
            }
        }
    };
}]);

angular.module('mm.core')
.directive('mmExternalContent', ["$log", "$mmFilepool", "$mmSite", "$mmSitesManager", "$mmUtil", "$q", "$mmApp", "$ionicPlatform", function($log, $mmFilepool, $mmSite, $mmSitesManager, $mmUtil, $q, $mmApp, $ionicPlatform) {
    $log = $log.getInstance('mmExternalContent');
        function addSource(dom, url) {
        if (dom.tagName !== 'SOURCE') {
            return;
        }
        var e = document.createElement('source'),
            type = dom.getAttribute('type');
        e.setAttribute('src', url);
        if (type) {
            if (ionic.Platform.isAndroid() && type == 'video/quicktime') {
                e.setAttribute('type', 'video/mp4');
            } else {
                e.setAttribute('type', type);
            }
        }
        dom.parentNode.insertBefore(e, dom);
    }
        function handleExternalContent(siteId, dom, targetAttr, url, component, componentId) {
        if (dom.tagName == 'VIDEO' && dom.textTracks && targetAttr != 'poster') {
            dom.textTracks.onaddtrack = function(event) {
                if (event.track) {
                    event.track.oncuechange = function() {
                        var line = $ionicPlatform.isTablet() || ionic.Platform.isAndroid() ? 90 : 80;
                        angular.forEach(event.track.cues, function(cue) {
                            cue.snapToLines = false;
                            cue.line = line;
                            cue.size = 100;
                        });
                        event.track.oncuechange = null;
                    };
                }
            };
        }
        if (!url || !$mmUtil.isDownloadableUrl(url)) {
            $log.debug('Ignoring non-downloadable URL: ' + url);
            if (dom.tagName === 'SOURCE') {
                addSource(dom, url);
            }
            return $q.reject();
        }
        return $mmSitesManager.getSite(siteId).then(function(site) {
            if (!site.canDownloadFiles() && $mmUtil.isPluginFileUrl(url)) {
                angular.element(dom).remove();
                return $q.reject();
            }
            var fn,
                downloadUnknown = dom.tagName == 'IMG' || dom.tagName == 'TRACK' || targetAttr == 'poster';
            if (targetAttr === 'src' && dom.tagName !== 'SOURCE' && dom.tagName !== 'TRACK') {
                fn = $mmFilepool.getSrcByUrl;
            } else {
                fn = $mmFilepool.getUrlByUrl;
            }
            return fn(siteId, url, component, componentId, 0, true, downloadUnknown).then(function(finalUrl) {
                $log.debug('Using URL ' + finalUrl + ' for ' + url);
                if (dom.tagName === 'SOURCE') {
                    addSource(dom, finalUrl);
                } else {
                    dom.setAttribute(targetAttr, finalUrl);
                }
                if (finalUrl.indexOf('http') === 0 && targetAttr != 'poster' &&
                            (dom.tagName == 'VIDEO' || dom.tagName == 'AUDIO' || dom.tagName == 'A' || dom.tagName == 'SOURCE')) {
                    var eventName = dom.tagName == 'A' ? 'click' : 'play';
                    if (dom.tagName == 'SOURCE') {
                        dom = $mmUtil.closest(dom, 'video,audio');
                        if (!dom) {
                            return;
                        }
                    }
                    angular.element(dom).on(eventName, function() {
                        if (!$mmApp.isNetworkAccessLimited()) {
                            fn(siteId, url, component, componentId, undefined, false);
                        }
                    });
                }
            });
        });
    }
    return {
        restrict: 'A',
        scope: {
            siteid: '='
        },
        link: function(scope, element, attrs) {
            var dom = element[0],
                siteid = scope.siteid || $mmSite.getId(),
                component = attrs.component,
                componentId = attrs.componentId,
                targetAttr,
                sourceAttr,
                observe = false;
            if (dom.tagName === 'A') {
                targetAttr = 'href';
                sourceAttr = 'href';
                if (attrs.hasOwnProperty('ngHref')) {
                    observe = true;
                }
            } else if (dom.tagName === 'IMG') {
                targetAttr = 'src';
                sourceAttr = 'src';
                if (attrs.hasOwnProperty('ngSrc')) {
                    observe = true;
                }
            } else if (dom.tagName === 'AUDIO' || dom.tagName === 'VIDEO' || dom.tagName === 'SOURCE' || dom.tagName === 'TRACK') {
                targetAttr = 'src';
                sourceAttr = 'targetSrc';
                if (attrs.hasOwnProperty('ngSrc')) {
                    observe = true;
                }
                if (dom.tagName === 'VIDEO' && attrs.poster) {
                    handleExternalContent(siteid, dom, 'poster', attrs.poster, component, componentId);
                }
            } else {
                $log.warn('Directive attached to non-supported tag: ' + dom.tagName);
                return;
            }
            if (observe) {
                attrs.$observe(targetAttr, function(url) {
                    if (!url) {
                        return;
                    }
                    handleExternalContent(siteid, dom, targetAttr, url, component, componentId);
                });
            } else {
                handleExternalContent(siteid, dom, targetAttr, attrs[sourceAttr] || attrs[targetAttr], component, componentId);
            }
        }
    };
}]);

angular.module('mm.core')
.directive('mmFile', ["$q", "$mmUtil", "$mmFilepool", "$mmSite", "$mmApp", "$mmEvents", "$mmFS", "mmCoreDownloaded", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", function($q, $mmUtil, $mmFilepool, $mmSite, $mmApp, $mmEvents, $mmFS, mmCoreDownloaded, mmCoreDownloading,
            mmCoreNotDownloaded, mmCoreOutdated) {
        function getState(scope, siteId, fileUrl, timeModified, alwaysDownload) {
        return $mmFilepool.getFileStateByUrl(siteId, fileUrl, timeModified).then(function(state) {
            var canDownload = $mmSite.canDownloadFiles();
            scope.isDownloaded = state === mmCoreDownloaded || state === mmCoreOutdated;
            scope.isDownloading = canDownload && state === mmCoreDownloading;
            scope.showDownload = canDownload && (state === mmCoreNotDownloaded || state === mmCoreOutdated ||
                    (alwaysDownload && state === mmCoreDownloaded));
        });
    }
        function downloadFile(scope, siteId, fileUrl, component, componentId, timeModified, alwaysDownload) {
        if (!$mmSite.canDownloadFiles()) {
            $mmUtil.showErrorModal('mm.core.cannotdownloadfiles', true);
            return $q.reject();
        }
        scope.isDownloading = true;
        return $mmFilepool.downloadUrl(siteId, fileUrl, false, component, componentId, timeModified).then(function(localUrl) {
            return localUrl;
        }).catch(function() {
            return getState(scope, siteId, fileUrl, timeModified, alwaysDownload).then(function() {
                if (scope.isDownloaded) {
                    return $mmFilepool.getInternalUrlByUrl(siteId, fileUrl);
                } else {
                    return $q.reject();
                }
            });
        });
    }
        function openFile(scope, siteId, fileUrl, fileSize, component, componentId, timeModified, alwaysDownload) {
        var fixedUrl = $mmSite.fixPluginfileURL(fileUrl),
            promise;
        if ($mmFS.isAvailable()) {
            promise = $q.when().then(function() {
                var isWifi = !$mmApp.isNetworkAccessLimited(),
                    isOnline = $mmApp.isOnline();
                if (scope.isDownloaded && !scope.showDownload) {
                    return $mmFilepool.getUrlByUrl(siteId, fileUrl, component, componentId, timeModified);
                } else {
                    if (!isOnline && !scope.isDownloaded) {
                        return $q.reject();
                    }
                    var isDownloading = scope.isDownloading;
                    scope.isDownloading = true;
                    return $mmFilepool.shouldDownloadBeforeOpen(fixedUrl, fileSize).then(function() {
                        if (isDownloading) {
                            return;
                        }
                        return downloadFile(scope, siteId, fileUrl, component, componentId, timeModified, alwaysDownload);
                    }, function() {
                        if (isWifi && isOnline) {
                            downloadFile(scope, siteId, fileUrl, component, componentId, timeModified, alwaysDownload);
                        }
                        if (isDownloading|| !scope.isDownloaded || isOnline) {
                            return fixedUrl;
                        } else {
                            return $mmFilepool.getUrlByUrl(siteId, fileUrl, component, componentId, timeModified);
                        }
                    });
                }
            });
        } else {
            promise = $q.when(fixedUrl);
        }
        return promise.then(function(url) {
            if (!url) {
                return;
            }
            if (url.indexOf('http') === 0) {
                return $mmUtil.openOnlineFile(url);
            } else {
                return $mmUtil.openFile(url);
            }
        });
    }
    return {
        restrict: 'E',
        templateUrl: 'core/templates/file.html',
        scope: {
            file: '=',
            canDelete: '@?',
            onDelete: '&?',
            canDownload: '@?',
            noBorder : '@?'
        },
        link: function(scope, element, attrs) {
            var fileUrl = scope.file.fileurl || scope.file.url,
                fileName = scope.file.filename,
                fileSize = scope.file.filesize,
                timeModified = attrs.timemodified || 0,
                siteId = $mmSite.getId(),
                component = attrs.component,
                componentId = attrs.componentId,
                alwaysDownload = attrs.alwaysDownload && attrs.alwaysDownload !== 'false',
                canDownload = scope.canDownload !== false && scope.canDownload !== 'false',
                observer;
            if (!fileName) {
                return;
            }
            scope.filename = fileName;
            scope.fileicon = $mmFS.getFileIcon(fileName);
            if (canDownload) {
                getState(scope, siteId, fileUrl, timeModified, alwaysDownload);
                $mmFilepool.getFileEventNameByUrl(siteId, fileUrl).then(function(eventName) {
                    observer = $mmEvents.on(eventName, function() {
                        getState(scope, siteId, fileUrl, timeModified, alwaysDownload);
                    });
                });
            }
            scope.download = function(e, openAfterDownload) {
                e.preventDefault();
                e.stopPropagation();
                var promise;
                if (scope.isDownloading && !openAfterDownload) {
                    return;
                }
                if (!$mmApp.isOnline() && (!openAfterDownload || (openAfterDownload && !scope.isDownloaded))) {
                    $mmUtil.showErrorModal('mm.core.networkerrormsg', true);
                    return;
                }
                if (openAfterDownload) {
                    openFile(scope, siteId, fileUrl, fileSize, component, componentId, timeModified, alwaysDownload)
                            .catch(function(error) {
                        $mmUtil.showErrorModalDefault(error, 'mm.core.errordownloading', true);
                    });
                } else {
                    promise = fileSize ? $mmUtil.confirmDownloadSize({size: fileSize, total: true}) : $q.when();
                    promise.then(function() {
                        $mmFilepool.invalidateFileByUrl(siteId, fileUrl).finally(function() {
                            scope.isDownloading = true;
                            $mmFilepool.addToQueueByUrl(siteId, fileUrl, component, componentId, timeModified).catch(function() {
                                $mmUtil.showErrorModal('mm.core.errordownloading', true);
                            });
                        });
                    });
                }
            };
            if (scope.canDelete) {
                scope.delete = function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    if (scope.onDelete) {
                        scope.onDelete();
                    }
                };
            }
            scope.$on('$destroy', function() {
                if (observer && observer.off) {
                    observer.off();
                }
            });
        }
    };
}]);

angular.module('mm.core')
.directive('mmFormatText', ["$interpolate", "$mmText", "$compile", "$translate", "$mmUtil", function($interpolate, $mmText, $compile, $translate, $mmUtil) {
    var extractVariableRegex = new RegExp('{{([^|]+)(|.*)?}}', 'i'),
        tagsToIgnore = ['AUDIO', 'VIDEO', 'BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'A'];
        function addExternalContent(el, component, componentId, siteId) {
        el.setAttribute('mm-external-content', '');
        if (component) {
            el.setAttribute('component', component);
            if (componentId) {
                el.setAttribute('component-id', componentId);
            }
        }
        if (siteId) {
            el.setAttribute('siteid', siteId);
        }
    }
        function addMediaAdaptClass(el) {
        angular.element(el).addClass('mm-media-adapt-width');
    }
        function getElementWidth(element) {
        var width = $mmUtil.getElementWidth(element);
        if (!width) {
            var angElement = angular.element(element),
                parentWidth = $mmUtil.getElementWidth(element.parentNode, true, false, false, true),
                previousDisplay = angElement.css('display');
            angElement.css('display', 'inline-block');
            width = $mmUtil.getElementWidth(element);
            if (parentWidth > 0 && (!width || width > parentWidth)) {
                width = parentWidth;
            }
            angElement.css('display', previousDisplay);
        }
        return parseInt(width, 10);
    }
        function getElementHeight(elementAng) {
        var element = elementAng[0],
            height;
        elementAng.removeClass('mm-enabled-media-adapt');
        height = $mmUtil.getElementHeight(element);
        elementAng.addClass('mm-enabled-media-adapt');
        return parseInt(height, 10) || false;
    }
        function formatAndRenderContents(scope, element, attrs, text) {
        var maxHeight = false;
        if (typeof text == 'undefined') {
            element.removeClass('opacity-hide');
            return;
        }
        text = $interpolate(text)(scope);
        text = text.trim();
        if (typeof attrs.maxHeight != "undefined") {
            maxHeight = parseInt(attrs.maxHeight || 0, 10) || false;
        } else if (typeof attrs.shorten != "undefined") {
            console.warn("mm-format-text: shorten attribute is deprecated please use max-height and expand-in-fullview instead.");
            maxHeight = 100;
        }
        formatContents(scope, element, attrs, text).then(function(fullText) {
            if (maxHeight && fullText != "") {
                renderText(scope, element, fullText);
                var height = element.css('max-height') ? false : getElementHeight(element);
                if (!height || height > maxHeight) {
                    var expandInFullview = $mmUtil.isTrueOrOne(attrs.fullviewOnClick) || false;
                    fullText += '<div class="mm-show-more">' + $translate.instant('mm.core.showmore') + '</div>';
                    if (expandInFullview) {
                        element.addClass('mm-expand-in-fullview');
                    }
                    element.addClass('mm-text-formatted mm-shortened');
                    element.css('max-height', maxHeight + 'px');
                    element.on('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        var target = e.target;
                        if (tagsToIgnore.indexOf(target.tagName) === -1 || (target.tagName === 'A' &&
                                !target.getAttribute('href'))) {
                            if (!expandInFullview) {
                                element.toggleClass('mm-shortened');
                            } else {
                                $mmText.expandText(attrs.expandTitle || $translate.instant('mm.core.description'), text,
                                    attrs.newlinesOnFullview, attrs.component, attrs.componentId);
                            }
                        } else {
                            $mmText.expandText(attrs.expandTitle || $translate.instant('mm.core.description'), text,
                                attrs.newlinesOnFullview, attrs.component, attrs.componentId);
                        }
                    });
                }
            }
            element.addClass('mm-enabled-media-adapt');
            renderText(scope, element, fullText, attrs.afterRender);
        });
    }
        function formatContents(scope, element, attrs, text) {
        var siteId = scope.siteid,
            component = attrs.component,
            componentId = attrs.componentId;
        return $mmText.formatText(text, attrs.clean, attrs.singleline).then(function(formatted) {
            var el = element[0],
                dom = angular.element('<div>').html(formatted),
                images = dom.find('img');
            angular.forEach(dom.find('a'), function(anchor) {
                anchor.setAttribute('mm-link', '');
                anchor.setAttribute('capture-link', true);
                addExternalContent(anchor, component, componentId, siteId);
            });
            if (images && images.length > 0) {
                var elWidth = getElementWidth(el) || 100;
                angular.forEach(images, function(img) {
                    addMediaAdaptClass(img);
                    addExternalContent(img, component, componentId, siteId);
                    if (!attrs.notAdaptImg) {
                        var imgWidth = getElementWidth(img),
                            container = angular.element('<span class="mm-adapted-img-container"></span>'),
                            jqImg = angular.element(img);
                        container.css('float', img.style.float);
                        jqImg.wrap(container);
                        if (imgWidth > elWidth) {
                            var label = $mmText.escapeHTML($translate.instant('mm.core.openfullimage')),
                                imgSrc = $mmText.escapeHTML(img.getAttribute('src'));
                            jqImg.after('<a href="#" class="mm-image-viewer-icon" mm-image-viewer img="' + imgSrc +
                                            '" aria-label="' + label + '"><i class="icon ion-ios-search-strong"></i></a>');
                        }
                    }
                });
            }
            angular.forEach(dom.find('audio'), function(el) {
                treatMedia(el, component, componentId, siteId);
            });
            angular.forEach(dom.find('video'), function(el) {
                treatVideoFilters(el);
                treatMedia(el, component, componentId, siteId);
                el.setAttribute('data-tap-disabled', true);
            });
            angular.forEach(dom.find('iframe'), addMediaAdaptClass);
            if (ionic.Platform.isIOS()) {
                angular.forEach(dom.find('select'), function(select) {
                    select.setAttribute('mm-ios-select-fix', '');
                });
            }
            angular.forEach(dom[0].querySelectorAll('.button'), function(button) {
                if (button.querySelector('a')) {
                    angular.element(button).addClass('mm-button-with-inner-link');
                }
            });
            return dom.html();
        });
    }
        function renderText(scope, element, text, afterRender) {
        element.html(text);
        element.removeClass('opacity-hide');
        $compile(element.contents())(scope);
        if (afterRender && scope[afterRender]) {
            scope[afterRender](scope);
        }
    }
    function youtubeGetId(url) {
        var regExp = /^.*(?:(?:youtu.be\/)|(?:v\/)|(?:\/u\/\w\/)|(?:embed\/)|(?:watch\?))\??v?=?([^#\&\?]*).*/;
        var match = url.match(regExp);
        return (match && match[1].length == 11)? match[1] : false;
    }
        function treatVideoFilters(el) {
        if (!angular.element(el).hasClass('video-js')) {
            return;
        }
        var data = JSON.parse(el.getAttribute('data-setup') || '{}'),
            youtubeId = data.techOrder && data.techOrder[0] && data.techOrder[0] == 'youtube' && data.sources && data.sources[0] &&
                data.sources[0].src && youtubeGetId(data.sources[0].src);
        if (!youtubeId) {
            return;
        }
        var iframe = document.createElement('iframe');
        iframe.id = el.id;
        iframe.src = 'https://www.youtube.com/embed/' + youtubeId;
        iframe.setAttribute('frameborder', 0);
        iframe.width = '100%';
        iframe.height = 300;
        el.parentNode.insertBefore(iframe, el);
        el.parentNode.removeChild(el);
    }
        function treatMedia(el, component, componentId, siteId) {
        addMediaAdaptClass(el);
        addExternalContent(el, component, componentId, siteId);
        angular.forEach(angular.element(el).find('source'), function(source) {
            source.setAttribute('target-src', source.getAttribute('src'));
            source.removeAttribute('src');
            addExternalContent(source, component, componentId, siteId);
        });
        angular.forEach(angular.element(el).find('track'), function(track) {
            addExternalContent(track, component, componentId, siteId);
        });
    }
    return {
        restrict: 'EA',
        scope: true,
        link: function(scope, element, attrs) {
            element.addClass('opacity-hide');
            var content = element.html();
            if (attrs.watch) {
                var matches = content.match(extractVariableRegex);
                if (matches && typeof matches[1] == 'string') {
                    var variable = matches[1].trim();
                    scope.$watch(variable, function() {
                        formatAndRenderContents(scope, element, attrs, content);
                    });
                } else {
                    formatAndRenderContents(scope, element, attrs, content);
                }
            } else {
                formatAndRenderContents(scope, element, attrs, content);
            }
        }
    };
}]);

angular.module('mm.core')
.constant('mmCoreIframeTimeout', 15000)
.directive('mmIframe', ["$log", "$mmUtil", "$mmText", "$mmSite", "$mmFS", "$timeout", "mmCoreIframeTimeout", function($log, $mmUtil, $mmText, $mmSite, $mmFS, $timeout, mmCoreIframeTimeout) {
    $log = $log.getInstance('mmIframe');
    var tags = ['iframe', 'frame', 'object', 'embed'];
        function treatFrame(element) {
        if (element) {
            redefineWindowOpen(element);
            treatLinks(element);
            element.on('load', function() {
                redefineWindowOpen(element);
                treatLinks(element);
            });
        }
    }
        function redefineWindowOpen(element) {
        var el = element[0],
            contentWindow = element.contentWindow || el.contentWindow,
            contents = element.contents();
        if (!contentWindow && el && el.contentDocument) {
            contentWindow = el.contentDocument.defaultView;
        }
        if (!contentWindow && el && el.getSVGDocument) {
            var svgDoc = el.getSVGDocument();
            if (svgDoc && svgDoc.defaultView) {
                contents = angular.element(svgdoc);
                contentWindow = svgdoc.defaultView;
            } else if (el.window) {
                contentWindow = el.window;
            } else if (el.getWindow) {
                contentWindow = el.getWindow();
            }
        }
        if (contentWindow) {
            contentWindow.open = function (url) {
                var scheme = $mmText.getUrlScheme(url);
                if (!scheme) {
                    var src = element[0] && (element[0].src || element[0].data);
                    if (src) {
                        var dirAndFile = $mmFS.getFileAndDirectoryFromPath(src);
                        if (dirAndFile.directory) {
                            url = $mmFS.concatenatePaths(dirAndFile.directory, url);
                        } else {
                            $log.warn('Cannot get iframe dir path to open relative url', url, element);
                            return {};
                        }
                    } else {
                        $log.warn('Cannot get iframe src to open relative url', url, element);
                        return {};
                    }
                }
                if (url.indexOf('cdvfile://') === 0 || url.indexOf('file://') === 0) {
                    $mmUtil.openFile(url).catch(function(error) {
                        $mmUtil.showErrorModal(error);
                    });
                } else {
                    if (!$mmSite.isLoggedIn()) {
                        $mmUtil.openInBrowser(url);
                    } else {
                        $mmSite.openInBrowserWithAutoLoginIfSameSite(url);
                    }
                }
                return {};
            };
        }
        angular.forEach(tags, function(tag) {
            angular.forEach(contents.find(tag), function(subelement) {
                treatFrame(angular.element(subelement));
            });
        });
    }
        function treatLinks(element) {
        var links = element.contents().find('a');
        angular.forEach(links, function(el) {
            var href = el.href;
            if (href) {
                var scheme = $mmText.getUrlScheme(href);
                if (scheme && scheme == 'javascript') {
                    return;
                } else if (scheme && scheme != 'file' && scheme != 'filesystem') {
                    angular.element(el).on('click', function(e) {
                        if (!e.defaultPrevented) {
                            e.preventDefault();
                            if (!$mmSite.isLoggedIn()) {
                                $mmUtil.openInBrowser(href);
                            } else {
                                $mmSite.openInBrowserWithAutoLoginIfSameSite(href);
                            }
                        }
                    });
                } else if (el.target == '_parent' || el.target == '_top' || el.target == '_blank') {
                    angular.element(el).on('click', function(e) {
                        if (!e.defaultPrevented) {
                            e.preventDefault();
                            $mmUtil.openFile(href).catch(function(error) {
                                $mmUtil.showErrorModal(error);
                            });
                        }
                    });
                } else if (ionic.Platform.isIOS() && (!el.target || el.target == '_self')) {
                    angular.element(el).on('click', function(e) {
                        if (!e.defaultPrevented) {
                            if (element[0].tagName.toLowerCase() == 'object') {
                                e.preventDefault();
                                element.attr('data', href);
                            } else {
                                e.preventDefault();
                                element.attr('src', href);
                            }
                        }
                    });
                }
            }
        });
    }
    return {
        restrict: 'E',
        templateUrl: 'core/templates/iframe.html',
        scope: {
            src: '='
        },
        link: function(scope, element, attrs) {
            var url = (scope.src && scope.src.toString()) || '', 
                iframe = angular.element(element.find('iframe')[0]);
            scope.width = $mmUtil.formatPixelsSize(attrs.iframeWidth) || '100%';
            scope.height = $mmUtil.formatPixelsSize(attrs.iframeHeight) || '100%';
            scope.loading = !!url.match(/^https?:\/\//i);
            treatFrame(iframe);
            if (scope.loading) {
                iframe.on('load', function() {
                    scope.loading = false;
                    $timeout();
                });
                iframe.on('error', function() {
                    scope.loading = false;
                    $mmUtil.showErrorModal('mm.core.errorloadingcontent', true);
                    $timeout();
                });
                $timeout(function() {
                    scope.loading = false;
                }, mmCoreIframeTimeout);
            }
        }
    };
}]);

angular.module('mm.core')
.directive('mmImageViewer', ["$ionicModal", function($ionicModal) {
    return {
        restrict: 'A',
        priority: 500,
        scope: true,
        link: function(scope, element, attrs) {
            if (attrs.img) {
                scope.img = attrs.img;
                scope.closeModal = function(){
                    scope.modal.hide();
                };
                element.on('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    if (!scope.modal) {
                        $ionicModal.fromTemplateUrl('core/templates/imageviewer.html', {
                            scope: scope,
                            animation: 'slide-in-up'
                        }).then(function(m) {
                            scope.modal = m;
                            scope.modal.show();
                        });
                    } else {
                        scope.modal.show();
                    }
                });
                scope.$on('$destroy', function() {
                    if (scope.modal) {
                        scope.modal.remove();
                    }
                });
            }
        }
    };
}]);

angular.module('mm.core')
.directive('mmInputErrors', ["$translate", "$compile", function($translate, $compile) {
    var errorContainerTemplate =
        '<div class="mm-input-error-container" ng-show="form[fieldName].$error && form.$submitted" ' +
                    'ng-messages="form[fieldName].$error" role="alert">' +
            '<div ng-repeat="(type, text) in errorMessages">' +
                '<div class="mm-input-error" ng-message-exp="type">{{text}}</div>' +
            '</div>' +
        '</div>';
    function initErrorMessages(scope, input) {
        scope.errorMessages = scope.errorMessages || {};
        scope.errorMessages.required = scope.errorMessages.required || $translate.instant('mm.core.required');
        scope.errorMessages.email = scope.errorMessages.email || $translate.instant('mm.login.invalidemail');
        scope.errorMessages.date = scope.errorMessages.date || $translate.instant('mm.login.invaliddate');
        scope.errorMessages.datetime = scope.errorMessages.datetime || $translate.instant('mm.login.invaliddate');
        scope.errorMessages.datetimelocal = scope.errorMessages.datetimelocal || $translate.instant('mm.login.invaliddate');
        scope.errorMessages.time = scope.errorMessages.time || $translate.instant('mm.login.invalidtime');
        scope.errorMessages.url = scope.errorMessages.url || $translate.instant('mm.login.invalidurl');
        angular.forEach(['min', 'max'], function(type) {
            if (!scope.errorMessages[type]) {
                if (input && typeof input[type] != 'undefined' && input[type] !== '') {
                    var value = input[type];
                    if (input.type == 'date' || input.type == 'datetime' || input.type == 'datetime-local') {
                        var date = moment(value);
                        if (date.isValid()) {
                            value = moment(value).format($translate.instant('mm.core.dfdaymonthyear'));
                        }
                    }
                    scope.errorMessages[type] = $translate.instant('mm.login.invalidvalue' + type, {$a: value});
                } else {
                    scope.errorMessages[type] = $translate.instant('mm.login.profileinvaliddata');
                }
            }
        });
    }
    return {
        restrict: 'A',
        require: '^form',
        scope: {
            fieldName: '@?',
            errorMessages: '=?'
        },
        link: function(scope, element, attrs, FormController) {
            var input;
            scope.form = FormController;
            if (!scope.fieldName) {
                input = element[0].querySelector('input, select, textarea');
                if (!input || !input.name) {
                    return;
                }
                scope.fieldName = input.name;
            }
            if (input) {
                initErrorMessages(scope, input);
            }
            var errorContainer = $compile(errorContainerTemplate)(scope);
            element.append(errorContainer);
            scope.$watch('form[fieldName].$invalid && form.$submitted', function(newValue) {
                if (!input) {
                    input = element[0].querySelector('*[name="' + scope.fieldName + '"]');
                    if (input) {
                        initErrorMessages(scope, input);
                    }
                }
                if (newValue) {
                    element.addClass('mm-input-has-errors');
                } else {
                    element.removeClass('mm-input-has-errors');
                }
            });
        }
    };
}]);

angular.module('mm.core')
.directive('mmIosSelectFix', function() {
    return {
        restrict: 'A',
        priority: 100,
        scope: false,
        require: 'select',
        link: function(scope, element) {
            if (ionic.Platform.isIOS()) {
                scope.$watch(function() {
                    return element.html();
                }, function() {
                    if (!element[0].querySelector('optgroup')) {
                        element.append('<optgroup label=""></optgroup>');
                    }
                });
            }
        }
    };
});

angular.module('mm.core')
.directive('mmKeepKeyboard', ["$mmUtil", "$timeout", "$mmApp", function($mmUtil, $timeout, $mmApp) {
    return {
        restrict: 'A',
        link: function(scope, element, attrs) {
            var selector = attrs.mmKeepKeyboard,
                keepInButton = attrs.keepInButton && attrs.keepInButton !== 'false',
                lastFocusOut = 0,
                candidateEls,
                selectedEl,
                button,
                input;
            if (typeof selector != 'string' || !selector) {
                return;
            }
            candidateEls = document.querySelectorAll(selector);
            selectedEl = candidateEls[candidateEls.length - 1];
            if (!selectedEl) {
                return;
            }
            if (keepInButton) {
                button = element[0];
                input = selectedEl;
            } else {
                button = selectedEl;
                input = element[0];
            }
            input.addEventListener('focusout', focusOut);
            button.addEventListener('click', buttonClicked);
            scope.$on('$destroy', function() {
                button.removeEventListener('click', buttonClicked);
                input.removeEventListener('focusout', focusOut);
            });
            function focusOut() {
                lastFocusOut = Date.now();
            }
            function buttonClicked() {
                if (document.activeElement == input) {
                    input.addEventListener('focusout', focusElementAgain);
                    $timeout(focusElementAgain);
                } else if (document.activeElement == button && Date.now() - lastFocusOut < 200) {
                    $timeout(focusElementAgain);
                }
            }
            function focusElementAgain() {
                if ($mmApp.isKeyboardVisible()) {
                    $mmUtil.focusElement(input);
                    input.removeEventListener('focusout', focusElementAgain);
                }
            }
        }
    };
}]);

angular.module('mm.core')
.directive('mmLink', ["$mmUtil", "$mmContentLinksHelper", "$location", "$mmSite", function($mmUtil, $mmContentLinksHelper, $location, $mmSite) {
        function navigate(href, inApp, autoLogin) {
        inApp = inApp && inApp !== 'false';
        autoLogin = autoLogin || 'check';
        if (href.indexOf('cdvfile://') === 0 || href.indexOf('file://') === 0) {
            $mmUtil.openFile(href).catch(function(error) {
                $mmUtil.showErrorModal(error);
            });
        } else if (href.charAt(0) == '#'){
            href = href.substr(1);
            if (href.charAt(0) == '/') {
                $location.url(href);
            } else {
                $mmUtil.scrollToElement(document, "#" + href + ", [name='" + href + "']");
            }
        } else {
            if (!$mmSite.isLoggedIn()) {
                if (inApp) {
                    $mmUtil.openInApp(href);
                } else {
                    $mmUtil.openInBrowser(href);
                }
            } else if (autoLogin == 'yes') {
                if (inApp) {
                    $mmSite.openInAppWithAutoLogin(href);
                } else {
                    $mmSite.openInBrowserWithAutoLogin(href);
                }
            } else if (autoLogin == 'no') {
                if (inApp) {
                    $mmUtil.openInApp(href);
                } else {
                    $mmUtil.openInBrowser(href);
                }
            } else {
                if (inApp) {
                    $mmSite.openInAppWithAutoLoginIfSameSite(href);
                } else {
                    $mmSite.openInBrowserWithAutoLoginIfSameSite(href);
                }
            }
        }
    }
    return {
        restrict: 'A',
        priority: 100,
        link: function(scope, element, attrs) {
            element.on('click', function(event) {
                if (!event.defaultPrevented) {
                    var href = element[0].getAttribute('href');
                    if (href) {
                        event.preventDefault();
                        event.stopPropagation();
                        if (attrs.captureLink && attrs.captureLink !== 'false') {
                            $mmContentLinksHelper.handleLink(href).then(function(treated) {
                                if (!treated) {
                                   navigate(href, attrs.inApp, attrs.autoLogin);
                                }
                            });
                        } else {
                            navigate(href, attrs.inApp, attrs.autoLogin);
                        }
                    }
                }
            });
        }
    };
}]);

angular.module('mm.core')
.directive('mmLoading', ["$translate", function($translate) {
    return {
        restrict: 'E',
        templateUrl: 'core/templates/loading.html',
        transclude: true,
        scope: {
            hideUntil: '=?',
            message: '@?',
            dynMessage: '=?',
            loadingPaddingTop: '=?'
        },
        link: function(scope, element, attrs) {
            var el = element[0],
                loading = angular.element(el.querySelector('.mm-loading-container'));
            if (!attrs.message) {
                $translate('mm.core.loading').then(function(loadingString) {
                    scope.message = loadingString;
                });
            }
            if (attrs.loadingPaddingTop) {
                scope.$watch('loadingPaddingTop', function(newValue) {
                    var num = parseInt(newValue);
                    if (num >= 0 || num < 0) {
                        loading.css('padding-top', newValue + 'px');
                    } else if(typeof newValue == 'string') {
                        loading.css('padding-top', newValue);
                    }
                });
            }
        }
    };
}]);

angular.module('mm.core')
.directive('mmLocalFile', ["$mmFS", "$mmText", "$mmUtil", "$timeout", "$translate", function($mmFS, $mmText, $mmUtil, $timeout, $translate) {
    function loadFileBasicData(scope, file) {
        scope.fileName = file.name;
        scope.fileIcon = $mmFS.getFileIcon(file.name);
        scope.fileExtension = $mmFS.getFileExtension(file.name);
    }
    return {
        restrict: 'E',
        templateUrl: 'core/templates/localfile.html',
        scope: {
            file: '=',
            manage: '=?',
            fileDeleted: '&?',
            fileRenamed: '&?',
            overrideClick: '=?',
            fileClicked: '&?',
            noBorder: '@?'
        },
        link: function(scope, element) {
            var file = scope.file,
                relativePath;
            if (!file || !file.name) {
                return;
            }
            relativePath = $mmFS.removeBasePath(file.toURL());
            if (!relativePath) {
                relativePath = file.fullPath;
            }
            loadFileBasicData(scope, file);
            scope.data = {};
            $mmFS.getMetadata(file).then(function(metadata) {
                if (metadata.size >= 0) {
                    scope.size = $mmText.bytesToSize(metadata.size, 2);
                }
                scope.timeModified = moment(metadata.modificationTime).format('LLL');
            });
            scope.open = function(e) {
                e.preventDefault();
                e.stopPropagation();
                if (scope.overrideClick && scope.fileClicked) {
                    scope.fileClicked();
                } else {
                    $mmUtil.openFile(file.toURL());
                }
            };
            scope.activateEdit = function(e) {
                e.preventDefault();
                e.stopPropagation();
                scope.editMode = true;
                scope.data.filename = file.name;
                $timeout(function() {
                    $mmUtil.focusElement(element[0].querySelector('input'));
                });
            };
            scope.changeName = function(e, newName) {
                e.preventDefault();
                e.stopPropagation();
                if (newName == file.name) {
                    scope.editMode = false;
                    return;
                }
                var modal = $mmUtil.showModalLoading(),
                    fileAndDir = $mmFS.getFileAndDirectoryFromPath(relativePath),
                    newPath = $mmFS.concatenatePaths(fileAndDir.directory, newName);
                $mmFS.getFile(newPath).then(function() {
                    $mmUtil.showErrorModal('mm.core.errorfileexistssamename', true);
                }).catch(function() {
                    return $mmFS.moveFile(relativePath, newPath).then(function(fileEntry) {
                        scope.editMode = false;
                        scope.file = file = fileEntry;
                        loadFileBasicData(scope, file);
                        scope.fileRenamed && scope.fileRenamed({file: file});
                    }).catch(function() {
                        $mmUtil.showErrorModal('mm.core.errorrenamefile', true);
                    });
                }).finally(function() {
                    modal.dismiss();
                });
            };
            scope.deleteFile = function(e) {
                e.preventDefault();
                e.stopPropagation();
                $mmUtil.showConfirm($translate.instant('mm.core.confirmdeletefile')).then(function() {
                    var modal = $mmUtil.showModalLoading();
                    $mmFS.removeFile(relativePath).then(function() {
                        scope.fileDeleted && scope.fileDeleted();
                    }).catch(function() {
                        $mmUtil.showErrorModal('mm.core.errordeletefile', true);
                    }).finally(function() {
                        modal.dismiss();
                    });
                });
            };
        }
    };
}]);

angular.module('mm.core')
.directive('mmMarkRequired', ["$translate", "$timeout", function($translate, $timeout) {
    return {
        restrict: 'A',
        link: function(scope, element, attrs) {
            var mark = attrs.mmMarkRequired && attrs.mmMarkRequired !== 'false' && attrs.mmMarkRequired !== '0',
                requiredLabel = $translate.instant('mm.core.required');
            if (mark) {
                element.append('<i class="icon ion-asterisk mm-input-required-asterisk" title="' + requiredLabel + '"></i>');
                $timeout(function() {
                    var ariaLabel = element.attr('aria-label') || $mmText.cleanTags(element.html(), true);
                    if (ariaLabel) {
                        element.attr('aria-label', ariaLabel + ' ' + requiredLabel);
                    }
                });
            } else {
                var asterisk = element[0].querySelector('.mm-input-required-asterisk');
                if (asterisk) {
                    angular.element(asterisk).remove();
                    $timeout(function() {
                        var ariaLabel = element.attr('aria-label');
                        if (ariaLabel) {
                            element.attr('aria-label', ariaLabel.replace(' ' + requiredLabel, ''));
                        }
                    });
                }
            }
        }
    };
}]);

angular.module('mm.core')
.directive('mmMultipleSelect', ["$ionicModal", "$translate", function($ionicModal, $translate) {
    return {
        restrict: 'E',
        priority: 100,
        scope: {
            title: '@',
            options: '='
        },
        templateUrl: 'core/templates/multipleselect.html',
        link: function(scope, element, attrs) {
            var keyProperty = attrs.keyProperty || "key",
                valueProperty = attrs.valueProperty || "value",
                selectedProperty = attrs.selectedProperty || "selected",
                strSeparator = $translate.instant('mm.core.listsep') + " ";
            scope.optionsRender = [];
            scope.selectedOptions = getSelectedOptionsText();
            element.on('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                if (!scope.modal) {
                    $ionicModal.fromTemplateUrl('core/templates/multipleselectpopover.html', {
                        scope: scope,
                        animation: 'slide-in-up'
                    }).then(function(m) {
                        scope.modal = m;
                        scope.optionsRender = scope.options.map(function(option) {
                            return {
                                key: option[keyProperty],
                                value: option[valueProperty],
                                selected: option[selectedProperty] || false
                            };
                        });
                        scope.modal.show();
                    });
                } else {
                    scope.modal.show();
                }
            });
            scope.saveOptions = function() {
                angular.forEach(scope.optionsRender, function (tempOption){
                    for (var j = 0; j < scope.options.length; j++) {
                        var option = scope.options[j];
                        if (option[keyProperty] == tempOption.key) {
                            option[selectedProperty] = tempOption.selected;
                            return;
                        }
                    }
                });
                scope.selectedOptions = getSelectedOptionsText();
                scope.closeModal();
            };
            function getSelectedOptionsText() {
                var selected = scope.options.filter(function(option) {
                    return !!option[selectedProperty];
                }).map(function(option) {
                    return option[valueProperty];
                });
                return selected.join(strSeparator);
            }
            scope.closeModal = function(){
                scope.modal.hide();
            };
            scope.$on('$destroy', function () {
                if (scope.modal){
                    scope.modal.remove();
                }
            });
        }
    };
}]);

angular.module('mm.core')
.directive('mmNavButtons', ["$document", "$mmUtil", "$compile", "$timeout", function($document, $mmUtil, $compile, $timeout) {
        function callBeforeEnter(controller, eventData, $scope) {
        var data = angular.copy(eventData);
        delete data.navBarItems;
        data.viewNotified = false;
        data.shouldAnimate = false;
        var previousTitles = document.querySelectorAll('ion-header-bar .back-button .back-text .previous-title'),
            modifiedTitles = [];
        angular.forEach(previousTitles, function(title, index) {
            if (title.innerHTML == 'undefined') {
                angular.element(title).css('display', 'none');
                modifiedTitles.push(title);
            }
        });
        controller.beforeEnter(undefined, data);
        $timeout(function() {
            angular.forEach($scope.$$watchers, function(watcher) {
                var value = watcher.get($scope);
                if (typeof value != 'undefined') {
                    watcher.last = value;
                    watcher.fn(value, undefined, $scope);
                }
            });
        });
        $timeout(function() {
            angular.forEach(modifiedTitles, function(title) {
                angular.element(title).css('display', '');
            });
        }, 1000);
    }
    return {
        restrict: 'E',
        require: '^ionNavBar',
        priority: 100,
        compile: function(tElement, tAttrs) {
            var side = 'left';
            if (/^primary|secondary|right$/i.test(tAttrs.side || '')) {
                side = tAttrs.side.toLowerCase();
            }
            var spanEle = $document[0].createElement('span');
            spanEle.className = side + '-buttons';
            spanEle.innerHTML = tElement.html();
            var navElementType = side + 'Buttons';
            tElement.attr('class', 'hide');
            tElement.empty();
            return {
                pre: function($scope, $element, $attrs, navBarCtrl) {
                    var splitView = $mmUtil.closest($element[0], 'mm-split-view'),
                        ionView,
                        unregisterViewListener,
                        parentViewCtrl;
                    if (splitView) {
                        ionView = $mmUtil.closest(splitView, 'ion-view');
                    } else {
                        ionView = $mmUtil.closest($element[0], 'ion-view');
                    }
                    if (!ionView) {
                        return;
                    }
                    parentViewCtrl = angular.element(ionView).data('$ionViewController');
                    if (parentViewCtrl) {
                        if (splitView) {
                            var svController = angular.element(splitView).controller('mmSplitView'),
                                eventData,
                                leftPaneButtons,
                                leftPaneButtonsHtml,
                                timeToWait;
                            if (!svController) {
                                return;
                            }
                            timeToWait = 1000 - (new Date().getTime() - svController.getStartTime());
                            $timeout(function() {
                                eventData = svController.getIonicViewEventData();
                                leftPaneButtonsHtml = svController.getHeaderBarButtonsHtml(spanEle.className);
                                if (leftPaneButtonsHtml && leftPaneButtonsHtml.trim()) {
                                    leftPaneButtons = angular.element(leftPaneButtonsHtml);
                                }
                                spanEle = $compile(spanEle.outerHTML)($scope);
                                var contextMenus = spanEle[0].querySelectorAll('mm-context-menu');
                                if (contextMenus.length) {
                                    angular.element(contextMenus).remove();
                                }
                                if (leftPaneButtons && leftPaneButtons.length) {
                                    if (side == 'secondary' || side == 'right') {
                                        spanEle.prepend(leftPaneButtons);
                                    } else {
                                        spanEle.append(leftPaneButtons);
                                    }
                                }
                                parentViewCtrl.navElement(navElementType, spanEle);
                                callBeforeEnter(parentViewCtrl, eventData, $scope);
                                unregisterViewListener = svController.onViewEvent(function(eventData) {
                                    callBeforeEnter(parentViewCtrl, eventData, $scope);
                                });
                                spanEle = null;
                            }, timeToWait);
                        } else {
                            parentViewCtrl.navElement(navElementType, spanEle.outerHTML);
                            spanEle = null;
                        }
                    } else {
                        navBarCtrl.navElement(navElementType, spanEle.outerHTML);
                        spanEle = null;
                    }
                    $scope.$on('$destroy', function() {
                        if (unregisterViewListener) {
                            unregisterViewListener();
                        }
                    });
                }
            };
        }
    };
}]);

angular.module('mm.core')
.directive('mmNavigationBar', ["$state", "$translate", function($state, $translate) {
    return {
        restrict: 'E',
        scope: {
            previous: '=?',
            next: '=?',
            action: '=?',
            info: '=?',
            component: '@?',
            componentId: '@?'
        },
        templateUrl: 'core/templates/navigationbar.html',
        link: function(scope, element, attrs) {
            scope.title = attrs.title || $translate.instant('mm.core.info');
            scope.showInfo = function() {
                $state.go('site.mm_textviewer', {
                    title: scope.title,
                    content: scope.info,
                    component: attrs.component,
                    componentId: attrs.componentId
                });
            };
        }
    };
}]);

angular.module('mm.core')
.directive('mmNoInputValidation', function() {
    return {
        restrict: 'A',
        priority: 500,
        compile: function(el, attrs) {
            attrs.$set('type',
                null,               
                false               
            );
        }
    }
});

angular.module('mm.core')
.directive('mmRichTextEditor', ["$ionicPlatform", "$mmLang", "$timeout", "$q", "$window", "$ionicScrollDelegate", "$mmUtil", "$mmSite", "$mmFilepool", function($ionicPlatform, $mmLang, $timeout, $q, $window, $ionicScrollDelegate, $mmUtil,
            $mmSite, $mmFilepool) {
    var editorInitialHeightDefault = 300,
        adjustHeightDefault = true,
        frameTags = ['iframe', 'frame', 'object', 'embed'];
        function calculateFixedBarsHeight(editorEl) {
        var ionContentEl = editorEl.parentElement;
        while (ionContentEl && ionContentEl.nodeName != 'ION-CONTENT') {
            ionContentEl = ionContentEl.parentElement;
        }
        if (ionContentEl.nodeName == 'ION-CONTENT') {
            return $window.innerHeight - $mmUtil.getElementHeight(ionContentEl);
        } else {
            return 0;
        }
    }
        function changeLanguageCode(lang) {
        var split = lang.split('-');
        if (split.length > 1) {
            split[1] = split[1].toUpperCase();
            return split.join('_');
        } else {
            return lang;
        }
    }
        function getCKEditorController(element) {
        var ckeditorEl = element.querySelector('textarea[ckeditor]');
        if (ckeditorEl) {
            return angular.element(ckeditorEl).controller('ckeditor');
        }
    }
        function getSurroundingHeight(element, top) {
        var height = 0;
        while (element.parentNode && element.parentNode.tagName != "ION-CONTENT" && (!top || element != top)) {
            var parent = element.parentNode;
            angular.forEach(parent.childNodes, function(child) {
                if (child.tagName && element.tagName && element.tagName != 'MM-LOADING' && child != element) {
                    height += $mmUtil.getElementHeight(child, false, true, true);
                }
            });
            element = parent;
        }
        var cs = getComputedStyle(element);
        height += (parseInt(cs.paddingTop, 10) + parseInt(cs.paddingBottom, 10));
        return height;
    }
        function searchAndFormatWysiwyg(element, component, componentId, tries) {
        if (typeof tries == 'undefined') {
            tries = 0;
        }
        var wysiwygIframe = element.querySelector('.cke_wysiwyg_frame');
        if (wysiwygIframe) {
            treatFrame(wysiwygIframe, component, componentId);
            return $q.when(wysiwygIframe);
        } else if (tries < 5) {
            return $timeout(function() {
                return searchAndFormatWysiwyg(element, component, componentId, tries+1);
            }, 100);
        }
    }
        function treatFrame(element, component, componentId) {
        if (element) {
            var loaded = false;
            element = angular.element(element);
            element.on('load', function() {
                if (!loaded) {
                    loaded = true;
                    treatExternalContent(element, component, componentId);
                    treatSubframes(element, component, componentId);
                }
            });
            $timeout(function() {
                if (!loaded) {
                    loaded = true;
                    treatExternalContent(element, component, componentId);
                    treatSubframes(element, component, componentId);
                }
            }, 1000);
        }
    }
        function treatSubframes(element, component, componentId) {
        var el = element[0],
            contentWindow = element.contentWindow || el.contentWindow,
            contents = element.contents();
        if (!contentWindow && el && el.contentDocument) {
            contentWindow = el.contentDocument.defaultView;
        }
        if (!contentWindow && el && el.getSVGDocument) {
            var svgDoc = el.getSVGDocument();
            if (svgDoc && svgDoc.defaultView) {
                contents = angular.element(svgdoc);
            }
        }
        angular.forEach(frameTags, function(tag) {
            angular.forEach(contents.find(tag), function(subelement) {
                treatFrame(angular.element(subelement), component, componentId);
            });
        });
    }
        function treatExternalContent(element, component, componentId) {
        var elements = element.contents().find('img');
        angular.forEach(elements, function(el) {
            var url = el.src,
                siteId = $mmSite.getId();
            if (!url || !$mmUtil.isDownloadableUrl(url) || (!$mmSite.canDownloadFiles() && $mmUtil.isPluginFileUrl(url))) {
                return;
            }
            return $mmFilepool.getSrcByUrl(siteId, url, component, componentId).then(function(finalUrl) {
                el.setAttribute('src', finalUrl);
            });
        });
    }
    return {
        restrict: 'E',
        templateUrl: 'core/templates/richtexteditor.html',
        scope: {
            model: '=',
            property: '@?',
            placeholder: '@?',
            options: '=?',
            tabletOptions: '=?',
            phoneOptions: '=?',
            scrollHandle: '@?',
            name: '@?',
            textChange: '&?',
            firstRender: '&?',
            component: '@?',
            componentId: '@?',
            required: '@?'
        },
        link: function(scope, element) {
            element = element[0];
            var defaultOptions = {
                    allowedContent: true,
                    defaultLanguage: 'en',
                    height: editorInitialHeightDefault,
                    adjustHeight: adjustHeightDefault,
                    toolbarCanCollapse: true,
                    toolbarStartupExpanded: false,
                    toolbar: [
                        {name: 'basicstyles', items: ['Bold', 'Italic']},
                        {name: 'styles', items: ['Format']},
                        {name: 'links', items: ['Link', 'Unlink']},
                        {name: 'lists', items: ['NumberedList', 'BulletedList']},
                        '/',
                        {name: 'document', items: ['Source', 'RemoveFormat']},
                        {name: 'tools', items: [ 'Maximize' ]}
                    ],
                    toolbarLocation: 'bottom',
                    removePlugins: 'elementspath,resize,pastetext,pastefromword,clipboard,image',
                    removeButtons: ''
                },
                scrollView,
                resized = false,
                fixedBarsHeight,
                component = scope.component,
                componentId = scope.componentId,
                firstChange = true,
                renderTime,
                editorInitialHeight = editorInitialHeightDefault,
                adjustHeight = adjustHeightDefault;
            scope.property = typeof scope.property == 'string' ? scope.property : 'text';
            if (scope.scrollHandle) {
                scrollView = $ionicScrollDelegate.$getByHandle(scope.scrollHandle);
            }
            $mmUtil.isRichTextEditorEnabled().then(function(enabled) {
                var promise;
                scope.richTextEditor = !!enabled;
                renderTime = new Date().getTime();
                if (enabled) {
                    promise = $mmLang.getCurrentLanguage().then(function(lang) {
                        defaultOptions.language = changeLanguageCode(lang);
                    });
                } else {
                    promise = $q.when();
                }
                promise.then(function() {
                    if ($ionicPlatform.isTablet()) {
                        scope.editorOptions = angular.extend(defaultOptions, scope.options, scope.tabletOptions);
                    } else {
                        scope.editorOptions = angular.extend(defaultOptions, scope.options, scope.phoneOptions);
                    }
                    editorInitialHeight = scope.editorOptions.height;
                    adjustHeight = scope.editorOptions.adjustHeight;
                    if (!enabled) {
                        textareaReady();
                    }
                });
            });
            function textareaReady() {
                var editorEl;
                $timeout(function() {
                    if (firstChange) {
                        firstChange = false;
                        editorEl = element.querySelector('.mm-textarea');
                        resizeContentTextarea(editorEl);
                        ionic.on('resize', onResize, window);
                    }
                }, 1000);
                scope.$on('$destroy', function() {
                    ionic.off('resize', onResize, window);
                });
                function onResize() {
                    resizeContentTextarea(editorEl);
                }
            }
            scope.editorReady = function() {
                var collapser = element.querySelector('.cke_toolbox_collapser'),
                    firstButton = element.querySelector('.cke_toolbox_main .cke_toolbar:first-child'),
                    lastButton = element.querySelector('.cke_toolbox_main .cke_toolbar:last-child'),
                    toolbar = element.querySelector('.cke_bottom'),
                    editorEl = element.querySelector('.cke'),
                    contentsEl = element.querySelector('.cke_contents'),
                    sourceCodeButton = element.querySelector('.cke_button__source'),
                    seeingSourceCode = false,
                    wysiwygIframe,
                    unregisterDialogListener,
                    editorController;
                searchAndFormatWysiwyg(element, component, componentId).then(function(iframe) {
                    wysiwygIframe = iframe;
                });
                if (firstButton && lastButton && collapser && toolbar) {
                    if (firstButton.offsetTop == lastButton.offsetTop) {
                        angular.element(collapser).css('display', 'none');
                    }
                    angular.element(collapser).on('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        angular.element(toolbar).toggleClass('cke_expanded');
                        if (resized) {
                            resizeContent(editorEl, contentsEl, toolbar);
                        }
                    });
                }
                if (sourceCodeButton) {
                    angular.element(sourceCodeButton).on('click', function() {
                        $timeout(function() {
                            seeingSourceCode = !seeingSourceCode;
                            if (!seeingSourceCode) {
                                searchAndFormatWysiwyg(element, component, componentId).then(function(iframe) {
                                    wysiwygIframe = iframe;
                                });
                            }
                        });
                    });
                }
                if (scope.richTextEditor) {
                    $timeout(function() {
                        if (firstChange) {
                            if (scope.firstRender) {
                                scope.firstRender();
                            }
                            firstChange = false;
                            resizeContent(editorEl, contentsEl, toolbar);
                        }
                    }, 1000);
                }
                editorController = getCKEditorController(element);
                ionic.on('resize', onResize, window);
                scope.$on('$destroy', function() {
                    if (editorController && editorController.instance) {
                        editorController.instance.destroy(false);
                    }
                    ionic.off('resize', onResize, window);
                    if (unregisterDialogListener) {
                        unregisterDialogListener();
                    }
                });
                function onResize() {
                    resizeContent(editorEl, contentsEl, toolbar);
                    if (firstButton.offsetTop == lastButton.offsetTop) {
                        angular.element(collapser).css('display', 'none');
                    } else {
                        angular.element(collapser).css('display', 'block');
                    }
                }
            };
            scope.onChange = function() {
                if (scope.richTextEditor && firstChange && scope.firstRender && new Date().getTime() - renderTime < 1000) {
                    scope.firstRender();
                }
                firstChange = false;
                if (scope.textChange) {
                    scope.textChange();
                }
            };
                        function resizeContentTextarea(editorEl) {
                var editorHeight = editorInitialHeight,
                    contentVisibleHeight,
                    screenSmallerThanEditor;
                if (typeof fixedBarsHeight == 'undefined') {
                    fixedBarsHeight = calculateFixedBarsHeight(editorEl);
                }
                contentVisibleHeight = $window.innerHeight - fixedBarsHeight;
                if (adjustHeight && contentVisibleHeight > 0) {
                    var topElement,
                        height;
                    if (adjustHeight !== true) {
                        topElement = document.getElementById(adjustHeight);
                        contentVisibleHeight = $mmUtil.getElementHeight(topElement) || contentVisibleHeight;
                    }
                    height = getSurroundingHeight(element, topElement);
                    if (contentVisibleHeight > height) {
                        editorHeight = contentVisibleHeight - height;
                        editorInitialHeight = editorHeight;
                    }
                }
                screenSmallerThanEditor = contentVisibleHeight > 0 && contentVisibleHeight < editorHeight;
                if (resized && !screenSmallerThanEditor) {
                    undoResize(editorEl);
                } else if (editorHeight > 60 && (resized || screenSmallerThanEditor || adjustHeight)) {
                    angular.element(editorEl).css('height', editorHeight + 'px');
                    resized = true;
                }
            }
                        function resizeContent(editorEl, contentsEl, toolbar) {
                var toolbarHeight = $mmUtil.getElementHeight(toolbar),
                    editorWithToolbarHeight = editorInitialHeight + toolbarHeight,
                    contentVisibleHeight,
                    editorContentNewHeight,
                    screenSmallerThanEditor,
                    editorMaximized;
                if (typeof fixedBarsHeight == 'undefined') {
                    fixedBarsHeight = calculateFixedBarsHeight(editorEl);
                }
                editorMaximized = !!editorEl.querySelector('.cke_maximized');
                contentVisibleHeight = $window.innerHeight - fixedBarsHeight;
                if (adjustHeight && !editorMaximized && contentVisibleHeight > 0) {
                    var topElement,
                        height;
                    if (adjustHeight !== true) {
                        topElement = document.getElementById(adjustHeight);
                        contentVisibleHeight = $mmUtil.getElementHeight(topElement) || contentVisibleHeight;
                    }
                    height = getSurroundingHeight(element, topElement);
                    if (contentVisibleHeight > height) {
                        editorWithToolbarHeight = contentVisibleHeight - height;
                        editorInitialHeight = editorWithToolbarHeight - toolbarHeight;
                    }
                }
                screenSmallerThanEditor = !editorMaximized && contentVisibleHeight > 0 &&
                    contentVisibleHeight < editorWithToolbarHeight;
                editorContentNewHeight = editorWithToolbarHeight - toolbarHeight;
                if (resized && !screenSmallerThanEditor) {
                    undoResize(editorEl, contentsEl);
                } else if (editorContentNewHeight > 60 && (resized || screenSmallerThanEditor || adjustHeight)) {
                    angular.element(editorEl).css('height', editorWithToolbarHeight + 'px');
                    angular.element(contentsEl).css('height', editorContentNewHeight + 'px');
                    resized = true;
                    if (scrollView) {
                        var focused = document.activeElement;
                        if (focused) {
                            var parentEditor = $mmUtil.closest(focused, '.cke');
                            if (parentEditor == editorEl) {
                                $mmUtil.scrollToElement(editorEl, undefined, scrollView);
                            }
                        }
                    }
                }
            }
            function undoResize(editorEl, contentsEl) {
                if (contentsEl) {
                    angular.element(editorEl).css('height', '');
                    angular.element(contentsEl).css('height', editorInitialHeight + 'px');
                } else {
                    angular.element(editorEl).css('height', editorInitialHeight + 'px');
                }
                resized = false;
            }
        }
    };
}]);

angular.module('mm.core')
.directive('mmSearchbox', ["$translate", "$mmUtil", function($translate, $mmUtil) {
    return {
        restrict: 'E',
        scope: {
            submitAction: '=',
            initialValue: '@?',
            searchLabel: '@?',
            placeholder: '@?',
            autocorrect: '@?',
            spellcheck: '@?',
            autofocus: '@?',
            lengthCheck: '@?'
        },
        templateUrl: 'core/templates/searchbox.html',
        link: function(scope, element) {
            scope.data = {
                value : scope.initialValue ? scope.initialValue : "",
                placeholder: scope.placeholder ? scope.placeholder : $translate.instant('mm.core.search'),
                autocorrect: scope.autocorrect ? scope.autocorrect : 'on',
                spellcheck: scope.spellcheck ? scope.spellcheck : 'true',
                searchLabel: scope.searchLabel ? scope.searchLabel : $translate.instant('mm.core.search'),
                autofocus: scope.autofocus && scope.autofocus != "false",
                lengthCheck: scope.lengthCheck ? scope.lengthCheck : 3
            };
            scope.seachBoxSubmit = function() {
                if (scope.data.value.length < scope.data.lengthCheck) {
                    return;
                }
                return scope.submitAction(scope.data.value);
            };
        }
    };
}]);

angular.module('mm.core')
.directive('mmShowPassword', ["$compile", function($compile) {
    var buttonHtml = '<a class="button button-clear button-positive icon" aria-label="{{ label | translate }}" ' +
                        'ng-class="{\'ion-eye\': !shown, \'ion-eye-disabled\': shown}" ng-click="toggle()" ' +
                        'mm-keep-keyboard="{{selector}}" keep-in-button="true"></a>';
    return {
        restrict: 'A',
        scope: true,
        link: function(scope, element, attrs) {
            var button;
            if (element[0].id) {
                scope.selector = '#' + element[0].id;
            } else if (element[0].name) {
                scope.selector = element[0].tagName.toLowerCase() + '[name="' + elm[0].name + '"]';
            } else {
                scope.selector = '';
            }
            button = $compile(angular.element(buttonHtml))(scope);
            element.wrap('<div class="item-input-inset mm-show-password-container">');
            element.after(button);
            if (!element.attr('autocorrect')) {
                element.attr('autocorrect', 'off');
            }
            if (!element.attr('autocapitalize')) {
                element.attr('autocapitalize', 'none');
            }
            scope.shown = attrs.initialShown && attrs.initialShown !== 'false';
            setData();
            scope.toggle = function() {
                scope.shown = !scope.shown;
                setData();
            };
            function setData() {
                scope.label = scope.shown ? 'mm.core.hide' : 'mm.core.show';
                element[0].type = scope.shown ? 'text' : 'password';
            }
        }
    };
}]);

angular.module('mm.core')
.directive('mmSitePicker', ["$mmSitesManager", "$mmSite", "$translate", "$mmText", "$q", function($mmSitesManager, $mmSite, $translate, $mmText, $q) {
    return {
        restrict: 'E',
        templateUrl: 'core/templates/sitepicker.html',
        scope: {
            siteSelected: '&',
            initialSite: '@?'
        },
        link: function(scope) {
            scope.selectedSite = scope.initialSite || $mmSite.getId();
            $mmSitesManager.getSites().then(function(sites) {
                var promises = [];
                sites.forEach(function(site) {
                    promises.push($mmText.formatText(site.sitename, true, true).catch(function() {
                        return site.sitename;
                    }).then(function(formatted) {
                        site.fullnameandsitename = $translate.instant('mm.core.fullnameandsitename',
                                {fullname: site.fullname, sitename: formatted});
                    }));
                });
                return $q.all(promises).then(function() {
                    scope.sites = sites;
                });
            });
        }
    };
}]);

angular.module('mm.core')
.constant('mmCoreSplitViewLoad', 'mmSplitView:load')
.constant('mmCoreSplitViewBlock', 'mmSplitView:block')
.controller('mmSplitView', ["$state", "$ionicPlatform", "$timeout", "$interpolate", function($state, $ionicPlatform, $timeout, $interpolate) {
    var self = this,
        element,
        menuState,
        linkToLoad,
        candidateLink,
        component,
        ionicViewEventData,
        viewEventListeners = [],
        headerBarButtons = {},
        headerButtonTypes = ['primary-buttons', 'secondary-buttons', 'left-buttons', 'right-buttons'],
        startTime = new Date().getTime();
        this.clearMarkedLinks = function() {
        angular.element(element.querySelectorAll('[mm-split-view-link]')).removeClass('mm-split-item-selected');
    };
        this.getCandidateLink = function() {
        return candidateLink;
    };
        this.getComponent = function() {
        return component;
    };
        this.getHeaderBarButtons = function(type) {
        if (!type) {
            return headerBarButtons;
        } else {
            return headerBarButtons[type];
        }
    };
        this.getHeaderBarButtonsHtml = function(type) {
        if (headerBarButtons[type]) {
            return headerBarButtons[type].innerHTML;
        }
    };
        this.getHeaderBarWithState = function(state) {
        var bars = document.querySelectorAll('ion-header-bar');
        for (var i = 0; i < bars.length; i++) {
            var bar = bars[i],
                barState = bar.parentElement && bar.parentElement.getAttribute('nav-bar');
            if (barState == state) {
                return bar;
            }
        }
    };
        this.getIonicViewEventData = function() {
        return ionicViewEventData || {};
    };
        this.getMenuState = function() {
        return menuState || $state.current.name;
    };
        this.getInactiveHeaderBar = function() {
        var bars = document.querySelectorAll('ion-header-bar'),
            activePosition = -1;
        for (var i = 0; i < bars.length; i++) {
            var bar = bars[i],
                barState = bar.parentElement && bar.parentElement.getAttribute('nav-bar');
            if (barState == 'active') {
                activePosition = i;
            }
        }
        if (activePosition === 0) {
            return bars[1];
        } else if (activePosition > 0) {
            return bars[0];
        }
    };
        this.getStartTime = function() {
        return startTime;
    };
        this.loadLink = function(scope, loadAttr, retrying) {
        if ($ionicPlatform.isTablet()) {
            if (!linkToLoad) {
                if (typeof loadAttr != 'undefined') {
                    var position = parseInt(loadAttr);
                    if (!position) {
                        position = parseInt($interpolate(loadAttr)(scope), 10);
                    }
                    if (position) {
                        var links = element.querySelectorAll('[mm-split-view-link]');
                        position = position > links.length ? 0 : position - 1;
                        linkToLoad = angular.element(links[position]);
                    } else {
                        linkToLoad = angular.element(element.querySelector('[mm-split-view-link]'));
                    }
                } else {
                    linkToLoad = angular.element(element.querySelector('[mm-split-view-link]'));
                }
            }
            if (!this.triggerClick(linkToLoad)) {
                if (!retrying) {
                    linkToLoad = undefined;
                    $timeout(function() {
                        self.loadLink(scope, loadAttr, true);
                    });
                }
            }
        }
    };
        self.onViewEvent = function(callBack) {
        if (!angular.isFunction(callBack)) {
            return;
        }
        viewEventListeners.push(callBack);
        return function() {
          var position = viewEventListeners.indexOf(callBack);
          if (position !== -1) {
            viewEventListeners.splice(position, 1);
          }
        };
    };
        self.saveHeaderBarButtons = function() {
        var headerBar = this.getHeaderBarWithState('entering');
        if (!headerBar) {
            headerBar = this.getInactiveHeaderBar();
            if (!headerBar) {
                return;
            }
        }
        headerButtonTypes.forEach(function(type) {
            headerBarButtons[type] = headerBar.querySelector('.' + type);
        });
    };
        this.setCandidateLink = function(link) {
        candidateLink = link;
    };
        this.setComponent = function(cmp) {
        component = cmp;
    };
        this.setElement = function(el) {
        element = el;
    };
        this.setLink = function(link) {
        linkToLoad = link;
        this.setCandidateLink(null);
    };
        this.setMenuState = function(state) {
        menuState = state;
    };
        this.setIonicViewEventData = function(data) {
        ionicViewEventData = data;
        angular.forEach(viewEventListeners, function(listener) {
            if (angular.isFunction(listener)) {
                listener(data);
            }
        });
    };
        this.triggerClick = function(link) {
        if (link && link.length && link.triggerHandler) {
            link.triggerHandler('click');
            return true;
        }
        return false;
    };
}])
.directive('mmSplitView', ["$log", "$state", "$ionicPlatform", "$mmUtil", "mmCoreSplitViewLoad", "mmCoreSplitViewBlock", function($log, $state, $ionicPlatform, $mmUtil, mmCoreSplitViewLoad, mmCoreSplitViewBlock) {
    $log = $log.getInstance('mmSplitView');
    return {
        restrict: 'E',
        templateUrl: 'core/templates/splitview.html',
        transclude: true,
        controller: 'mmSplitView',
        link: function(scope, element, attrs, controller) {
            var el = element[0],
                menu = angular.element(el.querySelector('.mm-split-pane-menu')),
                menuState = attrs.menuState || $state.$current.name,
                menuParams = $state.params,
                menuWidth = attrs.menuWidth,
                component = attrs.component || 'tablet',
                stateChangeListener,
                currentBlockFunction,
                leaving = false;
            controller.saveHeaderBarButtons();
            scope.component = component;
            controller.setComponent(component);
            controller.setElement(el);
            controller.setMenuState(menuState);
            if (menuWidth && $ionicPlatform.isTablet()) {
                menu.css('width', menuWidth);
                menu.css('-webkit-flex-basis', menuWidth);
                menu.css('-moz-flex-basis', menuWidth);
                menu.css('-ms-flex-basis', menuWidth);
                menu.css('flex-basis', menuWidth);
            }
            if (attrs.loadWhen) {
                scope.$watch(attrs.loadWhen, function(newValue) {
                    if (newValue) {
                        controller.loadLink(scope, attrs.load);
                    }
                });
            } else {
                controller.loadLink(scope, attrs.load);
            }
            scope.$on('$stateChangeSuccess', function(event, toState, toParams, fromState, fromParams) {
                if (toState.name === menuState && $mmUtil.basicLeftCompare(toParams, menuParams, 1)) {
                    controller.loadLink();
                }
            });
            scope.$on(mmCoreSplitViewLoad, function(e, data) {
                if (data && data.load) {
                    controller.loadLink(scope, data.load);
                } else {
                    controller.loadLink(scope, attrs.load);
                }
            });
            scope.$on('$ionicView.beforeEnter', eventReceived);
            scope.$on('$ionicView.afterEnter', eventReceived);
            scope.$on(mmCoreSplitViewBlock, blockEventReceived);
            function eventReceived(e, data) {
                if (controller.getIonicViewEventData().transitionId != data.transitionId) {
                    controller.setIonicViewEventData(data);
                }
            }
            function blockEventReceived(e, data) {
                if (!data || data.state != menuState || !$mmUtil.basicLeftCompare(data.stateParams, menuParams, 1)) {
                    return;
                }
                if (data.block && data.blockFunction) {
                    stateChangeListener && stateChangeListener();
                    stateChangeListener = scope.$on('$stateChangeStart', function(event, toState, toParams) {
                        event.preventDefault();
                        if (leaving) {
                            return;
                        }
                        leaving = true;
                        data.blockFunction().then(function() {
                            var candidateLink = controller.getCandidateLink();
                            stateChangeListener && stateChangeListener();
                            if (!controller.triggerClick(candidateLink)) {
                                return $state.go(toState.name, toParams);
                            }
                        }).finally(function() {
                            leaving = false;
                            controller.setCandidateLink(null);
                        });
                    });
                } else if (!data.block && currentBlockFunction && currentBlockFunction === data.blockFunction) {
                    stateChangeListener && stateChangeListener();
                }
            }
        }
    };
}]);

angular.module('mm.core')
.directive('mmSplitViewLink', ["$log", "$ionicPlatform", "$state", "$mmApp", function($log, $ionicPlatform, $state, $mmApp) {
    $log = $log.getInstance('mmSplitViewLink');
    var srefRegex = new RegExp(/([^\(]*)(\((.*)\))?$/);
        function createTabletState(stateName, tabletStateName, newViewName) {
        var targetState = $state.get(stateName),
            newConfig,
            viewName;
        if (targetState) {
            newConfig = angular.copy(targetState);
            viewName = Object.keys(newConfig.views)[0];
            newConfig.views[newViewName] = newConfig.views[viewName];
            delete newConfig.views[viewName];
            delete newConfig['name'];
            $mmApp.createState(tabletStateName, newConfig);
            return true;
        } else {
            $log.error('State doesn\'t exist: '+stateName);
            return false;
        }
    }
        function scopeEval(scope, value) {
        if (typeof value == 'string') {
            try {
                return scope.$eval(value);
            } catch(ex) {
                $log.error('Error evaluating string: ' + param);
            }
        }
    }
        function fillStateParams(stateParams, state) {
        if (!stateParams || !state || !state.params) {
            return;
        }
        angular.forEach(state.params, function(defaultValue, name) {
            if (typeof stateParams[name] == 'undefined') {
                stateParams[name] = defaultValue;
            }
        });
    }
    return {
        restrict: 'A',
        require: '^mmSplitView',
        link: function(scope, element, attrs, splitViewController) {
            var sref = attrs.mmSplitViewLink,
                menuState = splitViewController.getMenuState(),
                matches,
                stateName,
                stateParams,
                stateParamsString,
                tabletStateName,
                stateParamsFilled = false;
            if (sref) {
                matches = sref.match(srefRegex);
                if (matches && matches.length) {
                    stateName = matches[1];
                    tabletStateName = menuState + '.' + stateName.substr(stateName.lastIndexOf('.') + 1);
                    stateParamsString = matches[3];
                    stateParams = scopeEval(scope, stateParamsString);
                    scope.$watch(stateParamsString, function(newVal) {
                        stateParams = newVal;
                        fillStateParams(stateParams, $state.get(tabletStateName));
                    });
                    element.on('click', function(event) {
                        event.stopPropagation();
                        event.preventDefault();
                        if ($ionicPlatform.isTablet()) {
                            if (!$state.get(tabletStateName)) {
                                if (!createTabletState(stateName, tabletStateName, splitViewController.getComponent())) {
                                    return;
                                }
                            }
                            if (!stateParamsFilled) {
                                fillStateParams(stateParams, $state.get(tabletStateName));
                                stateParamsFilled = true;
                            }
                            splitViewController.setCandidateLink(element);
                            $state.go(tabletStateName, stateParams, {location:'replace'}).then(function() {
                                splitViewController.setLink(element);
                                splitViewController.clearMarkedLinks();
                                element.addClass('mm-split-item-selected');
                            });
                        } else {
                            $state.go(stateName, stateParams);
                        }
                    });
                } else {
                    $log.error('Invalid sref.');
                }
            } else {
                $log.error('Invalid sref.');
            }
        }
    };
}]);

angular.module('mm.core')
.directive('mmStateClass', ["$state", function($state) {
    return {
        restrict: 'A',
        link: function(scope, el) {
            var current = $state.$current.name,
                split,
                className = 'mm-';
            if (typeof current == 'string') {
                split = current.split('.');
                className += split.shift();
                if (split.length) {
                    className += '_' + split.pop();
                }
                el.addClass(className);
            }
        }
    };
}]);

angular.module('mm.core')
.directive('mmTimer', ["$interval", "$mmUtil", function($interval, $mmUtil) {
    return {
        restrict: 'E',
        scope: {
            endTime: '=',
            finished: '&'
        },
        templateUrl: 'core/templates/timer.html',
        link: function(scope, element, attrs) {
            if (!scope.endTime || !scope.finished) {
                return;
            }
            var timeLeftClass = attrs.timeLeftClass || 'mm-timer-timeleft-',
                timeInterval;
            element.addClass('mm-timer');
            scope.text = attrs.timerText || '';
            timeInterval = $interval(function() {
                scope.timeLeft = scope.endTime - $mmUtil.timestamp();
                if (scope.timeLeft < 0) {
                    $interval.cancel(timeInterval);
                    scope.finished();
                    return;
                }
                if (scope.timeLeft < 100 && !element.hasClass(timeLeftClass + scope.timeLeft)) {
                    element.removeClass(timeLeftClass + (scope.timeLeft + 1));
                    element.removeClass(timeLeftClass + (scope.timeLeft + 2));
                    element.addClass(timeLeftClass + scope.timeLeft);
                }
            }, 200);
            scope.$on('$destroy', function() {
                if (timeInterval) {
                    $interval.cancel(timeInterval);
                }
            });
        }
    };
}]);

angular.module('mm.core.comments', [])
.config(["$stateProvider", function($stateProvider) {
    $stateProvider
    .state('site.mm_commentviewer', {
        url: '/mm_commentviewer',
        params : {
            contextLevel: null,
            instanceId: null,
            component: null,
            itemId: null,
            area: null,
            page: null,
            title: null
        },
        views: {
            'site': {
                templateUrl: 'core/components/comments/templates/commentviewer.html',
                controller: 'mmCommentViewerCtrl'
            }
        }
    });
}]);

angular.module('mm.core.contentlinks', [])
.config(["$stateProvider", function($stateProvider) {
    $stateProvider
    .state('mm_contentlinks', {
        url: '/mm_contentlinks',
        abstract: true,
        templateUrl: 'core/components/contentlinks/templates/base.html',
        cache: false,  
    })
    .state('mm_contentlinks.choosesite', {
        url: '/choosesite',
        templateUrl: 'core/components/contentlinks/templates/choosesite.html',
        controller: 'mmContentLinksChooseSiteCtrl',
        params: {
            url: null
        }
    });
}])
.run(["$log", "$mmURLDelegate", "$mmContentLinksHelper", function($log, $mmURLDelegate, $mmContentLinksHelper) {
    $log = $log.getInstance('mmContentLinks');
    $mmURLDelegate.register('mmContentLinks', $mmContentLinksHelper.handleCustomUrl);
}]);

angular.module('mm.core.course', ['mm.core.courses'])
.constant('mmCoreCoursePriority', 800)
.constant('mmCoreCourseAllSectionsId', -1)
.config(["$stateProvider", "$mmCoursesDelegateProvider", "mmCoreCoursePriority", function($stateProvider, $mmCoursesDelegateProvider, mmCoreCoursePriority) {
    $stateProvider
    .state('site.mm_course', {
        url: '/mm_course',
        params: {
            courseid: null,
            sid: null,
            moduleid: null,
            coursefullname: null
        },
        views: {
            'site': {
                templateUrl: 'core/components/course/templates/sections.html',
                controller: 'mmCourseSectionsCtrl'
            }
        }
    })
    .state('site.mm_course-section', {
        url: '/mm_course-section',
        params: {
            sectionid: null,
            cid: null,
            mid: null
        },
        views: {
            'site': {
                templateUrl: 'core/components/course/templates/section.html',
                controller: 'mmCourseSectionCtrl'
            }
        }
    })
    .state('site.mm_course-modcontent', {
        url: '/mm_course-modcontent',
        params: {
            module: null
        },
        views: {
            site: {
                templateUrl: 'core/components/course/templates/modcontent.html',
                controller: 'mmCourseModContentCtrl'
            }
        }
    });
}])
.run(["$mmEvents", "mmCoreEventLogin", "mmCoreEventSiteUpdated", "$mmCourseDelegate", "mmCoreEventRemoteAddonsLoaded", function($mmEvents, mmCoreEventLogin, mmCoreEventSiteUpdated, $mmCourseDelegate, mmCoreEventRemoteAddonsLoaded) {
    $mmEvents.on(mmCoreEventLogin, $mmCourseDelegate.updateContentHandlers);
    $mmEvents.on(mmCoreEventSiteUpdated, $mmCourseDelegate.updateContentHandlers);
    $mmEvents.on(mmCoreEventRemoteAddonsLoaded, $mmCourseDelegate.updateContentHandlers);
}]);

angular.module('mm.core.courses', ['mm.core.contentlinks'])
.constant('mmCoursesSearchComponent', 'mmCoursesSearch')
.constant('mmCoursesSearchPerPage', 20)
.constant('mmCoursesEnrolInvalidKey', 'mmCoursesEnrolInvalidKey')
.constant('mmCoursesEventMyCoursesUpdated', 'my_courses_updated')
.constant('mmCoursesEventMyCoursesRefreshed', 'my_courses_refreshed')
.constant('mmCoursesAccessMethods', {
     guest: 'guest',
     default: 'default'
})
.config(["$stateProvider", function($stateProvider) {
    $stateProvider
    .state('site.mm_courses', {
        url: '/mm_courses',
        views: {
            'site': {
                templateUrl: 'core/components/courses/templates/list.html',
                controller: 'mmCoursesListCtrl'
            }
        }
    })
    .state('site.mm_searchcourses', {
        url: '/mm_searchcourses',
        views: {
            'site': {
                templateUrl: 'core/components/courses/templates/search.html',
                controller: 'mmCoursesSearchCtrl'
            }
        }
    })
    .state('site.mm_viewresult', {
        url: '/mm_viewresult',
        params: {
            course: null
        },
        views: {
            'site': {
                templateUrl: 'core/components/courses/templates/viewresult.html',
                controller: 'mmCoursesViewResultCtrl'
            }
        }
    })
    .state('site.mm_coursescategories', {
        url: '/mm_coursescategories',
        params: {
            categoryid: null
        },
        views: {
            'site': {
                templateUrl: 'core/components/courses/templates/coursecategories.html',
                controller: 'mmCourseCategoriesCtrl'
            }
        }
    })
    .state('site.mm_availablecourses', {
        url: '/mm_availablecourses',
        views: {
            'site': {
                templateUrl: 'core/components/courses/templates/availablecourses.html',
                controller: 'mmCoursesAvailableCtrl'
            }
        }
    });
}])
.config(["$mmContentLinksDelegateProvider", function($mmContentLinksDelegateProvider) {
    $mmContentLinksDelegateProvider.registerLinkHandler('mmCourses:courses', '$mmCoursesHandlers.coursesLinksHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmCourses:course', '$mmCoursesHandlers.courseLinksHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmCourses:dashboard', '$mmCoursesHandlers.dashboardLinksHandler');
}])
.run(["$mmEvents", "mmCoreEventLogin", "mmCoreEventSiteUpdated", "mmCoreEventLogout", "$mmCoursesDelegate", "$mmCourses", "mmCoreEventRemoteAddonsLoaded", function($mmEvents, mmCoreEventLogin, mmCoreEventSiteUpdated, mmCoreEventLogout, $mmCoursesDelegate, $mmCourses,
            mmCoreEventRemoteAddonsLoaded) {
    $mmEvents.on(mmCoreEventLogin, $mmCoursesDelegate.updateNavHandlers);
    $mmEvents.on(mmCoreEventSiteUpdated, $mmCoursesDelegate.updateNavHandlers);
    $mmEvents.on(mmCoreEventRemoteAddonsLoaded, $mmCoursesDelegate.updateNavHandlers);
    $mmEvents.on(mmCoreEventLogout, function() {
        $mmCoursesDelegate.clearCoursesHandlers();
        $mmCourses.clearCurrentCourses();
    });
}]);

angular.module('mm.core.fileuploader', ['mm.core'])
.constant('mmFileUploaderAlbumPriority', 2000)
.constant('mmFileUploaderCameraPriority', 1800)
.constant('mmFileUploaderAudioPriority', 1600)
.constant('mmFileUploaderVideoPriority', 1400)
.constant('mmFileUploaderFilePriority', 1200)
.config(["$mmFileUploaderDelegateProvider", "mmFileUploaderAlbumPriority", "mmFileUploaderCameraPriority", "mmFileUploaderAudioPriority", "mmFileUploaderVideoPriority", "mmFileUploaderFilePriority", function($mmFileUploaderDelegateProvider, mmFileUploaderAlbumPriority, mmFileUploaderCameraPriority,
            mmFileUploaderAudioPriority, mmFileUploaderVideoPriority, mmFileUploaderFilePriority) {
    $mmFileUploaderDelegateProvider.registerHandler('mmFileUploaderAlbum',
                '$mmFileUploaderHandlers.albumFilePicker', mmFileUploaderAlbumPriority);
    $mmFileUploaderDelegateProvider.registerHandler('mmFileUploaderCamera',
                '$mmFileUploaderHandlers.cameraFilePicker', mmFileUploaderCameraPriority);
    $mmFileUploaderDelegateProvider.registerHandler('mmFileUploaderAudio',
                '$mmFileUploaderHandlers.audioFilePicker', mmFileUploaderAudioPriority);
    $mmFileUploaderDelegateProvider.registerHandler('mmFileUploaderVideo',
                '$mmFileUploaderHandlers.videoFilePicker', mmFileUploaderVideoPriority);
    $mmFileUploaderDelegateProvider.registerHandler('mmFileUploaderFile',
                '$mmFileUploaderHandlers.filePicker', mmFileUploaderFilePriority);
}])
.run(["$mmEvents", "mmCoreEventLogin", "mmCoreEventSiteUpdated", "mmCoreEventLogout", "$mmFileUploaderDelegate", "mmCoreEventRemoteAddonsLoaded", function($mmEvents, mmCoreEventLogin, mmCoreEventSiteUpdated, mmCoreEventLogout, $mmFileUploaderDelegate,
            mmCoreEventRemoteAddonsLoaded) {
    $mmEvents.on(mmCoreEventLogin, $mmFileUploaderDelegate.updateHandlers);
    $mmEvents.on(mmCoreEventSiteUpdated, $mmFileUploaderDelegate.updateHandlers);
    $mmEvents.on(mmCoreEventRemoteAddonsLoaded, $mmFileUploaderDelegate.updateHandlers);
    $mmEvents.on(mmCoreEventLogout, $mmFileUploaderDelegate.clearSiteHandlers);
}]);

angular.module('mm.core.grades', [])
.config(["$stateProvider", function($stateProvider) {
    $stateProvider
    .state('site.grades', {
        url: '/grades',
        views: {
            'site': {
                templateUrl: 'core/components/grades/templates/table.html',
                controller: 'mmGradesTableCtrl'
            }
        },
        params: {
            course: null,
            userid: null,
            courseid: null,
            forcephoneview: null
        }
    })
    .state('site.grade', {
        url: '/grade',
        views: {
            'site': {
                templateUrl: 'core/components/grades/templates/grade.html',
                controller: 'mmGradesGradeCtrl'
            }
        },
        params: {
            courseid: null,
            userid: null,
            gradeid: null
        }
    });
}]);

angular.module('mm.core.login', [])
.constant('mmCoreLoginTokenChangePassword', '*changepassword*')
.config(["$stateProvider", "$urlRouterProvider", "$mmInitDelegateProvider", "mmInitDelegateMaxAddonPriority", function($stateProvider, $urlRouterProvider, $mmInitDelegateProvider, mmInitDelegateMaxAddonPriority) {
    $stateProvider
    .state('mm_login', {
        url: '/mm_login',
        abstract: true,
        templateUrl: 'core/components/login/templates/base.html',
        cache: false,  
        onEnter: ["$ionicHistory", function($ionicHistory) {
            $ionicHistory.clearHistory();
        }]
    })
    .state('mm_login.init', {
        url: '/init',
        templateUrl: 'core/components/login/templates/init.html',
        controller: 'mmLoginInitCtrl',
        cache: false
    })
    .state('mm_login.sites', {
        url: '/sites',
        templateUrl: 'core/components/login/templates/sites.html',
        controller: 'mmLoginSitesCtrl',
        onEnter: ["$mmLoginHelper", "$mmSitesManager", function($mmLoginHelper, $mmSitesManager) {
            $mmSitesManager.hasNoSites().then(function() {
                $mmLoginHelper.goToAddSite();
            });
        }]
    })
    .state('mm_login.site', {
        url: '/site',
        templateUrl: 'core/components/login/templates/site.html',
        controller: 'mmLoginSiteCtrl'
    })
    .state('mm_login.credentials', {
        url: '/cred',
        templateUrl: 'core/components/login/templates/credentials.html',
        controller: 'mmLoginCredentialsCtrl',
        params: {
            siteurl: '',
            username: '',
            urltoopen: '',
            siteconfig: null
        },
        onEnter: ["$state", "$stateParams", function($state, $stateParams) {
            if (!$stateParams.siteurl) {
              $state.go('mm_login.init');
            }
        }]
    })
    .state('mm_login.reconnect', {
        url: '/reconnect',
        templateUrl: 'core/components/login/templates/reconnect.html',
        controller: 'mmLoginReconnectCtrl',
        cache: false,
        params: {
            siteurl: '',
            username: '',
            infositeurl: '',
            siteid: '',
            statename: null,
            stateparams: null
        }
    })
    .state('mm_login.email_signup', {
        url: '/email_signup',
        templateUrl: 'core/components/login/templates/emailsignup.html',
        controller: 'mmLoginEmailSignupCtrl',
        cache: false,
        params: {
            siteurl: ''
        }
    })
    .state('mm_login.sitepolicy', {
        url: '/sitepolicy',
        templateUrl: 'core/components/login/templates/sitepolicy.html',
        controller: 'mmLoginSitePolicyCtrl',
        cache: false,
        params: {
            siteid: ''
        }
    });
    $urlRouterProvider.otherwise(function($injector) {
        var $state = $injector.get('$state');
        return $state.href('mm_login.init').replace('#', '');
    });
    $mmInitDelegateProvider.registerProcess('mmLogin', '$mmSitesManager.restoreSession', mmInitDelegateMaxAddonPriority + 200);
}])
.run(["$log", "$state", "$mmUtil", "$translate", "$mmSitesManager", "$rootScope", "$mmSite", "$mmURLDelegate", "$ionicHistory", "$timeout", "$mmEvents", "$mmLoginHelper", "mmCoreEventSessionExpired", "$mmApp", "$ionicPlatform", "mmCoreConfigConstants", "$mmText", "mmCoreEventPasswordChangeForced", "mmCoreEventUserNotFullySetup", "mmCoreEventSitePolicyNotAgreed", "$q", function($log, $state, $mmUtil, $translate, $mmSitesManager, $rootScope, $mmSite, $mmURLDelegate, $ionicHistory, $timeout,
                $mmEvents, $mmLoginHelper, mmCoreEventSessionExpired, $mmApp, $ionicPlatform, mmCoreConfigConstants, $mmText,
                mmCoreEventPasswordChangeForced, mmCoreEventUserNotFullySetup, mmCoreEventSitePolicyNotAgreed, $q) {
    $log = $log.getInstance('mmLogin');
    var isSSOConfirmShown = false,
        isOpenEditAlertShown = false,
        waitingForBrowser = false,
        lastInAppUrl;
    $mmEvents.on(mmCoreEventSessionExpired, sessionExpired);
    $mmEvents.on(mmCoreEventPasswordChangeForced, function(siteId) {
        openInAppForEdit(siteId, '/login/change_password.php', 'mm.core.forcepasswordchangenotice');
    });
    $mmEvents.on(mmCoreEventUserNotFullySetup, function(siteId) {
        openInAppForEdit(siteId, '/user/edit.php', 'mm.core.usernotfullysetup');
    });
    $mmEvents.on(mmCoreEventSitePolicyNotAgreed, function(siteId) {
        siteId = siteId || $mmSite.getId();
        if (!siteId || siteId != $mmSite.getId()) {
            return;
        }
        if (!$mmSite.wsAvailable('core_user_agree_site_policy')) {
            return;
        }
        $ionicHistory.nextViewOptions({disableBack: true});
        $state.go('mm_login.sitepolicy', {
            siteid: siteId
        });
    });
    $mmURLDelegate.register('mmLoginSSO', appLaunchedByURL);
    $rootScope.$on('$cordovaInAppBrowser:loadstart', function(e, event) {
        var url = event.url.replace(/^https?:\/\//, '');
        if (appLaunchedByURL(url)) {
            $mmUtil.closeInAppBrowser();
        } else if (ionic.Platform.isAndroid()) {
            var urlScheme = $mmText.getUrlProtocol(url);
            if (urlScheme && urlScheme !== 'file' && urlScheme !== 'cdvfile') {
                $mmUtil.openInBrowser(url);
                if (lastInAppUrl) {
                    $mmUtil.openInApp(lastInAppUrl);
                } else {
                    $mmUtil.closeInAppBrowser();
                }
            } else {
                lastInAppUrl = event.url;
            }
        }
    });
    $rootScope.$on('$cordovaInAppBrowser:exit', function() {
        waitingForBrowser = false;
        lastInAppUrl = false;
        checkLogout();
    });
    $ionicPlatform.on('resume', function() {
        $timeout(function() {
            waitingForBrowser = false;
            checkLogout();
        }, 1000);
    });
    $rootScope.$on('$stateChangeStart', function(event, toState, toParams, fromState, fromParams) {
        if (!$mmApp.isReady() && toState.name !== 'mm_login.init') {
            event.preventDefault();
            $state.transitionTo('mm_login.init');
            $log.warn('Forbidding state change to \'' + toState.name + '\'. App is not ready yet.');
            return;
        }
        var isLoginStateWithSession = toState.name === 'mm_login.reconnect' || toState.name === 'mm_login.sitepolicy';
        if (toState.name.substr(0, 8) === 'redirect' || toState.name.substr(0, 15) === 'mm_contentlinks') {
            return;
        } else if ((toState.name.substr(0, 8) !== 'mm_login' || isLoginStateWithSession) && !$mmSite.isLoggedIn()) {
            event.preventDefault();
            $log.debug('Redirect to login page, request was: ' + toState.name);
            $ionicHistory.nextViewOptions({
                disableAnimate: true,
                disableBack: true
            });
            $state.transitionTo('mm_login.init');
        } else if (toState.name.substr(0, 8) === 'mm_login' && !isLoginStateWithSession && $mmSite.isLoggedIn()) {
            event.preventDefault();
            $log.debug('Redirect to course page, request was: ' + toState.name);
            $ionicHistory.nextViewOptions({
                disableAnimate: true,
                disableBack: true
            });
            $mmLoginHelper.goToSiteInitialPage();
        }
    });
    function sessionExpired(data) {
        var siteId = data && data.siteid,
            siteUrl = $mmSite.getURL(),
            promise;
        if (typeof(siteUrl) === 'undefined') {
            return;
        }
        if (siteId && siteId !== $mmSite.getId()) {
            return;
        }
        $mmSitesManager.checkSite(siteUrl).then(function(result) {
            if (result.warning) {
                $mmUtil.showErrorModal(result.warning, true, 4000);
            }
            if ($mmLoginHelper.isSSOLoginNeeded(result.code)) {
                if (!$mmApp.isSSOAuthenticationOngoing() && !isSSOConfirmShown && !waitingForBrowser) {
                    isSSOConfirmShown = true;
                    if ($mmLoginHelper.shouldShowSSOConfirm(result.code)) {
                        promise = $mmUtil.showConfirm($translate.instant(
                                'mm.login.' + ($mmSite.isLoggedOut() ? 'loggedoutssodescription' : 'reconnectssodescription')));
                    } else {
                        promise = $q.when();
                    }
                    promise.then(function() {
                        waitingForBrowser = true;
                        $mmLoginHelper.openBrowserForSSOLogin(result.siteurl, result.code, result.service,
                                result.config && result.config.launchurl, data.statename, data.stateparams);
                    }).catch(function() {
                        logout();
                    }).finally(function() {
                        isSSOConfirmShown = false;
                    });
                }
            } else {
                var info = $mmSite.getInfo();
                if (typeof info != 'undefined' && typeof info.username != 'undefined') {
                    $ionicHistory.nextViewOptions({disableBack: true});
                    $state.go('mm_login.reconnect', {
                        siteurl: result.siteurl,
                        username: info.username,
                        infositeurl: info.siteurl,
                        siteid: siteId,
                        statename: data.statename,
                        stateparams: data.stateparams
                    });
                }
            }
        }).catch(function(error) {
            if ($mmSite.isLoggedOut()) {
                $mmUtil.showErrorModalDefault(error, 'mm.core.networkerrormsg', true);
                logout();
            }
        });
    }
    function openInAppForEdit(siteId, path, alertMessage) {
        if (!siteId || siteId !== $mmSite.getId()) {
            return;
        }
        var siteUrl = $mmSite.getURL();
        if (!siteUrl) {
            return;
        }
        if (!isOpenEditAlertShown && !waitingForBrowser) {
            isOpenEditAlertShown = true;
            $mmSite.invalidateWsCache();
            alertMessage = $translate.instant(alertMessage) + '<br>' + $translate.instant('mm.core.redirectingtosite');
            return $mmSite.openInAppWithAutoLogin(siteUrl + path, undefined, alertMessage).then(function() {
                waitingForBrowser = true;
            }).finally(function() {
                isOpenEditAlertShown = false;
            });
        }
    }
    function appLaunchedByURL(url) {
        var ssoScheme = mmCoreConfigConstants.customurlscheme + '://token=';
        if (url.indexOf(ssoScheme) == -1) {
            return false;
        }
        if ($mmApp.isSSOAuthenticationOngoing()) {
            return true;
        }
        $mmApp.startSSOAuthentication();
        $log.debug('App launched by URL');
        var modal = $mmUtil.showModalLoading('mm.login.authenticating', true),
            siteData;
        url = url.replace(ssoScheme, '');
        try {
            url = atob(url);
        } catch(err) {
            $log.error('Error decoding parameter received for login SSO');
            return false;
        }
        $mmApp.ready().then(function() {
            return $mmLoginHelper.validateBrowserSSOLogin(url);
        }).then(function(data) {
            siteData = data;
            return $mmLoginHelper.handleSSOLoginAuthentication(siteData.siteurl, siteData.token, siteData.privateToken);
        }).then(function() {
            if (siteData.statename) {
                $state.go(siteData.statename, siteData.stateparams);
            } else {
                $mmLoginHelper.goToSiteInitialPage();
            }
        }).catch(function(errorMessage) {
            if (typeof errorMessage === 'string' && errorMessage !== '') {
                $mmUtil.showErrorModal(errorMessage);
            }
        }).finally(function() {
            modal.dismiss();
            $mmApp.finishSSOAuthentication();
        });
        return true;
    }
    function checkLogout() {
        if (!$mmApp.isSSOAuthenticationOngoing() && $mmSite.isLoggedIn() && $mmSite.isLoggedOut() &&
                $state.current.name != 'mm_login.reconnect') {
            logout();
        }
    }
    function logout() {
        $mmSitesManager.logout().then(function() {
            $ionicHistory.nextViewOptions({
                disableAnimate: true,
                disableBack: true
            });
            $state.go('mm_login.sites');
        });
    }
}]);

angular.module('mm.core.question', [])
.constant('mmQuestionComponent', 'mmQuestion')
.run(["$mmEvents", "mmCoreEventLogin", "mmCoreEventSiteUpdated", "$mmQuestionDelegate", "$mmQuestionBehaviourDelegate", "mmCoreEventRemoteAddonsLoaded", function($mmEvents, mmCoreEventLogin, mmCoreEventSiteUpdated, $mmQuestionDelegate, $mmQuestionBehaviourDelegate,
			mmCoreEventRemoteAddonsLoaded) {
	function updateHandlers() {
		$mmQuestionDelegate.updateQuestionHandlers();
		$mmQuestionBehaviourDelegate.updateQuestionBehaviourHandlers();
	}
	$mmEvents.on(mmCoreEventLogin, updateHandlers);
	$mmEvents.on(mmCoreEventSiteUpdated, updateHandlers);
	$mmEvents.on(mmCoreEventRemoteAddonsLoaded, updateHandlers);
}]);

angular.module('mm.core.settings', [])
.constant('mmCoreSettingsReportInBackground', 'mmCoreReportInBackground')
.constant('mmCoreSettingsRichTextEditor', 'mmCoreSettingsRichTextEditor')
.constant('mmCoreSettingsSyncOnlyOnWifi', 'mmCoreSyncOnlyOnWifi')
.config(["$stateProvider", function($stateProvider) {
    $stateProvider
    .state('site.mm_settings', {
        url: '/mm_settings',
        views: {
            'site': {
                templateUrl: 'core/components/settings/templates/list.html',
                controller: 'mmSettingsListCtrl'
            }
        }
    })
    .state('site.mm_settings-about', {
        url: '/mm_settings-about',
        views: {
            'site': {
                templateUrl: 'core/components/settings/templates/about.html',
                controller: 'mmSettingsAboutCtrl'
            }
        }
    })
    .state('site.mm_settings-general', {
        url: '/mm_settings-general',
        views: {
            'site': {
                templateUrl: 'core/components/settings/templates/general.html',
                controller: 'mmSettingsGeneralCtrl'
            }
        }
    })
    .state('site.mm_settings-spaceusage', {
        url: '/mm_settings-spaceusage',
        views: {
            'site': {
                templateUrl: 'core/components/settings/templates/space-usage.html',
                controller: 'mmSettingsSpaceUsageCtrl'
            }
        }
    })
    .state('site.mm_settings-synchronization', {
        url: '/mm_settings-synchronization',
        views: {
            'site': {
                templateUrl: 'core/components/settings/templates/synchronization.html',
                controller: 'mmSettingsSynchronizationCtrl'
            }
        }
    });
}])
.run(["$mmEvents", "mmCoreEventLogin", "mmCoreEventSiteUpdated", "mmCoreEventLogout", "$mmSettingsDelegate", "mmCoreEventRemoteAddonsLoaded", function($mmEvents, mmCoreEventLogin, mmCoreEventSiteUpdated, mmCoreEventLogout, $mmSettingsDelegate,
            mmCoreEventRemoteAddonsLoaded) {
    $mmEvents.on(mmCoreEventLogin, $mmSettingsDelegate.updateHandlers);
    $mmEvents.on(mmCoreEventSiteUpdated, $mmSettingsDelegate.updateHandlers);
    $mmEvents.on(mmCoreEventRemoteAddonsLoaded, $mmSettingsDelegate.updateHandlers);
    $mmEvents.on(mmCoreEventLogout, $mmSettingsDelegate.clearSiteHandlers);
}]);

angular.module('mm.core.sharedfiles', ['mm.core'])
.constant('mmSharedFilesFolder', 'sharedfiles')
.constant('mmSharedFilesStore', 'shared_files')
.constant('mmSharedFilesEventFileShared', 'file_shared')
.constant('mmSharedFilesPickerPriority', 1000)
.config(["$stateProvider", "$mmFileUploaderDelegateProvider", "mmSharedFilesPickerPriority", function($stateProvider, $mmFileUploaderDelegateProvider, mmSharedFilesPickerPriority) {
    var chooseSiteState = {
            url: '/sharedfiles-choose-site',
            params: {
                filepath: null
            }
        },
        chooseSiteView = {
            controller: 'mmSharedFilesChooseSiteCtrl',
            templateUrl: 'core/components/sharedfiles/templates/choosesite.html'
        };
    $stateProvider
    .state('site.sharedfiles-choose-site', angular.extend(angular.copy(chooseSiteState), {
        views: {
            'site': chooseSiteView
        }
    }))
    .state('mm_login.sharedfiles-choose-site', angular.extend(angular.copy(chooseSiteState), chooseSiteView))
    .state('site.sharedfiles-list', {
        url: '/sharedfiles-list',
        params: {
            path: null,
            manage: false,
            pick: false
        },
        views: {
            'site': {
                templateUrl: 'core/components/sharedfiles/templates/list.html',
                controller: 'mmSharedFilesListCtrl'
            }
        }
    });
    $mmFileUploaderDelegateProvider.registerHandler('mmSharedFiles',
                '$mmSharedFilesHandlers.filePicker', mmSharedFilesPickerPriority);
}])
.run(["$mmSharedFilesHelper", "$ionicPlatform", function($mmSharedFilesHelper, $ionicPlatform) {
    if (ionic.Platform.isIOS()) {
        $ionicPlatform.on('resume', $mmSharedFilesHelper.searchIOSNewSharedFiles);
        $mmSharedFilesHelper.searchIOSNewSharedFiles();
    }
}]);

angular.module('mm.core.sidemenu', [])
.config(["$stateProvider", function($stateProvider) {
    $stateProvider
    .state('site', {
        url: '/site',
        templateUrl: 'core/components/sidemenu/templates/menu.html',
        controller: 'mmSideMenuCtrl',
        abstract: true,
        cache: false,
        onEnter: ["$ionicHistory", "$state", "$mmSite", function($ionicHistory, $state, $mmSite) {
            $ionicHistory.clearHistory();
            if (!$mmSite.isLoggedIn()) {
                $state.go('mm_login.init');
            }
        }]
    })
    .state('site.iframe-view', {
        url: '/iframe-view',
        params: {
            title: null,
            url: null
        },
        views: {
            'site': {
                templateUrl: 'core/components/sidemenu/templates/iframe.html',
                controller: 'mmSideMenuIframeViewCtrl'
            }
        }
    });
}])
.run(["$mmEvents", "mmCoreEventLogin", "mmCoreEventSiteUpdated", "mmCoreEventLogout", "$mmSideMenuDelegate", "mmCoreEventRemoteAddonsLoaded", function($mmEvents, mmCoreEventLogin, mmCoreEventSiteUpdated, mmCoreEventLogout, $mmSideMenuDelegate,
            mmCoreEventRemoteAddonsLoaded) {
    $mmEvents.on(mmCoreEventLogin, $mmSideMenuDelegate.updateNavHandlers);
    $mmEvents.on(mmCoreEventSiteUpdated, $mmSideMenuDelegate.updateNavHandlers);
    $mmEvents.on(mmCoreEventRemoteAddonsLoaded, $mmSideMenuDelegate.updateNavHandlers);
    $mmEvents.on(mmCoreEventLogout, $mmSideMenuDelegate.clearSiteHandlers);
}]);

angular.module('mm.core.textviewer', [])
.config(["$stateProvider", function($stateProvider) {
    $stateProvider
    .state('site.mm_textviewer', {
        url: '/mm_textviewer',
        params: {
            title: null,
            content: null,
            replacelinebreaks: null,
            component: null,
            componentId: null
        },
        views: {
            'site': {
                templateUrl: 'core/components/textviewer/templates/textviewer.html',
                controller: 'mmTextViewerIndexCtrl'
            }
        }
    });
}]);

angular.module('mm.core.user', ['mm.core.contentlinks'])
.constant('mmUserEventProfileRefreshed', 'user_profile_refreshed')
.constant('mmUserProfilePictureUpdated', 'user_profile_picture_updated')
.constant('mmUserProfileHandlersTypeNewPage', 'newpage')
.constant('mmUserProfileHandlersTypeCommunication', 'communication')
.constant('mmUserProfileHandlersTypeAction', 'action')
.constant('mmUserPriority', 700)
.value('mmUserProfileState', 'site.mm_user-profile')
.config(["$stateProvider", "$mmContentLinksDelegateProvider", "$mmUserDelegateProvider", "mmUserPriority", function($stateProvider, $mmContentLinksDelegateProvider, $mmUserDelegateProvider, mmUserPriority) {
    $stateProvider
        .state('site.mm_user-profile', {
            url: '/mm_user-profile',
            views: {
                'site': {
                    controller: 'mmUserProfileCtrl',
                    templateUrl: 'core/components/user/templates/profile.html'
                }
            },
            params: {
                courseid: 0,
                userid: 0
            }
        })
        .state('site.mm_user-about', {
            url: '/mm_user-about',
            views: {
                'site': {
                    controller: 'mmUserAboutCtrl',
                    templateUrl: 'core/components/user/templates/about.html'
                }
            },
            params: {
                courseid: 0,
                userid: 0
            }
        });
    $mmContentLinksDelegateProvider.registerLinkHandler('mmUser', '$mmUserHandlers.linksHandler');
    $mmUserDelegateProvider.registerProfileHandler('mmUser', '$mmUserHandlers.userEmail', mmUserPriority);
}])
.run(["$mmEvents", "mmCoreEventLogin", "mmCoreEventSiteUpdated", "$mmUserDelegate", "$mmSite", "mmCoreEventUserDeleted", "$mmUser", "mmCoreEventRemoteAddonsLoaded", "$mmUserProfileFieldsDelegate", function($mmEvents, mmCoreEventLogin, mmCoreEventSiteUpdated, $mmUserDelegate, $mmSite, mmCoreEventUserDeleted, $mmUser,
            mmCoreEventRemoteAddonsLoaded, $mmUserProfileFieldsDelegate) {
    function updateHandlers() {
        $mmUserDelegate.updateProfileHandlers();
        $mmUserProfileFieldsDelegate.updateFieldHandlers();
    }
    $mmEvents.on(mmCoreEventLogin, updateHandlers);
    $mmEvents.on(mmCoreEventSiteUpdated, updateHandlers);
    $mmEvents.on(mmCoreEventRemoteAddonsLoaded, updateHandlers);
    $mmEvents.on(mmCoreEventUserDeleted, function(data) {
        if (data.siteid && data.siteid === $mmSite.getId() && data.params) {
            var params = data.params,
                userid = 0;
            if (params.userid) {
                userid = params.userid;
            } else if (params.userids) {
                userid = params.userids[0];
            } else if (params.field === 'id' && params.values && params.values.length) {
                userid = params.values[0];
            } else if (params.userlist && params.userlist.length) {
                userid = params.userlist[0].userid;
            }
            userid = parseInt(userid);
            if (userid > 0) {
                $mmUser.deleteStoredUser(userid);
            }
        }
    });
}]);

angular.module('mm.core.user')
.provider('$mmUserDelegate', ["mmUserProfileHandlersTypeNewPage", function(mmUserProfileHandlersTypeNewPage) {
    var profileHandlers = {},
        self = {};
        self.registerProfileHandler = function(component, handler, priority) {
        if (typeof profileHandlers[component] !== 'undefined') {
            console.log("$mmUserDelegateProvider: Handler '" + profileHandlers[component].component + "' already registered as profile handler");
            return false;
        }
        console.log("$mmUserDelegateProvider: Registered component '" + component + "' as profile handler.");
        profileHandlers[component] = {
            component: component,
            handler: handler,
            instance: undefined,
            priority: typeof priority === 'undefined' ? 100 : priority
        };
        return true;
    };
    self.$get = ["$q", "$log", "$mmSite", "$mmUtil", "$mmCourses", function($q, $log, $mmSite, $mmUtil, $mmCourses) {
        var enabledProfileHandlers = {},
            self = {},
            lastUpdateHandlersStart;
        $log = $log.getInstance('$mmUserDelegate');
                self.getProfileHandlersFor = function(user, courseId) {
            var handlers = [],
                promises = [];
            return $mmCourses.getUserCourses(true).then(function(courses) {
                var courseIds = courses.map(function(course) {
                    return course.id;
                });
                return $mmCourses.getCoursesOptions(courseIds).then(function(options) {
                    var courseIdForOptions = courseId || $mmSite.getSiteHomeId();
                    var navOptions = options.navOptions[courseIdForOptions];
                    var admOptions = options.admOptions[courseIdForOptions];
                    angular.forEach(enabledProfileHandlers, function(handler) {
                        var isEnabledForUser = handler.instance.isEnabledForUser(user, courseId, navOptions, admOptions);
                        var promise = $q.when(isEnabledForUser).then(function(enabled) {
                            if (enabled) {
                                handlers.push({
                                    controller: handler.instance.getController(user, courseId),
                                    priority: handler.priority,
                                    type: handler.instance.type || mmUserProfileHandlersTypeNewPage
                                });
                            } else {
                                return $q.reject();
                            }
                        }).catch(function() {
                        });
                        promises.push(promise);
                    });
                    return $q.all(promises).then(function() {
                        return handlers;
                    });
                });
            }).catch(function() {
                return handlers;
            });
        };
                self.isLastUpdateCall = function(time) {
            if (!lastUpdateHandlersStart) {
                return true;
            }
            return time == lastUpdateHandlersStart;
        };
                self.updateProfileHandler = function(component, handlerInfo, time) {
            var promise,
                siteId = $mmSite.getId();
            if (typeof handlerInfo.instance === 'undefined') {
                handlerInfo.instance = $mmUtil.resolveObject(handlerInfo.handler, true);
            }
            if (!$mmSite.isLoggedIn()) {
                promise = $q.reject();
            } else if ($mmSite.isFeatureDisabled('$mmUserDelegate_' + component)) {
                promise = $q.when(false);
            } else {
                promise = $q.when(handlerInfo.instance.isEnabled());
            }
            return promise.catch(function() {
                return false;
            }).then(function(enabled) {
                if (self.isLastUpdateCall(time) && $mmSite.isLoggedIn() && $mmSite.getId() === siteId) {
                    if (enabled) {
                        enabledProfileHandlers[component] = {
                            instance: handlerInfo.instance,
                            priority: handlerInfo.priority
                        };
                    } else {
                        delete enabledProfileHandlers[component];
                    }
                }
            });
        };
                self.updateProfileHandlers = function() {
            var promises = [],
                now = new Date().getTime();
            $log.debug('Updating profile handlers for current site.');
            lastUpdateHandlersStart = now;
            angular.forEach(profileHandlers, function(handlerInfo, component) {
                promises.push(self.updateProfileHandler(component, handlerInfo, now));
            });
            return $q.all(promises).then(function() {
                return true;
            }, function() {
                return true;
            });
        };
        return self;
    }];
    return self;
}]);

angular.module('mm.core.user')
.factory('$mmUserHandlers', ["$mmContentLinksHelper", "mmUserProfileHandlersTypeCommunication", "$mmSite", "$window", "$mmContentLinkHandlerFactory", function($mmContentLinksHelper, mmUserProfileHandlersTypeCommunication, $mmSite, $window,
            $mmContentLinkHandlerFactory) {
    var self = {};
        self.linksHandler = $mmContentLinkHandlerFactory.createChild(
                /((\/user\/view\.php)|(\/user\/profile\.php)).*([\?\&]id=\d+)/);
    self.linksHandler.isEnabled = function(siteId, url, params, courseId) {
        return url.indexOf('/grade/report/') == -1;
    };
    self.linksHandler.getActions = function(siteIds, url, params, courseId) {
        return [{
            action: function(siteId) {
                var stateParams = {
                    courseid: params.course,
                    userid: parseInt(params.id, 10)
                };
                $mmContentLinksHelper.goInSite('site.mm_user-profile', stateParams, siteId);
            }
        }];
    };
        self.userEmail = function() {
        var self = {
            type: mmUserProfileHandlersTypeCommunication
        };
                self.isEnabled = function() {
            return true;
        };
                self.isEnabledForUser = function(user, courseId, navOptions, admOptions) {
            return user.id != $mmSite.getUserId() && user.email;
        };
                self.getController = function(user, courseId) {
                        return function($scope, $state) {
                $scope.icon = 'ion-android-mail';
                $scope.title = 'mm.user.sendemail';
                $scope.action = function($event) {
                    $event.preventDefault();
                    $event.stopPropagation();
                    $window.location.href = "mailto:" + user.email;
                };
            };
        };
        return self;
    };
    return self;
}]);

angular.module('mm.core.user')
.provider('$mmUserProfileFieldsDelegate', function() {
    var handlers = {},
        self = {};
        self.registerHandler = function(addon, fieldType, handler) {
        if (typeof handlers[fieldType] !== 'undefined') {
            console.log("$mmUserProfileFieldsDelegateProvider: Addon '" + addon +
                        "' already registered as handler for '" + fieldType + "'");
            return false;
        }
        console.log("$mmUserProfileFieldsDelegateProvider: Registered handler '" + addon + "' for user field '" + fieldType + "'");
        handlers[fieldType] = {
            addon: addon,
            handler: handler,
            instance: undefined
        };
        return true;
    };
    self.$get = ["$q", "$log", "$mmSite", "$mmUtil", function($q, $log, $mmSite, $mmUtil) {
        var enabledHandlers = {},
            self = {},
            lastUpdateHandlersStart;
        $log = $log.getInstance('$mmUserProfileFieldsDelegate');
                self.getDataForField = function(field, signup, registerAuth, model) {
            var handler = self.getHandlerInstance(field, signup),
                name = 'profile_field_' + field.shortname;
            if (handler) {
                if (handler.getData) {
                    return $q.when(handler.getData(field, signup, registerAuth, model));
                } else if (field.shortname && typeof model[name] != 'undefined') {
                    return $q.when({
                        type: field.type || field.datatype,
                        name: name,
                        value: model[name]
                    });
                }
            }
            return $q.when();
        };
                self.getDataForFields = function(fields, signup, registerAuth, model) {
            var result = [],
                promises = [];
            angular.forEach(fields, function(field) {
                promises.push(self.getDataForField(field, signup, registerAuth, model).then(function(data) {
                    if (data) {
                        result.push(data);
                    }
                }));
            });
            return $q.all(promises).then(function() {
                return result;
            });
        };
                self.getDirectiveForField = function(field, signup, registerAuth) {
            var handler = self.getHandlerInstance(field, signup);
            if (handler) {
                return handler.getDirectiveName(field, signup, registerAuth);
            }
        };
                self.getHandlerInstance = function(field, signup) {
            var type = field.type || field.datatype;
            if (signup) {
                if (handlers[type]) {
                    if (typeof handlers[type].instance === 'undefined') {
                        handlers[type].instance = $mmUtil.resolveObject(handlers[type].handler, true);
                    }
                    return handlers[type].instance;
                }
            } else {
                return enabledHandlers[type];
            }
        };
                self.isLastUpdateCall = function(time) {
            if (!lastUpdateHandlersStart) {
                return true;
            }
            return time == lastUpdateHandlersStart;
        };
                self.updateFieldHandler = function(fieldType, handlerInfo, time) {
            var promise,
                siteId = $mmSite.getId();
            if (typeof handlerInfo.instance === 'undefined') {
                handlerInfo.instance = $mmUtil.resolveObject(handlerInfo.handler, true);
            }
            if (!$mmSite.isLoggedIn()) {
                promise = $q.reject();
            } else {
                promise = $q.when(handlerInfo.instance.isEnabled());
            }
            return promise.catch(function() {
                return false;
            }).then(function(enabled) {
                if (self.isLastUpdateCall(time) && $mmSite.isLoggedIn() && $mmSite.getId() === siteId) {
                    if (enabled) {
                        enabledHandlers[fieldType] = handlerInfo.instance;
                    } else {
                        delete enabledHandlers[fieldType];
                    }
                }
            });
        };
                self.updateFieldHandlers = function() {
            var promises = [],
                now = new Date().getTime();
            $log.debug('Updating field handlers for current site.');
            lastUpdateHandlersStart = now;
            angular.forEach(handlers, function(handlerInfo, fieldType) {
                promises.push(self.updateFieldHandler(fieldType, handlerInfo, now));
            });
            return $q.all(promises).then(function() {
                return true;
            }, function() {
                return true;
            });
        };
        return self;
    }];
    return self;
});

angular.module('mm.core.user')
.constant('mmCoreUsersStore', 'users')
.config(["$mmSitesFactoryProvider", "mmCoreUsersStore", function($mmSitesFactoryProvider, mmCoreUsersStore) {
    var stores = [
        {
            name: mmCoreUsersStore,
            keyPath: 'id'
        }
    ];
    $mmSitesFactoryProvider.registerStores(stores);
}])
.factory('$mmUser', ["$log", "$q", "$mmSite", "$mmUtil", "$translate", "mmCoreUsersStore", "$mmFilepool", "$mmSitesManager", function($log, $q, $mmSite, $mmUtil, $translate, mmCoreUsersStore, $mmFilepool, $mmSitesManager) {
    $log = $log.getInstance('$mmUser');
    var self = {};
        self.deleteStoredUser = function(id) {
        if (!$mmSite.isLoggedIn()) {
            return $q.reject();
        }
        id = parseInt(id, 10);
        if (isNaN(id)) {
            return $q.reject();
        }
        self.invalidateUserCache(id);
        return $mmSite.getDb().remove(mmCoreUsersStore, id);
    };
        self.formatAddress = function(address, city, country) {
        var separator = $translate.instant('mm.core.listsep'),
            values = [address, city, country];
        values = values.filter(function (value) {
            return value && value.length > 0;
        });
        return values.join(separator + " ");
    };
        self.formatRoleList = function(roles) {
        if (!roles || roles.length <= 0) {
            return "";
        }
        var separator = $translate.instant('mm.core.listsep');
        roles = roles.reduce(function (previousValue, currentValue) {
            var role = $translate.instant('mm.user.' + currentValue.shortname);
            if (role.indexOf('mm.user.') < 0) {
                previousValue.push(role);
            }
            return previousValue;
        }, []);
        return roles.join(separator + " ");
    };
        self.getProfile = function(userid, courseid, forceLocal) {
        var deferred = $q.defer();
        if (forceLocal) {
            self.getUserFromLocal(userid).then(deferred.resolve, function() {
                self.getUserFromWS(userid, courseid).then(deferred.resolve, deferred.reject);
            });
        } else {
            self.getUserFromWS(userid, courseid).then(deferred.resolve, function() {
                self.getUserFromLocal(userid).then(deferred.resolve, deferred.reject);
            });
        }
        return deferred.promise;
    };
        function getUserCacheKey(userid) {
        return 'mmUser:data:'+userid;
    }
        self.getUserFromLocal = function(id) {
        if (!$mmSite.isLoggedIn()) {
            return $q.reject();
        }
        id = parseInt(id, 10);
        if (isNaN(id)) {
            return $q.reject();
        }
        return $mmSite.getDb().get(mmCoreUsersStore, id);
    };
        self.getUserFromWS = function(userid, courseid) {
        userid = parseInt(userid, 10);
        courseid = parseInt(courseid, 10);
        var wsName,
            data,
            preSets ={
                cacheKey: getUserCacheKey(userid)
            };
        if (courseid > 1) {
            $log.debug('Get participant with ID ' + userid + ' in course '+courseid);
            wsName = 'core_user_get_course_user_profiles';
            data = {
                "userlist[0][userid]": userid,
                "userlist[0][courseid]": courseid
            };
        } else {
            $log.debug('Get user with ID ' + userid);
            if ($mmSite.wsAvailable('core_user_get_users_by_field')) {
                wsName = 'core_user_get_users_by_field';
                data = {
                    'field': 'id',
                    'values[0]': userid
                };
            } else {
                wsName = 'core_user_get_users_by_id';
                data = {
                    'userids[0]': userid
                };
            }
        }
        return $mmSite.read(wsName, data, preSets).then(function(users) {
            if (users.length == 0) {
                return $q.reject();
            }
            var user = users.shift();
            if (user.country) {
                user.country = $mmUtil.getCountryName(user.country);
            }
            self.storeUser(user.id, user.fullname, user.profileimageurl);
            return user;
        });
    };
        self.invalidateUserCache = function(userid) {
        return $mmSite.invalidateWsCacheForKey(getUserCacheKey(userid));
    };
        self.isUpdatePictureDisabled = function(siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return self.isUpdatePictureDisabledInSite(site);
        });
    };
        self.isUpdatePictureDisabledInSite = function(site) {
        site = site || $mmSite;
        return site.isFeatureDisabled('$mmUserDelegate_picture');
    };
        self.prefetchProfiles = function(userIds, courseId, siteId) {
        siteId = siteId || $mmSite.getId();
        var treated = {},
            promises = [];
        angular.forEach(userIds, function(userId) {
            if (!treated[userId]) {
                treated[userId] = true;
                promises.push(self.getProfile(userId, courseId).then(function(profile) {
                    if (profile.profileimageurl) {
                        $mmFilepool.addToQueueByUrl(siteId, profile.profileimageurl);
                    }
                }));
            }
        });
        return $q.all(promises);
    };
        self.storeUser = function(id, fullname, avatar) {
        if (!$mmSite.isLoggedIn()) {
            return $q.reject();
        }
        id = parseInt(id, 10);
        if (isNaN(id)) {
            return $q.reject();
        }
        return $mmSite.getDb().insert(mmCoreUsersStore, {
            id: id,
            fullname: fullname,
            profileimageurl: avatar
        });
    };
        self.storeUsers = function(users) {
        var promises = [];
        angular.forEach(users, function(user) {
            var userid = user.id || user.userid,
                img = user.profileimageurl || user.profileimgurl;
            if (typeof userid != 'undefined') {
                promises.push(self.storeUser(userid, user.fullname, img));
            }
        });
        return $q.all(promises);
    };
        self.updateUserPreference = function(name, value, userId, siteId) {
        var preferences = [
            {
                type: name,
                value: value
            }
        ];
        return self.updateUserPreferences(preferences, undefined, userId, siteId);
    };
        self.updateUserPreferences = function(preferences, disableNotifications, userId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            var data = {
                    userid: userId,
                    preferences: preferences
                },
                preSets = {
                    responseExpected: false
                };
            if (typeof disableNotifications != 'undefined') {
                data.emailstop = disableNotifications ? 1 : 0;
            }
            return site.write('core_user_update_user_preferences', data, preSets);
        });
    };
        self.changeProfilePicture = function(draftItemId, userId) {
        var data = {
            'draftitemid': draftItemId,
            'delete': 0,
            'userid': userId
        };
        return $mmSite.write('core_user_update_picture', data).then(function(result) {
            if (!result.success) {
                return $q.reject();
            }
            return result.profileimageurl;
        });
    };
    return self;
}]);

angular.module('mm.core.comments')
.controller('mmCommentViewerCtrl', ["$stateParams", "$scope", "$translate", "$mmComments", "$mmUtil", "$mmUser", "$q", function($stateParams, $scope, $translate, $mmComments, $mmUtil, $mmUser, $q) {
    var contextLevel = $stateParams.contextLevel,
        instanceId = $stateParams.instanceId,
        component = $stateParams.component,
        itemId = $stateParams.itemId,
        area = $stateParams.area,
        page = $stateParams.page || 0;
    $scope.title = $stateParams.title || $translate.instant('mm.core.comments');
    function fetchComments() {
        return $mmComments.getComments(contextLevel, instanceId, component, itemId, area, page).then(function(comments) {
            $scope.comments = comments;
            angular.forEach(comments, function(comment) {
                $mmUser.getProfile(comment.userid, undefined, true).then(function(user) {
                    comment.profileimageurl = user.profileimageurl || true;
                });
            });
        }).catch(function(error) {
            if (error) {
                if (component == 'assignsubmission_comments') {
                    $mmUtil.showModal('mm.core.notice', 'mm.core.commentsnotworking');
                } else {
                    $mmUtil.showErrorModal(error);
                }
            } else {
                $translate('mm.core.error').then(function(error) {
                    $mmUtil.showErrorModal(error + ': get_comments');
                });
            }
            return $q.reject();
        });
    }
    fetchComments().finally(function() {
        $scope.commentsLoaded = true;
    });
    $scope.refreshComments = function() {
        return $mmComments.invalidateCommentsData(contextLevel, instanceId, component, itemId, area, page).finally(function() {
            return fetchComments().finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };
}]);
angular.module('mm.core.comments')
.directive('mmComments', ["$mmComments", "$state", function($mmComments, $state) {
    return {
        restrict: 'E',
        priority: 100,
        scope: {
            contextLevel: '@',
            instanceId: '@',
            component: '@',
            itemId: '@',
            area: '@?',
            page: '@?',
            title: '@?'
        },
        templateUrl: 'core/components/comments/templates/comments.html',
        link: function(scope, el, attr) {
            var params;
            scope.commentsCount = -1;
            scope.commentsLoaded = false;
            scope.showComments = function() {
                if (scope.commentsCount > 0) {
                    $state.go('site.mm_commentviewer', params);
                }
            };
            $mmComments.getComments(attr.contextLevel, attr.instanceId, attr.component, attr.itemId, attr.area, attr.page)
                    .then(function(comments) {
                params = {
                    contextLevel: attr.contextLevel,
                    instanceId: attr.instanceId,
                    component: attr.component,
                    itemId: attr.itemId,
                    area: attr.area,
                    page: attr.page,
                    title: attr.title
                };
                scope.commentsCount = comments && comments.length ? comments.length : 0;
                scope.commentsLoaded = true;
            }).catch(function() {
                scope.commentsLoaded = true;
            });
        }
    };
}]);

angular.module('mm.core.comments')
.factory('$mmComments', ["$log", "$mmSitesManager", "$mmSite", "$q", function($log, $mmSitesManager, $mmSite, $q) {
    $log = $log.getInstance('$mmComments');
    var self = {};
        function getCommentsCacheKey(contextLevel, instanceId, component, itemId, area, page) {
        page = page || 0;
        area = area || "";
        return getCommentsPrefixCacheKey(contextLevel, instanceId) + ':' + component + ':' + itemId + ':' + area + ':' + page;
    }
        function getCommentsPrefixCacheKey(contextLevel, instanceId) {
        return 'mmComments:comments:' + contextLevel + ':' + instanceId;
    }
        self.getComments = function(contextLevel, instanceId, component, itemId, area, page, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                "contextlevel": contextLevel,
                "instanceid": instanceId,
                "component": component,
                "itemid": itemId
            },
            preSets = {};
            if (area) {
                params.area = area;
            }
            if (page) {
                params.page = page;
            }
            preSets.cacheKey = getCommentsCacheKey(contextLevel, instanceId, component, itemId, area, page);
            return site.read('core_comment_get_comments', params, preSets).then(function(response) {
                if (response.comments) {
                    return response.comments;
                }
                return $q.reject();
            });
        });
    };
        self.invalidateCommentsData = function(contextLevel, instanceId, component, itemId, area, page, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getCommentsCacheKey(contextLevel, instanceId, component, itemId, area, page));
        });
    };
        self.invalidateCommentsByInstance = function(contextLevel, instanceId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKeyStartingWith(getCommentsPrefixCacheKey(contextLevel, instanceId));
        });
    };
        self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return  site.wsAvailable('core_comment_get_comments');
        });
    };
    return self;
}]);

angular.module('mm.core.contentlinks')
.controller('mmContentLinksChooseSiteCtrl', ["$scope", "$stateParams", "$mmSitesManager", "$mmUtil", "$ionicHistory", "$state", "$q", "$mmContentLinksDelegate", "$mmContentLinksHelper", function($scope, $stateParams, $mmSitesManager, $mmUtil, $ionicHistory, $state, $q,
            $mmContentLinksDelegate, $mmContentLinksHelper) {
    $scope.url = $stateParams.url || '';
    var action;
    function leaveView() {
        $mmSitesManager.logout().finally(function() {
            $ionicHistory.nextViewOptions({
                disableAnimate: true,
                disableBack: true
            });
            $state.go('mm_login.sites');
        });
    }
    if (!$scope.url) {
        leaveView();
        return;
    }
    $mmContentLinksDelegate.getActionsFor($scope.url).then(function(actions) {
        action = $mmContentLinksHelper.getFirstValidAction(actions);
        if (!action) {
            return $q.reject();
        }
        $mmSitesManager.getSites(action.sites).then(function(sites) {
            $scope.sites = sites;
        });
    }).catch(function() {
        $mmUtil.showErrorModal('mm.contentlinks.errornosites', true);
        leaveView();
    });
    $scope.siteClicked = function(siteId) {
        action.action(siteId);
    };
    $scope.cancel = function() {
        leaveView();
    };
}]);

angular.module('mm.core.contentlinks')
.provider('$mmContentLinksDelegate', function() {
    var linkHandlers = {},
        self = {};
        self.registerLinkHandler = function(name, handler, priority) {
        if (typeof linkHandlers[name] !== 'undefined') {
            console.log("$mmContentLinksDelegateProvider: Handler '" + linkHandlers[name].name +
                        "' already registered as link handler");
            return false;
        }
        console.log("$mmContentLinksDelegateProvider: Registered handler '" + name + "' as link handler.");
        linkHandlers[name] = {
            name: name,
            handler: handler,
            instance: undefined,
            priority: typeof priority === 'undefined' ? 100 : priority
        };
        return true;
    };
    self.$get = ["$mmUtil", "$log", "$q", "$mmSitesManager", function($mmUtil, $log, $q, $mmSitesManager) {
        var self = {};
        $log = $log.getInstance('$mmContentLinksDelegate');
                self.getActionsFor = function(url, courseId, username) {
            if (!url) {
                return $q.when([]);
            }
            return $mmSitesManager.getSiteIdsFromUrl(url, true, username).then(function(siteIds) {
                var linkActions = [],
                    promises = [],
                    params = $mmUtil.extractUrlParams(url);
                angular.forEach(linkHandlers, function(handler) {
                    if (typeof handler.instance === 'undefined') {
                        handler.instance = $mmUtil.resolveObject(handler.handler, true);
                    }
                    if (!handler.instance || !handler.instance.handles(url)) {
                        return;
                    }
                    var checkAll = handler.instance.checkAllSites;
                    promises.push($mmUtil.filterEnabledSites(siteIds, isEnabled, checkAll).then(function(siteIds) {
                        if (!siteIds.length) {
                            return;
                        }
                        return $q.when(handler.instance.getActions(siteIds, url, params, courseId)).then(function(actions) {
                            if (actions && actions.length) {
                                angular.forEach(actions, function(action) {
                                    action.message = action.message || 'mm.core.view';
                                    action.icon = action.icon || 'ion-eye';
                                    action.sites = action.sites || siteIds;
                                });
                                linkActions.push({
                                    priority: handler.priority,
                                    actions: actions
                                });
                            }
                        });
                    }));
                    function isEnabled(siteId) {
                        var promise;
                        if (handler.instance.featureName) {
                            promise = $mmSitesManager.isFeatureDisabled(handler.instance.featureName, siteId);
                        } else {
                            promise = $q.when(false);
                        }
                        return promise.then(function(disabled) {
                            if (disabled) {
                                return false;
                            }
                            if (!handler.instance.isEnabled) {
                                return true;
                            }
                            return handler.instance.isEnabled(siteId, url, params, courseId);
                        });
                    }
                });
                return $mmUtil.allPromises(promises).catch(function() {}).then(function() {
                    return sortActionsByPriority(linkActions);
                });
            });
        };
                self.getSiteUrl = function(url) {
            if (!url) {
                return;
            }
            for (var name in linkHandlers) {
                var handler = linkHandlers[name];
                if (typeof handler.instance === 'undefined') {
                    handler.instance = $mmUtil.resolveObject(handler.handler, true);
                }
                if (handler.instance && handler.instance.handles) {
                    var siteUrl = handler.instance.handles(url);
                    if (siteUrl) {
                        return siteUrl;
                    }
                }
            }
        };
                function sortActionsByPriority(actions) {
            var sorted = [];
            actions = actions.sort(function(a, b) {
                return a.priority > b.priority;
            });
            actions.forEach(function(entry) {
                sorted = sorted.concat(entry.actions);
            });
            return sorted;
        }
        return self;
    }];
    return self;
});

angular.module('mm.core')
.factory('$mmContentLinkHandlerFactory', ["$log", function($log) {
    $log = $log.getInstance('$mmContentLinkHandlerFactory');
    var self = {},
        contentLinkHandler = (function () {
            this.pattern = false;
            this.featureName = '';
            this.checkAllSites = false;
                        this.getActions = function(siteIds, url, params, courseId) {
                return [];
            };
                        this.handles = function(url) {
                if (this.pattern) {
                    var position = url.search(this.pattern);
                    if (position > -1) {
                        return url.substr(0, position);
                    }
                }
            };
                        this.isEnabled = function(siteId, url, params, courseId) {
                return true;
            };
            return this;
        }());
        self.createChild = function(pattern, featureName, checkAllSites) {
        var child = Object.create(contentLinkHandler);
        child.pattern = pattern;
        child.featureName = featureName;
        child.checkAllSites = !!checkAllSites;
        return child;
    };
    return self;
}]);
angular.module('mm.core.contentlinks')
.factory('$mmContentLinksHelper', ["$log", "$ionicHistory", "$state", "$mmSite", "$mmContentLinksDelegate", "$mmUtil", "$translate", "$mmCourseHelper", "$mmSitesManager", "$q", "$mmLoginHelper", "$mmText", "mmCoreConfigConstants", "$mmCourse", "$mmContentLinkHandlerFactory", function($log, $ionicHistory, $state, $mmSite, $mmContentLinksDelegate, $mmUtil, $translate,
            $mmCourseHelper, $mmSitesManager, $q, $mmLoginHelper, $mmText, mmCoreConfigConstants, $mmCourse,
            $mmContentLinkHandlerFactory) {
    $log = $log.getInstance('$mmContentLinksHelper');
    var self = {};
        self.createModuleGradeLinkHandler = function(addon, modName, service, gotoReview) {
        var regex = new RegExp('\/mod\/' + modName + '\/grade\.php.*([\&\?]id=\\d+)'),
            handler = $mmContentLinkHandlerFactory.createChild(regex, '$mmCourseDelegate_' + addon);
        handler.isEnabled = function(siteId, url, params, courseId) {
            courseId = courseId || params.courseid || params.cid;
            return self.isModuleIndexEnabled(service, siteId, courseId);
        };
        handler.getActions = function(siteIds, url, params, courseId) {
            courseId = courseId || params.courseid || params.cid;
            return self.treatModuleGradeUrl(siteIds, url, params, courseId, gotoReview);
        };
        return handler;
    };
        self.createModuleIndexLinkHandler = function(addon, modName, service) {
        var regex = new RegExp('\/mod\/' + modName + '\/view\.php.*([\&\?]id=\\d+)'),
            handler = $mmContentLinkHandlerFactory.createChild(regex, '$mmCourseDelegate_' + addon);
        handler.isEnabled = function(siteId, url, params, courseId) {
            courseId = courseId || params.courseid || params.cid;
            return self.isModuleIndexEnabled(service, siteId, courseId);
        };
        handler.getActions = self.treatModuleIndexUrl;
        return handler;
    };
        self.filterSupportedSites = $mmUtil.filterEnabledSites;
        self.getFirstValidAction = function(actions) {
        if (actions) {
            for (var i = 0; i < actions.length; i++) {
                var action = actions[i];
                if (action && action.sites && action.sites.length && angular.isFunction(action.action)) {
                    return action;
                }
            }
        }
    };
        self.goInSite = function(stateName, stateParams, siteId) {
        siteId = siteId || $mmSite.getId();
        if (siteId == $mmSite.getId()) {
            return $state.go(stateName, stateParams);
        } else {
            return $state.go('redirect', {
                siteid: siteId,
                state: stateName,
                params: stateParams
            });
        }
    };
        self.goToChooseSite = function(url) {
        $ionicHistory.nextViewOptions({
            disableBack: true
        });
        return $state.go('mm_contentlinks.choosesite', {url: url});
    };
        self.handleCustomUrl = function(url) {
        var contentLinksScheme = mmCoreConfigConstants.customurlscheme + '://link=';
        if (url.indexOf(contentLinksScheme) == -1) {
            return false;
        }
        $log.debug('Treating custom URL scheme: ' + url);
        var modal = $mmUtil.showModalLoading(),
            username;
        url = url.replace(contentLinksScheme, '');
        username = $mmText.getUsernameFromUrl(url);
        if (username) {
            url = url.replace(username + '@', '');
        }
        $mmSitesManager.getSiteIdsFromUrl(url, false, username).then(function(siteIds) {
            if (siteIds.length) {
                modal.dismiss();
                return self.handleLink(url, username).then(function(treated) {
                    if (!treated) {
                        $mmUtil.showErrorModal('mm.contentlinks.errornoactions', true);
                    }
                });
            } else {
                var siteUrl = $mmContentLinksDelegate.getSiteUrl(url);
                if (!siteUrl) {
                    $mmUtil.showErrorModal('mm.login.invalidsite', true);
                    return;
                }
                return $mmSitesManager.checkSite(siteUrl).then(function(result) {
                    var promise,
                        ssoNeeded = $mmLoginHelper.isSSOLoginNeeded(result.code);
                    modal.dismiss();
                    if (!$mmSite.isLoggedIn()) {
                        promise = $q.when();
                    } else {
                        promise = $mmUtil.showConfirm($translate('mm.contentlinks.confirmurlothersite')).then(function() {
                            if (!ssoNeeded) {
                                return $mmSitesManager.logout().catch(function() {
                                });
                            }
                        });
                    }
                    return promise.then(function() {
                        if (ssoNeeded) {
                            $mmLoginHelper.confirmAndOpenBrowserForSSOLogin(
                                        result.siteurl, result.code, result.service, result.config && result.config.launchurl);
                        } else {
                            $state.go('mm_login.credentials', {
                                siteurl: result.siteurl,
                                username: username,
                                urltoopen: url
                            });
                        }
                    });
                }, function(error) {
                    $mmUtil.showErrorModal(error);
                });
            }
        }).finally(function() {
            modal.dismiss();
        });
        return true;
    };
        self.handleLink = function(url, username) {
        return $mmContentLinksDelegate.getActionsFor(url, undefined, username).then(function(actions) {
            var action = self.getFirstValidAction(actions);
            if (action) {
                if (!$mmSite.isLoggedIn()) {
                    if (action.sites.length == 1) {
                        action.action(action.sites[0]);
                    } else {
                        self.goToChooseSite(url);
                    }
                } else if (action.sites.length == 1 && action.sites[0] == $mmSite.getId()) {
                    action.action(action.sites[0]);
                } else {
                    $mmUtil.showConfirm($translate('mm.contentlinks.confirmurlothersite')).then(function() {
                        if (action.sites.length == 1) {
                            action.action(action.sites[0]);
                        } else {
                            self.goToChooseSite(url);
                        }
                    });
                }
                return true;
            }
            return false;
        }).catch(function() {
            return false;
        });
    };
        self.isModuleIndexEnabled = function(service, siteId, courseId) {
        var promise;
        if (service.isPluginEnabled) {
            promise = service.isPluginEnabled(siteId);
        } else {
            promise = $q.when(true);
        }
        return promise.then(function(enabled) {
            if (!enabled) {
                return false;
            }
            return courseId || $mmCourse.canGetModuleWithoutCourseId(siteId);
        });
    };
        self.treatModuleGradeUrl = function(siteIds, url, params, courseId, gotoReview) {
        return [{
            action: function(siteId) {
                var modal = $mmUtil.showModalLoading();
                $mmSitesManager.getSite(siteId).then(function(site) {
                    if (!params.userid || params.userid == site.getUserId()) {
                        $mmCourseHelper.navigateToModule(parseInt(params.id, 10), siteId, courseId);
                    } else if (angular.isFunction(gotoReview)) {
                        gotoReview(url, params, courseId, siteId);
                    } else {
                        return site.openInBrowserWithAutoLogin(url);
                    }
                }).finally(function() {
                    modal.dismiss();
                });
            }
        }];
    };
        self.treatModuleIndexUrl = function(siteIds, url, params, courseId) {
        courseId = courseId || params.courseid || params.cid;
        return [{
            action: function(siteId) {
                $mmCourseHelper.navigateToModule(parseInt(params.id, 10), siteId, courseId);
            }
        }];
    };
    return self;
}]);

angular.module('mm.core.course')
.controller('mmCourseModContentCtrl', ["$log", "$stateParams", "$scope", "$mmCourseDelegate", "$mmCourse", "$translate", "$mmText", function($log, $stateParams, $scope, $mmCourseDelegate, $mmCourse, $translate, $mmText) {
    $log = $log.getInstance('mmCourseModContentCtrl');
    var module = $stateParams.module || {};
    $scope.isDisabledInSite = $mmCourseDelegate.isModuleDisabledInSite(module.modname);
    $scope.isSupportedByTheApp = $mmCourseDelegate.hasContentHandler(module.modname);
    $scope.moduleName = $mmCourse.translateModuleName(module.modname);
    $scope.isContributedPlugin = $scope.moduleName == $translate.instant('mm.core.mod_external-tool');
    $scope.description = module.description;
    $scope.title = module.name;
    $scope.url = module.url;
    $scope.expandDescription = function() {
        $mmText.expandText($translate.instant('mm.core.description'), $scope.description, false);
    };
}]);

angular.module('mm.core.course')
.controller('mmCourseSectionCtrl', ["$mmCourse", "$mmUtil", "$scope", "$stateParams", "$translate", "$mmEvents", "$ionicScrollDelegate", "$mmCourses", "$q", "mmCoreEventCompletionModuleViewed", "$mmCoursePrefetchDelegate", "$mmCourseHelper", "$timeout", function($mmCourse, $mmUtil, $scope, $stateParams, $translate, $mmEvents, $ionicScrollDelegate,
            $mmCourses, $q, mmCoreEventCompletionModuleViewed, $mmCoursePrefetchDelegate, $mmCourseHelper, $timeout) {
    var courseId = $stateParams.cid,
        sectionId = $stateParams.sectionid || -1,
        moduleId = $stateParams.mid,
        scrollView;
    $scope.sections = [];
    $scope.sectionHasContent = $mmCourseHelper.sectionHasContent;
    if (sectionId < 0) {
        $scope.title = $translate.instant('mm.course.allsections');
        $scope.summary = null;
        $scope.allSections = true;
    }
    function loadContent(sectionId) {
        return $mmCourses.getUserCourse(courseId, true).catch(function() {
        }).then(function(course) {
            var promise;
            if (course && course.enablecompletion === false) {
                promise = $q.when([]);
            } else {
                promise = $mmCourse.getActivitiesCompletionStatus(courseId).catch(function() {
                    return [];
                });
            }
            return promise.then(function(completionStatus) {
                var promise,
                    sectionnumber;
                if (sectionId < 0) {
                    sectionnumber = 0;
                    promise = $mmCourse.getSections(courseId, false, true);
                } else {
                    sectionnumber = sectionId;
                    promise = $mmCourse.getSection(courseId, false, true, sectionId).then(function(section) {
                        $scope.title = section.name;
                        $scope.summary = section.summary;
                        return [section];
                    });
                }
                return promise.then(function(sections) {
                    $scope.hasContent = $mmCourseHelper.addContentHandlerControllerForSectionModules(sections, courseId,
                        moduleId, completionStatus, $scope);
                    $scope.sections = sections;
                    if (sectionId > 0 && sections[0] && typeof sections[0].section != 'undefined') {
                        $mmCourse.logView(courseId, sections[0].section);
                    } else {
                        $mmCourse.logView(courseId);
                    }
                }, function(error) {
                    if (error) {
                        $mmUtil.showErrorModal(error);
                    } else {
                        $mmUtil.showErrorModal('mm.course.couldnotloadsectioncontent', true);
                    }
                });
            });
        });
    }
    loadContent(sectionId).finally(function() {
        $scope.sectionLoaded = true;
        if (moduleId) {
            $timeout(function() {
                if (!scrollView) {
                    scrollView = $ionicScrollDelegate.$getByHandle('mmSectionScroll');
                }
                $mmUtil.scrollToElement(document.body, '#mm-course-module-' + moduleId, scrollView);
            }, 400);
        }
    });
    $scope.doRefresh = function() {
        var promises = [];
        promises.push($mmCourse.invalidateSections(courseId));
        if ($scope.sections) {
            var modules = $mmCourseHelper.getSectionsModules($scope.sections);
            promises.push($mmCoursePrefetchDelegate.invalidateModules(modules, courseId));
        }
        $q.all(promises).finally(function() {
            loadContent(sectionId).finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };
    function refreshAfterCompletionChange() {
        if (!scrollView) {
            scrollView = $ionicScrollDelegate.$getByHandle('mmSectionScroll');
        }
        if (scrollView && scrollView.getScrollPosition()) {
            $scope.loadingPaddingTop = scrollView.getScrollPosition().top;
        }
        $scope.sectionLoaded = false;
        $scope.sections = [];
        loadContent(sectionId).finally(function() {
            $scope.sectionLoaded = true;
            $scope.loadingPaddingTop = 0;
        });
    }
    $scope.completionChanged = function() {
        $mmCourse.invalidateSections(courseId).finally(function() {
            refreshAfterCompletionChange();
        });
    };
    var observer = $mmEvents.on(mmCoreEventCompletionModuleViewed, function(cid) {
        if (cid === courseId) {
            refreshAfterCompletionChange();
        }
    });
    $scope.$on('$destroy', function() {
        if (observer && observer.off) {
            observer.off();
        }
    });
}]);

angular.module('mm.core.course')
.controller('mmCourseSectionsCtrl', ["$mmCourse", "$mmUtil", "$scope", "$stateParams", "$translate", "$mmCourseHelper", "$mmEvents", "$mmSite", "$mmCoursePrefetchDelegate", "$mmCourses", "$q", "$ionicHistory", "$ionicPlatform", "mmCoreCourseAllSectionsId", "mmCoreEventSectionStatusChanged", "$state", "$timeout", function($mmCourse, $mmUtil, $scope, $stateParams, $translate, $mmCourseHelper, $mmEvents,
            $mmSite, $mmCoursePrefetchDelegate, $mmCourses, $q, $ionicHistory, $ionicPlatform, mmCoreCourseAllSectionsId,
            mmCoreEventSectionStatusChanged, $state, $timeout) {
    var courseId = $stateParams.courseid,
        sectionId = $stateParams.sid,
        moduleId = $stateParams.moduleid,
        courseFullName = $stateParams.coursefullname;
    $scope.courseId = courseId;
    $scope.sectionToLoad = 2;
    $scope.fullname = courseFullName;
    $scope.downloadSectionsEnabled = $mmCourseHelper.isDownloadSectionsEnabled();
    $scope.downloadSectionsIcon = getDownloadSectionIcon();
    $scope.sectionHasContent = $mmCourseHelper.sectionHasContent;
    function loadSections(refresh) {
        var promise;
        if (courseFullName) {
            promise = $q.when();
        } else {
            promise = $mmCourses.getUserCourse(courseId).catch(function() {
                return $mmCourses.getCourse(courseId);
            }).then(function(course) {
                return course.fullname;
            }).catch(function() {
                return $translate.instant('mm.core.course');
            });
        }
        return promise.then(function(courseFullName) {
            if (courseFullName) {
                $scope.fullname = courseFullName;
            }
            return $mmCourse.getSections(courseId, false, true).then(function(sections) {
                return $translate('mm.course.allsections').then(function(str) {
                    var result = [{
                        name: str,
                        id: mmCoreCourseAllSectionsId
                    }].concat(sections);
                    $scope.sections = result;
                    if ($scope.downloadSectionsEnabled) {
                        calculateSectionStatus(refresh);
                    }
                });
            });
        }).catch(function(error) {
            if (error) {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mm.course.couldnotloadsections', true);
            }
        });
    }
    $scope.toggleDownloadSections = function() {
        $scope.downloadSectionsEnabled = !$scope.downloadSectionsEnabled;
        $mmCourseHelper.setDownloadSectionsEnabled($scope.downloadSectionsEnabled);
        $scope.downloadSectionsIcon = getDownloadSectionIcon();
        if ($scope.downloadSectionsEnabled) {
            calculateSectionStatus(false);
        }
    };
    function getDownloadSectionIcon() {
        return $scope.downloadSectionsEnabled ? 'ion-android-checkbox-outline' : 'ion-android-checkbox-outline-blank';
    }
    function calculateSectionStatus(refresh) {
        $mmCourseHelper.calculateSectionsStatus($scope.sections, $scope.courseId, true, refresh).catch(function() {
        }).then(function(downloadpromises) {
            if (downloadpromises && downloadpromises.length) {
                $mmUtil.allPromises(downloadpromises).catch(function() {
                    if (!$scope.$$destroyed) {
                        $mmUtil.showErrorModal('mm.course.errordownloadingsection', true);
                    }
                }).finally(function() {
                    if (!$scope.$$destroyed) {
                        $mmCourseHelper.calculateSectionsStatus($scope.sections, $scope.courseId, false);
                    }
                });
            }
        });
    }
    function prefetch(section, manual) {
        $mmCourseHelper.prefetch(section, courseId, $scope.sections).catch(function() {
            if ($scope.$$destroyed) {
                return;
            }
            var current = $ionicHistory.currentStateName(),
                isCurrent = ($ionicPlatform.isTablet() && current == 'site.mm_course.mm_course-section') ||
                            (!$ionicPlatform.isTablet() && current == 'site.mm_course');
            if (!manual && !isCurrent) {
                return;
            }
            $mmUtil.showErrorModal('mm.course.errordownloadingsection', true);
        }).finally(function() {
            if (!$scope.$$destroyed) {
                $mmCourseHelper.calculateSectionsStatus($scope.sections, courseId, false);
            }
        });
    }
    function autoloadSection() {
        if (sectionId) {
            if ($ionicPlatform.isTablet()) {
                angular.forEach($scope.sections, function(section, index) {
                    if (section.id == sectionId) {
                        $scope.sectionToLoad = index + 1;
                    }
                });
                $scope.moduleId = moduleId;
                $timeout(function() {
                    $scope.moduleId = null;
                }, 500);
            } else {
                $state.go('site.mm_course-section', {
                    sectionid: sectionId,
                    cid: courseId,
                    mid: moduleId
                });
            }
        }
    }
    $scope.doRefresh = function() {
        var promises = [];
        promises.push($mmCourses.invalidateUserCourses());
        promises.push($mmCourse.invalidateSections(courseId));
        if ($scope.sections && $scope.downloadSectionsEnabled) {
            var modules = $mmCourseHelper.getSectionsModules($scope.sections);
            promises.push($mmCoursePrefetchDelegate.invalidateModules(modules, courseId));
        }
        $q.all(promises).finally(function() {
            loadSections(true).finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };
    $scope.prefetch = function(e, section) {
        e.preventDefault();
        e.stopPropagation();
        section.isCalculating = true;
        $mmCourseHelper.confirmDownloadSize(courseId, section, $scope.sections).then(function() {
            prefetch(section, true);
        }).finally(function() {
            section.isCalculating = false;
        });
    };
    loadSections().finally(function() {
        autoloadSection();
        $scope.sectionsLoaded = true;
    });
    var statusObserver = $mmEvents.on(mmCoreEventSectionStatusChanged, function(data) {
        if ($scope.downloadSectionsEnabled && $scope.sections && $scope.sections.length && data.siteid === $mmSite.getId() &&
                    !$scope.$$destroyed && data.sectionid) {
            if ($mmCoursePrefetchDelegate.isBeingDownloaded($mmCourseHelper.getSectionDownloadId({id: data.sectionid}))) {
                return;
            }
            $mmCourseHelper.calculateSectionsStatus($scope.sections, courseId, false).then(function() {
                var section;
                angular.forEach($scope.sections, function(s) {
                    if (s.id === data.sectionid) {
                        section = s;
                    }
                });
                if (section) {
                    var downloadid = $mmCourseHelper.getSectionDownloadId(section);
                    if (section.isDownloading && !$mmCoursePrefetchDelegate.isBeingDownloaded(downloadid)) {
                        prefetch(section, false);
                    }
                }
            });
        }
    });
    $scope.$on('$destroy', function() {
        statusObserver && statusObserver.off && statusObserver.off();
    });
}]);

angular.module('mm.core.course')
.directive('mmCourseModDescription', function() {
    return {
        compile: function(element, attrs) {
            if (attrs.watch) {
                element.find('mm-format-text').attr('watch', attrs.watch);
            }
            return function(scope) {
                scope.showfull = !!attrs.showfull;
            };
        },
        restrict: 'E',
        scope: {
            description: '=',
            note: '=?',
            component: '@?',
            componentId: '@?'
        },
        templateUrl: 'core/components/course/templates/mod_description.html'
    };
});

angular.module('mm.core.course')
.directive('mmCourseModule', function() {
    return {
        restrict: 'E',
        scope: {
            module: '=',
            completionChanged: '=?'
        },
        templateUrl: 'core/components/course/templates/module.html'
    };
});

angular.module('mm.core.course')
.factory('$mmCourseContentHandler', ["$mmCourse", "$mmSite", function($mmCourse, $mmSite) {
    return {
        getController: function(module) {
            return function($scope, $state) {
                $scope.icon = $mmCourse.getModuleIconSrc(module.modname);
                $scope.title = module.name;
                $scope.class = 'mm-course-default-handler mm-course-module-' + module.modname + '-handler';
                $scope.action = function(e) {
                    $state.go('site.mm_course-modcontent', {module: module});
                    e.preventDefault();
                    e.stopPropagation();
                };
                if (module.url) {
                    $scope.buttons = [{
                        icon: 'ion-share',
                        label: 'mm.core.openinbrowser',
                        action: function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            $mmSite.openInBrowserWithAutoLoginIfSameSite(module.url);
                        }
                    }];
                }
            };
        }
    };
}]);

angular.module('mm.core.course')
.constant('mmCoreCourseModulesStore', 'course_modules')
.config(["$mmSitesFactoryProvider", "mmCoreCourseModulesStore", function($mmSitesFactoryProvider, mmCoreCourseModulesStore) {
    var stores = [
        {
            name: mmCoreCourseModulesStore,
            keyPath: 'id'
        }
    ];
    $mmSitesFactoryProvider.registerStores(stores);
}])
.factory('$mmCourse', ["$mmSite", "$translate", "$q", "$log", "$mmEvents", "$mmSitesManager", "mmCoreEventCompletionModuleViewed", function($mmSite, $translate, $q, $log, $mmEvents, $mmSitesManager, mmCoreEventCompletionModuleViewed) {
    $log = $log.getInstance('$mmCourse');
    var self = {},
        mods = ["assign", "assignment", "book", "chat", "choice", "data", "database", "date", "external-tool",
            "feedback", "file", "folder", "forum", "glossary", "ims", "imscp", "label", "lesson", "lti", "page", "quiz",
            "resource", "scorm", "survey", "url", "wiki", "workshop"
        ],
        modsWithContent = ['book', 'folder', 'imscp', 'page', 'resource', 'url'];
        function addContentsIfNeeded(module) {
        if (modsWithContent.indexOf(module.modname) > -1) {
            module.contents = module.contents || [];
        }
        return module;
    }
        self.canGetModuleWithoutCourseId = function(siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.wsAvailable('core_course_get_course_module');
        });
    };
        self.canGetModuleByInstance = function(siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.wsAvailable('core_course_get_course_module_by_instance');
        });
    };
        self.checkModuleCompletion = function(courseId, completion) {
        if (completion && completion.tracking === 2 && completion.state === 0) {
            self.invalidateSections(courseId).finally(function() {
                $mmEvents.trigger(mmCoreEventCompletionModuleViewed, courseId);
            });
        }
    };
        self.getActivitiesCompletionStatus = function(courseid, userid) {
        userid = userid || $mmSite.getUserId();
        $log.debug('Getting completion status for user ' + userid + ' in course ' + courseid);
        var params = {
                courseid: courseid,
                userid: userid
            },
            preSets = {
                cacheKey: getActivitiesCompletionCacheKey(courseid, userid)
            };
        return $mmSite.read('core_completion_get_activities_completion_status', params, preSets).then(function(data) {
            if (data && data.statuses) {
                var formattedStatuses = {};
                angular.forEach(data.statuses, function(status) {
                    formattedStatuses[status.cmid] = status;
                });
                return formattedStatuses;
            }
            return $q.reject();
        });
    };
        function getActivitiesCompletionCacheKey(courseid, userid) {
        return 'mmCourse:activitiescompletion:' + courseid + ':' + userid;
    }
        self.getModuleBasicInfo = function(moduleId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    cmid: moduleId
                },
                preSets = {
                    cacheKey: getModuleCacheKey(moduleId)
                };
            return site.read('core_course_get_course_module', params, preSets).then(function(response) {
                if (response.cm && (!response.warnings || !response.warnings.length)) {
                    return response.cm;
                }
                return $q.reject();
            });
        });
    };
        self.getModuleBasicGradeInfo = function(moduleId, siteId) {
        return self.getModuleBasicInfo(moduleId, siteId).then(function(info) {
            var grade = {
                advancedgrading: info.advancedgrading || false,
                grade: info.grade || false,
                gradecat: info.gradecat || false,
                gradepass: info.gradepass || false,
                outcomes: info.outcomes || false,
                scale: info.scale || false
            };
            if (grade.grade !== false || grade.advancedgrading !== false || grade.outcomes !== false) {
                return grade;
            }
            return false;
        });
    };
        self.getModuleBasicInfoByInstance = function(id, module, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    instance: id,
                    module: module
                },
                preSets = {
                    cacheKey: getModuleByInstanceCacheKey(id, module)
                };
            return site.read('core_course_get_course_module_by_instance', params, preSets).then(function(response) {
                if (response.cm && (!response.warnings || !response.warnings.length)) {
                    return response.cm;
                }
                return $q.reject();
            });
        });
    };
        self.getModule = function(moduleId, courseId, sectionId, preferCache, ignoreCache, siteId) {
        siteId = siteId || $mmSite.getId();
        if (!moduleId) {
            return $q.reject();
        }
        if (typeof preferCache == 'undefined') {
            preferCache = false;
        }
        var promise;
        if (!courseId) {
            promise = self.getModuleBasicInfo(moduleId, siteId).then(function(module) {
                return module.course;
            });
        } else {
            promise = $q.when(courseId);
        }
        return promise.then(function(cid) {
            courseId = cid;
            return $mmSitesManager.getSite(siteId);
        }).then(function(site) {
            $log.debug('Getting module ' + moduleId + ' in course ' + courseId);
            params = {
                courseid: courseId,
                options: [
                    {
                        name: 'cmid',
                        value: moduleId
                    }
                ]
            };
            preSets = {
                cacheKey: getModuleCacheKey(moduleId),
                omitExpires: preferCache
            };
            if (!preferCache && ignoreCache) {
                preSets.getFromCache = 0;
                preSets.emergencyCache = 0;
            }
            if (sectionId) {
                params.options.push({
                    name: 'sectionid',
                    value: sectionId
                });
            }
            return site.read('core_course_get_contents', params, preSets).catch(function() {
                return self.getSections(courseId, false, false, preSets, siteId);
            }).then(function(sections) {
                var section,
                    module;
                for (var i = 0; i < sections.length; i++) {
                    section = sections[i];
                    for (var j = 0; j < section.modules.length; j++) {
                        module = section.modules[j];
                        if (module.id == moduleId) {
                            module.course = courseId;
                            return addContentsIfNeeded(module);
                        }
                    }
                }
                return $q.reject();
            });
        });
    };
        function getModuleByInstanceCacheKey(id, module) {
        return 'mmCourse:moduleByInstance:' + module + ':' + id;
    }
        function getModuleCacheKey(moduleid) {
        return 'mmCourse:module:' + moduleid;
    }
        self.getModuleIconSrc = function(moduleName) {
        if (mods.indexOf(moduleName) < 0) {
            moduleName = "external-tool";
        }
        return "img/mod/" + moduleName + ".svg";
    };
        self.getModuleSectionId = function(moduleId, courseId, siteId) {
        if (!moduleId) {
            return $q.reject();
        }
        return self.getModuleBasicInfo(moduleId, siteId).then(function(module) {
            return module.section;
        }).catch(function() {
            if (!courseId) {
                return $q.reject();
            }
            return self.getSections(courseId, false, true, {}, siteId).then(function(sections) {
                for (var i = 0, seclen = sections.length; i < seclen; i++) {
                    var section = sections[i];
                    for (var j = 0, modlen = section.modules.length; j < modlen; j++) {
                        if (section.modules[j].id == moduleId) {
                            return section.id;
                        }
                    }
                }
                return $q.reject();
            });
        });
    };
        self.getSection = function(courseId, excludeModules, excludeContents, sectionId) {
        if (sectionId < 0) {
            return $q.reject('Invalid section ID');
        }
        return self.getSections(courseId, excludeModules, excludeContents).then(function(sections) {
            for (var i = 0; i < sections.length; i++) {
                if (sections[i].id == sectionId) {
                    return sections[i];
                }
            }
            return $q.reject('Unkown section');
        });
    };
        self.getSections = function(courseId, excludeModules, excludeContents, preSets, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            preSets = preSets || {};
            preSets.cacheKey = getSectionsCacheKey(courseId);
            preSets.getCacheUsingCacheKey = true;
            var options = [
                    {
                        name: 'excludemodules',
                        value: excludeModules ? 1 : 0
                    },
                    {
                        name: 'excludecontents',
                        value: excludeContents ? 1 : 0
                    }
                ];
            return site.read('core_course_get_contents', {
                courseid: courseId,
                options: options
            }, preSets).then(function(sections) {
                var siteHomeId = site.getSiteHomeId(),
                    showSections = true;
                if (courseId == siteHomeId) {
                    showSections = site.getStoredConfig('numsections');
                }
                if (typeof showSections != 'undefined' && !showSections && sections.length > 0) {
                    sections.pop();
                }
                angular.forEach(sections, function(section) {
                    angular.forEach(section.modules, function(module) {
                        addContentsIfNeeded(module);
                    });
                });
                return sections;
            });
        });
    };
        function getSectionsCacheKey(courseid) {
        return 'mmCourse:sections:' + courseid;
    }
        self.invalidateModule = function(moduleId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getModuleCacheKey(moduleId));
        });
    };
        self.invalidateModuleByInstance = function(id, module, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getModuleByInstanceCacheKey(id, module));
        });
    };
        self.invalidateSections = function(courseId, userId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var promises = [],
                siteHomeId = site.getSiteHomeId();
            userId = userId || site.getUserId();
            promises.push(site.invalidateWsCacheForKey(getSectionsCacheKey(courseId)));
            promises.push(site.invalidateWsCacheForKey(getActivitiesCompletionCacheKey(courseId, userId)));
            if (courseId == siteHomeId) {
                promises.push(site.invalidateConfig());
            }
            return $q.all(promises);
        });
    };
        self.loadModuleContents = function(module, courseId, sectionId, preferCache, ignoreCache, siteId) {
        siteId = siteId || $mmSite.getId();
        if (!ignoreCache && module.contents && module.contents.length) {
            return $q.when();
        }
        return $mmSitesManager.getSite(siteId).then(function(site) {
            if (site.isVersionGreaterEqualThan('2.9')) {
                return self.getModule(module.id, courseId, sectionId, preferCache, ignoreCache, siteId).then(function(mod) {
                    module.contents = mod.contents;
                });
            }
        });
    };
        self.logView = function(courseId, section) {
        var params = {
            courseid: courseId
        };
        if (typeof section != 'undefined') {
            params.sectionnumber = section;
        }
        return $mmSite.write('core_course_view_course', params).then(function(response) {
            if (!response.status) {
                return $q.reject();
            }
        });
    };
        self.translateModuleName = function(moduleName) {
        if (mods.indexOf(moduleName) < 0) {
            moduleName = "external-tool";
        }
        var langKey = 'mm.core.mod_' + moduleName,
            translated = $translate.instant(langKey);
        return translated !== langKey ? translated : moduleName;
    };
    return self;
}]);

angular.module('mm.core.course')
.provider('$mmCourseDelegate', function() {
    var contentHandlers = {},
        self = {};
        self.registerContentHandler = function(addon, handles, handler) {
        if (typeof contentHandlers[handles] !== 'undefined') {
            console.log("$mmCourseDelegateProvider: Addon '" + contentHandlers[handles].addon + "' already registered as handler for '" + handles + "'");
            return false;
        }
        console.log("$mmCourseDelegateProvider: Registered addon '" + addon + "' as course content handler.");
        contentHandlers[handles] = {
            addon: addon,
            handler: handler,
            instance: undefined
        };
        return true;
    };
    self.$get = ["$q", "$log", "$mmSite", "$mmUtil", "$mmCourseContentHandler", function($q, $log, $mmSite, $mmUtil, $mmCourseContentHandler) {
        var enabledHandlers = {},
            self = {},
            lastUpdateHandlersStart = {};
        $log = $log.getInstance('$mmCourseDelegate');
                self.getContentHandlerControllerFor = function(handles, module, courseid, sectionid) {
            if (typeof enabledHandlers[handles] !== 'undefined') {
                return enabledHandlers[handles].getController(module, courseid, sectionid);
            }
            return $mmCourseContentHandler.getController(module, courseid, sectionid);
        };
                self.hasContentHandler = function(handles) {
            return typeof contentHandlers[handles] !== 'undefined';
        };
                self.isModuleDisabled = function(handles, siteId) {
            return $mmSitesManager.getSite(siteId).then(function(site) {
                return self.isModuleDisabledInSite(handles, site);
            });
        };
                self.isModuleDisabledInSite = function(handles, site) {
            site = site || $mmSite;
            if (typeof contentHandlers[handles] !== 'undefined') {
                return site.isFeatureDisabled('$mmCourseDelegate_' + contentHandlers[handles].addon);
            }
            return false;
        };
                self.isLastUpdateCall = function(time) {
            if (!lastUpdateHandlersStart) {
                return true;
            }
            return time == lastUpdateHandlersStart;
        };
                self.updateContentHandler = function(handles, handlerInfo, time) {
            var promise,
                siteId = $mmSite.getId();
            if (typeof handlerInfo.instance === 'undefined') {
                handlerInfo.instance = $mmUtil.resolveObject(handlerInfo.handler, true);
            }
            if (!$mmSite.isLoggedIn()) {
                promise = $q.reject();
            } else if ($mmSite.isFeatureDisabled('$mmCourseDelegate_' + handlerInfo.addon)) {
                promise = $q.when(false);
            } else {
                promise = $q.when(handlerInfo.instance.isEnabled());
            }
            return promise.catch(function() {
                return false;
            }).then(function(enabled) {
                if (self.isLastUpdateCall(time) && $mmSite.isLoggedIn() && $mmSite.getId() === siteId) {
                    if (enabled) {
                        enabledHandlers[handles] = handlerInfo.instance;
                    } else {
                        delete enabledHandlers[handles];
                    }
                }
            });
        };
                self.updateContentHandlers = function() {
            var promises = [],
                now = new Date().getTime();
            $log.debug('Updating content handlers for current site.');
            lastUpdateHandlersStart = now;
            angular.forEach(contentHandlers, function(handlerInfo, handles) {
                promises.push(self.updateContentHandler(handles, handlerInfo, now));
            });
            return $q.all(promises).then(function() {
                return true;
            }, function() {
                return true;
            });
        };
        return self;
    }];
    return self;
});

angular.module('mm.core.course')
.factory('$mmCourseHelper', ["$q", "$mmCoursePrefetchDelegate", "$mmFilepool", "$mmUtil", "$mmCourse", "$mmSite", "$state", "$mmText", "mmCoreNotDownloaded", "mmCoreOutdated", "mmCoreDownloading", "mmCoreCourseAllSectionsId", "$mmSitesManager", "$mmAddonManager", "$controller", "$mmCourseDelegate", "$translate", "$mmEvents", "mmCoreEventPackageStatusChanged", function($q, $mmCoursePrefetchDelegate, $mmFilepool, $mmUtil, $mmCourse, $mmSite, $state, $mmText,
            mmCoreNotDownloaded, mmCoreOutdated, mmCoreDownloading, mmCoreCourseAllSectionsId, $mmSitesManager, $mmAddonManager,
            $controller, $mmCourseDelegate, $translate, $mmEvents, mmCoreEventPackageStatusChanged) {
    var self = {},
        calculateSectionStatus = false;
        self.isDownloadSectionsEnabled = function() {
        return calculateSectionStatus;
    };
        self.setDownloadSectionsEnabled = function(status) {
        calculateSectionStatus = status;
        return calculateSectionStatus;
    };
        self.calculateSectionStatus = function(section, courseid, restoreDownloads, refresh, dwnpromises) {
        if (section.id !== mmCoreCourseAllSectionsId) {
            return $mmCoursePrefetchDelegate.getModulesStatus(section.id, section.modules, courseid, refresh, restoreDownloads)
                    .then(function(result) {
                var downloadid = self.getSectionDownloadId(section);
                if ($mmCoursePrefetchDelegate.isBeingDownloaded(downloadid)) {
                    result.status = mmCoreDownloading;
                }
                section.showDownload = result.status === mmCoreNotDownloaded;
                section.showRefresh = result.status === mmCoreOutdated;
                if (result.status !== mmCoreDownloading) {
                    section.isDownloading = false;
                    section.total = 0;
                } else if (!restoreDownloads) {
                    section.count = 0;
                    section.total = result[mmCoreOutdated].length + result[mmCoreNotDownloaded].length +
                                    result[mmCoreDownloading].length;
                    section.isDownloading = true;
                } else {
                    var promise = self.startOrRestorePrefetch(section, result, courseid).then(function(prevented) {
                        if (prevented !== true) {
                            return self.calculateSectionStatus(section, courseid);
                        }
                    });
                    if (dwnpromises) {
                        dwnpromises.push(promise);
                    }
                }
                return result;
            });
        }
        return $q.reject();
    };
        self.calculateSectionsStatus = function(sections, courseid, restoreDownloads, refresh) {
        var allsectionssection,
            allsectionsstatus,
            downloadpromises = [],
            statuspromises = [];
        angular.forEach(sections, function(section) {
            if (section.id === mmCoreCourseAllSectionsId) {
                allsectionssection = section;
                section.isCalculating = true;
            } else {
                section.isCalculating = true;
                statuspromises.push(self.calculateSectionStatus(section, courseid, restoreDownloads, refresh, downloadpromises)
                        .then(function(result) {
                    allsectionsstatus = $mmFilepool.determinePackagesStatus(allsectionsstatus, result.status);
                }).finally(function() {
                    section.isCalculating = false;
                }));
            }
        });
        return $q.all(statuspromises).then(function() {
            if (allsectionssection) {
                allsectionssection.showDownload = allsectionsstatus === mmCoreNotDownloaded;
                allsectionssection.showRefresh = allsectionsstatus === mmCoreOutdated;
                allsectionssection.isDownloading = allsectionsstatus === mmCoreDownloading;
            }
            return downloadpromises;
        }).finally(function() {
            if (allsectionssection) {
                allsectionssection.isCalculating = false;
            }
        });
    };
        self.confirmDownloadSize = function(courseid, section, sections) {
        var sizePromise;
        if (section.id != mmCoreCourseAllSectionsId) {
            sizePromise = $mmCoursePrefetchDelegate.getDownloadSize(section.modules, courseid);
        } else {
            var promises = [],
                results = {
                    size: 0,
                    total: true
                };
            angular.forEach(sections, function(s) {
                if (s.id != mmCoreCourseAllSectionsId) {
                    promises.push($mmCoursePrefetchDelegate.getDownloadSize(s.modules, courseid).then(function(sectionsize) {
                        results.total = results.total && sectionsize.total;
                        results.size += sectionsize.size;
                    }));
                }
            });
            sizePromise = $q.all(promises).then(function() {
                return results;
            });
        }
        return sizePromise.then(function(size) {
            return $mmUtil.confirmDownloadSize(size);
        });
    };
        self.getModuleCourseIdByInstance = function(id, module, siteId) {
        return $mmCourse.getModuleBasicInfoByInstance(id, module, siteId).then(function(cm) {
            return cm.course;
        }).catch(function(error) {
            if (error) {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mm.course.errorgetmodule', true);
            }
            return $q.reject();
        });
    };
        self.getModulePrefetchInfo = function(module, courseId, invalidateCache) {
        var moduleInfo = {
                size: false,
                sizeReadable: false,
                timemodified: false,
                timemodifiedReadable: false,
                status: false,
                statusIcon: false
            },
            promises = [];
        if (typeof invalidateCache != "undefined" && invalidateCache) {
            $mmCoursePrefetchDelegate.invalidateModuleStatusCache(module);
        }
        promises.push($mmCoursePrefetchDelegate.getModuleDownloadedSize(module, courseId).then(function(moduleSize) {
            moduleInfo.size = moduleSize;
            moduleInfo.sizeReadable = $mmText.bytesToSize(moduleSize, 2);
        }));
        promises.push($mmCoursePrefetchDelegate.getModuleTimemodified(module, courseId).then(function(moduleModified) {
            moduleInfo.timemodified = moduleModified;
            if (moduleModified > 0) {
                var now = $mmUtil.timestamp();
                if (now - moduleModified < 7 * 86400) {
                    moduleInfo.timemodifiedReadable = moment(moduleModified * 1000).fromNow();
                } else {
                    moduleInfo.timemodifiedReadable = moment(moduleModified * 1000).calendar();
                }
            } else {
                moduleInfo.timemodifiedReadable = "";
            }
        }));
        promises.push($mmCoursePrefetchDelegate.getModuleStatus(module, courseId).then(function(moduleStatus) {
            moduleInfo.status = moduleStatus;
            switch (moduleStatus) {
                case mmCoreNotDownloaded:
                    moduleInfo.statusIcon = 'ion-ios-cloud-download-outline';
                    break;
                case mmCoreDownloading:
                    moduleInfo.statusIcon = 'spinner';
                    break;
                case mmCoreOutdated:
                    moduleInfo.statusIcon = 'ion-android-refresh';
                    break;
                default:
                    moduleInfo.statusIcon = "";
                    break;
            }
        }));
        return $q.all(promises).then(function () {
            return moduleInfo;
        });
    };
        self.getSectionDownloadId = function(section) {
        return 'Section-'+section.id;
    };
        self.getSectionsModules = function(sections) {
        if (!sections || !sections.length) {
            return [];
        }
        var modules = [];
        sections.forEach(function(section) {
            if (section.modules) {
                modules = modules.concat(section.modules);
            }
        });
        return modules;
    };
        self.addContentHandlerControllerForSectionModules = function(sections, courseId, moduleId, completionStatus, scope) {
        var hasContent = false;
        angular.forEach(sections, function(section) {
            if (!section || !self.sectionHasContent(section)) {
                return;
            }
            hasContent = true;
            angular.forEach(section.modules, function(module) {
                module._controller =
                        $mmCourseDelegate.getContentHandlerControllerFor(module.modname, module, courseId, section.id);
                if (completionStatus && typeof completionStatus[module.id] != 'undefined') {
                    module.completionstatus = completionStatus[module.id];
                }
                if (module.id == moduleId) {
                    var newScope = scope.$new();
                    $controller(module._controller, {$scope: newScope});
                    if (newScope.action) {
                        newScope.action();
                    }
                    newScope.$destroy();
                }
            });
        });
        return hasContent;
    }
        self.navigateToModule = function(moduleId, siteId, courseId, sectionId) {
        siteId = siteId || $mmSite.getId();
        var modal = $mmUtil.showModalLoading(),
            promise;
        return $mmCourse.canGetModuleWithoutCourseId(siteId).then(function(enabled) {
            if (courseId && sectionId) {
                promise = $q.when();
            } else if (!courseId && !enabled) {
                promise = $q.reject();
            } else if (!courseId) {
                promise = $mmCourse.getModuleBasicInfo(moduleId, siteId).then(function(module) {
                    courseId = module.course;
                    sectionId = module.section;
                });
            } else {
                promise = $mmCourse.getModuleSectionId(moduleId, courseId, siteId).then(function(id) {
                    sectionId = id;
                });
            }
            return promise.then(function() {
                return $mmSitesManager.getSite(siteId);
            }).then(function(site) {
                if (courseId == site.getSiteHomeId()) {
                    var $mmaFrontpage = $mmAddonManager.get('$mmaFrontpage');
                    if ($mmaFrontpage && !$mmaFrontpage.isDisabledInSite(site)) {
                        return $mmaFrontpage.isFrontpageAvailable().then(function() {
                            return $state.go('redirect', {
                                siteid: siteId,
                                state: 'site.frontpage',
                                params: {
                                    moduleid: moduleId
                                }
                            });
                        });
                    }
                } else {
                    return $state.go('redirect', {
                        siteid: siteId,
                        state: 'site.mm_course',
                        params: {
                            courseid: courseId,
                            moduleid: moduleId,
                            sid: sectionId
                        }
                    });
                }
            });
        }).catch(function(error) {
            $mmUtil.showErrorModalDefault(error, 'mm.course.errorgetmodule', true);
            return $q.reject();
        }).finally(function() {
            modal.dismiss();
        });
    };
        self.prefetch = function(section, courseid, sections) {
        if (section.id != mmCoreCourseAllSectionsId) {
            return self.prefetchSection(section, courseid, true, sections);
        } else {
            var promises = [];
            section.isDownloading = true;
            angular.forEach(sections, function(s) {
                if (s.id != mmCoreCourseAllSectionsId) {
                    promises.push(self.prefetchSection(s, courseid, false, sections).then(function() {
                        return self.calculateSectionStatus(s, courseid);
                    }));
                }
            });
            return $mmUtil.allPromises(promises);
        }
    };
        self.prefetchModule = function(scope, service, module, size, refresh, courseId) {
        return $mmUtil.confirmDownloadSize(size).then(function() {
            var promise = refresh ? service.invalidateContent(module.id, courseId) : $q.when();
            return promise.catch(function() {
            }).then(function() {
                var promise;
                if (service.prefetch) {
                    promise = service.prefetch(module, courseId);
                } else if (service.prefetchContent) {
                    promise = service.prefetchContent(module, courseId);
                } else {
                    return $q.reject();
                }
                return promise.catch(function() {
                    if (!scope.$$destroyed) {
                        $mmUtil.showErrorModal('mm.core.errordownloading', true);
                    }
                });
            });
        });
    };
        self.prefetchSection = function(section, courseid, singleDownload, sections) {
        if (section.id == mmCoreCourseAllSectionsId) {
            return $q.when();
        }
        section.isDownloading = true;
        return $mmCoursePrefetchDelegate.getModulesStatus(section.id, section.modules, courseid).then(function(result) {
            if (result.status === mmCoreNotDownloaded || result.status === mmCoreOutdated || result.status === mmCoreDownloading) {
                var promise = self.startOrRestorePrefetch(section, result, courseid);
                if (singleDownload) {
                    self.calculateSectionsStatus(sections, courseid, false);
                }
                return promise;
            }
        }, function() {
            section.isDownloading = false;
            return $q.reject();
        });
    };
        self.startOrRestorePrefetch = function(section, status, courseid) {
        if (section.id == mmCoreCourseAllSectionsId) {
            return $q.when(true);
        }
        if (section.total > 0) {
            return $q.when(true);
        }
        var modules = status[mmCoreOutdated].concat(status[mmCoreNotDownloaded]).concat(status[mmCoreDownloading]),
            downloadid = self.getSectionDownloadId(section);
        section.count = 0;
        section.total = modules.length;
        section.dwnModuleIds = modules.map(function(m) {
            return m.id;
        });
        section.isDownloading = true;
        return $mmCoursePrefetchDelegate.prefetchAll(downloadid, modules, courseid).then(function() {}, function() {
            return $q.reject();
        }, function(id) {
            var index = section.dwnModuleIds.indexOf(id);
            if (index > -1) {
                section.dwnModuleIds.splice(index, 1);
                section.count++;
            }
        });
    };
        self.sectionHasContent = function(section) {
        return !section.hiddenbynumsections  && (section.summary != '' || section.modules.length);
    };
        self.confirmAndRemove = function(module, courseId) {
        return $mmUtil.showConfirm($translate('mm.course.confirmdeletemodulefiles')).then(function() {
            return $mmCoursePrefetchDelegate.removeModuleFiles(module, courseId);
        });
    };
        self.contextMenuPrefetch = function(scope, module, courseId) {
        var icon = scope.prefetchStatusIcon;
        scope.prefetchStatusIcon = 'spinner';
        return $mmCoursePrefetchDelegate.getModuleDownloadSize(module, courseId).then(function(size) {
            return $mmUtil.confirmDownloadSize(size).then(function() {
                return $mmCoursePrefetchDelegate.prefetchModule(module, courseId).catch(function() {
                    return failPrefetch(!scope.$$destroyed);
                });
            }, function() {
                scope.prefetchStatusIcon = icon;
                return failPrefetch(false);
            });
        }, function(error) {
            return failPrefetch(true, error);
        });
        function failPrefetch(showError, error) {
            scope.prefetchStatusIcon = icon;
            if (showError) {
                $mmUtil.showErrorModalDefault(error, 'mm.core.errordownloading', true);
            }
            return $q.reject();
        }
    };
        self.fillContextMenu = function(scope, module, courseId, invalidateCache, component) {
        return self.getModulePrefetchInfo(module, courseId, invalidateCache).then(function(moduleInfo) {
            scope.size = moduleInfo.size > 0 ? moduleInfo.sizeReadable : 0;
            scope.prefetchStatusIcon = moduleInfo.statusIcon;
            if (moduleInfo.timemodified > 0) {
                scope.timemodified = $translate.instant('mm.core.lastmodified') + ': ' + moduleInfo.timemodifiedReadable;
            } else {
                scope.timemodified = $translate.instant('mm.core.download');
            }
            if (typeof scope.statusObserver == 'undefined' && component) {
                scope.statusObserver = $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
                    if (data.siteid === $mmSite.getId() && data.componentId === module.id && data.component === component) {
                        self.fillContextMenu(scope, module, courseId, false, component);
                    }
                });
                scope.$on('$destroy', function() {
                    scope.statusObserver && scope.statusObserver.off && scope.statusObserver.off();
                });
            }
        });
    };
    return self;
}])
.run(["$mmEvents", "mmCoreEventLogout", "$mmCourseHelper", function($mmEvents, mmCoreEventLogout, $mmCourseHelper) {
    $mmEvents.on(mmCoreEventLogout, function() {
        $mmCourseHelper.setDownloadSectionsEnabled(false);
    });
}]);
angular.module('mm.core')
.provider('$mmCoursePrefetchDelegate', function() {
    var prefetchHandlers = {},
        self = {};
        self.registerPrefetchHandler = function(addon, handles, handler) {
        if (typeof prefetchHandlers[handles] !== 'undefined') {
            console.log("$mmCoursePrefetchDelegateProvider: Addon '" + prefetchHandlers[handles].addon +
                            "' already registered as handler for '" + handles + "'");
            return false;
        }
        console.log("$mmCoursePrefetchDelegateProvider: Registered addon '" + addon + "' as prefetch handler.");
        prefetchHandlers[handles] = {
            addon: addon,
            handler: handler,
            instance: undefined
        };
        return true;
    };
    self.$get = ["$q", "$log", "$mmSite", "$mmUtil", "$mmFilepool", "$mmEvents", "$mmCourse", "mmCoreDownloaded", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", "mmCoreNotDownloadable", "mmCoreEventSectionStatusChanged", "$mmFS", "md5", function($q, $log, $mmSite, $mmUtil, $mmFilepool, $mmEvents, $mmCourse, mmCoreDownloaded, mmCoreDownloading,
                mmCoreNotDownloaded, mmCoreOutdated, mmCoreNotDownloadable, mmCoreEventSectionStatusChanged, $mmFS, md5) {
        var enabledHandlers = {},
            self = {},
            deferreds = {},
            lastUpdateHandlersStart,
            courseUpdatesPromises = {};
        $log = $log.getInstance('$mmCoursePrefetchDelegate');
                self.canCheckUpdates = function() {
            return $mmSite.wsAvailable('core_course_check_updates');
        };
                 self.canModuleUseCheckUpdates = function(module, courseId) {
            var handler = enabledHandlers[module.modname];
            if (!handler) {
                return $q.when(false);
            }
            if (handler.canUseCheckUpdates) {
                return $q.when(handler.canUseCheckUpdates(module, courseId));
            }
            return $q.when(true);
        };
                self.clearStatusCache = function() {
            statusCache.clear();
        };
                self.invalidateModuleStatusCache = function(module) {
            var handler = enabledHandlers[module.modname];
            if (handler) {
                statusCache.invalidate(handler.component, module.id);
            }
        };
        var statusCache = new function() {
            var cacheStore = {};
            this.clear = function() {
                cacheStore = {};
            };
                        this.get = function(component, componentId) {
                var packageId = $mmFilepool.getPackageId(component, componentId);
                if (!cacheStore[packageId]) {
                    cacheStore[packageId] = {};
                }
                return cacheStore[packageId];
            };
                        this.getValue = function(component, componentId, name, ignoreInvalidate) {
                var cache = this.get(component, componentId);
                if (cache[name] && typeof cache[name].value != "undefined") {
                    var now = new Date().getTime();
                    if (ignoreInvalidate || cache[name].lastupdate + 300000 >= now) {
                        return cache[name].value;
                    }
                }
                return undefined;
            };
                        this.setValue = function(component, componentId, name, value) {
                var cache = this.get(component, componentId);
                cache[name] = {
                    value: value,
                    lastupdate: new Date().getTime()
                };
                return value;
            };
                        this.invalidate = function(component, componentId) {
                var cache = this.get(component, componentId);
                angular.forEach(cache, function(entry) {
                    entry.lastupdate = 0;
                });
            };
        };
                self.determineModuleStatus = function(module, status, restoreDownloads, canCheck) {
            var handler = enabledHandlers[module.modname];
            if (handler) {
                if (status == mmCoreDownloading && restoreDownloads) {
                    if (!$mmFilepool.getPackageDownloadPromise($mmSite.getId(), handler.component, module.id)) {
                        handler.prefetch(module);
                    }
                } else if (handler.determineStatus) {
                    return handler.determineStatus(status, canCheck);
                }
            }
            return status;
        };
                function getCourseUpdatesCacheKey(courseId) {
            return 'mmCourse:courseUpdates:' + courseId;
        }
                function createToCheckList(modules, courseId) {
            var result = {
                    toCheck: [],
                    cannotUse: []
                },
                promises = [];
            angular.forEach(modules, function(module) {
                promises.push(getModuleStatusAndDownloadTime(module, courseId).then(function(data) {
                    if (data.status == mmCoreDownloaded) {
                        return self.canModuleUseCheckUpdates(module, courseId).then(function(canUse) {
                            if (canUse) {
                                result.toCheck.push({
                                    contextlevel: 'module',
                                    id: module.id,
                                    since: data.downloadtime || 0
                                });
                            } else {
                                result.cannotUse.push(module);
                            }
                        });
                    }
                }).catch(function() {
                }));
            });
            return $q.all(promises).then(function() {
                result.toCheck.sort(function (a, b) {
                    return a.id > b.id;
                });
                return result;
            });
        }
                function getModuleStatusAndDownloadTime(module, courseId) {
            var handler = enabledHandlers[module.modname],
                siteId = $mmSite.getId();
            if (handler) {
                return self.isModuleDownloadable(module, courseId).then(function(downloadable) {
                    if (!downloadable) {
                        return {
                            status: mmCoreNotDownloadable
                        };
                    }
                    var status = statusCache.getValue(handler.component, module.id, 'status');
                    if (typeof status != 'undefined' && status != mmCoreDownloaded) {
                        return {
                            status: status
                        };
                    }
                    return $mmFilepool.getPackageData(siteId, handler.component, module.id).then(function(data) {
                        var time = typeof data.downloadtime != 'undefined' ? data.downloadtime : data.timemodified;
                        return {
                            status: data.status,
                            downloadtime: time
                        };
                    });
                });
            }
            return $q.when({
                status: mmCoreNotDownloadable
            });
        }
                self.getCourseUpdates = function(modules, courseId) {
            if (!self.canCheckUpdates()) {
                return $q.reject();
            }
            var id = md5.createHash(courseId + '#' + JSON.stringify(modules)),
                siteId = $mmSite.getId(),
                promise;
            if (courseUpdatesPromises[siteId] && courseUpdatesPromises[siteId][id]) {
                return courseUpdatesPromises[siteId][id];
            } else if (!courseUpdatesPromises[siteId]) {
                courseUpdatesPromises[siteId] = {};
            }
            promise = createToCheckList(modules, courseId).then(function(data) {
                var result = {},
                    params,
                    preSets;
                angular.forEach(data.cannotUse, function(module) {
                    result[module.id] = false;
                });
                if (!data.toCheck.length) {
                    return result;
                }
                params = {
                    courseid: courseId,
                    tocheck: data.toCheck
                };
                preSets = {
                    cacheKey: getCourseUpdatesCacheKey(courseId),
                    getEmergencyCacheUsingCacheKey: true,
                    uniqueCacheKey: true
                };
                return $mmSite.read('core_course_check_updates', params, preSets).then(function(response) {
                    if (!response || typeof response.instances == 'undefined') {
                        return $q.reject();
                    }
                    angular.forEach(response.instances, function(instance) {
                        result[instance.id] = instance;
                    });
                    angular.forEach(response.warnings, function(warning) {
                        if (warning.warningcode == 'missingcallback') {
                            result[warning.itemid] = false;
                        }
                    });
                    return result;
                });
            }).finally(function() {
                delete courseUpdatesPromises[siteId][id];
            });
            courseUpdatesPromises[siteId][id] = promise;
            return promise;
        };
                self.getCourseUpdatesByCourseId = function(courseId) {
            if (!self.canCheckUpdates()) {
                return $q.reject();
            }
            return $mmCourse.getSections(courseId, false, true, {omitExpires: true}).then(function(sections) {
                var modules = [];
                angular.forEach(sections, function(section) {
                    if (section.modules) {
                        modules = modules.concat(section.modules);
                    }
                });
                return self.getCourseUpdates(modules, courseId);
            });
        };
                self.invalidateCourseUpdates = function(courseId) {
            return $mmSite.invalidateWsCacheForKey(getCourseUpdatesCacheKey(courseId));
        };
                self.getDownloadSize = function(modules, courseid) {
            var promises = [],
                results = {
                    size: 0,
                    total: true
                };
            angular.forEach(modules, function(module) {
                promises.push(self.getModuleStatus(module, courseid).then(function(modstatus) {
                    if (modstatus === mmCoreNotDownloaded || modstatus === mmCoreOutdated) {
                        return self.getModuleDownloadSize(module, courseid).then(function(modulesize) {
                            results.total = results.total && modulesize.total;
                            results.size += modulesize.size;
                        });
                    }
                    return $q.when();
                }));
            });
            return $q.all(promises).then(function() {
                return results;
            });
        };
                self.prefetchModule = function(module, courseid) {
            var handler = enabledHandlers[module.modname];
            if (handler) {
                return handler.prefetch(module, courseid);
            }
            return $q.when();
        };
                self.getModuleDownloadSize = function(module, courseid) {
            var downloadSize,
                handler = enabledHandlers[module.modname];
            if (handler) {
                return self.isModuleDownloadable(module, courseid).then(function(downloadable) {
                    if (!downloadable) {
                        return;
                    }
                    downloadSize = statusCache.getValue(handler.component, module.id, 'downloadSize');
                    if (typeof downloadSize != 'undefined') {
                        return downloadSize;
                    }
                    return $q.when(handler.getDownloadSize(module, courseid)).then(function(size) {
                        return statusCache.setValue(handler.component, module.id, 'downloadSize', size);
                    }).catch(function() {
                        return statusCache.getValue(handler.component, module.id, 'downloadSize', true);
                    });
                });
            }
            return $q.when(0);
        };
                self.getModuleDownloadedSize = function(module, courseid) {
            var downloadedSize,
                handler = enabledHandlers[module.modname];
            if (handler) {
                return self.isModuleDownloadable(module, courseid).then(function(downloadable) {
                    var promise;
                    if (!downloadable) {
                        return 0;
                    }
                    downloadedSize = statusCache.getValue(handler.component, module.id, 'downloadedSize');
                    if (typeof downloadedSize != 'undefined') {
                        return downloadedSize;
                    }
                    if (handler.getDownloadedSize) {
                        promise = $q.when(handler.getDownloadedSize(module, courseid));
                    } else {
                        promise = self.getModuleFiles(module, courseid).then(function(files) {
                            var siteId = $mmSite.getId(),
                                promises = [],
                                size = 0;
                            angular.forEach(files, function(file) {
                                promises.push($mmFilepool.getFilePathByUrl(siteId, file.fileurl).then(function(path) {
                                    return $mmFS.getFileSize(path).catch(function () {
                                        return $mmFilepool.isFileDownloadingByUrl(siteId, file.fileurl).then(function() {
                                            return file.filesize;
                                        }).catch(function() {
                                            return 0;
                                        });
                                    }).then(function(fs) {
                                        size += fs;
                                    });
                                }));
                            });
                            return $q.all(promises).then(function() {
                                return size;
                            });
                        });
                    }
                    return promise.then(function(size) {
                        return statusCache.setValue(handler.component, module.id, 'downloadedSize', size);
                    }).catch(function() {
                        return statusCache.getValue(handler.component, module.id, 'downloadedSize', true);
                    });
                });
            }
            return $q.when(0);
        };
                self.getModuleTimemodified = function(module, courseid, files) {
            var handler = enabledHandlers[module.modname],
                promise, timemodified;
            if (handler) {
                timemodified = statusCache.getValue(handler.component, module.id, 'timemodified');
                if (typeof timemodified != 'undefined') {
                    return $q.when(timemodified);
                }
                if (handler.getTimemodified) {
                    promise = handler.getTimemodified(module, courseid);
                } else {
                    promise = files ? $q.when(files) : self.getModuleFiles(module, courseid);
                    return promise.then(function(files) {
                        return $mmFilepool.getTimemodifiedFromFileList(files);
                    });
                }
                return $q.when(promise).then(function(timemodified) {
                    return statusCache.setValue(handler.component, module.id, 'timemodified', timemodified);
                }).catch(function() {
                    return statusCache.getValue(handler.component, module.id, 'timemodified', true);
                });
            }
            return $q.reject();
        };
                self.getModuleRevision = function(module, courseid, files) {
            var handler = enabledHandlers[module.modname],
                promise, revision;
            if (handler) {
                revision = statusCache.getValue(handler.component, module.id, 'revision');
                if (typeof revision != 'undefined') {
                    return $q.when(revision);
                }
                if (handler.getRevision) {
                    promise = handler.getRevision(module, courseid);
                } else {
                    promise = files ? $q.when(files) : self.getModuleFiles(module, courseid);
                    promise = promise.then(function(files) {
                        return $mmFilepool.getRevisionFromFileList(files);
                    });
                }
                return $q.when(promise).then(function(revision) {
                    return statusCache.setValue(handler.component, module.id, 'revision', revision);
                }).catch(function() {
                    return statusCache.getValue(handler.component, module.id, 'revision', true);
                });
            }
            return $q.reject();
        };
                self.getModuleFiles = function(module, courseId) {
            var handler = enabledHandlers[module.modname];
            module.contents = module.contents || [];
            if (handler.getFiles) {
                return $q.when(handler.getFiles(module, courseId));
            } else if (handler.loadContents) {
                return handler.loadContents(module, courseId).then(function() {
                    return module.contents;
                });
            } else {
                return $q.when(module.contents);
            }
        };
                self.removeModuleFiles = function(module, courseid) {
            var handler = enabledHandlers[module.modname],
                siteId = $mmSite.getId(),
                promise;
            if (handler && handler.removeFiles) {
                promise = handler.removeFiles(module, courseid);
            } else {
                promise = self.getModuleFiles(module, courseid).then(function(files) {
                    var promises = [];
                    angular.forEach(files, function(file) {
                        promises.push($mmFilepool.removeFileByUrl(siteId, file.fileurl).catch(function() {
                        }));
                    });
                    return $q.all(promises);
                });
            }
            return promise.then(function() {
                if (handler) {
                    statusCache.setValue(handler.component, module.id, 'downloadedSize', 0);
                    $mmFilepool.storePackageStatus(siteId, handler.component, module.id, mmCoreNotDownloaded);
                }
            });
        };
                self.getModuleStatus = function(module, courseid, revision, timemodified, updates) {
            var handler = enabledHandlers[module.modname],
                siteid = $mmSite.getId(),
                canCheck = self.canCheckUpdates();
            if (handler) {
                return self.isModuleDownloadable(module, courseid).then(function(downloadable) {
                    if (!downloadable) {
                        return mmCoreNotDownloadable;
                    }
                    var status = statusCache.getValue(handler.component, module.id, 'status'),
                        promise;
                    if (typeof status != 'undefined') {
                        return self.determineModuleStatus(module, status, true, canCheck);
                    }
                    return $mmFilepool.getPackageCurrentStatus(siteid, handler.component, module.id).then(function(status) {
                        status = handler.determineStatus ? handler.determineStatus(status, canCheck) : status;
                        if (status == mmCoreNotDownloaded || status == mmCoreOutdated || status == mmCoreDownloading) {
                            self.updateStatusCache(handler.component, module.id, status);
                            return self.determineModuleStatus(module, status, true, canCheck);
                        }
                        if (typeof updates == 'undefined') {
                            promise = self.getCourseUpdatesByCourseId(courseid).then(function(updates) {
                                if (!updates || updates[module.id] === false) {
                                    return $q.reject();
                                }
                                return updates;
                            });
                        } else if (updates === false) {
                            promise = $q.reject();
                        } else {
                            promise = $q.when(updates);
                        }
                        return promise.then(function(updates) {
                            var hasUpdPrms = self.moduleHasUpdates(module, courseid, updates).then(function(hasUpdates) {
                                if (hasUpdates) {
                                    status = mmCoreOutdated;
                                    return $mmFilepool.storePackageStatus(siteid, handler.component, module.id, status)
                                            .catch(function() {
                                    }).then(function() {
                                        return status;
                                    });
                                } else {
                                    return status;
                                }
                            });
                            return getStatus(hasUpdPrms, true);
                        }, function() {
                            var revisionNeedsFiles = typeof revision == 'undefined' && !handler.getRevision &&
                                            typeof statusCache.getValue(handler.component, module.id, 'revision') == 'undefined',
                                timemodifiedNeedsFiles = typeof timemodified == 'undefined' && !handler.getTimemodified &&
                                            typeof statusCache.getValue(handler.component, module.id, 'timemodified') == 'undefined';
                            if (revisionNeedsFiles || timemodifiedNeedsFiles) {
                                promise = self.getModuleFiles(module, courseid);
                            } else {
                                promise = $q.when();
                            }
                            return promise.then(function(files) {
                                var promises = [];
                                if (typeof revision == 'undefined') {
                                    promises.push(self.getModuleRevision(module, courseid, files).then(function(rev) {
                                        revision = rev;
                                    }));
                                }
                                if (typeof timemodified == 'undefined') {
                                    promises.push(self.getModuleTimemodified(module, courseid, files).then(function(timemod) {
                                        timemodified = timemod;
                                    }));
                                }
                                return $q.all(promises).then(function() {
                                    var getStatusPromise = $mmFilepool.getPackageStatus(
                                            siteid, handler.component, module.id, revision, timemodified);
                                    return getStatus(getStatusPromise, false);
                                });
                            });
                        });
                    });
                });
            }
            return $q.when(mmCoreNotDownloadable);
            function getStatus(promise, canCheck) {
                return promise.then(function(status) {
                    self.updateStatusCache(handler.component, module.id, status);
                    return self.determineModuleStatus(module, status, true, canCheck);
                }).catch(function() {
                    var status = statusCache.getValue(handler.component, module.id, 'status', true);
                    return self.determineModuleStatus(module, status, true, canCheck);
                });
            }
        };
                self.getModulesStatus = function(sectionid, modules, courseid, refresh, restoreDownloads) {
            var promises = [],
                status = mmCoreNotDownloadable,
                result = {};
            result[mmCoreNotDownloaded] = [];
            result[mmCoreDownloaded] = [];
            result[mmCoreDownloading] = [];
            result[mmCoreOutdated] = [];
            result.total = 0;
            return self.getCourseUpdatesByCourseId(courseid).catch(function() {
                return false;
            }).then(function(updates) {
                angular.forEach(modules, function(module) {
                    var handler = enabledHandlers[module.modname],
                        promise,
                        canCheck = updates && updates[module.id] !== false;
                    module.contents = module.contents || [];
                    if (handler) {
                        var cacheStatus = statusCache.getValue(handler.component, module.id, 'status');
                        if (!refresh && typeof cacheStatus != 'undefined') {
                            promise = $q.when(self.determineModuleStatus(module, cacheStatus, restoreDownloads, canCheck));
                        } else {
                            promise = self.getModuleStatus(module, courseid, undefined, undefined, updates);
                        }
                        promises.push(
                            promise.then(function(modstatus) {
                                if (modstatus != mmCoreNotDownloadable) {
                                    statusCache.setValue(handler.component, module.id, 'sectionid', sectionid);
                                    self.updateStatusCache(handler.component, module.id, modstatus);
                                    status = $mmFilepool.determinePackagesStatus(status, modstatus);
                                    result[modstatus].push(module);
                                    result.total++;
                                }
                            }).catch(function() {
                                modstatus = statusCache.getValue(handler.component, module.id, 'status', true);
                                if (typeof modstatus == 'undefined') {
                                    return $q.reject();
                                }
                                if (modstatus != mmCoreNotDownloadable) {
                                    status = $mmFilepool.determinePackagesStatus(status, modstatus);
                                    result[modstatus].push(module);
                                    result.total++;
                                }
                            })
                        );
                    }
                });
                return $q.all(promises).then(function() {
                    result.status = status;
                    return result;
                });
            });
        };
                self.getPrefetchHandlerFor = function(handles) {
            return enabledHandlers[handles];
        };
                self.invalidateModules = function(modules, courseId) {
            var promises = [];
            angular.forEach(modules, function(module) {
                var handler = enabledHandlers[module.modname];
                if (handler) {
                    if (handler.invalidateModule) {
                        promises.push(handler.invalidateModule(module, courseId).catch(function() {
                        }));
                    }
                    statusCache.invalidate(handler.component, module.id);
                }
            });
            promises.push(self.invalidateCourseUpdates(courseId));
            return $q.all(promises);
        };
                self.isBeingDownloaded = function(id) {
            return deferreds[$mmSite.getId()] && deferreds[$mmSite.getId()][id];
        };
                self.isLastUpdateCall = function(time) {
            if (!lastUpdateHandlersStart) {
                return true;
            }
            return time == lastUpdateHandlersStart;
        };
                self.isModuleDownloadable = function(module, courseid) {
            var handler = enabledHandlers[module.modname],
                promise;
            if (handler) {
                if (typeof handler.isDownloadable == 'function') {
                    var downloadable = statusCache.getValue(handler.component, module.id, 'downloadable');
                    if (typeof downloadable != 'undefined') {
                        promise = $q.when(downloadable);
                    } else {
                        promise = $q.when(handler.isDownloadable(module, courseid)).then(function(downloadable) {
                            statusCache.setValue(handler.component, module.id, 'downloadable', downloadable);
                            return downloadable;
                        });
                    }
                } else {
                    promise = $q.when(true);
                }
                return promise.catch(function() {
                    return false;
                });
            } else {
                return $q.when(false);
            }
        };
                self.moduleHasUpdates = function(module, courseId, updates) {
            var handler = enabledHandlers[module.modname],
                moduleUpdates = updates[module.id];
            if (handler && handler.hasUpdates) {
                return $q.when(handler.hasUpdates(module, courseId, moduleUpdates));
            } else if (!moduleUpdates || !moduleUpdates.updates || !moduleUpdates.updates.length) {
                return $q.when(false);
            } else if (handler && handler.updatesNames && handler.updatesNames.test) {
                for (var i = 0, len = moduleUpdates.updates.length; i < len; i++) {
                    if (handler.updatesNames.test(moduleUpdates.updates[i].name)) {
                        return $q.when(true);
                    }
                }
                return $q.when(false);
            }
            return $q.when(true);
        };
                self.prefetchAll = function(id, modules, courseid) {
            var siteid = $mmSite.getId();
            if (deferreds[siteid] && deferreds[siteid][id]) {
                return deferreds[siteid][id].promise;
            }
            var deferred = $q.defer(),
                promises = [];
            if (!deferreds[siteid]) {
                deferreds[siteid] = {};
            }
            deferreds[siteid][id] = deferred;
            angular.forEach(modules, function(module) {
                module.contents = module.contents || [];
                var handler = enabledHandlers[module.modname];
                if (handler) {
                    promises.push(self.isModuleDownloadable(module, courseid).then(function(downloadable) {
                        if (!downloadable) {
                            return;
                        }
                        return handler.prefetch(module, courseid).then(function() {
                            deferred.notify(module.id);
                        });
                    }));
                }
            });
            $q.all(promises).then(function() {
                delete deferreds[siteid][id];
                deferred.resolve();
            }, function() {
                delete deferreds[siteid][id];
                deferred.reject();
            });
            return deferred.promise;
        };
                self.updatePrefetchHandler = function(handles, handlerInfo, time) {
            var promise,
                siteId = $mmSite.getId();
            if (typeof handlerInfo.instance === 'undefined') {
                handlerInfo.instance = $mmUtil.resolveObject(handlerInfo.handler, true);
            }
            if (!$mmSite.isLoggedIn()) {
                promise = $q.reject();
            } else {
                promise = $q.when(handlerInfo.instance.isEnabled());
            }
            return promise.catch(function() {
                return false;
            }).then(function(enabled) {
                if (self.isLastUpdateCall(time) && $mmSite.isLoggedIn() && $mmSite.getId() === siteId) {
                    if (enabled) {
                        enabledHandlers[handles] = handlerInfo.instance;
                    } else {
                        delete enabledHandlers[handles];
                    }
                }
            });
        };
                self.updatePrefetchHandlers = function() {
            var promises = [],
                now = new Date().getTime();
            $log.debug('Updating prefetch handlers for current site.');
            lastUpdateHandlersStart = now;
            angular.forEach(prefetchHandlers, function(handlerInfo, handles) {
                promises.push(self.updatePrefetchHandler(handles, handlerInfo, now));
            });
            return $q.all(promises).then(function() {
                return true;
            }, function() {
                return true;
            });
        };
                self.updateStatusCache = function(component, componentId, status) {
            var notify,
                cachedStatus = statusCache.getValue(component, componentId, 'status', true);
            notify = typeof cachedStatus != 'undefined' && cachedStatus !== status;
            if (notify) {
                var sectionId = statusCache.getValue(component, componentId, 'sectionid', true);
                statusCache.invalidate(component, componentId);
                statusCache.setValue(component, componentId, 'status', status);
                statusCache.setValue(component, componentId, 'sectionid', sectionId);
                $mmEvents.trigger(mmCoreEventSectionStatusChanged, {
                    sectionid: sectionId,
                    siteid: $mmSite.getId()
                });
            } else {
                statusCache.setValue(component, componentId, 'status', status);
            }
        };
        return self;
    }];
    return self;
})
.run(["$mmEvents", "mmCoreEventLogin", "mmCoreEventSiteUpdated", "mmCoreEventLogout", "$mmCoursePrefetchDelegate", "$mmSite", "mmCoreEventPackageStatusChanged", "mmCoreEventRemoteAddonsLoaded", function($mmEvents, mmCoreEventLogin, mmCoreEventSiteUpdated, mmCoreEventLogout, $mmCoursePrefetchDelegate, $mmSite,
            mmCoreEventPackageStatusChanged, mmCoreEventRemoteAddonsLoaded) {
    $mmEvents.on(mmCoreEventLogin, $mmCoursePrefetchDelegate.updatePrefetchHandlers);
    $mmEvents.on(mmCoreEventSiteUpdated, $mmCoursePrefetchDelegate.updatePrefetchHandlers);
    $mmEvents.on(mmCoreEventRemoteAddonsLoaded, $mmCoursePrefetchDelegate.updatePrefetchHandlers);
    $mmEvents.on(mmCoreEventLogout, $mmCoursePrefetchDelegate.clearStatusCache);
    $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
        if (data.siteid === $mmSite.getId()) {
            $mmCoursePrefetchDelegate.updateStatusCache(data.component, data.componentId, data.status);
        }
    });
}]);

angular.module('mm.core.course')
.factory('$mmPrefetchFactory', ["$mmSite", "$mmFilepool", "$mmUtil", "$q", "$mmLang", "$mmApp", "mmCoreDownloading", "mmCoreDownloaded", "$mmCourse", function($mmSite, $mmFilepool, $mmUtil, $q, $mmLang, $mmApp, mmCoreDownloading, mmCoreDownloaded,
            $mmCourse) {
    var self = {},
        modulePrefetchHandler = (function () {
            var downloadPromises = {};
            this.component = 'core_module';
            this.isResource = false;
            this.updatesNames = /^.*files$/;
                        this.addOngoingDownload = function (id, promise, siteId) {
                var uniqueId = this.getUniqueId(id);
                siteId = siteId || $mmSite.getId();
                if (!downloadPromises[siteId]) {
                    downloadPromises[siteId] = {};
                }
                downloadPromises[siteId][uniqueId] = promise;
                return promise.finally(function() {
                    delete downloadPromises[siteId][uniqueId];
                });
            };
                        this.download = function(module, courseId) {
                return this.downloadOrPrefetch(module, courseId, false);
            };
                        this.downloadOrPrefetch = function(module, courseId, prefetch, dirPath) {
                if (!$mmApp.isOnline()) {
                    return $mmLang.translateAndReject('mm.core.networkerrormsg');
                }
                var siteId = $mmSite.getId(),
                    that = this;
                return that.loadContents(module, courseId, true).then(function() {
                    return that.getIntroFiles(module, courseId);
                }).then(function(introFiles) {
                    return that.getRevisionAndTimemodified(module, courseId, introFiles).then(function(data) {
                        var downloadFn = prefetch ? $mmFilepool.prefetchPackage : $mmFilepool.downloadPackage,
                            contentFiles = that.getContentDownloadableFiles(module),
                            promises = [];
                        if (dirPath) {
                            angular.forEach(introFiles, function(file) {
                                if (prefetch) {
                                    promises.push($mmFilepool.addToQueueByUrl(siteId, file.fileurl,
                                            that.component, module.id, file.timemodified));
                                } else {
                                    promises.push($mmFilepool.downloadUrl(siteId, file.fileurl, false,
                                            that.component, module.id, file.timemodified));
                                }
                            });
                            promises.push(downloadFn(siteId, contentFiles, that.component,
                                    module.id, data.revision, data.timemod, dirPath));
                        } else {
                            var files = introFiles.concat(contentFiles);
                            promises.push(downloadFn(siteId, files, that.component, module.id, data.revision, data.timemod));
                        }
                        return $q.all(promises);
                    });
                });
            };
                        this.getContentDownloadableFiles = function(module) {
                var files = [],
                    that = this;
                angular.forEach(module.contents, function(content) {
                    if (that.isFileDownloadable(content)) {
                        files.push(content);
                    }
                });
                return files;
            };
                        this.getDownloadSize = function(module, courseId) {
                return this.getFiles(module, courseId).then(function(files) {
                    return $mmUtil.sumFileSizes(files);
                }).catch(function() {
                    return {size: -1, total: false};
                });
            };
                        this.getDownloadedSize = function(module, courseId) {
                return $mmFilepool.getFilesSizeByComponent($mmSite.getId(), this.component, module.id);
            };
                        this.getDownloadingFilesEventNames = function(module, courseId) {
                var that = this,
                    siteId = $mmSite.getId();
                return that.loadContents(module, courseId).then(function() {
                    var promises = [],
                        eventNames = [];
                    angular.forEach(module.contents, function(content) {
                        var url = content.fileurl;
                        if (!that.isFileDownloadable(content)) {
                            return;
                        }
                        promises.push($mmFilepool.isFileDownloadingByUrl(siteId, url).then(function() {
                            return $mmFilepool.getFileEventNameByUrl(siteId, url).then(function(eventName) {
                                eventNames.push(eventName);
                            });
                        }).catch(function() {
                        }));
                    });
                    return $q.all(promises).then(function() {
                        return eventNames;
                    });
                });
            };
                        this.getFileEventNames = function(module, courseId) {
                var that = this,
                    siteId = $mmSite.getId();
                return that.loadContents(module, courseId).then(function() {
                    var promises = [];
                    angular.forEach(module.contents, function(content) {
                        var url = content.fileurl;
                        if (!that.isFileDownloadable(content)) {
                            return;
                        }
                        promises.push($mmFilepool.getFileEventNameByUrl(siteId, url));
                    });
                    return $q.all(promises);
                });
            };
                        this.getFiles = function(module, courseId) {
                var that = this;
                return that.loadContents(module, courseId).then(function() {
                    return that.getIntroFiles(module, courseId).then(function(files) {
                        return files.concat(that.getContentDownloadableFiles(module));
                    });
                });
            };
                        this.getIntroFiles = function(module, courseId) {
                return $q.when(this.getIntroFilesFromInstance(module));
            };
                        this.getIntroFilesFromInstance = function(module, instance) {
                if (instance) {
                    if (typeof instance.introfiles != 'undefined') {
                        return instance.introfiles;
                    } else if (instance.intro) {
                        return $mmUtil.extractDownloadableFilesFromHtmlAsFakeFileObjects(instance.intro);
                    }
                }
                if (module.description) {
                    return $q.when($mmUtil.extractDownloadableFilesFromHtmlAsFakeFileObjects(module.description));
                }
                return [];
            };
                        this.getOngoingDownload = function (id, siteId) {
                siteId = siteId || $mmSite.getId();
                if (this.isDownloading(id, siteId)) {
                    var uniqueId = this.getUniqueId(id);
                    return downloadPromises[siteId][uniqueId];
                }
                return $q.when();
            };
                        this.getRevision = function(module, courseId) {
                return this.getRevisionAndTimemodified(module, courseId).then(function(data) {
                    return data.revision;
                });
            };
                        this.getRevisionAndTimemodified = function(module, courseId, introFiles) {
                var that = this;
                return that.loadContents(module, courseId).then(function() {
                    var promise = introFiles ? $q.when(introFiles) : that.getIntroFiles(module, courseId);
                    return promise.then(function(files) {
                        files = files.concat(module.contents || []);
                        return {
                            timemod: $mmFilepool.getTimemodifiedFromFileList(files),
                            revision: $mmFilepool.getRevisionFromFileList(files)
                        };
                    });
                });
            };
                        this.getTimemodified = function(module, courseId) {
                return this.getRevisionAndTimemodified(module, courseId).then(function(data) {
                    return data.timemod;
                });
            };
                        this.getUniqueId = function(id) {
                return this.component + '#' + id;
            };
                        this.invalidateContent = function(moduleId) {
                var promises = [];
                promises.push($mmCourse.invalidateModule(moduleId));
                promises.push($mmFilepool.invalidateFilesByComponent($mmSite.getId(), this.component, moduleId));
                return $q.all(promises);
            };
                        this.invalidateModule = function(module, courseId) {
                return $mmCourse.invalidateModule(module.id);
            };
                        this.isDownloadable = function(module, courseId) {
                return $q.when(true);
            };
                        this.isDownloading = function(id, siteId) {
                siteId = siteId || $mmSite.getId();
                var uniqueId = this.getUniqueId(id);
                return !!(downloadPromises[siteId] && downloadPromises[siteId][uniqueId]);
            };
                        this.isEnabled = function() {
                return $mmSite.canDownloadFiles();
            };
                        this.isFileDownloadable = function(file) {
                return file.type === 'file';
            };
                        this.loadContents = function(module, courseId, ignoreCache) {
                if (this.isResource) {
                    return $mmCourse.loadModuleContents(module, courseId, false, false, ignoreCache);
                }
                return $q.when();
            };
                        this.prefetch = function(module, courseId, single) {
                return this.downloadOrPrefetch(module, courseId, true);
            };
                        this.prefetchPackage = function(module, courseId, single, downloadFn, siteId) {
                siteId = siteId || $mmSite.getId();
                if (!$mmApp.isOnline()) {
                    return $mmLang.translateAndReject('mm.core.networkerrormsg');
                }
                var that = this,
                    prefetchPromise,
                    extraParams = Array.prototype.slice.call(arguments, 5);
                if (that.isDownloading(module.id, siteId)) {
                    return that.getOngoingDownload(module.id, siteId);
                }
                prefetchPromise = this.setDownloading(module.id, siteId).then(function() {
                    var params = [module, courseId, single, siteId].concat(extraParams);
                    return $q.when(downloadFn.apply(that, params));
                }).then(function(data) {
                    return that.setDownloaded(module.id, siteId, data.revision, data.timemod);
                }).catch(function(error) {
                    return that.setPreviousStatusAndReject(module.id, error, siteId);
                });
                return that.addOngoingDownload(module.id, prefetchPromise, siteId);
            };
                        this.setDownloaded = function(id, siteId, revision, timemod) {
                siteId = siteId || $mmSite.getId();
                return $mmFilepool.storePackageStatus(siteId, this.component, id, mmCoreDownloaded, revision, timemod);
            };
                        this.setDownloading = function(id, siteId) {
                siteId = siteId || $mmSite.getId();
                return $mmFilepool.storePackageStatus(siteId, this.component, id, mmCoreDownloading);
            };
                        this.setPreviousStatusAndReject = function(id, error, siteId) {
                siteId = siteId || $mmSite.getId();
                return $mmFilepool.setPackagePreviousStatus(siteId, this.component, id).then(function() {
                    return $q.reject(error);
                });
            };
                        this.removeFiles = function(module, courseId) {
                return $mmFilepool.removeFilesByComponent($mmSite.getId(), this.component, module.id);
            };
            return this;
        }());
        self.createPrefetchHandler = function(component, isResource) {
        var child = Object.create(modulePrefetchHandler);
        child.component = component;
        child.isResource = !!isResource;
        return child;
    };
    return self;
}]);

angular.module('mm.core.courses')
.controller('mmCoursesAvailableCtrl', ["$scope", "$mmCourses", "$q", "$mmUtil", "$mmSite", function($scope, $mmCourses, $q, $mmUtil, $mmSite) {
    function loadCourses() {
        $scope.frontpageCourseId = $mmSite.getSiteHomeId();
        return $mmCourses.getCoursesByField().then(function(courses) {
            $scope.courses = courses;
        }).catch(function(message) {
            $mmUtil.showErrorModalDefault(message, 'mm.courses.errorloadcourses', true);
            return $q.reject();
        });
    }
    loadCourses().finally(function() {
        $scope.coursesLoaded = true;
    });
    $scope.refreshCourses = function() {
        var promises = [];
        promises.push($mmCourses.invalidateUserCourses());
        promises.push($mmCourses.invalidateCoursesByField());
        $q.all(promises).finally(function() {
            loadCourses().finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };
}]);

angular.module('mm.core.courses')
.controller('mmCourseCategoriesCtrl', ["$scope", "$stateParams", "$mmCourses", "$mmUtil", "$q", "$mmSite", function($scope, $stateParams, $mmCourses, $mmUtil, $q, $mmSite) {
    var categoryId = $stateParams.categoryid || 0;
    function fetchCategories() {
        return $mmCourses.getCategories(categoryId, true).then(function(cats) {
            $scope.currentCategory = false;
            angular.forEach(cats, function(cat, index) {
                if (cat.id == categoryId) {
                    $scope.currentCategory = cat;
                    delete cats[index];
                }
            });
            cats.sort(function(a,b) {
                if (a.depth == b.depth) {
                    return (a.sortorder > b.sortorder) ? 1 : ((b.sortorder > a.sortorder) ? -1 : 0);
                }
                return a.depth > b.depth ? 1 : -1;
            });
            $scope.categories = $mmUtil.formatTree(cats, 'parent', 'id', categoryId);
            if ($scope.currentCategory) {
                $scope.title = $scope.currentCategory.name;
                return $mmCourses.getCoursesByField('category', categoryId).then(function(courses) {
                    $scope.courses = courses;
                }, function(error) {
                    $mmUtil.showErrorModalDefault(error, 'mm.courses.errorloadcourses', true);
                });
            }
        }, function(error) {
            $mmUtil.showErrorModalDefault(error, 'mm.courses.errorloadcategories', true);
        });
    }
    fetchCategories().finally(function() {
        $scope.categoriesLoaded = true;
    });
    $scope.refreshCategories = function() {
        var promises = [];
        promises.push($mmCourses.invalidateUserCourses());
        promises.push($mmCourses.invalidateCategories(categoryId, true));
        promises.push($mmCourses.invalidateCoursesByField('category', categoryId));
        promises.push($mmSite.invalidateConfig());
        $q.all(promises).finally(function() {
            fetchCategories(true).finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };
}]);

angular.module('mm.core.courses')
.controller('mmCoursesListCtrl', ["$scope", "$mmCourses", "$mmCoursesDelegate", "$mmUtil", "$mmEvents", "$mmSite", "$q", "mmCoursesEventMyCoursesUpdated", "mmCoursesEventMyCoursesRefreshed", "mmCoreEventSiteUpdated", function($scope, $mmCourses, $mmCoursesDelegate, $mmUtil, $mmEvents, $mmSite, $q,
            mmCoursesEventMyCoursesUpdated, mmCoursesEventMyCoursesRefreshed, mmCoreEventSiteUpdated) {
    var updateSiteObserver,
        myCoursesObserver;
    $scope.searchEnabled = $mmCourses.isSearchCoursesAvailable() && !$mmCourses.isSearchCoursesDisabledInSite();
    $scope.areNavHandlersLoadedFor = $mmCoursesDelegate.areNavHandlersLoadedFor;
    $scope.filter = {};
    function fetchCourses(refresh) {
        return $mmCourses.getUserCourses().then(function(courses) {
            $scope.courses = courses;
            $scope.filter.filterText = '';
            return loadCoursesNavHandlers(refresh);
        }, function(error) {
            if (typeof error != 'undefined' && error !== '') {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mm.courses.errorloadcourses', true);
            }
        });
    }
    function loadCoursesNavHandlers(refresh) {
        var courseIds = $scope.courses.map(function(course) {
            return course.id;
        });
        return $mmCourses.getCoursesOptions(courseIds).then(function(options) {
            angular.forEach($scope.courses, function(course) {
                course._handlers = $mmCoursesDelegate.getNavHandlersFor(
                            course.id, refresh, options.navOptions[course.id], options.admOptions[course.id]);
            });
        });
    }
    fetchCourses().finally(function() {
        $scope.coursesLoaded = true;
    });
    $scope.refreshCourses = function() {
        var promises = [];
        $mmEvents.trigger(mmCoursesEventMyCoursesRefreshed);
        promises.push($mmCourses.invalidateUserCourses());
        promises.push($mmCourses.invalidateUserNavigationOptions());
        promises.push($mmCourses.invalidateUserAdministrationOptions());
        $mmCoursesDelegate.clearCoursesHandlers();
        $q.all(promises).finally(function() {
            fetchCourses(true).finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };
    myCoursesObserver = $mmEvents.on(mmCoursesEventMyCoursesUpdated, function(siteid) {
        if (siteid == $mmSite.getId()) {
            fetchCourses();
        }
    });
    updateSiteObserver = $mmEvents.on(mmCoreEventSiteUpdated, function(siteId) {
        if ($mmSite.getId() === siteId) {
            $scope.searchEnabled = $mmCourses.isSearchCoursesAvailable() && !$mmCourses.isSearchCoursesDisabledInSite();
        }
    });
    $scope.$on('$destroy', function() {
        myCoursesObserver && myCoursesObserver.off && myCoursesObserver.off();
        updateSiteObserver && updateSiteObserver.off && updateSiteObserver.off();
    });
}]);

angular.module('mm.core.courses')
.controller('mmCoursesSearchCtrl', ["$scope", "$mmCourses", "$q", "$mmUtil", function($scope, $mmCourses, $q, $mmUtil) {
    var page = 0,
    	currentSearch = '';
    $scope.searchText = '';
    function searchCourses(refresh) {
        if (refresh) {
            page = 0;
        }
        return $mmCourses.search(currentSearch, page).then(function(response) {
            if (page === 0) {
                $scope.courses = response.courses;
            } else {
                $scope.courses = $scope.courses.concat(response.courses);
            }
            $scope.total = response.total;
            page++;
            $scope.canLoadMore = $scope.courses.length < $scope.total;
        }).catch(function(message) {
            $scope.canLoadMore = false;
            $mmUtil.showErrorModalDefault(message, 'mm.courses.errorsearching', true);
            return $q.reject();
        });
    }
    $scope.search = function(text) {
        currentSearch = text;
        $scope.courses = undefined;
    	var modal = $mmUtil.showModalLoading('mm.core.searching', true);
    	searchCourses(true).finally(function() {
            modal.dismiss();
    	});
    };
    $scope.loadMoreResults = function() {
    	searchCourses();
    };
}]);

angular.module('mm.core.courses')
.controller('mmCoursesViewResultCtrl', ["$scope", "$stateParams", "$mmCourses", "$mmCoursesDelegate", "$mmUtil", "$translate", "$q", "$ionicModal", "$mmEvents", "$mmSite", "mmCoursesSearchComponent", "mmCoursesEnrolInvalidKey", "mmCoursesEventMyCoursesUpdated", "$timeout", function($scope, $stateParams, $mmCourses, $mmCoursesDelegate, $mmUtil, $translate, $q,
            $ionicModal, $mmEvents, $mmSite, mmCoursesSearchComponent, mmCoursesEnrolInvalidKey, mmCoursesEventMyCoursesUpdated,
            $timeout) {
    var course = angular.copy($stateParams.course || {}),
        selfEnrolWSAvailable = $mmCourses.isSelfEnrolmentEnabled(),
        guestWSAvailable = $mmCourses.isGuestWSAvailable(),
        isGuestEnabled = false,
        guestInstanceId,
        enrollmentMethods,
        waitStart = 0;
    $scope.course = course;
    $scope.component = mmCoursesSearchComponent;
    $scope.handlersShouldBeShown = true;
    $scope.selfEnrolInstances = [];
    $scope.enroldata = {
        password: ''
    };
    $scope.loadingHandlers = function() {
        return $scope.handlersShouldBeShown && !$mmCoursesDelegate.areNavHandlersLoadedFor(course.id);
    };
    function getCourse(refresh) {
        var promise;
        if (selfEnrolWSAvailable || guestWSAvailable) {
            $scope.selfEnrolInstances = [];
            promise = $mmCourses.getCourseEnrolmentMethods(course.id).then(function(methods) {
                enrollmentMethods = methods;
                angular.forEach(enrollmentMethods, function(method) {
                    if (selfEnrolWSAvailable && method.type === 'self') {
                        $scope.selfEnrolInstances.push(method);
                    } else if (guestWSAvailable && method.type === 'guest') {
                        isGuestEnabled = true;
                    }
                });
            }).catch(function(error) {
                if (error) {
                    $mmUtil.showErrorModal(error);
                }
            });
        } else {
            promise = $q.when();
        }
        return promise.then(function() {
            return $mmCourses.getUserCourse(course.id).then(function(c) {
                $scope.isEnrolled = true;
                return c;
            }).catch(function() {
                $scope.isEnrolled = false;
                return $mmCourses.getCourse(course.id);
            }).then(function(c) {
                course.fullname = c.fullname || course.fullname;
                course.summary = c.summary || course.summary;
                return loadCourseNavHandlers(refresh, false);
            }).catch(function() {
                return canAccessAsGuest().then(function(passwordRequired) {
                    if (!passwordRequired) {
                        return loadCourseNavHandlers(refresh, true);
                    } else {
                        course._handlers = [];
                        $scope.handlersShouldBeShown = false;
                    }
                }).catch(function() {
                    course._handlers = [];
                    $scope.handlersShouldBeShown = false;
                });
            });
        }).finally(function() {
            $scope.courseLoaded = true;
        });
    }
    function canAccessAsGuest() {
        if (!isGuestEnabled) {
            return $q.reject();
        }
        angular.forEach(enrollmentMethods, function(method) {
            if (method.type == 'guest') {
                guestInstanceId = method.id;
            }
        });
        if (guestInstanceId) {
            return $mmCourses.getCourseGuestEnrolmentInfo(guestInstanceId).then(function(info) {
                if (!info.status) {
                    return $q.reject();
                }
                return info.passwordrequired;
            });
        }
        return $q.reject();
    }
    function loadCourseNavHandlers(refresh, guest) {
        var promises = [],
            navOptions,
            admOptions;
        promises.push($mmCourses.getUserNavigationOptions([course.id]).catch(function() {
            return {};
        }).then(function(options) {
            navOptions = options;
        }));
        promises.push($mmCourses.getUserAdministrationOptions([course.id]).catch(function() {
            return {};
        }).then(function(options) {
            admOptions = options;
        }));
        return $q.all(promises).then(function() {
            var getHandlersFn = guest ? $mmCoursesDelegate.getNavHandlersForGuest : $mmCoursesDelegate.getNavHandlersFor;
            course._handlers = getHandlersFn(course.id, refresh, navOptions[course.id], admOptions[course.id]);
            $scope.handlersShouldBeShown = true;
        });
    }
    function refreshData() {
        var promises = [];
        promises.push($mmCourses.invalidateUserCourses());
        promises.push($mmCourses.invalidateCourse(course.id));
        promises.push($mmCourses.invalidateCourseEnrolmentMethods(course.id));
        promises.push($mmCourses.invalidateUserNavigationOptionsForCourses([course.id]));
        promises.push($mmCourses.invalidateUserAdministrationOptionsForCourses([course.id]));
        if (guestInstanceId) {
            promises.push($mmCourses.invalidateCourseGuestEnrolmentInfo(guestInstanceId));
        }
        $mmCoursesDelegate.clearCoursesHandlers(course.id);
        return $q.all(promises).finally(function() {
            return getCourse(true);
        });
    }
    getCourse();
    $scope.doRefresh = function() {
        refreshData().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
    if (selfEnrolWSAvailable && course.enrollmentmethods && course.enrollmentmethods.indexOf('self') > -1) {
        $ionicModal.fromTemplateUrl('core/components/courses/templates/password-modal.html', {
            scope: $scope,
            animation: 'slide-in-up'
        }).then(function(modal) {
            $scope.modal = modal;
            $scope.closeModal = function() {
                $scope.enroldata.password = '';
                delete $scope.currentEnrolInstance;
                return modal.hide();
            };
            $scope.$on('$destroy', function() {
                modal.remove();
            });
        });
        $scope.enrol = function(instanceId, password) {
            var promise;
            if ($scope.modal.isShown()) {
                promise = $q.when();
            } else {
                promise = $mmUtil.showConfirm($translate('mm.courses.confirmselfenrol'));
            }
            promise.then(function() {
                var modal = $mmUtil.showModalLoading('mm.core.loading', true);
                $mmCourses.selfEnrol(course.id, password, instanceId).then(function() {
                    $scope.isEnrolled = true;
                    $scope.courseLoaded = false;
                    $scope.closeModal().then(function() {
                        return waitForEnrolled(true);
                    }).then(function() {
                        refreshData().finally(function() {
                            $mmEvents.trigger(mmCoursesEventMyCoursesUpdated, $mmSite.getId());
                        });
                    });
                }).catch(function(error) {
                    if (error) {
                        if (error.code === mmCoursesEnrolInvalidKey) {
                            if ($scope.modal.isShown()) {
                                $mmUtil.showErrorModal(error.message);
                            } else {
                                $scope.currentEnrolInstance = instanceId;
                                $scope.modal.show();
                            }
                        } else if (typeof error == 'string') {
                            $mmUtil.showErrorModal(error);
                        }
                    } else {
                        $mmUtil.showErrorModal('mm.courses.errorselfenrol', true);
                    }
                }).finally(function() {
                    modal.dismiss();
                });
            });
        };
        function waitForEnrolled(init) {
            if (init) {
                waitStart = Date.now();
            }
            return $mmCourses.invalidateUserCourses().catch(function() {
            }).then(function() {
                return $mmCourses.getUserCourse(course.id);
            }).catch(function() {
                if ($scope.$$destroyed || (Date.now() - waitStart > 60000)) {
                    return;
                }
                return $timeout(function() {
                    return waitForEnrolled();
                }, 5000);
            });
        }
    }
}]);

angular.module('mm.core.courses')
.directive('mmCourseListItem', ["$mmCourses", "$translate", function($mmCourses, $translate) {
    return {
        restrict: 'E',
        templateUrl: 'core/components/courses/templates/courselistitem.html',
        scope: {
            course: '=',
        },
        link: function(scope) {
            var course = scope.course;
            return $mmCourses.getUserCourse(course.id).then(function() {
                course.isEnrolled = true;
            }).catch(function() {
                course.isEnrolled = false;
                course.enrollment = [];
                angular.forEach(course.enrollmentmethods, function(instance) {
                    if (instance === 'self') {
                        course.enrollment.push({
                            name: $translate.instant('mm.courses.selfenrolment'),
                            icon: 'ion-unlocked'
                        });
                    } else if (instance === 'guest') {
                        course.enrollment.push({
                            name: $translate.instant('mm.courses.allowguests'),
                            icon: 'ion-person'
                        });
                    }
                });
                if (course.enrollment.length == 0) {
                    course.enrollment.push({
                        name: $translate.instant('mm.courses.notenrollable'),
                        icon: 'ion-locked'
                    });
                }
            });
        }
    };
}]);

angular.module('mm.core.courses')
.factory('$mmCourses', ["$q", "$mmSite", "$log", "$mmSitesManager", "mmCoursesSearchPerPage", "mmCoursesEnrolInvalidKey", function($q, $mmSite, $log, $mmSitesManager, mmCoursesSearchPerPage, mmCoursesEnrolInvalidKey) {
    $log = $log.getInstance('$mmCourses');
    var self = {},
        currentCourses = {};
        self.getCategories = function(categoryId, addSubcategories, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var criteriaKey = categoryId == 0 ? 'parent' : 'id';
            var data = {
                    criteria: [
                        { key: criteriaKey, value: categoryId }
                    ],
                    addsubcategories: addSubcategories ? 1 : 0
                },
                preSets = {
                    cacheKey: getCategoriesCacheKey(categoryId, addSubcategories)
                };
            return site.read('core_course_get_categories', data, preSets);
        });
    };
        function getCategoriesCacheKey(categoryId, addSubcategories) {
        return 'mmCourses:categories:' + categoryId + ':' + addSubcategories;
    }
        self.isGetCategoriesAvailable = function() {
        return $mmSite.wsAvailable('core_course_get_categories');
    };
        self.isMyCoursesDisabled = function(siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return self.isMyCoursesDisabledInSite(site);
        });
    };
        self.isMyCoursesDisabledInSite = function(site) {
        site = site || $mmSite;
        return site.isFeatureDisabled('$mmSideMenuDelegate_mmCourses');
    };
        self.isSearchCoursesDisabled = function(siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return self.isSearchCoursesDisabledInSite(site);
        });
    };
        self.isSearchCoursesDisabledInSite = function(site) {
        site = site || $mmSite;
        return site.isFeatureDisabled('$mmCoursesDelegate_search');
    };
        self.clearCurrentCourses = function() {
        currentCourses = {};
    };
        self.getCourse = function(id, siteid) {
        return self.getCourses([id], siteid).then(function(courses) {
            if (courses && courses.length > 0) {
                return courses[0];
            }
            return $q.reject();
        });
    };
        self.getCourseEnrolmentMethods = function(id) {
        var params = {
                courseid: id
            },
            preSets = {
                cacheKey: getCourseEnrolmentMethodsCacheKey(id)
            };
        return $mmSite.read('core_enrol_get_course_enrolment_methods', params, preSets);
    };
        function getCourseEnrolmentMethodsCacheKey(id) {
        return 'mmCourses:enrolmentmethods:' + id;
    }
        self.getCourseGuestEnrolmentInfo = function(instanceId) {
        var params = {
                instanceid: instanceId
            },
            preSets = {
                cacheKey: getCourseGuestEnrolmentInfoCacheKey(instanceId)
            };
        return $mmSite.read('enrol_guest_get_instance_info', params, preSets).then(function(response) {
            return response.instanceinfo;
        });
    };
        function getCourseGuestEnrolmentInfoCacheKey(instanceId) {
        return 'mmCourses:guestinfo:' + instanceId;
    }
        self.getCourses = function(ids, siteid) {
        if (!angular.isArray(ids)) {
            return $q.reject();
        } else if (ids.length === 0) {
            return $q.when([]);
        }
        return $mmSitesManager.getSite(siteid).then(function(site) {
            var data = {
                    options: {
                        ids: ids
                    }
                },
                preSets = {
                    cacheKey: getCoursesCacheKey(ids)
                };
            return site.read('core_course_get_courses', data, preSets).then(function(courses) {
                if (typeof courses != 'object' && !angular.isArray(courses)) {
                    return $q.reject();
                }
                return courses;
            });
        });
    };
        function getCoursesCacheKey(ids) {
        return 'mmCourses:course:' + JSON.stringify(ids);
    }
        self.getCoursesByField = function(field, value, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var data = {
                    field: field || "",
                    value: field ? value : ""
                },
                preSets = {
                    cacheKey: getCoursesByFieldCacheKey(field, value)
                };
            return site.read('core_course_get_courses_by_field', data, preSets).then(function(courses) {
                if (courses.courses) {
                    return courses.courses.sort(function(a, b) {
                        if (typeof a.sortorder == "undefined" && typeof b.sortorder == "undefined") {
                            return b.id - a.id;
                        }
                        if (typeof a.sortorder == "undefined") {
                            return 1;
                        }
                        if (typeof b.sortorder == "undefined") {
                            return -1;
                        }
                        return a.sortorder - b.sortorder;
                    });
                }
                return $q.reject();
            });
        });
    };
        function getCoursesByFieldCacheKey(field, value) {
        field = field || "";
        value = field ? value : "";
        return 'mmCourses:coursesbyfield:' + field + ":" + value;
    }
        self.isGetCoursesByFieldAvailable = function() {
        return $mmSite.wsAvailable('core_course_get_courses_by_field');
    };
        self.getStoredCourse = function(id) {
        $log.warn('The function \'getStoredCourse\' is deprecated. Please use \'getUserCourse\' instead');
        return currentCourses[id];
    };
        self.getCoursesOptions = function(courseIds, siteId) {
        var promises = [],
            navOptions,
            admOptions;
        return $mmSitesManager.getSite(siteId).then(function(site) {
            courseIds.push(site.getSiteHomeId());
            siteId = siteId || site.getId();
            promises.push(self.getUserNavigationOptions(courseIds, siteId).catch(function() {
                return {};
            }).then(function(options) {
                navOptions = options;
            }));
            promises.push(self.getUserAdministrationOptions(courseIds, siteId).catch(function() {
                return {};
            }).then(function(options) {
                admOptions = options;
            }));
            return $q.all(promises).then(function() {
                return {navOptions: navOptions, admOptions: admOptions};
            });
        });
    };
        function getUserAdministrationOptionsCommonCacheKey() {
        return 'mmCourses:administrationOptions:';
    }
        function getUserAdministrationOptionsCacheKey(courseIds) {
        return getUserAdministrationOptionsCommonCacheKey() + courseIds.join(',');
    }
        self.getUserAdministrationOptions = function(courseIds, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    courseids: courseIds
                },
                preSets = {
                    cacheKey: getUserAdministrationOptionsCacheKey(courseIds)
                };
            return site.read('core_course_get_user_administration_options', params, preSets).then(function(response) {
                return formatUserOptions(response.courses);
            });
        });
    };
        self.getUserCourse = function(id, preferCache, siteid) {
        if (!id) {
            return $q.reject();
        }
        if (typeof preferCache == 'undefined') {
            preferCache = false;
        }
        return self.getUserCourses(preferCache, siteid).then(function(courses) {
            var course;
            angular.forEach(courses, function(c) {
                if (c.id == id) {
                    course = c;
                }
            });
            return course ? course : $q.reject();
        });
    };
        self.getUserCourses = function(preferCache, siteid) {
        if (typeof preferCache == 'undefined') {
            preferCache = false;
        }
        return $mmSitesManager.getSite(siteid).then(function(site) {
            var userid = site.getUserId(),
                presets = {
                    cacheKey: getUserCoursesCacheKey(),
                    omitExpires: preferCache
                },
                data = {userid: userid};
            if (typeof userid === 'undefined') {
                return $q.reject();
            }
            return site.read('core_enrol_get_users_courses', data, presets).then(function(courses) {
                siteid = siteid || site.getId();
                if (siteid === $mmSite.getId()) {
                    storeCoursesInMemory(courses);
                }
                return courses;
            });
        });
    };
        function getUserCoursesCacheKey() {
        return 'mmCourses:usercourses';
    }
        function getUserNavigationOptionsCommonCacheKey() {
        return 'mmCourses:navigationOptions:';
    }
        function getUserNavigationOptionsCacheKey(courseIds) {
        return getUserNavigationOptionsCommonCacheKey() + courseIds.join(',');
    }
        self.getUserNavigationOptions = function(courseIds, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    courseids: courseIds
                },
                preSets = {
                    cacheKey: getUserNavigationOptionsCacheKey(courseIds)
                };
            return site.read('core_course_get_user_navigation_options', params, preSets).then(function(response) {
                return formatUserOptions(response.courses);
            });
        });
    };
        function formatUserOptions(courses) {
        var result = {};
        angular.forEach(courses, function(course) {
            var options = {};
            angular.forEach(course.options, function(option) {
                options[option.name] = option.available;
            });
            result[course.id] = options;
        });
        return result;
    }
        self.invalidateCategories = function(categoryId, addSubcategories, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getCategoriesCacheKey(categoryId, addSubcategories));
        });
    };
        self.invalidateCourse = function(id, siteId) {
        return self.invalidateCourses([id], siteId);
    };
        self.invalidateCourseEnrolmentMethods = function(id) {
        return $mmSite.invalidateWsCacheForKey(getCourseEnrolmentMethodsCacheKey(id));
    };
        self.invalidateCourseGuestEnrolmentInfo = function(instanceId) {
        return $mmSite.invalidateWsCacheForKey(getCourseGuestEnrolmentInfoCacheKey(instanceId));
    };
        self.invalidateCourses = function(ids, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getCoursesCacheKey(ids));
        });
    };
        self.invalidateCoursesByField = function(field, value, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getCoursesByFieldCacheKey(field, value));
        });
    };
        self.invalidateUserAdministrationOptions = function(siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKeyStartingWith(getUserAdministrationOptionsCommonCacheKey());
        });
    };
        self.invalidateUserAdministrationOptionsForCourses = function(courseIds, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getUserAdministrationOptionsCacheKey(courseIds));
        });
    };
        self.invalidateUserCourses = function(siteid) {
        return $mmSitesManager.getSite(siteid).then(function(site) {
            return site.invalidateWsCacheForKey(getUserCoursesCacheKey());
        });
    };
        self.invalidateUserNavigationOptions = function(siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKeyStartingWith(getUserNavigationOptionsCommonCacheKey());
        });
    };
        self.invalidateUserNavigationOptionsForCourses = function(courseIds, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getUserNavigationOptionsCacheKey(courseIds));
        });
    };
        self.isGuestWSAvailable = function() {
        return $mmSite.wsAvailable('enrol_guest_get_instance_info');
    };
        self.isSearchCoursesAvailable = function() {
        return $mmSite.wsAvailable('core_course_search_courses');
    };
        self.isSelfEnrolmentEnabled = function() {
        return $mmSite.wsAvailable('enrol_self_enrol_user');
    };
        self.search = function(text, page, perpage) {
        page = page || 0;
        perpage = perpage || mmCoursesSearchPerPage;
        var params = {
                criterianame: 'search',
                criteriavalue: text,
                page: page,
                perpage: perpage
            }, preSets = {
                getFromCache: false
            };
        return $mmSite.read('core_course_search_courses', params, preSets).then(function(response) {
            if (typeof response == 'object') {
                return {total: response.total, courses: response.courses};
            }
            return $q.reject();
        });
    };
        self.selfEnrol = function(courseid, password, instanceId) {
        if (typeof password == 'undefined') {
            password = '';
        }
        var params = {
            courseid: courseid,
            password: password
        };
        if (instanceId) {
            params.instanceid = instanceId;
        }
        return $mmSite.write('enrol_self_enrol_user', params).then(function(response) {
            if (response) {
                if (response.status) {
                    return true;
                } else if (response.warnings && response.warnings.length) {
                    var message;
                    angular.forEach(response.warnings, function(warning) {
                        if (warning.warningcode == '2' || warning.warningcode == '4') {
                            message = warning.message;
                        }
                    });
                    if (message) {
                        return $q.reject({code: mmCoursesEnrolInvalidKey, message: message});
                    }
                }
            }
            return $q.reject();
        });
    };
        function storeCoursesInMemory(courses) {
        angular.forEach(courses, function(course) {
            currentCourses[course.id] = angular.copy(course);
        });
    }
    return self;
}]);

angular.module('mm.core.courses')
.provider('$mmCoursesDelegate', function() {
    var navHandlers = {},
        self = {};
        self.registerNavHandler = function(addon, handler, priority) {
        if (typeof navHandlers[addon] !== 'undefined') {
            console.log("$mmCoursesDelegateProvider: Addon '" + navHandlers[addon].addon + "' already registered as navigation handler");
            return false;
        }
        console.log("$mmCoursesDelegateProvider: Registered addon '" + addon + "' as navibation handler.");
        navHandlers[addon] = {
            addon: addon,
            handler: handler,
            instance: undefined,
            priority: priority
        };
        return true;
    };
    self.$get = ["$mmUtil", "$q", "$log", "$mmSite", "mmCoursesAccessMethods", function($mmUtil, $q, $log, $mmSite, mmCoursesAccessMethods) {
        var enabledNavHandlers = {},
            coursesHandlers = {},
            self = {},
            loaded = {},
            lastUpdateHandlersStart,
            lastUpdateHandlersForCoursesStart = {};
        $log = $log.getInstance('$mmCoursesDelegate');
                self.areNavHandlersLoadedFor = function(courseId) {
            return loaded[courseId];
        };
                self.clearCoursesHandlers = function(courseId) {
            if (courseId) {
                coursesHandlers[courseId] = false;
                loaded[courseId] = false;
            } else {
                coursesHandlers = {};
                loaded = {};
            }
        };
                function getNavHandlersForAccess(courseId, refresh, accessData, navOptions, admOptions) {
            if (refresh || !coursesHandlers[courseId] || coursesHandlers[courseId].access.type != accessData.type) {
                coursesHandlers[courseId] = {
                    access: accessData,
                    navOptions: navOptions,
                    admOptions: admOptions,
                    handlers: []
                };
                self.updateNavHandlersForCourse(courseId, accessData, navOptions, admOptions);
            }
            return coursesHandlers[courseId].handlers;
        }
                self.getNavHandlersFor = function(courseId, refresh, navOptions, admOptions) {
            var accessData = {
                type: mmCoursesAccessMethods.default
            };
            return getNavHandlersForAccess(courseId, refresh, accessData, navOptions, admOptions);
        };
                self.getNavHandlersForGuest = function(courseId, refresh, navOptions, admOptions) {
            var accessData = {
                type: mmCoursesAccessMethods.guest
            };
            return getNavHandlersForAccess(courseId, refresh, accessData, navOptions, admOptions);
        };
                self.isLastUpdateCall = function(time) {
            if (!lastUpdateHandlersStart) {
                return true;
            }
            return time == lastUpdateHandlersStart;
        };
                self.isLastUpdateCourseCall = function(courseId, time) {
            if (!lastUpdateHandlersForCoursesStart[courseId]) {
                return true;
            }
            return time == lastUpdateHandlersForCoursesStart[courseId];
        };
                self.updateNavHandler = function(addon, handlerInfo, time) {
            var promise,
                siteId = $mmSite.getId();
            if (typeof handlerInfo.instance === 'undefined') {
                handlerInfo.instance = $mmUtil.resolveObject(handlerInfo.handler, true);
            }
            if (!$mmSite.isLoggedIn()) {
                promise = $q.reject();
            } else if ($mmSite.isFeatureDisabled('$mmCoursesDelegate_' + addon)) {
                promise = $q.when(false);
            } else {
                promise = $q.when(handlerInfo.instance.isEnabled());
            }
            return promise.catch(function() {
                return false;
            }).then(function(enabled) {
                if (self.isLastUpdateCall(time) && $mmSite.isLoggedIn() && $mmSite.getId() === siteId) {
                    if (enabled) {
                        enabledNavHandlers[addon] = {
                            instance: handlerInfo.instance,
                            priority: handlerInfo.priority
                        };
                    } else {
                        delete enabledNavHandlers[addon];
                    }
                }
            });
        };
                self.updateNavHandlers = function() {
            var promises = [],
                siteId = $mmSite.getId(),
                now = new Date().getTime();
            $log.debug('Updating navigation handlers for current site.');
            lastUpdateHandlersStart = now;
            angular.forEach(navHandlers, function(handlerInfo, addon) {
                promises.push(self.updateNavHandler(addon, handlerInfo, now));
            });
            return $q.all(promises).then(function() {
                return true;
            }, function() {
                return true;
            }).finally(function() {
                if (self.isLastUpdateCall(now) && $mmSite.isLoggedIn() && $mmSite.getId() === siteId) {
                    angular.forEach(coursesHandlers, function(handler, courseId) {
                        self.updateNavHandlersForCourse(parseInt(courseId), handler.access, handler.navOptions, handler.admOptions);
                    });
                }
            });
        };
                self.updateNavHandlersForCourse = function(courseId, accessData, navOptions, admOptions) {
            var promises = [],
                enabledForCourse = [],
                siteId = $mmSite.getId(),
                now = new Date().getTime();
            lastUpdateHandlersForCoursesStart[courseId] = now;
            angular.forEach(enabledNavHandlers, function(handler) {
                var promise = $q.when(handler.instance.isEnabledForCourse(courseId, accessData, navOptions, admOptions))
                        .then(function(enabled) {
                    if (enabled) {
                        enabledForCourse.push(handler);
                    } else {
                        return $q.reject();
                    }
                }).catch(function() {
                });
                promises.push(promise);
            });
            return $q.all(promises).then(function() {
                return true;
            }).catch(function() {
                return true;
            }).finally(function() {
                if (self.isLastUpdateCourseCall(courseId, now) && $mmSite.isLoggedIn() && $mmSite.getId() === siteId) {
                    $mmUtil.emptyArray(coursesHandlers[courseId].handlers);
                    angular.forEach(enabledForCourse, function(handler) {
                        coursesHandlers[courseId].handlers.push({
                            controller: handler.instance.getController(courseId),
                            priority: handler.priority
                        });
                    });
                    loaded[courseId] = true;
                }
            });
        };
        return self;
    }];
    return self;
});

angular.module('mm.core.courses')
.factory('$mmCoursesHandlers', ["$mmSite", "$state", "$mmCourses", "$q", "$mmUtil", "$translate", "$timeout", "$mmCourse", "$mmSitesManager", "mmCoursesEnrolInvalidKey", "$mmContentLinkHandlerFactory", function($mmSite, $state, $mmCourses, $q, $mmUtil, $translate, $timeout, $mmCourse, $mmSitesManager,
            mmCoursesEnrolInvalidKey, $mmContentLinkHandlerFactory) {
    var self = {};
        self.coursesLinksHandler = $mmContentLinkHandlerFactory.createChild(
                /\/course\/?(index\.php.*)?$/, '$mmSideMenuDelegate_mmCourses');
    self.coursesLinksHandler.getActions = function(siteIds, url, params, courseId) {
        return [{
            action: function(siteId) {
                var state = 'site.mm_courses',
                    stateParams = {};
                if ($mmCourses.isGetCoursesByFieldAvailable()) {
                    if (params.categoryid && $mmCourses.isGetCategoriesAvailable()) {
                        state = 'site.mm_coursescategories';
                        stateParams.categoryid = parseInt(params.categoryid, 10);
                    } else {
                        state = 'site.mm_availablecourses';
                    }
                }
                $state.go('redirect', {
                    siteid: siteId || $mmSite.getId(),
                    state: state,
                    params: stateParams
                });
            }
        }];
    };
        self.courseLinksHandler = $mmContentLinkHandlerFactory.createChild(
                /((\/enrol\/index\.php)|(\/course\/enrol\.php)|(\/course\/view\.php)).*([\?\&]id=\d+)/);
    self.courseLinksHandler.isEnabled = function(siteId, url, params, courseId) {
        courseId = parseInt(params.id, 10);
        if (!courseId) {
            return false;
        }
        return $mmSitesManager.getSiteHomeId(siteId).then(function(siteHomeId) {
           return courseId != siteHomeId;
       });
    };
    self.courseLinksHandler.getActions = function(siteIds, url, params, courseId) {
        courseId = parseInt(params.id, 10);
        return [{
            action: function(siteId) {
                siteId = siteId || $mmSite.getId();
                if (siteId == $mmSite.getId()) {
                    actionEnrol(courseId, url);
                } else {
                    $state.go('redirect', {
                        siteid: siteId,
                        state: 'site.mm_course',
                        params: {courseid: courseId}
                    });
                }
            }
        }];
    };
        function actionEnrol(courseId, url) {
        var modal = $mmUtil.showModalLoading(),
            isEnrolUrl = !!url.match(/(\/enrol\/index\.php)|(\/course\/enrol\.php)/);
        $mmCourses.getUserCourse(courseId).catch(function() {
            return canSelfEnrol(courseId).then(function() {
                var promise;
                modal.dismiss();
                promise = isEnrolUrl ? $q.when() : $mmUtil.showConfirm($translate('mm.courses.confirmselfenrol'));
                return promise.then(function() {
                    return selfEnrol(courseId).catch(function(error) {
                        if (typeof error == 'string') {
                            $mmUtil.showErrorModal(error);
                        }
                        return $q.reject();
                    });
                }, function() {
                    return $mmCourse.getSections(courseId, false, true);
                });
            }, function(error) {
                return $mmCourse.getSections(courseId, false, true).catch(function() {
                    modal.dismiss();
                    if (typeof error != 'string') {
                        error = $translate.instant('mm.courses.notenroled');
                    }
                    var body = $translate('mm.core.twoparagraphs',
                                    {p1: error, p2: $translate.instant('mm.core.confirmopeninbrowser')});
                    $mmUtil.showConfirm(body).then(function() {
                        $mmSite.openInBrowserWithAutoLogin(url);
                    });
                    return $q.reject();
                });
            });
        }).then(function() {
            modal.dismiss();
            $state.go('redirect', {
                siteid: $mmSite.getId(),
                state: 'site.mm_course',
                params: {courseid: courseId}
            });
        });
    }
        function canSelfEnrol(courseId) {
        if (!$mmCourses.isSelfEnrolmentEnabled()) {
            return $q.reject();
        }
        return $mmCourses.getCourseEnrolmentMethods(courseId).then(function(methods) {
            var isSelfEnrolEnabled = false,
                instances = 0;
            angular.forEach(methods, function(method) {
                if (method.type == 'self' && method.status) {
                    isSelfEnrolEnabled = true;
                    instances++;
                }
            });
            if (!isSelfEnrolEnabled || instances != 1) {
                return $q.reject();
            }
        });
    }
        function selfEnrol(courseId, password) {
        var modal = $mmUtil.showModalLoading();
        return $mmCourses.selfEnrol(courseId, password).then(function() {
            return $mmCourses.invalidateUserCourses().catch(function() {
            }).then(function() {
                return $timeout(function() {}, 4000).finally(function() {
                    modal.dismiss();
                });
            });
        }).catch(function(error) {
            modal.dismiss();
            if (error && error.code === mmCoursesEnrolInvalidKey) {
                var title = $translate.instant('mm.courses.selfenrolment'),
                    body = ' ',
                    placeholder = $translate.instant('mm.courses.password');
                if (typeof password != 'undefined') {
                    $mmUtil.showErrorModal(error.message);
                }
                return $mmUtil.showPrompt(body, title, placeholder).then(function(password) {
                    return selfEnrol(courseId, password);
                });
            } else {
                return $q.reject(error);
            }
        });
    }
        self.dashboardLinksHandler = $mmContentLinkHandlerFactory.createChild(
                /\/my\/?$/, '$mmSideMenuDelegate_mmCourses');
    self.dashboardLinksHandler.getActions = function(siteIds, url, params, courseId) {
        return [{
            action: function(siteId) {
                $state.go('redirect', {
                    siteid: siteId || $mmSite.getId(),
                    state: 'site.mm_courses'
                });
            }
        }];
    };
    return self;
}]);

angular.module('mm.core.fileuploader')
.directive('mmFileUploaderOnChange', function() {
  return {
    restrict: 'A',
    link: function (scope, element, attrs) {
      var onChangeHandler = scope.$eval(attrs.mmFileUploaderOnChange);
      element.bind('change', onChangeHandler);
    }
  };
});

angular.module('mm.core.fileuploader')
.provider('$mmFileUploaderDelegate', function() {
    var handlers = {},
        self = {};
        self.registerHandler = function(addon, handler, priority) {
        if (typeof handlers[addon] !== 'undefined') {
            console.log("$mmFileUploaderDelegate: Addon '" + handlers[addon].addon + "' already registered as handler");
            return false;
        }
        console.log("$mmFileUploaderDelegate: Registered addon '" + addon + "' as handler.");
        handlers[addon] = {
            addon: addon,
            handler: handler,
            instance: undefined,
            priority: priority
        };
        return true;
    };
    self.$get = ["$mmUtil", "$q", "$log", "$mmSite", function($mmUtil, $q, $log, $mmSite) {
        var enabledHandlers = {},
            self = {},
            lastUpdateHandlersStart;
        $log = $log.getInstance('$mmFileUploaderDelegate');
                self.clearSiteHandlers = function() {
            enabledHandlers = {};
        };
                self.getHandlers = function() {
            var handlers = [];
            angular.forEach(enabledHandlers, function(handler) {
                var data = handler.instance.getData();
                data.priority = handler.priority;
                handlers.push(data);
            });
            return handlers;
        };
                self.isLastUpdateCall = function(time) {
            if (!lastUpdateHandlersStart) {
                return true;
            }
            return time == lastUpdateHandlersStart;
        };
                self.updateHandler = function(addon, handlerInfo, time) {
            var promise,
                siteId = $mmSite.getId();
            if (typeof handlerInfo.instance === 'undefined') {
                handlerInfo.instance = $mmUtil.resolveObject(handlerInfo.handler, true);
            }
            if (!$mmSite.isLoggedIn()) {
                promise = $q.reject();
            } else {
                promise = $q.when(handlerInfo.instance.isEnabled());
            }
            return promise.catch(function() {
                return false;
            }).then(function(enabled) {
                if (self.isLastUpdateCall(time) && $mmSite.isLoggedIn() && $mmSite.getId() === siteId) {
                    if (enabled) {
                        enabledHandlers[addon] = {
                            instance: handlerInfo.instance,
                            priority: handlerInfo.priority
                        };
                    } else {
                        delete enabledHandlers[addon];
                    }
                }
            });
        };
                self.updateHandlers = function() {
            var promises = [],
                now = new Date().getTime();
            $log.debug('Updating navigation handlers for current site.');
            lastUpdateHandlersStart = now;
            angular.forEach(handlers, function(handlerInfo, addon) {
                promises.push(self.updateHandler(addon, handlerInfo, now));
            });
            return $q.all(promises).then(function() {
                return true;
            }, function() {
                return true;
            });
        };
        return self;
    }];
    return self;
});

angular.module('mm.core.fileuploader')
.factory('$mmFileUploader', ["$mmSite", "$mmFS", "$q", "$timeout", "$log", "$mmSitesManager", "$mmFilepool", "$mmUtil", function($mmSite, $mmFS, $q, $timeout, $log, $mmSitesManager, $mmFilepool, $mmUtil) {
    $log = $log.getInstance('$mmFileUploader');
    var self = {};
        self.storeFilesToUpload = function(folderPath, files) {
        var result = {
            online: [],
            offline: 0
        };
        if (!files || !files.length) {
            return $q.when(result);
        }
        return $mmFS.removeUnusedFiles(folderPath, files).then(function() {
            var promises = [];
            angular.forEach(files, function(file) {
                if (file.filename && !file.name) {
                    result.online.push({
                        filename: file.filename,
                        fileurl: file.fileurl
                    });
                } else if (!file.name) {
                    promises.push($q.reject());
                } else if (file.fullPath && file.fullPath.indexOf(folderPath) != -1) {
                    result.offline++;
                } else {
                    var destFile = $mmFS.concatenatePaths(folderPath, file.name);
                    promises.push($mmFS.copyFile(file.toURL(), destFile));
                    result.offline++;
                }
            });
            return $q.all(promises).then(function() {
                return result;
            });
        });
    };
        self.uploadFile = function(uri, options, siteId) {
        options = options || {};
        siteId = siteId || $mmSite.getId();
        var deleteAfterUpload = options.deleteAfterUpload,
            ftOptions = angular.copy(options);
        delete ftOptions.deleteAfterUpload;
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.uploadFile(uri, ftOptions);
        }).then(function(result) {
            if (deleteAfterUpload) {
                $timeout(function() {
                    $mmFS.removeExternalFile(uri);
                }, 500);
            }
            return result;
        });
    };
        self.uploadImage = function(uri, isFromAlbum) {
        $log.debug('Uploading an image');
        var options = {
                fileName: 'image_' + $mmUtil.readableTimestamp() + '.jpg',
                mimeType: 'image/jpeg'
            },
            fileName,
            extension;
        if (typeof uri == 'undefined' || uri === '') {
            $log.debug('Received invalid URI in $mmFileUploader.uploadImage()');
            return $q.reject();
        }
        if (isFromAlbum) {
            fileName = $mmFS.getFileAndDirectoryFromPath(uri).name;
            fileName = fileName.replace(/(\.[^\.]*)\?[^\.]*$/, '$1');
            extension = $mmFS.getFileExtension(fileName);
            if (extension) {
                options.fileName = fileName;
                options.mimeType = $mmFS.getMimeType(extension);
            }
        }
        options.deleteAfterUpload = !isFromAlbum;
        options.fileKey = 'file';
        return self.uploadFile(uri, options);
    };
        self.uploadMedia = function(mediaFile) {
        $log.debug('Uploading media');
        var options = {},
            filename = mediaFile.name,
            split;
        split = filename.split('.');
        split[0] += '_' + $mmUtil.readableTimestamp();
        filename = split.join('.');
        options.fileKey = null;
        options.fileName = filename;
        options.mimeType = null;
        options.deleteAfterUpload = true;
        return self.uploadFile(mediaFile.fullPath, options);
    };
        self.uploadGenericFile = function(uri, name, type, deleteAfterUpload, fileArea, itemId, siteId) {
        var options = {};
        options.fileKey = null;
        options.fileName = name;
        options.mimeType = type;
        options.deleteAfterUpload = deleteAfterUpload;
        options.itemId = itemId || 0;
        options.fileArea = fileArea;
        return self.uploadFile(uri, options, siteId);
    };
        self.uploadOrReuploadFile = function(file, itemId, component, componentId, siteId) {
        siteId = siteId || $mmSite.getId();
        var promise,
            fileName;
        if (file.filename && !file.name) {
            fileName = file.filename;
            promise = $mmFilepool.downloadUrl(siteId, file.fileurl, false, component, componentId).then(function(path) {
                return $mmFS.getExternalFile(path);
            });
        } else {
            fileName = file.name;
            promise = $q.when(file);
        }
        return promise.then(function(fileEntry) {
            return self.uploadGenericFile(fileEntry.toURL(), fileName, fileEntry.type, true, 'draft', itemId, siteId)
                    .then(function(result) {
                return result.itemid;
            });
        });
    };
        self.uploadOrReuploadFiles = function(files, component, componentId, siteId) {
        siteId = siteId || $mmSite.getId();
        if (!files || !files.length) {
            return $q.when(1);
        }
        return self.uploadOrReuploadFile(files[0], 0, component, componentId, siteId).then(function(itemId) {
            var promises = [],
                error;
            angular.forEach(files, function(file, index) {
                if (index === 0) {
                    return;
                }
                promises.push(self.uploadOrReuploadFile(file, itemId, component, componentId, siteId).catch(function(message) {
                    error = message;
                    return $q.reject();
                }));
            });
            return $q.all(promises).then(function() {
                return itemId;
            }).catch(function() {
                return $q.reject(error);
            });
        });
    };
    return self;
}]);

angular.module('mm.core.fileuploader')
.factory('$mmFileUploaderHandlers', ["$mmFileUploaderHelper", "$rootScope", "$compile", "$mmUtil", "$mmApp", function($mmFileUploaderHelper, $rootScope, $compile, $mmUtil, $mmApp) {
    var self = {};
        self.albumFilePicker = function() {
        var self = {};
                self.isEnabled = function() {
            return true;
        };
                self.getData = function() {
            return {
                name: 'album',
                title: 'mm.fileuploader.photoalbums',
                class: 'mm-fileuploader-album-handler',
                icon: 'ion-images',
                action: function(maxSize, upload, allowOffline) {
                    return $mmFileUploaderHelper.uploadImage(true, maxSize, upload).then(function(result) {
                        return {
                            uploaded: true,
                            result: result
                        };
                    });
                }
            };
        };
        return self;
    };
        self.cameraFilePicker = function() {
        var self = {};
                self.isEnabled = function() {
            return true;
        };
                self.getData = function() {
            return {
                name: 'camera',
                title: 'mm.fileuploader.camera',
                class: 'mm-fileuploader-camera-handler',
                icon: 'ion-camera',
                action: function(maxSize, upload, allowOffline) {
                    return $mmFileUploaderHelper.uploadImage(false, maxSize, upload).then(function(result) {
                        return {
                            uploaded: true,
                            result: result
                        };
                    });
                }
            };
        };
        return self;
    };
        self.audioFilePicker = function() {
        var self = {};
                self.isEnabled = function() {
            return true;
        };
                self.getData = function() {
            return {
                name: 'audio',
                title: 'mm.fileuploader.audio',
                class: 'mm-fileuploader-audio-handler',
                icon: 'ion-mic-a',
                action: function(maxSize, upload, allowOffline) {
                    return $mmFileUploaderHelper.uploadAudioOrVideo(true, maxSize, upload).then(function(result) {
                        return {
                            uploaded: true,
                            result: result
                        };
                    });
                }
            };
        };
        return self;
    };
        self.videoFilePicker = function() {
        var self = {};
                self.isEnabled = function() {
            return true;
        };
                self.getData = function() {
            return {
                name: 'video',
                title: 'mm.fileuploader.video',
                class: 'mm-fileuploader-video-handler',
                icon: 'ion-ios-videocam',
                action: function(maxSize, upload, allowOffline) {
                    return $mmFileUploaderHelper.uploadAudioOrVideo(false, maxSize, upload).then(function(result) {
                        return {
                            uploaded: true,
                            result: result
                        };
                    });
                }
            };
        };
        return self;
    };
        self.filePicker = function() {
        var self = {},
            uploadFileScope;
                self.isEnabled = function() {
            return ionic.Platform.isAndroid();
        };
                self.getData = function() {
            return {
                name: 'file',
                title: 'mm.fileuploader.file',
                class: 'mm-fileuploader-file-handler',
                icon: 'ion-folder',
                afterRender: function(maxSize, upload, allowOffline) {
                    var element = document.querySelector('.mm-fileuploader-file-handler');
                    if (element) {
                        var input = angular.element('<input type="file" mm-file-uploader-on-change="filePicked">');
                        if (!uploadFileScope) {
                            uploadFileScope = $rootScope.$new();
                            uploadFileScope.filePicked = function(evt) {
                                var input = evt.srcElement;
                                var file = input.files[0];
                                input.value = '';
                                if (!file) {
                                    return;
                                }
                                $mmFileUploaderHelper.uploadFileObject(file, maxSize, upload, allowOffline).then(function(result) {
                                    $mmFileUploaderHelper.fileUploaded(result);
                                }).catch(function(error) {
                                    if (error) {
                                        $mmUtil.showErrorModal(error);
                                    }
                                });
                            };
                        }
                        $compile(input)(uploadFileScope);
                        element.appendChild(input[0]);
                    }
                }
            };
        };
        return self;
    };
    return self;
}]);

angular.module('mm.core.fileuploader')
.constant('mmFileUploaderFileSizeWarning', 1048576)
.constant('mmFileUploaderWifiFileSizeWarning', 10485760)
.factory('$mmFileUploaderHelper', ["$q", "$mmUtil", "$mmApp", "$log", "$translate", "$window", "$rootScope", "$ionicActionSheet", "$mmFileUploader", "$cordovaCamera", "$cordovaCapture", "$mmLang", "$mmFS", "$mmText", "$timeout", "mmFileUploaderFileSizeWarning", "mmFileUploaderWifiFileSizeWarning", "$mmFileUploaderDelegate", function($q, $mmUtil, $mmApp, $log, $translate, $window, $rootScope, $ionicActionSheet,
        $mmFileUploader, $cordovaCamera, $cordovaCapture, $mmLang, $mmFS, $mmText, $timeout, mmFileUploaderFileSizeWarning,
        mmFileUploaderWifiFileSizeWarning, $mmFileUploaderDelegate) {
    $log = $log.getInstance('$mmFileUploaderHelper');
    var self = {},
        filePickerDeferred,
        hideActionSheet;
        self.areFileListDifferent = function(a, b) {
        a = a || [];
        b = b || [];
        if (a.length != b.length) {
            return true;
        }
        for (var i = 0; i < a.length; i++) {
            if (a[i].name != b[i].name) {
                return true;
            }
        }
        return false;
    };
        self.clearTmpFiles = function(files) {
        files.forEach(function(file) {
            if (!file.offline && file.remove) {
                file.remove();
            }
        });
    };
        self.confirmUploadFile = function(size, alwaysConfirm, allowOffline, wifiThreshold, limitedThreshold) {
        if (size == 0) {
            return $q.when();
        }
        if (!allowOffline && !$mmApp.isOnline()) {
            return $mmLang.translateAndReject('mm.fileuploader.errormustbeonlinetoupload');
        }
        wifiThreshold = typeof wifiThreshold == 'undefined' ? mmFileUploaderWifiFileSizeWarning : wifiThreshold;
        limitedThreshold = typeof limitedThreshold == 'undefined' ? mmFileUploaderFileSizeWarning : limitedThreshold;
        if (size < 0) {
            return $mmUtil.showConfirm($translate('mm.fileuploader.confirmuploadunknownsize'));
        } else if (size >= wifiThreshold || ($mmApp.isNetworkAccessLimited() && size >= limitedThreshold)) {
            size = $mmText.bytesToSize(size, 2);
            return $mmUtil.showConfirm($translate('mm.fileuploader.confirmuploadfile', {size: size}));
        } else {
            if (alwaysConfirm) {
                return $mmUtil.showConfirm($translate('mm.core.areyousure'));
            } else {
                return $q.when();
            }
        }
    };
        self.copyAndUploadFile = function(file, upload) {
        var modal = $mmUtil.showModalLoading('mm.fileuploader.readingfile', true),
            fileData;
        return $mmFS.readFileData(file, $mmFS.FORMATARRAYBUFFER).then(function(data) {
            fileData = data;
            return $mmFS.getUniqueNameInFolder($mmFS.getTmpFolder(), file.name);
        }).then(function(newName) {
            var filepath = $mmFS.concatenatePaths($mmFS.getTmpFolder(), newName);
            return $mmFS.writeFile(filepath, fileData);
        }).catch(function(error) {
            $log.error('Error reading file to upload: '+JSON.stringify(error));
            modal.dismiss();
            return $mmLang.translateAndReject('mm.fileuploader.errorreadingfile');
        }).then(function(fileEntry) {
            modal.dismiss();
            if (upload) {
                return self.uploadGenericFile(fileEntry.toURL(), file.name, file.type, true);
            } else {
                return fileEntry;
            }
        });
    };
        self.errorMaxBytes = function(maxSize, fileName) {
        var error = $translate.instant('mm.fileuploader.maxbytesfile', {$a: {
            file: fileName,
            size: $mmText.bytesToSize(maxSize, 2)
        }});
        $mmUtil.showErrorModal(error);
        return $q.reject();
    };
        self.filePickerClosed = function() {
        if (filePickerDeferred) {
            filePickerDeferred.reject();
            filePickerDeferred = undefined;
        }
        if (hideActionSheet) {
            hideActionSheet();
        }
    };
        self.fileUploaded = function(result) {
        if (filePickerDeferred) {
            filePickerDeferred.resolve(result);
            filePickerDeferred = undefined;
        }
        if (hideActionSheet) {
            hideActionSheet();
        }
    };
        self.getStoredFiles = function(folderPath) {
        return $mmFS.getDirectoryContents(folderPath).then(function(files) {
            return self.markOfflineFiles(files);
        });
    };
        self.markOfflineFiles = function(files) {
        angular.forEach(files, function(file) {
            file.offline = true;
            file.filename = file.name;
        });
        return files;
    };
        self.selectAndUploadFile = function(maxSize, title, filterMethods) {
        return selectFile(maxSize, false, title, filterMethods, true);
    };
        self.selectFile = function(maxSize, allowOffline, title, filterMethods) {
        return selectFile(maxSize, allowOffline, title, filterMethods, false);
    };
        function selectFile(maxSize, allowOffline, title, filterMethods, upload) {
        var buttons = [],
            handlers;
        filePickerDeferred = $q.defer();
        handlers = $mmFileUploaderDelegate.getHandlers();
        handlers.sort(function(a, b) {
            return a.priority < b.priority;
        });
        angular.forEach(handlers, function(handler) {
            if (filterMethods && filterMethods.indexOf(handler.name) == -1) {
                return;
            }
            buttons.push({
                text: (handler.icon ? '<i class="icon ' + handler.icon + '"></i>' : '') + $translate.instant(handler.title),
                action: handler.action,
                className: handler.class,
                afterRender: handler.afterRender
            });
        });
        hideActionSheet = $ionicActionSheet.show({
            buttons: buttons,
            titleText: title ? title : $translate.instant('mm.fileuploader.' + (upload ? 'uploadafile' : 'selectafile')),
            cancelText: $translate.instant('mm.core.cancel'),
            buttonClicked: function(index) {
                if (angular.isFunction(buttons[index].action)) {
                    if (!allowOffline && !$mmApp.isOnline()) {
                        $mmUtil.showErrorModal('mm.fileuploader.errormustbeonlinetoupload', true);
                        return;
                    }
                    buttons[index].action(maxSize, upload, allowOffline).then(function(data) {
                        if (data.uploaded) {
                            return data.result;
                        } else {
                            if (data.fileEntry) {
                                return self.uploadFileEntry(data.fileEntry, data.delete, maxSize, upload, allowOffline);
                            } else if (data.path) {
                                return $mmFS.getFile(data.path).then(function(fileEntry) {
                                    return self.uploadFileEntry(fileEntry, data.delete, maxSize, upload, allowOffline);
                                }, function() {
                                    return $mmFS.getExternalFile(data.path).then(function(fileEntry) {
                                        return uploadFileEntry(fileEntry, data.delete, maxSize, upload, allowOffline);
                                    });
                                });
                            }
                            $mmUtil.showErrorModal('No file received');
                        }
                    }).then(function(result) {
                        self.fileUploaded(result);
                    }).catch(function(error) {
                        if (error) {
                            $mmUtil.showErrorModal(error);
                        }
                    });
                }
                return false;
            },
            cancel: function() {
                self.filePickerClosed();
                return true;
            }
        });
        $timeout(function() {
            angular.forEach(buttons, function(button) {
                if (angular.isFunction(button.afterRender)) {
                    button.afterRender(maxSize, upload, allowOffline);
                }
            });
        }, 500);
        return filePickerDeferred.promise;
    }
        self.showConfirmAndUploadInSite = function(fileEntry, deleteAfterUpload, siteId) {
        return $mmFS.getFileObjectFromFileEntry(fileEntry).then(function(file) {
            return self.confirmUploadFile(file.size).then(function() {
                return self.uploadGenericFile(fileEntry.toURL(), file.name, file.type, deleteAfterUpload, siteId).then(function() {
                    $mmUtil.showModal('mm.core.success', 'mm.fileuploader.fileuploaded');
                });
            }).catch(function(err) {
                if (err) {
                    $mmUtil.showErrorModal(err);
                }
                return $q.reject();
            });
        }, function() {
            $mmUtil.showErrorModal('mm.fileuploader.errorreadingfile', true);
            return $q.reject();
        });
    };
        self.uploadAudioOrVideo = function(isAudio, maxSize, upload) {
        $log.debug('Trying to record a video file');
        var fn = isAudio ? $cordovaCapture.captureAudio : $cordovaCapture.captureVideo;
        return fn({limit: 1}).then(function(medias) {
            var media = medias[0],
                path = media.localURL;
            if (upload) {
                return uploadFile(true, path, maxSize, true, $mmFileUploader.uploadMedia, media);
            } else {
                return copyToTmpFolder(path, true, maxSize);
            }
        }, function(error) {
            var defaultError = isAudio ? 'mm.fileuploader.errorcapturingaudio' : 'mm.fileuploader.errorcapturingvideo';
            return treatCaptureError(error, defaultError);
        });
    };
        self.uploadGenericFile = function(uri, name, type, deleteAfterUpload, siteId) {
        return uploadFile(deleteAfterUpload, uri, -1, false,
                $mmFileUploader.uploadGenericFile, uri, name, type, deleteAfterUpload, undefined, undefined, siteId);
    };
        self.uploadImage = function(fromAlbum, maxSize, upload) {
        $log.debug('Trying to capture an image with camera');
        var options = {
            quality: 50,
            destinationType: navigator.camera.DestinationType.FILE_URI,
            correctOrientation: true
        };
        if (fromAlbum) {
            options.sourceType = navigator.camera.PictureSourceType.PHOTOLIBRARY;
            options.popoverOptions = new CameraPopoverOptions(10, 10, $window.innerWidth  - 200, $window.innerHeight - 200,
                                            Camera.PopoverArrowDirection.ARROW_ANY);
            if (ionic.Platform.isIOS()) {
                options.mediaType = Camera.MediaType.ALLMEDIA;
            }
        }
        return $cordovaCamera.getPicture(options).then(function(path) {
            if (upload) {
                return uploadFile(!fromAlbum, path, maxSize, true, $mmFileUploader.uploadImage, path, fromAlbum);
            } else {
                return copyToTmpFolder(path, !fromAlbum, maxSize, 'jpg');
            }
        }, function(error) {
            var defaultError = fromAlbum ? 'mm.fileuploader.errorgettingimagealbum' : 'mm.fileuploader.errorcapturingimage';
            return treatImageError(error, defaultError);
        });
    };
        self.uploadFileEntry = function(fileEntry, deleteAfter, maxSize, upload, allowOffline) {
        return $mmFS.getFileObjectFromFileEntry(fileEntry).then(function(file) {
            return self.uploadFileObject(file, maxSize, upload, allowOffline).then(function(result) {
                if (deleteAfter) {
                    $mmFS.removeFileByFileEntry(fileEntry);
                }
                return result;
            });
        });
    };
        self.uploadFileObject = function(file, maxSize, upload, allowOffline) {
        if (maxSize != -1 && file.size > maxSize) {
            return self.errorMaxBytes(maxSize, file.name);
        }
        return self.confirmUploadFile(file.size, false, allowOffline).then(function() {
            return self.copyAndUploadFile(file, upload);
        });
    };
        function treatImageError(error, defaultMessage) {
        if (error) {
            if (typeof error == 'string') {
                if (error.toLowerCase().indexOf("error") > -1 || error.toLowerCase().indexOf("unable") > -1) {
                    $log.error('Error getting image: ' + error);
                    return $q.reject(error);
                } else {
                    $log.debug('Cancelled');
                }
            } else {
                return $mmLang.translateAndReject(defaultMessage);
            }
        }
        return $q.reject();
    }
        function treatCaptureError(error, defaultMessage) {
        if (error) {
            if (typeof error === 'string') {
                $log.error('Error while recording audio/video: ' + error);
                if (error.indexOf('No Activity found') > -1) {
                    return $mmLang.translateAndReject('mm.fileuploader.errornoapp');
                } else {
                    return $mmLang.translateAndReject(defaultMessage);
                }
            } else {
                if (error.code != 3) {
                    $log.error('Error while recording audio/video: ' + JSON.stringify(error));
                    return $mmLang.translateAndReject(defaultMessage);
                } else {
                    $log.debug('Cancelled');
                }
            }
        }
        return $q.reject();
    }
        function copyToTmpFolder(path, shouldDelete, maxSize, defaultExt) {
        var fileName = $mmFS.getFileAndDirectoryFromPath(path).name,
            promise,
            fileTooLarge;
        if (typeof maxSize != 'undefined' && maxSize != -1) {
            promise = $mmFS.getExternalFile(path).then(function(fileEntry) {
                return $mmFS.getFileObjectFromFileEntry(fileEntry).then(function(file) {
                    if (file.size > maxSize) {
                        fileTooLarge = file;
                    }
                });
            }).catch(function() {
            });
        } else {
            promise = $q.when();
        }
        return promise.then(function() {
            if (fileTooLarge) {
                return self.errorMaxBytes(maxSize, fileTooLarge.name);
            }
            fileName = fileName.replace(/(\.[^\.]*)\?[^\.]*$/, '$1');
            return $mmFS.getUniqueNameInFolder($mmFS.getTmpFolder(), fileName, defaultExt);
        }).then(function(newName) {
            var destPath = $mmFS.concatenatePaths($mmFS.getTmpFolder(), newName);
            if (shouldDelete) {
                return $mmFS.moveExternalFile(path, destPath);
            } else {
                return $mmFS.copyExternalFile(path, destPath);
            }
        });
    }
        function uploadFile(deleteAfterUpload, path, maxSize, checkSize, uploadFn) {
        var errorStr = $translate.instant('mm.core.error'),
            retryStr = $translate.instant('mm.core.retry'),
            args = arguments,
            progressTemplate =  "<div>" +
                                    "<ion-spinner></ion-spinner>" +
                                    "<p ng-if=\"!perc\">{{'mm.fileuploader.uploading' | translate}}</p>" +
                                    "<p ng-if=\"perc\">{{'mm.fileuploader.uploadingperc' | translate:{$a: perc} }}</p>" +
                                "</div>",
            scope,
            modal,
            promise,
            file;
        if (!$mmApp.isOnline()) {
            return errorUploading($translate.instant('mm.fileuploader.errormustbeonlinetoupload'));
        }
        if (checkSize) {
            promise = $mmFS.getExternalFile(path).then(function(fileEntry) {
                return $mmFS.getFileObjectFromFileEntry(fileEntry).then(function(f) {
                    file = f;
                    return file.size;
                });
            }).catch(function() {
            });
        } else {
            promise = $q.when(0);
        }
        return promise.then(function(size) {
            if (maxSize != -1 && size > maxSize) {
                return self.errorMaxBytes(maxSize, file.name);
            }
            if (size > 0) {
                return self.confirmUploadFile(size);
            }
        }).then(function() {
            scope = $rootScope.$new();
            modal = $mmUtil.showModalLoadingWithTemplate(progressTemplate, {scope: scope});
            return uploadFn.apply(undefined, Array.prototype.slice.call(args, 5)).then(undefined, undefined, function(progress) {
                if (progress && progress.lengthComputable) {
                    var perc = parseFloat(Math.min((progress.loaded / progress.total) * 100, 100)).toFixed(1);
                    if (perc >= 0) {
                        scope.perc = perc;
                    }
                }
            }).catch(function(error) {
                $log.error('Error uploading file: '+JSON.stringify(error));
                modal.dismiss();
                if (typeof error != 'string') {
                    error = $translate.instant('mm.fileuploader.errorwhileuploading');
                }
                return errorUploading(error);
            }).finally(function() {
                modal.dismiss();
                scope.$destroy();
            });
        });
        function errorUploading(error) {
            var options = {
                okText: retryStr
            };
            return $mmUtil.showConfirm(error, errorStr, options).then(function() {
                return uploadFile.apply(undefined, args);
            }, function() {
                if (deleteAfterUpload) {
                    angular.forEach(paths, function(path) {
                        $mmFS.removeExternalFile(path);
                    });
                }
                return $q.reject();
            });
        }
    }
    return self;
}]);

angular.module('mm.core.grades')
.controller('mmGradesGradeCtrl', ["$scope", "$stateParams", "$mmUtil", "$mmGrades", "$mmSite", "$mmGradesHelper", "$log", function($scope, $stateParams, $mmUtil, $mmGrades, $mmSite, $mmGradesHelper, $log) {
    $log = $log.getInstance('mmGradesGradeCtrl');
    var courseId = $stateParams.courseid,
        userId = $stateParams.userid || $mmSite.getUserId();
    function fetchGrade() {
        return $mmGrades.getGradesTable(courseId, userId).then(function(table) {
            $scope.grade = $mmGradesHelper.getGradeRow(table, $stateParams.gradeid);
        }, function(message) {
            $mmUtil.showErrorModal(message);
            $scope.errormessage = message;
        });
    }
    fetchGrade().finally(function() {
        $scope.gradeLoaded = true;
    });
    $scope.refreshGrade = function() {
        fetchGrade().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
    $scope.refreshGrade = function() {
        $mmGrades.invalidateGradesTableData(courseId, userId).finally(function() {
            fetchGrade().finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };
}]);

angular.module('mm.core.grades')
.controller('mmGradesTableCtrl', ["$scope", "$stateParams", "$mmUtil", "$mmGrades", "$mmSite", "$mmGradesHelper", "$state", function($scope, $stateParams, $mmUtil, $mmGrades, $mmSite, $mmGradesHelper, $state) {
    var course = $stateParams.course || {},
        courseId = $stateParams.courseid || course.id,
        userId = $stateParams.userid || $mmSite.getUserId(),
        forcePhoneView = $stateParams.forcephoneview || false;
    $scope.forcePhoneView = !!forcePhoneView;
    function fetchGrades() {
        return $mmGrades.getGradesTable(courseId, userId).then(function(table) {
            table = $mmGradesHelper.formatGradesTable(table, forcePhoneView);
            return $mmGradesHelper.translateGradesTable(table).then(function(table) {
                $scope.gradesTable = table;
            });
        }, function(message) {
            $mmUtil.showErrorModal(message);
            $scope.errormessage = message;
        });
    }
    fetchGrades().then(function() {
        $mmSite.write('gradereport_user_view_grade_report', {
            courseid: courseId,
            userid: userId
        });
    }).finally(function() {
        $scope.gradesLoaded = true;
    });
    $scope.expandGradeInfo = function(gradeid) {
        if (gradeid) {
            $state.go('site.grade', {
                courseid: courseId,
                userid: userId,
                gradeid: gradeid
            });
        }
    };
    $scope.refreshGrades = function() {
        $mmGrades.invalidateGradesTableData(courseId, userId).finally(function() {
            fetchGrades().finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };
}]);

angular.module('mm.core.grades')
.factory('$mmGrades', ["$q", "$log", "$mmSite", "$mmCourses", "$mmSitesManager", "$mmUtil", "$mmText", function($q, $log, $mmSite, $mmCourses, $mmSitesManager, $mmUtil, $mmText) {
    $log = $log.getInstance('$mmGrades');
    var self = {};
        function getGradesTableCacheKey(courseId, userId) {
        return getGradesTablePrefixCacheKey(courseId) + userId;
    }
        function getGradeItemsCacheKey(courseId, userId, groupId) {
        groupId = groupId || 0;
        return getGradeItemsPrefixCacheKey(courseId) + userId + ':' + groupId;
    }
        function getGradesTablePrefixCacheKey(courseId) {
        return 'mmGrades:table:' + courseId + ':';
    }
        function getGradeItemsPrefixCacheKey(courseId) {
        return 'mmGrades:items:' + courseId + ':';
    }
        self.invalidateGradesTableData = function(courseId, userId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getGradesTableCacheKey(courseId, userId));
        });
    };
        self.invalidateGradeItemsData = function(courseId, userId, groupId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getGradeItemsCacheKey(courseId, userId, groupId));
        });
    };
        self.invalidateGradesTableCourseData = function(courseId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKeyStartingWith(getGradesTablePrefixCacheKey(courseId));
        });
    };
        self.invalidateGradeCourseItemsData = function(courseId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKeyStartingWith(getGradeItemsPrefixCacheKey(courseId));
        });
    };
        self.isPluginEnabled = function(siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.wsAvailable('gradereport_user_get_grades_table');
        });
    };
        self.isPluginEnabledForCourse = function(courseId, siteId) {
        if (!courseId) {
            return $q.reject();
        }
        return $mmCourses.getUserCourse(courseId, true, siteId).then(function(course) {
            if (course && typeof course.showgrades != 'undefined' && course.showgrades == 0) {
                return false;
            }
            return true;
        });
    };
        self.isGradeItemsAvalaible = function(siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.wsAvailable('gradereport_user_get_grade_items');
        });
    };
        self.isPluginEnabledForUser = function(courseId, userId) {
        var data = {
                courseid: courseId,
                userid: userId
            };
        return $mmSite.read('gradereport_user_get_grades_table', data, {}).then(function() {
            return true;
        }).catch(function() {
            return false;
        });
    };
        self.getGradesTable = function(courseId, userId, siteId, ignoreCache) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            $log.debug('Get grades for course ' + courseId + ' and user ' + userId);
            var data = {
                    courseid : courseId,
                    userid   : userId
                },
                preSets = {
                    cacheKey: getGradesTableCacheKey(courseId, userId)
                };
            if (ignoreCache) {
                preSets.getFromCache = 0;
                preSets.emergencyCache = 0;
            }
            return site.read('gradereport_user_get_grades_table', data, preSets).then(function (table) {
                if (table && table.tables && table.tables[0]) {
                    return table.tables[0];
                }
                return $q.reject();
            });
        });
    };
        self.getGradeItems = function(courseId, userId, groupId, siteId, ignoreCache) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            $log.debug('Get grades for course ' + courseId + ', user ' + userId);
            var data = {
                    courseid : courseId,
                    userid   : userId,
                    groupid  : groupId || 0
                },
                preSets = {
                    cacheKey: getGradeItemsCacheKey(courseId, userId, groupId)
                };
            if (ignoreCache) {
                preSets.getFromCache = 0;
                preSets.emergencyCache = 0;
            }
            return site.read('gradereport_user_get_grade_items', data, preSets).then(function(grades) {
                if (grades && grades.usergrades && grades.usergrades[0]) {
                    return grades.usergrades[0];
                }
                return $q.reject();
            });
        });
    };
        function getGradeModuleItems(courseId, moduleId, userId, groupId, siteId, ignoreCache) {
        return self.getGradeItems(courseId, userId, groupId, siteId, ignoreCache).then(function(grades) {
            if (grades && grades.gradeitems) {
                var items = [];
                for (var x in grades.gradeitems) {
                    if (grades.gradeitems[x].cmid == moduleId) {
                        items.push(grades.gradeitems[x]);
                    }
                }
                if (items.length > 0) {
                    return items;
                }
            }
            return $q.reject();
        });
    }
        function getGradesItemFromTable(courseId, moduleId, userId, siteId, ignoreCache) {
        return self.getGradesTable(courseId, userId, siteId, ignoreCache).then(function(table) {
            var regex = /href="([^"]*\/mod\/[^"|^\/]*\/[^"|^\.]*\.php[^"]*)/,
                matches,
                hrefParams,
                entry,
                items = [];
            for (var i = 0; i < table.tabledata.length; i++) {
                entry = table.tabledata[i];
                if (entry.itemname && entry.itemname.content) {
                    matches = entry.itemname.content.match(regex);
                    if (matches && matches.length) {
                        hrefParams = $mmUtil.extractUrlParams(matches[1]);
                        if (hrefParams && hrefParams.id == moduleId) {
                            var item = {};
                            angular.forEach(entry, function(value, name) {
                                if (value && value.content) {
                                    switch (name) {
                                        case 'grade':
                                            var grade = parseFloat(value.content);
                                            if (!isNaN(grade)) {
                                                item.gradeformatted = grade;
                                            }
                                            break;
                                        case 'percentage':
                                        case 'range':
                                            name += 'formatted';
                                        default:
                                            item[name] = $mmText.decodeHTML(value.content).trim();
                                    }
                                }
                            });
                            items.push(item);
                        }
                    }
                }
            }
            if (items.length > 0) {
                return items;
            }
            return $q.reject();
        });
    }
        self.getGradeModuleItems = function(courseId, moduleId, userId, groupId, siteId, ignoreCache) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            return self.isGradeItemsAvalaible(siteId).then(function(enabled) {
                if (enabled) {
                    return getGradeModuleItems(courseId, moduleId, userId, groupId, siteId, ignoreCache).catch(function() {
                        return getGradesItemFromTable(courseId, moduleId, userId, siteId, ignoreCache);
                    });
                } else {
                    return getGradesItemFromTable(courseId, moduleId, userId, siteId, ignoreCache);
                }
            });
        });
    };
        self.invalidateGradeModuleItems = function(courseId, userId, groupId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            return self.isGradeItemsAvalaible(siteId).then(function(enabled) {
                if (enabled) {
                    return self.invalidateGradeItemsData(courseId, userId, groupId, siteId);
                } else {
                    return self.invalidateGradesTableData(courseId, userId, siteId);
                }
            });
        });
    };
        self.invalidateGradeCourseItems = function(courseId, siteId) {
        siteId = siteId || $mmSite.getId();
        return self.isGradeItemsAvalaible(siteId).then(function(enabled) {
            if (enabled) {
                return self.invalidateGradeCourseItemsData(courseId, siteId);
            } else {
                return self.invalidateGradesTableCourseData(courseId, siteId);
            }
        });
    };
    return self;
}]);

angular.module('mm.core.grades')
.factory('$mmGradesHelper', ["$q", "$mmText", "$translate", "$mmCourse", "$sce", function($q, $mmText, $translate, $mmCourse, $sce) {
    var self = {};
        self.formatGradesTable = function(table, forcePhoneView) {
        var formatted = {
            columns: [],
            rows: []
        };
        var columns = {
            itemname: true,
            weight: false,
            grade: false,
            range: false,
            percentage: false,
            lettergrade: false,
            rank: false,
            average: false,
            feedback: false,
            contributiontocoursetotal: false
        };
        var returnedColumns = [];
        var tabledata = [];
        var maxDepth = 0;
        if (table['tabledata']) {
            tabledata = table['tabledata'];
            maxDepth = table['maxdepth'];
            for (var el in tabledata) {
                if (!angular.isArray(tabledata[el]) && typeof(tabledata[el]["leader"]) === "undefined") {
                    for (var col in tabledata[el]) {
                        returnedColumns.push(col);
                    }
                    break;
                }
            }
        }
        if (returnedColumns.length > 0) {
            var columnAdded = false;
            for (var i = 0; i < tabledata.length && !columnAdded; i++) {
                if (typeof(tabledata[i]["grade"]) != "undefined" &&
                        typeof(tabledata[i]["grade"]["content"]) != "undefined") {
                    columns.grade = true;
                    columnAdded = true;
                } else if (typeof(tabledata[i]["percentage"]) != "undefined" &&
                        typeof(tabledata[i]["percentage"]["content"]) != "undefined") {
                    columns.percentage = true;
                    columnAdded = true;
                }
            }
            if (!columnAdded) {
                columns.grade = true;
            }
            for (var colName in columns) {
                if (returnedColumns.indexOf(colName) > -1) {
                    var width = colName == "itemname" ? maxDepth : 1;
                    var column = {
                        id: colName,
                        name: colName,
                        width: width,
                        showAlways: columns[colName]
                    };
                    formatted.columns.push(column);
                }
            }
            var name, rowspan, tclass, colspan, content, celltype, id, headers, img;
            for (var i = 0; i < tabledata.length; i++) {
                var row = {};
                row.text = '';
                if (typeof(tabledata[i]['leader']) != "undefined") {
                    rowspan = tabledata[i]['leader']['rowspan'];
                    tclass = tabledata[i]['leader']['class'];
                    row.text += '<td class="' + tclass + '" rowspan="' + rowspan + '"></td>';
                }
                for (el in returnedColumns) {
                    name = returnedColumns[el];
                    if (forcePhoneView && !columns[name]) {
                        continue;
                    }
                    if (typeof(tabledata[i][name]) != "undefined") {
                        tclass = (typeof(tabledata[i][name]['class']) != "undefined")? tabledata[i][name]['class'] : '';
                        tclass += columns[name] ? '' : ' hidden-phone';
                        colspan = (typeof(tabledata[i][name]['colspan']) != "undefined")? "colspan='"+tabledata[i][name]['colspan']+"'" : '';
                        content = (typeof(tabledata[i][name]['content']) != "undefined")? tabledata[i][name]['content'] : null;
                        celltype = (typeof(tabledata[i][name]['celltype']) != "undefined")? tabledata[i][name]['celltype'] : 'td';
                        id = (typeof(tabledata[i][name]['id']) != "undefined")? "id='" + tabledata[i][name]['id'] +"'" : '';
                        headers = (typeof(tabledata[i][name]['headers']) != "undefined")? "headers='" + tabledata[i][name]['headers'] + "'" : '';
                        if (typeof(content) != "undefined") {
                            img = getImgHTML(content);
                            content = content.replace(/<\/span>/gi, "\n");
                            content = $mmText.cleanTags(content);
                            content = $mmText.replaceNewLines(content, '<br>');
                            content = img + " " + content;
                            row.text += "<" + celltype + " " + id + " " + headers + " " + "class='"+ tclass +"' " + colspan +">";
                            row.text += content;
                            row.text += "</" + celltype + ">";
                        }
                    }
                }
                if (row.text.length > 0) {
                    if (tabledata[i].itemname && tabledata[i].itemname.id && tabledata[i].itemname.id.substr(0, 3) == 'row') {
                        row.id = tabledata[i].itemname.id.split('_')[1];
                    }
                    row.text = $sce.trustAsHtml(row.text);
                }
                formatted.rows.push(row);
            }
        }
        return formatted;
    };
        self.getGradeRow = function(table, gradeid) {
        var row = {},
            selectedRow = false;
        if (table['tabledata']) {
            var tabledata = table['tabledata'];
            for (var i = 0; i < tabledata.length; i++) {
                if (tabledata[i].itemname && tabledata[i].itemname.id && tabledata[i].itemname.id.substr(0, 3) == 'row') {
                    if (tabledata[i].itemname.id.split('_')[1] == gradeid) {
                        selectedRow = tabledata[i];
                        break;
                    }
                }
            }
        }
        if (!selectedRow) {
            return "";
        }
        for (var name in selectedRow) {
            if (typeof(selectedRow[name]) != "undefined" && typeof(selectedRow[name]['content']) != "undefined") {
                var content = selectedRow[name]['content'];
                if (name == 'itemname') {
                    var img = getImgHTML(content);
                    row.link = getModuleLink(content);
                    content = content.replace(/<\/span>/gi, "\n");
                    content = $mmText.cleanTags(content);
                    content = img + " " + content;
                } else {
                    content = $mmText.replaceNewLines(content, '<br>');
                }
                if (content == '&nbsp;') {
                    content = "";
                }
                row[name] = content.trim();
            }
        }
        return row;
    };
        function getImgHTML(text) {
        var img = '';
        text = text.replace("%2F", "/").replace("%2f", "/");
        if (text.indexOf("/agg_mean") > -1) {
            img = '<img src="core/components/grades/img/agg_mean.png" width="16">';
        } else if (text.indexOf("/agg_sum") > -1) {
            img = '<img src="core/components/grades/img/agg_sum.png" width="16">';
        } else if (text.indexOf("/outcomes") > -1) {
            img = '<img src="core/components/grades/img/outcomes.png" width="16">';
        } else if (text.indexOf("i/folder") > -1) {
            img = '<img src="core/components/grades/img/folder.png" width="16">';
        } else if (text.indexOf("/manual_item") > -1) {
            img = '<img src="core/components/grades/img/manual_item.png" width="16">';
        } else if (text.indexOf("/mod/") > -1) {
            var module = text.match(/mod\/([^\/]*)\//);
            if (typeof module[1] != "undefined") {
                var moduleSrc = $mmCourse.getModuleIconSrc(module[1]);
                img = '<img src="' + moduleSrc + '" width="16">';
            }
        }
        if (img) {
            img = '<span class="app-ico">' + img + '</span>';
        }
        return img;
    }
        function getModuleLink(text) {
        var el = angular.element(text)[0],
            link = el.attributes['href'] ? el.attributes['href'].value : false;
        if (!link || link.indexOf("/mod/") < 0) {
            return false;
        }
        return link;
    }
        self.translateGradesTable = function(table) {
        var columns = angular.copy(table.columns),
            promises = [];
        columns.forEach(function(column) {
            var promise = $translate('mm.grades.'+column.name).then(function(translated) {
                column.name = translated;
            });
            promises.push(promise);
        });
        return $q.all(promises).then(function() {
            return {
                columns: columns,
                rows: table.rows
            };
        });
    };
    return self;
}]);

angular.module('mm.core.login')
.controller('mmLoginCredentialsCtrl', ["$scope", "$stateParams", "$mmSitesManager", "$mmUtil", "$ionicHistory", "$mmApp", "$q", "$mmLoginHelper", "$mmContentLinksDelegate", "$mmContentLinksHelper", "$translate", function($scope, $stateParams, $mmSitesManager, $mmUtil, $ionicHistory, $mmApp,
            $q, $mmLoginHelper, $mmContentLinksDelegate, $mmContentLinksHelper, $translate) {
    $scope.siteurl = $stateParams.siteurl;
    $scope.credentials = {
        username: $stateParams.username
    };
    $scope.siteChecked = false;
    var urlToOpen = $stateParams.urltoopen,
        siteConfig = $stateParams.siteconfig;
    treatSiteConfig(siteConfig);
    function checkSite(siteurl) {
        var checkmodal = $mmUtil.showModalLoading(),
            protocol = siteurl.indexOf('http://') === 0 ? 'http://' : undefined;
        return $mmSitesManager.checkSite(siteurl, protocol).then(function(result) {
            $scope.siteChecked = true;
            $scope.siteurl = result.siteurl;
            treatSiteConfig(result.config);
            if (result && result.warning) {
                $mmUtil.showErrorModal(result.warning, true, 4000);
            }
            if ($mmLoginHelper.isSSOLoginNeeded(result.code)) {
                $scope.isBrowserSSO = true;
                if (!$mmApp.isSSOAuthenticationOngoing() && !$scope.$$destroyed) {
                    $mmLoginHelper.confirmAndOpenBrowserForSSOLogin(
                                result.siteurl, result.code, result.service, result.config && result.config.launchurl);
                }
            } else {
                $scope.isBrowserSSO = false;
            }
        }).catch(function(error) {
            $mmUtil.showErrorModal(error);
            return $q.reject();
        }).finally(function() {
            checkmodal.dismiss();
        });
    }
    function treatSiteConfig(siteConfig) {
        if (siteConfig) {
            $scope.sitename = siteConfig.sitename;
            $scope.logourl = siteConfig.logourl || siteConfig.compactlogourl;
            $scope.authInstructions = siteConfig.authinstructions || $translate.instant('mm.login.loginsteps');
            $scope.canSignup = siteConfig.registerauth == 'email' && !$mmLoginHelper.isEmailSignupDisabled(siteConfig);
        } else {
            $scope.sitename = null;
            $scope.logourl = null;
            $scope.authInstructions = null;
            $scope.canSignup = false;
        }
    }
    if ($mmLoginHelper.isFixedUrlSet()) {
        checkSite($scope.siteurl);
    } else {
        $scope.siteChecked = true;
    }
    $scope.login = function() {
        $mmApp.closeKeyboard();
        var siteurl = $scope.siteurl,
            username = $scope.credentials.username,
            password = $scope.credentials.password;
        if (!$scope.siteChecked) {
            return checkSite(siteurl).then(function() {
                if (!$scope.isBrowserSSO) {
                    return $scope.login();
                }
            });
        } else if ($scope.isBrowserSSO) {
            return checkSite(siteurl);
        }
        if (!username) {
            $mmUtil.showErrorModal('mm.login.usernamerequired', true);
            return;
        }
        if (!password) {
            $mmUtil.showErrorModal('mm.login.passwordrequired', true);
            return;
        }
        var modal = $mmUtil.showModalLoading();
        return $mmSitesManager.getUserToken(siteurl, username, password).then(function(data) {
            return $mmSitesManager.newSite(data.siteurl, data.token, data.privatetoken).then(function() {
                delete $scope.credentials;
                $ionicHistory.nextViewOptions({disableBack: true});
                if (urlToOpen) {
                    return $mmContentLinksDelegate.getActionsFor(urlToOpen, undefined, username).then(function(actions) {
                        action = $mmContentLinksHelper.getFirstValidAction(actions);
                        if (action && action.sites.length) {
                            action.action(action.sites[0]);
                        } else {
                            return $mmLoginHelper.goToSiteInitialPage();
                        }
                    });
                } else {
                    return $mmLoginHelper.goToSiteInitialPage();
                }
            });
        }).catch(function(error) {
            $mmLoginHelper.treatUserTokenError(siteurl, error);
        }).finally(function() {
            modal.dismiss();
        });
    };
}]);

angular.module('mm.core.login')
.controller('mmLoginEmailSignupCtrl', ["$scope", "$stateParams", "$mmUtil", "$ionicHistory", "$mmLoginHelper", "$mmWS", "$q", "$translate", "$ionicModal", "$ionicScrollDelegate", "$mmUserProfileFieldsDelegate", "$mmSitesManager", "$mmText", function($scope, $stateParams, $mmUtil, $ionicHistory, $mmLoginHelper, $mmWS, $q, $translate,
            $ionicModal, $ionicScrollDelegate, $mmUserProfileFieldsDelegate, $mmSitesManager, $mmText) {
    var siteConfig,
        modalInitialized = false,
        scrollView = $ionicScrollDelegate.$getByHandle('mmLoginEmailSignupScroll');
    $scope.siteurl = $stateParams.siteurl;
    $scope.data = {};
    $scope.escapeForRegex = $mmText.escapeForRegex;
    $scope.usernameErrors = $mmLoginHelper.getErrorMessages('mm.login.usernamerequired');
    $scope.passwordErrors = $mmLoginHelper.getErrorMessages('mm.login.passwordrequired');
    $scope.emailErrors = $mmLoginHelper.getErrorMessages('mm.login.missingemail');
    $scope.email2Errors = $mmLoginHelper.getErrorMessages('mm.login.missingemail', null, 'mm.login.emailnotmatch');
    $scope.policyErrors = $mmLoginHelper.getErrorMessages('mm.login.policyagree');
    function fetchData() {
        return $mmSitesManager.getSitePublicConfig($scope.siteurl).then(function(config) {
            siteConfig = config;
            if (treatSiteConfig(siteConfig)) {
                return getSignupSettings();
            }
        }).catch(function(err) {
            $mmUtil.showErrorModal(err);
            return $q.reject();
        });
    }
    function treatSiteConfig(siteConfig) {
        if (siteConfig && siteConfig.registerauth == 'email' && !$mmLoginHelper.isEmailSignupDisabled(siteConfig)) {
            $scope.logourl = siteConfig.logourl || siteConfig.compactlogourl;
            $scope.authInstructions = siteConfig.authinstructions;
            initAuthInstructionsModal();
            return true;
        } else {
            $mmUtil.showErrorModal($translate.instant('mm.login.signupplugindisabled',
                    {$a: $translate.instant('mm.login.auth_email')}));
            $ionicHistory.goBack();
            return false;
        }
    }
    function getSignupSettings() {
        return $mmWS.callAjax('auth_email_get_signup_settings', {}, {siteurl: $scope.siteurl}).then(function(settings) {
            $scope.settings = settings;
            $scope.countries = $mmUtil.getCountryList();
            $scope.categories = $mmLoginHelper.formatProfileFieldsForSignup(settings.profilefields);
            if (settings.defaultcity && !$scope.data.city) {
                $scope.data.city = settings.defaultcity;
            }
            if (settings.country && !$scope.data.country) {
                $scope.data.country = settings.country;
            }
            $scope.namefieldsErrors = {};
            angular.forEach(settings.namefields, function(field) {
                $scope.namefieldsErrors[field] = $mmLoginHelper.getErrorMessages('mm.login.missing' + field);
            });
        });
    }
    function initAuthInstructionsModal() {
        if ($scope.authInstructions && !modalInitialized) {
            $ionicModal.fromTemplateUrl('core/components/login/templates/authinstructions-modal.html', {
                scope: $scope,
                animation: 'slide-in-up'
            }).then(function(modal) {
                modalInitialized = true;
                $scope.showAuthInstructions = function() {
                    modal.show();
                };
                $scope.closeAuthInstructions = function() {
                    modal.hide();
                };
                $scope.$on('$destroy', function() {
                    modal.remove();
                });
            });
        }
    }
    fetchData().finally(function() {
        $scope.settingsLoaded = true;
    });
    $scope.refreshSettings = function() {
        fetchData().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
    $scope.requestCaptcha = function() {
        var modal = $mmUtil.showModalLoading();
        $scope.data.recaptcharesponse = '';
        getSignupSettings().finally(function() {
            modal.dismiss();
        });
    };
    $scope.create = function(signupForm) {
        if (!signupForm.$valid) {
            return $mmUtil.scrollToInputError(document, scrollView).then(function(found) {
                if (!found) {
                    $mmUtil.showErrorModal('mm.core.errorinvalidform', true);
                }
            });
        } else {
            var fields = $scope.settings.profilefields,
                params = {
                    username: $scope.data.username.trim().toLowerCase(),
                    password: $scope.data.password,
                    firstname: $mmText.cleanTags($scope.data.firstname),
                    lastname: $mmText.cleanTags($scope.data.lastname),
                    email: $scope.data.email.trim(),
                    city: $mmText.cleanTags($scope.data.city),
                    country: $scope.data.country
                },
                modal = $mmUtil.showModalLoading('mm.core.sending', true);
            if (siteConfig.launchurl) {
                var service = $mmSitesManager.determineService($scope.siteurl);
                params.redirect = $mmLoginHelper.prepareForSSOLogin($scope.siteurl, service, siteConfig.launchurl);
            }
            if ($scope.settings.recaptchachallengehash && $scope.settings.recaptchachallengeimage) {
                params.recaptchachallengehash = $scope.settings.recaptchachallengehash;
                params.recaptcharesponse = $scope.data.recaptcharesponse;
            }
            $mmUserProfileFieldsDelegate.getDataForFields(fields, true, 'email', $scope.data).then(function(fieldsData) {
                params.customprofilefields = fieldsData;
                return $mmWS.callAjax('auth_email_signup_user', params, {siteurl: $scope.siteurl}).then(function(result) {
                    if (result.success) {
                        var message = $translate.instant('mm.login.emailconfirmsent', {$a: $scope.data.email});
                        $mmUtil.showModal('mm.core.success', message);
                        $ionicHistory.goBack();
                    } else {
                        if (result.warnings && result.warnings.length) {
                            $mmUtil.showErrorModal(result.warnings[0].message);
                        } else {
                            $mmUtil.showErrorModal('mm.login.usernotaddederror', true);
                        }
                        $scope.requestCaptcha();
                    }
                });
            }).catch(function(error) {
                if (error) {
                    $mmUtil.showErrorModal(error);
                } else {
                    $mmUtil.showErrorModal('mm.login.usernotaddederror', true);
                }
                $scope.requestCaptcha();
            }).finally(function() {
                modal.dismiss();
            });
        }
    };
}]);

angular.module('mm.core.login')
.controller('mmLoginInitCtrl', ["$log", "$ionicHistory", "$state", "$mmSitesManager", "$mmSite", "$mmApp", "$mmLoginHelper", function($log, $ionicHistory, $state, $mmSitesManager, $mmSite, $mmApp, $mmLoginHelper) {
    $log = $log.getInstance('mmLoginInitCtrl');
    $mmApp.ready().then(function() {
        $ionicHistory.nextViewOptions({
            disableAnimate: true,
            disableBack: true
        });
        var redirectData = $mmApp.getRedirect();
        if (redirectData.siteid && redirectData.state) {
            $mmApp.storeRedirect('', '', '');
            if (new Date().getTime() - redirectData.timemodified < 20000) {
                return $mmSitesManager.loadSite(redirectData.siteid).then(function() {
                    if (!$mmLoginHelper.isSiteLoggedOut(redirectData.state, redirectData.params)) {
                        $state.go(redirectData.state, redirectData.params);
                    }
                }).catch(function() {
                    loadCurrent();
                });
            }
        }
        loadCurrent();
    });
    function loadCurrent() {
        if ($mmSite.isLoggedIn()) {
            if (!$mmLoginHelper.isSiteLoggedOut()) {
                $mmLoginHelper.goToSiteInitialPage();
            }
        } else {
            $mmSitesManager.hasSites().then(function() {
                return $state.go('mm_login.sites');
            }, function() {
                return $mmLoginHelper.goToAddSite();
            });
        }
    }
}]);

angular.module('mm.core.login')
.controller('mmLoginReconnectCtrl', ["$scope", "$state", "$stateParams", "$mmSitesManager", "$mmApp", "$mmUtil", "$ionicHistory", "$mmLoginHelper", "$mmSite", function($scope, $state, $stateParams, $mmSitesManager, $mmApp, $mmUtil, $ionicHistory,
            $mmLoginHelper, $mmSite) {
    var infositeurl = $stateParams.infositeurl,
        stateName = $stateParams.statename,
        stateParams = $stateParams.stateparams;
    $scope.siteurl = $stateParams.siteurl;
    $scope.credentials = {
        username: $stateParams.username,
        password: ''
    };
    $scope.isLoggedOut = $mmSite.isLoggedOut();
    $mmSitesManager.getSite($stateParams.siteid).then(function(site) {
        $scope.site = {
            id: site.id,
            fullname: site.infos.fullname,
            avatar: site.infos.userpictureurl
        };
        $scope.credentials.username = site.infos.username;
        $scope.siteurl = site.infos.siteurl;
    });
    $scope.cancel = function() {
        $mmSitesManager.logout().finally(function() {
            $ionicHistory.nextViewOptions({
                disableAnimate: true,
                disableBack: true
            });
            $state.go('mm_login.sites');
        });
    };
    $scope.login = function() {
        $mmApp.closeKeyboard();
        var siteurl = $scope.siteurl,
            username = $scope.credentials.username,
            password = $scope.credentials.password;
        if (!password) {
            $mmUtil.showErrorModal('mm.login.passwordrequired', true);
            return;
        }
        var modal = $mmUtil.showModalLoading();
        $mmSitesManager.getUserToken(siteurl, username, password).then(function(data) {
            $mmSitesManager.updateSiteToken(infositeurl, username, data.token, data.privatetoken).then(function() {
                $mmSitesManager.updateSiteInfoByUrl(infositeurl, username).finally(function() {
                    delete $scope.credentials;
                    $ionicHistory.nextViewOptions({disableBack: true});
                    if (stateName) {
                        return $state.go(stateName, stateParams);
                    } else {
                        return $mmLoginHelper.goToSiteInitialPage();
                    }
                });
            }, function() {
                $mmUtil.showErrorModal('mm.login.errorupdatesite', true);
                $scope.cancel();
            }).finally(function() {
                modal.dismiss();
            });
        }, function(error) {
            modal.dismiss();
            $mmLoginHelper.treatUserTokenError(siteurl, error);
        });
    };
}]);

angular.module('mm.core.login')
.controller('mmLoginSiteCtrl', ["$scope", "$state", "$mmSitesManager", "$mmUtil", "$ionicHistory", "$mmApp", "$ionicModal", "$ionicPopup", "$mmLoginHelper", "$q", function($scope, $state, $mmSitesManager, $mmUtil, $ionicHistory, $mmApp, $ionicModal, $ionicPopup,
        $mmLoginHelper, $q) {
    $scope.siteurl = '';
    $scope.connect = function(url) {
        $mmApp.closeKeyboard();
        if (!url) {
            $mmUtil.showErrorModal('mm.login.siteurlrequired', true);
            return;
        }
        var modal = $mmUtil.showModalLoading(),
            sitedata = $mmSitesManager.getDemoSiteData(url);
        if (sitedata) {
            $mmSitesManager.getUserToken(sitedata.url, sitedata.username, sitedata.password).then(function(data) {
                $mmSitesManager.newSite(data.siteurl, data.token, data.privatetoken).then(function() {
                    $ionicHistory.nextViewOptions({disableBack: true});
                    return $mmLoginHelper.goToSiteInitialPage();
                }, function(error) {
                    $mmUtil.showErrorModal(error);
                }).finally(function() {
                    modal.dismiss();
                });
            }, function(error) {
                modal.dismiss();
                $mmLoginHelper.treatUserTokenError(sitedata.url, error);
            });
        } else {
            $mmSitesManager.checkSite(url).then(function(result) {
                if (result.warning) {
                    $mmUtil.showErrorModal(result.warning, true, 4000);
                }
                if ($mmLoginHelper.isSSOLoginNeeded(result.code)) {
                    $mmLoginHelper.confirmAndOpenBrowserForSSOLogin(
                                result.siteurl, result.code, result.service, result.config && result.config.launchurl);
                } else {
                    $state.go('mm_login.credentials', {siteurl: result.siteurl, siteconfig: result.config});
                }
            }, function(error) {
                showLoginIssue(url, error);
            }).finally(function() {
                modal.dismiss();
            });
        }
    };
    $mmUtil.getDocsUrl().then(function(docsurl) {
        $scope.docsurl = docsurl;
    });
    function showLoginIssue(siteurl, issue) {
        $scope.siteurl = siteurl;
        $scope.issue = issue;
        var popup = $ionicPopup.show({
            templateUrl:  'core/components/login/templates/login-issue.html',
            scope: $scope,
            cssClass: 'mm-nohead mm-bigpopup'
        });
        $scope.closePopup = function() {
            popup.close();
        };
        return popup.then(function() {
            return $q.reject();
        });
    }
    $ionicModal.fromTemplateUrl('core/components/login/templates/help-modal.html', {
        scope: $scope,
        animation: 'slide-in-up'
    }).then(function(helpModal) {
        $scope.showHelp = function() {
            helpModal.show();
        };
        $scope.closeHelp = function() {
            helpModal.hide();
        };
        $scope.$on('$destroy', function() {
            helpModal.remove();
        });
    });
}]);

angular.module('mm.core.login')
.controller('mmLoginSitePolicyCtrl', ["$scope", "$state", "$stateParams", "$mmSitesManager", "$mmSite", "$mmUtil", "$ionicHistory", "$mmLoginHelper", "$mmWS", "$q", "$sce", "$mmFS", function($scope, $state, $stateParams, $mmSitesManager, $mmSite, $mmUtil, $ionicHistory,
            $mmLoginHelper, $mmWS, $q, $sce, $mmFS) {
    var siteId = $stateParams.siteid || $mmSite.getId();
    if (!siteId || siteId != $mmSite.getId() || !$mmSite.wsAvailable('core_user_agree_site_policy')) {
        cancel();
        return;
    }
    function fetchSitePolicy() {
        return $mmWS.callAjax('auth_email_get_signup_settings', {}, {siteurl: $mmSite.getURL()}).then(function(settings) {
            if (!settings.sitepolicy) {
                return $q.reject();
            }
            $scope.sitePolicy = settings.sitepolicy;
            return $mmUtil.getMimeType($scope.sitePolicy).then(function(mimeType) {
                var extension = $mmFS.getExtension(mimeType, $scope.sitePolicy);
                $scope.showInline = extension == 'html' || extension == 'html';
                if ($scope.showInline) {
                    $scope.trustedSitePolicy = $sce.trustAsResourceUrl(settings.sitepolicy);
                }
            }).catch(function() {
                $scope.showInline = false;
            }).finally(function() {
                $scope.policyLoaded = true;
            });
        }).catch(function(error) {
            $mmUtil.showErrorModalDefault(error, 'Error getting site policy.');
            cancel();
        });
    }
    fetchSitePolicy();
    $scope.cancel = function() {
        cancel();
    };
    $scope.accept = function() {
        var modal = $mmUtil.showModalLoading('mm.core.sending', true);
        $mmLoginHelper.acceptSitePolicy(siteId).then(function() {
            return $mmSite.invalidateWsCache().catch(function() {
            }).then(function() {
                $ionicHistory.nextViewOptions({disableBack: true});
                return $mmLoginHelper.goToSiteInitialPage();
            });
        }).catch(function(error) {
            $mmUtil.showErrorModalDefault(error, 'Error accepting site policy.');
        }).finally(function() {
            modal.dismiss();
        });
    };
    function cancel() {
        $mmSitesManager.logout().finally(function() {
            $ionicHistory.nextViewOptions({
                disableAnimate: true,
                disableBack: true
            });
            $state.go('mm_login.sites');
        });
    }
}]);

angular.module('mm.core.login')
.controller('mmLoginSitesCtrl', ["$scope", "$mmSitesManager", "$log", "$translate", "$mmUtil", "$ionicHistory", "$mmText", "$mmLoginHelper", "$mmAddonManager", function($scope, $mmSitesManager, $log, $translate, $mmUtil, $ionicHistory, $mmText, $mmLoginHelper,
            $mmAddonManager) {
    $log = $log.getInstance('mmLoginSitesCtrl');
    var $mmaPushNotifications = $mmAddonManager.get('$mmaPushNotifications');
    $mmSitesManager.getSites().then(function(sites) {
        sites = sites.map(function(site) {
            site.siteurl = site.siteurl.replace(/^https?:\/\//, '');
            site.badge = 0;
            if ($mmaPushNotifications) {
                $mmaPushNotifications.getSiteCounter(site.id).then(function(number) {
                    site.badge = number;
                });
            }
            return site;
        });
        $scope.sites = sites.sort(function(a, b) {
            var compareA = a.siteurl.toLowerCase(),
                compareB = b.siteurl.toLowerCase(),
                compare = compareA.localeCompare(compareB);
            if (compare !== 0) {
                return compare;
            }
            compareA = a.fullname.toLowerCase().trim();
            compareB = b.fullname.toLowerCase().trim();
            return compareA.localeCompare(compareB);
        });
        $scope.data = {
            hasSites: sites.length > 0,
            showDelete: false
        };
    });
    $scope.toggleDelete = function() {
        $scope.data.showDelete = !$scope.data.showDelete;
    };
    $scope.onItemDelete = function(e, index) {
        e.stopPropagation();
        var site = $scope.sites[index],
            sitename = site.sitename;
        $mmText.formatText(sitename).then(function(sitename) {
            $mmUtil.showConfirm($translate.instant('mm.login.confirmdeletesite', {sitename: sitename})).then(function() {
                $mmSitesManager.deleteSite(site.id).then(function() {
                    $scope.sites.splice(index, 1);
                    $scope.data.showDelete = false;
                    $mmSitesManager.hasNoSites().then(function() {
                        $ionicHistory.nextViewOptions({disableBack: true});
                        $mmLoginHelper.goToAddSite();
                    });
                }, function() {
                    $log.error('Delete site failed');
                    $mmUtil.showErrorModal('mm.login.errordeletesite', true);
                });
            });
        });
    };
    $scope.login = function(siteId) {
        var modal = $mmUtil.showModalLoading();
        $mmSitesManager.loadSite(siteId).then(function() {
            if (!$mmLoginHelper.isSiteLoggedOut()) {
                $ionicHistory.nextViewOptions({disableBack: true});
                return $mmLoginHelper.goToSiteInitialPage();
            }
        }, function(error) {
            $log.error('Error loading site ' + siteId);
            error = error || 'Error loading site.';
            $mmUtil.showErrorModal(error);
        }).finally(function() {
            modal.dismiss();
        });
    };
    $scope.add = function() {
        $mmLoginHelper.goToAddSite();
    };
}]);

angular.module('mm.core.login')
.constant('mmLoginSSOCode', 2)
.constant('mmLoginSSOInAppCode', 3)
.constant('mmLoginLaunchSiteURL', 'mmLoginLaunchSiteURL')
.constant('mmLoginLaunchPassport', 'mmLoginLaunchPassport')
.constant('mmLoginLaunchData', 'mmLoginLaunchData')
.factory('$mmLoginHelper', ["$q", "$log", "$mmConfig", "mmLoginSSOCode", "mmLoginSSOInAppCode", "mmLoginLaunchData", "$mmEvents", "md5", "$mmSite", "$mmSitesManager", "$mmLang", "$mmUtil", "$state", "$mmAddonManager", "$translate", "mmCoreConfigConstants", "mmCoreEventSessionExpired", "mmUserProfileState", "$mmCourses", function($q, $log, $mmConfig, mmLoginSSOCode, mmLoginSSOInAppCode, mmLoginLaunchData, $mmEvents,
            md5, $mmSite, $mmSitesManager, $mmLang, $mmUtil, $state, $mmAddonManager, $translate, mmCoreConfigConstants,
            mmCoreEventSessionExpired, mmUserProfileState, $mmCourses) {
    $log = $log.getInstance('$mmLoginHelper');
    var self = {};
        self.acceptSitePolicy = function(siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.write('core_user_agree_site_policy', {}).then(function(result) {
                if (!result.status) {
                    if (result.warnings && result.warnings.length) {
                        return $q.reject(result.warnings[0].message);
                    } else {
                        return $q.reject();
                    }
                }
            });
        });
    };
        self.confirmAndOpenBrowserForSSOLogin = function(siteurl, typeOfLogin, service, launchUrl) {
        var showConfirmation = self.shouldShowSSOConfirm(typeOfLogin),
            promise = showConfirmation ? $mmUtil.showConfirm($translate('mm.login.logininsiterequired')) : $q.when();
        promise.then(function() {
            self.openBrowserForSSOLogin(siteurl, typeOfLogin, service, launchUrl);
        });
    };
        self.formatProfileFieldsForSignup = function(profileFields) {
        var categories = {};
        angular.forEach(profileFields, function(field) {
            if (!field.signup) {
                return;
            }
            if (!categories[field.categoryid]) {
                categories[field.categoryid] = {
                    id: field.categoryid,
                    name: field.categoryname,
                    fields: []
                };
            }
            categories[field.categoryid].fields.push(field);
        });
        return categories;
    };
        self.getErrorMessages = function(requiredMsg, emailMsg, patternMsg, urlMsg, minlengthMsg, maxlengthMsg, minMsg, maxMsg) {
        var errors = {};
        if (requiredMsg) {
            errors.required = $translate.instant(requiredMsg);
        }
        if (emailMsg) {
            errors.email = $translate.instant(emailMsg);
        }
        if (patternMsg) {
            errors.pattern = $translate.instant(patternMsg);
        }
        if (urlMsg) {
            errors.url = $translate.instant(urlMsg);
        }
        if (minlengthMsg) {
            errors.minlength = $translate.instant(minlengthMsg);
        }
        if (maxlengthMsg) {
            errors.maxlength = $translate.instant(maxlengthMsg);
        }
        if (minMsg) {
            errors.min = $translate.instant(minMsg);
        }
        if (maxMsg) {
            errors.max = $translate.instant(maxMsg);
        }
        return errors;
    };
        self.goToAddSite = function() {
        if (mmCoreConfigConstants.siteurl) {
            return $state.go('mm_login.credentials', {siteurl: mmCoreConfigConstants.siteurl});
        } else {
            return $state.go('mm_login.site');
        }
    };
        self.goToSiteInitialPage = function() {
        var myCoursesDisabled = $mmCourses.isMyCoursesDisabledInSite();
        if (myCoursesDisabled || ($mmSite.getInfo() && $mmSite.getInfo().userhomepage === 0)) {
            var $mmaFrontpage = $mmAddonManager.get('$mmaFrontpage');
            if ($mmaFrontpage && !$mmaFrontpage.isDisabledInSite()) {
                return $mmaFrontpage.isFrontpageAvailable().then(function() {
                    return $state.go('site.frontpage');
                }).catch(function() {
                    if (!myCoursesDisabled) {
                        return $state.go('site.mm_courses');
                    }
                    return $state.go(mmUserProfileState, {userid: $mmSite.getUserId()});
                });
            }
        }
        if (!myCoursesDisabled) {
            return $state.go('site.mm_courses');
        }
        return $state.go(mmUserProfileState, {userid: $mmSite.getUserId()});
    };
        self.isEmailSignupDisabled = function(config) {
        var disabledFeatures = config && config.tool_mobile_disabledfeatures;
        if (!disabledFeatures) {
            return false;
        }
        var regEx = new RegExp('(,|^)\\$mmLoginEmailSignup(,|$)', 'g');
        return !!disabledFeatures.match(regEx);
    };
        self.isFixedUrlSet = function() {
        return !!mmCoreConfigConstants.siteurl;
    };
        self.isSiteLoggedOut = function(stateName, stateParams) {
        if ($mmSite.isLoggedOut()) {
            $mmEvents.trigger(mmCoreEventSessionExpired, {
                siteid: $mmSite.getId(),
                statename: stateName,
                stateparams: stateParams
            });
            return true;
        }
        return false;
    };
        self.isSSOEmbeddedBrowser = function(code) {
        return code == mmLoginSSOInAppCode;
    };
        self.isSSOLoginNeeded = function(code) {
        return code == mmLoginSSOCode || code == mmLoginSSOInAppCode;
    };
        self.openBrowserForSSOLogin = function(siteurl, typeOfLogin, service, launchUrl, stateName, stateParams) {
        var loginUrl = self.prepareForSSOLogin(siteurl, service, launchUrl, stateName, stateParams);
        if (self.isSSOEmbeddedBrowser(typeOfLogin)) {
            var options = {
                clearsessioncache: 'yes',
                closebuttoncaption: $translate.instant('mm.login.cancel'),
            };
            $mmUtil.openInApp(loginUrl, options);
        } else {
            $mmUtil.openInBrowser(loginUrl);
            if (navigator.app) {
                navigator.app.exitApp();
            }
        }
    };
        self.prepareForSSOLogin = function(siteUrl, service, launchUrl, stateName, stateParams) {
        service = service || mmCoreConfigConstants.wsextservice;
        launchUrl = launchUrl || siteUrl + '/local/mobile/launch.php';
        var passport = Math.random() * 1000,
            loginUrl = launchUrl + '?service=' + service;
        loginUrl += "&passport=" + passport;
        loginUrl += "&urlscheme=" + mmCoreConfigConstants.customurlscheme;
        $mmConfig.set(mmLoginLaunchData, {
            siteurl: siteUrl,
            passport: passport,
            statename: stateName || '',
            stateparams: stateParams || {}
        });
        return loginUrl;
    };
        self.shouldShowSSOConfirm = function(typeOfLogin) {
        return !self.isSSOEmbeddedBrowser(typeOfLogin) &&
                    (!mmCoreConfigConstants.skipssoconfirmation || mmCoreConfigConstants.skipssoconfirmation === 'false');
    };
        self.validateBrowserSSOLogin = function(url) {
        var params = url.split(":::");
        return $mmConfig.get(mmLoginLaunchData).then(function(data) {
            var launchSiteURL = data.siteurl,
                passport = data.passport;
            $mmConfig.delete(mmLoginLaunchData);
            var signature = md5.createHash(launchSiteURL + passport);
            if (signature != params[0]) {
                if (launchSiteURL.indexOf("https://") != -1) {
                    launchSiteURL = launchSiteURL.replace("https://", "http://");
                } else {
                    launchSiteURL = launchSiteURL.replace("http://", "https://");
                }
                signature = md5.createHash(launchSiteURL + passport);
            }
            if (signature == params[0]) {
                $log.debug('Signature validated');
                return {
                    siteurl: launchSiteURL,
                    token: params[1],
                    privateToken: params[2],
                    statename: data.statename,
                    stateparams: data.stateparams
                };
            } else {
                $log.debug('Inalid signature in the URL request yours: ' + params[0] + ' mine: '
                                + signature + ' for passport ' + passport);
                return $mmLang.translateAndReject('mm.core.unexpectederror');
            }
        });
    };
        self.handleSSOLoginAuthentication = function(siteurl, token, privateToken) {
        if ($mmSite.isLoggedIn()) {
            var info = $mmSite.getInfo();
            if (typeof info != 'undefined' && typeof info.username != 'undefined') {
                return $mmSitesManager.updateSiteToken(info.siteurl, info.username, token, privateToken).then(function() {
                    $mmSitesManager.updateSiteInfoByUrl(info.siteurl, info.username);
                }).catch(function() {
                    return $mmLang.translateAndReject('mm.login.errorupdatesite');
                });
            }
            return $mmLang.translateAndReject('mm.login.errorupdatesite');
        } else {
            return $mmSitesManager.newSite(siteurl, token, privateToken);
        }
    };
        self.treatUserTokenError = function(siteurl, error) {
        if (typeof error == 'string') {
            $mmUtil.showErrorModal(error);
        } else if (error.errorcode == 'forcepasswordchangenotice') {
            self.openChangePassword(siteurl, error.error);
        } else {
            $mmUtil.showErrorModal(error.error);
        }
    };
        self.openChangePassword = function(siteurl, error) {
        return $mmUtil.showModal('mm.core.notice', error, 3000).then(function() {
            var changepasswordurl = siteurl + '/login/change_password.php';
            $mmUtil.openInApp(changepasswordurl);
        });
    };
    return self;
}]);

angular.module('mm.core.question')
.directive('mmQuestionBehaviour', ["$compile", function($compile) {
    return {
        restrict: 'A',
        link: function(scope, element) {
            if (scope.directive) {
                element[0].removeAttribute('mm-question-behaviour');
                element[0].setAttribute(scope.directive, '');
                $compile(element)(scope);
            }
        }
    };
}]);

angular.module('mm.core.question')
.directive('mmQuestion', ["$log", "$compile", "$mmQuestionDelegate", "$mmQuestionHelper", "$mmQuestionBehaviourDelegate", "$mmUtil", "$translate", "$q", "$mmQuestion", function($log, $compile, $mmQuestionDelegate, $mmQuestionHelper, $mmQuestionBehaviourDelegate, $mmUtil,
            $translate, $q, $mmQuestion) {
    $log = $log.getInstance('mmQuestion');
    return {
        restrict: 'E',
        templateUrl: 'core/components/question/templates/question.html',
        scope: {
            question: '=',
            component: '=?',
            componentId: '=?',
            attemptId: '=?',
            abort: '&',
            buttonClicked: '&?',
            offlineEnabled: '@?',
            scrollHandle: '@?'
        },
        link: function(scope, element) {
            var question = scope.question,
                component = scope.component,
                attemptId = scope.attemptId,
                questionContainer = element[0].querySelector('.mm-question-container'),
                behaviour,
                promise,
                offline = scope.offlineEnabled && scope.offlineEnabled !== '0' && scope.offlineEnabled !== 'false';
            if (question && questionContainer) {
                var directive = $mmQuestionDelegate.getDirectiveForQuestion(question);
                if (directive) {
                    $mmQuestionHelper.extractQuestionScripts(question);
                    behaviour = $mmQuestionDelegate.getBehaviourForQuestion(question, question.preferredBehaviour);
                    if (!$mmQuestionBehaviourDelegate.isBehaviourSupported(behaviour)) {
                        $log.warn('Aborting question because the behaviour is not supported.', question.name);
                        $mmQuestionHelper.showDirectiveError(scope,
                                $translate.instant('mma.mod_quiz.errorbehaviournotsupported') + ' ' + behaviour);
                        return;
                    }
                    scope.seqCheck = $mmQuestionHelper.getQuestionSequenceCheckFromHtml(question.html);
                    if (!scope.seqCheck) {
                        $log.warn('Aborting question because couldn\'t retrieve sequence check.', question.name);
                        $mmQuestionHelper.showDirectiveError(scope);
                        return;
                    }
                    if (offline) {
                        promise = $mmQuestion.getQuestionAnswers(component, attemptId, question.slot).then(function(answers) {
                            question.localAnswers = $mmQuestion.convertAnswersArrayToObject(answers, true);
                        }).catch(function() {
                            question.localAnswers = {};
                        });
                    } else {
                        question.localAnswers = {};
                        promise = $q.when();
                    }
                    promise.then(function() {
                        scope.behaviourDirectives = $mmQuestionBehaviourDelegate.handleQuestion(
                                        question, question.preferredBehaviour);
                        $mmQuestionHelper.extractQbehaviourRedoButton(question);
                        question.html = $mmUtil.removeElementFromHtml(question.html, '.im-controls');
                        question.validationError = $mmQuestionHelper.getValidationErrorFromHtml(question.html);
                        $mmQuestionHelper.loadLocalAnswersInHtml(question);
                        $mmQuestionHelper.extractQuestionFeedback(question);
                        $mmQuestionHelper.extractQuestionComment(question);
                        questionContainer.setAttribute(directive, '');
                        $compile(questionContainer)(scope);
                    });
                }
            }
        }
    };
}]);

angular.module('mm.core.question')
.provider('$mmQuestionBehaviourDelegate', function() {
    var handlers = {},
        self = {};
        self.registerHandler = function(name, behaviour, handler) {
        if (typeof handlers[behaviour] !== 'undefined') {
            console.log("$mmQuestionBehaviourDelegateProvider: Addon '" + name +
                            "' already registered as handler for '" + behaviour + "'");
            return false;
        }
        console.log("$mmQuestionBehaviourDelegateProvider: Registered handler '" + name + "' for behaviour '" + behaviour + "'");
        handlers[behaviour] = {
            addon: name,
            instance: undefined,
            handler: handler
        };
    };
    self.$get = ["$log", "$q", "$mmUtil", "$mmSite", "$mmQuestionDelegate", function($log, $q, $mmUtil, $mmSite, $mmQuestionDelegate) {
        $log = $log.getInstance('$mmQuestionBehaviourDelegate');
        var enabledHandlers = {},
            self = {},
            lastUpdateHandlersStart;
                self.determineQuestionState = function(behaviour, component, attemptId, question, siteId) {
            behaviour = $mmQuestionDelegate.getBehaviourForQuestion(question, behaviour);
            var handler = enabledHandlers[behaviour];
            if (typeof handler != 'undefined' && handler.determineQuestionState) {
                return $q.when(handler.determineQuestionState(component, attemptId, question, siteId));
            }
            return $q.when(false);
        };
                self.handleQuestion = function(question, behaviour) {
            behaviour = $mmQuestionDelegate.getBehaviourForQuestion(question, behaviour);
            if (typeof enabledHandlers[behaviour] != 'undefined') {
                return enabledHandlers[behaviour].handleQuestion(question);
            }
        };
                self.isBehaviourSupported = function(behaviour) {
            return typeof enabledHandlers[behaviour] != 'undefined';
        };
                self.isLastUpdateCall = function(time) {
            if (!lastUpdateHandlersStart) {
                return true;
            }
            return time == lastUpdateHandlersStart;
        };
                self.updateQuestionBehaviourHandler = function(behaviour, handlerInfo, time) {
            var promise,
                siteId = $mmSite.getId();
            if (typeof handlerInfo.instance === 'undefined') {
                handlerInfo.instance = $mmUtil.resolveObject(handlerInfo.handler, true);
            }
            if (!$mmSite.isLoggedIn()) {
                promise = $q.reject();
            } else {
                promise = $q.when(handlerInfo.instance.isEnabled());
            }
            return promise.catch(function() {
                return false;
            }).then(function(enabled) {
                if (self.isLastUpdateCall(time) && $mmSite.isLoggedIn() && $mmSite.getId() === siteId) {
                    if (enabled) {
                        enabledHandlers[behaviour] = handlerInfo.instance;
                    } else {
                        delete enabledHandlers[behaviour];
                    }
                }
            });
        };
                self.updateQuestionBehaviourHandlers = function() {
            var promises = [],
                now = new Date().getTime();
            $log.debug('Updating question behaviour handlers for current site.');
            lastUpdateHandlersStart = now;
            angular.forEach(handlers, function(handlerInfo, behaviour) {
                promises.push(self.updateQuestionBehaviourHandler(behaviour, handlerInfo, now));
            });
            return $q.all(promises).then(function() {
                return true;
            }, function() {
                return true;
            });
        };
        return self;
    }];
    return self;
});

angular.module('mm.core.question')
.provider('$mmQuestionDelegate', function() {
    var handlers = {},
        self = {};
        self.registerHandler = function(name, questionType, handler) {
        if (typeof handlers[questionType] !== 'undefined') {
            console.log("$mmQuestionDelegateProvider: Addon '" + name + "' already registered as handler for '" + questionType + "'");
            return false;
        }
        console.log("$mmQuestionDelegateProvider: Registered handler '" + name + "' for question type '" + questionType + "'");
        handlers[questionType] = {
            addon: name,
            instance: undefined,
            handler: handler
        };
    };
    self.$get = ["$log", "$q", "$mmUtil", "$mmSite", function($log, $q, $mmUtil, $mmSite) {
        $log = $log.getInstance('$mmQuestionDelegate');
        var enabledHandlers = {},
            self = {},
            lastUpdateHandlersStart;
                self.getBehaviourForQuestion = function(question, behaviour) {
            var type = 'qtype_' + question.type;
            if (typeof enabledHandlers[type] != 'undefined' && enabledHandlers[type].getBehaviour) {
                var questionBehaviour = enabledHandlers[type].getBehaviour(question, behaviour);
                if (questionBehaviour) {
                    return questionBehaviour;
                }
            }
            return behaviour;
        };
                self.getDirectiveForQuestion = function(question) {
            var type = 'qtype_' + question.type;
            if (typeof enabledHandlers[type] != 'undefined') {
                return enabledHandlers[type].getDirectiveName(question);
            }
        };
                self.getPreventSubmitMessage = function(question) {
            var type = 'qtype_' + question.type,
                handler = enabledHandlers[type];
            if (typeof handler != 'undefined' && handler.getPreventSubmitMessage) {
                return handler.getPreventSubmitMessage(question);
            }
        };
                self.isCompleteResponse = function(question, answers) {
            var type = 'qtype_' + question.type;
            if (typeof enabledHandlers[type] != 'undefined') {
                if (enabledHandlers[type].isCompleteResponse) {
                    return enabledHandlers[type].isCompleteResponse(question, answers);
                }
            }
            return -1;
        };
                self.isGradableResponse = function(question, answers) {
            var type = 'qtype_' + question.type;
            if (typeof enabledHandlers[type] != 'undefined') {
                if (enabledHandlers[type].isGradableResponse) {
                    return enabledHandlers[type].isGradableResponse(question, answers);
                }
            }
            return -1;
        };
                self.isLastUpdateCall = function(time) {
            if (!lastUpdateHandlersStart) {
                return true;
            }
            return time == lastUpdateHandlersStart;
        };
                self.isSameResponse = function(question, prevAnswers, newAnswers) {
            var type = 'qtype_' + question.type;
            if (typeof enabledHandlers[type] != 'undefined') {
                if (enabledHandlers[type].isSameResponse) {
                    return enabledHandlers[type].isSameResponse(question, prevAnswers, newAnswers);
                }
            }
            return false;
        };
                self.isQuestionSupported = function(type) {
            return typeof enabledHandlers['qtype_' + type] != 'undefined';
        };
                self.updateQuestionHandler = function(questionType, handlerInfo, time) {
            var promise,
                siteId = $mmSite.getId();
            if (typeof handlerInfo.instance === 'undefined') {
                handlerInfo.instance = $mmUtil.resolveObject(handlerInfo.handler, true);
            }
            if (!$mmSite.isLoggedIn()) {
                promise = $q.reject();
            } else {
                promise = $q.when(handlerInfo.instance.isEnabled());
            }
            return promise.catch(function() {
                return false;
            }).then(function(enabled) {
                if (self.isLastUpdateCall(time) && $mmSite.isLoggedIn() && $mmSite.getId() === siteId) {
                    if (enabled) {
                        enabledHandlers[questionType] = handlerInfo.instance;
                    } else {
                        delete enabledHandlers[questionType];
                    }
                }
            });
        };
                self.updateQuestionHandlers = function() {
            var promises = [],
                now = new Date().getTime();
            $log.debug('Updating question handlers for current site.');
            lastUpdateHandlersStart = now;
            angular.forEach(handlers, function(handlerInfo, questionType) {
                promises.push(self.updateQuestionHandler(questionType, handlerInfo, now));
            });
            return $q.all(promises).then(function() {
                return true;
            }, function() {
                return true;
            });
        };
                self.validateSequenceCheck = function(question, offlineSequenceCheck) {
            var type = 'qtype_' + question.type;
            if (typeof enabledHandlers[type] != 'undefined') {
                if (enabledHandlers[type].validateSequenceCheck) {
                    return enabledHandlers[type].validateSequenceCheck(question, offlineSequenceCheck);
                } else {
                    return question.sequencecheck == offlineSequenceCheck;
                }
            }
            return false;
        };
        return self;
    }];
    return self;
});

angular.module('mm.core.question')
.factory('$mmQuestionHelper', ["$mmUtil", "$mmText", "$ionicModal", "mmQuestionComponent", "$mmSitesManager", "$mmFilepool", "$q", "$mmQuestion", "$mmSite", function($mmUtil, $mmText, $ionicModal, mmQuestionComponent, $mmSitesManager, $mmFilepool, $q,
            $mmQuestion, $mmSite) {
    var self = {},
        lastErrorShown = 0;
        function addBehaviourButton(question, button) {
        if (!button || !question) {
            return;
        }
        if (!question.behaviourButtons) {
            question.behaviourButtons = [];
        }
        question.behaviourButtons.push({
            id: button.id,
            name: button.name,
            value: button.value,
            disabled: button.disabled
        });
    }
        self.directiveInit = function(scope, log) {
        var question = scope.question,
            questionEl;
        if (!question) {
            log.warn('Aborting because of no question received.');
            return self.showDirectiveError(scope);
        }
        questionEl = angular.element(question.html);
        question.text = $mmUtil.getContentsOfElement(questionEl, '.qtext');
        if (typeof question.text == 'undefined') {
            log.warn('Aborting because of an error parsing question.', question.name);
            return self.showDirectiveError(scope);
        }
        return questionEl;
    };
        self.extractQbehaviourButtons = function(question, selector) {
        selector = selector || '.im-controls input[type="submit"]';
        var div = document.createElement('div'),
            buttons;
        div.innerHTML = question.html;
        buttons = div.querySelectorAll(selector);
        angular.forEach(buttons, function(button) {
            addBehaviourButton(question, button);
        });
        question.html = div.innerHTML;
    };
        self.extractQbehaviourCBM = function(question) {
        var div = document.createElement('div'),
            labels;
        div.innerHTML = question.html;
        labels = div.querySelectorAll('.im-controls .certaintychoices label[for*="certainty"]');
        question.behaviourCertaintyOptions = [];
        angular.forEach(labels, function(label) {
            var input = label.querySelector('input[type="radio"]');
            if (input) {
                question.behaviourCertaintyOptions.push({
                    id: input.id,
                    name: input.name,
                    value: input.value,
                    text: $mmText.cleanTags(label.innerHTML),
                    disabled: input.disabled
                });
                if (input.checked) {
                    question.behaviourCertaintySelected = input.value;
                }
            }
        });
        if (question.localAnswers && typeof question.localAnswers['-certainty'] != 'undefined') {
            question.behaviourCertaintySelected = question.localAnswers['-certainty'];
        }
        return labels && labels.length;
    };
        self.extractQbehaviourRedoButton = function(question) {
        var div = document.createElement('div'),
            redoSelector = 'input[type="submit"][name*=redoslot], input[type="submit"][name*=tryagain]';
        if (!searchButton('html', '.outcome ' + redoSelector)) {
            if (question.feedbackHtml) {
                if (searchButton('feedbackHtml', redoSelector)) {
                    return;
                }
            }
            if (question.infoHtml) {
                searchButton('infoHtml', redoSelector);
            }
        }
        function searchButton(htmlProperty, selector) {
            var button;
            div.innerHTML = question[htmlProperty];
            button = div.querySelector(selector);
            if (button) {
                addBehaviourButton(question, button);
                angular.element(button).remove();
                question[htmlProperty] = div.innerHTML;
                return true;
            }
            return false;
        }
    };
        self.extractQbehaviourSeenInput = function(question) {
        var div = document.createElement('div'),
            seenInput;
        div.innerHTML = question.html;
        seenInput = div.querySelector('input[type="hidden"][name*=seen]');
        if (seenInput) {
            question.behaviourSeenInput = {
                name: seenInput.name,
                value: seenInput.value
            };
            angular.element(seenInput).remove();
            question.html = div.innerHTML;
            return true;
        }
        return false;
    };
        self.extractQuestionComment = function(question) {
        extractQuestionLastElementNotInContent(question, '.comment', 'commentHtml');
    };
        self.extractQuestionFeedback = function(question) {
        extractQuestionLastElementNotInContent(question, '.outcome', 'feedbackHtml');
    };
        self.extractQuestionInfoBox = function(question, selector) {
        extractQuestionLastElementNotInContent(question, selector, 'infoHtml');
    };
        function extractQuestionLastElementNotInContent(question, selector, attrName) {
        var div = document.createElement('div'),
            matches,
            last,
            position;
        div.innerHTML = question.html;
        matches = div.querySelectorAll(selector);
        position = matches.length -1;
        last = matches[position];
        while (last) {
            if (!$mmUtil.closest(last, '.formulation')) {
                question[attrName] = last.innerHTML;
                angular.element(last).remove();
                question.html = div.innerHTML;
                return;
            }
            position--;
            last = matches[position];
        }
    }
        self.extractQuestionScripts = function(question) {
        var matches;
        question.scriptsCode = '';
        question.initObjects = [];
        if (question.html) {
            matches = question.html.match(/<script[^>]*>[\s\S]*?<\/script>/mg);
            angular.forEach(matches, function(match) {
                question.scriptsCode += match;
                question.html = question.html.replace(match, '');
                var initMatches = match.match(new RegExp('M\.qtype_' + question.type + '\.init_question\\(.*?}\\);', 'mg'));
                if (initMatches) {
                    var initMatch = initMatches.pop();
                    initMatch = initMatch.replace('M.qtype_' + question.type + '.init_question(', '');
                    initMatch = initMatch.substr(0, initMatch.length - 2);
                    try {
                        question.initObjects = JSON.parse(initMatch);
                    } catch(ex) {}
                }
            });
        }
    };
        self.getAllInputNamesFromHtml = function(html) {
        var form = document.createElement('form'),
            answers = {};
        form.innerHTML = html;
        angular.forEach(form.elements, function(element) {
            var name = element.name || '';
            if (!name || name.match(/_:flagged$/) || element.type == 'submit' || element.tagName == 'BUTTON') {
                return;
            }
            answers[$mmQuestion.removeQuestionPrefix(name)] = true;
        });
        return answers;
    };
        self.getAnswersFromForm = function(form) {
        if (!form || !form.elements) {
            return {};
        }
        var answers = {};
        angular.forEach(form.elements, function(element) {
            var name = element.name || '';
            if (!name || name.match(/_:flagged$/) || element.type == 'submit' || element.tagName == 'BUTTON') {
                return;
            }
            if (element.type == 'checkbox') {
                answers[name] = !!element.checked;
            } else if (element.type == 'radio') {
                if (element.checked) {
                    answers[name] = element.value;
                }
            } else {
                answers[name] = element.value;
            }
        });
        return answers;
    };
        self.getQuestionAttachmentsFromHtml = function(html) {
        var el = angular.element('<div></div>'),
            anchors,
            attachments = [];
        el.html(html);
        el = el[0];
        $mmUtil.removeElement(el, 'div[id*=filemanager]');
        anchors = el.querySelectorAll('a');
        angular.forEach(anchors, function(anchor) {
            var content = anchor.innerHTML;
            if (anchor.href && content) {
                content = $mmText.cleanTags(content, true).trim();
                attachments.push({
                    filename: content,
                    fileurl: anchor.href
                });
            }
        });
        return attachments;
    };
        self.getQuestionSequenceCheckFromHtml = function(html) {
        var el,
            input;
        if (html) {
            el = angular.element(html)[0];
            input = el.querySelector('input[name*=sequencecheck]');
            if (input && typeof input.name != 'undefined' && typeof input.value != 'undefined') {
                return {
                    name: input.name,
                    value: input.value
                };
            }
        }
    };
        self.getQuestionStateClass = function(name) {
        var state = $mmQuestion.getState(name);
        return state ? state.class : '';
    };
        self.getValidationErrorFromHtml = function(html) {
        return $mmUtil.getContentsOfElement(angular.element(html), '.validationerror');
    };
        self.hasDraftFileUrls = function(html) {
        var url = $mmSite.getURL();
        if (url.slice(-1) != '/') {
            url = url += '/';
        }
        url += 'draftfile.php';
        return html.indexOf(url) != -1;
    };
        self.inputTextDirective = function(scope, log) {
        var questionEl = self.directiveInit(scope, log);
        if (questionEl) {
            questionEl = questionEl[0] || questionEl;
            input = questionEl.querySelector('input[type="text"][name*=answer]');
            if (!input) {
                log.warn('Aborting because couldn\'t find input.', question.name);
                return self.showDirectiveError(scope);
            }
            scope.input = {
                id: input.id,
                name: input.name,
                value: input.value,
                readOnly: input.readOnly
            };
            if (input.className.indexOf('incorrect') >= 0) {
                scope.input.isCorrect = 0;
            } else if (input.className.indexOf('correct') >= 0) {
                scope.input.isCorrect = 1;
            }
        }
    };
        self.loadLocalAnswersInHtml = function(question) {
        var form = document.createElement('form');
        form.innerHTML = question.html;
        angular.forEach(form.elements, function(element) {
            var name = element.name || '';
            if (!name || name.match(/_:flagged$/) || element.type == 'submit' || element.tagName == 'BUTTON') {
                return;
            }
            name = $mmQuestion.removeQuestionPrefix(name);
            if (question.localAnswers && typeof question.localAnswers[name] != 'undefined') {
                var selected;
                if (element.tagName == 'TEXTAREA') {
                    element.innerHTML = question.localAnswers[name];
                } else if (element.tagName == 'SELECT') {
                    selected = element.querySelector('option[value="' + question.localAnswers[name] + '"]');
                    if (selected) {
                        selected.setAttribute('selected', 'selected');
                    }
                } else if (element.type == 'radio' || element.type == 'checkbox') {
                    if (element.value == question.localAnswers[name]) {
                        element.setAttribute('checked', 'checked');
                    }
                } else {
                    element.setAttribute('value', question.localAnswers[name]);
                }
            }
        });
        question.html = form.innerHTML;
    };
        self.matchingDirective = function(scope, log) {
        var questionEl = self.directiveInit(scope, log),
            question = scope.question,
            rows;
        if (questionEl) {
            questionEl = questionEl[0] || questionEl;
            rows = questionEl.querySelectorAll('tr');
            if (!rows || !rows.length) {
                log.warn('Aborting because couldn\'t find any row.', question.name);
                return self.showDirectiveError(scope);
            }
            question.rows = [];
            angular.forEach(rows, function(row) {
                var rowModel = {},
                    select,
                    options,
                    accessibilityLabel,
                    columns = row.querySelectorAll('td');
                if (!columns || columns.length < 2) {
                    log.warn('Aborting because couldn\'t find the right columns.', question.name);
                    return self.showDirectiveError(scope);
                }
                rowModel.text = columns[0].innerHTML;
                select = columns[1].querySelector('select');
                options = columns[1].querySelectorAll('option');
                if (!select || !options || !options.length) {
                    log.warn('Aborting because couldn\'t find select or options.', question.name);
                    return self.showDirectiveError(scope);
                }
                rowModel.id = select.id;
                rowModel.name = select.name;
                rowModel.disabled = select.disabled;
                rowModel.selected = false;
                rowModel.options = [];
                if (columns[1].className.indexOf('incorrect') >= 0) {
                    rowModel.isCorrect = 0;
                } else if (columns[1].className.indexOf('correct') >= 0) {
                    rowModel.isCorrect = 1;
                }
                angular.forEach(options, function(option) {
                    if (typeof option.value == 'undefined') {
                        log.warn('Aborting because couldn\'t find option value.', question.name);
                        return self.showDirectiveError(scope);
                    }
                    var opt = {
                        value: option.value,
                        label: option.innerHTML,
                        selected: option.selected
                    };
                    if (opt.selected) {
                        rowModel.selected = opt;
                    }
                    rowModel.options.push(opt);
                });
                accessibilityLabel = columns[1].querySelector('label.accesshide');
                rowModel.accessibilityLabel = accessibilityLabel.innerHTML;
                question.rows.push(rowModel);
            });
            question.loaded = true;
        }
    };
        self.multiChoiceDirective = function(scope, log) {
        var questionEl = self.directiveInit(scope, log),
            question = scope.question;
        scope.mcAnswers = {};
        if (questionEl) {
            questionEl = questionEl[0] || questionEl;
            question.prompt = $mmUtil.getContentsOfElement(questionEl, '.prompt');
            var options = questionEl.querySelectorAll('input[type="radio"]');
            if (!options || !options.length) {
                question.multi = true;
                options = questionEl.querySelectorAll('input[type="checkbox"]');
                if (!options || !options.length) {
                    log.warn('Aborting because of no radio and checkbox found.', question.name);
                    return self.showDirectiveError(scope);
                }
            }
            question.options = [];
            angular.forEach(options, function(element) {
                var option = {
                        id: element.id,
                        name: element.name,
                        value: element.value,
                        checked: element.checked,
                        disabled: element.disabled
                    },
                    label,
                    parent = element.parentNode,
                    feedback;
                label = questionEl.querySelector('label[for="' + option.id + '"]');
                if (label) {
                    option.text = label.innerHTML;
                    if (typeof option.name != 'undefined' && typeof option.value != 'undefined' &&
                                typeof option.text != 'undefined') {
                        if (element.checked) {
                            if (!question.multi) {
                                scope.mcAnswers[option.name] = option.value;
                            }
                            if (parent) {
                                if (parent && parent.className.indexOf('incorrect') >= 0) {
                                    option.isCorrect = 0;
                                } else if (parent && parent.className.indexOf('correct') >= 0) {
                                    option.isCorrect = 1;
                                }
                                feedback = parent.querySelector('.specificfeedback');
                                if (feedback) {
                                    option.feedback = feedback.innerHTML;
                                }
                            }
                        }
                        question.options.push(option);
                        return;
                    }
                }
                log.warn('Aborting because of an error parsing options.', question.name, option.name);
                return self.showDirectiveError(scope);
            });
        }
    };
        self.prefetchQuestionFiles = function(question, siteId, component, componentId) {
        var urls = $mmUtil.extractDownloadableFilesFromHtml(question.html);
        if (!component) {
            component = mmQuestionComponent;
            componentId = question.id;
        }
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var promises = [];
            angular.forEach(urls, function(url) {
                if (!site.canDownloadFiles() && $mmUtil.isPluginFileUrl(url)) {
                    return;
                }
                if (url.indexOf('theme/image.php') > -1 && url.indexOf('flagged') > -1) {
                    return;
                }
                promises.push($mmFilepool.addToQueueByUrl(siteId, url, component, componentId));
            });
            return $q.all(promises);
        });
    };
        self.replaceCorrectnessClasses = function(element) {
        $mmUtil.replaceClassesInElement(element, {
            correct: 'mm-question-answer-correct',
            incorrect: 'mm-question-answer-incorrect'
        });
    };
        self.replaceFeedbackClasses = function(element) {
        $mmUtil.replaceClassesInElement(element, {
            outcome: 'mm-question-feedback-container mm-question-feedback-padding',
            specificfeedback: 'mm-question-feedback-container mm-question-feedback-inline'
        });
    };
        self.showDirectiveError = function(scope, error) {
        error = error || 'Error processing the question. This could be caused by custom modifications in your site.';
        var now = new Date().getTime();
        if (now - lastErrorShown > 500) {
            lastErrorShown = now;
            $mmUtil.showErrorModal(error);
        }
        scope.abort();
    };
        self.treatCorrectnessIcons = function(scope, element) {
        element = element[0] || element;
        var icons = element.querySelectorAll('.questioncorrectnessicon');
        angular.forEach(icons, function(icon) {
            var parent;
            if (icon.src && icon.src.indexOf('incorrect') > -1) {
                icon.src = 'img/icons/grade_incorrect.svg';
            } else if (icon.src && icon.src.indexOf('correct') > -1) {
                icon.src = 'img/icons/grade_correct.svg';
            }
            parent = icon.parentNode;
            if (!parent) {
                return;
            }
            if (!parent.querySelector('.feedbackspan.accesshide')) {
                return;
            }
            icon.setAttribute('ng-click', 'questionCorrectnessIconClicked($event)');
        });
        scope.questionCorrectnessIconClicked = function(event) {
            var parent = event.target.parentNode,
                feedback;
            if (parent) {
                feedback = parent.querySelector('.feedbackspan.accesshide');
                if (feedback && feedback.innerHTML) {
                    scope.currentFeedback = feedback.innerHTML;
                    scope.feedbackModal.show();
                }
            }
        };
        $ionicModal.fromTemplateUrl('core/components/question/templates/feedbackmodal.html', {
            scope: scope
        }).then(function(modal) {
            scope.feedbackModal = modal;
            scope.closeModal = function() {
                modal.hide();
            };
        });
    };
    return self;
}]);

angular.module('mm.core.question')
.constant('mmQuestionStore', 'questions')
.constant('mmQuestionAnswersStore', 'question_answers')
.config(["$mmSitesFactoryProvider", "mmQuestionStore", "mmQuestionAnswersStore", function($mmSitesFactoryProvider, mmQuestionStore, mmQuestionAnswersStore) {
    var stores = [
        {
            name: mmQuestionStore,
            keyPath: ['component', 'attemptid', 'slot'],
            indexes: [
                {
                    name: 'userid'
                },
                {
                    name: 'component'
                },
                {
                    name: 'componentId'
                },
                {
                    name: 'attemptid'
                },
                {
                    name: 'slot'
                },
                {
                    name: 'state'
                },
                {
                    name: 'componentAndAttempt',
                    keyPath: ['component', 'attemptid']
                },
                {
                    name: 'componentAndComponentId',
                    keyPath: ['component', 'componentId']
                }
            ]
        },
        {
            name: mmQuestionAnswersStore,
            keyPath: ['component', 'attemptid', 'name'],
            indexes: [
                {
                    name: 'userid'
                },
                {
                    name: 'component'
                },
                {
                    name: 'componentId'
                },
                {
                    name: 'attemptid'
                },
                {
                    name: 'name'
                },
                {
                    name: 'questionslot'
                },
                {
                    name: 'componentAndAttempt',
                    keyPath: ['component', 'attemptid']
                },
                {
                    name: 'componentAndComponentId',
                    keyPath: ['component', 'componentId']
                },
                {
                    name: 'componentAndAttemptAndQuestion',
                    keyPath: ['component', 'attemptid', 'questionslot']
                }
            ]
        }
    ];
    $mmSitesFactoryProvider.registerStores(stores);
}])
.factory('$mmQuestion', ["$log", "$mmSite", "$mmSitesManager", "$mmUtil", "$q", "$mmQuestionDelegate", "mmQuestionStore", "mmQuestionAnswersStore", function($log, $mmSite, $mmSitesManager, $mmUtil, $q, $mmQuestionDelegate, mmQuestionStore,
            mmQuestionAnswersStore) {
    $log = $log.getInstance('$mmQuestion');
    var self = {},
        questionPrefixRegex = /q\d+:(\d+)_/,
        states = {
            todo: {
                name: 'todo',
                class: 'mm-question-notyetanswered',
                status: 'notyetanswered',
                active: true,
                finished: false
            },
            invalid: {
                name: 'invalid',
                class: 'mm-question-invalidanswer',
                status: 'invalidanswer',
                active: true,
                finished: false
            },
            complete: {
                name: 'complete',
                class: 'mm-question-answersaved',
                status: 'answersaved',
                active: true,
                finished: false
            },
            needsgrading: {
                name: 'needsgrading',
                class: 'mm-question-requiresgrading',
                status: 'requiresgrading',
                active: false,
                finished: true
            },
            finished: {
                name: 'finished',
                class: 'mm-question-complete',
                status: 'complete',
                active: false,
                finished: true
            },
            gaveup: {
                name: 'gaveup',
                class: 'mm-question-notanswered',
                status: 'notanswered',
                active: false,
                finished: true
            },
            gradedwrong: {
                name: 'gradedwrong',
                class: 'mm-question-incorrect',
                status: 'incorrect',
                active: false,
                finished: true
            },
            gradedpartial: {
                name: 'gradedpartial',
                class: 'mm-question-partiallycorrect',
                status: 'partiallycorrect',
                active: false,
                finished: true
            },
            gradedright: {
                name: 'gradedright',
                class: 'mm-question-correct',
                status: 'correct',
                active: false,
                finished: true
            },
            mangrwrong: {
                name: 'mangrwrong',
                class: 'mm-question-incorrect',
                status: 'incorrect',
                active: false,
                finished: true
            },
            mangrpartial: {
                name: 'mangrpartial',
                class: 'mm-question-partiallycorrect',
                status: 'partiallycorrect',
                active: false,
                finished: true
            },
            mangrright: {
                name: 'mangrright',
                class: 'mm-question-correct',
                status: 'correct',
                active: false,
                finished: true
            },
            unknown: {
                name: 'unknown',
                class: 'mm-question-unknown',
                status: 'unknown',
                active: true,
                finished: false
            }
        };
        self.compareAllAnswers = function(prevAnswers, newAnswers) {
        var equal = true,
            keys = $mmUtil.mergeArraysWithoutDuplicates(Object.keys(prevAnswers), Object.keys(newAnswers));
        angular.forEach(keys, function(key) {
            if (!self.isExtraAnswer(key[0])) {
                if (!$mmUtil.sameAtKeyMissingIsBlank(prevAnswers, newAnswers, key)) {
                    equal = false;
                }
            }
        });
        return equal;
    };
        self.convertAnswersArrayToObject = function(answers, removePrefix) {
        var result = {};
        angular.forEach(answers, function(answer) {
            if (removePrefix) {
                var nameWithoutPrefix = self.removeQuestionPrefix(answer.name);
                result[nameWithoutPrefix] = answer.value;
            } else {
                result[answer.name] = answer.value;
            }
        });
        return result;
    };
        self.getAnswer = function(component, attemptId, name, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.getDb().get(mmQuestionAnswersStore, [component, attemptId, name]);
        });
    };
        self.getAttemptAnswers = function(component, attemptId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.getDb().whereEqual(mmQuestionAnswersStore, 'componentAndAttempt', [component, attemptId]);
        });
    };
        self.getAttemptQuestions = function(component, attemptId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.getDb().whereEqual(mmQuestionStore, 'componentAndAttempt', [component, attemptId]);
        });
    };
        self.getBasicAnswers = function(answers) {
        var result = {};
        angular.forEach(answers, function(value, name) {
            if (!self.isExtraAnswer(name)) {
                result[name] = value;
            }
        });
        return result;
    };
        self.getQuestion = function(component, attemptId, slot, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.getDb().get(mmQuestionStore, [component, attemptId, slot]);
        });
    };
        self.getQuestionAnswers = function(component, attemptId, slot, filter, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.getDb().whereEqual(mmQuestionAnswersStore, 'componentAndAttemptAndQuestion',
                        [component, attemptId, slot]).then(function(answers) {
                if (filter) {
                    var result = [];
                    angular.forEach(answers, function(answer) {
                        if (self.isExtraAnswer(answer.name)) {
                            result.push(answer);
                        }
                    });
                    return result;
                } else {
                    return answers;
                }
            });
        });
    };
        self.getQuestionSlotFromName = function(name) {
        if (name) {
            var match = name.match(questionPrefixRegex);
            if (match && match[1]) {
                return parseInt(match[1], 10);
            }
        }
        return -1;
    };
        self.getState = function(name) {
        return states[name];
    };
        self.isCompleteResponse = function(question, answers) {
        return $mmQuestionDelegate.isCompleteResponse(question, answers);
    };
        self.isExtraAnswer = function(name) {
        name = self.removeQuestionPrefix(name);
        return name[0] == '-' || name[0] == ':';
    };
        self.isGradableResponse = function(question, answers) {
        return $mmQuestionDelegate.isGradableResponse(question, answers);
    };
        self.isSameResponse = function(question, prevAnswers, newAnswers) {
        return $mmQuestionDelegate.isSameResponse(question, prevAnswers, newAnswers);
    };
        self.removeAttemptAnswers = function(component, attemptId, siteId) {
        siteId = siteId || $mmSite.getId();
        return self.getAttemptAnswers(component, attemptId, siteId).then(function(answers) {
            var promises = [];
            angular.forEach(answers, function(answer) {
                promises.push(self.removeAnswer(component, attemptId, answer.name, siteId));
            });
            return $q.all(promises);
        });
    };
        self.removeAttemptQuestions = function(component, attemptId, siteId) {
        siteId = siteId || $mmSite.getId();
        return self.getAttemptQuestions(component, attemptId, siteId).then(function(questions) {
            var promises = [];
            angular.forEach(questions, function(question) {
                promises.push(self.removeQuestion(component, attemptId, question.slot, siteId));
            });
            return $q.all(promises);
        });
    };
        self.removeAnswer = function(component, attemptId, name, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.getDb().remove(mmQuestionAnswersStore, [component, attemptId, name]);
        });
    };
        self.removeQuestion = function(component, attemptId, slot, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.getDb().remove(mmQuestionStore, [component, attemptId, slot]);
        });
    };
        self.removeQuestionAnswers = function(component, attemptId, slot, siteId) {
        return self.getQuestionAnswers(component, attemptId, slot, false, siteId).then(function(answers) {
            var promises = [];
            angular.forEach(answers, function(answer) {
                promises.push(self.removeAnswer(component, attemptId, answer.name, siteId));
            });
            return $q.all(promises);
        });
    };
        self.removeQuestionPrefix = function(name) {
        if (name) {
            return name.replace(questionPrefixRegex, '');
        }
        return '';
    };
        self.saveAnswers = function(component, componentId, attemptId, userId, answers, timemod, siteId) {
        siteId = siteId || $mmSite.getId();
        timemod = timemod || $mmUtil.timestamp();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var db = site.getDb(),
                promises = [];
            angular.forEach(answers, function(value, name) {
                var entry = {
                    component: component,
                    componentId: componentId,
                    attemptid: attemptId,
                    userid: userId,
                    questionslot: self.getQuestionSlotFromName(name),
                    name: name,
                    value: value,
                    timemodified: timemod
                };
                promises.push(db.insert(mmQuestionAnswersStore, entry));
            });
            return $q.all(promises);
        });
    };
        self.saveQuestion = function(component, componentId, attemptId, userId, question, state, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var entry = {
                component: component,
                componentId: componentId,
                attemptid: attemptId,
                userid: userId,
                number: question.number,
                slot: question.slot,
                state: state
            };
            return site.getDb().insert(mmQuestionStore, entry);
        });
    };
    return self;
}]);

angular.module('mm.core.settings')
.controller('mmSettingsAboutCtrl', ["$scope", "$translate", "$window", "$mmApp", "$ionicPlatform", "$mmLang", "$mmFS", "$mmLocalNotifications", "mmCoreConfigConstants", function($scope, $translate, $window, $mmApp, $ionicPlatform, $mmLang, $mmFS,
            $mmLocalNotifications, mmCoreConfigConstants) {
    $scope.versionname = mmCoreConfigConstants.versionname;
    $scope.appname = mmCoreConfigConstants.appname;
    $scope.versioncode = mmCoreConfigConstants.versioncode;
    $scope.privacyPolicy = mmCoreConfigConstants.privacypolicy;
    $scope.navigator = $window.navigator;
    if ($window.location && $window.location.href) {
        var url = $window.location.href;
        $scope.locationhref = url.substr(0, url.indexOf('#/site/'));
    }
    $scope.appready = $mmApp.isReady() ? 'mm.core.yes' : 'mm.core.no';
    $scope.devicetype = $ionicPlatform.isTablet() ? 'mm.core.tablet' : 'mm.core.phone';
    if (ionic.Platform.isAndroid()) {
        $scope.deviceos = 'mm.core.android';
    } else if (ionic.Platform.isIOS()) {
        $scope.deviceos = 'mm.core.ios';
    } else if (ionic.Platform.isWindowsPhone()) {
        $scope.deviceos = 'mm.core.windowsphone';
    } else {
        var matches = navigator.userAgent.match(/\(([^\)]*)\)/);
        if (matches && matches.length > 1) {
            $scope.deviceos = matches[1];
        } else {
            $scope.deviceos = 'mm.core.unknown';
        }
    }
    $mmLang.getCurrentLanguage().then(function(lang) {
        $scope.currentlanguage = lang;
    });
    $scope.networkstatus = $mmApp.isOnline() ? 'mm.core.online' : 'mm.core.offline';
    $scope.wificonnection = $mmApp.isNetworkAccessLimited() ? 'mm.core.no' : 'mm.core.yes';
    $scope.devicewebworkers = !!window.Worker && !!window.URL ? 'mm.core.yes' : 'mm.core.no';
    $scope.device = ionic.Platform.device();
    if ($mmFS.isAvailable()) {
        $mmFS.getBasePath().then(function(basepath) {
            $scope.filesystemroot = basepath;
            $scope.fsclickable = $mmFS.usesHTMLAPI();
        });
    }
    $scope.storagetype = $mmApp.getDB().getType();
    $scope.localnotifavailable = $mmLocalNotifications.isAvailable() ? 'mm.core.yes' : 'mm.core.no';
}]);

angular.module('mm.core.settings')
.controller('mmSettingsGeneralCtrl', ["$scope", "$mmLang", "$ionicHistory", "$mmEvents", "$mmConfig", "mmCoreEventLanguageChanged", "mmCoreSettingsReportInBackground", "mmCoreConfigConstants", "mmCoreSettingsRichTextEditor", "$mmUtil", function($scope, $mmLang, $ionicHistory, $mmEvents, $mmConfig, mmCoreEventLanguageChanged,
            mmCoreSettingsReportInBackground, mmCoreConfigConstants, mmCoreSettingsRichTextEditor,
            $mmUtil) {
    $scope.langs = mmCoreConfigConstants.languages;
    $mmLang.getCurrentLanguage().then(function(currentLanguage) {
        $scope.selectedLanguage = currentLanguage;
    });
    $scope.languageChanged = function(newLang) {
        $mmLang.changeCurrentLanguage(newLang).finally(function() {
            $ionicHistory.clearCache();
            $mmEvents.trigger(mmCoreEventLanguageChanged);
        });
    };
    $scope.rteSupported = $mmUtil.isRichTextEditorSupported();
    if ($scope.rteSupported) {
        $mmConfig.get(mmCoreSettingsRichTextEditor, true).then(function(richTextEditorEnabled) {
            $scope.richTextEditor = richTextEditorEnabled;
        });
        $scope.richTextEditorChanged = function(richTextEditor) {
            $mmConfig.set(mmCoreSettingsRichTextEditor, richTextEditor);
        };
    }
    if (localStorage && localStorage.getItem && localStorage.setItem) {
        $scope.showReport = true;
        $scope.reportInBackground = parseInt(localStorage.getItem(mmCoreSettingsReportInBackground), 10) === 1;
        $scope.reportChanged = function(inBackground) {
            localStorage.setItem(mmCoreSettingsReportInBackground, inBackground ? '1' : '0');
        };
    } else {
        $scope.showReport = false;
    }
}]);

angular.module('mm.core.settings')
.controller('mmSettingsListCtrl', ["$scope", "$mmSettingsDelegate", function($scope, $mmSettingsDelegate) {
    $scope.isIOS = ionic.Platform.isIOS();
    $scope.handlers = $mmSettingsDelegate.getHandlers();
    $scope.areHandlersLoaded = $mmSettingsDelegate.areHandlersLoaded;
}]);

angular.module('mm.core.settings')
.controller('mmSettingsSpaceUsageCtrl', ["$log", "$scope", "$mmSitesManager", "$mmFS", "$q", "$mmUtil", "$translate", "$mmText", "$mmFilepool", function($log, $scope, $mmSitesManager, $mmFS, $q, $mmUtil, $translate,
            $mmText, $mmFilepool) {
    $log = $log.getInstance('mmSettingsSpaceUsageCtrl');
    function calculateSizeUsage() {
        return $mmSitesManager.getSites().then(function(sites) {
            var promises = [];
            $scope.sites = sites;
            angular.forEach(sites, function(siteEntry) {
                var promise = $mmSitesManager.getSite(siteEntry.id).then(function(site) {
                    return site.getSpaceUsage().then(function(size) {
                        siteEntry.spaceusage = size;
                    });
                });
                promises.push(promise);
            });
            return $q.all(promises);
        });
    }
    function calculateTotalUsage() {
        var total = 0;
        angular.forEach($scope.sites, function(site) {
            if (site.spaceusage) {
                total += parseInt(site.spaceusage, 10);
            }
        });
        $scope.totalusage = total;
    }
    function calculateFreeSpace() {
        if ($mmFS.isAvailable()) {
            return $mmFS.calculateFreeSpace().then(function(freespace) {
                $scope.freespace = freespace;
            }, function() {
                $scope.freespace = 0;
            });
        } else {
            $scope.freespace = 0;
        }
    }
    function fetchData() {
        var promises = [];
        promises.push(calculateSizeUsage().then(calculateTotalUsage));
        promises.push($q.when(calculateFreeSpace()));
        return $q.all(promises);
    }
    fetchData().finally(function() {
        $scope.sizeLoaded = true;
    });
    $scope.refresh = function() {
        fetchData().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
    function updateSiteUsage(site, newUsage) {
        var oldUsage = site.spaceusage;
        site.spaceusage = newUsage;
        $scope.totalusage -= oldUsage - newUsage;
        $scope.freespace += oldUsage - newUsage;
    }
    $scope.deleteSiteFiles = function(siteData) {
        if (siteData) {
            var siteid = siteData.id,
                sitename = siteData.sitename;
            $mmText.formatText(sitename).then(function(sitename) {
                $translate('mm.settings.deletesitefilestitle').then(function(title) {
                    return $mmUtil.showConfirm($translate('mm.settings.deletesitefiles', {sitename: sitename}), title);
                }).then(function() {
                    return $mmSitesManager.getSite(siteid);
                }).then(function(site) {
                    return site.deleteFolder().then(function() {
                        $mmFilepool.clearAllPackagesStatus(siteid);
                        $mmFilepool.clearFilepool(siteid);
                        updateSiteUsage(siteData, 0);
                    }).catch(function(error) {
                        if (error && error.code === FileError.NOT_FOUND_ERR) {
                            $mmFilepool.clearAllPackagesStatus(siteid);
                            updateSiteUsage(siteData, 0);
                        } else {
                            $mmUtil.showErrorModal('mm.settings.errordeletesitefiles', true);
                            site.getSpaceUsage().then(function(size) {
                                updateSiteUsage(siteData, size);
                            });
                        }
                    });
                });
            });
        }
    };
}]);

angular.module('mm.core.settings')
.controller('mmSettingsSynchronizationCtrl', ["$log", "$scope", "$mmUtil", "$mmConfig", "$mmSettingsHelper", "mmCoreSettingsSyncOnlyOnWifi", function($log, $scope, $mmUtil, $mmConfig, $mmSettingsHelper,
            mmCoreSettingsSyncOnlyOnWifi) {
    $log = $log.getInstance('mmSettingsSynchronizationCtrl');
    $mmSettingsHelper.getSites().then(function(sites) {
        $scope.sites = sites;
        angular.forEach(sites, function(site) {
            if (site.synchronizing) {
                $mmSettingsHelper.getSiteSyncPromise(site.id).catch(errorSyncing);
            }
        });
    });
    $mmConfig.get(mmCoreSettingsSyncOnlyOnWifi, true).then(function(syncOnlyOnWifi) {
        $scope.syncOnlyOnWifi = syncOnlyOnWifi;
    });
    $scope.syncWifiChanged = function(syncOnlyOnWifi) {
        $mmConfig.set(mmCoreSettingsSyncOnlyOnWifi, syncOnlyOnWifi);
    };
    $scope.synchronize = function(siteId) {
        if ($scope.sites[siteId] && !$scope.sites[siteId].synchronizing) {
            $mmSettingsHelper.synchronizeSite($scope.syncOnlyOnWifi, siteId).catch(errorSyncing);
        }
    };
    function errorSyncing(error) {
        if (!$scope.$$destroyed) {
            if (error) {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mm.settings.errorsyncsite', true);
            }
        }
    }
}]);

angular.module('mm.core.settings')
.provider('$mmSettingsDelegate', function() {
    var handlers = {},
        self = {};
        self.registerHandler = function(component, handler, priority) {
        if (typeof handlers[component] !== 'undefined') {
            console.log("$mmSettingsDelegateProvider: Handler '" + handlers[component].component + "' already registered as settings handler");
            return false;
        }
        console.log("$mmSettingsDelegateProvider: Registered component '" + component + "' as settings handler.");
        handlers[component] = {
            component: component,
            handler: handler,
            instance: undefined,
            priority: typeof priority === 'undefined' ? 100 : priority
        };
        return true;
    };
    self.$get = ["$q", "$log", "$mmSite", "$mmUtil", function($q, $log, $mmSite, $mmUtil) {
        var enabledHandlers = {},
            currentSiteHandlers = [],
            self = {},
            loaded = false,
            lastUpdateHandlersStart;
        $log = $log.getInstance('$mmSettingsDelegate');
                self.areHandlersLoaded = function() {
            return loaded;
        };
                self.clearSiteHandlers = function() {
            loaded = false;
            $mmUtil.emptyArray(currentSiteHandlers);
        };
                self.getHandlers = function() {
            return currentSiteHandlers;
        };
                self.isLastUpdateCall = function(time) {
            if (!lastUpdateHandlersStart) {
                return true;
            }
            return time == lastUpdateHandlersStart;
        };
                self.updateHandler = function(addon, handlerInfo, time) {
            var promise,
                siteId = $mmSite.getId();
            if (typeof handlerInfo.instance === 'undefined') {
                handlerInfo.instance = $mmUtil.resolveObject(handlerInfo.handler, true);
            }
            if (!$mmSite.isLoggedIn()) {
                promise = $q.reject();
            } else {
                promise = $q.when(handlerInfo.instance.isEnabled());
            }
            return promise.catch(function() {
                return false;
            }).then(function(enabled) {
                if (self.isLastUpdateCall(time) && $mmSite.isLoggedIn() && $mmSite.getId() === siteId) {
                    if (enabled) {
                        enabledHandlers[addon] = {
                            instance: handlerInfo.instance,
                            priority: handlerInfo.priority
                        };
                    } else {
                        delete enabledHandlers[addon];
                    }
                }
            });
        };
                self.updateHandlers = function() {
            var promises = [],
                now = new Date().getTime();
            $log.debug('Updating setting handlers for current site.');
            lastUpdateHandlersStart = now;
            angular.forEach(handlers, function(handlerInfo, addon) {
                promises.push(self.updateHandler(addon, handlerInfo, now));
            });
            return $q.all(promises).then(function() {
                return true;
            }, function() {
                return true;
            }).finally(function() {
                if (self.isLastUpdateCall(now)) {
                    $mmUtil.emptyArray(currentSiteHandlers);
                    angular.forEach(enabledHandlers, function(handler) {
                        currentSiteHandlers.push({
                            controller: handler.instance.getController(),
                            priority: handler.priority
                        });
                    });
                    loaded = true;
                }
            });
        };
        return self;
    }];
    return self;
});

angular.module('mm.core')
.factory('$mmSettingsHelper', ["$log", "$mmSitesManager", "$q", "$mmFilepool", "$mmLang", "$mmEvents", "$mmCronDelegate", "$mmApp", "mmCoreEventSessionExpired", function($log, $mmSitesManager, $q, $mmFilepool, $mmLang, $mmEvents, $mmCronDelegate, $mmApp,
            mmCoreEventSessionExpired) {
    $log = $log.getInstance('$mmSettingsHelper');
    var self = {},
        sites = {},
        syncPromises = {};
        self.getProcessor = function(processors, name, fallback) {
        if (!processors) {
            return;
        }
        if (typeof fallback == 'undefined') {
            fallback = true;
        }
        for (var i = 0, len = processors.length; i < len; i++) {
            var processor = processors[i];
            if (processor.name == name) {
                return processor;
            }
        }
        if (fallback) {
            return processors[0];
        }
    };
        self.getProcessorComponents = function(processor, components) {
        var result = [];
        angular.forEach(components, function(component) {
            var componentCopy = angular.copy(component);
            componentCopy.notifications = [];
            angular.forEach(component.notifications, function(notification) {
                var hasProcessor = false;
                for (var i = 0, len = notification.processors.length; i < len; i++) {
                    var proc = notification.processors[i];
                    if (proc.name == processor) {
                        hasProcessor = true;
                        notification.currentProcessor = proc;
                        break;
                    }
                }
                if (hasProcessor) {
                    componentCopy.notifications.push(notification);
                }
            });
            if (componentCopy.notifications.length) {
                result.push(componentCopy);
            }
        });
        return result;
    };
        self.getSites = function() {
        return $mmSitesManager.getSites().then(function(dbSites) {
            var newSites = {};
            angular.forEach(dbSites, function(site) {
                if (sites[site.id]) {
                    newSites[site.id] = sites[site.id];
                    newSites[site.id].siteurl = site.siteurl;
                    newSites[site.id].fullname = site.fullname;
                    newSites[site.id].sitename = site.sitename;
                    newSites[site.id].avatar = site.avatar;
                } else {
                    newSites[site.id] = site;
                    newSites[site.id].synchronizing = false;
                }
            });
            sites = newSites;
            return sites;
        });
    };
        self.getSiteSyncPromise = function(siteId) {
        if (syncPromises[siteId]) {
            return syncPromises[siteId];
        } else {
            return $q.when();
        }
    };
        self.synchronizeSite = function(syncOnlyOnWifi, siteId) {
        if (!sites[siteId]) {
            return $q.reject();
        }
        if (syncPromises[siteId]) {
            return syncPromises[siteId];
        }
        var promises = [],
            syncPromise,
            deleted = false,
            hasSyncHooks = $mmCronDelegate.hasManualSyncHooks();
        if (hasSyncHooks && !$mmApp.isOnline()) {
            return $mmLang.translateAndReject('mm.settings.cannotsyncoffline');
        } else if (hasSyncHooks && syncOnlyOnWifi && $mmApp.isNetworkAccessLimited()) {
            return $mmLang.translateAndReject('mm.settings.cannotsyncwithoutwifi');
        }
        sites[siteId].synchronizing = true;
        promises.push($mmFilepool.invalidateAllFiles(siteId).catch(function() {
        }));
        promises.push($mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCache().then(function() {
                var subPromises = [];
                subPromises.push(site.checkIfLocalMobileInstalledAndNotUsed().then(function() {
                    $mmEvents.trigger(mmCoreEventSessionExpired, {siteid: siteId});
                    return $mmLang.translateAndReject('mm.core.lostconnection');
                }, function() {
                    return $mmSitesManager.updateSiteInfo(siteId).then(function() {
                        sites[siteId].siteurl = site.getInfo().siteurl;
                        sites[siteId].fullname = site.getInfo().fullname;
                        sites[siteId].sitename = site.getInfo().sitename;
                        sites[siteId].avatar = site.getInfo().userpictureurl;
                    });
                }));
                subPromises.push($mmCronDelegate.forceSyncExecution(siteId));
                return $q.all(subPromises);
            });
        }));
        syncPromise = $q.all(promises).finally(function() {
            sites[siteId].synchronizing = false;
            deleted = true;
            delete syncPromises[siteId];
        });
        if (!deleted) {
            syncPromises[siteId] = syncPromise;
        }
        return syncPromise;
    };
    return self;
}]);

angular.module('mm.core.sharedfiles')
.controller('mmSharedFilesChooseSiteCtrl', ["$scope", "$stateParams", "$mmSitesManager", "$mmUtil", "$ionicHistory", "$mmFS", "$mmSharedFilesHelper", function($scope, $stateParams, $mmSitesManager, $mmUtil, $ionicHistory, $mmFS,
            $mmSharedFilesHelper) {
    var filePath = $stateParams.filepath || {},
        fileAndDir = $mmFS.getFileAndDirectoryFromPath(filePath),
        fileEntry;
    if (!filePath) {
        $mmUtil.showErrorModal('Error reading file.');
        $ionicHistory.goBack();
        return;
    }
    $scope.filename = fileAndDir.name;
    $mmFS.getFile(filePath).then(function(fe) {
        fileEntry = fe;
        $scope.filename = fileEntry.name;
    }).catch(function() {
        $mmUtil.showErrorModal('Error reading file.');
        $ionicHistory.goBack();
    });
    $mmSitesManager.getSites().then(function(sites) {
        $scope.sites = sites;
    }).finally(function() {
        $scope.loaded = true;
    });
    $scope.storeInSite = function(siteId) {
        $scope.loaded = false;
        $mmSharedFilesHelper.storeSharedFileInSite(fileEntry, siteId).then(function() {
            $ionicHistory.goBack();
        }).finally(function() {
            $scope.loaded = true;
        });
    };
}]);

angular.module('mm.core.sharedfiles')
.controller('mmSharedFilesListCtrl', ["$scope", "$stateParams", "$mmSharedFiles", "$ionicScrollDelegate", "$state", "$mmFS", "$translate", "$mmEvents", "$mmSite", "$mmSharedFilesHelper", "$ionicHistory", "mmSharedFilesEventFileShared", function($scope, $stateParams, $mmSharedFiles, $ionicScrollDelegate, $state, $mmFS,
            $translate, $mmEvents, $mmSite, $mmSharedFilesHelper, $ionicHistory, mmSharedFilesEventFileShared) {
    var path = $stateParams.path || '',
        manage = $stateParams.manage,
        pick = $stateParams.pick,
        shareObserver,
        siteId = $mmSite.getId();
    $scope.manage = manage;
    $scope.pick = pick;
    if (path) {
        $scope.title = $mmFS.getFileAndDirectoryFromPath(path).name;
    } else {
        $scope.title = $translate.instant('mm.sharedfiles.sharedfiles');
    }
    function loadFiles() {
        return $mmSharedFiles.getSiteSharedFiles(siteId, path).then(function(files) {
            $scope.files = files;
        });
    }
    loadFiles().finally(function() {
        $scope.filesLoaded = true;
    });
    shareObserver = $mmEvents.on(mmSharedFilesEventFileShared, function(data) {
        if (data.siteid == siteId) {
            $scope.filesLoaded = false;
            loadFiles().finally(function() {
                $scope.filesLoaded = true;
            });
        }
    });
    $scope.refreshFiles = function() {
        loadFiles().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
    $scope.fileDeleted = function(index) {
        $scope.files.splice(index, 1);
        $ionicScrollDelegate.resize();
    };
    $scope.fileRenamed = function(index, file) {
        $scope.files[index] = file;
    };
    $scope.openFolder = function(folder) {
        $state.go('site.sharedfiles-list', {path: $mmFS.concatenatePaths(path, folder.name), manage: manage, pick: pick});
    };
    $scope.changeSite = function(sid) {
        siteId = sid;
        $scope.filesLoaded = false;
        loadFiles().finally(function() {
            $scope.filesLoaded = true;
        });
    };
    if (pick) {
        $scope.filePicked = function(file) {
            $mmSharedFilesHelper.filePicked(file.fullPath);
            if (path) {
                var count = path.split('/').length + 1;
                $ionicHistory.goBack(-count);
            } else {
                $ionicHistory.goBack();
            }
        };
    }
    $scope.$on('$destroy', function() {
        shareObserver && shareObserver.off && shareObserver.off();
        if (pick && !path) {
            $mmSharedFilesHelper.filePickerClosed();
        }
    });
}]);

angular.module('mm.core.sharedfiles')
.factory('$mmSharedFilesHandlers', ["$mmSharedFilesHelper", function($mmSharedFilesHelper) {
    var self = {};
        self.filePicker = function() {
        var self = {};
                self.isEnabled = function() {
            return ionic.Platform.isIOS();
        };
                self.getData = function() {
            return {
                name: 'sharedfiles',
                title: 'mm.sharedfiles.sharedfiles',
                class: 'mm-sharedfiles-filepicker-handler',
                icon: 'ion-folder',
                action: function(maxSize, upload, allowOffline) {
                    return $mmSharedFilesHelper.pickSharedFile();
                }
            };
        };
        return self;
    };
    return self;
}]);

angular.module('mm.core.sharedfiles')
.factory('$mmSharedFilesHelper', ["$mmSharedFiles", "$mmUtil", "$log", "$mmApp", "$mmSitesManager", "$mmFS", "$rootScope", "$q", "$ionicModal", "$state", "$translate", "$mmSite", function($mmSharedFiles, $mmUtil, $log, $mmApp, $mmSitesManager, $mmFS, $rootScope, $q,
            $ionicModal, $state, $translate, $mmSite) {
    $log = $log.getInstance('$mmSharedFilesHelper');
    var self = {},
        filePickerDeferred,
        fileListModal,
        fileListScope;
        self.askRenameReplace = function(originalName, newName) {
        var scope = $rootScope.$new();
        scope.originalName = originalName;
        scope.newName = newName;
        return $ionicModal.fromTemplateUrl('core/components/sharedfiles/templates/renamereplace.html', {
            scope: scope,
            animation: 'slide-in-up'
        }).then(function(modal) {
            var deferred = $q.defer();
            scope.modal = modal;
            modal.show();
            scope.click = function(name) {
                close().catch(function() {}).then(function() {
                    deferred.resolve(name);
                });
            };
            scope.closeModal = function() {
                close().catch(function() {}).then(function() {
                    deferred.reject();
                });
            };
            function close() {
                return modal.remove().then(function() {
                    scope.$destroy();
                });
            }
            return deferred.promise;
        });
    };
        self.filePickerClosed = function() {
        if (filePickerDeferred) {
            filePickerDeferred.reject();
            filePickerDeferred = undefined;
        }
    };
        self.filePicked = function(filePath) {
        if (filePickerDeferred) {
            filePickerDeferred.resolve({
                path: filePath,
                uploaded: false
            });
            filePickerDeferred = undefined;
        }
    };
        self.goToChooseSite = function(filePath) {
        var parentState = $state.$current.name.split('.')[0];
        return $state.go(parentState + '.sharedfiles-choose-site', {filepath: filePath});
    };
        self.initFileListModal = function() {
        if (fileListModal) {
            return $q.when();
        }
        if (!fileListScope) {
            fileListScope = $rootScope.$new();
        }
        return $ionicModal.fromTemplateUrl('core/components/sharedfiles/templates/listmodal.html', {
            scope: fileListScope,
            animation: 'slide-in-up'
        }).then(function(modal) {
            fileListScope.modal = modal;
        });
    };
        self.pickSharedFile = function() {
        var path = '',
            siteId = $mmSite.getId();
        filePickerDeferred = $q.defer();
        self.initFileListModal().then(function() {
            fileListScope.filesLoaded = false;
            if (path) {
                fileListScope.title = $mmFS.getFileAndDirectoryFromPath(path).name;
            } else {
                fileListScope.title = $translate.instant('mm.sharedfiles.sharedfiles');
            }
            loadFiles().then(function() {
                fileListScope.closeModal = function() {
                    fileListScope.modal.hide();
                    self.filePickerClosed();
                };
                fileListScope.refreshFiles = function() {
                    loadFiles().finally(function() {
                        fileListScope.$broadcast('scroll.refreshComplete');
                    });
                };
                fileListScope.openFolder = function(folder) {
                    path = $mmFS.concatenatePaths(path, folder.name);
                    fileListScope.filesLoaded = false;
                    loadFiles();
                };
                fileListScope.changeSite = function(sid) {
                    siteId = sid;
                    path = '';
                    fileListScope.filesLoaded = false;
                    loadFiles();
                };
                fileListScope.filePicked = function(file) {
                    self.filePicked(file.fullPath);
                    fileListScope.modal.hide();
                };
            });
            fileListScope.modal.show();
        }).catch(function() {
            self.filePickerClosed();
        });
        return filePickerDeferred.promise;
        function loadFiles() {
            return $mmSharedFiles.getSiteSharedFiles(siteId, path).then(function(files) {
                fileListScope.files = files;
                fileListScope.filesLoaded = true;
            });
        }
    };
        self.searchIOSNewSharedFiles = function() {
        return $mmApp.ready().then(function() {
            if ($state.$current.name == 'site.sharedfiles-choose-site') {
                return $q.reject();
            }
            return $mmSharedFiles.checkIOSNewFiles().then(function(fileEntry) {
                return $mmSitesManager.getSitesIds().then(function(siteIds) {
                    if (!siteIds.length) {
                        $mmUtil.showErrorModal('mm.sharedfiles.errorreceivefilenosites', true);
                        $mmSharedFiles.deleteInboxFile(fileEntry);
                    } else if (siteIds.length == 1) {
                        self.storeSharedFileInSite(fileEntry, siteIds[0]);
                    } else {
                        self.goToChooseSite(fileEntry.fullPath);
                    }
                });
            });
        });
    };
        self.storeSharedFileInSite = function(fileEntry, siteId) {
        siteId = siteId || $mmSite.getId();
        var sharedFilesDirPath = $mmSharedFiles.getSiteSharedFilesDirPath(siteId);
        return $mmFS.getUniqueNameInFolder(sharedFilesDirPath, fileEntry.name).then(function(newName) {
            if (newName == fileEntry.name) {
                return newName;
            } else {
                return self.askRenameReplace(fileEntry.name, newName);
            }
        }).then(function(name) {
            return $mmSharedFiles.storeFileInSite(fileEntry, name, siteId).finally(function() {
                $mmSharedFiles.deleteInboxFile(fileEntry);
                $mmUtil.showModal(undefined, $translate.instant('mm.sharedfiles.successstorefile'));
            }).catch(function(err) {
                $mmUtil.showErrorModal(err || 'Error moving file.');
                return $q.reject();
            });
        });
    };
    return self;
}]);

angular.module('mm.core.sharedfiles')
.config(["$mmAppProvider", "mmSharedFilesStore", function($mmAppProvider, mmSharedFilesStore) {
    var stores = [
        {
            name: mmSharedFilesStore,
            keyPath: 'id'
        }
    ];
    $mmAppProvider.registerStores(stores);
}])
.factory('$mmSharedFiles', ["$mmFS", "$q", "$log", "$mmApp", "$mmSite", "$mmEvents", "md5", "mmSharedFilesStore", "mmSharedFilesFolder", "mmSharedFilesEventFileShared", function($mmFS, $q, $log, $mmApp, $mmSite, $mmEvents, md5, mmSharedFilesStore, mmSharedFilesFolder,
            mmSharedFilesEventFileShared) {
    $log = $log.getInstance('$mmSharedFiles');
    var self = {};
        self.checkIOSNewFiles = function() {
        $log.debug('Search for new files on iOS');
        return $mmFS.getDirectoryContents('Inbox').then(function(entries) {
            if (entries.length > 0) {
                var promises = [],
                    fileToReturn;
                angular.forEach(entries, function(entry) {
                    var fileId = self._getFileId(entry);
                    promises.push(self._isFileTreated(fileId).then(function() {
                        self.deleteInboxFile(entry);
                    }).catch(function() {
                        $log.debug('Found new file ' + entry.name + ' shared with the app.');
                        if (!fileToReturn) {
                            fileToReturn = entry;
                        }
                    }));
                });
                return $q.all(promises).then(function() {
                    var fileId;
                    if (fileToReturn) {
                        fileId = self._getFileId(fileToReturn);
                        return self._markAsTreated(fileId).then(function() {
                            $log.debug('File marked as "treated": ' + fileToReturn.name);
                            return fileToReturn;
                        });
                    } else {
                        return $q.reject();
                    }
                });
            } else {
                return $q.reject();
            }
        });
    };
        self.deleteInboxFile = function(entry) {
        var fileId = self._getFileId(entry),
            deferred = $q.defer();
        function removeMark() {
            self._unmarkAsTreated(fileId).then(function() {
                $log.debug('"Treated" mark removed from file: ' + entry.name);
                deferred.resolve();
            }).catch(function() {
                $log.debug('Error deleting "treated" mark from file: ' + entry.name);
                deferred.reject();
            });
        }
        $log.debug('Delete inbox file: ' + entry.name);
        entry.remove(removeMark, removeMark);
        return deferred.promise;
    };
        self._getFileId = function(entry) {
        return md5.createHash(entry.name);
    };
        self.getSiteSharedFiles = function(siteId, path) {
        siteId = siteId || $mmSite.getId();
        var pathToGet = self.getSiteSharedFilesDirPath(siteId);
        if (path) {
            pathToGet = $mmFS.concatenatePaths(pathToGet, path);
        }
        return $mmFS.getDirectoryContents(pathToGet).catch(function() {
            return [];
        });
    };
        self.getSiteSharedFilesDirPath = function(siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmFS.getSiteFolder(siteId) + '/' + mmSharedFilesFolder;
    };
        self._isFileTreated = function(fileId) {
        return $mmApp.getDB().get(mmSharedFilesStore, fileId);
    };
        self._markAsTreated = function(fileId) {
        return $mmApp.getDB().insert(mmSharedFilesStore, {id: fileId});
    };
        self.storeFileInSite = function(entry, newName, siteId) {
        siteId = siteId || $mmSite.getId();
        if (!entry || !siteId) {
            return $q.reject();
        }
        newName = newName || entry.name;
        var sharedFilesFolder = self.getSiteSharedFilesDirPath(siteId),
            newPath = $mmFS.concatenatePaths(sharedFilesFolder, newName);
        return $mmFS.createDir(sharedFilesFolder).then(function() {
            return $mmFS.moveFile(entry.fullPath, newPath).then(function(newFile) {
                $mmEvents.trigger(mmSharedFilesEventFileShared, {siteid: siteId, name: newName});
                return newFile;
            });
        });
    };
        self._unmarkAsTreated = function(fileId) {
        return $mmApp.getDB().remove(mmSharedFilesStore, fileId);
    };
    return self;
}]);

angular.module('mm.core.textviewer')
.controller('mmTextViewerIndexCtrl', ["$stateParams", "$scope", "$mmText", function($stateParams, $scope, $mmText) {
    $scope.title = $stateParams.title;
    if ($stateParams.replacelinebreaks) {
        $scope.content = $mmText.replaceNewLines($stateParams.content, '<br>');
    } else {
        $scope.content = $stateParams.content;
    }
    if ($stateParams.component) {
        $scope.component = $stateParams.component;
        if ($stateParams.componentId) {
            $scope.componentId = $stateParams.componentId;
        }
    }
}]);

angular.module('mm.core.sidemenu')
.controller('mmSideMenuIframeViewCtrl', ["$scope", "$stateParams", "$sce", function($scope, $stateParams, $sce) {
    $scope.title = $stateParams.title;
    $scope.url = $sce.trustAsResourceUrl($stateParams.url);
}]);

angular.module('mm.core.sidemenu')
.controller('mmSideMenuCtrl', ["$scope", "$state", "$mmSideMenuDelegate", "$mmSitesManager", "$mmSite", "$mmEvents", "$timeout", "mmCoreEventLanguageChanged", "mmCoreEventSiteUpdated", "$mmSideMenu", "$mmCourses", function($scope, $state, $mmSideMenuDelegate, $mmSitesManager, $mmSite, $mmEvents,
            $timeout, mmCoreEventLanguageChanged, mmCoreEventSiteUpdated, $mmSideMenu, $mmCourses) {
    $mmSideMenu.setScope($scope);
    $scope.handlers = $mmSideMenuDelegate.getNavHandlers();
    $scope.areNavHandlersLoaded = $mmSideMenuDelegate.areNavHandlersLoaded;
    loadSiteInfo();
    $scope.logout = function() {
        $mmSitesManager.logout().finally(function() {
            $state.go('mm_login.sites');
        });
    };
    function loadSiteInfo() {
        var config = $mmSite.getStoredConfig();
        $scope.siteinfo = $mmSite.getInfo();
        $scope.logoutLabel = 'mm.sidemenu.' + (config && config.tool_mobile_forcelogout == "1" ? 'logout': 'changesite');
        $scope.showMyCourses = !$mmCourses.isMyCoursesDisabledInSite();
        $scope.showWeb = !$mmSite.isFeatureDisabled('$mmSideMenuDelegate_website');
        $scope.showHelp = !$mmSite.isFeatureDisabled('$mmSideMenuDelegate_help');
        $mmSite.getDocsUrl().then(function(docsurl) {
            $scope.docsurl = docsurl;
        });
        $mmSideMenu.getCustomMenuItems().then(function(items) {
            $scope.customItems = items;
        });
    }
    function updateSiteInfo() {
        $scope.siteinfo = undefined;
        $timeout(function() {
            loadSiteInfo();
        });
    }
    var langObserver = $mmEvents.on(mmCoreEventLanguageChanged, updateSiteInfo);
    var updateSiteObserver = $mmEvents.on(mmCoreEventSiteUpdated, function(siteid) {
        if ($mmSite.getId() === siteid) {
            updateSiteInfo();
        }
    });
    $scope.$on('$destroy', function() {
        if (langObserver && langObserver.off) {
            langObserver.off();
        }
        if (updateSiteObserver && updateSiteObserver.off) {
            updateSiteObserver.off();
        }
    });
}]);

angular.module('mm.core.sidemenu')
.provider('$mmSideMenuDelegate', function() {
    var navHandlers = {},
        self = {};
        self.registerNavHandler = function(addon, handler, priority) {
        if (typeof navHandlers[addon] !== 'undefined') {
            console.log("$mmSideMenuDelegateProvider: Addon '" + navHandlers[addon].addon + "' already registered as navigation handler");
            return false;
        }
        console.log("$mmSideMenuDelegateProvider: Registered addon '" + addon + "' as navigation handler.");
        navHandlers[addon] = {
            addon: addon,
            handler: handler,
            instance: undefined,
            priority: priority
        };
        return true;
    };
    self.$get = ["$mmUtil", "$q", "$log", "$mmSite", function($mmUtil, $q, $log, $mmSite) {
        var enabledNavHandlers = {},
            currentSiteHandlers = [],
            self = {},
            loaded = false,
            lastUpdateHandlersStart;
        $log = $log.getInstance('$mmSideMenuDelegate');
                self.areNavHandlersLoaded = function() {
            return loaded;
        };
                self.clearSiteHandlers = function() {
            loaded = false;
            $mmUtil.emptyArray(currentSiteHandlers);
        };
                self.getNavHandlers = function() {
            return currentSiteHandlers;
        };
                self.isLastUpdateCall = function(time) {
            if (!lastUpdateHandlersStart) {
                return true;
            }
            return time == lastUpdateHandlersStart;
        };
                self.updateNavHandler = function(addon, handlerInfo, time) {
            var promise,
                siteId = $mmSite.getId();
            if (typeof handlerInfo.instance === 'undefined') {
                handlerInfo.instance = $mmUtil.resolveObject(handlerInfo.handler, true);
            }
            if (!$mmSite.isLoggedIn()) {
                promise = $q.reject();
            } else if ($mmSite.isFeatureDisabled('$mmSideMenuDelegate_' + addon)) {
                promise = $q.when(false);
            } else {
                promise = $q.when(handlerInfo.instance.isEnabled());
            }
            return promise.catch(function() {
                return false;
            }).then(function(enabled) {
                if (self.isLastUpdateCall(time) && $mmSite.isLoggedIn() && $mmSite.getId() === siteId) {
                    if (enabled) {
                        enabledNavHandlers[addon] = {
                            instance: handlerInfo.instance,
                            priority: handlerInfo.priority
                        };
                    } else {
                        delete enabledNavHandlers[addon];
                    }
                }
            });
        };
                self.updateNavHandlers = function() {
            var promises = [],
                now = new Date().getTime();
            $log.debug('Updating navigation handlers for current site.');
            lastUpdateHandlersStart = now;
            angular.forEach(navHandlers, function(handlerInfo, addon) {
                promises.push(self.updateNavHandler(addon, handlerInfo, now));
            });
            return $q.all(promises).then(function() {
                return true;
            }, function() {
                return true;
            }).finally(function() {
                if (self.isLastUpdateCall(now)) {
                    $mmUtil.emptyArray(currentSiteHandlers);
                    angular.forEach(enabledNavHandlers, function(handler) {
                        currentSiteHandlers.push({
                            controller: handler.instance.getController(),
                            priority: handler.priority
                        });
                    });
                    loaded = true;
                }
            });
        };
        return self;
    }];
    return self;
});

angular.module('mm.core.sidemenu')
.factory('$mmSideMenu', ["$log", "$mmLang", "$mmSitesManager", "mmCoreConfigConstants", function($log, $mmLang, $mmSitesManager, mmCoreConfigConstants) {
    $log = $log.getInstance('$mmSideMenu');
    var self = {},
        scope;
        self.getCustomMenuItems = function(siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var itemsString = site.getStoredConfig('tool_mobile_custommenuitems'),
                items,
                position = 0,
                map = {},
                result = [];
            if (!itemsString || typeof itemsString != 'string') {
                return result;
            }
            items = itemsString.split(/(?:\r\n|\r|\n)/);
            angular.forEach(items, function(item) {
                var values = item.split('|'),
                    id,
                    label = values[0] ? values[0].trim() : values[0],
                    url = values[1] ? values[1].trim() : values[1],
                    type = values[2] ? values[2].trim() : values[2],
                    lang = (values[3] ? values[3].trim() : values[3]) || 'none',
                    icon = values[4] ? values[4].trim() : values[4];
                if (!label || !url || !type) {
                    return;
                }
                id = url + '#' + type;
                if (!icon) {
                    icon = type == 'embedded' ? 'ion-qr-scanner' : 'ion-link';
                }
                if (!map[id]) {
                    map[id] = {
                        url: url,
                        type: type,
                        position: position,
                        labels: {}
                    };
                    position++;
                }
                map[id].labels[lang.toLowerCase()] = {
                    label: label,
                    icon: icon
                };
            });
            if (!position) {
                return result;
            }
            return $mmLang.getCurrentLanguage().then(function(currentLang) {
                var fallbackLang = mmCoreConfigConstants.default_lang || 'en';
                angular.forEach(map, function(entry) {
                    var data = entry.labels[currentLang] || entry.labels.none || entry.labels[fallbackLang];
                    if (!data) {
                        data = entry.labels[Object.keys(entry.labels)[0]];
                    }
                    result[entry.position] = {
                        url: entry.url,
                        type: entry.type,
                        label: data.label,
                        icon: data.icon
                    };
                });
                return result;
            });
        });
    };
        self.hideRightSideMenu = function() {
        if (!scope) {
            return false;
        }
        if (!scope.rightSideMenu) {
            scope.rightSideMenu = {};
        }
        scope.rightSideMenu.show = false;
        return true;
    };
        self.setScope = function(scp) {
        scope = scp;
    };
        self.showRightSideMenu = function(template, data) {
        if (!template || !scope) {
            return false;
        }
        if (!scope.rightSideMenu) {
            scope.rightSideMenu = {};
        }
        scope.rightSideMenu.show = true;
        scope.rightSideMenu.template = template;
        scope.rsmScope = data;
        return true;
    };
    return self;
}])
.run(["$rootScope", "$mmSideMenu", function($rootScope, $mmSideMenu) {
    $rootScope.$on('$stateChangeStart', function(event, toState) {
        if (toState.name.split('.').length == 2) {
            $mmSideMenu.hideRightSideMenu();
        }
    });
}]);

angular.module('mm.core')
.directive('mmUserLink', ["$state", "mmUserProfileState", function($state, mmUserProfileState) {
    return {
        restrict: 'A',
        link: function(scope, element, attrs) {
            element.on('click', function(event) {
                event.preventDefault();
                event.stopPropagation();
                $state.go(mmUserProfileState, {courseid: attrs.courseid, userid: attrs.userid});
            });
        }
    };
}]);

angular.module('mm.core.user')
.directive('mmUserProfileField', ["$mmUserProfileFieldsDelegate", "$compile", function($mmUserProfileFieldsDelegate, $compile) {
    return {
        restrict: 'E',
        scope: {
            field: '=',
            signup: '@?',
            edit: '@?',
            model: '=?',
            registerAuth: '@?',
            scrollHandle: '@?',
        },
        templateUrl: 'core/components/user/templates/userprofilefield.html',
        link: function(scope, element) {
            var field = scope.field,
                fieldContainer = element[0].querySelector('.mm-userprofilefield-container');
            scope.signup = scope.signup && scope.signup !== 'false';
            scope.edit = scope.edit && scope.edit !== 'false';
            if (field && fieldContainer) {
                var directive = $mmUserProfileFieldsDelegate.getDirectiveForField(field, scope.signup, scope.registerAuth);
                if (directive) {
                    fieldContainer.setAttribute(directive, '');
                    $compile(fieldContainer)(scope);
                }
            }
        }
    };
}]);

angular.module('mm.core.user')
.controller('mmUserAboutCtrl', ["$scope", "$stateParams", "$mmUtil", "$mmUser", "$q", "$mmEvents", "$mmCourses", "mmUserEventProfileRefreshed", function($scope, $stateParams, $mmUtil, $mmUser, $q, $mmEvents, $mmCourses,
            mmUserEventProfileRefreshed) {
    var courseId = $stateParams.courseid,
        userId   = $stateParams.userid;
    $scope.isAndroid = ionic.Platform.isAndroid();
    function fetchUserData() {
        return $mmUser.getProfile(userId, courseId).then(function(user) {
            if (user.address) {
                user.address = $mmUser.formatAddress(user.address, user.city, user.country);
                user.encodedAddress = encodeURIComponent(user.address);
            }
            $scope.user = user;
            $scope.title = user.fullname;
            $scope.hasContact = user.email || user.phone1 || user.phone2 || user.city || user.country || user.address;
            $scope.hasDetails = user.url || user.interests || (user.customfields && user.customfields.length > 0);
        }, function(message) {
            if (message) {
                $mmUtil.showErrorModal(message);
            }
            return $q.reject();
        });
    }
    fetchUserData().finally(function() {
        $scope.userLoaded = true;
    });
    $scope.refreshUser = function() {
        var promises = [];
        promises.push($mmUser.invalidateUserCache(userId));
        $q.all(promises).finally(function() {
            fetchUserData().finally(function() {
                $mmEvents.trigger(mmUserEventProfileRefreshed, {courseid: courseId, userid: userId, user: $scope.user});
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };
}]);

angular.module('mm.core.user')
.controller('mmUserProfileCtrl', ["$scope", "$stateParams", "$mmUtil", "$mmUser", "$mmUserDelegate", "$mmSite", "$translate", "$mmCourses", "$q", "$mmEvents", "$mmFileUploaderHelper", "$mmSitesManager", "mmUserEventProfileRefreshed", "mmUserProfilePictureUpdated", "mmUserProfileHandlersTypeNewPage", "mmUserProfileHandlersTypeCommunication", "mmUserProfileHandlersTypeAction", function($scope, $stateParams, $mmUtil, $mmUser, $mmUserDelegate, $mmSite, $translate, $mmCourses,
            $q, $mmEvents, $mmFileUploaderHelper, $mmSitesManager, mmUserEventProfileRefreshed, mmUserProfilePictureUpdated,
            mmUserProfileHandlersTypeNewPage, mmUserProfileHandlersTypeCommunication, mmUserProfileHandlersTypeAction) {
    $scope.courseId = $stateParams.courseid;
    $scope.userId   = $stateParams.userid;
    function fetchUserData() {
        return $mmUser.getProfile($scope.userId, $scope.courseId).then(function(user) {
            user.address = $mmUser.formatAddress("", user.city, user.country);
            user.roles = $mmUser.formatRoleList(user.roles);
            $scope.user = user;
            $scope.title = user.fullname;
            $scope.isLoadingHandlers = true;
            $mmUserDelegate.getProfileHandlersFor(user, $scope.courseId).then(function(handlers) {
                $scope.actionHandlers = [];
                $scope.newPageHandlers = [];
                $scope.communicationHandlers = [];
                angular.forEach(handlers, function(handler) {
                    switch (handler.type) {
                        case mmUserProfileHandlersTypeCommunication:
                            $scope.communicationHandlers.push(handler);
                            break;
                        case mmUserProfileHandlersTypeAction:
                            $scope.actionHandlers.push(handler);
                            break;
                        case mmUserProfileHandlersTypeNewPage:
                        default:
                            $scope.newPageHandlers.push(handler);
                            break;
                    }
                });
            }).finally(function() {
                $scope.isLoadingHandlers = false;
            });
        }, function(message) {
            if (message) {
                $mmUtil.showErrorModal(message);
            }
            return $q.reject();
        });
    }
    fetchUserData().then(function() {
        return $mmSite.write('core_user_view_user_profile', {
            userid: $scope.userId,
            courseid: $scope.courseId
        }).catch(function(error) {
            $scope.isDeleted = error === $translate.instant('mm.core.userdeleted');
        });
    }).finally(function() {
        $scope.userLoaded = true;
    });
    obsRefreshed = $mmEvents.on(mmUserEventProfileRefreshed, function(data) {
        if (typeof data.user != "undefined") {
            $scope.user.email = data.user.email;
            $scope.user.address = $mmUser.formatAddress("", data.user.city, data.user.country);
        }
    });
    $scope.refreshUser = function() {
        var promises = [];
        promises.push($mmUser.invalidateUserCache($scope.userId));
        promises.push($mmCourses.invalidateUserNavigationOptions());
        promises.push($mmCourses.invalidateUserAdministrationOptions());
        $q.all(promises).finally(function() {
            fetchUserData().finally(function() {
                $mmEvents.trigger(mmUserEventProfileRefreshed, {courseid: $scope.courseId, userid: $scope.userId,
                    user: $scope.user});
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };
    $scope.canChangeProfilePicture =
        (!$scope.courseId || $scope.courseId == $mmSite.getSiteHomeId()) &&
        $scope.userId == $mmSite.getUserId() &&
        $mmSite.canUploadFiles() &&
        $mmSite.wsAvailable('core_user_update_picture') &&
        !$mmUser.isUpdatePictureDisabledInSite();
    $scope.changeProfilePicture = function() {
        var maxSize = -1;
        var title = $translate.instant('mm.user.newpicture');
        var filterMethods = ['album', 'camera'];
        return $mmFileUploaderHelper.selectAndUploadFile(maxSize, title, filterMethods).then(function(result) {
            return $mmUser.changeProfilePicture(result.itemid, $scope.userId).then(function(profileimageurl) {
                $mmEvents.trigger(mmUserProfilePictureUpdated, {userId: $scope.userId, picture: profileimageurl});
                $mmSitesManager.updateSiteInfo($mmSite.getId());
                $scope.refreshUser();
            });
        }).catch(function(message) {
            if (message) {
                $mmUtil.showErrorModal(message);
            }
            return $q.reject();
        });
    };
    $scope.$on('$destroy', function() {
        obsRefreshed && obsRefreshed.off && obsRefreshed.off();
    });
}]);

angular.module('mm.addons.badges', [])
.constant('mmaBadgesPriority', 50)
.constant('mmaBadgesComponent', 'mmaBadges')
.config(["$stateProvider", "$mmUserDelegateProvider", "mmaBadgesPriority", "$mmContentLinksDelegateProvider", function($stateProvider, $mmUserDelegateProvider, mmaBadgesPriority, $mmContentLinksDelegateProvider) {
    $stateProvider
    .state('site.userbadges', {
        url: '/userbadges',
        views: {
            'site': {
                templateUrl: 'addons/badges/templates/userbadges.html',
                controller: 'mmaBadgesUserCtrl'
            }
        },
        params: {
            courseid: null,
            userid: null
        }
    })
    .state('site.issuedbadge', {
        url: '/issuedbadge',
        views: {
            'site': {
                templateUrl: 'addons/badges/templates/issuedbadge.html',
                controller: 'mmaBadgesIssuedCtrl'
            }
        },
        params: {
            cid: null,
            uid: null,
            uniquehash: null
        }
    });
    $mmUserDelegateProvider.registerProfileHandler('mmaBadges', '$mmaBadgesHandlers.userProfile', mmaBadgesPriority);
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaBadges:myBadges', '$mmaBadgesHandlers.myBadgesLinksHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaBadges:badge', '$mmaBadgesHandlers.badgeLinksHandler');
}]);

angular.module('mm.addons.calendar', [])
.constant('mmaCalendarDaysInterval', 30)
.constant('mmaCalendarDefaultNotifTime', 60)
.constant('mmaCalendarComponent', 'mmaCalendarEvents')
.constant('mmaCalendarPriority', 400)
.constant('mmaCalendarDefaultNotifTimeSetting', 'mmaCalendarDefaultNotifTime')
.constant('mmaCalendarDefaultNotifTimeChangedEvent', 'mma_calendar_default_notif_time_changed')
.config(["$stateProvider", "$mmSideMenuDelegateProvider", "mmaCalendarPriority", function($stateProvider, $mmSideMenuDelegateProvider, mmaCalendarPriority) {
    $stateProvider
        .state('site.calendar', {
            url: '/calendar',
            views: {
                'site': {
                    controller: 'mmaCalendarListCtrl',
                    templateUrl: 'addons/calendar/templates/list.html'
                }
            },
            params: {
                eventid: null,
                clear: false
            }
        })
        .state('site.calendar-event', {
            url: '/calendar-event/:id',
            views: {
                'site': {
                    controller: 'mmaCalendarEventCtrl',
                    templateUrl: 'addons/calendar/templates/event.html'
                }
            }
        })
        .state('site.calendar-settings', {
            url: '/calendar-settings',
            views: {
                'site': {
                    controller: 'mmaCalendarSettingsCtrl',
                    templateUrl: 'addons/calendar/templates/settings.html'
                }
            }
        });
    $mmSideMenuDelegateProvider.registerNavHandler('mmaCalendar', '$mmaCalendarHandlers.sideMenuNav', mmaCalendarPriority);
}])
.run(["$mmaCalendar", "$mmLocalNotifications", "$state", "$mmApp", "mmaCalendarComponent", function($mmaCalendar, $mmLocalNotifications, $state, $mmApp, mmaCalendarComponent) {
    $mmLocalNotifications.registerClick(mmaCalendarComponent, function(data) {
        if (data.eventid) {
            $mmApp.ready().then(function() {
                $mmaCalendar.isDisabled(data.siteid).then(function(disabled) {
                    if (disabled) {
                        return;
                    }
                    $state.go('redirect', {siteid: data.siteid, state: 'site.calendar', params: {eventid: data.eventid}});
                });
            });
        }
    });
    $mmApp.ready().then(function() {
        $mmaCalendar.scheduleAllSitesEventsNotifications();
    });
}]);

angular.module('mm.addons.competency', [])
.constant('mmaCompetencyPriority', 900)
.constant('mmaCourseCompetenciesPriority', 700)
.constant('mmaCompetencyStatusDraft', 0)
.constant('mmaCompetencyStatusActive', 1)
.constant('mmaCompetencyStatusComplete', 2)
.constant('mmaCompetencyStatusWaitingForReview', 3)
.constant('mmaCompetencyStatusInReview', 4)
.constant('mmaCompetencyReviewStatusIdle', 0)
.constant('mmaCompetencyReviewStatusWaitingForReview', 1)
.constant('mmaCompetencyReviewStatusInReview', 2)
.config(["$stateProvider", "$mmSideMenuDelegateProvider", "$mmCoursesDelegateProvider", "$mmUserDelegateProvider", "mmaCompetencyPriority", "mmaCourseCompetenciesPriority", function($stateProvider, $mmSideMenuDelegateProvider, $mmCoursesDelegateProvider, $mmUserDelegateProvider,
    mmaCompetencyPriority, mmaCourseCompetenciesPriority) {
    $stateProvider
        .state('site.learningplans', {
            url: '/learningplans',
            params: {
                userid: null
            },
            views: {
                'site': {
                    controller: 'mmaLearningPlansListCtrl',
                    templateUrl: 'addons/competency/templates/planlist.html'
                }
            }
        })
        .state('site.learningplan', {
            url: '/learningplan',
            params: {
                id: null
            },
            views: {
                'site': {
                    controller: 'mmaLearningPlanCtrl',
                    templateUrl: 'addons/competency/templates/plan.html'
                }
            }
        })
        .state('site.competencies', {
            url: '/competencies',
            params: {
                pid: null,
                cid: null,
                compid: null,
                uid: null
            },
            views: {
                'site': {
                    controller: 'mmaCompetenciesListCtrl',
                    templateUrl: 'addons/competency/templates/competencies.html'
                }
            }
        })
        .state('site.competency', {
            url: '/competency',
            params: {
                planid: null,
                courseid: null,
                competencyid: null,
                userid: null
            },
            views: {
                'site': {
                    controller: 'mmaCompetencyCtrl',
                    templateUrl: 'addons/competency/templates/competency.html'
                }
            }
        })
        .state('site.coursecompetencies', {
            url: '/coursecompetencies',
            params: {
                courseid: null,
                userid: null
            },
            views: {
                'site': {
                    controller: 'mmaCourseCompetenciesCtrl',
                    templateUrl: 'addons/competency/templates/coursecompetencies.html'
                }
            }
        })
        .state('site.competencysummary', {
            url: '/competencysummary',
            params: {
                competencyid: null
            },
            views: {
                'site': {
                    controller: 'mmaCompetencySummaryCtrl',
                    templateUrl: 'addons/competency/templates/competencysummary.html'
                }
            }
        });
    $mmSideMenuDelegateProvider.registerNavHandler('mmaCompetency', '$mmaCompetencyHandlers.sideMenuNav', mmaCompetencyPriority);
    $mmCoursesDelegateProvider.registerNavHandler('mmaCompetency', '$mmaCompetencyHandlers.coursesNav',
        mmaCourseCompetenciesPriority);
    $mmUserDelegateProvider.registerProfileHandler('mmaCompetency:learningPlan', '$mmaCompetencyHandlers.learningPlan',
        mmaCompetencyPriority);
}]);
angular.module('mm.addons.coursecompletion', [])
.constant('mmaCourseCompletionPriority', 200)
.constant('mmaCourseCompletionViewCompletionPriority', 200)
.config(["$stateProvider", "$mmUserDelegateProvider", "$mmCoursesDelegateProvider", "mmaCourseCompletionPriority", "mmaCourseCompletionViewCompletionPriority", function($stateProvider, $mmUserDelegateProvider, $mmCoursesDelegateProvider, mmaCourseCompletionPriority,
            mmaCourseCompletionViewCompletionPriority) {
    $stateProvider
    .state('site.course-completion', {
        url: '/course-completion',
        views: {
            'site': {
                templateUrl: 'addons/coursecompletion/templates/report.html',
                controller: 'mmaCourseCompletionReportCtrl'
            }
        },
        params: {
            course: null,
            userid: null
        }
    });
    $mmUserDelegateProvider.registerProfileHandler('mmaCourseCompletion:viewCompletion',
            '$mmaCourseCompletionHandlers.viewCompletion', mmaCourseCompletionViewCompletionPriority);
    $mmCoursesDelegateProvider.registerNavHandler('mmaCourseCompletion',
            '$mmaCourseCompletionHandlers.coursesNav', mmaCourseCompletionPriority);
}]);

angular.module('mm.addons.files', ['mm.core'])
.constant('mmaFilesMyComponent', 'mmaFilesMy')
.constant('mmaFilesSiteComponent', 'mmaFilesSite')
.constant('mmaFilesPriority', 200)
.config(["$stateProvider", "$mmSideMenuDelegateProvider", "mmaFilesPriority", function($stateProvider, $mmSideMenuDelegateProvider, mmaFilesPriority) {
    $stateProvider
        .state('site.files', {
            url: '/files',
            views: {
                'site': {
                    controller: 'mmaFilesIndexController',
                    templateUrl: 'addons/files/templates/index.html'
                }
            }
        })
        .state('site.files-list', {
            url: '/list',
            params: {
                path: false,
                root: false,
                title: false
            },
            views: {
                'site': {
                    controller: 'mmaFilesListController',
                    templateUrl: 'addons/files/templates/list.html'
                }
            }
        })
        .state('site.files-choose-site', {
            url: '/choose-site',
            params: {
                file: null
            },
            views: {
                'site': {
                    controller: 'mmaFilesChooseSiteCtrl',
                    templateUrl: 'addons/files/templates/choosesite.html'
                }
            }
        });
    $mmSideMenuDelegateProvider.registerNavHandler('mmaFiles', '$mmaFilesHandlers.sideMenuNav', mmaFilesPriority);
}]);

angular.module('mm.addons.frontpage', [])
.constant('mmaFrontpagePriority', 1000)
.config(["$stateProvider", "$mmCoursesDelegateProvider", "mmCoreCoursePriority", function($stateProvider, $mmCoursesDelegateProvider, mmCoreCoursePriority) {
    $stateProvider
    .state('site.frontpage', {
        url: '/frontpage',
        params: {
            moduleid: null
        },
        views: {
            'site': {
                templateUrl: 'addons/frontpage/templates/frontpage.html',
                controller: 'mmaFrontpageCtrl'
            }
        }
    });
}])
.config(["$mmSideMenuDelegateProvider", "$mmContentLinksDelegateProvider", "mmaFrontpagePriority", function($mmSideMenuDelegateProvider, $mmContentLinksDelegateProvider, mmaFrontpagePriority) {
    $mmSideMenuDelegateProvider.registerNavHandler('mmaFrontpage', '$mmaFrontPageHandlers.sideMenuNav', mmaFrontpagePriority);
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaFrontpage', '$mmaFrontPageHandlers.linksHandler');
}]);

angular.module('mm.addons.grades', [])
.constant('mmaGradesPriority', 400)
.constant('mmaGradesViewGradesPriority', 400)
.constant('mmaGradesSideMenuPriority', 950)
.config(["$stateProvider", "$mmUserDelegateProvider", "$mmCoursesDelegateProvider", "$mmContentLinksDelegateProvider", "$mmSideMenuDelegateProvider", "mmaGradesPriority", "mmaGradesViewGradesPriority", "mmaGradesSideMenuPriority", function($stateProvider, $mmUserDelegateProvider, $mmCoursesDelegateProvider, $mmContentLinksDelegateProvider,
            $mmSideMenuDelegateProvider, mmaGradesPriority, mmaGradesViewGradesPriority, mmaGradesSideMenuPriority) {
    $stateProvider
    .state('site.coursesgrades', {
        url: '/coursesgrades',
        views: {
            'site': {
                templateUrl: 'addons/grades/templates/courses.html',
                controller: 'mmaGradesCoursesGradesCtrl'
            }
        }
    });
    $mmUserDelegateProvider.registerProfileHandler('mmaGrades:viewGrades', '$mmaGradesHandlers.viewGrades', mmaGradesViewGradesPriority);
    $mmCoursesDelegateProvider.registerNavHandler('mmaGrades', '$mmaGradesHandlers.coursesNav', mmaGradesPriority);
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaGrades:user', '$mmaGradesHandlers.userLinksHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaGrades:overview', '$mmaGradesHandlers.overviewLinksHandler');
    $mmSideMenuDelegateProvider.registerNavHandler('mmaGrades', '$mmaGradesHandlers.sideMenuNav', mmaGradesSideMenuPriority);
}]);

angular.module('mm.addons.messageoutput', []);

angular.module('mm.addons.messages', ['mm.core'])
.constant('mmaMessagesComponent', 'mmaMessages')
.constant('mmaMessagesLimitMessages', 50)
.constant('mmaMessagesDiscussionLoadedEvent', 'mma_messages_discussion_loaded')
.constant('mmaMessagesDiscussionLeftEvent', 'mma_messages_discussion_left')
.constant('mmaMessagesPollInterval', 10000)
.constant('mmaMessagesPriority', 600)
.constant('mmaMessagesSendMessagePriority', 1000)
.constant('mmaMessagesAddContactPriority', 800)
.constant('mmaMessagesBlockContactPriority', 600)
.constant('mmaMessagesPreferencesPriority', 600)
.constant('mmaMessagesNewMessageEvent', 'mma-messages_new_message')
.constant('mmaMessagesReadChangedEvent', 'mma-messages_read_changed')
.constant('mmaMessagesReadCronEvent', 'mma-messages_read_cron')
.constant('mmaMessagesAutomSyncedEvent', 'mma_messages_autom_synced')
.config(["$stateProvider", "$mmUserDelegateProvider", "$mmSideMenuDelegateProvider", "mmaMessagesSendMessagePriority", "mmaMessagesAddContactPriority", "mmaMessagesBlockContactPriority", "mmaMessagesPriority", "$mmContentLinksDelegateProvider", "$mmSettingsDelegateProvider", "mmaMessagesPreferencesPriority", function($stateProvider, $mmUserDelegateProvider, $mmSideMenuDelegateProvider, mmaMessagesSendMessagePriority,
            mmaMessagesAddContactPriority, mmaMessagesBlockContactPriority, mmaMessagesPriority, $mmContentLinksDelegateProvider,
            $mmSettingsDelegateProvider, mmaMessagesPreferencesPriority) {
    $stateProvider
    .state('site.messages', {
        url: '/messages',
        views: {
            'site': {
                templateUrl: 'addons/messages/templates/index.html'
            }
        }
    })
    .state('site.messages-discussion', {
        url: '/messages-discussion',
        params: {
            userId: null,
            showKeyboard: false,
        },
        views: {
            'site': {
                templateUrl: 'addons/messages/templates/discussion.html',
                controller: 'mmaMessagesDiscussionCtrl'
            }
        }
    })
    .state('site.messages-preferences', {
        url: '/messages-preferences',
        views: {
            'site': {
                controller: 'mmaMessagesPreferencesCtrl',
                templateUrl: 'addons/messages/templates/preferences.html'
            }
        }
    });
    $mmSideMenuDelegateProvider.registerNavHandler('mmaMessages', '$mmaMessagesHandlers.sideMenuNav', mmaMessagesPriority);
    $mmUserDelegateProvider.registerProfileHandler('mmaMessages:sendMessage', '$mmaMessagesHandlers.sendMessage', mmaMessagesSendMessagePriority);
    $mmUserDelegateProvider.registerProfileHandler('mmaMessages:addContact', '$mmaMessagesHandlers.addContact', mmaMessagesAddContactPriority);
    $mmUserDelegateProvider.registerProfileHandler('mmaMessages:blockContact', '$mmaMessagesHandlers.blockContact', mmaMessagesBlockContactPriority);
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaMessages:index', '$mmaMessagesHandlers.indexLinksHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaMessages:discussion', '$mmaMessagesHandlers.discussionLinksHandler');
    $mmSettingsDelegateProvider.registerHandler('mmaMessages:preferences',
            '$mmaMessagesHandlers.preferences', mmaMessagesPreferencesPriority);
}])
.run(["$mmaMessages", "$mmEvents", "$state", "$mmAddonManager", "$mmUtil", "mmCoreEventLogin", "$mmCronDelegate", "$mmaMessagesSync", "mmCoreEventOnlineStatusChanged", "$mmSitesManager", function($mmaMessages, $mmEvents, $state, $mmAddonManager, $mmUtil, mmCoreEventLogin, $mmCronDelegate, $mmaMessagesSync,
            mmCoreEventOnlineStatusChanged, $mmSitesManager) {
    $mmEvents.on(mmCoreEventLogin, function() {
        $mmaMessages.invalidateEnabledCache();
    });
    var $mmPushNotificationsDelegate = $mmAddonManager.get('$mmPushNotificationsDelegate');
    if ($mmPushNotificationsDelegate) {
        $mmPushNotificationsDelegate.registerHandler('mmaMessages', function(notification) {
            if ($mmUtil.isFalseOrZero(notification.notif)) {
                $mmaMessages.isMessagingEnabledForSite(notification.site).then(function() {
                    $mmSitesManager.isFeatureDisabled('$mmSideMenuDelegate_mmaMessages', notification.site).then(function(disabled) {
                        if (disabled) {
                            return;
                        }
                        $mmaMessages.invalidateDiscussionsCache().finally(function() {
                            $state.go('redirect', {siteid: notification.site, state: 'site.messages'});
                        });
                    });
                });
                return true;
            }
        });
    }
    $mmCronDelegate.register('mmaMessagesSync', '$mmaMessagesHandlers.syncHandler');
    $mmCronDelegate.register('mmaMessagesMenu', '$mmaMessagesHandlers.sideMenuNav');
    $mmEvents.on(mmCoreEventOnlineStatusChanged, function(online) {
        if (online) {
            $mmaMessagesSync.syncAllDiscussions(undefined, true);
        }
    });
}]);

angular.module('mm.addons.notes', [])
.constant('mmaNotesPriority', 200)
.constant('mmaNotesAddNotePriority', 200)
.constant('mmaNotesComponent', 'mmaNotes')
.constant('mmaNotesAutomSyncedEvent', 'mma_notes_autom_synced')
.constant('mmaModNotesSyncTime', 300000)
.config(["$stateProvider", "$mmUserDelegateProvider", "$mmCoursesDelegateProvider", "mmaNotesPriority", "mmaNotesAddNotePriority", function($stateProvider, $mmUserDelegateProvider, $mmCoursesDelegateProvider, mmaNotesPriority, mmaNotesAddNotePriority) {
    $stateProvider
    .state('site.notes-types', {
        url: '/notes-types',
        views: {
            'site': {
                templateUrl: 'addons/notes/templates/types.html',
                controller: 'mmaNotesTypesCtrl'
            }
        },
        params: {
            course: null
        }
    })
    .state('site.notes-list', {
        url: '/notes-list',
        views: {
            'site': {
                templateUrl: 'addons/notes/templates/list.html',
                controller: 'mmaNotesListCtrl'
            }
        },
        params: {
            courseid: null,
            type: null
        }
    });
    $mmUserDelegateProvider.registerProfileHandler('mmaNotes:addNote', '$mmaNotesHandlers.addNote', mmaNotesAddNotePriority);
    $mmCoursesDelegateProvider.registerNavHandler('mmaNotes', '$mmaNotesHandlers.coursesNav', mmaNotesPriority);
}])
.run(["$mmCronDelegate", function($mmCronDelegate) {
    $mmCronDelegate.register('mmaNotes', '$mmaNotesHandlers.syncHandler');
}]);

angular.module('mm.addons.notifications', [])
.constant('mmaNotificationsListLimit', 20)
.constant('mmaNotificationsPriority', 800)
.constant('mmaNotificationsPreferencesPriority', 500)
.constant('mmaNotificationsReadChangedEvent', 'mma-notifications_read_changed')
.constant('mmaNotificationsReadCronEvent', 'mma-notifications_read_cron')
.config(["$stateProvider", "$mmSideMenuDelegateProvider", "mmaNotificationsPriority", "$mmSettingsDelegateProvider", "mmaNotificationsPreferencesPriority", function($stateProvider, $mmSideMenuDelegateProvider, mmaNotificationsPriority, $mmSettingsDelegateProvider,
            mmaNotificationsPreferencesPriority) {
    $stateProvider
    .state('site.notifications', {
        url: '/notifications',
        views: {
            'site': {
                templateUrl: 'addons/notifications/templates/list.html',
                controller: 'mmaNotificationsListCtrl'
            }
        }
    })
    .state('site.notifications-preferences', {
        url: '/notifications-preferences',
        views: {
            'site': {
                controller: 'mmaNotificationsPreferencesCtrl',
                templateUrl: 'addons/notifications/templates/preferences.html'
            }
        }
    });
    $mmSideMenuDelegateProvider.registerNavHandler('mmaNotifications', '$mmaNotificationsHandlers.sideMenuNav', mmaNotificationsPriority);
    $mmSettingsDelegateProvider.registerHandler('mmaNotifications:preferences',
            '$mmaNotificationsHandlers.preferences', mmaNotificationsPreferencesPriority);
}])
.run(["$log", "$mmaNotifications", "$mmUtil", "$state", "$mmAddonManager", "$mmCronDelegate", "$mmSitesManager", function($log, $mmaNotifications, $mmUtil, $state, $mmAddonManager, $mmCronDelegate, $mmSitesManager) {
    $log = $log.getInstance('mmaNotifications');
    var $mmPushNotificationsDelegate = $mmAddonManager.get('$mmPushNotificationsDelegate');
    if ($mmPushNotificationsDelegate) {
        $mmPushNotificationsDelegate.registerHandler('mmaNotifications', function(notification) {
            if ($mmUtil.isTrueOrOne(notification.notif)) {
                $mmaNotifications.isPluginEnabledForSite(notification.site).then(function() {
                    $mmSitesManager.isFeatureDisabled('$mmSideMenuDelegate_mmaNotifications', notification.site)
                            .then(function(disabled) {
                        if (disabled) {
                            return;
                        }
                        $mmaNotifications.invalidateNotificationsList().finally(function() {
                            $state.go('redirect', {siteid: notification.site, state: 'site.notifications'});
                        });
                    });
                });
                return true;
            }
        });
    }
    $mmCronDelegate.register('mmaNotificationsMenu', '$mmaNotificationsHandlers.sideMenuNav');
}]);

angular.module('mm.addons.participants', [])
.constant('mmaParticipantsListLimit', 50)
.constant('mmaParticipantsPriority', 600)
.config(["$stateProvider", "$mmCoursesDelegateProvider", "$mmContentLinksDelegateProvider", "mmaParticipantsPriority", function($stateProvider, $mmCoursesDelegateProvider, $mmContentLinksDelegateProvider, mmaParticipantsPriority) {
    $stateProvider
        .state('site.participants', {
            url: '/participants',
            views: {
                'site': {
                    controller: 'mmaParticipantsListCtrl',
                    templateUrl: 'addons/participants/templates/list.html'
                }
            },
            params: {
                course: null
            }
        });
    $mmCoursesDelegateProvider.registerNavHandler('mmaParticipants', '$mmaParticipantsHandlers.coursesNavHandler',
                mmaParticipantsPriority);
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaParticipants', '$mmaParticipantsHandlers.linksHandler');
}]);

angular.module('mm.addons.pushnotifications', [])
.constant('mmaPushNotificationsComponent', 'mmaPushNotifications')
.run(["$mmaPushNotifications", "$ionicPlatform", "$rootScope", "$mmEvents", "$mmLocalNotifications", "mmCoreEventLogin", "mmaPushNotificationsComponent", "mmCoreEventSiteDeleted", function($mmaPushNotifications, $ionicPlatform, $rootScope, $mmEvents, $mmLocalNotifications, mmCoreEventLogin,
            mmaPushNotificationsComponent, mmCoreEventSiteDeleted) {
    $ionicPlatform.ready(function() {
        $mmaPushNotifications.registerDevice();
    });
    $rootScope.$on('$cordovaPushV5:notificationReceived', function(e, notification) {
        $mmaPushNotifications.onMessageReceived(notification);
    });
    $mmEvents.on(mmCoreEventLogin, function() {
        $mmaPushNotifications.registerDeviceOnMoodle();
    });
    $mmEvents.on(mmCoreEventSiteDeleted, function(site) {
        $mmaPushNotifications.unregisterDeviceOnMoodle(site);
        $mmaPushNotifications.cleanSiteCounters(site.id);
    });
    $mmLocalNotifications.registerClick(mmaPushNotificationsComponent, $mmaPushNotifications.notificationClicked);
}]);

angular.module('mm.addons.remotestyles', [])
.constant('mmaRemoteStylesComponent', 'mmaRemoteStyles')
.config(["$mmInitDelegateProvider", "mmInitDelegateMaxAddonPriority", function($mmInitDelegateProvider, mmInitDelegateMaxAddonPriority) {
    $mmInitDelegateProvider.registerProcess('mmaRemoteStylesCurrent',
                '$mmaRemoteStyles._preloadCurrentSite', mmInitDelegateMaxAddonPriority + 250, true);
    $mmInitDelegateProvider.registerProcess('mmaRemoteStylesPreload', '$mmaRemoteStyles._preloadSites');
}])
.run(["$mmEvents", "mmCoreEventLogin", "mmCoreEventLogout", "mmCoreEventSiteAdded", "mmCoreEventSiteUpdated", "$mmaRemoteStyles", "$mmSite", "mmCoreEventSiteDeleted", function($mmEvents, mmCoreEventLogin, mmCoreEventLogout, mmCoreEventSiteAdded, mmCoreEventSiteUpdated, $mmaRemoteStyles,
            $mmSite, mmCoreEventSiteDeleted) {
    $mmEvents.on(mmCoreEventSiteAdded, function(siteId) {
        $mmaRemoteStyles.addSite(siteId);
    });
    $mmEvents.on(mmCoreEventSiteUpdated, function(siteId) {
        if (siteId === $mmSite.getId()) {
            $mmaRemoteStyles.load(siteId);
        }
    });
    $mmEvents.on(mmCoreEventLogin, $mmaRemoteStyles.enable);
    $mmEvents.on(mmCoreEventLogout, $mmaRemoteStyles.clear);
    $mmEvents.on(mmCoreEventSiteDeleted, function(site) {
        $mmaRemoteStyles.removeSite(site.id);
    });
}]);

angular.module('mm.addons.messageoutput_airnotifier', [])
.config(["$stateProvider", function($stateProvider) {
    $stateProvider
    .state('site.messageoutput-airnotifier-preferences', {
        url: '/messageoutput-airnotifier-preferences',
        params: {
        	title: null
        },
        views: {
            'site': {
                controller: 'mmaMessageOutputAirnotifierDevicesCtrl',
                templateUrl: 'addons/messageoutput/airnotifier/templates/devices.html'
            }
        }
    });
}])
.run(["$mmAddonManager", function($mmAddonManager) {
    var $mmaMessageOutputDelegate = $mmAddonManager.get('$mmaMessageOutputDelegate');
    if ($mmaMessageOutputDelegate) {
        $mmaMessageOutputDelegate.registerHandler('mmaMessageOutputAirnotifier', 'airnotifier',
                '$mmaMessageOutputAirnotifierHandlers.processorPreferences');
    }
}]);

angular.module('mm.addons.mod_book', ['mm.core'])
.constant('mmaModBookComponent', 'mmaModBook')
.config(["$stateProvider", function($stateProvider) {
    $stateProvider
    .state('site.mod_book', {
      url: '/mod_book',
      params: {
        module: null,
        courseid: null
      },
      views: {
        'site': {
          controller: 'mmaModBookIndexCtrl',
          templateUrl: 'addons/mod/book/templates/index.html'
        }
      }
    });
}])
.config(["$mmCourseDelegateProvider", "$mmCoursePrefetchDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmCoursePrefetchDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModBook', 'book', '$mmaModBookHandlers.courseContentHandler');
    $mmCoursePrefetchDelegateProvider.registerPrefetchHandler('mmaModBook', 'book', '$mmaModBookPrefetchHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModBook', '$mmaModBookHandlers.linksHandler');
}]);

angular.module('mm.addons.mod_assign', ['mm.core'])
.constant('mmaModAssignComponent', 'mmaModAssign')
.constant('mmaModAssignSubmissionComponent', 'mmaModAssignSubmission')
.constant('mmaModAssignSubmissionStatusNew', 'new')
.constant('mmaModAssignSubmissionStatusReopened', 'reopened')
.constant('mmaModAssignSubmissionStatusDraft', 'draft')
.constant('mmaModAssignSubmissionStatusSubmitted', 'submitted')
.constant('mmaModAssignAttemptReopenMethodNone', 'none')
.constant('mmaModAssignAttemptReopenMethodManual', 'manual')
.constant('mmaModAssignUnlimitedAttempts', -1)
.constant('mmaModAssignGradingStatusGraded', 'graded')
.constant('mmaModAssignGradingStatusNotGraded', 'notgraded')
.constant('mmaModMarkingWorkflowStateReleased', 'released')
.constant('mmaModAssignNeedGrading', 'needgrading')
.constant('mmaModAssignSubmissionInvalidatedEvent', 'mma_mod_assign_submission_invalidated')
.constant('mmaModAssignSubmissionSavedEvent', 'mma_mod_assign_submission_saved')
.constant('mmaModAssignFeedbackSavedEvent', 'mma_mod_assign_feedback_saved')
.constant('mmaModAssignSubmittedForGradingEvent', 'mma_mod_assign_submitted_for_grading')
.constant('mmaModAssignEventAutomSynced', 'mma_mod_assign_autom_synced')
.constant('mmaModAssignEventManualSynced', 'mma_mod_assign_manual_synced')
.constant('mmaModAssignEventSubmitGrade', 'mma_mod_assign_submit_grade')
.constant('mmaModAssignGradedEvent', 'mma_mod_assign_graded')
.constant('mmaModAssignSyncTime', 300000)
.config(["$stateProvider", function($stateProvider) {
    $stateProvider
    .state('site.mod_assign', {
        url: '/mod_assign',
        params: {
            module: null,
            courseid: null
        },
        views: {
            'site': {
                controller: 'mmaModAssignIndexCtrl',
                templateUrl: 'addons/mod/assign/templates/index.html'
            }
        }
    })
    .state('site.mod_assign-description', {
        url: '/mod_assign-description',
        params: {
            moduleid: null,
            description: null,
            files: null
        },
        views: {
            'site': {
                controller: 'mmaModAssignDescriptionCtrl',
                templateUrl: 'addons/mod/assign/templates/description.html'
            }
        }
    })
    .state('site.mod_assign-submission-list', {
        url: '/mod_assign-submission-list',
        params: {
            status: null,
            moduleid: null,
            modulename: null,
            courseid: null
        },
        views: {
            'site': {
                controller: 'mmaModAssignSubmissionListCtrl',
                templateUrl: 'addons/mod/assign/templates/submissionlist.html'
            }
        }
    })
    .state('site.mod_assign-submission', {
        url: '/mod_assign-submission',
        params: {
            submitid: null,
            blindid: null,
            moduleid: null,
            courseid: null,
            showSubmission: null
        },
        views: {
            'site': {
                controller: 'mmaModAssignSubmissionReviewCtrl',
                templateUrl: 'addons/mod/assign/templates/submissionreview.html'
            }
        }
    })
    .state('site.mod_assign-submission-edit', {
        url: '/mod_assign-submission-edit',
        params: {
            moduleid: null,
            courseid: null,
            userid: null,
            blindid: null
        },
        views: {
            'site': {
                controller: 'mmaModAssignEditCtrl',
                templateUrl: 'addons/mod/assign/templates/edit.html'
            }
        }
    })
    .state('site.mod_assign-feedback-edit', {
        url: '/mod_assign-feedback-edit',
        params: {
            assignid: null,
            userid: null,
            plugintype: null,
            assign: null,
            submission: null,
            plugin: null
        },
        views: {
            'site': {
                controller: 'mmaModAssignFeedbackEditCtrl',
                templateUrl: 'addons/mod/assign/templates/feedbackedit.html'
            }
        }
    });
}])
.config(["$mmCourseDelegateProvider", "$mmContentLinksDelegateProvider", "$mmCoursePrefetchDelegateProvider", function($mmCourseDelegateProvider, $mmContentLinksDelegateProvider, $mmCoursePrefetchDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModAssign', 'assign', '$mmaModAssignHandlers.courseContent');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModAssign', '$mmaModAssignHandlers.linksHandler');
    $mmCoursePrefetchDelegateProvider.registerPrefetchHandler('mmaModAssign', 'assign', '$mmaModAssignPrefetchHandler');
}])
.run(["$mmCronDelegate", function($mmCronDelegate) {
    $mmCronDelegate.register('mmaModAssign', '$mmaModAssignHandlers.syncHandler');
}]);
angular.module('mm.addons.mod_chat', [])
.constant('mmaChatPollInterval', 4000)
.constant('mmaModChatComponent', 'mmaModChat')
.config(["$stateProvider", function($stateProvider) {
    $stateProvider
    .state('site.mod_chat', {
        url: '/mod_chat',
        params: {
            module: null,
            courseid: null
        },
        views: {
            'site': {
                controller: 'mmaModChatIndexCtrl',
                templateUrl: 'addons/mod/chat/templates/index.html'
            }
        }
    })
    .state('site.mod_chat-chat', {
        url: '/mod_chat-chat',
        params: {
            chatid: null,
            courseid: null,
            title: null
        },
        views: {
            'site': {
                controller: 'mmaModChatChatCtrl',
                templateUrl: 'addons/mod/chat/templates/chat.html'
            }
        }
    });
}])
.config(["$mmCourseDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModChat', 'chat', '$mmaModChatHandlers.courseContent');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModChat', '$mmaModChatHandlers.linksHandler');
}]);
angular.module('mm.addons.mod_choice', ["chart.js"])
.constant('mmaModChoiceResultsNot', 0)
.constant('mmaModChoiceResultsAfterAnswer', 1)
.constant('mmaModChoiceResultsAfterClose', 2)
.constant('mmaModChoiceResultsAlways', 3)
.constant('mmaModChoiceComponent', 'mmaModChoice')
.constant('mmaModChoiceAutomSyncedEvent', 'mma-mod_choice_autom_synced')
.config(["$stateProvider", function($stateProvider) {
    $stateProvider
    .state('site.mod_choice', {
        url: '/mod_choice',
        params: {
            module: null,
            courseid: null
        },
        views: {
            'site': {
                controller: 'mmaModChoiceIndexCtrl',
                templateUrl: 'addons/mod/choice/templates/index.html'
            }
        }
    });
}])
.config(["$mmCourseDelegateProvider", "$mmContentLinksDelegateProvider", "$mmCoursePrefetchDelegateProvider", function($mmCourseDelegateProvider, $mmContentLinksDelegateProvider, $mmCoursePrefetchDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModChoice', 'choice', '$mmaModChoiceHandlers.courseContent');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModChoice', '$mmaModChoiceHandlers.linksHandler');
    $mmCoursePrefetchDelegateProvider.registerPrefetchHandler('mmaModChoice', 'choice', '$mmaModChoicePrefetchHandler');
}])
.run(["$mmCronDelegate", function($mmCronDelegate) {
    $mmCronDelegate.register('mmaModChoice', '$mmaModChoiceHandlers.syncHandler');
}]);

angular.module('mm.addons.mod_folder', ['mm.core'])
.constant('mmaModFolderComponent', 'mmaModFolder')
.config(["$stateProvider", function($stateProvider) {
    $stateProvider
    .state('site.mod_folder', {
      url: '/mod_folder',
      params: {
        module: null,
        courseid: null,
        sectionid: null,
        path: null
      },
      views: {
        'site': {
          controller: 'mmaModFolderIndexCtrl',
          templateUrl: 'addons/mod/folder/templates/index.html'
        }
      }
    });
}])
.config(["$mmCourseDelegateProvider", "$mmCoursePrefetchDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmCoursePrefetchDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModFolder', 'folder', '$mmaModFolderHandlers.courseContent');
    $mmCoursePrefetchDelegateProvider.registerPrefetchHandler('mmaModFolder', 'folder', '$mmaModFolderPrefetchHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModFolder', '$mmaModFolderHandlers.linksHandler');
}]);

angular.module('mm.addons.mod_forum', [])
.constant('mmaModForumDiscPerPage', 10)
.constant('mmaModForumComponent', 'mmaModForum')
.constant('mmaModForumNewDiscussionEvent', 'mma-mod_forum_new_discussion')
.constant('mmaModForumReplyDiscussionEvent', 'mma-mod_forum_reply_discussion')
.constant('mmaModForumAutomSyncedEvent', 'mma-mod_forum_autom_synced')
.constant('mmaModForumManualSyncedEvent', 'mma-mod_forum_manual_synced')
.constant('mmaModForumSyncTime', 300000)
.config(["$stateProvider", function($stateProvider) {
    $stateProvider
    .state('site.mod_forum', {
        url: '/mod_forum',
        params: {
            module: null,
            courseid: null
        },
        views: {
            'site': {
                controller: 'mmaModForumDiscussionsCtrl',
                templateUrl: 'addons/mod/forum/templates/discussions.html'
            }
        }
    })
    .state('site.mod_forum-discussion', {
        url: '/mod_forum-discussion',
        params: {
            discussionid: null,
            cid: null,
            forumid: null,
            cmid: null,
            trackposts: null,
            locked: null
        },
        views: {
            'site': {
                controller: 'mmaModForumDiscussionCtrl',
                templateUrl: 'addons/mod/forum/templates/discussion.html'
            }
        }
    })
    .state('site.mod_forum-newdiscussion', {
        url: '/mod_forum-newdiscussion',
        params: {
            cid: null,
            forumid: null,
            cmid: null,
            timecreated: null
        },
        views: {
            'site': {
                controller: 'mmaModForumNewDiscussionCtrl',
                templateUrl: 'addons/mod/forum/templates/newdiscussion.html'
            }
        }
    });
}])
.config(["$mmCourseDelegateProvider", "$mmContentLinksDelegateProvider", "$mmCoursePrefetchDelegateProvider", function($mmCourseDelegateProvider, $mmContentLinksDelegateProvider, $mmCoursePrefetchDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModForum', 'forum', '$mmaModForumHandlers.courseContent');
    $mmCoursePrefetchDelegateProvider.registerPrefetchHandler('mmaModForum', 'forum', '$mmaModForumPrefetchHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModForum:index', '$mmaModForumHandlers.indexLinksHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModForum:discussion', '$mmaModForumHandlers.discussionLinksHandler');
}])
.run(["$mmCronDelegate", function($mmCronDelegate) {
    $mmCronDelegate.register('mmaModForum', '$mmaModForumHandlers.syncHandler');
}]);

angular.module('mm.addons.mod_glossary', ['mm.core'])
.constant('mmaModGlossaryComponent', 'mmaModGlossary')
.constant('mmaModGlossaryAddEntryEvent', 'mma-mod_glossary_add_entry')
.constant('mmaModGlossaryAutomSyncedEvent', 'mma-mod_glossar_autom_synced')
.constant('mmaModGlossaryLimitEntriesNum', 25)
.constant('mmaModGlossaryLimitCategoriesNum', 20)
.constant('mmaModGlossaryShowAllCategories', 0)
.constant('mmaModGlossaryShowNotCategorised', -1)
.constant('mmaModGlossarySyncTime', 300000)
.config(["$stateProvider", function($stateProvider) {
    $stateProvider
    .state('site.mod_glossary', {
      url: '/mod_glossary',
      params: {
        module: null,
        courseid: null
      },
      views: {
        'site': {
          controller: 'mmaModGlossaryIndexCtrl',
          templateUrl: 'addons/mod/glossary/templates/index.html'
        }
      }
    })
    .state('site.mod_glossary-entry', {
      url: '/mod_glossary-entry',
      params: {
        cid: null,
        entryid: null
      },
      views: {
        'site': {
          controller: 'mmaModGlossaryEntryCtrl',
          templateUrl: 'addons/mod/glossary/templates/entry.html'
        }
      }
    })
    .state('site.mod_glossary-edit', {
        url: '/mod_glossary-edit',
        params: {
            module: null,
            cmid: null,
            glossary: null,
            glossaryid: null,
            courseid: null,
            entry: null
        },
        views: {
            'site': {
                controller: 'mmaModGlossaryEditCtrl',
                templateUrl: 'addons/mod/glossary/templates/edit.html'
            }
        }
    });
}])
.config(["$mmCourseDelegateProvider", "$mmContentLinksDelegateProvider", "$mmCoursePrefetchDelegateProvider", function($mmCourseDelegateProvider, $mmContentLinksDelegateProvider, $mmCoursePrefetchDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModGlossary', 'glossary', '$mmaModGlossaryHandlers.courseContent');
    $mmCoursePrefetchDelegateProvider.registerPrefetchHandler('mmaModGlossary', 'glossary', '$mmaModGlossaryPrefetchHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModGlossary:index', '$mmaModGlossaryHandlers.indexLinksHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModGlossary:entry', '$mmaModGlossaryHandlers.entryLinksHandler');
}])
.run(["$mmCronDelegate", function($mmCronDelegate) {
    $mmCronDelegate.register('mmaModGlossary', '$mmaModGlossaryHandlers.syncHandler');
}]);

angular.module('mm.addons.mod_imscp', ['mm.core'])
.constant('mmaModImscpComponent', 'mmaModImscp')
.config(["$stateProvider", function($stateProvider) {
    $stateProvider
    .state('site.mod_imscp', {
      url: '/mod_imscp',
      params: {
        module: null,
        courseid: null
      },
      views: {
        'site': {
          controller: 'mmaModImscpIndexCtrl',
          templateUrl: 'addons/mod/imscp/templates/index.html'
        }
      }
    });
}])
.config(["$mmCourseDelegateProvider", "$mmCoursePrefetchDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmCoursePrefetchDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModImscp', 'imscp', '$mmaModImscpHandlers.courseContent');
    $mmCoursePrefetchDelegateProvider.registerPrefetchHandler('mmaModImscp', 'imscp', '$mmaModImscpPrefetchHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModImscp', '$mmaModImscpHandlers.linksHandler');
}]);

angular.module('mm.addons.mod_label', ['mm.core'])
.config(["$mmCourseDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModLabel', 'label', '$mmaModLabelHandlers.courseContent');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModLabel', '$mmaModLabelHandlers.linksHandler');
}]);

angular.module('mm.addons.mod_lti', [])
.constant('mmaModLtiComponent', 'mmaModLti')
.config(["$stateProvider", function($stateProvider) {
    $stateProvider
    .state('site.mod_lti', {
        url: '/mod_lti',
        params: {
            module: null,
            courseid: null
        },
        views: {
            'site': {
                controller: 'mmaModLtiIndexCtrl',
                templateUrl: 'addons/mod/lti/templates/index.html'
            }
        }
    });
}])
.config(["$mmCourseDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModLti', 'lti', '$mmaModLtiHandlers.courseContent');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModLti', '$mmaModLtiHandlers.linksHandler');
}]);

angular.module('mm.addons.mod_page', ['mm.core'])
.constant('mmaModPageComponent', 'mmaModPage')
.config(["$stateProvider", function($stateProvider) {
    $stateProvider
    .state('site.mod_page', {
      url: '/mod_page',
      params: {
        module: null,
        courseid: null
      },
      views: {
        'site': {
          controller: 'mmaModPageIndexCtrl',
          templateUrl: 'addons/mod/page/templates/index.html'
        }
      }
    });
}])
.config(["$mmCourseDelegateProvider", "$mmCoursePrefetchDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmCoursePrefetchDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModPage', 'page', '$mmaModPageHandlers.courseContent');
    $mmCoursePrefetchDelegateProvider.registerPrefetchHandler('mmaModPage', 'page', '$mmaModPagePrefetchHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModPage', '$mmaModPageHandlers.linksHandler');
}]);

angular.module('mm.addons.mod_quiz', ['mm.core'])
.constant('mmaModQuizComponent', 'mmaModQuiz')
.constant('mmaModQuizCheckChangesInterval', 5000)
.constant('mmaModQuizComponent', 'mmaModQuiz')
.constant('mmaModQuizEventAttemptFinished', 'mma_mod_quiz_attempt_finished')
.constant('mmaModQuizEventAutomSynced', 'mma_mod_quiz_autom_synced')
.constant('mmaModQuizSyncTime', 300000)
.config(["$stateProvider", function($stateProvider) {
    $stateProvider
    .state('site.mod_quiz', {
      url: '/mod_quiz',
      params: {
        module: null,
        courseid: null
      },
      views: {
        'site': {
          controller: 'mmaModQuizIndexCtrl',
          templateUrl: 'addons/mod/quiz/templates/index.html'
        }
      }
    })
    .state('site.mod_quiz-attempt', {
      url: '/mod_quiz-attempt',
      params: {
        courseid: null,
        quizid: null,
        attemptid: null
      },
      views: {
        'site': {
          controller: 'mmaModQuizAttemptCtrl',
          templateUrl: 'addons/mod/quiz/templates/attempt.html'
        }
      }
    })
    .state('site.mod_quiz-player', {
      url: '/mod_quiz-player',
      params: {
        courseid: null,
        quizid: null,
        moduleurl: null
      },
      views: {
        'site': {
          controller: 'mmaModQuizPlayerCtrl',
          templateUrl: 'addons/mod/quiz/templates/player.html'
        }
      }
    })
    .state('site.mod_quiz-review', {
      url: '/mod_quiz-review',
      params: {
        courseid: null,
        quizid: null,
        attemptid: null,
        page: -1
      },
      views: {
        'site': {
          controller: 'mmaModQuizReviewCtrl',
          templateUrl: 'addons/mod/quiz/templates/review.html'
        }
      }
    });
}])
.config(["$mmCourseDelegateProvider", "$mmContentLinksDelegateProvider", "$mmCoursePrefetchDelegateProvider", function($mmCourseDelegateProvider, $mmContentLinksDelegateProvider, $mmCoursePrefetchDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModQuiz', 'quiz', '$mmaModQuizHandlers.courseContentHandler');
    $mmCoursePrefetchDelegateProvider.registerPrefetchHandler('mmaModQuiz', 'quiz', '$mmaModQuizPrefetchHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModQuiz:index', '$mmaModQuizHandlers.indexLinksHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModQuiz:grade', '$mmaModQuizHandlers.gradeLinksHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModQuiz:review', '$mmaModQuizHandlers.reviewLinksHandler');
}])
.run(["$mmCronDelegate", function($mmCronDelegate) {
    $mmCronDelegate.register('mmaModQuiz', '$mmaModQuizHandlers.syncHandler');
}]);

angular.module('mm.addons.mod_resource', ['mm.core'])
.constant('mmaModResourceComponent', 'mmaModResource')
.config(["$stateProvider", function($stateProvider) {
    $stateProvider
    .state('site.mod_resource', {
      url: '/mod_resource',
      params: {
        module: null,
        courseid: null
      },
      views: {
        'site': {
          controller: 'mmaModResourceIndexCtrl',
          templateUrl: 'addons/mod/resource/templates/index.html'
        }
      }
    });
}])
.config(["$mmCourseDelegateProvider", "$mmCoursePrefetchDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmCoursePrefetchDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModResource', 'resource', '$mmaModResourceHandlers.courseContent');
    $mmCoursePrefetchDelegateProvider.registerPrefetchHandler('mmaModResource', 'resource', '$mmaModResourcePrefetchHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModResource', '$mmaModResourceHandlers.linksHandler');
}]);

angular.module('mm.addons.mod_scorm', ['mm.core'])
.constant('mmaModScormComponent', 'mmaModScorm')
.constant('mmaModScormEventLaunchNextSco', 'mma_mod_scorm_launch_next_sco')
.constant('mmaModScormEventLaunchPrevSco', 'mma_mod_scorm_launch_prev_sco')
.constant('mmaModScormEventUpdateToc', 'mma_mod_scorm_update_toc')
.constant('mmaModScormEventGoOffline', 'mma_mod_scorm_go_offline')
.constant('mmaModScormEventAutomSynced', 'mma_mod_scorm_autom_synced')
.constant('mmaModScormSyncTime', 300000)
.config(["$stateProvider", function($stateProvider) {
    $stateProvider
    .state('site.mod_scorm', {
      url: '/mod_scorm',
      params: {
        module: null,
        courseid: null
      },
      views: {
        'site': {
          controller: 'mmaModScormIndexCtrl',
          templateUrl: 'addons/mod/scorm/templates/index.html'
        }
      }
    })
    .state('site.mod_scorm-player', {
      url: '/mod_scorm-player',
      params: {
        scorm: null,
        mode: null,
        newAttempt: false,
        organizationId: null,
        scoId: null
      },
      views: {
        'site': {
          controller: 'mmaModScormPlayerCtrl',
          templateUrl: 'addons/mod/scorm/templates/player.html'
        }
      }
    });
}])
.config(["$mmCourseDelegateProvider", "$mmCoursePrefetchDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmCoursePrefetchDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModScorm', 'scorm', '$mmaModScormHandlers.courseContent');
    $mmCoursePrefetchDelegateProvider.registerPrefetchHandler('mmaModScorm', 'scorm', '$mmaModScormPrefetchHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModScorm:index', '$mmaModScormHandlers.indexLinksHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModScorm:grade', '$mmaModScormHandlers.gradeLinksHandler');
}])
.run(["$mmCronDelegate", function($mmCronDelegate) {
    $mmCronDelegate.register('mmaModScorm', '$mmaModScormHandlers.syncHandler');
}]);

angular.module('mm.addons.mod_survey', [])
.constant('mmaModSurveyComponent', 'mmaModSurvey')
.constant('mmaModSurveyAutomSyncedEvent', 'mma_mod_survey_autom_synced')
.constant('mmaModSurveySyncTime', 300000)
.config(["$stateProvider", function($stateProvider) {
    $stateProvider
    .state('site.mod_survey', {
        url: '/mod_survey',
        params: {
            module: null,
            courseid: null
        },
        views: {
            'site': {
                controller: 'mmaModSurveyIndexCtrl',
                templateUrl: 'addons/mod/survey/templates/index.html'
            }
        }
    });
}])
.config(["$mmCourseDelegateProvider", "$mmContentLinksDelegateProvider", "$mmCoursePrefetchDelegateProvider", function($mmCourseDelegateProvider, $mmContentLinksDelegateProvider, $mmCoursePrefetchDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModSurvey', 'survey', '$mmaModSurveyHandlers.courseContent');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModSurvey', '$mmaModSurveyHandlers.linksHandler');
    $mmCoursePrefetchDelegateProvider.registerPrefetchHandler('mmaModSurvey', 'survey', '$mmaModSurveyPrefetchHandler');
}])
.run(["$mmCronDelegate", function($mmCronDelegate) {
    $mmCronDelegate.register('mmaModSurvey', '$mmaModSurveyHandlers.syncHandler');
}]);

angular.module('mm.addons.mod_url', ['mm.core'])
.constant('mmaModUrlComponent', 'mmaModUrl')
.config(["$stateProvider", function($stateProvider) {
    $stateProvider
    .state('site.mod_url', {
      url: '/mod_url',
      params: {
        module: null,
        courseid: null
      },
      views: {
        'site': {
          controller: 'mmaModUrlIndexCtrl',
          templateUrl: 'addons/mod/url/templates/index.html'
        }
      }
    });
}])
.config(["$mmCourseDelegateProvider", "$mmContentLinksDelegateProvider", function($mmCourseDelegateProvider, $mmContentLinksDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModUrl', 'url', '$mmaModUrlHandlers.courseContentHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModUrl', '$mmaModUrlHandlers.linksHandler');
}]);

angular.module('mm.addons.mod_wiki', [])
.constant('mmaModWikiSubwikiPagesLoaded', 'mma_mod_wiki_subwiki_pages_loaded')
.constant('mmaModWikiPageCreatedEvent', 'mma_mod_wiki_page_created')
.constant('mmaModWikiManualSyncedEvent', 'mma_mod_wiki_manual_synced')
.constant('mmaModWikiSubwikiAutomSyncedEvent', 'mma_mod_wiki_subwiki_autom_synced')
.constant('mmaModWikiComponent', 'mmaModWiki')
.constant('mmaModWikiRenewLockTimeout', 30)
.constant('mmaModWikiSyncTime', 300000)
.config(["$stateProvider", function($stateProvider) {
    $stateProvider
    .state('site.mod_wiki', {
        url: '/mod_wiki',
        params: {
            module: null,
            moduleid: null,
            courseid: null,
            pageid: null,
            pagetitle: null,
            wikiid: null,
            subwikiid: null,
            userid: null,
            groupid: null,
            action: null
        },
        views: {
            'site': {
                controller: 'mmaModWikiIndexCtrl',
                templateUrl: 'addons/mod/wiki/templates/index.html'
            }
        }
    })
    .state('site.mod_wiki-edit', {
        url: '/mod_wiki-edit',
        params: {
            module: null,
            courseid: null,
            pageid: null,
            pagetitle: null,
            subwikiid: null,
            wikiid: null,
            userid: null,
            groupid: null,
            section: null
        },
        views: {
            'site': {
                controller: 'mmaModWikiEditCtrl',
                templateUrl: 'addons/mod/wiki/templates/edit.html'
            }
        }
    });
}])
.config(["$mmCourseDelegateProvider", "$mmContentLinksDelegateProvider", "$mmCoursePrefetchDelegateProvider", function($mmCourseDelegateProvider, $mmContentLinksDelegateProvider, $mmCoursePrefetchDelegateProvider) {
    $mmCourseDelegateProvider.registerContentHandler('mmaModWiki', 'wiki', '$mmaModWikiHandlers.courseContent');
    $mmCoursePrefetchDelegateProvider.registerPrefetchHandler('mmaModWiki', 'wiki', '$mmaModWikiPrefetchHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModWiki:index', '$mmaModWikiHandlers.indexLinksHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModWiki:pagemap', '$mmaModWikiHandlers.pageMapLinksHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModWiki:create', '$mmaModWikiHandlers.createLinksHandler');
    $mmContentLinksDelegateProvider.registerLinkHandler('mmaModWiki:edit', '$mmaModWikiHandlers.editLinksHandler');
}])
.run(["$mmEvents", "mmCoreEventLogout", "$mmaModWiki", "$mmCronDelegate", function($mmEvents, mmCoreEventLogout, $mmaModWiki, $mmCronDelegate) {
    $mmEvents.on(mmCoreEventLogout, $mmaModWiki.clearSubwikiList);
    $mmCronDelegate.register('mmaModWiki', '$mmaModWikiHandlers.syncHandler');
}]);

angular.module('mm.addons.qbehaviour_adaptive', ['mm.core'])
.config(["$mmQuestionBehaviourDelegateProvider", function($mmQuestionBehaviourDelegateProvider) {
    $mmQuestionBehaviourDelegateProvider.registerHandler('mmaQbehaviourAdaptive', 'adaptive', '$mmaQbehaviourAdaptiveHandler');
}]);

angular.module('mm.addons.qbehaviour_adaptivenopenalty', ['mm.core'])
.config(["$mmQuestionBehaviourDelegateProvider", function($mmQuestionBehaviourDelegateProvider) {
    $mmQuestionBehaviourDelegateProvider.registerHandler('mmaQbehaviourAdaptiveNoPenalty', 'adaptivenopenalty',
    			'$mmaQbehaviourAdaptiveNoPenaltyHandler');
}]);

angular.module('mm.addons.qbehaviour_deferredfeedback', ['mm.core'])
.config(["$mmQuestionBehaviourDelegateProvider", function($mmQuestionBehaviourDelegateProvider) {
    $mmQuestionBehaviourDelegateProvider.registerHandler('mmaQbehaviourDeferredFeedback', 'deferredfeedback',
    			'$mmaQbehaviourDeferredFeedbackHandler');
}]);

angular.module('mm.addons.qbehaviour_deferredcbm', ['mm.core'])
.config(["$mmQuestionBehaviourDelegateProvider", function($mmQuestionBehaviourDelegateProvider) {
    $mmQuestionBehaviourDelegateProvider.registerHandler('mmaQbehaviourDeferredCBM', 'deferredcbm',
    			'$mmaQbehaviourDeferredCBMHandler');
}]);

angular.module('mm.addons.qbehaviour_immediatecbm', ['mm.core'])
.config(["$mmQuestionBehaviourDelegateProvider", function($mmQuestionBehaviourDelegateProvider) {
    $mmQuestionBehaviourDelegateProvider.registerHandler('mmaQbehaviourImmediateCBM', 'immediatecbm',
    			'$mmaQbehaviourImmediateCBMHandler');
}]);

angular.module('mm.addons.qbehaviour_immediatefeedback', ['mm.core'])
.config(["$mmQuestionBehaviourDelegateProvider", function($mmQuestionBehaviourDelegateProvider) {
    $mmQuestionBehaviourDelegateProvider.registerHandler('mmaQbehaviourImmediateFeedback', 'immediatefeedback',
    			'$mmaQbehaviourImmediateFeedbackHandler');
}]);

angular.module('mm.addons.qbehaviour_informationitem', ['mm.core'])
.config(["$mmQuestionBehaviourDelegateProvider", function($mmQuestionBehaviourDelegateProvider) {
    $mmQuestionBehaviourDelegateProvider.registerHandler('mmaQbehaviourInformationItem', 'informationitem',
    			'$mmaQbehaviourInformationItemHandler');
}]);

angular.module('mm.addons.qbehaviour_interactive', ['mm.core'])
.config(["$mmQuestionBehaviourDelegateProvider", function($mmQuestionBehaviourDelegateProvider) {
    $mmQuestionBehaviourDelegateProvider.registerHandler('mmaQbehaviourInteractive', 'interactive',
    			'$mmaQbehaviourInteractiveHandler');
}]);

angular.module('mm.addons.qbehaviour_interactivecountback', ['mm.core'])
.config(["$mmQuestionBehaviourDelegateProvider", function($mmQuestionBehaviourDelegateProvider) {
    $mmQuestionBehaviourDelegateProvider.registerHandler('mmaQbehaviourInteractiveCountback', 'interactivecountback',
    			'$mmaQbehaviourInteractiveCountbackHandler');
}]);

angular.module('mm.addons.qbehaviour_manualgraded', ['mm.core'])
.config(["$mmQuestionBehaviourDelegateProvider", function($mmQuestionBehaviourDelegateProvider) {
    $mmQuestionBehaviourDelegateProvider.registerHandler('mmaQbehaviourManualGraded', 'manualgraded',
    			'$mmaQbehaviourManualGradedHandler');
}]);

angular.module('mm.addons.qtype_calculated', ['mm.core'])
.config(["$mmQuestionDelegateProvider", function($mmQuestionDelegateProvider) {
    $mmQuestionDelegateProvider.registerHandler('mmaQtypeCalculated', 'qtype_calculated', '$mmaQtypeCalculatedHandler');
}]);

angular.module('mm.addons.qtype_calculatedsimple', ['mm.core'])
.config(["$mmQuestionDelegateProvider", function($mmQuestionDelegateProvider) {
    $mmQuestionDelegateProvider.registerHandler('mmaQtypeCalculatedSimple', 'qtype_calculatedsimple',
    												'$mmaQtypeCalculatedSimpleHandler');
}]);

angular.module('mm.addons.qtype_calculatedmulti', ['mm.core'])
.config(["$mmQuestionDelegateProvider", function($mmQuestionDelegateProvider) {
    $mmQuestionDelegateProvider.registerHandler('mmaQtypeCalculatedMulti', 'qtype_calculatedmulti',
    												'$mmaQtypeCalculatedMultiHandler');
}]);

angular.module('mm.addons.qtype_ddimageortext', ['mm.core'])
.config(["$mmQuestionDelegateProvider", function($mmQuestionDelegateProvider) {
    $mmQuestionDelegateProvider.registerHandler('mmaQtypeDdimageortext', 'qtype_ddimageortext', '$mmaQtypeDdimageortextHandler');
}]);

angular.module('mm.addons.qtype_ddmarker', ['mm.core'])
.config(["$mmQuestionDelegateProvider", function($mmQuestionDelegateProvider) {
    $mmQuestionDelegateProvider.registerHandler('mmaQtypeDdmarker', 'qtype_ddmarker', '$mmaQtypeDdmarkerHandler');
}]);

angular.module('mm.addons.qtype_ddwtos', ['mm.core'])
.config(["$mmQuestionDelegateProvider", function($mmQuestionDelegateProvider) {
    $mmQuestionDelegateProvider.registerHandler('mmaQtypeDdwtos', 'qtype_ddwtos', '$mmaQtypeDdwtosHandler');
}]);

angular.module('mm.addons.qtype_description', ['mm.core'])
.config(["$mmQuestionDelegateProvider", function($mmQuestionDelegateProvider) {
    $mmQuestionDelegateProvider.registerHandler('mmaQtypeDescription', 'qtype_description', '$mmaQtypeDescriptionHandler');
}]);

angular.module('mm.addons.qtype_essay', ['mm.core'])
.config(["$mmQuestionDelegateProvider", function($mmQuestionDelegateProvider) {
    $mmQuestionDelegateProvider.registerHandler('mmaQtypeEssay', 'qtype_essay', '$mmaQtypeEssayHandler');
}]);

angular.module('mm.addons.qtype_gapselect', ['mm.core'])
.config(["$mmQuestionDelegateProvider", function($mmQuestionDelegateProvider) {
    $mmQuestionDelegateProvider.registerHandler('mmaQtypeGapSelect', 'qtype_gapselect', '$mmaQtypeGapSelectHandler');
}]);

angular.module('mm.addons.qtype_match', ['mm.core'])
.config(["$mmQuestionDelegateProvider", function($mmQuestionDelegateProvider) {
    $mmQuestionDelegateProvider.registerHandler('mmaQtypeMatch', 'qtype_match', '$mmaQtypeMatchHandler');
}]);

angular.module('mm.addons.qtype_multianswer', ['mm.core'])
.config(["$mmQuestionDelegateProvider", function($mmQuestionDelegateProvider) {
    $mmQuestionDelegateProvider.registerHandler('mmaQtypeMultianswer', 'qtype_multianswer', '$mmaQtypeMultianswerHandler');
}]);

angular.module('mm.addons.qtype_numerical', ['mm.core'])
.config(["$mmQuestionDelegateProvider", function($mmQuestionDelegateProvider) {
    $mmQuestionDelegateProvider.registerHandler('mmaQtypeNumerical', 'qtype_numerical', '$mmaQtypeNumericalHandler');
}]);

angular.module('mm.addons.qtype_multichoice', ['mm.core'])
.config(["$mmQuestionDelegateProvider", function($mmQuestionDelegateProvider) {
    $mmQuestionDelegateProvider.registerHandler('mmaQtypeMultichoice', 'qtype_multichoice', '$mmaQtypeMultichoiceHandler');
}]);

angular.module('mm.addons.qtype_randomsamatch', ['mm.core'])
.config(["$mmQuestionDelegateProvider", function($mmQuestionDelegateProvider) {
    $mmQuestionDelegateProvider.registerHandler('mmaQtypeRandomSaMatch', 'qtype_randomsamatch', '$mmaQtypeRandomSaMatchHandler');
}]);

angular.module('mm.addons.qtype_shortanswer', ['mm.core'])
.config(["$mmQuestionDelegateProvider", function($mmQuestionDelegateProvider) {
    $mmQuestionDelegateProvider.registerHandler('mmaQtypeShortAnswer', 'qtype_shortanswer', '$mmaQtypeShortAnswerHandler');
}]);

angular.module('mm.addons.qtype_truefalse', ['mm.core'])
.config(["$mmQuestionDelegateProvider", function($mmQuestionDelegateProvider) {
    $mmQuestionDelegateProvider.registerHandler('mmaQtypeTruefalse', 'qtype_truefalse', '$mmaQtypeTruefalseHandler');
}]);

angular.module('mm.addons.userprofilefield_checkbox', ['mm.core'])
.config(["$mmUserProfileFieldsDelegateProvider", function($mmUserProfileFieldsDelegateProvider) {
    $mmUserProfileFieldsDelegateProvider.registerHandler('mmaUserProfileFieldCheckbox',
    		'checkbox', '$mmaUserProfileFieldCheckboxHandler');
}]);

angular.module('mm.addons.userprofilefield_datetime', ['mm.core'])
.config(["$mmUserProfileFieldsDelegateProvider", function($mmUserProfileFieldsDelegateProvider) {
    $mmUserProfileFieldsDelegateProvider.registerHandler('mmaUserProfileFieldDatetime',
    		'datetime', '$mmaUserProfileFieldDatetimeHandler');
}]);

angular.module('mm.addons.userprofilefield_menu', ['mm.core'])
.config(["$mmUserProfileFieldsDelegateProvider", function($mmUserProfileFieldsDelegateProvider) {
    $mmUserProfileFieldsDelegateProvider.registerHandler('mmaUserProfileFieldMenu',
    		'menu', '$mmaUserProfileFieldMenuHandler');
}]);

angular.module('mm.addons.userprofilefield_text', ['mm.core'])
.config(["$mmUserProfileFieldsDelegateProvider", function($mmUserProfileFieldsDelegateProvider) {
    $mmUserProfileFieldsDelegateProvider.registerHandler('mmaUserProfileFieldText',
    		'text', '$mmaUserProfileFieldTextHandler');
}]);

angular.module('mm.addons.userprofilefield_textarea', ['mm.core'])
.config(["$mmUserProfileFieldsDelegateProvider", function($mmUserProfileFieldsDelegateProvider) {
    $mmUserProfileFieldsDelegateProvider.registerHandler('mmaUserProfileFieldTextarea',
    		'textarea', '$mmaUserProfileFieldTextareaHandler');
}]);

angular.module('mm.addons.mod_assign')
.directive('mmaModAssignFeedbackFile', ["$mmaModAssign", function($mmaModAssign) {
    return {
        restrict: 'A',
        priority: 100,
        templateUrl: 'addons/mod/assign/feedback/file/template.html',
        link: function(scope) {
            if (!scope.plugin) {
                return;
            }
            scope.files = $mmaModAssign.getSubmissionPluginAttachments(scope.plugin);
        }
    };
}]);

angular.module('mm.addons.mod_assign')
.factory('$mmaModAssignFeedbackFileHandler', ["$mmaModAssign", "$mmFilepool", "$q", "mmaModAssignComponent", function($mmaModAssign, $mmFilepool, $q, mmaModAssignComponent) {
    var self = {};
        self.isEnabled = function() {
        return true;
    };
        self.getDirectiveName = function() {
        return 'mma-mod-assign-feedback-file';
    };
        self.getPluginFiles = function(assign, submission, plugin, siteId) {
        return $mmaModAssign.getSubmissionPluginAttachments(plugin);
    };
    return self;
}])
.run(["$mmAddonManager", function($mmAddonManager) {
    var $mmaModAssignFeedbackDelegate = $mmAddonManager.get('$mmaModAssignFeedbackDelegate');
    if ($mmaModAssignFeedbackDelegate) {
        $mmaModAssignFeedbackDelegate.registerHandler('mmaModAssignFeedbackFile', 'file', '$mmaModAssignFeedbackFileHandler');
    }
}]);

angular.module('mm.addons.mod_assign')
.directive('mmaModAssignFeedbackEditpdf', ["$mmaModAssign", function($mmaModAssign) {
    return {
        restrict: 'A',
        priority: 100,
        templateUrl: 'addons/mod/assign/feedback/editpdf/template.html',
        link: function(scope) {
            if (!scope.plugin) {
                return;
            }
            scope.files = $mmaModAssign.getSubmissionPluginAttachments(scope.plugin);
        }
    };
}]);

angular.module('mm.addons.mod_assign')
.factory('$mmaModAssignFeedbackEditpdfHandler', ["$mmaModAssign", "$mmFilepool", "$q", "mmaModAssignComponent", function($mmaModAssign, $mmFilepool, $q, mmaModAssignComponent) {
    var self = {};
        self.isEnabled = function() {
        return true;
    };
        self.getDirectiveName = function() {
        return 'mma-mod-assign-feedback-editpdf';
    };
        self.getPluginFiles = function(assign, submission, plugin, siteId) {
        return $mmaModAssign.getSubmissionPluginAttachments(plugin);
    };
    return self;
}])
.run(["$mmAddonManager", function($mmAddonManager) {
    var $mmaModAssignFeedbackDelegate = $mmAddonManager.get('$mmaModAssignFeedbackDelegate');
    if ($mmaModAssignFeedbackDelegate) {
        $mmaModAssignFeedbackDelegate.registerHandler('mmaModAssignFeedbackEditpdf', 'editpdf',
                '$mmaModAssignFeedbackEditpdfHandler');
    }
}]);

angular.module('mm.addons.mod_assign')
.directive('mmaModAssignFeedbackComments', ["$mmaModAssign", "$mmText", "$mmUtil", "$q", "$mmaModAssignFeedbackCommentsHandler", "$mmEvents", "mmaModAssignFeedbackSavedEvent", "$mmSite", "$mmaModAssignOffline", function($mmaModAssign, $mmText, $mmUtil, $q, $mmaModAssignFeedbackCommentsHandler,
        $mmEvents, mmaModAssignFeedbackSavedEvent, $mmSite, $mmaModAssignOffline) {
    function getContents(scope, rteEnabled) {
        var draft = $mmaModAssignFeedbackCommentsHandler.getDraft(scope.assign.id, scope.userid);
        if (!draft) {
            return $mmaModAssignOffline.getSubmissionGrade(scope.assign.id, scope.userid).catch(function() {
            }).then(function(offlineData) {
                if (offlineData && offlineData.plugindata && offlineData.plugindata.assignfeedbackcomments_editor) {
                    scope.isSent = false;
                    $mmaModAssignFeedbackCommentsHandler.saveDraft(scope.assign.id, scope.userid,
                        offlineData.plugindata.assignfeedbackcomments_editor);
                    return offlineData.plugindata.assignfeedbackcomments_editor.text;
                }
                scope.isSent = true;
                return $mmaModAssign.getSubmissionPluginText(scope.plugin, scope.edit && !rteEnabled);
            });
        } else {
            scope.isSent = false;
        }
        return $q.when(draft.text);
    }
    return {
        restrict: 'A',
        priority: 100,
        templateUrl: 'addons/mod/assign/feedback/comments/template.html',
        link: function(scope, element, attributes) {
            var obsSaved;
            if (!scope.plugin) {
                return;
            }
            if (scope.edit) {
                promise = $mmUtil.isRichTextEditorEnabled();
            } else {
                promise = $q.when(false);
            }
            promise.then(function(enabled) {
                rteEnabled = enabled;
                return getContents(scope, rteEnabled);
            }).then(function(text) {
                scope.model = {
                    text: text
                };
                scope.plugin.originalText = text;
                if (!scope.canEdit && !scope.edit) {
                    angular.element(element).on('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        if (scope.model.text && scope.model.text != "") {
                            $mmText.expandText(scope.plugin.name, scope.model.text, false, scope.assignComponent,
                                scope.assign.cmid);
                        }
                    });
                }
                if (!scope.edit) {
                    obsSaved = $mmEvents.on(mmaModAssignFeedbackSavedEvent, function(data) {
                        if (scope.plugin.type ==  data.pluginType && scope.assign && data.assignmentId == scope.assign.id &&
                                data.userId == scope.userid && data.siteId == $mmSite.getId()) {
                            return getContents(scope, rteEnabled).then(function(text) {
                                scope.model.text = text;
                            });
                        }
                    });
                    scope.$on('$destroy', function() {
                        obsSaved && obsSaved.off && obsSaved.off();
                    });
                }
                scope.firstRender = function() {
                    scope.plugin.originalText = scope.model.text;
                };
            });
        }
    };
}]);

angular.module('mm.addons.mod_assign')
.factory('$mmaModAssignFeedbackCommentsHandler', ["$mmText", "$mmSite", "$mmUtil", function($mmText, $mmSite, $mmUtil) {
    var self = {},
        drafts = {};
        self.isEnabled = function() {
        return true;
    };
        self.isEnabledForEdit = function() {
        return true;
    };
        self.getDirectiveName = function() {
        return 'mma-mod-assign-feedback-comments';
    };
        self.prepareFeedbackData = function(assignId, userId, pluginData, siteId) {
        var draft = self.getDraft(assignId, userId, siteId);
        if (draft) {
            return $mmUtil.isRichTextEditorEnabled().then(function(enabled) {
                if (!enabled) {
                    draft.text = $mmText.formatHtmlLines(draft.text);
                }
                pluginData.assignfeedbackcomments_editor = draft;
            });
        }
    };
        self.getFeedbackDataToDraft = function(plugin, inputData) {
        return {
            text: getTextToSubmit(plugin, inputData),
            format: 1
        };
    };
        self.hasDataChanged = function(assign, plugin, inputData) {
        if (typeof plugin.originalText != 'undefined') {
            return plugin.originalText != inputData.assignfeedbackcomments_editor;
        } else {
            return false;
        }
    };
        self.hasDraftData = function(assignId, userId, siteId) {
        var draft = self.getDraft(assignId, userId, siteId);
        if (draft) {
            return true;
        }
        return false;
    };
        function getTextToSubmit(plugin, inputData) {
        var text = inputData.assignfeedbackcomments_editor,
            files = plugin.fileareas && plugin.fileareas[0] ? plugin.fileareas[0].files : [];
        return $mmText.restorePluginfileUrls(text, files);
    }
        self.getDraft = function(assignId, userId, siteId) {
        var id = getDraftId(assignId, userId, siteId);
        if (typeof drafts[id] != 'undefined') {
            return drafts[id];
        }
        return false;
    };
        self.discardDraft = function(assignId, userId, siteId) {
        var id = getDraftId(assignId, userId, siteId);
        if (typeof drafts[id] != 'undefined') {
            delete drafts[id];
        }
    };
        self.saveDraft = function(assignId, userId, data, siteId) {
        if (data) {
            var id = getDraftId(assignId, userId, siteId);
            drafts[id] = data;
        }
    };
        function getDraftId(assignId, userId, siteId) {
        siteId = siteId || $mmSite.getId();
        return siteId + '#' + assignId + '#' + userId;
    }
    return self;
}])
.run(["$mmAddonManager", function($mmAddonManager) {
    var $mmaModAssignFeedbackDelegate = $mmAddonManager.get('$mmaModAssignFeedbackDelegate');
    if ($mmaModAssignFeedbackDelegate) {
        $mmaModAssignFeedbackDelegate.registerHandler('mmaModAssignFeedbackComments', 'comments',
                '$mmaModAssignFeedbackCommentsHandler');
    }
}]);

angular.module('mm.addons.mod_assign')
.directive('mmaModAssignSubmissionFile', ["$mmaModAssign", "$mmaModAssignSubmissionFileSession", "$mmaModAssignHelper", "$mmaModAssignOffline", "mmaModAssignSubmissionFileName", "$mmFileUploaderHelper", "$q", function($mmaModAssign, $mmaModAssignSubmissionFileSession, $mmaModAssignHelper,
            $mmaModAssignOffline, mmaModAssignSubmissionFileName, $mmFileUploaderHelper, $q) {
    return {
        restrict: 'A',
        priority: 100,
        templateUrl: 'addons/mod/assign/submission/file/template.html',
        link: function(scope) {
            if (!scope.plugin) {
                return;
            }
            $mmaModAssignOffline.getSubmission(scope.assign.id).catch(function() {
            }).then(function(offlineData) {
                if (offlineData && offlineData.plugindata && offlineData.plugindata.files_filemanager) {
                    var promise;
                    if (offlineData.plugindata.files_filemanager.offline) {
                        promise = $mmaModAssignHelper.getStoredSubmissionFiles(scope.assign.id, mmaModAssignSubmissionFileName);
                    } else {
                        promise = $q.when([]);
                    }
                    return promise.then(function(offlineFiles) {
                        var onlineFiles = offlineData.plugindata.files_filemanager.online || [];
                        offlineFiles = $mmFileUploaderHelper.markOfflineFiles(offlineFiles);
                        scope.files = onlineFiles.concat(offlineFiles);
                    });
                } else {
                    scope.files = $mmaModAssign.getSubmissionPluginAttachments(scope.plugin);
                }
            }).finally(function() {
                $mmaModAssignSubmissionFileSession.setFiles(scope.assign.id, scope.files);
            });
        }
    };
}]);

angular.module('mm.addons.mod_assign')
.constant('mmaModAssignSubmissionFileName', 'submission_file')
.factory('$mmaModAssignSubmissionFileHandler', ["$mmaModAssignSubmissionFileSession", "$mmaModAssign", "$mmSite", "$q", "$mmaModAssignHelper", "$mmWS", "$mmFS", "$mmFilepool", "$mmUtil", "$mmaModAssignOffline", "mmaModAssignSubmissionFileName", "$mmFileUploaderHelper", function($mmaModAssignSubmissionFileSession, $mmaModAssign, $mmSite, $q,
            $mmaModAssignHelper, $mmWS, $mmFS, $mmFilepool, $mmUtil, $mmaModAssignOffline, mmaModAssignSubmissionFileName,
            $mmFileUploaderHelper) {
    var self = {};
        self.canEditOffline = function(assign, submission, plugin) {
        return true;
    };
        self.clearTmpData = function(assign, submission, plugin, inputData) {
        var files = $mmaModAssignSubmissionFileSession.getFiles(assign.id);
        $mmaModAssignSubmissionFileSession.clearFiles(assign.id);
        $mmFileUploaderHelper.clearTmpFiles(files);
    };
        self.copySubmissionData = function(assign, plugin, pluginData) {
        var files = $mmaModAssign.getSubmissionPluginAttachments(plugin);
        return $mmaModAssignHelper.uploadFiles(assign.id, files).then(function(itemId) {
            pluginData.files_filemanager = itemId;
        });
    };
        self.deleteOfflineData = function(assign, submission, plugin, offlineData, siteId) {
        return $mmaModAssignHelper.deleteStoredSubmissionFiles(assign.id,
                mmaModAssignSubmissionFileName, submission.userid, siteId).catch(function() {
        });
    };
        self.getSizeForCopy = function(assign, plugin) {
        var files = $mmaModAssign.getSubmissionPluginAttachments(plugin),
            totalSize = 0,
            promises = [];
        angular.forEach(files, function(file) {
            promises.push($mmWS.getRemoteFileSize(file.fileurl).then(function(size) {
                if (size == -1) {
                    return $q.reject();
                }
                totalSize += size;
            }));
        });
        return $q.all(promises).then(function() {
            return totalSize;
        });
    };
        self.getSizeForEdit = function(assign, submission, plugin, inputData) {
        var siteId = $mmSite.getId();
        if (self.hasDataChanged(assign, submission, plugin, inputData)) {
            var files = $mmaModAssignSubmissionFileSession.getFiles(assign.id),
                totalSize = 0,
                promises = [];
            angular.forEach(files, function(file) {
                if (file.filename && !file.name) {
                    promises.push($mmFilepool.getFilePathByUrl(siteId, file.fileurl).then(function(path) {
                        return $mmFS.getFile(path).then(function(fileEntry) {
                            return $mmFS.getFileObjectFromFileEntry(fileEntry);
                        }).then(function(file) {
                            totalSize += file.size;
                        });
                    }).catch(function() {
                        return $mmWS.getRemoteFileSize(file.fileurl).then(function(size) {
                            if (size == -1) {
                                return $q.reject();
                            }
                            totalSize += size;
                        });
                    }));
                } else if (file.name) {
                    promises.push($mmFS.getFileObjectFromFileEntry(file).then(function(file) {
                        totalSize += file.size;
                    }));
                }
            });
            return $q.all(promises).then(function() {
                return totalSize;
            });
        } else {
            return 0;
        }
    };
        self.isEnabled = function() {
        return true;
    };
        self.isEnabledForEdit = function() {
        return true;
    };
        self.getDirectiveName = function(plugin, edit) {
        return 'mma-mod-assign-submission-file';
    };
        self.getPluginFiles = function(assign, submission, plugin, siteId) {
        return $mmaModAssign.getSubmissionPluginAttachments(plugin);
    };
        self.hasDataChanged = function(assign, submission, plugin, inputData) {
        return $mmaModAssignOffline.getSubmission(assign.id, submission.userid).catch(function() {
        }).then(function(offlineData) {
            if (offlineData && offlineData.plugindata && offlineData.plugindata.files_filemanager) {
                return offlineData.plugindata.files_filemanager.offline + offlineData.plugindata.files_filemanager.online.length;
            }
            var pluginFiles = $mmaModAssign.getSubmissionPluginAttachments(plugin);
            return pluginFiles && pluginFiles.length;
        }).then(function(numFiles) {
            var currentFiles = $mmaModAssignSubmissionFileSession.getFiles(assign.id);
            if (currentFiles.length != numFiles) {
                return true;
            }
            for (var i = 0; i < currentFiles.length; i++) {
                var file = currentFiles[i];
                if (!file.filename && typeof file.name != 'undefined' && !file.offline) {
                    return true;
                }
            }
            return false;
        });
    };
        self.prepareSubmissionData = function(assign, submission, plugin, inputData, pluginData, offline, userId, siteId) {
        siteId = siteId || $mmSite.getId();
        if (self.hasDataChanged(assign, submission, plugin, inputData)) {
            var currentFiles = $mmaModAssignSubmissionFileSession.getFiles(assign.id),
                error = $mmUtil.hasRepeatedFilenames(currentFiles);
            if (error) {
                return $q.reject(error);
            }
            return $mmaModAssignHelper.uploadOrStoreFiles(assign.id, mmaModAssignSubmissionFileName,
                        currentFiles, offline, userId, siteId).then(function(result) {
                pluginData.files_filemanager = result;
            });
        }
    };
        self.prepareSyncData = function(assign, submission, plugin, offlineData, pluginData, siteId) {
        var filesData = offlineData && offlineData.plugindata && offlineData.plugindata.files_filemanager;
        if (filesData) {
            var files = filesData.online || [],
                promise;
            if (filesData.offline) {
                promise = $mmaModAssignHelper.getStoredSubmissionFiles(assign.id,
                            mmaModAssignSubmissionFileName, submission.userid, siteId).then(function(result) {
                    files = files.concat(result);
                }).catch(function() {
                });
            } else {
                promise = $q.when();
            }
            return promise.then(function() {
                return $mmaModAssignHelper.uploadFiles(assign.id, files, siteId).then(function(itemId) {
                    pluginData.files_filemanager = itemId;
                });
            });
        }
    };
    return self;
}])
.run(["$mmAddonManager", function($mmAddonManager) {
    var $mmaModAssignSubmissionDelegate = $mmAddonManager.get('$mmaModAssignSubmissionDelegate');
    if ($mmaModAssignSubmissionDelegate) {
        $mmaModAssignSubmissionDelegate.registerHandler('mmaModAssignSubmissionFile', 'file',
                                '$mmaModAssignSubmissionFileHandler');
    }
}]);

angular.module('mm.addons.mod_assign')
.factory('$mmaModAssignSubmissionFileSession', ["$mmSite", function($mmSite) {
    var self = {},
        files = {};
        self.addFile = function(assignmentId, file, siteId) {
        siteId = siteId || $mmSite.getId();
        if (!files[siteId]) {
            files[siteId] = {};
        }
        if (!files[siteId][assignmentId]) {
            files[siteId][assignmentId] = [];
        }
        files[siteId][assignmentId].push(file);
    };
        self.clearFiles = function(assignmentId, siteId) {
        siteId = siteId || $mmSite.getId();
        if (files[siteId] && files[siteId][assignmentId]) {
            files[siteId][assignmentId] = [];
        }
    };
        self.getFiles = function(assignmentId, siteId) {
        siteId = siteId || $mmSite.getId();
        if (files[siteId] && files[siteId][assignmentId]) {
            return files[siteId][assignmentId];
        }
        return [];
    };
        self.removeFile = function(assignmentId, file, siteId) {
        siteId = siteId || $mmSite.getId();
        if (files[siteId] && files[siteId][assignmentId]) {
            var position = files[siteId][assignmentId].indexOf(file);
            if (position != -1) {
                files[siteId][assignmentId].splice(position, 1);
            }
        }
    };
        self.removeFileByIndex = function(assignmentId, index, siteId) {
        siteId = siteId || $mmSite.getId();
        if (files[siteId] && files[siteId][assignmentId] && index >= 0 && index < files[siteId][assignmentId].length) {
            files[siteId][assignmentId].splice(index, 1);
        }
    };
        self.setFiles = function(assignmentId, newFiles, siteId) {
        siteId = siteId || $mmSite.getId();
        if (!files[siteId]) {
            files[siteId] = {};
        }
        files[siteId][assignmentId] = newFiles;
    };
    return self;
}]);

angular.module('mm.addons.mod_assign')
.directive('mmaModAssignSubmissionComments', ["$state", "$mmComments", "mmaModAssignSubmissionInvalidatedEvent", function($state, $mmComments, mmaModAssignSubmissionInvalidatedEvent) {
    return {
        restrict: 'A',
        priority: 100,
        templateUrl: 'addons/mod/assign/submission/comments/template.html',
        link: function(scope) {
            scope.showComments = function() {
                var params = {
                    contextLevel: 'module',
                    instanceId: scope.cmid,
                    component: 'assignsubmission_comments',
                    itemId: scope.submissionId,
                    area: 'submission_comments',
                    title: scope.plugin.name
                };
                $state.go('site.mm_commentviewer', params);
            };
            scope.submissionId = scope.submission.id;
            scope.cmid = scope.assign.cmid;
            var obsLoaded = scope.$on(mmaModAssignSubmissionInvalidatedEvent, function() {
                $mmComments.invalidateCommentsData('module', scope.cmid, 'assignsubmission_comments', scope.submissionId,
                    'submission_comments');
            });
            scope.$on('$destroy', obsLoaded);
        }
    };
}]);

angular.module('mm.addons.mod_assign')
.factory('$mmaModAssignSubmissionCommentsHandler', ["$mmComments", function($mmComments) {
    var self = {};
        self.canEditOffline = function(assign, submission, plugin) {
        return true;
    };
        self.isEnabled = function() {
        return $mmComments.isPluginEnabled();
    };
        self.isEnabledForEdit = function() {
        return true;
    };
        self.getDirectiveName = function(plugin, edit) {
        return edit ? false : 'mma-mod-assign-submission-comments';
    };
        self.prefetch = function(assign, submission, plugin, siteId) {
        return $mmComments.getComments('module', assign.cmid, 'assignsubmission_comments', submission.id,
                    'submission_comments', 0, siteId).catch(function() {
        });
    };
    return self;
}])
.run(["$mmAddonManager", function($mmAddonManager) {
    var $mmaModAssignSubmissionDelegate = $mmAddonManager.get('$mmaModAssignSubmissionDelegate');
    if ($mmaModAssignSubmissionDelegate) {
        $mmaModAssignSubmissionDelegate.registerHandler('mmaModAssignSubmissionComments', 'comments',
                                '$mmaModAssignSubmissionCommentsHandler');
    }
}]);

angular.module('mm.addons.mod_assign')
.directive('mmaModAssignSubmissionOnlinetext', ["$mmaModAssign", "$mmText", "$timeout", "$q", "$mmUtil", "$mmaModAssignOffline", function($mmaModAssign, $mmText, $timeout, $q, $mmUtil, $mmaModAssignOffline) {
    return {
        restrict: 'A',
        priority: 100,
        templateUrl: 'addons/mod/assign/submission/onlinetext/template.html',
        link: function(scope, element) {
            var wordCountTimeout,
                promise,
                rteEnabled;
            if (!scope.plugin) {
                return;
            }
            if (scope.edit) {
                promise = $mmUtil.isRichTextEditorEnabled();
            } else {
                promise = $q.when(false);
            }
            promise.then(function(enabled) {
                rteEnabled = enabled;
                return $mmaModAssignOffline.getSubmission(scope.assign.id).catch(function() {
                }).then(function(offlineData) {
                    if (offlineData && offlineData.plugindata && offlineData.plugindata.onlinetext_editor) {
                        return offlineData.plugindata.onlinetext_editor.text;
                    }
                    return $mmaModAssign.getSubmissionPluginText(scope.plugin, scope.edit && !rteEnabled);
                });
            }).then(function(text) {
                scope.configs.wordlimit = parseInt(scope.configs.wordlimit, 10);
                scope.configs.wordlimitenabled = parseInt(scope.configs.wordlimitenabled, 10);
                scope.model = {
                    text: text
                };
                if (rteEnabled) {
                    scope.plugin.rteInitialText = text;
                }
                if (!scope.edit) {
                    angular.element(element).on('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        if (text) {
                            $mmText.expandText(scope.plugin.name, text, false, scope.assignComponent, scope.assign.cmid);
                        }
                    });
                }
                scope.onChange = function() {
                    if (scope.configs.wordlimitenabled) {
                        $timeout.cancel(wordCountTimeout);
                        wordCountTimeout = $timeout(function() {
                            scope.words = $mmText.countWords(scope.model.text);
                        }, 1500);
                    }
                };
                scope.firstRender = function() {
                    scope.plugin.rteInitialText = scope.model.text;
                    if (scope.configs.wordlimitenabled) {
                        scope.words = $mmText.countWords(scope.model.text);
                    }
                };
                if (!rteEnabled && scope.configs.wordlimitenabled) {
                    scope.words = $mmText.countWords(scope.model.text);
                }
            });
        }
    };
}]);

angular.module('mm.addons.mod_assign')
.factory('$mmaModAssignSubmissionOnlinetextHandler', ["$mmSite", "$mmaModAssign", "$q", "$mmaModAssignHelper", "$mmWS", "$mmText", "$mmaModAssignOffline", "$mmUtil", function($mmSite, $mmaModAssign, $q, $mmaModAssignHelper, $mmWS, $mmText,
            $mmaModAssignOffline, $mmUtil) {
    var self = {};
        self.canEditOffline = function(assign, submission, plugin) {
        return false;
    };
        self.copySubmissionData = function(assign, plugin, pluginData) {
        var text = $mmaModAssign.getSubmissionPluginText(plugin, true),
            files = $mmaModAssign.getSubmissionPluginAttachments(plugin),
            promise;
        if (!files.length) {
            promise = $q.when(0);
        } else {
            promise = $mmaModAssignHelper.uploadFiles(assign.id, files);
        }
        return promise.then(function(itemId) {
            pluginData.onlinetext_editor = {
                text: text,
                format: 1,
                itemid: itemId
            };
        });
    };
        self.getPluginFiles = function(assign, submission, plugin, siteId) {
        return $mmaModAssign.getSubmissionPluginAttachments(plugin);
    };
        self.getSizeForCopy = function(assign, plugin) {
        var text = $mmaModAssign.getSubmissionPluginText(plugin, true),
            files = $mmaModAssign.getSubmissionPluginAttachments(plugin),
            totalSize = text.length,
            promises;
        if (!files.length) {
            return totalSize;
        }
        promises = [];
        angular.forEach(files, function(file) {
            promises.push($mmWS.getRemoteFileSize(file.fileurl).then(function(size) {
                if (size == -1) {
                    return $q.reject();
                }
                totalSize += size;
            }));
        });
        return $q.all(promises).then(function() {
            return totalSize;
        });
    };
        self.getSizeForEdit = function(assign, submission, plugin, inputData) {
        var text = $mmaModAssign.getSubmissionPluginText(plugin, true);
        return text.length;
    };
        self.isEnabled = function() {
        return true;
    };
        self.isEnabledForEdit = function() {
        return $mmSite.isVersionGreaterEqualThan('3.1.1') || $mmSite.checkIfAppUsesLocalMobile();
    };
        self.getDirectiveName = function(plugin, edit) {
        return 'mma-mod-assign-submission-onlinetext';
    };
        self.prepareSubmissionData = function(assign, submission, plugin, inputData, pluginData, offline, userId, siteId) {
        return $mmUtil.isRichTextEditorEnabled().then(function(enabled) {
            var text = getTextToSubmit(plugin, inputData);
            if (!enabled) {
                text = $mmText.formatHtmlLines(text);
            }
            pluginData.onlinetext_editor = {
                text: text,
                format: 1,
                itemid: 0
            };
        });
    };
        self.hasDataChanged = function(assign, submission, plugin, inputData) {
        if (typeof plugin.rteInitialText != 'undefined') {
            return plugin.rteInitialText != inputData.onlinetext_editor_text;
        } else {
            return $mmaModAssignOffline.getSubmission(assign.id, submission.userid).catch(function() {
            }).then(function(data) {
                if (data && data.plugindata && data.plugindata.onlinetext_editor) {
                    return data.plugindata.onlinetext_editor.text;
                }
                return plugin.editorfields && plugin.editorfields[0] ? plugin.editorfields[0].text : '';
            }).then(function(initialText) {
                return initialText != getTextToSubmit(plugin, inputData);
            });
        }
    };
        function getTextToSubmit(plugin, inputData) {
        var text = inputData.onlinetext_editor_text,
            files = plugin.fileareas && plugin.fileareas[0] ? plugin.fileareas[0].files : [];
        return $mmText.restorePluginfileUrls(text, files);
    }
        self.prepareSyncData = function(assign, submission, plugin, offlineData, pluginData, siteId) {
        var textData = offlineData && offlineData.plugindata && offlineData.plugindata.onlinetext_editor;
        if (textData) {
            pluginData.onlinetext_editor = textData;
        }
    };
    return self;
}])
.run(["$mmAddonManager", function($mmAddonManager) {
    var $mmaModAssignSubmissionDelegate = $mmAddonManager.get('$mmaModAssignSubmissionDelegate');
    if ($mmaModAssignSubmissionDelegate) {
        $mmaModAssignSubmissionDelegate.registerHandler('mmaModAssignSubmissionOnlinetext', 'onlinetext',
                                '$mmaModAssignSubmissionOnlinetextHandler');
    }
}]);

angular.module('mm.addons.mod_quiz')
.factory('$mmaQuizAccessIpAddressHandler', function() {
    var self = {};
        self.isEnabled = function() {
        return true;
    };
        self.isPreflightCheckRequired = function(quiz, attempt, prefetch, siteId) {
        return false;
    };
    return self;
})
.run(["$mmAddonManager", function($mmAddonManager) {
    var $mmaModQuizAccessRulesDelegate = $mmAddonManager.get('$mmaModQuizAccessRulesDelegate');
    if ($mmaModQuizAccessRulesDelegate) {
        $mmaModQuizAccessRulesDelegate.registerHandler('mmaQuizAccessIpAddress', 'quizaccess_ipaddress',
                                '$mmaQuizAccessIpAddressHandler');
    }
}]);

angular.module('mm.addons.mod_quiz')
.factory('$mmaQuizAccessNumAttemptsHandler', function() {
    var self = {};
        self.isEnabled = function() {
        return true;
    };
        self.isPreflightCheckRequired = function(quiz, attempt, prefetch, siteId) {
        return false;
    };
    return self;
})
.run(["$mmAddonManager", function($mmAddonManager) {
    var $mmaModQuizAccessRulesDelegate = $mmAddonManager.get('$mmaModQuizAccessRulesDelegate');
    if ($mmaModQuizAccessRulesDelegate) {
        $mmaModQuizAccessRulesDelegate.registerHandler('mmaQuizAccessNumAttempts', 'quizaccess_numattempts',
                                '$mmaQuizAccessNumAttemptsHandler');
    }
}]);

angular.module('mm.addons.mod_quiz')
.factory('$mmaQuizAccessDelayBetweenAttemptsHandler', function() {
    var self = {};
        self.isEnabled = function() {
        return true;
    };
        self.isPreflightCheckRequired = function(quiz, attempt, prefetch, siteId) {
        return false;
    };
    return self;
})
.run(["$mmAddonManager", function($mmAddonManager) {
    var $mmaModQuizAccessRulesDelegate = $mmAddonManager.get('$mmaModQuizAccessRulesDelegate');
    if ($mmaModQuizAccessRulesDelegate) {
        $mmaModQuizAccessRulesDelegate.registerHandler('mmaQuizAccessDelayBetweenAttempts', 'quizaccess_delaybetweenattempts',
                                '$mmaQuizAccessDelayBetweenAttemptsHandler');
    }
}]);

angular.module('mm.addons.mod_quiz')
.directive('mmaQuizAccessOfflineAttemptsPreflight', function() {
    return {
        restrict: 'A',
        priority: 100,
        templateUrl: 'addons/mod/quiz/accessrules/offlineattempts/template.html'
    };
});

angular.module('mm.addons.mod_quiz')
.factory('$mmaQuizAccessOfflineAttemptsHandler', ["mmaModQuizSyncTime", function(mmaModQuizSyncTime) {
    var self = {};
        self.isEnabled = function() {
        return true;
    };
        self.isPreflightCheckRequired = function(quiz, attempt, prefetch, siteId) {
        if (prefetch) {
            return false;
        }
        if (!attempt) {
            return true;
        }
        return new Date().getTime() - mmaModQuizSyncTime > attempt.quizSyncTime;
    };
        self.getFixedPreflightData = function(quiz, attempt, preflightData, prefetch, siteId) {
        preflightData.confirmdatasaved = 1;
    };
        self.getPreflightDirectiveName = function() {
        return 'mma-quiz-access-offline-attempts-preflight';
    };
    return self;
}])
.run(["$mmAddonManager", function($mmAddonManager) {
    var $mmaModQuizAccessRulesDelegate = $mmAddonManager.get('$mmaModQuizAccessRulesDelegate');
    if ($mmaModQuizAccessRulesDelegate) {
        $mmaModQuizAccessRulesDelegate.registerHandler('mmaQuizAccessOfflineAttempts', 'quizaccess_offlineattempts',
                                '$mmaQuizAccessOfflineAttemptsHandler');
    }
}]);

angular.module('mm.addons.mod_quiz')
.factory('$mmaQuizAccessOpenCloseDateHandler', ["$mmaModQuiz", function($mmaModQuiz) {
    var self = {};
        self.isEnabled = function() {
        return true;
    };
        self.isPreflightCheckRequired = function(quiz, attempt, prefetch, siteId) {
        return false;
    };
        self.shouldShowTimeLeft = function(attempt, endTime, timeNow) {
        if (attempt.preview && timeNow > endTime) {
            return false;
        }
        if (timeNow > endTime - $mmaModQuiz.QUIZ_SHOW_TIME_BEFORE_DEADLINE) {
            return true;
        }
        return false;
    };
    return self;
}])
.run(["$mmAddonManager", function($mmAddonManager) {
    var $mmaModQuizAccessRulesDelegate = $mmAddonManager.get('$mmaModQuizAccessRulesDelegate');
    if ($mmaModQuizAccessRulesDelegate) {
        $mmaModQuizAccessRulesDelegate.registerHandler('mmaQuizAccessOpenCloseDate', 'quizaccess_openclosedate',
                                '$mmaQuizAccessOpenCloseDateHandler');
    }
}]);

angular.module('mm.addons.mod_quiz')
.directive('mmaQuizAccessPasswordPreflight', function() {
    return {
        restrict: 'A',
        priority: 100,
        templateUrl: 'addons/mod/quiz/accessrules/password/template.html'
    };
});

angular.module('mm.addons.mod_quiz')
.constant('mmaModQuizAccessPasswordStore', 'mod_quiz_access_password')
.config(["$mmSitesFactoryProvider", "mmaModQuizAccessPasswordStore", function($mmSitesFactoryProvider, mmaModQuizAccessPasswordStore) {
    var stores = [
        {
            name: mmaModQuizAccessPasswordStore,
            keyPath: 'id',
            indexes: []
        }
    ];
    $mmSitesFactoryProvider.registerStores(stores);
}])
.factory('$mmaQuizAccessPasswordHandler', ["$mmSitesManager", "$mmSite", "$q", "mmaModQuizAccessPasswordStore", function($mmSitesManager, $mmSite, $q, mmaModQuizAccessPasswordStore) {
    var self = {};
        self.cleanPreflight = function(data) {
        delete data.quizpassword;
    };
        function getPasswordEntry(quizId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.getDb().get(mmaModQuizAccessPasswordStore, quizId);
        });
    }
        function removePassword(quizId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.getDb().remove(mmaModQuizAccessPasswordStore, quizId);
        });
    }
        function storePassword(quizId, password, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var entry = {
                id: quizId,
                password: password,
                timemodified: new Date().getTime()
            };
            return site.getDb().insert(mmaModQuizAccessPasswordStore, entry);
        });
    }
        self.getFixedPreflightData = function(quiz, attempt, preflightData, prefetch, siteId) {
        if (quiz && quiz.id && typeof preflightData.quizpassword == 'undefined') {
            return getPasswordEntry(quiz.id, siteId).then(function(entry) {
                preflightData.quizpassword = entry.password;
            }).catch(function() {
            });
        }
        return $q.when();
    };
        self.isEnabled = function() {
        return true;
    };
        self.isPreflightCheckRequired = function(quiz, attempt, prefetch, siteId) {
        return getPasswordEntry(quiz.id, siteId).then(function() {
            return false;
        }).catch(function() {
            return true;
        });
    };
        self.getPreflightDirectiveName = function() {
        return 'mma-quiz-access-password-preflight';
    };
        self.notifyPreflightCheckPassed = function(quiz, attempt, preflightData, prefetch, siteId) {
        if (quiz && quiz.id && typeof preflightData.quizpassword != 'undefined') {
            return storePassword(quiz.id, preflightData.quizpassword, siteId);
        }
        return $q.when();
    };
        self.notifyPreflightCheckFailed = function(quiz, attempt, preflightData, prefetch, siteId) {
        if (quiz && quiz.id) {
            return removePassword(quiz.id, siteId);
        }
        return $q.when();
    };
    return self;
}])
.run(["$mmAddonManager", function($mmAddonManager) {
    var $mmaModQuizAccessRulesDelegate = $mmAddonManager.get('$mmaModQuizAccessRulesDelegate');
    if ($mmaModQuizAccessRulesDelegate) {
        $mmaModQuizAccessRulesDelegate.registerHandler('mmaQuizAccessPassword', 'quizaccess_password',
                                '$mmaQuizAccessPasswordHandler');
    }
}]);

angular.module('mm.addons.mod_quiz')
.factory('$mmaQuizAccessSafeBrowserHandler', function() {
    var self = {};
        self.isEnabled = function() {
        return true;
    };
        self.isPreflightCheckRequired = function(quiz, attempt, prefetch, siteId) {
        return false;
    };
    return self;
})
.run(["$mmAddonManager", function($mmAddonManager) {
    var $mmaModQuizAccessRulesDelegate = $mmAddonManager.get('$mmaModQuizAccessRulesDelegate');
    if ($mmaModQuizAccessRulesDelegate) {
        $mmaModQuizAccessRulesDelegate.registerHandler('mmaQuizAccessSafeBrowser', 'quizaccess_safebrowser',
                                '$mmaQuizAccessSafeBrowserHandler');
    }
}]);

angular.module('mm.addons.mod_quiz')
.factory('$mmaQuizAccessSecureWindowHandler', function() {
    var self = {};
        self.isEnabled = function() {
        return true;
    };
        self.isPreflightCheckRequired = function(quiz, attempt, prefetch, siteId) {
        return false;
    };
    return self;
})
.run(["$mmAddonManager", function($mmAddonManager) {
    var $mmaModQuizAccessRulesDelegate = $mmAddonManager.get('$mmaModQuizAccessRulesDelegate');
    if ($mmaModQuizAccessRulesDelegate) {
        $mmaModQuizAccessRulesDelegate.registerHandler('mmaQuizAccessSecureWindow', 'quizaccess_securewindow',
                                '$mmaQuizAccessSecureWindowHandler');
    }
}]);

angular.module('mm.addons.mod_quiz')
.directive('mmaQuizAccessTimeLimitPreflight', function() {
    return {
        restrict: 'A',
        priority: 100,
        templateUrl: 'addons/mod/quiz/accessrules/timelimit/template.html'
    };
});

angular.module('mm.addons.mod_quiz')
.factory('$mmaQuizAccessTimeLimitHandler', function() {
    var self = {};
        self.isEnabled = function() {
        return true;
    };
        self.isPreflightCheckRequired = function(quiz, attempt, prefetch, siteId) {
        return !attempt;
    };
        self.getPreflightDirectiveName = function() {
        return 'mma-quiz-access-time-limit-preflight';
    };
        self.shouldShowTimeLeft = function(attempt, endTime, timeNow) {
        return !(attempt.preview && timeNow > endTime);
    };
    return self;
})
.run(["$mmAddonManager", function($mmAddonManager) {
    var $mmaModQuizAccessRulesDelegate = $mmAddonManager.get('$mmaModQuizAccessRulesDelegate');
    if ($mmaModQuizAccessRulesDelegate) {
        $mmaModQuizAccessRulesDelegate.registerHandler('mmaQuizAccessTimeLimit', 'quizaccess_timelimit',
                                '$mmaQuizAccessTimeLimitHandler');
    }
}]);

angular.module('mm.addons.badges')
.controller('mmaBadgesIssuedCtrl', ["$scope", "$stateParams", "$mmUtil", "$mmaBadges", "$mmSite", "$q", "$mmCourses", "$mmUser", function($scope, $stateParams, $mmUtil, $mmaBadges, $mmSite, $q, $mmCourses, $mmUser) {
    $scope.courseId = $stateParams.cid;
    $scope.userId = $stateParams.uid || $mmSite.getUserId();
    var uniqueHash = $stateParams.uniquehash;
    function fetchIssuedBadge() {
        var promises = [],
            promise;
        promise = $mmUser.getProfile($scope.userId, $scope.courseId, true).then(function(user) {
            $scope.user = user;
        });
        promises.push(promise);
        promise = $mmaBadges.getUserBadges($scope.courseId, $scope.userId).then(function(badges) {
            angular.forEach(badges, function(badge) {
                if (uniqueHash == badge.uniquehash) {
                    $scope.badge = badge;
                    if (badge.courseid) {
                        return $mmCourses.getUserCourse(badge.courseid, true).then(function(course) {
                            $scope.course = course;
                        }).catch(function() {
                            $scope.course = null;
                        });
                    }
                }
            });
        }).catch(function(message) {
            if (message) {
                $mmUtil.showErrorModal(message);
            } else {
                $mmUtil.showErrorModal('Error getting badge data.');
            }
            return $q.reject();
        });
        promises.push(promise);
        return $q.all(promises);
    }
    fetchIssuedBadge().finally(function() {
        $scope.badgeLoaded = true;
    });
    $scope.refreshBadges = function() {
        $mmaBadges.invalidateUserBadges($scope.courseId, $scope.userId).finally(function() {
            fetchIssuedBadge().finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };
}]);

angular.module('mm.addons.badges')
.controller('mmaBadgesUserCtrl', ["$scope", "$mmaBadges", "$mmUtil", "$stateParams", "$q", "$mmSite", function($scope, $mmaBadges, $mmUtil, $stateParams, $q, $mmSite) {
    $scope.courseId = $stateParams.courseid;
    $scope.userId = $stateParams.userid || $mmSite.getUserId();
    function fetchBadges() {
        return $mmaBadges.getUserBadges($scope.courseId, $scope.userId).then(function(badges) {
            $scope.badges = badges;
        }).catch(function(message) {
            if (message) {
                $mmUtil.showErrorModal(message);
            } else {
                $mmUtil.showErrorModal('Error getting badges data.');
            }
            return $q.reject();
        });
    }
    fetchBadges().finally(function() {
        $scope.badgesLoaded = true;
    });
    $scope.refreshBadges = function() {
        $mmaBadges.invalidateUserBadges($scope.courseId, $scope.userId).finally(function() {
            fetchBadges().finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };
}]);

angular.module('mm.addons.badges')
.factory('$mmaBadges', ["$log", "$mmSitesManager", function($log, $mmSitesManager) {
    $log = $log.getInstance('$mmaBadges');
    var self = {};
        self.isPluginEnabled = function(siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            if (!site.canUseAdvancedFeature('enablebadges')) {
                return false;
            } else if (!site.wsAvailable('core_badges_get_user_badges') || !site.wsAvailable('core_course_get_user_navigation_options')) {
                return false;
            }
            return true;
        });
    };
        function getBadgesCacheKey(courseId, userId) {
        return 'mmaBadges:badges:' + courseId + ':' + userId;
    }
        self.getUserBadges = function(courseId, userId, siteId) {
        $log.debug('Get badges for course ' + courseId);
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var data = {
                    courseid : courseId,
                    userid : userId
                },
                presets = {
                    cacheKey: getBadgesCacheKey(courseId, userId)
                };
            return site.read('core_badges_get_user_badges', data, presets).then(function(response) {
                if (response && response.badges) {
                    return response.badges;
                } else {
                    return $q.reject();
                }
            });
        });
    };
        self.invalidateUserBadges = function(courseId, userId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getBadgesCacheKey(courseId, userId));
        });
    };
    return self;
}]);

angular.module('mm.addons.badges')
.factory('$mmaBadgesHandlers', ["$mmaBadges", "$mmContentLinksHelper", "mmUserProfileHandlersTypeNewPage", "$mmContentLinkHandlerFactory", function($mmaBadges, $mmContentLinksHelper, mmUserProfileHandlersTypeNewPage,
            $mmContentLinkHandlerFactory) {
    var self = {};
        self.userProfile = function() {
        var self = {
            type: mmUserProfileHandlersTypeNewPage
        };
                self.isEnabled = function() {
            return $mmaBadges.isPluginEnabled();
        };
                self.isEnabledForUser = function(user, courseId, navOptions, admOptions) {
            if (navOptions && typeof navOptions.badges != 'undefined') {
                return navOptions.badges;
            }
            return false;
        };
                self.getController = function(user, courseId) {
                        return function($scope, $state) {
                $scope.icon = 'ion-trophy';
                $scope.title = 'mma.badges.badges';
                $scope.action = function($event) {
                    $event.preventDefault();
                    $event.stopPropagation();
                    $state.go('site.userbadges', {
                        courseid: courseId,
                        userid: user.id
                    });
                };
            };
        };
        return self;
    };
        self.myBadgesLinksHandler = $mmContentLinkHandlerFactory.createChild('/badges/mybadges.php', '$mmUserDelegate_mmaBadges');
    self.myBadgesLinksHandler.isEnabled = $mmaBadges.isPluginEnabled;
    self.myBadgesLinksHandler.getActions = function(siteIds, url, params, courseId) {
        return [{
            action: function(siteId) {
                var stateParams = {
                    courseid: 0
                };
                $mmContentLinksHelper.goInSite('site.userbadges', stateParams, siteId);
            }
        }];
    };
        self.badgeLinksHandler = $mmContentLinkHandlerFactory.createChild(/\/badges\/badge\.php.*([\?\&]hash=)/);
    self.badgeLinksHandler.isEnabled = $mmaBadges.isPluginEnabled;
    self.badgeLinksHandler.getActions = function(siteIds, url, params) {
        return [{
            action: function(siteId) {
                var stateParams = {
                    cid: 0,
                    uniquehash: params.hash
                };
                $mmContentLinksHelper.goInSite('site.issuedbadge', stateParams, siteId);
            }
        }];
    };
    return self;
}]);

angular.module('mm.addons.calendar')
.controller('mmaCalendarEventCtrl', ["$scope", "$log", "$stateParams", "$mmaCalendar", "$mmUtil", "$mmCourse", "$mmCourses", "$translate", "$mmLocalNotifications", function($scope, $log, $stateParams, $mmaCalendar, $mmUtil, $mmCourse, $mmCourses, $translate,
        $mmLocalNotifications) {
    $log = $log.getInstance('mmaCalendarEventCtrl');
    var eventid = parseInt($stateParams.id);
    function fetchEvent(refresh) {
        return $mmaCalendar.getEvent(eventid, refresh).then(function(e) {
            $mmaCalendar.formatEventData(e);
            $scope.event = e;
            $scope.title = e.name;
            if (e.moduleicon) {
                var name = $mmCourse.translateModuleName(e.modulename);
                if (name.indexOf('mm.core.mod') === -1) {
                    e.modulename = name;
                }
            }
            if (e.courseid > 1) {
                $mmCourses.getUserCourse(e.courseid, true).then(function(course) {
                    $scope.coursename = course.fullname;
                });
            }
        }, function(error) {
            if (error) {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mma.calendar.errorloadevent', true);
            }
        });
    }
    fetchEvent().finally(function() {
        $scope.eventLoaded = true;
    });
    $scope.refreshEvent = function() {
        fetchEvent(true).finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
    $scope.notificationsEnabled = $mmLocalNotifications.isAvailable();
    if ($scope.notificationsEnabled) {
        $mmaCalendar.getEventNotificationTimeOption(eventid).then(function(notificationtime) {
            $scope.notification = {
                time: String(notificationtime)
            };
        });
        $mmaCalendar.getDefaultNotificationTime().then(function(defaultTime) {
            if (defaultTime === 0) {
                $scope.defaultTimeReadable = $translate.instant('mm.settings.disabled');
            } else {
                $scope.defaultTimeReadable = moment.duration(defaultTime * 60 * 1000).humanize();
            }
        });
        $scope.updateNotificationTime = function() {
            var time = parseInt($scope.notification.time, 10);
            if (!isNaN(time) && $scope.event && $scope.event.id) {
                $mmaCalendar.updateNotificationTime($scope.event, time);
            }
        };
    }
}]);

angular.module('mm.addons.calendar')
.controller('mmaCalendarListCtrl', ["$scope", "$stateParams", "$log", "$state", "$mmaCalendar", "$mmUtil", "$ionicHistory", "$mmEvents", "mmaCalendarDaysInterval", "$ionicScrollDelegate", "$mmLocalNotifications", "$mmCourses", "mmaCalendarDefaultNotifTimeChangedEvent", "$ionicPopover", "$q", "$translate", function($scope, $stateParams, $log, $state, $mmaCalendar, $mmUtil, $ionicHistory, $mmEvents,
        mmaCalendarDaysInterval, $ionicScrollDelegate, $mmLocalNotifications, $mmCourses, mmaCalendarDefaultNotifTimeChangedEvent,
        $ionicPopover, $q, $translate) {
    $log = $log.getInstance('mmaCalendarListCtrl');
    var daysLoaded,
        emptyEventsTimes,
        scrollView = $ionicScrollDelegate.$getByHandle('mmaCalendarEventsListScroll'),
        obsDefaultTimeChange,
        popover,
        allCourses = {
            id: -1,
            fullname: $translate.instant('mm.core.fulllistofcourses')
        };
    if ($stateParams.eventid) {
        $ionicHistory.clearHistory();
        $state.go('site.calendar-event', {id: $stateParams.eventid});
    }
    function initVars() {
        daysLoaded = 0;
        emptyEventsTimes = 0;
        $scope.events = [];
    }
    function fetchData(refresh) {
        initVars();
        return loadCourses().then(function() {
            return fetchEvents(refresh);
        });
    }
    function fetchEvents(refresh) {
        return $mmaCalendar.getEvents(daysLoaded, mmaCalendarDaysInterval, refresh).then(function(events) {
            daysLoaded += mmaCalendarDaysInterval;
            if (events.length === 0) {
                emptyEventsTimes++;
                if (emptyEventsTimes > 5) {
                    $scope.canLoadMore = false;
                    $scope.eventsLoaded = true;
                } else {
                    return fetchEvents();
                }
            } else {
                angular.forEach(events, $mmaCalendar.formatEventData);
                if (refresh) {
                    $scope.events = events;
                } else {
                    $scope.events = $scope.events.concat(events);
                }
                $scope.eventsLoaded = true;
                $scope.canLoadMore = true;
                $mmaCalendar.scheduleEventsNotifications(events);
            }
            scrollView.resize();
        }, function(error) {
            if (error) {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mma.calendar.errorloadevents', true);
            }
            $scope.eventsLoaded = true;
            $scope.canLoadMore = false;
        });
    }
    function loadCourses() {
        return $mmCourses.getUserCourses(false).then(function(courses) {
            courses.unshift(allCourses);
            $scope.courses = courses;
        });
    }
    $scope.filter = {
        courseid: -1,
    };
    $scope.notificationsEnabled = $mmLocalNotifications.isAvailable();
    fetchData();
    $ionicPopover.fromTemplateUrl('addons/calendar/templates/course_picker.html', {
        scope: $scope
    }).then(function(po) {
        popover = po;
        $scope.pickCourse = function(event) {
            popover.show(event);
        };
        $scope.coursePicked = function() {
            popover.hide();
            scrollView.scrollTop();
        };
    });
    $scope.loadMoreEvents = function() {
        fetchEvents().finally(function() {
            $scope.$broadcast('scroll.infiniteScrollComplete');
        });
    };
    $scope.refreshEvents = function() {
        var promises = [];
        promises.push($mmCourses.invalidateUserCourses());
        promises.push($mmaCalendar.invalidateEventsList());
        return $q.all(promises).finally(function() {
            fetchData(true).finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };
    $scope.openSettings = function() {
        $state.go('site.calendar-settings');
    };
    $scope.filterEvent = function(event) {
        if ($scope.filter.courseid == -1) {
            return true;
        }
        return event.courseid === 1 || event.courseid == $scope.filter.courseid;
    };
    if ($scope.notificationsEnabled) {
        obsDefaultTimeChange = $mmEvents.on(mmaCalendarDefaultNotifTimeChangedEvent, function() {
            $mmaCalendar.scheduleEventsNotifications($scope.events);
        });
    }
    $scope.$on('$destroy', function() {
        obsDefaultTimeChange && obsDefaultTimeChange.off && obsDefaultTimeChange.off();
        popover && popover.remove();
    });
}]);

angular.module('mm.addons.calendar')
.controller('mmaCalendarSettingsCtrl', ["$scope", "$mmaCalendar", "$mmEvents", "$mmSite", "mmaCalendarDefaultNotifTimeChangedEvent", function($scope, $mmaCalendar, $mmEvents, $mmSite,
            mmaCalendarDefaultNotifTimeChangedEvent) {
    $mmaCalendar.getDefaultNotificationTime().then(function(time) {
        $scope.defaultTime = String(time);
    });
    $scope.updateDefaultTime = function(newTime) {
        $mmaCalendar.setDefaultNotificationTime(newTime);
        $mmEvents.trigger(mmaCalendarDefaultNotifTimeChangedEvent, {siteid: $mmSite.getId(), time: newTime});
    };
}]);

angular.module('mm.addons.calendar')
.constant('mmaCalendarEventsStore', 'calendar_events')
.config(["$mmSitesFactoryProvider", "mmaCalendarEventsStore", function($mmSitesFactoryProvider, mmaCalendarEventsStore) {
    var stores = [
        {
            name: mmaCalendarEventsStore,
            keyPath: 'id',
            indexes: [
                {
                    name: 'notificationtime'
                }
            ]
        }
    ];
    $mmSitesFactoryProvider.registerStores(stores);
}])
.factory('$mmaCalendar', ["$log", "$q", "$mmSite", "$mmUtil", "$mmCourses", "$mmGroups", "$mmCourse", "$mmLocalNotifications", "$mmSitesManager", "mmCoreSecondsDay", "mmaCalendarDaysInterval", "mmaCalendarEventsStore", "mmaCalendarDefaultNotifTime", "mmaCalendarComponent", "mmaCalendarDefaultNotifTimeSetting", "$mmConfig", function($log, $q, $mmSite, $mmUtil, $mmCourses, $mmGroups, $mmCourse, $mmLocalNotifications,
        $mmSitesManager, mmCoreSecondsDay, mmaCalendarDaysInterval, mmaCalendarEventsStore, mmaCalendarDefaultNotifTime,
        mmaCalendarComponent, mmaCalendarDefaultNotifTimeSetting, $mmConfig) {
    $log = $log.getInstance('$mmaCalendar');
    var self = {},
        calendarImgPath = 'addons/calendar/img/',
        eventicons = {
            'course': calendarImgPath + 'courseevent.svg',
            'group': calendarImgPath + 'groupevent.svg',
            'site': calendarImgPath + 'siteevent.svg',
            'user': calendarImgPath + 'userevent.svg'
        };
        function getEventsListCacheKey(daysToStart, daysInterval) {
        return 'mmaCalendar:events:' + daysToStart + ':' + daysInterval;
    }
        function getEventCacheKey(id) {
        return 'mmaCalendar:events:' + id;
    }
        function getEventsCommonCacheKey() {
        return 'mmaCalendar:events:';
    }
        function storeEventsInLocalDB(events, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var promises = [],
                db = site.getDb();
            angular.forEach(events, function(event) {
                promises.push(self.getEventFromLocalDb(event.id, siteId).catch(function() {
                    return {};
                }).then(function(e) {
                    if (typeof e.notificationtime != 'undefined') {
                        event.notificationtime = e.notificationtime;
                    }
                    return db.insert(mmaCalendarEventsStore, event);
                }));
            });
            return $q.all(promises);
        });
    }
        self.formatEventData = function(e) {
        var icon = self.getEventIcon(e.eventtype);
        if (icon === '') {
            icon = $mmCourse.getModuleIconSrc(e.modulename);
            e.moduleicon = icon;
        }
        e.icon = icon;
    };
        self.getAllEventsFromLocalDb = function(siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.getDb().getAll(mmaCalendarEventsStore);
        });
    };
        self.getDefaultNotificationTime = function(siteId) {
        siteId = siteId || $mmSite.getId();
        var key = mmaCalendarDefaultNotifTimeSetting + '#' + siteId;
        return $mmConfig.get(key, mmaCalendarDefaultNotifTime);
    };
        self.getEvent = function(id, refresh) {
        var presets = {},
            data = {
                "options[userevents]": 0,
                "options[siteevents]": 0,
                "events[eventids][0]": id
            };
        presets.cacheKey = getEventCacheKey(id);
        if (refresh) {
            presets.getFromCache = false;
        }
        return $mmSite.read('core_calendar_get_calendar_events', data, presets).then(function(response) {
            var e = response.events[0];
            if (e) {
                return e;
            } else {
                return self.getEventFromLocalDb(id);
            }
        }, function() {
            return self.getEventFromLocalDb(id);
        });
    };
        self.getEventFromLocalDb = function(id, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.getDb().get(mmaCalendarEventsStore, id);
        });
    };
        self.getEventIcon = function(type) {
        return eventicons[type] || '';
    };
        self.getEventNotificationTime = function(id, siteId) {
        siteId = siteId || $mmSite.getId();
        return self.getEventNotificationTimeOption(id, siteId).then(function(time) {
            if (time == -1) {
                return self.getDefaultNotificationTime(siteId);
            }
            return time;
        });
    };
        self.getEventNotificationTimeOption = function(id, siteId) {
        siteId = siteId || $mmSite.getId();
        return self.getEventFromLocalDb(id, siteId).then(function(e) {
            if (typeof e.notificationtime != 'undefined') {
                return e.notificationtime;
            }
            return -1;
        }, function() {
            return -1;
        });
    };
        self.getEvents = function(daysToStart, daysInterval, refresh, siteId) {
        daysToStart = daysToStart || 0;
        daysInterval = daysInterval || mmaCalendarDaysInterval;
        siteId = siteId || $mmSite.getId();
         var now = $mmUtil.timestamp(),
            start = now + (mmCoreSecondsDay * daysToStart),
            end = start + (mmCoreSecondsDay * daysInterval);
        var data = {
            "options[userevents]": 1,
            "options[siteevents]": 1,
            "options[timestart]": start,
            "options[timeend]": end
        };
        return $mmCourses.getUserCourses(false, siteId).then(function(courses) {
            courses.push({id: 1});
            angular.forEach(courses, function(course, index) {
                data["events[courseids][" + index + "]"] = course.id;
            });
            return $mmGroups.getUserGroups(courses, refresh, siteId).then(function(groups) {
                angular.forEach(groups, function(group, index) {
                    data["events[groupids][" + index + "]"] = group.id;
                });
                return $mmSitesManager.getSite(siteId).then(function(site) {
                    var preSets = {
                        cacheKey: getEventsListCacheKey(daysToStart, daysInterval),
                        getCacheUsingCacheKey: true
                    };
                    return site.read('core_calendar_get_calendar_events', data, preSets).then(function(response) {
                        storeEventsInLocalDB(response.events, siteId);
                        return response.events;
                    });
                });
            });
        });
    };
        self.invalidateEventsList = function() {
        var p1 = $mmCourses.invalidateUserCourses(),
            p2 = $mmSite.invalidateWsCacheForKeyStartingWith(getEventsCommonCacheKey());
        return $q.all([p1, p2]);
    };
        self.isAvailable = function() {
        return $mmSite.wsAvailable('core_calendar_get_calendar_events');
    };
        self.isDisabled = function(siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return self.isDisabledInSite(site);
        });
    };
        self.isDisabledInSite = function(site) {
        site = site || $mmSite;
        return site.isFeatureDisabled('$mmSideMenuDelegate_mmaCalendar');
    };
        self.scheduleAllSitesEventsNotifications = function() {
        if ($mmLocalNotifications.isAvailable()) {
            return $mmSitesManager.getSitesIds().then(function(siteIds) {
                var promises = [];
                angular.forEach(siteIds, function(siteId) {
                    promises.push(self.isDisabled(siteId).then(function(disabled) {
                        if (!disabled) {
                            return self.getEvents(undefined, undefined, false, siteId).then(function(events) {
                                return self.scheduleEventsNotifications(events, siteId);
                            });
                        }
                    }));
                });
                return $q.all(promises);
            });
        } else {
            return $q.when();
        }
    };
        self.scheduleEventNotification = function(event, time, siteId) {
        siteId = siteId || $mmSite.getId();
        if ($mmLocalNotifications.isAvailable()) {
            if (time === 0) {
                return $mmLocalNotifications.cancel(event.id, mmaCalendarComponent, siteId);
            }
            var promise = time == -1 ? self.getDefaultNotificationTime(siteId) : $q.when(time);
            return promise.then(function(time) {
                var timeend = (event.timestart + event.timeduration) * 1000;
                if (timeend <= new Date().getTime()) {
                    return $q.when();
                }
                var dateTriggered = new Date((event.timestart - (time * 60)) * 1000),
                    startDate = new Date(event.timestart * 1000),
                    notification = {
                        id: event.id,
                        title: event.name,
                        text: startDate.toLocaleString(),
                        at: dateTriggered,
                        data: {
                            eventid: event.id,
                            siteid: siteId
                        }
                    };
                return $mmLocalNotifications.schedule(notification, mmaCalendarComponent, siteId);
            });
        } else {
            return $q.when();
        }
    };
        self.scheduleEventsNotifications = function(events, siteId) {
        siteId = siteId || $mmSite.getId();
        var promises = [];
        if ($mmLocalNotifications.isAvailable()) {
            angular.forEach(events, function(e) {
                var promise = self.getEventNotificationTime(e.id, siteId).then(function(time) {
                    return self.scheduleEventNotification(e, time, siteId);
                });
                promises.push(promise);
            });
        }
        return $q.all(promises);
    };
        self.setDefaultNotificationTime = function(time, siteId) {
        siteId = siteId || $mmSite.getId();
        var key = mmaCalendarDefaultNotifTimeSetting + '#' + siteId;
        return $mmConfig.set(key, time);
    };
        self.storeEventInLocalDb = function(event, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.getDb().insert(mmaCalendarEventsStore, event);
        });
    };
        self.updateNotificationTime = function(event, time) {
        if (!$mmSite.isLoggedIn()) {
            return $q.reject();
        }
        var db = $mmSite.getDb();
        event.notificationtime = time;
        return db.insert(mmaCalendarEventsStore, event).then(function() {
            return self.scheduleEventNotification(event, time);
        });
    };
    return self;
}]);

angular.module('mm.addons.calendar')
.factory('$mmaCalendarHandlers', ["$log", "$mmaCalendar", function($log, $mmaCalendar) {
    $log = $log.getInstance('$mmaCalendarHandlers');
    var self = {};
        self.sideMenuNav = function() {
        var self = {};
                self.isEnabled = function() {
            return $mmaCalendar.isAvailable();
        };
                self.getController = function() {
                        return function($scope) {
                $scope.icon = 'ion-calendar';
                $scope.title = 'mma.calendar.calendarevents';
                $scope.state = 'site.calendar';
                $scope.class = 'mma-calendar-handler';
            };
        };
        return self;
    };
    return self;
}]);

angular.module('mm.addons.coursecompletion')
.controller('mmaCourseCompletionReportCtrl', ["$scope", "$stateParams", "$mmUtil", "$mmaCourseCompletion", "$mmSite", "$ionicPlatform", function($scope, $stateParams, $mmUtil, $mmaCourseCompletion, $mmSite,
            $ionicPlatform) {
    var course = $stateParams.course,
        userid = $stateParams.userid || $mmSite.getUserId();
    $scope.isTablet = $ionicPlatform.isTablet();
    function fetchCompletion() {
        return $mmaCourseCompletion.getCompletion(course.id, userid).then(function(completion) {
            completion.statusText = $mmaCourseCompletion.getCompletedStatusText(completion);
            $scope.completion = completion;
            $scope.showSelfComplete = $mmaCourseCompletion.isSelfCompletionAvailable() &&
                                        $mmaCourseCompletion.canMarkSelfCompleted(userid, completion);
        }).catch(function(message) {
            if (message) {
                $mmUtil.showErrorModal(message);
            } else {
                $mmUtil.showErrorModal('mma.coursecompletion.couldnotloadreport', true);
            }
        });
    }
    fetchCompletion().finally(function() {
        $scope.completionLoaded = true;
    });
    function refreshCompletion() {
        return $mmaCourseCompletion.invalidateCourseCompletion(course.id, userid).finally(function() {
            return fetchCompletion();
        });
    }
    $scope.refreshCompletion = function() {
        refreshCompletion().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
    $scope.completeCourse = function() {
        var modal = $mmUtil.showModalLoading('mm.core.sending', true);
        $mmaCourseCompletion.markCourseAsSelfCompleted(course.id).then(function() {
            return refreshCompletion();
        }).catch(function(message) {
            $mmUtil.showErrorModal(message);
        }).finally(function() {
            modal.dismiss();
        });
    };
}]);

angular.module('mm.addons.coursecompletion')
.factory('$mmaCourseCompletion', ["$mmSite", "$log", "$q", "$mmCourses", function($mmSite, $log, $q, $mmCourses) {
    $log = $log.getInstance('$mmaCourseCompletion');
    var self = {};
        self.canMarkSelfCompleted = function(userid, completion) {
        var selfCompletionActive = false,
            alreadyMarked = false;
        if ($mmSite.getUserId() != userid) {
            return false;
        }
        angular.forEach(completion.completions, function(criteria) {
            if (criteria.type === 1) {
                selfCompletionActive = true;
                alreadyMarked = criteria.complete;
            }
        });
        return selfCompletionActive && !alreadyMarked;
    };
        self.getCompletedStatusText = function(completion) {
        if (completion.completed) {
            return 'mma.coursecompletion.completed';
        } else {
            var hasStarted = false;
            angular.forEach(completion.completions, function(criteria) {
                if (criteria.timecompleted || criteria.complete) {
                    hasStarted = true;
                }
            });
            if (hasStarted) {
                return 'mma.coursecompletion.inprogress';
            } else {
                return 'mma.coursecompletion.notyetstarted';
            }
        }
    };
        self.getCompletion = function(courseid, userid) {
        userid = userid || $mmSite.getUserId();
        $log.debug('Get completion for course ' + courseid + ' and user ' + userid);
        var data = {
                courseid : courseid,
                userid: userid
            },
            preSets = {
                cacheKey: getCompletionCacheKey(courseid, userid)
            };
        return $mmSite.read('core_completion_get_course_completion_status', data, preSets).then(function(data) {
            if (data.completionstatus) {
                return data.completionstatus;
            }
            return $q.reject();
        });
    };
        function getCompletionCacheKey(courseid, userid) {
        return 'mmaCourseCompletion:view:' + courseid + ':' + userid;
    }
        self.invalidateCourseCompletion = function(courseid, userid) {
        userid = userid || $mmSite.getUserId();
        return $mmSite.invalidateWsCacheForKey(getCompletionCacheKey(courseid, userid));
    };
        self.isPluginViewEnabled = function() {
        if (!$mmSite.isLoggedIn()) {
            return false;
        } else if (!$mmSite.wsAvailable('core_completion_get_course_completion_status')) {
            return false;
        }
        return true;
    };
        self.isPluginViewEnabledForCourse = function(courseId) {
        if (!courseId) {
            return $q.reject();
        }
        return $mmCourses.getUserCourse(courseId, true).then(function(course) {
            if (course && typeof course.enablecompletion != 'undefined' && course.enablecompletion == 0) {
                return false;
            }
            return true;
        });
    };
        self.isPluginViewEnabledForUser = function(courseId, userId) {
        return self.getCompletion(courseId, userId).then(function() {
            return true;
        }).catch(function() {
            return false;
        });
    };
        self.isSelfCompletionAvailable = function() {
        return $mmSite.wsAvailable('core_completion_mark_course_self_completed');
    };
        self.markCourseAsSelfCompleted = function(courseid) {
        var params = {
            courseid: courseid
        };
        return $mmSite.write('core_completion_mark_course_self_completed', params).then(function(response) {
            if (!response.status) {
                return $q.reject();
            }
        });
    };
    return self;
}]);

angular.module('mm.addons.coursecompletion')
.factory('$mmaCourseCompletionHandlers', ["$mmaCourseCompletion", "$state", "mmCoursesAccessMethods", "mmUserProfileHandlersTypeNewPage", function($mmaCourseCompletion, $state, mmCoursesAccessMethods, mmUserProfileHandlersTypeNewPage) {
    var self = {},
        viewCompletionEnabledCache = {},
        coursesNavEnabledCache = {};
        function getCacheKey(courseId, userId) {
        return courseId + '#' + userId;
    }
        self.clearViewCompletionCache = function(courseId, userId) {
        if (courseId && userId) {
            delete viewCompletionEnabledCache[getCacheKey(courseId, userId)];
        } else {
            viewCompletionEnabledCache = {};
        }
    };
        self.clearCoursesNavCache = function() {
        coursesNavEnabledCache = {};
    };
        self.viewCompletion = function() {
        var self = {
            type: mmUserProfileHandlersTypeNewPage
        };
                self.isEnabled = function() {
            return $mmaCourseCompletion.isPluginViewEnabled();
        };
                self.isEnabledForUser = function(user, courseId, navOptions, admOptions) {
            return $mmaCourseCompletion.isPluginViewEnabledForCourse(courseId).then(function(courseEnabled) {
                var cacheKey = getCacheKey(courseId, user.id);
                if (!courseEnabled) {
                    viewCompletionEnabledCache[cacheKey] = false;
                }
                if (typeof viewCompletionEnabledCache[cacheKey] != 'undefined') {
                    return viewCompletionEnabledCache[cacheKey];
                }
                return $mmaCourseCompletion.isPluginViewEnabledForUser(courseId, user.id).then(function(enabled) {
                    viewCompletionEnabledCache[cacheKey] = enabled;
                    return enabled;
                });
            });
        };
                self.getController = function(user, courseId) {
                        return function($scope) {
                $scope.title = 'mma.coursecompletion.coursecompletion';
                $scope.class = 'mma-coursecompletion-user-handler';
                $scope.icon = 'ion-android-checkbox-outline';
                $scope.action = function($event) {
                    $event.preventDefault();
                    $event.stopPropagation();
                    $state.go('site.course-completion', {
                        userid: user.id,
                        course: {id: courseId}
                    });
                };
            };
        };
        return self;
    };
        self.coursesNav = function() {
        var self = {};
                self.isEnabled = function() {
            return $mmaCourseCompletion.isPluginViewEnabled();
        };
                self.isEnabledForCourse = function(courseId, accessData, navOptions, admOptions) {
            if (accessData && accessData.type == mmCoursesAccessMethods.guest) {
                return false;
            }
            return $mmaCourseCompletion.isPluginViewEnabledForCourse(courseId).then(function(courseEnabled) {
                if (!courseEnabled) {
                    coursesNavEnabledCache[courseId] = false;
                }
                if (typeof coursesNavEnabledCache[courseId] != 'undefined') {
                    return coursesNavEnabledCache[courseId];
                }
                return $mmaCourseCompletion.isPluginViewEnabledForUser(courseId).then(function(enabled) {
                    coursesNavEnabledCache[courseId] = enabled;
                    return enabled;
                });
            });
        };
                self.getController = function(courseId) {
                        return function($scope, $state) {
                $scope.icon = 'ion-android-checkbox-outline';
                $scope.title = 'mma.coursecompletion.coursecompletion';
                $scope.class = 'mma-coursecompletion-mine-handler';
                $scope.action = function($event, course) {
                    $event.preventDefault();
                    $event.stopPropagation();
                    $state.go('site.course-completion', {
                        course: course
                    });
                };
            };
        };
        return self;
    };
    return self;
}])
.run(["$mmaCourseCompletionHandlers", "$mmEvents", "mmCoreEventLogout", "mmCoursesEventMyCoursesRefreshed", "mmUserEventProfileRefreshed", function($mmaCourseCompletionHandlers, $mmEvents, mmCoreEventLogout, mmCoursesEventMyCoursesRefreshed,
            mmUserEventProfileRefreshed) {
    $mmEvents.on(mmCoreEventLogout, function() {
        $mmaCourseCompletionHandlers.clearViewCompletionCache();
        $mmaCourseCompletionHandlers.clearCoursesNavCache();
    });
    $mmEvents.on(mmCoursesEventMyCoursesRefreshed, $mmaCourseCompletionHandlers.clearCoursesNavCache);
    $mmEvents.on(mmUserEventProfileRefreshed, function(data) {
        if (data) {
            $mmaCourseCompletionHandlers.clearViewCompletionCache(data.courseid, data.userid);
        }
    });
}]);

angular.module('mm.addons.files')
.controller('mmaFilesIndexController', ["$scope", "$mmaFiles", "$mmSite", "$mmUtil", "$mmApp", "$mmaFilesHelper", "$mmEvents", "mmCoreEventSiteUpdated", function($scope, $mmaFiles, $mmSite, $mmUtil, $mmApp, $mmaFilesHelper, $mmEvents,
            mmCoreEventSiteUpdated) {
    var updateSiteObserver;
    function setData() {
        var canAccessFiles = $mmaFiles.canAccessFiles(),
            canAccessMyFiles = $mmSite.canAccessMyFiles(),
            canViewMyFiles = canAccessFiles && !$mmaFiles.isPrivateFilesDisabledInSite();
        $scope.showPrivateFiles = canViewMyFiles && canAccessMyFiles;
        $scope.showSiteFiles = !$mmaFiles.isSiteFilesDisabledInSite();
        $scope.canDownload = $mmSite.canDownloadFiles();
        $scope.showUpload = !canViewMyFiles && canAccessMyFiles && $mmSite.canUploadFiles() && !$mmaFiles.isUploadDisabledInSite();
    }
    setData();
    $scope.add = function() {
        $mmaFiles.versionCanUploadFiles().then(function(canUpload) {
            if (!canUpload) {
                $mmUtil.showModal('mm.core.notice', 'mma.files.erroruploadnotworking');
            } else if (!$mmApp.isOnline()) {
                $mmUtil.showErrorModal('mm.fileuploader.errormustbeonlinetoupload', true);
            } else {
                $mmaFilesHelper.selectAndUploadFile();
            }
        });
    };
    updateSiteObserver = $mmEvents.on(mmCoreEventSiteUpdated, function(siteId) {
        if ($mmSite.getId() === siteId) {
            setData();
        }
    });
    $scope.$on('$destroy', function() {
        updateSiteObserver && updateSiteObserver.off && updateSiteObserver.off();
    });
}]);

angular.module('mm.addons.files')
.controller('mmaFilesListController', ["$q", "$scope", "$stateParams", "$mmaFiles", "$mmSite", "$translate", "$mmUtil", "$mmaFilesHelper", "$mmApp", "mmaFilesMyComponent", "mmaFilesSiteComponent", function($q, $scope, $stateParams, $mmaFiles, $mmSite, $translate, $mmUtil,
        $mmaFilesHelper, $mmApp, mmaFilesMyComponent, mmaFilesSiteComponent) {
    var path = $stateParams.path,
        root = $stateParams.root,
        promise;
    $scope.count = -1;
    $scope.component = root === 'my' ? mmaFilesMyComponent : mmaFilesSiteComponent;
    function fetchFiles(root, path) {
        if (!path) {
            if (root === 'site') {
                promise = $mmaFiles.getSiteFiles();
                $scope.title = $translate.instant('mma.files.sitefiles');
            } else if (root === 'my') {
                promise = $mmaFiles.getMyFiles();
                $scope.title = $translate.instant('mma.files.files');
            } else {
                promise = $q.reject();
            }
        } else {
            pathdata = JSON.parse(path);
            promise = $mmaFiles.getFiles(pathdata);
            $scope.title = $stateParams.title;
        }
        return promise.then(function(files) {
            $scope.files = files.entries;
            $scope.count = files.count;
        }).catch(function() {
            $mmUtil.showErrorModal('mma.files.couldnotloadfiles', true);
        });
    }
    function refreshFiles() {
        return $mmaFiles.invalidateDirectory(root, path).finally(function() {
            return fetchFiles(root, path);
        });
    }
    fetchFiles(root, path).finally(function() {
        $scope.filesLoaded = true;
    });
    $scope.refreshFiles = function() {
        refreshFiles().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
    $scope.showUpload = root === 'my' && !path && $mmSite.canUploadFiles() && !$mmaFiles.isUploadDisabledInSite();
    $scope.add = function() {
        $mmaFiles.versionCanUploadFiles().then(function(canUpload) {
            if (!canUpload) {
                $mmUtil.showModal('mm.core.notice', 'mma.files.erroruploadnotworking');
            } else if (!$mmApp.isOnline()) {
                $mmUtil.showErrorModal('mm.fileuploader.errormustbeonlinetoupload', true);
            } else {
                $mmaFilesHelper.selectAndUploadFile().then(function() {
                    $scope.filesLoaded = false;
                    refreshFiles().finally(function() {
                        $scope.filesLoaded = true;
                    });
                });
            }
        });
    };
}]);

angular.module('mm.addons.files')
.factory('$mmaFiles', ["$mmSite", "$mmFS", "$q", "$log", "$mmSitesManager", "md5", function($mmSite, $mmFS, $q, $log, $mmSitesManager, md5) {
    $log = $log.getInstance('$mmaFiles');
    var self = {},
        defaultParams = {
            "contextid": 0,
            "component": "",
            "filearea": "",
            "itemid": 0,
            "filepath": "",
            "filename": ""
        };
        self.canAccessFiles = function() {
        return $mmSite.wsAvailable('core_files_get_files');
    };
        self.canMoveFromDraftToPrivate = function(siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.wsAvailable('core_user_add_user_private_files');
        });
    };
        self.getFiles = function(params) {
        var deferred = $q.defer(),
            options = {};
        options.cacheKey = getFilesListCacheKey(params);
        $mmSite.read('core_files_get_files', params, options).then(function(result) {
            var data = {
                entries: [],
                count: 0
            };
            if (typeof result.files == 'undefined') {
                deferred.reject();
                return;
            }
            angular.forEach(result.files, function(entry) {
                entry.link = {};
                entry.link.contextid = (entry.contextid) ? entry.contextid : "";
                entry.link.component = (entry.component) ? entry.component : "";
                entry.link.filearea = (entry.filearea) ? entry.filearea : "";
                entry.link.itemid = (entry.itemid) ? entry.itemid : 0;
                entry.link.filepath = (entry.filepath) ? entry.filepath : "";
                entry.link.filename = (entry.filename) ? entry.filename : "";
                if (entry.component && entry.isdir) {
                    entry.link.filename = "";
                }
                if (entry.isdir) {
                    entry.imgpath = $mmFS.getFolderIcon();
                } else {
                    entry.imgpath = $mmFS.getFileIcon(entry.filename);
                }
                entry.link = JSON.stringify(entry.link);
                entry.linkId = md5.createHash(entry.link);
                data.count += 1;
                data.entries.push(entry);
            });
            deferred.resolve(data);
        }, function() {
            deferred.reject();
        });
        return deferred.promise;
    };
        function getFilesListCacheKey(params) {
        var root = params.component === '' ? 'site' : 'my';
        return 'mmaFiles:list:' + root + ':' + params.contextid + ':' + params.filepath;
    }
        self.getMyFiles = function() {
        var params = getMyFilesRootParams();
        return self.getFiles(params);
    };
        function getMyFilesListCommonCacheKey() {
        return 'mmaFiles:list:my';
    }
        function getMyFilesRootParams() {
        var params = angular.copy(defaultParams, {});
        params.component = "user";
        params.filearea = "private";
        params.contextid = -1;
        params.contextlevel = "user";
        params.instanceid = $mmSite.getUserId();
        return params;
    }
        self.getSiteFiles = function() {
        var params = angular.copy(defaultParams, {});
        return self.getFiles(params);
    };
        function getSiteFilesListCommonCacheKey() {
        return 'mmaFiles:list:site';
    }
        self.invalidateDirectory = function(root, path, siteid) {
        siteid = siteid || $mmSite.getId();
        var params = {};
        if (!path) {
            if (root === 'site') {
                params = angular.copy(defaultParams, {});
            } else if (root === 'my') {
                params = getMyFilesRootParams();
            }
        } else {
            params = JSON.parse(path);
        }
        return $mmSitesManager.getSite(siteid).then(function(site) {
            return site.invalidateWsCacheForKey(getFilesListCacheKey(params));
        });
    };
        self.invalidateMyFiles = function() {
        return $mmSite.invalidateWsCacheForKeyStartingWith(getMyFilesListCommonCacheKey());
    };
        self.invalidateSiteFiles = function() {
        return $mmSite.invalidateWsCacheForKeyStartingWith(getSiteFilesListCommonCacheKey());
    };
        self.isDisabled = function(siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return self.isDisabledInSite(site);
        });
    };
        self.isDisabledInSite = function(site) {
        site = site || $mmSite;
        return site.isFeatureDisabled('$mmSideMenuDelegate_mmaFiles');
    };
        self.isPluginEnabled = function() {
        var canAccessMyFiles = $mmSite.canAccessMyFiles(),
            canViewMyFiles = self.canAccessFiles() && canAccessMyFiles && !self.isPrivateFilesDisabledInSite(),
            canViewSiteFiles = !self.isSiteFilesDisabledInSite(),
            canUploadFiles = canAccessMyFiles && $mmSite.canUploadFiles() && !self.isUploadDisabledInSite();
        return canViewMyFiles || canViewSiteFiles || canUploadFiles;
    };
        self.isPrivateFilesDisabled = function(siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return self.isPrivateFilesDisabledInSite(site);
        });
    };
        self.isPrivateFilesDisabledInSite = function(site) {
        site = site || $mmSite;
        return site.isFeatureDisabled('files_privatefiles');
    };
        self.isSiteFilesDisabled = function(siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return self.isSiteFilesDisabledInSite(site);
        });
    };
        self.isSiteFilesDisabledInSite = function(site) {
        site = site || $mmSite;
        return site.isFeatureDisabled('files_sitefiles');
    };
        self.isUploadDisabled = function(siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return self.isUploadDisabledInSite(site);
        });
    };
        self.isUploadDisabledInSite = function(site) {
        site = site || $mmSite;
        return site.isFeatureDisabled('files_upload');
    };
        self.moveFromDraftToPrivate = function(draftId, siteId) {
        siteId = siteId || $mmSite.getId();
        var params = {
                draftid: draftId
            },
            preSets = {
                responseExpected: false
            };
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.write('core_user_add_user_private_files', params, preSets);
        });
    };
        self.shouldMoveFromDraftToPrivate = function(siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.isVersionGreaterEqualThan('3.1.0');
        });
    };
        self.versionCanUploadFiles = function(siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            if (site.isVersionGreaterEqualThan('3.1.1')) {
                return self.canMoveFromDraftToPrivate(siteId);
            } else if (site.isVersionGreaterEqualThan('3.1.0')) {
                return false;
            }
            return true;
        });
    };
    return self;
}]);

angular.module('mm.addons.files')
.factory('$mmaFilesHandlers', ["$log", "$mmaFiles", function($log, $mmaFiles) {
    $log = $log.getInstance('$mmaFilesHandlers');
    var self = {};
        self.sideMenuNav = function() {
        var self = {};
                self.isEnabled = function() {
            return $mmaFiles.isPluginEnabled();
        };
                self.getController = function() {
                        return function($scope) {
                $scope.icon = 'ion-folder';
                $scope.title = 'mma.files.files';
                $scope.state = 'site.files';
                $scope.class = 'mma-files-handler';
            };
        };
        return self;
    };
    return self;
}]);

angular.module('mm.addons.files')
.factory('$mmaFilesHelper', ["$q", "$mmUtil", "$log", "$mmaFiles", "$mmFileUploaderHelper", "$mmSite", function($q, $mmUtil, $log, $mmaFiles, $mmFileUploaderHelper, $mmSite) {
    $log = $log.getInstance('$mmaFilesHelper');
    var self = {};
        self.selectAndUploadFile = function() {
        var maxSize = $mmSite.getInfo().usermaxuploadfilesize,
            userQuota = $mmSite.getInfo().userquota;
        if (userQuota === 0) {
            userQuota = -1;
        }
        if (typeof maxSize == 'undefined') {
            if (typeof userQuota != 'undefined') {
                maxSize = userQuota;
            } else {
                maxSize = -1;
            }
        } else if (typeof userQuota != 'undefined') {
            maxSize = Math.min(maxSize, userQuota);
        }
        return $mmFileUploaderHelper.selectAndUploadFile(maxSize).then(function(result) {
            return $mmaFiles.shouldMoveFromDraftToPrivate().then(function(move) {
                if (move) {
                    if (!result) {
                        return $q.reject();
                    }
                    var modal = $mmUtil.showModalLoading('mm.fileuploader.uploading', true);
                    return $mmaFiles.moveFromDraftToPrivate(result.itemid).catch(function(error) {
                        if (error) {
                            $mmUtil.showErrorModal(error);
                        } else {
                            $mmUtil.showErrorModal('mm.fileuploader.errorwhileuploading', true);
                        }
                        return $q.reject();
                    }).finally(function() {
                        modal.dismiss();
                    });
                }
            });
        }).then(function() {
            $mmUtil.showModal('mm.core.success', 'mm.fileuploader.fileuploaded');
        });
    };
    return self;
}]);

angular.module('mm.addons.frontpage')
.controller('mmaFrontpageCtrl', ["$mmCourse", "$mmUtil", "$scope", "$stateParams", "$mmSite", "$q", "$mmCoursePrefetchDelegate", "$mmCourseHelper", function($mmCourse, $mmUtil, $scope, $stateParams, $mmSite, $q, $mmCoursePrefetchDelegate,
            $mmCourseHelper) {
    var courseId = $mmSite.getSiteHomeId(),
        moduleId = $stateParams.moduleid,
        sectionsLoaded;
    $scope.items = [];
    $scope.sectionHasContent = $mmCourseHelper.sectionHasContent;
    function loadContent() {
        $scope.hasContent = false;
        var config = $mmSite.getStoredConfig() || {numsections: 1};
        if (config.frontpageloggedin) {
            var frontpageItems = [
                    'mma-frontpage-item-news',
                    false,
                    'mma-frontpage-item-categories',
                    false,
                    'mma-frontpage-item-categories',
                    'mma-frontpage-item-enrolled-course-list',
                    'mma-frontpage-item-all-course-list',
                    'mma-frontpage-item-course-search'
                ],
                items = config.frontpageloggedin.split(',');
            $scope.items = [];
            angular.forEach(items, function (itemNumber) {
                var item = frontpageItems[parseInt(itemNumber, 10)];
                if (!item || $scope.items.indexOf(item) >= 0) {
                    return;
                }
                $scope.hasContent = true;
                $scope.items.push(item);
            });
        }
        return $mmCourse.getSections(courseId, false, true).then(function(sections) {
            sectionsLoaded = sections;
            if (config.numsections && sections.length > 0) {
                $scope.section = sections.pop();
            } else {
                $scope.section = false;
            }
            if (sections.length > 0) {
                $scope.block = sections.pop();
            } else {
                $scope.block = false;
            }
            $scope.hasContent = $mmCourseHelper.addContentHandlerControllerForSectionModules([$scope.section, $scope.block],
                courseId, moduleId, false, $scope) || $scope.hasContent;
            $mmCourse.logView(courseId);
        }, function(error) {
            $mmUtil.showErrorModalDefault(error, 'mm.course.couldnotloadsectioncontent', true);
        });
    }
    loadContent().finally(function() {
        $scope.frontpageLoaded = true;
    });
    $scope.doRefresh = function() {
        var promises = [];
        promises.push($mmCourse.invalidateSections(courseId));
        promises.push($mmSite.invalidateConfig());
        if (sectionsLoaded) {
            var modules = $mmCourseHelper.getSectionsModules(sectionsLoaded);
            promises.push($mmCoursePrefetchDelegate.invalidateModules(modules, courseId));
        }
        $q.all(promises).finally(function() {
            loadContent().finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };
}]);

angular.module('mm.addons.frontpage')
.directive('mmaFrontpageItem', ["$compile", function($compile) {
    return {
        restrict: 'E',
        scope: {
            name: '@'
        },
        templateUrl: 'addons/frontpage/templates/frontpageitem.html',
        link: function(scope, element) {
            var container = element[0].querySelector('.mma-frontpage-item-container')
            if (typeof scope.name == "undefined" || !container) {
                return;
            }
            container.setAttribute(scope.name, '');
            $compile(container)(scope);
        }
    };
}]);

angular.module('mm.addons.frontpage')
.directive('mmaFrontpageItemAllCourseList', ["$mmCourses", function($mmCourses) {
    return {
        restrict: 'A',
        priority: 100,
        templateUrl: 'addons/frontpage/templates/frontpageitemallcourselist.html',
        link: function(scope) {
            scope.show = $mmCourses.isGetCoursesByFieldAvailable();
        }
    };
}]);

angular.module('mm.addons.frontpage')
.directive('mmaFrontpageItemCategories', ["$mmCourses", function($mmCourses) {
    return {
        restrict: 'A',
        priority: 100,
        templateUrl: 'addons/frontpage/templates/frontpageitemcategories.html',
        link: function(scope) {
            scope.show = $mmCourses.isGetCategoriesAvailable() && $mmCourses.isGetCoursesByFieldAvailable();
        }
    };
}]);

angular.module('mm.addons.frontpage')
.directive('mmaFrontpageItemCourseSearch', ["$mmCourses", function($mmCourses) {
    return {
        restrict: 'A',
        priority: 100,
        templateUrl: 'addons/frontpage/templates/frontpageitemcoursesearch.html',
        link: function(scope) {
            scope.show = !$mmCourses.isSearchCoursesDisabledInSite();
        }
    };
}]);

angular.module('mm.addons.frontpage')
.directive('mmaFrontpageItemEnrolledCourseList', ["$mmCourses", function($mmCourses) {
    return {
        restrict: 'A',
        priority: 100,
        templateUrl: 'addons/frontpage/templates/frontpageitemenrolledcourselist.html',
        link: function(scope) {
            return $mmCourses.getUserCourses().then(function(courses) {
                scope.show = courses.length > 0 && !$mmCourses.isMyCoursesDisabledInSite();
            });
        }
    };
}]);

angular.module('mm.addons.frontpage')
.directive('mmaFrontpageItemNews', ["$mmCourse", "$mmSite", "$mmAddonManager", "$mmCourseDelegate", function($mmCourse, $mmSite, $mmAddonManager, $mmCourseDelegate) {
    return {
        restrict: 'A',
        priority: 100,
        templateUrl: 'addons/frontpage/templates/frontpageitemnews.html',
        link: function(scope) {
            var newsitems = $mmSite.getStoredConfig('newsitems') || 0;
            if (!newsitems) {
                return;
            }
            var courseId = $mmSite.getSiteHomeId();
            $mmaModForum = $mmAddonManager.get('$mmaModForum');
            if ($mmaModForum) {
                return $mmaModForum.getCourseForums(courseId).then(function(forums) {
                    for (var x in forums) {
                        if (forums[x].type == 'news') {
                            return forums[x];
                        }
                    }
                }).then(function(forum) {
                    if (forum) {
                        return $mmCourse.getModuleBasicInfo(forum.cmid).then(function(module) {
                            scope.show = true;
                            scope.module = module;
                            scope.module._controller =
                                $mmCourseDelegate.getContentHandlerControllerFor(module.modname, module, courseId,
                                    module.section);
                        });
                    }
                });
            }
        }
    };
}]);

angular.module('mm.addons.frontpage')
.factory('$mmaFrontpage', ["$mmSite", "$log", "$q", "$mmCourse", "$mmSitesManager", function($mmSite, $log, $q, $mmCourse, $mmSitesManager) {
    $log = $log.getInstance('$mmaFrontpage');
    var self = {};
        self.isDisabled = function(siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return self.isDisabledInSite(site);
        });
    };
        self.isDisabledInSite = function(site) {
        site = site || $mmSite;
        return site.isFeatureDisabled('$mmSideMenuDelegate_mmaFrontpage');
    };
        self.isPluginEnabled = function() {
        if (!$mmSite.isLoggedIn()) {
            return false;
        }
        return true;
    };
        self.isFrontpageAvailable = function(siteId) {
        $log.debug('Using WS call to check if frontpage is available.');
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var siteHomeId = site.getSiteHomeId(),
                hasData = false;
            return $mmCourse.getSections(siteHomeId, false, true, {emergencyCache: false}, siteId).then(function(data) {
                if (!angular.isArray(data) || !data.length) {
                    return $q.reject();
                }
                angular.forEach(data, function(section) {
                    if (section.summary || (section.modules && section.modules.length)) {
                        hasData = true;
                    }
                });
                if (!hasData) {
                    return $q.reject();
                }
            }).catch(function() {
                var config = site.getStoredConfig();
                if (config && config.frontpageloggedin) {
                    var items = config.frontpageloggedin.split(',');
                    if (items.length > 0) {
                        return;
                    }
                }
                if (!hasData) {
                    return $q.reject();
                }
            });
        });
    };
    return self;
}]);

angular.module('mm.addons.frontpage')
.factory('$mmaFrontPageHandlers', ["$log", "$mmaFrontpage", "$state", "$mmSitesManager", "$mmContentLinkHandlerFactory", function($log, $mmaFrontpage, $state, $mmSitesManager, $mmContentLinkHandlerFactory) {
    $log = $log.getInstance('$mmaFrontPageHandlers');
    var self = {};
        self.sideMenuNav = function() {
        var self = {};
                self.isEnabled = function() {
            if ($mmaFrontpage.isPluginEnabled()) {
                return $mmaFrontpage.isFrontpageAvailable().then(function() {
                    return true;
                });
            }
            return false;
        };
                self.getController = function() {
                        return function($scope) {
                $scope.icon = 'ion-home';
                $scope.title = 'mma.frontpage.sitehome';
                $scope.state = 'site.frontpage';
                $scope.class = 'mma-frontpage-handler';
            };
        };
        return self;
    };
        self.linksHandler = $mmContentLinkHandlerFactory.createChild(
                /\/course\/view\.php.*([\?\&]id=\d+)/, '$mmSideMenuDelegate_mmaFrontpage');
    self.linksHandler.isEnabled = function(siteId, url, params, courseId) {
        courseId = parseInt(params.id, 10);
        if (!courseId) {
            return false;
        }
        return $mmSitesManager.getSite(siteId).then(function(site) {
            if (courseId != site.getSiteHomeId()) {
                return false;
            }
            return $mmaFrontpage.isFrontpageAvailable(siteId).then(function() {
                return true;
            }).catch(function() {
                return false;
            });
        });
    };
    self.linksHandler.getActions = function(siteIds, url, params, courseId) {
        return [{
            action: function(siteId) {
                $state.go('redirect', {
                    siteid: siteId,
                    state: 'site.frontpage'
                });
            }
        }];
    };
    return self;
}]);

angular.module('mm.addons.grades')
.controller('mmaGradesCoursesGradesCtrl', ["$scope", "$mmUtil", "$mmaCoursesGrades", "$mmSite", "$log", function($scope, $mmUtil, $mmaCoursesGrades, $mmSite, $log) {
    $log = $log.getInstance('mmaGradesCoursesGradesCtrl');
    $scope.userid = $mmSite.getUserId();
    $scope.grades = [];
    function fetchCoursesGrades() {
        return $mmaCoursesGrades.getGrades().then(function(grades) {
            return $mmaCoursesGrades.getGradesCourseData(grades).then(function(grades) {
               $scope.grades = grades;
            });
        }, function(message) {
            $mmUtil.showErrorModal(message);
        });
    }
    fetchCoursesGrades().then(function() {
        var courseId = $mmSite.getSiteHomeId();
        $mmSite.write('gradereport_overview_view_grade_report', {
            courseid: courseId,
        });
    }).finally(function() {
        $scope.gradesLoaded = true;
    });
    $scope.refreshGrades = function() {
        $mmaCoursesGrades.invalidateCoursesGradesData().finally(function() {
            fetchCoursesGrades().finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };
}]);

angular.module('mm.addons.grades')
.factory('$mmaCoursesGrades', ["$q", "$log", "$mmSite", "$mmCourses", "$mmSitesManager", "$mmCourses", function($q, $log, $mmSite, $mmCourses, $mmSitesManager, $mmCourses) {
    $log = $log.getInstance('$mmaCoursesGrades');
    var self = {};
        function getCoursesGradesCacheKey() {
        return 'mmaGrades:coursesgrades';
    }
        self.invalidateCoursesGradesData = function(siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getCoursesGradesCacheKey());
        });
    };
        self.isPluginEnabled = function(siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            if (!site.wsAvailable('gradereport_overview_get_course_grades')) {
                return false;
            }
            var url = site.getStoredConfig('mygradesurl') || '';
            return url.indexOf('/grade/report/overview/') !== -1;
        });
    };
        self.getGrades = function(siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            $log.debug('Get course grades');
            var data = {},
                preSets = {
                    cacheKey: getCoursesGradesCacheKey()
                };
            return site.read('gradereport_overview_get_course_grades', data, preSets).then(function (data) {
                if (data && data.grades) {
                    return data.grades;
                }
                return $q.reject();
            });
        });
    };
        self.getGradesCourseData = function(grades) {
        return $mmCourses.getUserCourses(true).then(function(courses){
            var indexedCourses = {};
            angular.forEach(courses, function(course) {
                indexedCourses[course.id] = course;
            });
            angular.forEach(grades, function(grade) {
                if (typeof indexedCourses[grade.courseid] != 'undefined') {
                    grade.coursefullname = indexedCourses[grade.courseid].fullname;
                }
            });
            return grades;
        });
    };
    return self;
}]);

angular.module('mm.addons.grades')
.factory('$mmaGradesHandlers', ["$mmGrades", "$mmaCoursesGrades", "$state", "$mmContentLinksHelper", "$mmContentLinkHandlerFactory", "mmCoursesAccessMethods", "mmUserProfileHandlersTypeNewPage", function($mmGrades, $mmaCoursesGrades, $state, $mmContentLinksHelper, $mmContentLinkHandlerFactory,
            mmCoursesAccessMethods, mmUserProfileHandlersTypeNewPage) {
    var self = {},
        viewGradesEnabledCache = {};
        function getCacheKey(courseId, userId) {
        return courseId + '#' + userId;
    }
        self.clearViewGradesCache = function(courseId, userId) {
        if (courseId && userId) {
            delete viewGradesEnabledCache[getCacheKey(courseId, userId)];
        } else {
            viewGradesEnabledCache = {};
        }
    };
        self.coursesNav = function() {
        var self = {};
                self.isEnabled = function() {
            return $mmGrades.isPluginEnabled();
        };
                self.isEnabledForCourse = function(courseId, accessData, navOptions, admOptions) {
            if (accessData && accessData.type == mmCoursesAccessMethods.guest) {
                return false;
            }
            if (navOptions && typeof navOptions.grades != 'undefined') {
                return navOptions.grades;
            }
            return $mmGrades.isPluginEnabledForCourse(courseId);
        };
                self.getController = function() {
                        return function($scope, $state) {
                $scope.icon = 'ion-stats-bars';
                $scope.title = 'mm.grades.grades';
                $scope.class = 'mma-grades-mine-handler';
                $scope.action = function($event, course) {
                    $event.preventDefault();
                    $event.stopPropagation();
                    $state.go('site.grades', {
                        course: course
                    });
                };
            };
        };
        return self;
    };
        self.viewGrades = function() {
        var self = {
            type: mmUserProfileHandlersTypeNewPage
        };
                self.isEnabled = function() {
            return $mmGrades.isPluginEnabled();
        };
                self.isEnabledForUser = function(user, courseId, navOptions, admOptions) {
            return $mmGrades.isPluginEnabledForCourse(courseId).then(function() {
                var cacheKey = getCacheKey(courseId, user.id);
                if (typeof viewGradesEnabledCache[cacheKey] != 'undefined') {
                    return viewGradesEnabledCache[cacheKey];
                }
                return $mmGrades.isPluginEnabledForUser(courseId, user.id).then(function(enabled) {
                    viewGradesEnabledCache[cacheKey] = enabled;
                    return enabled;
                });
            });
        };
                self.getController = function(user, courseId) {
                        return function($scope) {
                $scope.title = 'mm.grades.grades';
                $scope.class = 'mma-grades-user-handler';
                $scope.icon = 'ion-stats-bars';
                $scope.action = function($event) {
                    $event.preventDefault();
                    $event.stopPropagation();
                    $state.go('site.grades', {
                        userid: user.id,
                        course: {id: courseId}
                    });
                };
            };
        };
        return self;
    };
        self.userLinksHandler = $mmContentLinkHandlerFactory.createChild(
                '/grade/report/user/index.php', '$mmUserDelegate_mmaGrades:viewGrades');
    self.userLinksHandler.isEnabled = function(siteId, url, params, courseId) {
        courseId = parseInt(params.id, 10) || courseId;
        if (!courseId) {
            return false;
        }
        return $mmGrades.isPluginEnabled(siteId).then(function(enabled) {
            if (!enabled) {
                return false;
            }
            return $mmGrades.isPluginEnabledForCourse(courseId, siteId);
        });
    };
    self.userLinksHandler.getActions = function(siteIds, url, params, courseId) {
        courseId = parseInt(params.id, 10) || courseId;
        return [{
            action: function(siteId) {
                var stateParams = {
                    course: {id: courseId},
                    userid: params.userid ? parseInt(params.userid, 10) : false,
                    courseid: courseId,
                    forcephoneview: false
                };
                $mmContentLinksHelper.goInSite('site.grades', stateParams, siteId);
            }
        }];
    };
        self.overviewLinksHandler = $mmContentLinkHandlerFactory.createChild(
                '/grade/report/overview/index.php', '$mmSideMenuDelegate_mmaGrades');
    self.overviewLinksHandler.isEnabled = $mmaCoursesGrades.isPluginEnabled;
    self.overviewLinksHandler.getActions = function(siteIds, url, params, courseId) {
        return [{
            action: function(siteId) {
                $state.go('redirect', {
                    siteid: siteId,
                    state: 'site.coursesgrades',
                    params: {}
                });
            }
        }];
    };
        self.sideMenuNav = function() {
        var self = {};
                self.isEnabled = function() {
            return $mmaCoursesGrades.isPluginEnabled();
        };
                self.getController = function() {
                        return function($scope) {
                $scope.icon = 'ion-stats-bars';
                $scope.title = 'mm.grades.grades';
                $scope.state = 'site.coursesgrades';
                $scope.class = 'mma-grades-coursesgrades';
            };
        };
        return self;
    };
    return self;
}])
.run(["$mmaGradesHandlers", "$mmEvents", "mmCoreEventLogout", "mmUserEventProfileRefreshed", function($mmaGradesHandlers, $mmEvents, mmCoreEventLogout, mmUserEventProfileRefreshed) {
    $mmEvents.on(mmCoreEventLogout, $mmaGradesHandlers.clearViewGradesCache);
    $mmEvents.on(mmUserEventProfileRefreshed, function(data) {
        if (data) {
            $mmaGradesHandlers.clearViewGradesCache(data.courseid, data.userid);
        }
    });
}]);

angular.module('mm.addons.messages')
.controller('mmaMessagesContactsCtrl', ["$scope", "$mmaMessages", "$mmSite", "$mmUtil", "$mmApp", "mmUserProfileState", "$q", "$translate", function($scope, $mmaMessages, $mmSite, $mmUtil, $mmApp, mmUserProfileState, $q,
            $translate) {
    var currentUserId = $mmSite.getUserId(),
        searchingMessage = $translate.instant('mm.core.searching'),
        loadingMessage = $translate.instant('mm.core.loading'),
        searchedString;
    $scope.loaded = false;
    $scope.contactTypes = ['online', 'offline', 'blocked', 'strangers', 'search'];
    $scope.searchType = 'search';
    $scope.hasContacts = false;
    $scope.canSearch = $mmaMessages.isSearchEnabled;
    $scope.formData = {
        searchString: ''
    };
    $scope.userStateName = mmUserProfileState;
    $scope.refresh = function() {
        var promise;
        if (searchedString) {
            promise = search(searchedString);
        } else {
            promise = $mmaMessages.invalidateAllContactsCache(currentUserId).then(function() {
                return fetchContacts(true);
            });
        }
        promise.finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
    $scope.search = function(query) {
        $mmApp.closeKeyboard();
        $scope.loaded = false;
        $scope.loadingMessage = searchingMessage;
        return search(query).finally(function() {
            $scope.loaded = true;
        });
    };
    $scope.clearSearch = function() {
        $scope.loaded = false;
        fetchContacts().finally(function() {
            $scope.loaded = true;
        });
    };
    function search(query) {
        return $mmaMessages.searchContacts(query).then(function(result) {
            $scope.hasContacts = result.length > 0;
            searchedString = query;
            $scope.contacts = {
                search: result
            };
        }).catch(function(error) {
            $mmUtil.showErrorModalDefault(error, 'mma.messages.errorwhileretrievingcontacts', true);
            return $q.reject();
        });
    }
    function fetchContacts() {
        $scope.loadingMessage = loadingMessage;
        return $mmaMessages.getAllContacts().then(function(contacts) {
            $scope.contacts = contacts;
            searchedString = false;
            angular.forEach(contacts, function(contact) {
                if (contact.length > 0) {
                    $scope.hasContacts = true;
                }
            });
        }).catch(function(error) {
            $mmUtil.showErrorModalDefault(error, 'mma.messages.errorwhileretrievingcontacts', true);
            return $q.reject();
        });
    }
    fetchContacts().finally(function() {
        $scope.loaded = true;
    });
}]);

angular.module('mm.addons.messages')
.controller('mmaMessagesDiscussionCtrl', ["$scope", "$stateParams", "$mmApp", "$mmaMessages", "$mmSite", "$timeout", "$mmEvents", "$window", "$ionicScrollDelegate", "mmUserProfileState", "$mmUtil", "mmaMessagesPollInterval", "$interval", "$log", "$ionicHistory", "$ionicPlatform", "mmCoreEventKeyboardShow", "mmCoreEventKeyboardHide", "mmaMessagesDiscussionLoadedEvent", "mmaMessagesDiscussionLeftEvent", "$mmUser", "$translate", "mmaMessagesNewMessageEvent", "mmaMessagesAutomSyncedEvent", "$mmaMessagesSync", "$q", "md5", "$mmText", "mmaMessagesReadChangedEvent", function($scope, $stateParams, $mmApp, $mmaMessages, $mmSite, $timeout, $mmEvents, $window,
        $ionicScrollDelegate, mmUserProfileState, $mmUtil, mmaMessagesPollInterval, $interval, $log, $ionicHistory, $ionicPlatform,
        mmCoreEventKeyboardShow, mmCoreEventKeyboardHide, mmaMessagesDiscussionLoadedEvent, mmaMessagesDiscussionLeftEvent,
        $mmUser, $translate, mmaMessagesNewMessageEvent, mmaMessagesAutomSyncedEvent, $mmaMessagesSync, $q, md5, $mmText,
        mmaMessagesReadChangedEvent) {
    $log = $log.getInstance('mmaMessagesDiscussionCtrl');
    var userId = $stateParams.userId,
        messagesBeingSent = 0,
        polling,
        fetching,
        backView = $ionicHistory.backView(),
        lastMessage = {message: '', timecreated: 0},
        scrollView = $ionicScrollDelegate.$getByHandle('mmaMessagesScroll'),
        canDelete = $mmaMessages.canDeleteMessages(),
        syncObserver,
        scrollKeyboardInitialized = false,
        pagesLoaded = 1,
        unreadMessageFrom = false;
    $scope.showKeyboard = $stateParams.showKeyboard;
    $scope.loaded = false;
    $scope.messages = [];
    $scope.userId = userId;
    $scope.currentUserId = $mmSite.getUserId();
    $scope.data = {
        showDelete: false,
        canDelete: false
    };
    $scope.canLoadMore = false;
    $scope.loadingPrevious = false;
    if (backView && backView.stateName === mmUserProfileState) {
        $scope.profileLink = false;
    }
    if (userId) {
        $mmUser.getProfile(userId, undefined, true).then(function(user) {
            if (!$scope.title) {
                $scope.title = user.fullname;
            }
            if (typeof $scope.profileLink == 'undefined') {
                $scope.profileLink = user.profileimageurl || true;
            }
        }).catch(function() {
            $scope.profileLink = true;
        });
    }
    $scope.showDate = function(message, prevMessage) {
        if (!prevMessage) {
            return true;
        } else if (message.pending) {
            return false;
        }
        return !moment(message.timecreated).isSame(prevMessage.timecreated, 'day');
    };
        $scope.copyMessage = function(text) {
        $mmUtil.copyToClipboard(text);
    };
    $scope.sendMessage = function(text) {
        var message;
        if (!text.trim()) {
            return;
        }
        hideUnreadLabel();
        $scope.data.showDelete = false;
        $scope.newMessage = '';
        text = $mmText.replaceNewLines(text, '<br>');
        message = {
            pending: true,
            sending: true,
            useridfrom: $scope.currentUserId,
            smallmessage: text,
            text: text,
            timecreated: new Date().getTime()
        };
        $scope.messages.push(message);
        messagesBeingSent++;
        waitForFetch().finally(function() {
            $mmaMessages.sendMessage(userId, text).then(function(data) {
                var promise;
                messagesBeingSent--;
                if (data.sent) {
                    promise = fetchMessages();
                } else {
                    promise = $q.reject();
                }
                promise.catch(function() {
                    message.sending = false;
                    if (data.sent) {
                        message.pending = false;
                    } else if (data.message) {
                        message.timecreated = data.message.timecreated;
                    }
                    notifyNewMessage();
                });
            }).catch(function(error) {
                messagesBeingSent--;
                $mmApp.closeKeyboard();
                $mmUtil.showErrorModalDefault(error, 'mma.messages.messagenotsent', true);
                $scope.messages.splice($scope.messages.indexOf(message), 1);
            });
        });
    };
    $mmaMessagesSync.syncDiscussion(userId).catch(function() {
    }).then(function(warnings) {
        if (warnings && warnings[0]) {
            $mmUtil.showErrorModal(warnings[0]);
        }
        fetchMessages().then(function() {
            if (!$scope.title && $scope.messages.length) {
                if ($scope.messages[0].useridto != $scope.currentUserId) {
                    $scope.title = $scope.messages[0].usertofullname || '';
                } else {
                    $scope.title = $scope.messages[0].userfromfullname || '';
                }
            }
        }, function(error) {
            $mmUtil.showErrorModalDefault(error, 'mma.messages.errorwhileretrievingmessages', true);
        }).finally(function() {
            triggerDiscussionLoadedEvent();
            $scope.loaded = true;
        });
    });
    var triggerDiscussionLoadedEvent = function() {
        if (canDelete) {
            var first = $scope.messages[0];
            $scope.data.canDelete = first && !first.sending;
        }
        if ($ionicPlatform.isTablet()) {
            $mmEvents.trigger(mmaMessagesDiscussionLoadedEvent, {userId: $scope.userId, canDelete: $scope.data.canDelete});
        }
    };
    $scope.scrollAfterRender = function(scope) {
        if (scope.$last === true) {
            if (scrollView.getScrollPosition().top == scrollView.getScrollView().getScrollMax().top) {
                $timeout(function() {
                    scrollView.scrollBottom();
                    if (!scrollKeyboardInitialized) {
                        setScrollWithKeyboard();
                    }
                });
            }
        }
    };
    $scope.toggleDelete = function() {
        $scope.data.showDelete = !$scope.data.showDelete;
    };
    function fetchMessages() {
        $log.debug('Polling new messages for discussion with user ' + userId);
        if (messagesBeingSent > 0) {
            return $q.reject();
        } else if (fetching) {
            return $q.reject();
        }
        fetching = true;
        return $mmaMessagesSync.waitForSync(userId).then(function() {
            return $mmaMessages.invalidateDiscussionCache(userId).catch(function() {
            });
        }).then(function() {
            return getDiscussion(pagesLoaded);
        }).then(function(messages) {
            if (messagesBeingSent > 0) {
                return $q.reject();
            }
            var currentMessages = {};
            angular.forEach($scope.messages, function(message) {
                var id = md5.createHash(message.smallmessage) + '#' + message.timecreated;
                currentMessages[id] = {
                    message: message
                };
            });
            angular.forEach(messages, function(message) {
                var id = md5.createHash(message.smallmessage) + '#' + message.timecreated;
                if (!currentMessages[id]) {
                    $scope.messages.push(message);
                } else {
                    currentMessages[id].keep = true;
                }
            });
            angular.forEach(currentMessages, function(entry) {
                if (entry.keep) {
                    return;
                }
                var position = $scope.messages.indexOf(entry.message);
                if (position != -1) {
                    $scope.messages.splice(position, 1);
                }
            });
            $mmaMessages.sortMessages($scope.messages);
            notifyNewMessage();
            markMessagesAsRead();
        }).finally(function() {
            fetching = false;
        });
    }
    function hideUnreadLabel() {
        if (typeof unreadMessageFrom == 'number') {
            angular.forEach($scope.messages, function(message) {
                if (message.id == unreadMessageFrom) {
                    message.unreadFrom = false;
                }
            });
            unreadMessageFrom = true;
        }
    }
    function waitForFetch() {
        if (!fetching) {
            return $q.when();
        }
        return $timeout(function() {
            return waitForFetch();
        }, 400);
    }
    function markMessagesAsRead() {
        var readChanged = false,
            previousMessageRead = false,
            promises = [];
        angular.forEach($scope.messages, function(message) {
            if (message.useridfrom != $scope.currentUserId) {
                if (message.read == 0) {
                    promises.push($mmaMessages.markMessageRead(message.id).then(function() {
                        readChanged = true;
                        message.read = 1;
                    }));
                }
                if (!unreadMessageFrom) {
                    message.unreadFrom = message.read == 0 && previousMessageRead;
                    unreadMessageFrom = message.unreadFrom && parseInt(message.id, 10);
                    previousMessageRead = message.read != 0;
                }
            }
        });
        if (!unreadMessageFrom) {
            unreadMessageFrom = true;
        }
        $q.all(promises).finally(function() {
            if (readChanged) {
                $mmEvents.trigger(mmaMessagesReadChangedEvent, {
                    siteid: $mmSite.getId(),
                    userid: userId
                });
            }
        });
    }
    function getDiscussion(pagesToLoad, lfReceivedUnread, lfReceivedRead, lfSentUnread, lfSentRead) {
        lfReceivedUnread = lfReceivedUnread || 0;
        lfReceivedRead = lfReceivedRead || 0;
        lfSentUnread = lfSentUnread || 0;
        lfSentRead = lfSentRead || 0;
        var excludePending = lfReceivedUnread > 0 || lfReceivedRead > 0 || lfSentUnread > 0 || lfSentRead > 0;
        return $mmaMessages.getDiscussion(userId, excludePending, lfReceivedUnread, lfReceivedRead, lfSentUnread, lfSentRead)
                .then(function(result) {
            pagesToLoad--;
            if (pagesToLoad > 0 && result.canLoadMore) {
                angular.forEach(result.messages, function(message) {
                    if (!message.pending) {
                        if (message.useridfrom == userId) {
                            if (message.read) {
                                lfReceivedRead++;
                            } else {
                                lfReceivedUnread++;
                            }
                        } else {
                            if (message.read) {
                                lfSentRead++;
                            } else {
                                lfSentUnread++;
                            }
                        }
                    }
                });
                return getDiscussion(pagesToLoad, lfReceivedUnread, lfReceivedRead, lfSentUnread, lfSentRead)
                        .then(function(nextMessages) {
                    return result.messages.concat(nextMessages);
                });
            } else {
                $scope.canLoadMore = result.canLoadMore;
                return result.messages;
            }
        });
    }
    function setPolling() {
        if (polling) {
            return;
        }
        polling = $interval(fetchMessages, mmaMessagesPollInterval);
    }
    function unsetPolling() {
        if (polling) {
            $log.debug('Cancelling polling for conversation with user ' + userId);
            $interval.cancel(polling);
            polling = undefined;
        }
    }
    if ($ionicPlatform.isTablet()) {
        $scope.$on('$viewContentLoaded', function(){
            setPolling();
        });
        $scope.$on('$destroy', function(){
            unsetPolling();
        });
    } else {
        $scope.$on('$ionicView.enter', function() {
            setPolling();
        });
        $scope.$on('$ionicView.leave', function(e) {
            unsetPolling();
        });
    }
    function notifyNewMessage() {
        var last = $scope.messages[$scope.messages.length - 1],
            trigger = false;
        if ((last && (last.text !== lastMessage.message || last.timecreated !== lastMessage.timecreated))) {
            lastMessage = {message: last.text, timecreated: last.timecreated};
            trigger = true;
        } else if (!last) {
            lastMessage = {message: "", timecreated: 0};
            trigger = true;
        }
        if (trigger) {
            $mmEvents.trigger(mmaMessagesNewMessageEvent, {
                siteid: $mmSite.getId(),
                userid: userId,
                message: lastMessage.message,
                timecreated: lastMessage.timecreated
            });
            var newCanDelete = (last && last.id && $scope.messages.length == 1) || $scope.messages.length > 1;
            if (canDelete && ($scope.data.canDelete != newCanDelete)) {
                triggerDiscussionLoadedEvent();
            }
        }
    }
    function setScrollWithKeyboard() {
        scrollKeyboardInitialized = true;
        $timeout(function() {
            var obsShow,
                obsHide,
                keyboardHeight,
                maxInitialScroll = scrollView.getScrollView().__contentHeight - scrollView.getScrollView().__clientHeight,
                initialHeight = $window.innerHeight;
            obsShow = $mmEvents.on(mmCoreEventKeyboardShow, function(e) {
                $timeout(function() {
                    var heightDifference = initialHeight - $window.innerHeight,
                        newKeyboardHeight = heightDifference > 50 ? heightDifference : e.keyboardHeight;
                    if (newKeyboardHeight) {
                        keyboardHeight = newKeyboardHeight;
                        scrollView.scrollBy(0, newKeyboardHeight);
                    }
                });
            });
            obsHide = $mmEvents.on(mmCoreEventKeyboardHide, function(e) {
                if (!scrollView || !scrollView.getScrollPosition()) {
                    return;
                }
                if (scrollView.getScrollPosition().top >= maxInitialScroll) {
                    scrollView.scrollBy(0, scrollView.getScrollPosition().top - keyboardHeight - maxInitialScroll);
                } else {
                    scrollView.scrollBy(0, - keyboardHeight);
                }
            });
            $scope.$on('$destroy', function() {
                obsShow && obsShow.off && obsShow.off();
                obsHide && obsHide.off && obsHide.off();
            });
        });
    }
    $scope.loadPrevious = function() {
        if ($scope.loadingPrevious) {
            return;
        }
        $scope.loadingPrevious = true;
        waitForFetch().finally(function() {
            var oldHeight = scrollView.getScrollView().__contentHeight;
            pagesLoaded++;
            fetchMessages().then(function() {
                scrollView.resize();
                $timeout(function() {
                    var newHeight = scrollView.getScrollView().__contentHeight;
                    scrollView.scrollBy(0, newHeight - oldHeight);
                });
            }).catch(function(error) {
                pagesLoaded--;
                $mmUtil.showErrorModalDefault(error, 'mma.messages.errorwhileretrievingmessages', true);
            }).finally(function() {
                $scope.loadingPrevious = false;
            });
        });
    };
    $scope.deleteMessage = function(message, index) {
        var langKey = message.pending ? 'mm.core.areyousure' : 'mma.messages.deletemessageconfirmation';
        $mmUtil.showConfirm($translate(langKey)).then(function() {
            var modal = $mmUtil.showModalLoading('mm.core.deleting', true);
            $mmaMessages.deleteMessage(message).then(function() {
                $scope.messages.splice(index, 1);
                fetchMessages();
            }).catch(function(error) {
                $mmUtil.showErrorModalDefault(error, 'mma.messages.errordeletemessage', true);
            }).finally(function() {
                modal.dismiss();
            });
        });
    };
    syncObserver = $mmEvents.on(mmaMessagesAutomSyncedEvent, function(data) {
        if (data && data.siteid == $mmSite.getId() && data.userid == userId) {
            fetchMessages();
            if (data.warnings && data.warnings[0]) {
                $mmUtil.showErrorModal(data.warnings[0]);
            }
        }
    });
    $scope.$on('$destroy', function() {
        if ($ionicPlatform.isTablet()) {
            $mmEvents.trigger(mmaMessagesDiscussionLeftEvent);
        }
        if (syncObserver && syncObserver.off) {
            syncObserver.off();
        }
    });
}]);

angular.module('mm.addons.messages')
.controller('mmaMessagesDiscussionsCtrl', ["$scope", "$mmUtil", "$mmaMessages", "$rootScope", "$mmEvents", "$mmSite", "$ionicPlatform", "mmCoreSplitViewLoad", "mmaMessagesNewMessageEvent", "$mmAddonManager", "mmaMessagesReadChangedEvent", "mmaMessagesReadCronEvent", function($scope, $mmUtil, $mmaMessages, $rootScope, $mmEvents, $mmSite, $ionicPlatform,
            mmCoreSplitViewLoad, mmaMessagesNewMessageEvent, $mmAddonManager, mmaMessagesReadChangedEvent,
            mmaMessagesReadCronEvent) {
    var newMessagesObserver, readChangedObserver, cronObserver,
        siteId = $mmSite.getId(),
        discussions,
        $mmPushNotificationsDelegate = $mmAddonManager.get('$mmPushNotificationsDelegate'),
        unregisterResume;
    $scope.loaded = false;
    function fetchDiscussions() {
        return $mmaMessages.getDiscussions().then(function(discs) {
            discussions = discs;
            var discussionsSorted = [];
            angular.forEach(discussions, function(discussion) {
                discussion.unread = !!discussion.unread;
                discussionsSorted.push(discussion);
            });
            $scope.discussions = discussionsSorted;
        }, function(error) {
            $mmUtil.showErrorModalDefault(error, 'mma.messages.errorwhileretrievingdiscussions', true);
        }).finally(function() {
            $scope.loaded = true;
        });
    }
    function refreshData() {
        return $mmaMessages.invalidateDiscussionsCache().then(function() {
            return fetchDiscussions();
        });
    }
    $scope.refresh = function() {
        refreshData().finally(function() {
            $mmEvents.trigger(mmaMessagesReadChangedEvent, {siteid: siteId});
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
    fetchDiscussions().finally(function() {
        $rootScope.$broadcast(mmCoreSplitViewLoad);
    });
    newMessagesObserver = $mmEvents.on(mmaMessagesNewMessageEvent, function(data) {
        var discussion;
        if (data && data.siteid == siteId && data.userid) {
            discussion = discussions[data.userid];
            if (typeof discussion == 'undefined') {
                $scope.loaded = false;
                refreshData().finally(function() {
                    $scope.loaded = true;
                });
            } else {
                discussion.message.message = data.message;
                discussion.message.timecreated = data.timecreated;
            }
        }
    });
    readChangedObserver = $mmEvents.on(mmaMessagesReadChangedEvent, function(data) {
        if (data && data.siteid == siteId && data.userid) {
            var discussion = discussions[data.userid];
            if (typeof discussion != 'undefined') {
                discussion.unread = false;
                $mmaMessages.invalidateDiscussionsCache();
            }
        }
    });
    cronObserver = $mmEvents.on(mmaMessagesReadCronEvent, function(data) {
        if (data && (data.siteid == siteId || !data.siteid)) {
            refreshData();
        }
    });
    if ($mmPushNotificationsDelegate) {
        $mmPushNotificationsDelegate.registerReceiveHandler('mmaMessages:discussions', function(notification) {
            if ($mmUtil.isFalseOrZero(notification.notif)) {
                if (notification.site == siteId) {
                    refreshData();
                }
            }
        });
    }
    unregisterResume = $ionicPlatform.on('resume', function() {
        $scope.loaded = false;
        refreshData();
    });
    $scope.$on('$destroy', function() {
        newMessagesObserver && newMessagesObserver.off && newMessagesObserver.off();
        readChangedObserver && readChangedObserver.off && readChangedObserver.off();
        cronObserver && cronObserver.off && cronObserver.off();
        if ($mmPushNotificationsDelegate) {
            $mmPushNotificationsDelegate.unregisterReceiveHandler('mmaMessages:discussions');
        }
        if (unregisterResume) {
            unregisterResume();
        }
    });
}]);

angular.module('mm.addons.messages')
.controller('mmaMessagesPreferencesCtrl', ["$scope", "$mmaMessages", "$mmUtil", "$ionicPlatform", "$mmUser", "$timeout", function($scope, $mmaMessages, $mmUtil, $ionicPlatform, $mmUser, $timeout) {
    var updateTimeout;
    $scope.isTablet = $ionicPlatform.isTablet();
    function fetchPreferences() {
        return $mmaMessages.getMessagePreferences().then(function(preferences) {
            preferences.blocknoncontacts = !!preferences.blocknoncontacts;
            $scope.preferences = preferences;
        }).catch(function(message) {
            $mmUtil.showErrorModal(message);
        }).finally(function() {
            $scope.preferencesLoaded = true;
        });
    }
    function updatePreferencesAfterDelay() {
        $timeout.cancel(updateTimeout);
        updateTimeout = $timeout(function() {
            updateTimeout = null;
            updatePreferences();
        }, 5000);
    }
    function updatePreferences() {
        $mmaMessages.invalidateMessagePreferences().finally(function() {
            $mmaMessages.getMessagePreferences();
        });
    }
    fetchPreferences();
    $scope.refreshPreferences = function() {
        $mmaMessages.invalidateMessagePreferences().finally(function() {
            fetchPreferences().finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };
    $scope.changePreference = function(notification, state, processor) {
        var processorState = processor[state],
            preferenceName = notification.preferencekey + '_' + processorState.name,
            value;
        angular.forEach(notification.processors, function(processor) {
            if (processor[state].checked) {
                if (!value) {
                    value = processor.name;
                } else {
                    value += ',' + processor.name;
                }
            }
        });
        if (!value) {
            value = 'none';
        }
        if (!notification.updating) {
            notification.updating = {};
        }
        notification.updating[state] = true;
        $mmUser.updateUserPreference(preferenceName, value).then(function() {
            updatePreferencesAfterDelay();
        }).catch(function(message) {
            $mmUtil.showErrorModal(message);
            processorState.checked = !processorState.checked;
        }).finally(function() {
            notification.updating[state] = false;
        });
    };
    $scope.blockNonContacts = function(block) {
        var modal = $mmUtil.showModalLoading('mm.core.sending', true);
        $mmUser.updateUserPreference('message_blocknoncontacts', block ? 1 : 0).then(function() {
            updatePreferencesAfterDelay();
        }).catch(function(message) {
            $mmUtil.showErrorModal(message);
            $scope.preferences.blocknoncontacts = !$scope.preferences.blocknoncontacts;
        }).finally(function() {
            modal.dismiss();
        });
    };
    $scope.$on('$destroy', function() {
        if (updateTimeout) {
            $timeout.cancel(updateTimeout);
            updatePreferences();
        }
    });
}]);

angular.module('mm.addons.messages')
.filter('mmaMessagesFormat', ["$mmText", function($mmText) {
  return function(text) {
    text = text.replace(/-{4,}/ig, '');
    text = text.replace(/<br \/><br \/>/ig, "<br>");
    text = $mmText.replaceNewLines(text, '<br>');
    return text;
  };
}]);

angular.module('mm.addons.messages')
.factory('$mmaMessagesHandlers', ["$log", "$mmaMessages", "$mmSite", "$state", "$mmUtil", "$mmContentLinksHelper", "$mmaMessagesSync", "$mmSitesManager", "mmUserProfileHandlersTypeCommunication", "mmUserProfileHandlersTypeAction", "$translate", "mmaMessagesReadChangedEvent", "$mmEvents", "mmaMessagesReadCronEvent", "$mmAddonManager", "$mmContentLinkHandlerFactory", function($log, $mmaMessages, $mmSite, $state, $mmUtil, $mmContentLinksHelper, $mmaMessagesSync,
            $mmSitesManager, mmUserProfileHandlersTypeCommunication, mmUserProfileHandlersTypeAction, $translate,
            mmaMessagesReadChangedEvent, $mmEvents, mmaMessagesReadCronEvent, $mmAddonManager, $mmContentLinkHandlerFactory) {
    $log = $log.getInstance('$mmaMessagesHandlers');
    var self = {};
        self.addContact = function() {
        var self = {
            type: mmUserProfileHandlersTypeAction
        };
        self.isEnabled = function() {
            return $mmaMessages.isPluginEnabled();
        };
                self.isEnabledForUser = function(user, courseId, navOptions, admOptions) {
            return user.id != $mmSite.getUserId();
        };
                self.getController = function(user, courseid) {
            return function($scope, $rootScope) {
                var disabled = false;
                function updateTitle() {
                    return $mmaMessages.isContact(user.id).then(function(isContact) {
                        if (isContact) {
                            $scope.title = 'mma.messages.removecontact';
                            $scope.class = 'mma-messages-removecontact-handler';
                            $scope.icon = 'ion-minus-round';
                        } else {
                            $scope.title = 'mma.messages.addcontact';
                            $scope.class = 'mma-messages-addcontact-handler';
                            $scope.icon = 'ion-plus-round';
                        }
                    }).catch(function() {
                        $scope.hidden = true;
                    });
                }
                $scope.title = '';
                $scope.spinner = false;
                $scope.action = function($event) {
                    if (disabled) {
                        return;
                    }
                    disabled = true;
                    $scope.spinner = true;
                    $mmaMessages.isContact(user.id).then(function(isContact) {
                        if (isContact) {
                            var template = $translate.instant('mma.messages.removecontactconfirm'),
                                title = $translate.instant('mma.messages.removecontact');
                            return $mmUtil.showConfirm(template, title, {okText: title}).then(function() {
                                return $mmaMessages.removeContact(user.id);
                            }).catch(function() {
                            });
                        } else {
                            return $mmaMessages.addContact(user.id);
                        }
                    }).catch(function(error) {
                        $mmUtil.showErrorModal(error);
                    }).finally(function() {
                        $rootScope.$broadcast('mmaMessagesHandlers:addUpdated');
                        updateTitle().finally(function() {
                            disabled = false;
                            $scope.spinner = false;
                        });
                    });
                };
                $scope.$on('mmaMessagesHandlers:blockUpdated', function() {
                    updateTitle();
                });
                updateTitle();
            };
        };
        return self;
    };
        self.blockContact = function() {
        var self = {
            type: mmUserProfileHandlersTypeAction
        };
        self.isEnabled = function() {
            return $mmaMessages.isPluginEnabled();
        };
                self.isEnabledForUser = function(user, courseId, navOptions, admOptions) {
            return user.id != $mmSite.getUserId();
        };
        self.getController = function(user, courseid) {
                        return function($scope, $rootScope) {
                var disabled = false;
                function updateTitle() {
                    return $mmaMessages.isBlocked(user.id).then(function(isBlocked) {
                        if (isBlocked) {
                            $scope.title = 'mma.messages.unblockcontact';
                            $scope.class = 'mma-messages-unblockcontact-handler';
                            $scope.icon = 'ion-checkmark-circled';
                        } else {
                            $scope.title = 'mma.messages.blockcontact';
                            $scope.class = 'mma-messages-blockcontact-handler';
                            $scope.icon = 'ion-close-circled';
                        }
                    }).catch(function() {
                        $scope.hidden = true;
                    });
                }
                $scope.title = '';
                $scope.spinner = false;
                $scope.action = function($event) {
                    if (disabled) {
                        return;
                    }
                    disabled = true;
                    $scope.spinner = true;
                    $mmaMessages.isBlocked(user.id).then(function(isBlocked) {
                        if (isBlocked) {
                            return $mmaMessages.unblockContact(user.id);
                        } else {
                            var template = $translate.instant('mma.messages.blockcontactconfirm'),
                                title = $translate.instant('mma.messages.blockcontact');
                            return $mmUtil.showConfirm(template, title, {okText: title}).then(function() {
                                return $mmaMessages.blockContact(user.id);
                            }).catch(function() {
                            });
                        }
                    }).catch(function(error) {
                        $mmUtil.showErrorModal(error);
                    }).finally(function() {
                        $rootScope.$broadcast('mmaMessagesHandlers:blockUpdated');
                        updateTitle().finally(function() {
                            disabled = false;
                            $scope.spinner = false;
                        });
                    });
                };
                $scope.$on('mmaMessagesHandlers:addUpdated', function() {
                    updateTitle();
                });
                updateTitle();
            };
        };
        return self;
    };
        self.sendMessage = function() {
        var self = {
            type: mmUserProfileHandlersTypeCommunication
        };
        self.isEnabled = function() {
            return $mmaMessages.isPluginEnabled();
        };
                self.isEnabledForUser = function(user, courseId, navOptions, admOptions) {
            return user.id != $mmSite.getUserId();
        };
        self.getController = function(user, courseid) {
                        return function($scope) {
                $scope.title = 'mma.messages.message';
                $scope.class = 'mma-messages-sendmessage-handler';
                $scope.icon = 'ion-chatbubble';
                $scope.action = function($event) {
                    $event.preventDefault();
                    $event.stopPropagation();
                    $state.go('site.messages-discussion', {
                        userId: user.id,
                        showKeyboard: true
                    });
                };
            };
        };
        return self;
    };
        self.sideMenuNav = function() {
        var self = {};
                self.isEnabled = function() {
            return $mmaMessages.isPluginEnabled();
        };
                self.getController = function() {
                        return function($scope) {
                var $mmPushNotificationsDelegate = $mmAddonManager.get('$mmPushNotificationsDelegate'),
                    $mmaPushNotifications = $mmAddonManager.get('$mmaPushNotifications'),
                    readChangedObserver, cronObserver;
                $scope.icon = 'ion-chatbox';
                $scope.title = 'mma.messages.messages';
                $scope.state = 'site.messages';
                $scope.class = 'mma-messages-handler';
                if ($mmaMessages.isMessageCountEnabled(true)) {
                    $scope.loading = true;
                    updateUnreadConversationsCount().finally(function() {
                        $scope.loading = false;
                    });
                    readChangedObserver = $mmEvents.on(mmaMessagesReadChangedEvent, function(data) {
                        if (data && $mmSitesManager.isCurrentSite(data.siteid)) {
                            updateUnreadConversationsCount(data.siteid);
                        }
                    });
                    cronObserver = $mmEvents.on(mmaMessagesReadCronEvent, function(data) {
                        if (data && $mmSitesManager.isCurrentSite(data.siteid)) {
                            updateUnreadConversationsCount(data.siteid);
                        }
                    });
                    if ($mmPushNotificationsDelegate) {
                        $mmPushNotificationsDelegate.registerReceiveHandler('mmaMessages:sidemenu', function(notification) {
                            if ($mmUtil.isFalseOrZero(notification.notif) && $mmSitesManager.isCurrentSite(notification.site)) {
                                updateUnreadConversationsCount(notification.site);
                            }
                        });
                        $mmPushNotificationsDelegate.registerCounterHandler('mmaMessages');
                    }
                    function updateUnreadConversationsCount(siteId) {
                        return $mmaMessages.getUnreadConversationsCount().then(function(unread) {
                            $scope.badge = parseInt(unread, 10) > 0 ? unread : '';
                            if ($mmaPushNotifications) {
                                $mmaPushNotifications.updateAddonCounter(siteId, 'mmaMessages', unread);
                            }
                        });
                    }
                }
                $scope.$on('$destroy', function() {
                    readChangedObserver && readChangedObserver.off && readChangedObserver.off();
                    cronObserver && cronObserver.off && cronObserver.off();
                    if ($mmPushNotificationsDelegate) {
                        $mmPushNotificationsDelegate.unregisterReceiveHandler('mmaMessages:sidemenu');
                    }
                });
            };
        };
                self.execute = function(siteId) {
            if ($mmSitesManager.isCurrentSite(siteId) && $mmaMessages.isMessageCountEnabled(true)) {
                $mmEvents.trigger(mmaMessagesReadCronEvent, {
                    siteid: siteId
                });
            }
        };
                self.getInterval = function() {
            return 600000;
        };
                self.isSync = function() {
            return !$mmaMessages.isMessageCountEnabled();
        };
                self.canManualSync = function() {
            return true;
        };
                self.usesNetwork = function() {
            return true;
        };
        return self;
    };
        self.indexLinksHandler = $mmContentLinkHandlerFactory.createChild(
            /\/message\/index\.php((?![\?\&](id|user1|user2)=\d+).)*$/, '$mmSideMenuDelegate_mmaMessages');
    self.indexLinksHandler.isEnabled = $mmaMessages.isPluginEnabled;
    self.indexLinksHandler.getActions = function(siteIds, url, params, courseId) {
        return [{
            action: function(siteId) {
                $state.go('redirect', {
                    siteid: siteId,
                    state: 'site.messages',
                    params: {}
                });
            }
        }];
    };
        self.discussionLinksHandler = $mmContentLinkHandlerFactory.createChild(
            /\/message\/index\.php.*([\?\&](id|user1|user2)=\d+)/, '$mmUserDelegate_mmaMessages:sendMessage');
    self.discussionLinksHandler.isEnabled = function(siteId, url, params, courseId) {
        return $mmaMessages.isPluginEnabled(siteId).then(function(enabled) {
            if (!enabled) {
                return false;
            }
            if (typeof params.id == 'undefined' && typeof params.user2 == 'undefined') {
                return false;
            }
            if (typeof params.user1 != 'undefined') {
                return $mmSitesManager.getSite(siteId).then(function(site) {
                    return parseInt(params.user1, 10) == site.getUserId();
                });
            }
            return true;
        });
    };
    self.discussionLinksHandler.getActions = function(siteIds, url, params, courseId) {
        return [{
            action: function(siteId) {
                var stateParams = {
                    userId: parseInt(params.id || params.user2, 10)
                };
                $mmContentLinksHelper.goInSite('site.messages-discussion', stateParams, siteId);
            }
        }];
    };
        self.syncHandler = function() {
        var self = {};
                self.execute = function(siteId) {
            return $mmaMessagesSync.syncAllDiscussions(siteId);
        };
                self.getInterval = function() {
            return 300000;
        };
                self.isSync = function() {
            return true;
        };
                self.usesNetwork = function() {
            return true;
        };
        return self;
    };
        self.preferences = function() {
        var self = {};
                self.isEnabled = function() {
            return $mmaMessages.isMessagePreferencesEnabled();
        };
                self.getController = function() {
            return function($scope) {
                $scope.title = 'mma.messages.messagepreferences';
                $scope.class = 'mma-messages-messagepreferences-handler';
                $scope.state = 'site.messages-preferences';
            };
        };
        return self;
    };
    return self;
}]);

angular.module('mm.addons.messages')
.factory('$mmaMessages', ["$mmSite", "$mmSitesManager", "$log", "$q", "$mmUser", "$mmaMessagesOffline", "$mmApp", "$mmUtil", "mmaMessagesNewMessageEvent", "mmaMessagesLimitMessages", function($mmSite, $mmSitesManager, $log, $q, $mmUser, $mmaMessagesOffline, $mmApp, $mmUtil,
            mmaMessagesNewMessageEvent, mmaMessagesLimitMessages) {
    $log = $log.getInstance('$mmaMessages');
    var self = {};
        self.addContact = function(userId) {
        return $mmSite.write('core_message_create_contacts', {
            userids: [ userId ]
        }).then(function() {
            return self.invalidateAllContactsCache($mmSite.getUserId());
        });
    };
        self.blockContact = function(userId) {
        return $mmSite.write('core_message_block_contacts', {
            userids: [ userId ]
        }).then(function() {
            return self.invalidateAllContactsCache($mmSite.getUserId());
        });
    };
        self.canDeleteMessages = function() {
        return $mmSite.wsAvailable('core_message_delete_message');
    };
        self.deleteMessage = function(message) {
        if (message.id) {
            return self.deleteMessageOnline(message.id, message.read);
        } else {
            return $mmaMessagesOffline.deleteMessage(message.touserid, message.smallmessage, message.timecreated);
        }
    };
        self.deleteMessageOnline = function(id, read, userId) {
        userId = userId || $mmSite.getUserId();
        var params = {
                messageid: id,
                userid: userId,
                read: read
            };
        return $mmSite.write('core_message_delete_message', params).then(function() {
            return self.invalidateDiscussionCache(userId);
        });
    };
        self.getAllContacts = function() {
        return self.getContacts().then(function(contacts) {
            return self.getBlockedContacts().then(function(blocked) {
                contacts.blocked = blocked.users;
                storeUsersFromAllContacts(contacts);
                return contacts;
            }, function() {
                contacts.blocked = [];
                storeUsersFromAllContacts(contacts);
                return contacts;
            });
        });
    };
        self.getBlockedContacts = function() {
        var params = {
                userid: $mmSite.getUserId()
            },
            presets = {
                cacheKey: self._getCacheKeyForBlockedContacts($mmSite.getUserId())
            };
        if (!$mmSite.wsAvailable('core_message_get_blocked_users')) {
            return $q.when({users: [], warnings: []});
        }
        return $mmSite.read('core_message_get_blocked_users', params, presets);
    };
        self._getCacheKeyForContacts = function() {
        return 'mmaMessages:contacts';
    };
        self._getCacheKeyForBlockedContacts = function(userId) {
        return 'mmaMessages:blockedContacts:' + userId;
    };
        self._getCacheKeyForDiscussion = function(userId) {
        return 'mmaMessages:discussion:' + userId;
    };
        self._getCacheKeyForDiscussions = function() {
        return 'mmaMessages:discussions';
    };
        self._getCacheKeyForEnabled = function() {
        return 'mmaMessages:enabled';
    };
        self.getContacts = function() {
        var presets = {
                cacheKey: self._getCacheKeyForContacts()
            };
        return $mmSite.read('core_message_get_contacts', undefined, presets).then(function(contacts) {
            var validContacts = {};
            angular.forEach(contacts, function(typeContacts, typeName) {
                if (!validContacts[typeName]) {
                    validContacts[typeName] = [];
                }
                angular.forEach(typeContacts, function(contact) {
                    if (contact.id > 0) {
                        validContacts[typeName].push(contact);
                    }
                });
            });
            return validContacts;
        });
    };
        self.getDiscussionEventName = function(userid) {
        return mmaMessagesNewMessageEvent + '_' + $mmSite.getUserId() + '_' + userid;
    };
        self.getDiscussion = function(userId, excludePending, lfReceivedUnread, lfReceivedRead, lfSentUnread, lfSentRead) {
        lfReceivedUnread = lfReceivedUnread || 0;
        lfReceivedRead = lfReceivedRead || 0;
        lfSentUnread = lfSentUnread || 0;
        lfSentRead = lfSentRead || 0;
        var result = {},
            presets = {
                cacheKey: self._getCacheKeyForDiscussion(userId)
            },
            params = {
                useridto: $mmSite.getUserId(),
                useridfrom: userId,
                limitnum: mmaMessagesLimitMessages
            },
            hasReceived,
            hasSent;
        if (lfReceivedUnread > 0 || lfReceivedRead > 0 || lfSentUnread > 0 || lfSentRead > 0) {
            presets.getFromCache = 0;
            presets.saveToCache = 0;
            presets.emergencyCache = 0;
        }
        return self._getRecentMessages(params, presets, lfReceivedUnread, lfReceivedRead).then(function(response) {
            result.messages = response;
            params.useridto = userId;
            params.useridfrom = $mmSite.getUserId();
            hasReceived = response.length > 0;
            return self._getRecentMessages(params, presets, lfSentUnread, lfSentRead);
        }).then(function(response) {
            result.messages = result.messages.concat(response);
            hasSent = response.length > 0;
            if (result.messages.length > mmaMessagesLimitMessages) {
                result.canLoadMore = true;
                result.messages = self.sortMessages(result.messages);
                result.messages = result.messages.slice(-mmaMessagesLimitMessages);
            } else {
                result.canLoadMore = result.messages.length == mmaMessagesLimitMessages && (!hasReceived || !hasSent);
            }
            if (excludePending) {
                return result;
            }
            return $mmaMessagesOffline.getMessages(userId).then(function(offlineMessages) {
                angular.forEach(offlineMessages, function(message) {
                    message.pending = true;
                    message.text = message.smallmessage;
                });
                result.messages = result.messages.concat(offlineMessages);
                return result;
            });
        });
    };
        self.getDiscussions = function() {
        var discussions = {},
            currentUserId = $mmSite.getUserId(),
            params = {
                useridto: currentUserId,
                useridfrom: 0,
                limitnum: mmaMessagesLimitMessages
            },
            presets = {
                cacheKey: self._getCacheKeyForDiscussions()
            };
        return self._getRecentMessages(params, presets).then(function(messages) {
            angular.forEach(messages, function(message) {
                treatRecentMessage(message, message.useridfrom, message.userfromfullname);
            });
            params.useridfrom = params.useridto;
            params.useridto = 0;
            return self._getRecentMessages(params, presets);
        }).then(function(messages) {
            angular.forEach(messages, function(message) {
                treatRecentMessage(message, message.useridto, message.usertofullname);
            });
            return $mmaMessagesOffline.getAllMessages();
        }).then(function(offlineMessages) {
            angular.forEach(offlineMessages, function(message) {
                message.pending = true;
                message.text = message.smallmessage;
                treatRecentMessage(message, message.touserid, '');
            });
            return self.getDiscussionsUserImg(discussions).then(function(discussions) {
                storeUsersFromDiscussions(discussions);
                return discussions;
            });
        });
        function treatRecentMessage(message, userId, userFullname) {
            if (typeof discussions[userId] === 'undefined') {
                discussions[userId] = {
                    fullname: userFullname,
                    profileimageurl: ''
                };
                if (!message.timeread && !message.pending && message.useridfrom != currentUserId) {
                    discussions[userId].unread = true;
                }
            }
            var discMessage = discussions[userId].message;
            if (typeof discMessage === 'undefined' || (!discMessage.pending && message.pending) ||
                    (discMessage.pending == message.pending && (discMessage.timecreated < message.timecreated ||
                    (discMessage.timecreated == message.timecreated && discMessage.id < message.id)))) {
                discussions[userId].message = {
                    id: message.id,
                    user: userId,
                    message: message.text,
                    timecreated: message.timecreated,
                    pending: message.pending
                };
            }
        }
    };
        self.markMessageRead = function(messageId) {
        var params = {
                'messageid': messageId,
                'timeread': $mmUtil.timestamp()
            };
        return $mmSite.write('core_message_mark_message_read', params);
    };
        self.getDiscussionsUserImg = function(discussions) {
        var promises = [];
        angular.forEach(discussions, function(discussion) {
            if (!discussion.profileimageurl) {
                var promise = $mmUser.getProfile(discussion.message.user, 1, true).then(function(user) {
                    discussion.profileimageurl = user.profileimageurl;
                }, function() {
                });
                promises.push(promise);
            }
        });
        return $q.all(promises).then(function() {
            return discussions;
        });
    };
        self._getMessages = function(params, presets) {
        params = angular.extend(params, {
            type: 'conversations',
            newestfirst: 1,
        });
        return $mmSite.read('core_message_get_messages', params, presets).then(function(response) {
            angular.forEach(response.messages, function(message) {
                message.read = params.read == 0 ? 0 : 1;
                message.timecreated = message.timecreated ? message.timecreated * 1000 : 0;
                message.timeread = message.timeread ? message.timeread * 1000 : 0;
            });
            return response;
        });
    };
        self._getRecentMessages = function(params, preSets, limitFromUnread, limitFromRead) {
        limitFromUnread = limitFromUnread || 0;
        limitFromRead = limitFromRead || 0;
        params = angular.extend(params, {
            read: 0,
            limitfrom: limitFromUnread
        });
        return self._getMessages(params, preSets).then(function(response) {
            var messages = response.messages;
            if (messages) {
                if (messages.length >= params.limitnum) {
                    return messages;
                }
                params.limitnum = params.limitnum - messages.length;
                params.read = 1;
                params.limitfrom = limitFromRead;
                return self._getMessages(params, preSets).then(function(response) {
                    if (response.messages) {
                        messages = messages.concat(response.messages);
                    }
                    return messages;
                }, function() {
                    return messages;
                });
            } else {
                return $q.reject();
            }
        });
    };
        function getMessagePreferencesCacheKey() {
        return 'mmaMessages:messagePreferences';
    }
        self.getMessagePreferences = function(siteId) {
        $log.debug('Get message preferences');
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var preSets = {
                    cacheKey: getMessagePreferencesCacheKey()
                };
            return site.read('core_message_get_user_message_preferences', {}, preSets).then(function(data) {
                if (data.preferences) {
                    data.preferences.blocknoncontacts = data.blocknoncontacts;
                    return data.preferences;
                }
                return $q.reject();
            });
        });
    };
        self.getUnreadConversationsCount = function(userId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            if (site.wsAvailable('core_message_get_unread_conversations_count')) {
                var params = {
                        useridto: userId
                    },
                    preSets = {
                        getFromCache: 0,
                        emergencyCache: 0,
                        saveToCache: 0,
                        typeExpected: 'number'
                    };
                return site.read('core_message_get_unread_conversations_count', params, preSets).catch(function() {
                    return 0;
                });
            }
            var params = {
                read: 0,
                limitfrom: 0,
                limitnum: mmaMessagesLimitMessages + 1,
                useridto: userId,
                useridfrom: 0,
            };
            return self._getMessages(params).then(function(response) {
                var discussions = {},
                    count;
                angular.forEach(response.messages, function(message) {
                    discussions[message.useridto] = 1;
                });
                count = Object.keys(discussions).length;
                return (count > mmaMessagesLimitMessages) ? count + "+" : count;
            }).catch(function() {
                return 0;
            });
        });
    };
        self.invalidateAllContactsCache = function(userId, siteId) {
        return self.invalidateContactsCache(siteId).then(function() {
            return self.invalidateBlockedContactsCache(userId, siteId);
        });
    };
        self.invalidateBlockedContactsCache = function(userId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(self._getCacheKeyForBlockedContacts(userId));
        });
    };
        self.invalidateContactsCache = function(siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(self._getCacheKeyForContacts());
        });
    };
        self.invalidateDiscussionCache = function(userId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(self._getCacheKeyForDiscussion(userId));
        });
    };
        self.invalidateDiscussionsCache = function(siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(self._getCacheKeyForDiscussions()).then(function(){
                return self.invalidateContactsCache(siteId);
            });
        });
    };
        self.invalidateEnabledCache = function(siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(self._getCacheKeyForEnabled());
        });
    };
        self.invalidateMessagePreferences = function(siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getMessagePreferencesCacheKey());
        });
    };
        self.isBlocked = function(userId) {
        return self.getBlockedContacts().then(function(blockedContacts) {
            var blocked = false;
            if (!blockedContacts.users || blockedContacts.users.length < 1) {
                return blocked;
            }
            angular.forEach(blockedContacts.users, function(user) {
                if (userId == user.id) {
                    blocked = true;
                }
            });
            return blocked;
        });
    };
        self.isContact = function(userId) {
        return self.getContacts().then(function(contacts) {
            var isContact = false,
                types = ['online', 'offline'];
            angular.forEach(types, function(type) {
                if (contacts[type] && contacts[type].length > 0) {
                    angular.forEach(contacts[type], function(user) {
                        if (userId == user.id) {
                            isContact = true;
                        }
                    });
                }
            });
            return isContact;
        });
    };
        self.isMessageCountEnabled = function(useFallback) {
        return $mmSite.wsAvailable('core_message_get_unread_conversations_count') ||
            (useFallback && $mmSite.wsAvailable('core_message_get_messages'));
    };
        self._isMessagingEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var enabled = site.canUseAdvancedFeature('messaging', 'unknown');
            if (enabled === 'unknown') {
                $log.debug('Using WS call to check if messaging is enabled.');
                return site.read('core_message_search_contacts', {
                    searchtext: 'CheckingIfMessagingIsEnabled',
                    onlymycourses: 0
                }, {
                    emergencyCache: false,
                    cacheKey: self._getCacheKeyForEnabled()
                });
            }
            if (enabled) {
                return true;
            }
            return $q.reject();
        });
    };
       self.isMessagingEnabledForSite = function(siteid) {
        return $mmSitesManager.getSite(siteid).then(function(site) {
            if (!site.canUseAdvancedFeature('messaging') || !site.wsAvailable('core_message_get_messages')) {
                return $q.reject();
            }
            $log.debug('Using WS call to check if messaging is enabled.');
            return site.read('core_message_search_contacts', {
                searchtext: 'CheckingIfMessagingIsEnabled',
                onlymycourses: 0
            }, {
                emergencyCache: false,
                cacheKey: self._getCacheKeyForEnabled()
            });
        });
    };
        self.isMessagePreferencesEnabled = function() {
        return $mmSite.wsAvailable('core_message_get_user_message_preferences');
    };
        self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            if (!site.canUseAdvancedFeature('messaging')) {
                return false;
            } else if (!site.wsAvailable('core_message_get_messages')) {
                return false;
            } else {
                return self._isMessagingEnabled(siteId).then(function() {
                    return true;
                });
            }
        });
    };
        self.isSearchEnabled = function() {
        return $mmSite.wsAvailable('core_message_search_contacts');
    };
        self.removeContact = function(userId) {
        return $mmSite.write('core_message_delete_contacts', {
            userids: [ userId ]
        }, {
            responseExpected: false
        }).then(function() {
            return self.invalidateContactsCache();
        });
    };
        self.searchContacts = function(query, limit) {
        var data = {
                searchtext: query,
                onlymycourses: 0
            },
            preSets = {
                getFromCache: 0
            };
        limit = typeof limit === 'undefined' ? 100 : limit;
        return $mmSite.read('core_message_search_contacts', data, preSets).then(function(contacts) {
            if (limit && contacts.length > limit) {
                contacts = contacts.splice(0, limit);
            }
            $mmUser.storeUsers(contacts);
            return contacts;
        });
    };
        self.sendMessage = function(to, message, siteId) {
        siteId = siteId || $mmSite.getId();
        if (!$mmApp.isOnline()) {
            return storeOffline();
        }
        return $mmaMessagesOffline.hasMessages(to, siteId).catch(function() {
            return true;
        }).then(function(hasStoredMessages) {
            if (hasStoredMessages) {
                return storeOffline();
            }
            return self.sendMessageOnline(to, message).then(function() {
                return {sent: true};
            }).catch(function(data) {
                if (data.wserror) {
                    return $q.reject(data.error);
                } else {
                    return storeOffline();
                }
            });
        });
        function storeOffline() {
            return $mmaMessagesOffline.saveMessage(to, message, siteId).then(function(entry) {
                return {
                    sent: false,
                    message: entry
                };
            });
        }
    };
        self.sendMessageOnline = function(to, message, siteId) {
        var messages = [
                {
                    touserid: to,
                    text: message,
                    textformat: 1
                }
            ];
        return self.sendMessagesOnline(messages, siteId).catch(function(error) {
            return $q.reject({
                error: error,
                wserror: $mmUtil.isWebServiceError(error)
            });
        }).then(function(response) {
            if (response && response[0] && response[0].msgid === -1) {
                return $q.reject({
                    error: response[0].errormessage,
                    wserror: true
                });
            }
            return self.invalidateDiscussionCache(to, siteId).catch(function() {
            });
        });
    };
        self.sendMessagesOnline = function(messages, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var data = {
                    messages: messages
                };
            return site.write('core_message_send_instant_messages', data);
        });
    };
        self.sortMessages = function(messages) {
        return messages.sort(function (a, b) {
            var timecreatedA, timecreatedB;
            if (a.pending && !b.pending) {
                return 1;
            } else if (!a.pending && b.pending) {
                return -1;
            }
            timecreatedA = parseInt(a.timecreated, 10);
            timecreatedB = parseInt(b.timecreated, 10);
            if (timecreatedA == timecreatedB && a.id) {
                return a.id >= b.id;
            }
            return timecreatedA >= timecreatedB ? 1 : -1;
        });
    };
        function storeUsersFromAllContacts(contactTypes) {
        angular.forEach(contactTypes, function(contacts) {
            $mmUser.storeUsers(contacts);
        });
    }
        function storeUsersFromDiscussions(discussions) {
        angular.forEach(discussions, function(discussion, userid) {
            if (typeof userid != 'undefined' && !isNaN(parseInt(userid))) {
                $mmUser.storeUser(userid, discussion.fullname, discussion.profileimageurl);
            }
        });
    }
        self.unblockContact = function(userId) {
        return $mmSite.write('core_message_unblock_contacts', {
            userids: [ userId ]
        }, {
            responseExpected: false
        }).then(function() {
            return self.invalidateAllContactsCache($mmSite.getUserId());
        });
    };
    return self;
}]);

angular.module('mm.addons.messages')
.constant('mmaMessagesOfflineMessagesStore', 'mma_messages_offline_messages')
.config(["$mmSitesFactoryProvider", "mmaMessagesOfflineMessagesStore", function($mmSitesFactoryProvider, mmaMessagesOfflineMessagesStore) {
    var stores = [
        {
            name: mmaMessagesOfflineMessagesStore,
            keyPath: ['touserid', 'smallmessage', 'timecreated'],
            indexes: [
                {
                    name: 'touserid'
                },
                {
                    name: 'useridfrom'
                },
                {
                    name: 'smallmessage'
                },
                {
                    name: 'timecreated'
                },
                {
                    name: 'deviceoffline'
                }
            ]
        }
    ];
    $mmSitesFactoryProvider.registerStores(stores);
}])
.factory('$mmaMessagesOffline', ["$mmSitesManager", "$log", "$mmSite", "$mmApp", "$q", "mmaMessagesOfflineMessagesStore", function($mmSitesManager, $log, $mmSite, $mmApp, $q, mmaMessagesOfflineMessagesStore) {
    $log = $log.getInstance('$mmaMessagesOffline');
    var self = {};
        self.deleteMessage = function(to, message, timecreated, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.getDb().remove(mmaMessagesOfflineMessagesStore, [to, message, timecreated]);
        });
    };
        self.getAllDeviceOfflineMessages = function(siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.getDb().whereEqual(mmaMessagesOfflineMessagesStore, 'deviceoffline', 1);
        });
    };
        self.getAllMessages = function(siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.getDb().getAll(mmaMessagesOfflineMessagesStore);
        });
    };
        self.getMessages = function(to, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.getDb().whereEqual(mmaMessagesOfflineMessagesStore, 'touserid', to);
        });
    };
        self.getMessage = function(to, message, timecreated, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.getDb().get(mmaMessagesOfflineMessagesStore, [to, message, timecreated]);
        });
    };
        self.hasMessages = function(to, siteId) {
        return self.getMessages(to, siteId).then(function(messages) {
            return !!messages.length;
        });
    };
        self.saveMessage = function(to, message, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var db = site.getDb(),
                entry = {
                    touserid: to,
                    useridfrom: site.getUserId(),
                    smallmessage: message,
                    textformat: 1,
                    timecreated: new Date().getTime(),
                    deviceoffline: $mmApp.isOnline() ? 0 : 1
                };
            return db.insert(mmaMessagesOfflineMessagesStore, entry).then(function() {
                return entry;
            });
        });
    };
        self.setMessageDeviceOffline = function(to, message, timecreated, value, siteId) {
        siteId = siteId || $mmSite.getId();
        value = value ? 1 : 0;
        return self.getMessage(to, message, timecreated, siteId).then(function(entry) {
            entry.deviceoffline = value;
            return $mmSitesManager.getSite(siteId).then(function(site) {
                return site.getDb().insert(mmaMessagesOfflineMessagesStore, entry);
            });
        });
    };
        self.setMessagesDeviceOffline = function(messages, value, siteId) {
        siteId = siteId || $mmSite.getId();
        value = value ? 1 : 0;
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var db = site.getDb(),
                promises = [];
            angular.forEach(messages, function(message) {
                message.deviceoffline = value;
                promises.push(db.insert(mmaMessagesOfflineMessagesStore, message));
            });
            return $q.all(promises);
        });
    };
    return self;
}]);

angular.module('mm.addons.messages')
.factory('$mmaMessagesSync', ["$log", "$mmSite", "$q", "$timeout", "$mmUser", "$mmApp", "$translate", "$mmaMessages", "$mmaMessagesOffline", "$mmSitesManager", "$mmEvents", "mmaMessagesAutomSyncedEvent", "$mmSync", "mmaMessagesComponent", function($log, $mmSite, $q, $timeout, $mmUser, $mmApp, $translate, $mmaMessages, $mmaMessagesOffline,
            $mmSitesManager, $mmEvents, mmaMessagesAutomSyncedEvent, $mmSync, mmaMessagesComponent) {
    $log = $log.getInstance('$mmaMessagesSync');
    var self = $mmSync.createChild(mmaMessagesComponent);
        self.syncAllDiscussions = function(siteId, onlyDeviceOffline) {
        if (!$mmApp.isOnline()) {
            $log.debug('Cannot sync all discussions because device is offline.');
            return $q.reject();
        }
        var promise;
        if (!siteId) {
            $log.debug('Try to sync discussions in all sites.' + (onlyDeviceOffline ? ' Only offline.' : ''));
            promise = $mmSitesManager.getSitesIds();
        } else {
            $log.debug('Try to sync discussions in site ' + siteId + (onlyDeviceOffline ? '. Only offline.' : ''));
            promise = $q.when([siteId]);
        }
        return promise.then(function(siteIds) {
            var sitePromises = [];
            angular.forEach(siteIds, function(siteId) {
                var fn = onlyDeviceOffline ? $mmaMessagesOffline.getAllDeviceOfflineMessages : $mmaMessagesOffline.getAllMessages;
                sitePromises.push(fn(siteId).then(function(messages) {
                    var userIds = [],
                        promises = [];
                    angular.forEach(messages, function(message) {
                        if (userIds.indexOf(message.touserid) == -1) {
                            userIds.push(message.touserid);
                        }
                    });
                    angular.forEach(userIds, function(userId) {
                        promises.push(self.syncDiscussion(userId, siteId).then(function(warnings) {
                            if (typeof warnings != 'undefined') {
                                $mmEvents.trigger(mmaMessagesAutomSyncedEvent, {
                                    siteid: siteId,
                                    userid: userId,
                                    warnings: warnings
                                });
                            }
                        }));
                    });
                    return $q.all(promises);
                }));
            });
            return $q.all(sitePromises);
        });
    };
        self.syncDiscussion = function(userId, siteId) {
        siteId = siteId || $mmSite.getId();
        var syncPromise,
            warnings = [];
        if (self.isSyncing(userId, siteId)) {
            return self.getOngoingSync(userId, siteId);
        }
        $log.debug('Try to sync discussion with user ' + userId);
        syncPromise = $mmaMessagesOffline.getMessages(userId, siteId).then(function(messages) {
            if (!messages.length) {
                return [];
            } else if (!$mmApp.isOnline()) {
                $mmaMessagesOffline.setMessagesDeviceOffline(messages, true);
                return $q.reject();
            }
            var promise = $q.when(),
                errors = [];
            messages = $mmaMessages.sortMessages(messages);
            angular.forEach(messages, function(message, index) {
                promise = promise.then(function() {
                    return $mmaMessages.sendMessageOnline(userId, message.smallmessage, siteId).catch(function(data) {
                        if (data.wserror) {
                            if (errors.indexOf(data.error) == -1) {
                                errors.push(data.error);
                            }
                        } else {
                            if ($mmApp.isOnline()) {
                                $mmaMessagesOffline.setMessagesDeviceOffline(messages, false);
                            }
                            return $q.reject(data.error);
                        }
                    }).then(function() {
                        return $mmaMessagesOffline.deleteMessage(userId, message.smallmessage, message.timecreated, siteId);
                    }).then(function() {
                        if (index < messages.length - 1) {
                            return $timeout(function() {}, 1000);
                        }
                    });
                });
            });
            return promise.then(function() {
                return errors;
            });
        }).then(function(errors) {
            if (errors && errors.length) {
                return $mmUser.getProfile(userId, undefined, true).catch(function() {
                    return {};
                }).then(function(user) {
                    angular.forEach(errors, function(error) {
                        warnings.push($translate.instant('mma.messages.warningmessagenotsent', {
                            user: user.fullname ? user.fullname : userId,
                            error: error
                        }));
                    });
                });
            }
        }).then(function() {
            return warnings;
        });
        return self.addOngoingSync(userId, syncPromise, siteId);
    };
    return self;
}]);

angular.module('mm.addons.notifications')
.controller('mmaNotificationsListCtrl', ["$scope", "$mmUtil", "$mmaNotifications", "mmaNotificationsListLimit", "$mmAddonManager", "mmUserProfileState", "$q", "$mmEvents", "$mmSite", "mmaNotificationsReadChangedEvent", "mmaNotificationsReadCronEvent", "$state", function($scope, $mmUtil, $mmaNotifications, mmaNotificationsListLimit, $mmAddonManager,
            mmUserProfileState, $q, $mmEvents, $mmSite, mmaNotificationsReadChangedEvent, mmaNotificationsReadCronEvent, $state) {
    var readCount = 0,
        unreadCount = 0,
        siteId = $mmSite.getId(),
        $mmPushNotificationsDelegate = $mmAddonManager.get('$mmPushNotificationsDelegate'),
        cronObserver;
    $scope.notifications = [];
    $scope.userStateName = mmUserProfileState;
    function fetchNotifications(refresh) {
        if (refresh) {
            readCount = 0;
            unreadCount = 0;
        }
        return $mmaNotifications.getUnreadNotifications(unreadCount, mmaNotificationsListLimit).then(function(unread) {
            var promise;
            unreadCount += unread.length;
            if (unread.length < mmaNotificationsListLimit) {
                var readLimit = mmaNotificationsListLimit - unread.length;
                promise = $mmaNotifications.getReadNotifications(readCount, readLimit).then(function(read) {
                    readCount += read.length;
                    if (refresh) {
                        $scope.notifications = unread.concat(read);
                    } else {
                        $scope.notifications = $scope.notifications.concat(unread).concat(read);
                    }
                    $scope.canLoadMore = read.length >= readLimit;
                }, function(error) {
                    if (unread.length == 0) {
                        $mmUtil.showErrorModalDefault(error, 'mma.notifications.errorgetnotifications', true);
                        $scope.canLoadMore = false;
                    }
                });
            } else {
                promise = $q.when();
                if (refresh) {
                    $scope.notifications = unread;
                } else {
                    $scope.notifications = $scope.notifications.concat(unread);
                }
                $scope.canLoadMore = true;
            }
            return promise.then(function() {
                markNotificationsAsRead(unread);
            });
        }, function(error) {
            $mmUtil.showErrorModalDefault(error, 'mma.notifications.errorgetnotifications', true);
            $scope.canLoadMore = false;
        });
    }
    fetchNotifications().finally(function() {
        $scope.notificationsLoaded = true;
    });
    cronObserver = $mmEvents.on(mmaNotificationsReadCronEvent, function(data) {
        if ($state.current.name == 'site.notifications' && data && (data.siteid == siteId || !data.siteid)) {
            refreshData();
        }
    });
    if ($mmPushNotificationsDelegate) {
        $mmPushNotificationsDelegate.registerReceiveHandler('mmaNotifications:discussions', function(notification) {
            if ($state.current.name == 'site.notifications' && $mmUtil.isTrueOrOne(notification.notif) &&
                    notification.site == siteId) {
                refreshData();
            }
        });
    }
    var skip = true;
    $scope.$on('$ionicView.enter', function() {
        if (skip) {
            skip = false;
            return;
        }
        $scope.notificationsLoaded = false;
        refreshData().finally(function() {
            $scope.notificationsLoaded = true;
        });
    });
    function markNotificationsAsRead(notifications) {
        if (notifications.length > 0) {
            var promises = [];
            angular.forEach(notifications, function(notification) {
                promises.push($mmaNotifications.markNotificationRead(notification.id));
            });
            $q.all(promises).finally(function() {
                $mmaNotifications.invalidateNotificationsList().finally(function() {
                    $mmEvents.trigger(mmaNotificationsReadChangedEvent, {siteid: siteId});
                });
            });
        }
    }
    function refreshData() {
        return $mmaNotifications.invalidateNotificationsList().finally(function() {
            return fetchNotifications(true);
        });
    }
    $scope.refreshNotifications = function() {
        refreshData().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
    $scope.loadMoreNotifications = function(){
        fetchNotifications().finally(function() {
            $scope.$broadcast('scroll.infiniteScrollComplete');
        });
    };
    $scope.$on('$destroy', function() {
        cronObserver && cronObserver.off && cronObserver.off();
        if ($mmPushNotificationsDelegate) {
            $mmPushNotificationsDelegate.unregisterReceiveHandler('mmaNotifications:discussions');
        }
    });
}]);

angular.module('mm.addons.notifications')
.controller('mmaNotificationsPreferencesCtrl', ["$scope", "$mmaNotifications", "$mmUtil", "$ionicPlatform", "$mmUser", "$mmaMessageOutputDelegate", "$q", "$timeout", "$mmSettingsHelper", function($scope, $mmaNotifications, $mmUtil, $ionicPlatform, $mmUser,
            $mmaMessageOutputDelegate, $q, $timeout, $mmSettingsHelper) {
    var updateTimeout;
    $scope.isTablet = $ionicPlatform.isTablet();
    function fetchPreferences() {
        return $mmaNotifications.getNotificationPreferences().then(function(preferences) {
            if (!$scope.currentProcessor) {
                $scope.currentProcessor = $mmSettingsHelper.getProcessor(preferences.processors, 'airnotifier');
            }
            if (!$scope.currentProcessor) {
                return $q.reject('No processor found');
            }
            preferences.disableall = !!preferences.disableall;
            $scope.preferences = preferences;
            loadProcessor($scope.currentProcessor);
        }).catch(function(message) {
            $mmUtil.showErrorModal(message);
        }).finally(function() {
            $scope.preferencesLoaded = true;
        });
    }
    function loadProcessor(processor) {
        if (!processor) {
            return;
        }
        $scope.currentProcessor = processor;
        $scope.components = $mmSettingsHelper.getProcessorComponents(processor.name, $scope.preferences.components);
        processor.supported = $mmaMessageOutputDelegate.hasHandler(processor.name);
        if (processor.supported) {
            processor.preferencesLabel = $mmaMessageOutputDelegate.getPreferenceLabel(processor.name);
        }
    }
    function updatePreferencesAfterDelay() {
        $timeout.cancel(updateTimeout);
        updateTimeout = $timeout(function() {
            updateTimeout = null;
            updatePreferences();
        }, 5000);
    }
    function updatePreferences() {
        $mmaNotifications.invalidateNotificationPreferences().finally(function() {
            $mmaNotifications.getNotificationPreferences();
        });
    }
    fetchPreferences();
    $scope.refreshPreferences = function() {
        $mmaNotifications.invalidateNotificationPreferences().finally(function() {
            fetchPreferences().finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };
    $scope.changeProcessor = function(processor) {
        loadProcessor(processor);
    };
    $scope.openProcessorPreferences = function() {
        if (!$scope.currentProcessor || !$scope.currentProcessor.hassettings || !$scope.currentProcessor.supported) {
            return;
        }
        $mmaMessageOutputDelegate.openPreferencesViewFor($scope.currentProcessor);
    };
    $scope.changePreference = function(notification, state) {
        var processorState = notification.currentProcessor[state],
            preferenceName = notification.preferencekey + '_' + processorState.name,
            value;
        angular.forEach(notification.processors, function(processor) {
            if (processor[state].checked) {
                if (!value) {
                    value = processor.name;
                } else {
                    value += ',' + processor.name;
                }
            }
        });
        if (!value) {
            value = 'none';
        }
        processorState.updating = true;
        $mmUser.updateUserPreference(preferenceName, value).then(function() {
            updatePreferencesAfterDelay();
        }).catch(function(message) {
            $mmUtil.showErrorModal(message);
            notification.currentProcessor[state].checked = !notification.currentProcessor[state].checked;
        }).finally(function() {
            processorState.updating = false;
        });
    };
    $scope.disableAll = function(disable) {
        var modal = $mmUtil.showModalLoading('mm.core.sending', true);
        $mmUser.updateUserPreferences([], disable).then(function() {
            updatePreferencesAfterDelay();
        }).catch(function(message) {
            $mmUtil.showErrorModal(message);
            $scope.preferences.disableall = !$scope.preferences.disableall;
        }).finally(function() {
            modal.dismiss();
        });
    };
    $scope.$on('$destroy', function() {
        if (updateTimeout) {
            $timeout.cancel(updateTimeout);
            updatePreferences();
        }
    });
}]);

angular.module('mm.addons.notifications')
.directive('mmaNotificationsActions', ["$log", "$mmContentLinksDelegate", function($log, $mmContentLinksDelegate) {
    $log = $log.getInstance('mmaNotificationsActions');
    function link(scope) {
        if (scope.contexturl) {
            $mmContentLinksDelegate.getActionsFor(scope.contexturl, scope.courseid).then(function(actions) {
                scope.actions = actions;
            });
        }
    }
    return {
        link: link,
        restrict: 'E',
        scope: {
            contexturl: '=',
            courseid: '='
        },
        templateUrl: 'addons/notifications/templates/actions.html',
    };
}]);

angular.module('mm.addons.notifications')
.filter('mmaNotificationsFormat', ["$mmText", function($mmText) {
  return function(text) {
    text = text.replace(/-{4,}/ig, '');
    text = $mmText.replaceNewLines(text, '<br>');
    return text;
  };
}]);

angular.module('mm.addons.notifications')
.factory('$mmaNotificationsHandlers', ["$log", "$mmaNotifications", "$mmEvents", "$mmSitesManager", "$mmUtil", "mmaNotificationsReadChangedEvent", "mmaNotificationsReadCronEvent", "$mmAddonManager", function($log, $mmaNotifications, $mmEvents, $mmSitesManager, $mmUtil,
        mmaNotificationsReadChangedEvent, mmaNotificationsReadCronEvent, $mmAddonManager) {
    $log = $log.getInstance('$mmaNotificationsHandlers');
    var self = {};
        self.sideMenuNav = function() {
        var self = {};
                self.isEnabled = function() {
            return $mmaNotifications.isPluginEnabled();
        };
                self.getController = function() {
                        return function($scope) {
                var $mmPushNotificationsDelegate = $mmAddonManager.get('$mmPushNotificationsDelegate'),
                    $mmaPushNotifications = $mmAddonManager.get('$mmaPushNotifications'),
                    readChangedObserver, cronObserver;
                $scope.icon = 'ion-ios-bell';
                $scope.title = 'mma.notifications.notifications';
                $scope.state = 'site.notifications';
                $scope.class = 'mma-notifications-handler';
                if ($mmaNotifications.isNotificationCountEnabled(true)) {
                    $scope.loading = true;
                    updateUnreadNotificationsCount().finally(function() {
                        $scope.loading = false;
                    });
                    readChangedObserver = $mmEvents.on(mmaNotificationsReadChangedEvent, function(data) {
                        if (data && $mmSitesManager.isCurrentSite(data.siteid)) {
                            updateUnreadNotificationsCount(data.siteid);
                        }
                    });
                    cronObserver = $mmEvents.on(mmaNotificationsReadCronEvent, function(data) {
                        if (data && $mmSitesManager.isCurrentSite(data.siteid)) {
                            updateUnreadNotificationsCount(data.siteid);
                        }
                    });
                    if ($mmPushNotificationsDelegate) {
                        $mmPushNotificationsDelegate.registerReceiveHandler('mmaNotifications:sidemenu', function(notification) {
                            if ($mmUtil.isTrueOrOne(notification.notif) && $mmSitesManager.isCurrentSite(notification.site)) {
                                updateUnreadNotificationsCount(notification.site);
                            }
                        });
                        $mmPushNotificationsDelegate.registerCounterHandler('mmaNotifications');
                    }
                    function updateUnreadNotificationsCount(siteId) {
                        return $mmaNotifications.getUnreadNotificationsCount().then(function(unread) {
                            $scope.badge = parseInt(unread, 10) > 0 ? unread : '';
                            if ($mmaPushNotifications) {
                                $mmaPushNotifications.updateAddonCounter(siteId, 'mmaNotifications', unread);
                            }
                        });
                    }
                }
                $scope.$on('$destroy', function() {
                    readChangedObserver && readChangedObserver.off && readChangedObserver.off();
                    cronObserver && cronObserver.off && cronObserver.off();
                    if ($mmPushNotificationsDelegate) {
                        $mmPushNotificationsDelegate.unregisterReceiveHandler('mmaNotifications:sidemenu');
                    }
                });
            };
        };
                self.execute = function(siteId) {
            if ($mmSitesManager.isCurrentSite(siteId) && $mmaNotifications.isNotificationCountEnabled(true)) {
                $mmEvents.trigger(mmaNotificationsReadCronEvent, {
                    siteid: siteId
                });
            }
        };
                self.getInterval = function() {
            return 600000;
        };
                self.isSync = function() {
            return !$mmaNotifications.isNotificationCountEnabled();
        };
                self.canManualSync = function() {
            return true;
        };
                self.usesNetwork = function() {
            return true;
        };
        return self;
    };
        self.preferences = function() {
        var self = {};
                self.isEnabled = function() {
            return $mmaNotifications.isNotificationPreferencesEnabled();
        };
                self.getController = function() {
            return function($scope) {
                $scope.title = 'mma.notifications.notificationpreferences';
                $scope.class = 'mma-notifications-notificationpreferences-handler';
                $scope.state = 'site.notifications-preferences';
            };
        };
        return self;
    };
    return self;
}]);

angular.module('mm.addons.notifications')
.factory('$mmaNotifications', ["$q", "$log", "$mmSite", "$mmSitesManager", "$mmUser", "$mmUtil", "mmaNotificationsListLimit", function($q, $log, $mmSite, $mmSitesManager, $mmUser, $mmUtil, mmaNotificationsListLimit) {
    $log = $log.getInstance('$mmaNotifications');
    var self = {};
    function formatNotificationsData(notifications) {
        angular.forEach(notifications, function(notification) {
            if (notification.contexturl && notification.contexturl.indexOf('/mod/forum/')) {
                notification.mobiletext = notification.smallmessage;
            } else {
                notification.mobiletext = notification.fullmessage;
            }
            var cid = notification.fullmessagehtml.match(/course\/view\.php\?id=([^"]*)/);
            if (cid && cid[1]) {
                notification.courseid = cid[1];
            }
            $mmUser.getProfile(notification.useridfrom, notification.courseid, true).then(function(user) {
                notification.profileimageurlfrom = user.profileimageurl;
            });
        });
    }
        function getNotificationPreferencesCacheKey() {
        return 'mmaNotifications:notificationPreferences';
    }
        self.getNotificationPreferences = function(siteId) {
        $log.debug('Get notification preferences');
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var preSets = {
                    cacheKey: getNotificationPreferencesCacheKey()
                };
            return site.read('core_message_get_user_notification_preferences', {}, preSets).then(function(data) {
                return data.preferences;
            });
        });
    };
        function getNotificationsCacheKey() {
        return 'mmaNotifications:list';
    }
        self.getNotifications = function(read, limitFrom, limitNumber) {
        limitFrom = limitFrom || 0;
        limitNumber = limitNumber || mmaNotificationsListLimit;
        $log.debug('Get ' + (read ? 'read' : 'unread') + ' notifications from ' + limitFrom + '. Limit: ' + limitNumber);
        var data = {
            useridto: $mmSite.getUserId(),
            useridfrom: 0,
            type: 'notifications',
            read: read ? 1 : 0,
            newestfirst: 1,
            limitfrom: limitFrom,
            limitnum: limitNumber
        };
        var preSets = {
            cacheKey: getNotificationsCacheKey()
        };
        return $mmSite.read('core_message_get_messages', data, preSets).then(function(response) {
            if (response.messages) {
                var notifications = response.messages;
                formatNotificationsData(notifications);
                return notifications;
            } else {
                return $q.reject();
            }
        });
    };
        self.getReadNotifications = function(limitFrom, limitNumber) {
        return self.getNotifications(true, limitFrom, limitNumber);
    };
        self.getUnreadNotifications = function(limitFrom, limitNumber) {
        return self.getNotifications(false, limitFrom, limitNumber);
    };
        self.getUnreadNotificationsCount = function(userId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            if (site.wsAvailable('message_popup_get_unread_popup_notification_count')) {
                userId = userId || site.getUserId();
                var params = {
                        useridto: userId
                    },
                    preSets = {
                        getFromCache: 0,
                        emergencyCache: 0,
                        saveToCache: 0,
                        typeExpected: 'number'
                    };
                return site.read('message_popup_get_unread_popup_notification_count', params, preSets).catch(function() {
                    return 0;
                });
            }
            return self.getNotifications(false, 0, mmaNotificationsListLimit + 1).then(function(unread) {
                return (unread.length > mmaNotificationsListLimit) ? unread.length + "+" : unread.length;
            }).catch(function() {
                return 0;
            });
        });
    };
        self.markNotificationRead = function(notificationId) {
        var params = {
                'messageid': notificationId,
                'timeread': $mmUtil.timestamp()
            };
        return $mmSite.write('core_message_mark_message_read', params);
    };
        self.invalidateNotificationPreferences = function(siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getNotificationPreferencesCacheKey());
        });
    };
        self.invalidateNotificationsList = function() {
        return $mmSite.invalidateWsCacheForKey(getNotificationsCacheKey());
    };
        self.isNotificationCountEnabled = function(useFallback) {
        return $mmSite.wsAvailable('message_popup_get_unread_popup_notification_count') ||
            (useFallback && $mmSite.wsAvailable('core_message_get_messages'));
    };
        self.isNotificationPreferencesEnabled = function() {
        return $mmSite.wsAvailable('core_message_get_user_notification_preferences');
    };
        self.isPluginEnabled = function() {
        return $mmSite.wsAvailable('core_message_get_messages');
    };
        self.isPluginEnabledForSite = function(siteid) {
        return $mmSitesManager.getSite(siteid).then(function(site) {
            if (!site.wsAvailable('core_message_get_messages')) {
                return $q.reject();
            }
        });
    };
    return self;
}]);

angular.module('mm.addons.messageoutput')
.factory('$mmaMessageOutputDelegate', ["$q", "$log", "$mmSite", "$mmUtil", "$translate", function($q, $log, $mmSite, $mmUtil, $translate) {
    var handlers = {},
        enabledHandlers = {},
        self = {},
        updatePromises = {},
        lastUpdateHandlersStart;
    $log = $log.getInstance('$mmaMessageOutputDelegate');
        self.getPreferenceLabel = function(processorName) {
        if (enabledHandlers[processorName] && enabledHandlers[processorName].getPreferenceLabel) {
            return $translate.instant(enabledHandlers[processorName].getPreferenceLabel());
        }
        return $translate.instant('mm.settings.processorsettings');
    };
        self.hasHandler = function(processorName) {
        return typeof enabledHandlers[processorName] !== 'undefined';
    };
        self.isLastUpdateCall = function(time) {
        if (!lastUpdateHandlersStart) {
            return true;
        }
        return time == lastUpdateHandlersStart;
    };
        self.openPreferencesViewFor = function(processor) {
        if (self.hasHandler(processor.name)) {
            enabledHandlers[processor.name].openPreferencesView(processor);
        }
    };
        self.registerHandler = function(addon, processorName, handler) {
        if (typeof handlers[processorName] !== 'undefined') {
            $log.debug("Addon '" + handlers[processorName].addon + "' already registered as handler for '" + processorName + "'");
            return false;
        }
        $log.debug("Registered addon '" + addon + "' as preference handler.");
        handlers[processorName] = {
            addon: addon,
            handler: handler,
            instance: undefined
        };
        if ($mmSite.isLoggedIn()) {
            self.updatePreferenceHandler(processorName, handlers[processorName]);
        }
    };
        self.updatePreferenceHandler = function(processorName, handlerInfo, time) {
        var promise,
            deleted = false,
            siteId = $mmSite.getId();
        if (updatePromises[siteId] && updatePromises[siteId][processorName]) {
            return updatePromises[siteId][processorName];
        } else if (!updatePromises[siteId]) {
            updatePromises[siteId] = {};
        }
        if (typeof handlerInfo.instance === 'undefined') {
            handlerInfo.instance = $mmUtil.resolveObject(handlerInfo.handler, true);
        }
        if (!$mmSite.isLoggedIn()) {
            promise = $q.reject();
        } else {
            promise = $q.when(handlerInfo.instance.isEnabled());
        }
        promise = promise.catch(function() {
            return false;
        }).then(function(enabled) {
            if (self.isLastUpdateCall(time) && $mmSite.isLoggedIn() && $mmSite.getId() === siteId) {
                if (enabled) {
                    enabledHandlers[processorName] = handlerInfo.instance;
                } else {
                    delete enabledHandlers[processorName];
                }
            }
        }).finally(function() {
            delete updatePromises[siteId][processorName];
            deleted = true;
        });
        if (!deleted) {
            updatePromises[siteId][processorName] = promise;
        }
        return promise;
    };
        self.updatePreferenceHandlers = function() {
        var promises = [],
            now = new Date().getTime();
        $log.debug('Updating preferences handlers for current site.');
        lastUpdateHandlersStart = now;
        angular.forEach(handlers, function(handlerInfo, processorName) {
            promises.push(self.updatePreferenceHandler(processorName, handlerInfo, now));
        });
        return $q.all(promises).then(function() {
            return true;
        }, function() {
            return true;
        });
    };
    return self;
}])
.run(["$mmEvents", "mmCoreEventLogin", "mmCoreEventSiteUpdated", "mmCoreEventRemoteAddonsLoaded", "$mmaMessageOutputDelegate", function($mmEvents, mmCoreEventLogin, mmCoreEventSiteUpdated, mmCoreEventRemoteAddonsLoaded, $mmaMessageOutputDelegate) {
    $mmEvents.on(mmCoreEventLogin, $mmaMessageOutputDelegate.updatePreferenceHandlers);
    $mmEvents.on(mmCoreEventSiteUpdated, $mmaMessageOutputDelegate.updatePreferenceHandlers);
    $mmEvents.on(mmCoreEventRemoteAddonsLoaded, $mmaMessageOutputDelegate.updatePreferenceHandlers);
}]);

angular.module('mm.addons.participants')
.controller('mmaParticipantsListCtrl', ["$scope", "$state", "$stateParams", "$mmUtil", "$mmaParticipants", "$ionicPlatform", "$mmSite", "mmUserProfileState", function($scope, $state, $stateParams, $mmUtil, $mmaParticipants, $ionicPlatform, $mmSite,
            mmUserProfileState) {
    var course = $stateParams.course,
        courseid = course.id;
    $scope.participants = [];
    $scope.courseid = courseid;
    $scope.userStateName = mmUserProfileState;
    function fetchParticipants(refresh) {
        var firstToGet = refresh ? 0 : $scope.participants.length;
        return $mmaParticipants.getParticipants(courseid, firstToGet).then(function(data) {
            if (refresh) {
                $scope.participants = data.participants;
            } else {
                $scope.participants = $scope.participants.concat(data.participants);
            }
            $scope.canLoadMore = data.canLoadMore;
        }, function(message) {
            $mmUtil.showErrorModal(message);
            $scope.canLoadMore = false;
        });
    }
    fetchParticipants(true).then(function() {
        $mmSite.write('core_user_view_user_list', {
            courseid: courseid
        });
    }).finally(function() {
        $scope.participantsLoaded = true;
    });
    $scope.loadMoreParticipants = function(){
        fetchParticipants().finally(function() {
            $scope.$broadcast('scroll.infiniteScrollComplete');
        });
    };
    $scope.refreshParticipants = function() {
        $mmaParticipants.invalidateParticipantsList(courseid).finally(function() {
            fetchParticipants(true).finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };
}]);

angular.module('mm.addons.participants')
.factory('$mmaParticipantsHandlers', ["$mmaParticipants", "mmCoursesAccessMethods", "$state", "$mmContentLinkHandlerFactory", function($mmaParticipants, mmCoursesAccessMethods, $state, $mmContentLinkHandlerFactory) {
    var self = {};
        self.coursesNavHandler = function() {
        var self = {};
                self.isEnabled = function() {
            return true;
        };
                self.isEnabledForCourse = function(courseId, accessData, navOptions, admOptions) {
            if (accessData && accessData.type == mmCoursesAccessMethods.guest) {
                return false;
            }
            if (navOptions && typeof navOptions.participants != 'undefined') {
                return navOptions.participants;
            }
            return $mmaParticipants.isPluginEnabledForCourse(courseId);
        };
                self.getController = function(courseId) {
            return function($scope, $state) {
                $scope.icon = 'ion-person-stalker';
                $scope.title = 'mma.participants.participants';
                $scope.class = 'mma-participants-handler';
                $scope.action = function($event, course) {
                    $event.preventDefault();
                    $event.stopPropagation();
                    $state.go('site.participants', {
                        course: course
                    });
                };
            };
        };
        return self;
    };
        self.linksHandler = $mmContentLinkHandlerFactory.createChild(
            /\/user\/index\.php/, '$mmCoursesDelegate_mmaParticipants');
    self.linksHandler.isEnabled = function(siteId, url, params, courseId) {
        courseId = parseInt(params.id, 10) || courseId;
        if (!courseId || url.indexOf('/grade/report/') != -1) {
            return false;
        }
        return $mmaParticipants.isPluginEnabledForCourse(courseId, siteId);
    };
    self.linksHandler.getActions = function(siteIds, url, params, courseId) {
        courseId = parseInt(params.id, 10) || courseId;
        return [{
            action: function(siteId) {
                $state.go('redirect', {
                    siteid: siteId,
                    state: 'site.participants',
                    params: {
                        course: {id: courseId}
                    }
                });
            }
        }];
    };
    return self;
}]);

angular.module('mm.addons.participants')
.factory('$mmaParticipants', ["$log", "$mmSite", "$mmUser", "mmaParticipantsListLimit", "$mmSitesManager", function($log, $mmSite, $mmUser, mmaParticipantsListLimit, $mmSitesManager) {
    $log = $log.getInstance('$mmaParticipants');
    var self = {};
        function getParticipantsListCacheKey(courseId) {
        return 'mmaParticipants:list:' + courseId;
    }
        self.getParticipants = function(courseId, limitFrom, limitNumber, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            if (typeof limitFrom == 'undefined') {
                limitFrom = 0;
            }
            if (typeof limitNumber == 'undefined') {
                limitNumber = mmaParticipantsListLimit;
            }
            $log.debug('Get participants for course ' + courseId + ' starting at ' + limitFrom);
            var wsName,
                data = {
                    courseid: courseId
                }, preSets = {
                    cacheKey: getParticipantsListCacheKey(courseId)
                };
            if (site.wsAvailable('core_enrol_get_enrolled_users')) {
                wsName = 'core_enrol_get_enrolled_users';
                data.options = [
                    {
                        name: 'limitfrom',
                        value: limitFrom
                    },
                    {
                        name: 'limitnumber',
                        value: limitNumber
                    },
                    {
                        name: 'sortby',
                        value: 'siteorder'
                    }
                ];
            } else {
                wsName = 'moodle_enrol_get_enrolled_users';
                limitNumber = 9999999999;
            }
            return site.read(wsName, data, preSets).then(function(users) {
                angular.forEach(users, function(user) {
                    if (typeof user.id == 'undefined' && typeof user.userid != 'undefined') {
                        user.id = user.userid;
                    }
                    if (typeof user.profileimageurl == 'undefined' && typeof user.profileimgurl != 'undefined') {
                        user.profileimageurl = user.profileimgurl;
                    }
                });
                var canLoadMore = users.length >= limitNumber;
                $mmUser.storeUsers(users);
                return {participants: users, canLoadMore: canLoadMore};
            });
        });
    };
        self.invalidateParticipantsList = function(courseId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getParticipantsListCacheKey(courseId));
        });
    };
        self.isDisabled = function(siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return self.isDisabledInSite(site);
        });
    };
        self.isDisabledInSite = function(site) {
        site = site || $mmSite;
        return site.isFeatureDisabled('$mmCoursesDelegate_mmaParticipants');
    };
        self.isPluginEnabledForCourse = function(courseId, siteId) {
        if (!courseId) {
            return $q.reject();
        }
        return self.getParticipants(courseId, 0, 1, siteId).then(function() {
            return true;
        }).catch(function() {
            return false;
        });
    };
    return self;
}]);

angular.module('mm.addons.pushnotifications')
.factory('$mmPushNotificationsDelegate', ["$log", function($log) {
    $log = $log.getInstance('$mmPushNotificationsDelegate');
    var clickHandlers = {},
        receiveHandlers = {},
        counterHandlers = {},
        self = {};
        self.clicked = function(notification) {
        for (var name in clickHandlers) {
            var callback = clickHandlers[name];
            if (typeof callback == 'function') {
                var treated = callback(notification);
                if (treated) {
                    return;
                }
            }
        }
    };
        self.received = function(notification) {
        for (var name in receiveHandlers) {
            var callback = receiveHandlers[name];
            if (typeof callback == 'function') {
                callback(notification);
            }
        }
    };
        self.registerHandler = function(name, callback) {
        $log.debug("Registered handler '" + name + "' as CLICK push notification handler.");
        clickHandlers[name] = callback;
    };
        self.registerReceiveHandler = function(name, callback) {
        $log.debug("Registered handler '" + name + "' as RECEIVE push notification handler.");
        receiveHandlers[name] = callback;
    };
        self.unregisterReceiveHandler = function(name) {
        $log.debug("Unregister handler '" + name + "' from RECEIVE push notification handlers.");
        delete receiveHandlers[name];
    };
        self.registerCounterHandler = function(name) {
        $log.debug("Registered handler '" + name + "' as badge counter handler.");
        counterHandlers[name] = name;
    };
        self.isCounterHandlerRegistered = function(name) {
        return typeof counterHandlers[name] != "undefined";
    };
        self.getCounterHandlers = function() {
        return counterHandlers;
    };
    return self;
}]);

angular.module('mm.addons.pushnotifications')
.constant('mmaPushNotificationsBadgeStore', 'mma_pushnotifications_badge')
.config(["$mmAppProvider", "mmaPushNotificationsBadgeStore", function($mmAppProvider, mmaPushNotificationsBadgeStore) {
    var stores = [
        {
            name: mmaPushNotificationsBadgeStore,
            keyPath: ['siteid', 'addon'],
            indexes: [
                {
                    name: 'siteid'
                },
                {
                    name: 'addon'
                }
            ]
        }
    ];
    $mmAppProvider.registerStores(stores);
}])
.factory('$mmaPushNotifications', ["$mmSite", "$log", "$cordovaPushV5", "$mmText", "$q", "$cordovaDevice", "$mmUtil", "$mmSitesManager", "mmCoreConfigConstants", "$mmApp", "$mmLocalNotifications", "$mmPushNotificationsDelegate", "mmaPushNotificationsComponent", "mmaPushNotificationsBadgeStore", function($mmSite, $log, $cordovaPushV5, $mmText, $q, $cordovaDevice, $mmUtil, $mmSitesManager,
            mmCoreConfigConstants, $mmApp, $mmLocalNotifications, $mmPushNotificationsDelegate, mmaPushNotificationsComponent,
            mmaPushNotificationsBadgeStore) {
    $log = $log.getInstance('$mmaPushNotifications');
    var self = {},
        pushID;
        self.getPushId = function() {
        return pushID;
    };
        self.isPluginEnabled = function() {
        return $mmSite.wsAvailable('core_user_add_user_device')
                && $mmSite.wsAvailable('message_airnotifier_is_system_configured')
                && $mmSite.wsAvailable('message_airnotifier_are_notification_preferences_configured');
    };
        self.notificationClicked = function(notification) {
        $mmApp.ready().then(function() {
            $mmPushNotificationsDelegate.clicked(notification);
        });
    };
        self.onMessageReceived = function(notification) {
        var promise,
            data = notification ? notification.additionalData : {};
        if (data.site) {
            promise = $mmSitesManager.getSite(data.site);
        } else {
            promise = $q.when();
        }
        promise.then(function() {
            if ($mmUtil.isTrueOrOne(data.foreground)) {
                if ($mmLocalNotifications.isAvailable()) {
                    var localNotif = {
                            id: 1,
                            at: new Date(),
                            data: {
                                notif: data.notif,
                                site: data.site
                            }
                        },
                        promises = [];
                    promises.push($mmText.formatText(notification.title, true, true).then(function(formattedTitle) {
                        localNotif.title = formattedTitle;
                    }).catch(function() {
                        localNotif.title = notification.title;
                    }));
                    promises.push($mmText.formatText(notification.message, true, true).then(function(formattedMessage) {
                        localNotif.text = formattedMessage;
                    }).catch(function() {
                        localNotif.text = notification.message;
                    }));
                    $q.all(promises).then(function() {
                        $mmLocalNotifications.schedule(localNotif, mmaPushNotificationsComponent, data.site);
                    });
                }
                $mmApp.ready().then(function() {
                    data.title = notification.title;
                    data.message = notification.message;
                    $mmPushNotificationsDelegate.received(data);
                });
            } else {
                data.title = notification.title;
                data.message = notification.message;
                self.notificationClicked(data);
            }
        });
    };
        self.registerDevice = function() {
        try {
            var options = {
                android: {
                    senderID: mmCoreConfigConstants.gcmpn
                },
                ios: {
                    alert: true,
                    badge: true,
                    sound: true
                }
            };
            return $cordovaPushV5.initialize(options).then(function() {
                $cordovaPushV5.onNotification();
                $cordovaPushV5.onError();
                return $cordovaPushV5.register().then(function(token) {
                    pushID = token;
                    return self.registerDeviceOnMoodle();
                });
            });
        } catch(ex) {}
        return $q.reject();
    };
        self.registerDeviceOnMoodle = function() {
        $log.debug('Register device on Moodle.');
        if (!$mmSite.isLoggedIn() || !pushID || !$mmApp.isDevice()) {
            return $q.reject();
        }
        var data = {
            appid:      mmCoreConfigConstants.app_id,
            name:       ionic.Platform.device().name || '',
            model:      $cordovaDevice.getModel(),
            platform:   $cordovaDevice.getPlatform(),
            version:    $cordovaDevice.getVersion(),
            pushid:     pushID,
            uuid:       $cordovaDevice.getUUID()
        };
        return $mmSite.write('core_user_add_user_device', data);
    };
        self.unregisterDeviceOnMoodle = function(site) {
        if (!site || !$mmApp.isDevice()) {
            return $q.reject();
        }
        $log.debug('Unregister device on Moodle: ' + site.id);
        var data = {
            appid: mmCoreConfigConstants.app_id,
            uuid:  $cordovaDevice.getUUID()
        };
        return site.write('core_user_remove_user_device', data).then(function(response) {
            if (!response || !response.removed) {
                return $q.reject();
            }
        });
    };
        self.updateAddonCounter = function(siteId, addon, number) {
        if ($mmPushNotificationsDelegate.isCounterHandlerRegistered(addon)) {
            siteId = siteId || $mmSite.getId();
            return saveAddonBadge(siteId, number, addon).then(function() {
                return self.updateSiteCounter(siteId).then(function() {
                    return number;
                });
            });
        }
        return $q.when(0);
    };
        self.updateSiteCounter = function(siteId) {
        var addons = $mmPushNotificationsDelegate.getCounterHandlers(),
            promises = [];
        angular.forEach(addons, function(addon) {
            promises.push(getAddonBadge(siteId, addon));
        });
        return $q.all(promises).then(function (counters) {
            var plus = false,
                total = counters.reduce(function (previous, counter) {
                    if (counter != parseInt(counter, 10)) {
                        plus = true;
                        counter = parseInt(counter, 10);
                    }
                    return previous + counter;
                }, 0);
            total = plus && total > 0 ? total + '+' : total;
            return saveAddonBadge(siteId, total);
        }).then(function(siteTotal) {
            return self.updateAppCounter().then(function() {
                return siteTotal;
            });
        });
    };
        self.updateAppCounter = function() {
        return $mmSitesManager.getSitesIds().then(function (sites) {
            var promises = [];
            angular.forEach(sites, function(siteId) {
                promises.push(getAddonBadge(siteId));
            });
            return $q.all(promises).then(function (counters) {
                var total = counters.reduce(function (previous, counter) {
                        return previous + parseInt(counter, 10);
                    }, 0);
                return $cordovaPushV5.setBadgeNumber(total).then(function() {
                    return total;
                });
            });
        });
    };
        self.cleanSiteCounters = function(siteId) {
        var db = $mmApp.getDB();
        return db.whereEqual(mmaPushNotificationsBadgeStore, 'siteid', siteId).then(function (entries) {
            var promises =  [];
            angular.forEach(entries, function (entry) {
                promises.push(db.remove(mmaPushNotificationsBadgeStore, [entry.siteid, entry.addon]));
            });
            return $q.all(promises);
        }).finally(function() {
            self.updateAppCounter();
        });
    };
        self.getSiteCounter = function(siteId) {
        return getAddonBadge(siteId);
    };
        function getAddonBadge(siteId, addon) {
        addon = addon || 'site';
        return $mmApp.getDB().get(mmaPushNotificationsBadgeStore, [siteId, addon]).then(function(entry) {
             return (entry && entry.number) || 0;
        }).catch(function() {
            return 0;
        });
    }
        function saveAddonBadge(siteId, number, addon) {
        var entry = {
            siteid: siteId,
            addon: addon || 'site',
            number: number
        };
        return $mmApp.getDB().insert(mmaPushNotificationsBadgeStore, entry).then(function() {
            return number;
        });
    }
    return self;
}]);

angular.module('mm.addons.qbehaviour_adaptive')
.factory('$mmaQbehaviourAdaptiveHandler', ["$mmQuestionHelper", function($mmQuestionHelper) {
    var self = {};
        self.isEnabled = function() {
        return true;
    };
        self.handleQuestion = function(question) {
        $mmQuestionHelper.extractQbehaviourButtons(question);
    };
    return self;
}]);

angular.module('mm.addons.qbehaviour_adaptivenopenalty')
.factory('$mmaQbehaviourAdaptiveNoPenaltyHandler', ["$mmQuestionHelper", function($mmQuestionHelper) {
    var self = {};
        self.isEnabled = function() {
        return true;
    };
        self.handleQuestion = function(question) {
        $mmQuestionHelper.extractQbehaviourButtons(question);
    };
    return self;
}]);

angular.module('mm.addons.qbehaviour_deferredcbm')
.directive('mmaQbehaviourDeferredCbm', function() {
    return {
        restrict: 'A',
        priority: 100,
        templateUrl: 'addons/qbehaviour/deferredcbm/template.html'
    };
});

angular.module('mm.addons.qbehaviour_deferredcbm')
.factory('$mmaQbehaviourDeferredCBMHandler', ["$mmQuestionHelper", "$mmaQbehaviourDeferredFeedbackHandler", "$mmQuestion", function($mmQuestionHelper, $mmaQbehaviourDeferredFeedbackHandler, $mmQuestion) {
    var self = {};
        self.determineQuestionState = function(component, attemptId, question, siteId) {
        return $mmaQbehaviourDeferredFeedbackHandler.determineQuestionState(
                    component, attemptId, question, siteId, self.isCompleteResponse, self.isSameResponse);
    };
        self.isCompleteResponse = function(question, answers) {
        var complete = $mmQuestion.isCompleteResponse(question, answers);
        if (complete && complete != -1) {
            return !!answers['-certainty'];
        }
        return complete;
    };
        self.isSameResponse = function(question, prevAnswers, prevBasicAnswers, newAnswers, newBasicAnswers) {
        var same = $mmQuestion.isSameResponse(question, prevBasicAnswers, newBasicAnswers);
        if (same) {
            return prevAnswers['-certainty'] == newAnswers['-certainty'];
        }
        return same;
    };
        self.isEnabled = function() {
        return true;
    };
        self.handleQuestion = function(question) {
        if ($mmQuestionHelper.extractQbehaviourCBM(question)) {
            return ['mma-qbehaviour-deferred-cbm'];
        }
    };
    return self;
}]);

angular.module('mm.addons.qbehaviour_deferredfeedback')
.factory('$mmaQbehaviourDeferredFeedbackHandler', ["$mmQuestion", function($mmQuestion) {
    var self = {};
        self.determineQuestionState = function(component, attemptId, question, siteId, isComplete, isSame) {
        return $mmQuestion.getQuestion(component, attemptId, question.slot, siteId).catch(function() {
            return question;
        }).then(function(dbQuestion) {
            var state = $mmQuestion.getState(dbQuestion.state);
            if (state.finished || !state.active) {
                return false;
            }
            return $mmQuestion.getQuestionAnswers(component, attemptId, question.slot, false, siteId);
        }).then(function(prevAnswers) {
            var complete,
                gradable,
                newState,
                prevBasicAnswers,
                newBasicAnswers = $mmQuestion.getBasicAnswers(question.answers);
            prevAnswers = $mmQuestion.convertAnswersArrayToObject(prevAnswers, true);
            prevBasicAnswers = $mmQuestion.getBasicAnswers(prevAnswers);
            if (typeof isSame == 'function') {
                if (isSame(question, prevAnswers, prevBasicAnswers, question.answers, newBasicAnswers)) {
                    return false;
                }
            } else {
                if ($mmQuestion.isSameResponse(question, prevBasicAnswers, newBasicAnswers)) {
                    return false;
                }
            }
            if (typeof isComplete == 'function') {
                complete = isComplete(question, question.answers);
            } else {
                complete = $mmQuestion.isCompleteResponse(question, newBasicAnswers);
            }
            if (complete == -1) {
                newState = 'unknown';
            } else if (complete) {
                newState = 'complete';
            } else {
                gradable = $mmQuestion.isGradableResponse(question, newBasicAnswers);
                if (gradable == -1) {
                    newState = 'unknown';
                } else if (gradable) {
                    newState = 'invalid';
                } else {
                    newState = 'todo';
                }
            }
            return $mmQuestion.getState(newState);
        });
    };
        self.isEnabled = function() {
        return true;
    };
        self.handleQuestion = function(question) {
    };
    return self;
}]);

angular.module('mm.addons.qbehaviour_immediatecbm')
.factory('$mmaQbehaviourImmediateCBMHandler', ["$mmQuestionHelper", function($mmQuestionHelper) {
    var self = {};
        self.isEnabled = function() {
        return true;
    };
        self.handleQuestion = function(question) {
        $mmQuestionHelper.extractQbehaviourButtons(question);
        if ($mmQuestionHelper.extractQbehaviourCBM(question)) {
            return ['mma-qbehaviour-deferred-cbm'];
        }
    };
    return self;
}]);

angular.module('mm.addons.qbehaviour_immediatefeedback')
.factory('$mmaQbehaviourImmediateFeedbackHandler', ["$mmQuestionHelper", function($mmQuestionHelper) {
    var self = {};
        self.isEnabled = function() {
        return true;
    };
        self.handleQuestion = function(question) {
        $mmQuestionHelper.extractQbehaviourButtons(question);
    };
    return self;
}]);

angular.module('mm.addons.qbehaviour_informationitem')
.directive('mmaQbehaviourInformationItem', function() {
    return {
        restrict: 'A',
        priority: 100,
        templateUrl: 'addons/qbehaviour/informationitem/template.html'
    };
});

angular.module('mm.addons.qbehaviour_informationitem')
.factory('$mmaQbehaviourInformationItemHandler', ["$mmQuestionHelper", "$mmQuestion", function($mmQuestionHelper, $mmQuestion) {
    var self = {};
        self.determineQuestionState = function(component, attemptId, question, siteId, isComplete, isSame) {
        if (question.answers['-seen']) {
            return $mmQuestion.getState('complete');
        }
        return false;
    };
        self.isEnabled = function() {
        return true;
    };
        self.handleQuestion = function(question) {
        if ($mmQuestionHelper.extractQbehaviourSeenInput(question)) {
            return ['mma-qbehaviour-information-item'];
        }
    };
    return self;
}]);

angular.module('mm.addons.qbehaviour_interactive')
.factory('$mmaQbehaviourInteractiveHandler', ["$mmQuestionHelper", function($mmQuestionHelper) {
    var self = {};
        self.isEnabled = function() {
        return true;
    };
        self.handleQuestion = function(question) {
        $mmQuestionHelper.extractQbehaviourButtons(question);
    };
    return self;
}]);

angular.module('mm.addons.qbehaviour_interactivecountback')
.factory('$mmaQbehaviourInteractiveCountbackHandler', ["$mmQuestionHelper", function($mmQuestionHelper) {
    var self = {};
        self.isEnabled = function() {
        return true;
    };
        self.handleQuestion = function(question) {
        $mmQuestionHelper.extractQbehaviourButtons(question);
    };
    return self;
}]);

angular.module('mm.addons.qbehaviour_manualgraded')
.factory('$mmaQbehaviourManualGradedHandler', ["$mmQuestion", function($mmQuestion) {
    var self = {};
        self.determineQuestionState = function(component, attemptId, question, siteId, isComplete, isSame) {
        return $mmQuestion.getQuestion(component, attemptId, question.slot, siteId).catch(function() {
            return question;
        }).then(function(dbQuestion) {
            var state = $mmQuestion.getState(dbQuestion.state);
            if (state.finished || !state.active) {
                return false;
            }
            return $mmQuestion.getQuestionAnswers(component, attemptId, question.slot, false, siteId);
        }).then(function(prevAnswers) {
            var complete,
                newState,
                prevBasicAnswers,
                newBasicAnswers = $mmQuestion.getBasicAnswers(question.answers);
            prevAnswers = $mmQuestion.convertAnswersArrayToObject(prevAnswers);
            prevBasicAnswers = $mmQuestion.getBasicAnswers(prevAnswers);
            if (typeof isSame == 'function') {
                if (isSame(question, prevAnswers, prevBasicAnswers, question.answers, newBasicAnswers)) {
                    return false;
                }
            } else {
                if ($mmQuestion.isSameResponse(question, prevBasicAnswers, newBasicAnswers)) {
                    return false;
                }
            }
            if (typeof isComplete == 'function') {
                complete = isComplete(question, question.answers);
            } else {
                complete = $mmQuestion.isCompleteResponse(question, newBasicAnswers);
            }
            if (complete == -1) {
                newState = 'unknown';
            } else if (complete) {
                newState = 'complete';
            } else {
                newState = 'todo';
            }
            return $mmQuestion.getState(newState);
        });
    };
        self.isEnabled = function() {
        return true;
    };
        self.handleQuestion = function(question) {
    };
    return self;
}]);

angular.module('mm.addons.qtype_calculated')
.directive('mmaQtypeCalculated', ["$log", "$mmQuestionHelper", function($log, $mmQuestionHelper) {
	$log = $log.getInstance('mmaQtypeCalculated');
    return {
        restrict: 'A',
        priority: 100,
        templateUrl: 'addons/qtype/shortanswer/template.html',
        link: function(scope) {
            $mmQuestionHelper.inputTextDirective(scope, $log);
        }
    };
}]);

angular.module('mm.addons.qtype_calculated')
.factory('$mmaQtypeCalculatedHandler', ["$mmaQtypeNumericalHandler", function($mmaQtypeNumericalHandler) {
    var self = {};
        self.isCompleteResponse = function(question, answers) {
        return $mmaQtypeNumericalHandler.isCompleteResponse(question, answers);
    };
        self.isEnabled = function() {
        return true;
    };
        self.isGradableResponse = function(question, answers) {
        return $mmaQtypeNumericalHandler.isGradableResponse(question, answers);
    };
        self.isSameResponse = function(question, prevAnswers, newAnswers) {
        return $mmaQtypeNumericalHandler.isSameResponse(question, prevAnswers, newAnswers);
    };
        self.getDirectiveName = function(question) {
        return 'mma-qtype-calculated';
    };
    return self;
}]);

angular.module('mm.addons.qtype_calculatedmulti')
.directive('mmaQtypeCalculatedMulti', ["$log", "$mmQuestionHelper", function($log, $mmQuestionHelper) {
	$log = $log.getInstance('mmaQtypeCalculatedMulti');
    return {
        restrict: 'A',
        priority: 100,
        templateUrl: 'addons/qtype/multichoice/template.html',
        link: function(scope) {
        	$mmQuestionHelper.multiChoiceDirective(scope, $log);
        }
    };
}]);

angular.module('mm.addons.qtype_calculatedmulti')
.factory('$mmaQtypeCalculatedMultiHandler', ["$mmaQtypeMultichoiceHandler", function($mmaQtypeMultichoiceHandler) {
    var self = {};
        self.isCompleteResponse = function(question, answers) {
        return $mmaQtypeMultichoiceHandler.isCompleteResponseSingle(answers);
    };
        self.isEnabled = function() {
        return true;
    };
        self.isGradableResponse = function(question, answers) {
        return $mmaQtypeMultichoiceHandler.isGradableResponseSingle(answers);
    };
        self.isSameResponse = function(question, prevAnswers, newAnswers) {
        return $mmaQtypeMultichoiceHandler.isSameResponseSingle(prevAnswers, newAnswers);
    };
        self.getDirectiveName = function(question) {
        return 'mma-qtype-calculated-multi';
    };
    return self;
}]);

angular.module('mm.addons.qtype_calculatedsimple')
.directive('mmaQtypeCalculatedSimple', ["$log", "$mmQuestionHelper", function($log, $mmQuestionHelper) {
	$log = $log.getInstance('mmaQtypeCalculatedSimple');
    return {
        restrict: 'A',
        priority: 100,
        templateUrl: 'addons/qtype/shortanswer/template.html',
        link: function(scope) {
            $mmQuestionHelper.inputTextDirective(scope, $log);
        }
    };
}]);

angular.module('mm.addons.qtype_calculatedsimple')
.factory('$mmaQtypeCalculatedSimpleHandler', ["$mmaQtypeCalculatedHandler", function($mmaQtypeCalculatedHandler) {
    var self = {};
        self.isCompleteResponse = function(question, answers) {
        return $mmaQtypeCalculatedHandler.isCompleteResponse(question, answers);
    };
        self.isEnabled = function() {
        return true;
    };
        self.isGradableResponse = function(question, answers) {
        return $mmaQtypeCalculatedHandler.isGradableResponse(question, answers);
    };
        self.isSameResponse = function(question, prevAnswers, newAnswers) {
        return $mmaQtypeCalculatedHandler.isSameResponse(question, prevAnswers, newAnswers);
    };
        self.getDirectiveName = function(question) {
        return 'mma-qtype-calculated-simple';
    };
    return self;
}]);

angular.module('mm.addons.qtype_ddimageortext')
.directive('mmaQtypeDdimageortext', ["$log", "$mmQuestionHelper", "$mmaQtypeDdimageortextRender", "$timeout", "$mmUtil", function($log, $mmQuestionHelper, $mmaQtypeDdimageortextRender, $timeout, $mmUtil) {
	$log = $log.getInstance('mmaQtypeDdimageortext');
    return {
        restrict: 'A',
        priority: 100,
        templateUrl: 'addons/qtype/ddimageortext/template.html',
        link: function(scope) {
            var ddarea, questionEl,
                drops = [],
                question = scope.question;
            if (!question) {
                $log.warn('Aborting because of no question received.');
                return $mmQuestionHelper.showDirectiveError(scope);
            }
            questionEl = angular.element(question.html);
            questionEl = questionEl[0] || questionEl;
            ddarea = questionEl.querySelector('.ddarea');
            question.text = $mmUtil.getContentsOfElement(questionEl, '.qtext');
            if (!ddarea || typeof question.text == 'undefined') {
                log.warn('Aborting because of an error parsing question.', question.name);
                return self.showDirectiveError(scope);
            }
            question.ddarea = ddarea.outerHTML;
            question.readonly = false;
            if (question.initObjects) {
                if (typeof question.initObjects.drops != 'undefined') {
                    drops = question.initObjects.drops;
                }
                if (typeof question.initObjects.readonly != 'undefined') {
                    question.readonly = question.initObjects.readonly;
                }
            }
            question.loaded = false;
            $timeout(function() {
                var qi = $mmaQtypeDdimageortextRender.init_question(question, question.readonly, drops);
                scope.$on('$destroy', function() {
                    qi.destroy();
                });
            });
        }
    };
}]);

angular.module('mm.addons.qtype_ddimageortext')
.factory('$mmaQtypeDdimageortextHandler', ["$mmQuestion", function($mmQuestion) {
    var self = {};
        self.isCompleteResponse = function(question, answers) {
        var isComplete = true;
        angular.forEach(answers, function(value) {
            if (!value || value === '0') {
                isComplete = false;
            }
        });
        return isComplete;
    };
        self.isEnabled = function() {
        return true;
    };
        self.isGradableResponse = function(question, answers) {
        var hasReponse = false;
        angular.forEach(answers, function(value) {
            if (value && value !== '0') {
                hasReponse = true;
            }
        });
        return hasReponse;
    };
        self.isSameResponse = function(question, prevAnswers, newAnswers) {
        return $mmQuestion.compareAllAnswers(prevAnswers, newAnswers);
    };
        self.getBehaviour = function(question, behaviour) {
        if (behaviour === 'interactive') {
            return 'interactivecountback';
        }
        return behaviour;
    };
        self.getDirectiveName = function(question) {
        return 'mma-qtype-ddimageortext';
    };
    return self;
}]);

angular.module('mm.addons.qtype_ddimageortext')
.factory('$mmaQtypeDdimageortextRender', ["$mmUtil", "$timeout", function($mmUtil, $timeout) {
    var self = {};
    function question_instance(question, readonly, drops) {
        var instance = this;
        this.toload = 0;
        this.doc = null;
        this.afterimageloaddone = false;
        this.readonly = readonly;
        this.topnode = null;
        this.drops = drops;
        this.proportion = 1;
        this.selected = null;
        this.resizeFunction = function() {
            instance.reposition_drags_for_question();
        };
        this.destroy = function() {
            this.stop_polling();
            ionic.off('resize', this.resizeFunction, window);
        };
        this.initializer = function(question) {
            this.doc = this.doc_structure(question.slot);
            if (this.readonly) {
                var container = angular.element(this.doc.top_node());
                container.addClass('readonly');
            }
            $timeout(function() {
                var bgimg = instance.doc.bg_img();
                if (!bgimg.complete || !bgimg.naturalWidth) {
                    instance.toload++;
                    angular.element(bgimg).on('load', function() {
                        instance.toload--;
                    });
                }
                var item_homes = instance.doc.drag_item_homes();
                angular.forEach(item_homes, function(item) {
                    if (item.tagName == 'IMG') {
                        if (!item.complete || !item.naturalWidth) {
                            instance.toload++;
                            angular.element(item).on('load', function() {
                                instance.toload--;
                            });
                        }
                    }
                });
                instance.poll_for_image_load();
            });
            ionic.on('resize', this.resizeFunction, window);
        };
        this.poll_for_image_load = function () {
            if (this.afterimageloaddone) {
                return;
            }
            if (this.toload <= 0) {
                this.create_all_drag_and_drops();
                this.afterimageloaddone = true;
                question.loaded = true;
            }
            $timeout(function() {
                instance.poll_for_image_load();
            }, 1000);
        };
        this.stop_polling = function() {
            this.afterimageloaddone = true;
        };
                this.doc_structure = function(slot) {
            var topnode = document.querySelector("#mma-mod_quiz-question-" + slot + ' .mma-qtype-ddimageortext-container');
            var dragitemsarea = topnode.querySelector('div.dragitems');
            return {
                top_node : function() {
                    return topnode;
                },
                drag_itemsarea : function() {
                    return dragitemsarea;
                },
                drag_items : function() {
                    return dragitemsarea.querySelectorAll('.drag');
                },
                drop_zones : function() {
                    return topnode.querySelectorAll('div.dropzones div.dropzone');
                },
                drop_zone_group : function(groupno) {
                    return topnode.querySelectorAll('div.dropzones div.group' + groupno);
                },
                drag_items_cloned_from : function(dragitemno) {
                    return dragitemsarea.querySelectorAll('.dragitems' + dragitemno);
                },
                drag_item : function(draginstanceno) {
                    return dragitemsarea.querySelector('.draginstance' + draginstanceno);
                },
                drag_items_in_group : function(groupno) {
                    return dragitemsarea.querySelectorAll('.drag.group' + groupno);
                },
                drag_item_homes : function() {
                    return dragitemsarea.querySelectorAll('.draghome');
                },
                bg_img : function() {
                    return topnode.querySelector('.dropbackground');
                },
                drag_item_home : function (dragitemno) {
                    return dragitemsarea.querySelector('.dragitemhomes' + dragitemno);
                },
                get_classname_numeric_suffix : function(node, prefix) {
                    node = angular.element(node);
                    var classes = node.attr('class');
                    if (classes !== '') {
                        var classesarr = classes.split(' ');
                        var patt1 = new RegExp('^' + prefix + '([0-9])+$');
                        var patt2 = new RegExp('([0-9])+$');
                        for (var index = 0; index < classesarr.length; index++) {
                            if (patt1.test(classesarr[index])) {
                                var match = patt2.exec(classesarr[index]);
                                return + match[0];
                            }
                        }
                    }
                    throw 'Prefix "' + prefix + '" not found in class names.';
                },
                clone_new_drag_item : function (draginstanceno, dragitemno) {
                    var drag, divdrag;
                    var draghome = this.drag_item_home(dragitemno);
                    if (draghome === null) {
                        return null;
                    }
                    var draghomeimg = draghome.querySelector('img');
                    if (draghomeimg) {
                        draghomeimg = angular.element(draghomeimg);
                        draghome = angular.element(draghome);
                        drag = draghomeimg.clone(true);
                        divdrag = angular.element('<div>');
                        divdrag.append(drag);
                        divdrag.attr('class', draghome.attr('class'));
                        drag.attr('class', '');
                    } else {
                        draghome = angular.element(draghome);
                        divdrag = draghome.clone(true);
                    }
                    divdrag.removeClass('dragitemhomes' + dragitemno);
                    divdrag.removeClass('draghome');
                    divdrag.addClass('dragitems' + dragitemno);
                    divdrag.addClass('draginstance' + draginstanceno);
                    divdrag.addClass('drag');
                    divdrag.css('visibility', 'inherit').css('position', 'absolute');
                    divdrag.attr('draginstanceno', draginstanceno);
                    divdrag.attr('dragitemno', dragitemno);
                    draghome.after(divdrag);
                    return divdrag;
                }
            };
        };
        this.draggable_for_question = function (drag, group, choice) {
            drag.attr('group', group);
            drag.attr('choice', choice);
            drag.on('click', function(e) {
                if (drag.hasClass('beingdragged')) {
                    instance.deselect_drags();
                } else {
                    instance.select_drag(drag);
                }
                e.preventDefault();
                e.stopPropagation();
            });
        };
        this.select_drag = function(drag) {
            this.deselect_drags();
            this.selected = drag;
            drag.addClass('beingdragged');
        };
        this.deselect_drags = function() {
            var drags = this.doc.drag_items();
            angular.element(drags).removeClass('beingdragged');
            this.selected = null;
        };
        this.make_drag_area_clickable = function() {
            if (this.readonly) {
                return;
            }
            var home = angular.element(this.doc.drag_itemsarea());
            home.on('click', function(e) {
                var drag = instance.selected;
                if (!drag) {
                    return false;
                }
                instance.deselect_drags();
                instance.remove_drag_from_drop(drag);
                e.preventDefault();
                e.stopPropagation();
            });
        };
        this.update_padding_sizes_all = function () {
            for (var groupno = 1; groupno <= 8; groupno++) {
                this.update_padding_size_for_group(groupno);
            }
        };
        this.update_padding_size_for_group = function (groupno) {
            var originalpadding, img, width, height;
            var groupitems = this.doc.top_node().querySelectorAll('.draghome.group' + groupno);
            if (groupitems.length !== 0) {
                var maxwidth = 0;
                var maxheight = 0;
                for (var x = 0; x < groupitems.length; x++) {
                    img = groupitems[x].querySelector('img');
                    if (img) {
                        maxwidth = Math.max(maxwidth, Math.round(this.proportion * img.naturalWidth));
                        maxheight = Math.max(maxheight, Math.round(this.proportion * img.naturalHeight));
                    } else {
                        originalpadding = angular.element(groupitems[x]).css('padding');
                        angular.element(groupitems[x]).css('padding', '');
                        maxwidth = Math.max(maxwidth, Math.round(groupitems[x].clientWidth));
                        maxheight = Math.max(maxheight, Math.round(groupitems[x].clientHeight));
                        angular.element(groupitems[x]).css('padding', originalpadding);
                    }
                }
                if (maxwidth <= 0 || maxheight <= 0) {
                    return;
                }
                maxwidth = Math.round(maxwidth + this.proportion * 8);
                maxheight = Math.round(maxheight + this.proportion * 8);
                for (var y = 0; y < groupitems.length; y++) {
                    var item = groupitems[y];
                    img = item.querySelector('img');
                    if (img) {
                        width = Math.round(img.naturalWidth * this.proportion);
                        height = Math.round(img.naturalHeight * this.proportion);
                    } else {
                        originalpadding = angular.element(item).css('padding');
                        angular.element(item).css('padding', '');
                        width = Math.round(item.clientWidth);
                        height = Math.round(item.clientHeight);
                        angular.element(item).css('padding', originalpadding);
                    }
                    var margintopbottom = Math.round((maxheight - height) / 2);
                    var marginleftright = Math.round((maxwidth - width) / 2);
                    var widthcorrection = maxwidth - (width + marginleftright * 2);
                    var heightcorrection = maxheight - (height + margintopbottom * 2);
                    angular.element(item).css('padding', margintopbottom + 'px ' + marginleftright + 'px ' +
                        (margintopbottom + heightcorrection) + 'px ' + (marginleftright + widthcorrection) + 'px');
                    var dragitemno = Number(this.doc.get_classname_numeric_suffix(item, 'dragitemhomes'));
                    var drags = this.doc.top_node().querySelectorAll('.drag.group' + groupno + '.dragitems' + dragitemno);
                    angular.element(drags).css('padding', margintopbottom + 'px ' + marginleftright + 'px ' +
                        (margintopbottom + heightcorrection) + 'px ' + (marginleftright + widthcorrection) + 'px');
                }
                angular.element(this.doc.drop_zone_group(groupno))
                    .css('width', maxwidth + 2 + 'px ').css('height', maxheight + 2 + 'px ');
            }
        };
        this.convert_to_window_xy = function (bgimgxy) {
            var position = $mmUtil.getElementXY(this.doc.bg_img(), null, 'ddarea');
            bgimgxy = bgimgxy.split(',');
            bgimgxy[0] *= this.proportion;
            bgimgxy[1] *= this.proportion;
            return [Number(bgimgxy[0]) + position[0] + 1, Number(bgimgxy[1]) + position[1] + 1];
        };
        this.create_all_drag_and_drops = function () {
            this.init_drops();
            angular.element(this.doc.drag_itemsarea()).addClass('clearfix');
            this.make_drag_area_clickable();
            var i = 0;
            var dragitemhomes = this.doc.drag_item_homes();
            for (var x = 0; x < dragitemhomes.length; x++) {
                var dragitemhome = dragitemhomes[x];
                var dragitemno = Number(this.doc.get_classname_numeric_suffix(dragitemhome, 'dragitemhomes'));
                var choice = + this.doc.get_classname_numeric_suffix(dragitemhome, 'choice');
                var group = + this.doc.get_classname_numeric_suffix(dragitemhome, 'group');
                if (dragitemhome.tagName == 'IMG') {
                    var dragitemhomeAng = angular.element(dragitemhome);
                    var wrap = angular.element('<div>');
                    wrap.addClass(dragitemhomeAng.attr('class'));
                    dragitemhomeAng.attr('class', '');
                    dragitemhomeAng.wrap(wrap);
                }
                var dragnode = this.doc.clone_new_drag_item(i, dragitemno);
                i++;
                if (!this.readonly) {
                    this.draggable_for_question(dragnode, group, choice);
                }
                if (dragnode.hasClass('infinite')) {
                    var groupsize = this.doc.drop_zone_group(group).length;
                    var dragstocreate = groupsize - 1;
                    while (dragstocreate > 0) {
                        dragnode = this.doc.clone_new_drag_item(i, dragitemno);
                        i++;
                        if (!this.readonly) {
                            this.draggable_for_question(dragnode, group, choice);
                        }
                        dragstocreate--;
                    }
                }
            }
            this.reposition_drags_for_question();
            if (!this.readonly) {
                var dropzones = this.doc.drop_zones();
                angular.element(dropzones).attr('tabIndex', 0);
            }
        };
        this.drop_click = function (dropnode) {
            var drag = instance.selected;
            if (!drag) {
                return false;
            }
            this.deselect_drags();
            dropnodeAng = angular.element(dropnode);
            if (Number(dropnodeAng.attr('group')) === Number(drag.attr('group'))) {
                this.place_drag_in_drop(drag, dropnode);
            }
        };
        this.remove_drag_from_drop = function (drag) {
            var inputid = drag.attr('inputid');
            if (inputid) {
                var inputnode = angular.element(this.doc.top_node().querySelector('input#' + inputid));
                inputnode.attr('value', '');
            }
            var dragitemhome = this.doc.drag_item_home(drag.attr('dragitemno'));
            var position = $mmUtil.getElementXY(dragitemhome, null, 'ddarea');
            drag.css('left', position[0] + 'px').css('top', position[1] + 'px');
            drag.removeClass('placed');
            drag.attr('inputid', '');
        };
        this.place_drag_in_drop = function (drag, drop) {
            var targetinputid = angular.element(drop).attr('inputid');
            var inputnode = angular.element(this.doc.top_node().querySelector('input#' + targetinputid));
            var origininputid = drag.attr('inputid');
            if (origininputid && origininputid != targetinputid) {
                var origininputnode = angular.element(this.doc.top_node().querySelector('input#' + origininputid));
                origininputnode.attr('value', '');
            }
            var position = $mmUtil.getElementXY(drop, null, 'ddarea');
            drag.css('left', position[0] - 1 + 'px').css('top', position[1] - 1 + 'px');
            drag.addClass('placed');
            inputnode.attr('value', drag.attr('choice'));
            drag.attr('inputid', targetinputid);
        };
        this.calculate_img_proportion = function() {
            var bgimg = this.doc.bg_img();
            this.proportion = 1;
            if (bgimg.width != bgimg.naturalWidth) {
                this.proportion = bgimg.width / bgimg.naturalWidth;
            }
        };
        this.reposition_drags_for_question = function() {
            var dragitem;
            var drag_items = this.doc.drag_items();
            angular.element(drag_items).removeClass('placed').attr('inputid', '');
            this.calculate_img_proportion();
            var dragitemhomes = this.doc.drag_item_homes();
            for (var x = 0; x < dragitemhomes.length; x++) {
                var dragitemhome = dragitemhomes[x];
                var dragitemhomeimg = dragitemhome.querySelector('img');
                if (dragitemhomeimg && dragitemhomeimg.naturalWidth > 0) {
                    var widthheight = [Math.round(dragitemhomeimg.naturalWidth * this.proportion),
                        Math.round(dragitemhomeimg.naturalHeight * this.proportion)];
                    angular.element(dragitemhomeimg).css('width', widthheight[0] + 'px').css('height', widthheight[1] + 'px');
                    var dragitemno = Number(this.doc.get_classname_numeric_suffix(dragitemhome, 'dragitemhomes'));
                    var groupno = this.doc.get_classname_numeric_suffix(dragitemhome, 'group');
                    var dragsimg = this.doc.top_node().querySelectorAll('.drag.group' + groupno + '.dragitems' + dragitemno + '  img');
                    angular.element(dragsimg).css('width', widthheight[0] + 'px').css('height', widthheight[1] + 'px');
                }
            }
            this.update_padding_sizes_all();
            var drop_zones = this.doc.drop_zones();
            for (var y = 0; y < drop_zones.length; y++) {
                var dropzone = drop_zones[y];
                var dropzoneAng = angular.element(dropzone);
                var relativexy = instance.convert_to_window_xy(dropzoneAng.attr('xy'));
                dropzoneAng.css('left', relativexy[0] + 'px').css('top', relativexy[1] + 'px');
                var inputcss = 'input#' + dropzoneAng.attr('inputid');
                var input = instance.doc.top_node().querySelector(inputcss);
                var choice = Number(input.value);
                if (choice > 0) {
                    dragitem = instance.get_unplaced_choice_for_drop(choice, dropzoneAng);
                    if (dragitem !== null) {
                        instance.place_drag_in_drop(dragitem, dropzone);
                    }
                }
            }
            for (var z = 0; z < drag_items.length; z++) {
                dragitem = angular.element(drag_items[z]);
                if (!dragitem.hasClass('placed') && !dragitem.hasClass('beingdragged')) {
                    instance.remove_drag_from_drop(dragitem);
                }
            }
        };
        this.get_choices_for_drop = function(choice, drop) {
            var group = drop.attr('group');
            return this.doc.top_node().querySelectorAll('div.dragitemgroup' + group + ' .choice' + choice + '.drag');
        };
        this.get_unplaced_choice_for_drop = function(choice, drop) {
            var dragitems = this.get_choices_for_drop(choice, drop);
            var dragitem;
            for (var x = 0; x < dragitems.length; x++) {
                dragitem = angular.element(dragitems[x]);
                if (instance.readonly || (!dragitem.hasClass('placed') && !dragitem.hasClass('beingdragged'))) {
                    return dragitem;
                }
            }
            return null;
        };
        this.init_drops = function () {
            var dropareas = this.doc.top_node().querySelector('div.dropzones');
            dropareas = angular.element(dropareas);
            var groupnodes = {};
            for (var groupno = 1; groupno <= 8; groupno++) {
                var groupnode = angular.element('<div class = "dropzonegroup' + groupno + '"></div>');
                dropareas.append(groupnode);
                groupnodes[groupno] = groupnode;
            }
            for (var dropno in this.drops) {
                var drop = this.drops[dropno];
                var nodeclass = 'dropzone group' + drop.group + ' place' + dropno;
                var title = drop.text.replace('"', '\"');
                var dropnodehtml = '<div title="' + title + '" class="' + nodeclass + '">&nbsp;</div>';
                var dropnode = angular.element(dropnodehtml);
                groupnodes[drop.group].append(dropnode);
                dropnode.css('opacity', 0.5);
                dropnode.attr('xy', drop.xy);
                dropnode.attr('aria-label', drop.text);
                dropnode.attr('place', dropno);
                dropnode.attr('inputid', drop.fieldname.replace(':', '_'));
                dropnode.attr('group', drop.group);
                dropnode.on('click', function(e) {
                    instance.drop_click(this);
                    e.preventDefault();
                    e.stopPropagation();
                });
            }
        };
        this.initializer(question);
    }
    self.init_question = function(question, readonly, drops) {
        var qi = new question_instance(question, readonly, drops);
        return qi;
    };
    return self;
}]);
angular.module('mm.addons.qtype_ddmarker')
.directive('mmaQtypeDdmarker', ["$log", "$mmQuestionHelper", "$mmaQtypeDdmarkerRender", "$timeout", "$mmUtil", function($log, $mmQuestionHelper, $mmaQtypeDdmarkerRender, $timeout, $mmUtil) {
    $log = $log.getInstance('mmaQtypeDdmarker');
    return {
        restrict: 'A',
        priority: 100,
        templateUrl: 'addons/qtype/ddmarker/template.html',
        link: function(scope) {
            var ddarea, ddform, wrongparts, questionEl,
                dropzones = [],
                question = scope.question;
            if (!question) {
                $log.warn('Aborting because of no question received.');
                return $mmQuestionHelper.showDirectiveError(scope);
            }
            questionEl = angular.element(question.html);
            questionEl = questionEl[0] || questionEl;
            ddarea = questionEl.querySelector('.ddarea');
            ddform = questionEl.querySelector('.ddform');
            question.text = $mmUtil.getContentsOfElement(questionEl, '.qtext');
            if (!ddarea || !ddform || typeof question.text == 'undefined') {
                log.warn('Aborting because of an error parsing question.', question.name);
                return self.showDirectiveError(scope);
            }
            question.ddarea = ddarea.outerHTML;
            wrongparts = questionEl.querySelector('.wrongparts');
            if (wrongparts) {
                question.ddarea += wrongparts.outerHTML;
            }
            question.ddarea += ddform.outerHTML;
            question.readonly = false;
            if (question.initObjects) {
                if (typeof question.initObjects.dropzones != 'undefined') {
                    dropzones = question.initObjects.dropzones;
                }
                if (typeof question.initObjects.readonly != 'undefined') {
                    question.readonly = question.initObjects.readonly;
                }
            }
            question.loaded = false;
            $timeout(function() {
                var qi = $mmaQtypeDdmarkerRender.init_question(question, question.readonly, dropzones);
                scope.$on('$destroy', function() {
                    qi.destroy();
                });
            });
        }
    };
}]);

angular.module('mm.addons.qtype_ddmarker')
.factory('$mmaQtypeDdmarkerHandler', ["$mmQuestion", function($mmQuestion) {
    var self = {};
        self.isCompleteResponse = function(question, answers) {
        var hasReponse = false;
        angular.forEach(answers, function(value) {
            if (value) {
                hasReponse = true;
            }
        });
        return hasReponse;
    };
        self.isEnabled = function() {
        return true;
    };
        self.isGradableResponse = function(question, answers) {
        return self.isCompleteResponse(question, answers);
    };
        self.isSameResponse = function(question, prevAnswers, newAnswers) {
        return $mmQuestion.compareAllAnswers(prevAnswers, newAnswers);
    };
        self.getBehaviour = function(question, behaviour) {
        if (behaviour === 'interactive') {
            return 'interactivecountback';
        }
        return behaviour;
    };
        self.getDirectiveName = function(question) {
        return 'mma-qtype-ddmarker';
    };
    return self;
}]);

angular.module('mm.addons.qtype_ddmarker')
.factory('$mmaQtypeDdmarkerRender', ["$mmUtil", "$timeout", function($mmUtil, $timeout) {
    var self = {};
    function question_instance(question, readonly, dropzones) {
        var instance = this;
        this.doc = null;
        this.afterimageloaddone = false;
        this.drops = null;
        this.readonly = readonly;
        this.topnode = null;
        this.dropzones = dropzones;
        this.colours = ['#FFFFFF', '#B0C4DE', '#DCDCDC', '#D8BFD8', '#87CEFA','#DAA520', '#FFD700', '#F0E68C'];
        this.nextcolourindex = 0;
        this.proportion = 1;
        this.shapes = [];
        this.selected = null;
        this.resizeFunction = function() {
            instance.redraw_drags_and_drops();
        };
        this.destroy = function() {
            ionic.off('resize', this.resizeFunction, window);
        };
        function GraphicsAPI () {
            this.dropzone = null;
            var NS="http://www.w3.org/2000/svg";
            this.addShape = function(shapeAttribs, coords) {
                var SVGObj= document.createElementNS(NS, shapeAttribs.type);
                var shape = angular.element(SVGObj)
                    .attr('fill', shapeAttribs.color)
                    .attr('fill-opacity', 0.5)
                    .attr('stroke', 'black');
                for (var x in coords) {
                    shape.attr(x, coords[x]);
                }
                this.dropzone.append(shape);
                return shape;
            };
            this.clear = function() {
                var bgimg = instance.doc.bg_img();
                var position = $mmUtil.getElementXY(bgimg, null, 'ddarea');
                var dropzones = instance.doc.top_node().querySelector("div.ddarea div.dropzones");
                dropzones = angular.element(dropzones);
                dropzones.css('left', position[0] + 'px')
                    .css('top', position[1] + 'px')
                    .css('width', bgimg.width + 'px')
                    .css('height', bgimg.height + 'px');
                var markertexts = angular.element(instance.doc.marker_texts());
                markertexts.css('left', position[0] + 'px')
                    .css('top', position[1] + 'px')
                    .css('width', bgimg.width + 'px')
                    .css('height', bgimg.height + 'px');
                if (!this.dropzone) {
                    this.dropzone = document.createElementNS(NS, "svg");
                    this.dropzone = angular.element(this.dropzone);
                    dropzones.append(this.dropzone);
                } else {
                    this.dropzone.empty();
                }
                this.dropzone.css('width', bgimg.width + 'px').css('height', bgimg.height + 'px');
                instance.shapes = [];
            };
        }
        var graphics = new GraphicsAPI();
        this.initializer = function(question) {
            this.doc = this.doc_structure(question.slot);
            $timeout(function() {
                instance.poll_for_image_load();
            });
            ionic.on('resize', this.resizeFunction, window);
        };
        this.poll_for_image_load = function () {
            if (this.afterimageloaddone) {
                return;
            }
            var bgimg = angular.element(this.doc.bg_img());
            bgimg.on('load', function() {
                bgimg.off('load');
                instance.make_image_dropable();
                $timeout(function() {
                    instance.redraw_drags_and_drops();
                });
                instance.afterimageloaddone = true;
                question.loaded = true;
            });
            $timeout(function() {
                instance.poll_for_image_load();
            }, 500);
        };
                this.doc_structure = function(slot) {
            var topnode = document.querySelector("#mma-mod_quiz-question-" + slot + ' .mma-qtype-ddmarker-container');
            var dragitemsarea = topnode.querySelector('div.dragitems');
            return {
                top_node : function() {
                    return topnode;
                },
                bg_img : function() {
                    return topnode.querySelector('.dropbackground');
                },
                drag_itemsarea : function() {
                    return dragitemsarea;
                },
                drag_items : function() {
                    return dragitemsarea.querySelectorAll('.dragitem');
                },
                drag_items_for_choice : function(choiceno) {
                    return dragitemsarea.querySelectorAll('span.dragitem.choice' + choiceno);
                },
                drag_item_for_choice : function(choiceno, itemno) {
                    return dragitemsarea.querySelector('span.dragitem.choice' + choiceno +
                                            '.item' + itemno);
                },
                drag_item_being_dragged : function(choiceno) {
                    return dragitemsarea.querySelector('span.dragitem.beingdragged.choice' + choiceno);
                },
                drag_item_home : function (choiceno) {
                    return dragitemsarea.querySelector('span.draghome.choice' + choiceno);
                },
                drag_item_homes : function() {
                    return dragitemsarea.querySelectorAll('span.draghome');
                },
                get_classname_numeric_suffix : function(node, prefix) {
                    node = angular.element(node);
                    var classes = node.attr('class');
                    if (classes !== '') {
                        var classesarr = classes.split(' ');
                        var patt1 = new RegExp('^' + prefix + '([0-9])+$');
                        var patt2 = new RegExp('([0-9])+$');
                        for (var index = 0; index < classesarr.length; index++) {
                            if (patt1.test(classesarr[index])) {
                                var match = patt2.exec(classesarr[index]);
                                return Number(match[0]);
                            }
                        }
                    }
                    return null;
                },
                inputs_for_choices : function () {
                    return topnode.querySelectorAll('input.choices');
                },
                input_for_choice : function (choiceno) {
                    return topnode.querySelector('input.choice' + choiceno);
                },
                marker_texts : function () {
                    return topnode.querySelector('div.markertexts');
                }
            };
        };
        this.restart_colours = function () {
            this.nextcolourindex = 0;
        };
        this.get_next_colour = function () {
            var colour = this.colours[this.nextcolourindex];
            this.nextcolourindex++;
            if (this.nextcolourindex === this.colours.length) {
                this.nextcolourindex = 0;
            }
            return colour;
        };
        this.convert_to_window_xy = function (bgimgxy) {
            var bgimg = this.doc.bg_img();
            var position = $mmUtil.getElementXY(bgimg, null, 'ddarea');
            bgimgxy[0] *= this.proportion;
            bgimgxy[1] *= this.proportion;
            return [Number(bgimgxy[0]) + position[0], Number(bgimgxy[1]) + position[1]];
        };
        this.draw_drop_zone = function (dropzoneno, markertext, shape, coords, colour, link) {
            var existingmarkertext;
            var marker_texts = this.doc.marker_texts();
            if (link) {
                existingmarkertext = marker_texts.querySelector('span.markertext' + dropzoneno + ' a');
            } else {
                existingmarkertext = marker_texts.querySelector('span.markertext' + dropzoneno);
            }
            if (existingmarkertext) {
                existingmarkertext = angular.element(existingmarkertext);
                if (markertext !== '') {
                    existingmarkertext.html(markertext);
                } else {
                    existingmarkertext.remove();
                }
            } else if (markertext !== '') {
                var classnames = 'markertext markertext' + dropzoneno;
                marker_texts = angular.element(marker_texts);
                if (link) {
                    marker_texts.append('<span class="' + classnames + '"><a href="#">' + markertext + '</a></span>');
                } else {
                    marker_texts.append('<span class="' + classnames + '">' + markertext + '</span>');
                }
            }
            var drawfunc = 'draw_shape_' + shape;
            if (this[drawfunc] instanceof Function){
                var xyfortext = this[drawfunc](dropzoneno, coords, colour);
                if (xyfortext !== null) {
                    var markerspan = this.doc.top_node().querySelector('div.ddarea div.markertexts span.markertext' + dropzoneno);
                    if (markerspan !== null) {
                        xyfortext[0] = (xyfortext[0] - markerspan.offsetWidth / 2) * this.proportion;
                        xyfortext[1] = (xyfortext[1] - markerspan.offsetHeight / 2) * this.proportion;
                        var markerspanAng = angular.element(markerspan);
                        markerspanAng.css('opacity', '0.6').css('left', xyfortext[0] + 'px').css('top', xyfortext[1] + 'px');
                        var markerspananchor = markerspan.querySelector('a');
                        if (markerspananchor !== null) {
                            markerspananchor = angular.element(markerspananchor);
                            markerspananchor.on('click', function (e) {
                                angular.forEach(instance.shapes, function(elem) {
                                    elem.css('fill-opacity', 0.5);
                                });
                                instance.shapes[dropzoneno].css('fill-opacity', 1);
                                $timeout(function() {
                                    instance.shapes[dropzoneno].css('fill-opacity', 0.5);
                                }, 2000);
                                e.preventDefault();
                                e.stopPropagation();
                            });
                            markerspananchor.attr('tabIndex', 0);
                       }
                   }
               }
            }
        };
        this.draw_shape_circle = function (dropzoneno, coords, colour) {
            var coordsparts = coords.match(/(\d+),(\d+);(\d+)/);
            if (coordsparts && coordsparts.length === 4) {
                coordsparts.shift();
                coordsparts = coordsparts.map(function(i) {
                   return Number(i);
                });
                var circleLimit = [coordsparts[0] - coordsparts[2], coordsparts[1] - coordsparts[2]];
                if (this.coords_in_img(circleLimit)) {
                    this.shapes[dropzoneno] = graphics.addShape({
                        type: 'circle',
                        color: colour
                    }, {
                        cx: coordsparts[0] * instance.proportion,
                        cy: coordsparts[1] * instance.proportion,
                        r: coordsparts[2] * instance.proportion
                    });
                    return [coordsparts[0], coordsparts[1]];
                }
            }
            return null;
        };
        this.draw_shape_rectangle = function (dropzoneno, coords, colour) {
            var coordsparts = coords.match(/(\d+),(\d+);(\d+),(\d+)/);
            if (coordsparts && coordsparts.length === 5) {
                coordsparts.shift();
                coordsparts = coordsparts.map(function(i) {
                   return Number(i);
                });
                var rectLimits = [coordsparts[0] + coordsparts[2], coordsparts[1] + coordsparts[3]];
                if (this.coords_in_img(rectLimits)) {
                    this.shapes[dropzoneno] = graphics.addShape({
                        type: 'rect',
                        color: colour
                    }, {
                        x: coordsparts[0] * instance.proportion,
                        y: coordsparts[1] * instance.proportion,
                        width: coordsparts[2] * instance.proportion,
                        height: coordsparts[3] * instance.proportion
                    });
                    return [coordsparts[0] + coordsparts[2] / 2, coordsparts[1] + coordsparts[3] / 2];
                }
            }
            return null;
        };
        this.draw_shape_polygon = function (dropzoneno, coords, colour) {
            var coordsparts = coords.split(';');
            var points = [];
            var maxxy = [0, 0];
            var bgimg = this.doc.bg_img();
            var minxy = [bgimg.width, bgimg.height];
            for (var i in coordsparts) {
                var parts = coordsparts[i].match(/^(\d+),(\d+)$/);
                if (parts !== null && this.coords_in_img([parts[1], parts[2]])) {
                    parts[1] *= this.proportion;
                    parts[2] *= this.proportion;
                    minxy[0] = Math.min(parts[1], minxy[0]);
                    minxy[1] = Math.min(parts[2], minxy[1]);
                    maxxy[0] = Math.max(parts[1], maxxy[0]);
                    maxxy[1] = Math.max(parts[2], maxxy[1]);
                    points.push(parts[1] + ',' + parts[2]);
                }
            }
            if (points.length > 2) {
                this.shapes[dropzoneno] = graphics.addShape({
                    type: "polygon",
                    color: colour
                }, {
                    points: points.join(' ')
                });
                return [(minxy[0] + maxxy[0]) / 2, (minxy[1] + maxxy[1]) / 2];
            }
            return null;
        };
        this.coords_in_img = function (coords) {
            return (coords[0] * this.proportion <= this.doc.bg_img().width && coords[1] * this.proportion <= this.doc.bg_img().height);
        };
                this.clone_new_drag_item = function (draghome, itemno) {
            var marker = draghome.querySelector('span.markertext');
            angular.element(marker).css('opacity', 0.6);
            draghome = angular.element(draghome);
            var drag = draghome.clone(true);
            drag.removeClass('draghome');
            drag.addClass('dragitem');
            drag.addClass('item' + itemno);
            draghome.after(drag);
            if (!this.readonly) {
                this.draggable(drag);
            }
            return drag;
        };
        this.draggable = function (drag) {
            drag.on('click', function(e) {
                var dragging = instance.selected;
                if (dragging && !drag.hasClass('unplaced')) {
                    var position = $mmUtil.getElementXY(e.target, null, 'ddarea');
                    var img = instance.doc.bg_img();
                    var imgpos = $mmUtil.getElementXY(img, null, 'ddarea');
                    position[0] = position[0] - imgpos[0] + e.offsetX;
                    position[1] = position[1] - imgpos[1] + e.offsetY;
                    if (position[0] <= img.width && position[1] <= img.height) {
                        instance.deselect_drags();
                        instance.drop_drag(dragging, position);
                        e.preventDefault();
                        e.stopPropagation();
                        return;
                    }
                }
                if (drag.hasClass('beingdragged')) {
                    instance.deselect_drags();
                } else {
                    instance.select_drag(drag);
                }
                e.preventDefault();
                e.stopPropagation();
            });
        };
        this.make_image_dropable = function() {
            if (this.readonly) {
                return;
            }
            var bgimg = angular.element(this.doc.bg_img());
            bgimg.on('click', function(e) {
                var drag = instance.selected;
                if (!drag) {
                    return false;
                }
                var position = [e.offsetX, e.offsetY];
                instance.deselect_drags();
                instance.drop_drag(drag, position);
                e.preventDefault();
                e.stopPropagation();
            });
            var home = angular.element(this.doc.drag_itemsarea());
            home.on('click', function(e) {
                var drag = instance.selected;
                if (!drag) {
                    return false;
                }
                if (drag.hasClass('unplaced')) {
                    instance.deselect_drags();
                    return false;
                }
                instance.deselect_drags();
                instance.drop_drag(drag, null);
                e.preventDefault();
                e.stopPropagation();
            });
        };
        this.select_drag = function(drag) {
            this.deselect_drags();
            this.selected = drag;
            drag.addClass('beingdragged');
            var itemno = this.get_itemno_for_node(drag);
            if (itemno !== null) {
                drag.removeClass('item' + itemno);
            }
        };
        this.deselect_drags = function() {
            var drags = this.doc.drag_items();
            angular.element(drags).removeClass('beingdragged');
            this.selected = null;
        };
        this.drop_drag = function(drag, position) {
            var choiceno = this.get_choiceno_for_node(drag);
            if (position) {
                if (this.proportion < 1) {
                    position[0] = Math.round(position[0] / this.proportion);
                }
                if (this.proportion < 1) {
                    position[1] = Math.round(position[1] / this.proportion);
                }
            }
            this.save_all_xy_for_choice(choiceno, drag, position);
            this.redraw_drags_and_drops();
        };
        this.save_all_xy_for_choice = function (choiceno, dropped, position) {
            var coords = [];
            var bgimgxy;
            for (var i = 0; i < this.doc.drag_items_for_choice(choiceno).length; i++) {
                var dragitem = this.doc.drag_item_for_choice(choiceno, i);
                if (dragitem) {
                    var dragitemAng = angular.element(dragitem);
                    dragitemAng.removeClass('item' + i);
                    bgimgxy = this.get_drag_xy(dragitem);
                    dragitemAng.addClass('item' + coords.length);
                    coords.push(bgimgxy);
                }
            }
            if (position !== null){
                dropped.removeClass('unplaced');
                dropped.addClass('item' + coords.length);
                coords.push(position);
            } else {
                dropped.addClass('unplaced');
            }
            if (coords.length > 0) {
                this.set_form_value(choiceno, coords.join(';'));
            } else {
                this.reset_drag_xy(choiceno);
            }
        };
        this.get_drag_xy = function(dragitem) {
            var position = $mmUtil.getElementXY(dragitem, null, 'ddarea');
            var bgimg = this.doc.bg_img();
            var bgimgxy = $mmUtil.getElementXY(bgimg, null, 'ddarea');
            position[0] -= bgimgxy[0];
            position[1] -= bgimgxy[1];
            if (this.proportion < 1) {
                position[0] = Math.round(position[0] / this.proportion);
            }
            if (this.proportion < 1) {
                position[1] = Math.round(position[1] / this.proportion);
            }
            return position;
        };
        this.reset_drag_xy = function (choiceno) {
            this.set_form_value(choiceno, '');
        };
        this.set_form_value = function (choiceno, value) {
            this.doc.input_for_choice(choiceno).setAttribute('value', value);
        };
        this.calculate_img_proportion = function() {
            var bgimg = this.doc.bg_img();
            this.proportion = 1;
            if (bgimg.width != bgimg.naturalWidth) {
                this.proportion = bgimg.width / bgimg.naturalWidth;
            }
        };
        this.redraw_drags_and_drops = function() {
            var drags = this.doc.drag_items();
            angular.element(drags).addClass('unneeded');
            angular.element(drags).addClass('unplaced');
            this.calculate_img_proportion();
            var inputs = this.doc.inputs_for_choices();
            for (var x = 0; x < inputs.length; x++) {
                var input = angular.element(inputs[x]);
                var choiceno = this.get_choiceno_for_node(input);
                var coords = this.get_coords(input);
                var dragitemhome = this.doc.drag_item_home(choiceno);
                var homeposition = this.drag_home_xy(choiceno);
                for (var i = 0; i < coords.length; i++) {
                    var dragitem = this.doc.drag_item_for_choice(choiceno, i);
                    if (dragitem) {
                        dragitem = angular.element(dragitem);
                    }
                    if (!dragitem || dragitem.hasClass('beingdragged')) {
                        dragitem = this.clone_new_drag_item(dragitemhome, i);
                    } else {
                        dragitem.removeClass('unneeded');
                    }
                    if (homeposition[0] != coords[i][0] || homeposition[1] != coords[i][1]) {
                        dragitem.removeClass('unplaced');
                    }
                    dragitem.css('left', coords[i][0] + 'px').css('top', coords[i][1] + 'px');
                }
            }
            for (var y = 0; y < drags.length; y++) {
                var item = angular.element(drags[y]);
                if (item.hasClass('unneeded') && !item.hasClass('beingdragged')) {
                    item.remove(true);
                }
            }
            if (this.dropzones.length !== 0) {
                graphics.clear();
                this.restart_colours();
                for (var dropzoneno in this.dropzones) {
                    var colourfordropzone = this.get_next_colour();
                    var d = this.dropzones[dropzoneno];
                    this.draw_drop_zone(dropzoneno, d.markertext, d.shape, d.coords, colourfordropzone, true);
                }
            }
        };
                this.get_coords = function (input) {
            var choiceno = this.get_choiceno_for_node(input);
            var fv = input.attr('value');
            var infinite = input.hasClass('infinite');
            var noofdrags = this.get_noofdrags_for_node(input);
            var dragging = (null !== this.doc.drag_item_being_dragged(choiceno));
            var coords = [];
            if (fv !== '' && typeof fv != 'undefined') {
                var coordsstrings = fv.split(';');
                for (var i = 0; i < coordsstrings.length; i++) {
                    coords[coords.length] = this.convert_to_window_xy(coordsstrings[i].split(','));
                }
            }
            var displayeddrags = coords.length + (dragging ? 1 : 0);
            if (infinite || (displayeddrags < noofdrags)) {
                coords[coords.length] = this.drag_home_xy(choiceno);
            }
            return coords;
        };
        this.drag_home_xy = function (choiceno) {
            var dragitemhome = this.doc.drag_item_home(choiceno);
            var position = $mmUtil.getElementXY(dragitemhome, null, 'ddarea');
            return [position[0], position[1]];
        };
        this.get_choiceno_for_node = function(node) {
            return Number(this.doc.get_classname_numeric_suffix(node, 'choice'));
        };
        this.get_itemno_for_node = function(node) {
            return Number(this.doc.get_classname_numeric_suffix(node, 'item'));
        };
        this.get_noofdrags_for_node = function(node) {
            return Number(this.doc.get_classname_numeric_suffix(node, 'noofdrags'));
        };
        this.initializer(question);
    }
    self.init_question = function(question, readonly, dropzones) {
        var qi = new question_instance(question, readonly, dropzones);
        return qi;
    };
    return self;
}]);
angular.module('mm.addons.qtype_ddwtos')
.directive('mmaQtypeDdwtos', ["$log", "$mmQuestionHelper", "$mmaQtypeDdwtosRender", "$timeout", "$mmUtil", function($log, $mmQuestionHelper, $mmaQtypeDdwtosRender, $timeout, $mmUtil) {
	$log = $log.getInstance('mmaQtypeDdwtos');
    return {
        restrict: 'A',
        priority: 100,
        templateUrl: 'addons/qtype/ddwtos/template.html',
        link: function(scope) {
            var answersEl, questionEl,
                inputIds = [],
                question = scope.question;
            if (!question) {
                $log.warn('Aborting because of no question received.');
                return $mmQuestionHelper.showDirectiveError(scope);
            }
            questionEl = angular.element(question.html);
            questionEl = questionEl[0] || questionEl;
            $mmQuestionHelper.replaceCorrectnessClasses(questionEl);
            $mmQuestionHelper.replaceFeedbackClasses(questionEl);
            $mmQuestionHelper.treatCorrectnessIcons(scope, questionEl);
            answersEl = questionEl.querySelector('.answercontainer');
            if (!answersEl) {
                log.warn('Aborting because of an error parsing question.', question.name);
                return self.showDirectiveError(scope);
            }
            question.readonly = angular.element(answersEl).hasClass('readonly');
            question.answers = answersEl.outerHTML;
            question.text = $mmUtil.getContentsOfElement(questionEl, '.qtext');
            if (typeof question.text == 'undefined') {
                log.warn('Aborting because of an error parsing question.', question.name);
                return self.showDirectiveError(scope);
            }
            inputIdsEls = questionEl.querySelectorAll('input[type="hidden"]:not([name*=sequencecheck])');
            for (var x = 0; x < inputIdsEls.length; x++) {
                question.text += inputIdsEls[x].outerHTML;
                inputIds.push(inputIdsEls[x].getAttribute('id'));
            }
            $timeout(function() {
                var qi = $mmaQtypeDdwtosRender.init_question(question, question.readonly, inputIds);
                scope.$on('$destroy', function() {
                    qi.destroy();
                });
            });
        }
    };
}]);

angular.module('mm.addons.qtype_ddwtos')
.factory('$mmaQtypeDdwtosHandler', ["$mmQuestion", function($mmQuestion) {
    var self = {};
        self.isCompleteResponse = function(question, answers) {
        var isComplete = true;
        angular.forEach(answers, function(value) {
            if (!value || value === '0') {
                isComplete = false;
            }
        });
        return isComplete;
    };
        self.isEnabled = function() {
        return true;
    };
        self.isGradableResponse = function(question, answers) {
        var hasReponse = false;
        angular.forEach(answers, function(value) {
            if (value && value !== '0') {
                hasReponse = true;
            }
        });
        return hasReponse;
    };
        self.isSameResponse = function(question, prevAnswers, newAnswers) {
        return $mmQuestion.compareAllAnswers(prevAnswers, newAnswers);
    };
        self.getBehaviour = function(question, behaviour) {
        if (behaviour === 'interactive') {
            return 'interactivecountback';
        }
        return behaviour;
    };
        self.getDirectiveName = function(question) {
        return 'mma-qtype-ddwtos';
    };
    return self;
}]);

angular.module('mm.addons.qtype_ddwtos')
.factory('$mmaQtypeDdwtosRender', ["$mmUtil", "$timeout", function($mmUtil, $timeout) {
    var self = {};
    function question_instance(question, readonly, inputIds) {
        var instance = this;
        this.selectors = null;
        this.nextdragitemno = 1;
        this.placed = null;
        this.readonly = readonly;
        this.inputids = inputIds;
        this.selected = null;
        this.resizeFunction = function() {
            instance.position_drag_items();
        };
        this.destroy = function() {
            ionic.off('resize', this.resizeFunction, window);
        };
        this.initializer = function(question) {
            this.selectors = this.css_selectors(question.slot);
            var container = document.querySelector(this.selectors.top_node());
            container = angular.element(container);
            if (this.readonly) {
                container.addClass('readonly');
            } else {
                container.addClass('notreadonly');
            }
            this.set_padding_sizes_all();
            this.clone_drag_items();
            this.initial_place_of_drag_items();
            this.make_drop_zones();
            $timeout(function() {
                instance.position_drag_items();
            });
            ionic.on('resize', this.resizeFunction, window);
        };
                this.css_selectors = function(slot) {
            var topnode = "#mma-mod_quiz-question-" + slot + ' .mma-qtype-ddwtos-container';
            return {
                top_node : function() {
                    return topnode;
                },
                drag_container : function() {
                    return topnode + ' div.drags';
                },
                drags : function() {
                    return this.drag_container() + ' span.drag';
                },
                drag : function(no) {
                    return this.drags() + '.no' + no;
                },
                drags_in_group : function(groupno) {
                    return this.drags() + '.group' + groupno;
                },
                unplaced_drags_in_group : function(groupno) {
                    return this.drags_in_group(groupno) + '.unplaced';
                },
                drags_for_choice_in_group : function(choiceno, groupno) {
                    return this.drags_in_group(groupno) + '.choice' + choiceno;
                },
                unplaced_drags_for_choice_in_group : function(choiceno, groupno) {
                    return this.unplaced_drags_in_group(groupno) + '.choice' + choiceno;
                },
                drops : function() {
                    return topnode + ' span.drop';
                },
                drop_for_place : function(placeno) {
                    return this.drops() + '.place' + placeno;
                },
                drops_in_group : function(groupno) {
                    return this.drops() + '.group' + groupno;
                },
                drag_homes : function() {
                    return topnode + ' span.draghome';
                },
                drag_homes_group : function(groupno) {
                    return topnode + ' .draggrouphomes' + groupno + ' span.draghome';
                },
                drag_home : function(groupno, choiceno) {
                    return topnode + ' .draggrouphomes' + groupno + ' span.draghome.choice' + choiceno;
                },
                drops_group : function(groupno) {
                    return topnode + ' span.drop.group' + groupno;
                }
            };
        };
        this.set_padding_sizes_all = function() {
            for (var groupno = 1; groupno <= 8; groupno++) {
                this.set_padding_size_for_group(groupno);
            }
        };
        this.set_padding_size_for_group = function(groupno) {
            var groupItems = document.querySelectorAll(this.selectors.drag_homes_group(groupno));
            if (groupItems.length !== 0) {
                var maxwidth = 0;
                var maxheight = 0;
                angular.forEach(groupItems, function(item) {
                    maxwidth = Math.max(maxwidth, Math.ceil(item.offsetWidth));
                    maxheight = Math.max(maxheight, Math.ceil(item.offsetHeight));
                });
                maxwidth += 8;
                maxheight += 2;
                angular.forEach(groupItems, function(item) {
                    pad_to_width_height(item, maxwidth, maxheight);
                });
                var dropsGroup = document.querySelectorAll(this.selectors.drops_group(groupno));
                angular.forEach(dropsGroup, function(item) {
                    pad_to_width_height(item, maxwidth + 2, maxheight + 2);
                });
            }
        };
        function pad_to_width_height(node, width, height) {
            node.style.width = width + 'px';
            node.style.height = height + 'px';
            node.style.lineHeight = height + 'px';
        }
                this.clone_drag_items = function () {
            var dragHomes = document.querySelectorAll(this.selectors.drag_homes());
            for (var x = 0; x < dragHomes.length; x++) {
                this.clone_drag_items_for_one_choice(dragHomes[x]);
            }
        };
        this.clone_drag_items_for_one_choice = function(draghome) {
            draghome = angular.element(draghome);
            if (draghome.hasClass('infinite')) {
                var groupno = this.get_group(draghome);
                var noofdrags = document.querySelectorAll(this.selectors.drops_in_group(groupno)).length;
                for (var x = 0; x < noofdrags; x++) {
                    this.clone_drag_item(draghome);
                }
            } else {
                this.clone_drag_item(draghome);
            }
        };
        this.clone_drag_item = function(draghome) {
            var drag = draghome.clone(true);
            drag.removeClass('draghome');
            drag.addClass('drag');
            drag.addClass('no' + this.nextdragitemno);
            this.nextdragitemno++;
            drag.css('visibility', 'visible').css('position', 'absolute');
            var container = document.querySelector(this.selectors.drag_container());
            container = angular.element(container);
            container.append(drag);
            if (!this.readonly) {
                this.make_draggable(drag);
            }
        };
        this.get_classname_numeric_suffix = function(node, prefix) {
            node = angular.element(node);
            var classes = node.attr('class');
            if (classes !== '' && typeof classes !== 'undefined') {
                var classesarr = classes.split(' ');
                var patt1 = new RegExp('^' + prefix + '([0-9])+$');
                var patt2 = new RegExp('([0-9])+$');
                for (var index = 0; index < classesarr.length; index++) {
                    if (patt1.test(classesarr[index])) {
                        var match = patt2.exec(classesarr[index]);
                        return Number(match[0]);
                    }
                }
            }
            throw 'Prefix "' + prefix + '" not found in class names.';
        };
        this.get_choice = function(node) {
            return this.get_classname_numeric_suffix(node, 'choice');
        };
        this.get_group = function(node) {
            return this.get_classname_numeric_suffix(node, 'group');
        };
        this.get_place = function(node) {
            return this.get_classname_numeric_suffix(node, 'place');
        };
        this.get_no = function(node) {
            return this.get_classname_numeric_suffix(node, 'no');
        };
        this.initial_place_of_drag_items = function() {
            var inputid, inputnode, choiceno, drop, drag, groupno, placeno,
                drags = document.querySelectorAll(this.selectors.drags());
            drags = angular.element(drags);
            drags.addClass('unplaced');
            this.placed = [];
            for (placeno in this.inputids) {
                inputid = this.inputids[placeno];
                inputnode = document.querySelector('input#' + inputid);
                choiceno = Number(inputnode.getAttribute('value'));
                if (choiceno !== 0) {
                    drop = document.querySelector(this.selectors.drop_for_place(parseInt(placeno) + 1));
                    groupno = this.get_group(drop);
                    drag = document.querySelector(this.selectors.unplaced_drags_for_choice_in_group(choiceno, groupno));
                    this.place_drag_in_drop(drag, drop);
                    this.position_drag_item(drag);
                }
            }
        };
        this.make_draggable = function (drag) {
            drag.on('click', function() {
                if (drag.hasClass('selected')) {
                    instance.deselect_drags();
                } else {
                    instance.select_drag(drag);
                }
            });
        };
        this.select_drag = function(drag) {
            this.deselect_drags();
            drag = angular.element(drag);
            this.selected = drag;
            drag.addClass('selected');
        };
        this.deselect_drags = function() {
            var drags;
            drags = document.querySelectorAll(instance.selectors.drags());
            angular.element(drags).removeClass('selected');
            this.selected = null;
        };
        this.make_drop_zones = function () {
            if (this.readonly) {
                return;
            }
            var drops = document.querySelectorAll(this.selectors.drops());
            for (var x = 0; x < drops.length; x++) {
                this.make_drop_zone(drops[x]);
            }
            var home = document.querySelector(this.selectors.top_node() + ' .answercontainer');
            home = angular.element(home);
            home.on('click', function() {
                var drag = instance.selected;
                if (!drag) {
                    return false;
                }
                if (drag.hasClass('unplaced')) {
                    instance.deselect_drags();
                    return false;
                }
                instance.remove_drag_from_drop(drag);
                instance.deselect_drags();
                instance.position_drag_item(drag);
            });
        };
        this.make_drop_zone = function (drop) {
            drop = angular.element(drop);
            drop.on('click', function() {
                var drag = instance.selected;
                if (!drag) {
                    return false;
                }
                if (instance.get_group(drag) === instance.get_group(drop)) {
                    instance.place_drag_in_drop(drag, drop);
                    instance.deselect_drags();
                    instance.position_drag_item(drag);
                }
            });
        };
        this.place_drag_in_drop = function (drag, drop) {
            var placeno, inputid, inputnode;
            placeno = this.get_place(drop);
            inputid = this.inputids[placeno - 1];
            inputnode = document.querySelector('input#' + inputid);
            if (drag !== null) {
                inputnode.setAttribute('value', this.get_choice(drag));
            } else {
                inputnode.setAttribute('value', '0');
            }
            for (var alreadytheredragno in this.placed) {
                if (this.placed[alreadytheredragno] === placeno) {
                    delete this.placed[alreadytheredragno];
                }
            }
            if (drag !== null) {
                this.placed[this.get_no(drag)] = placeno;
            }
        };
        this.remove_drag_from_drop = function (drag) {
            var placeno = this.placed[this.get_no(drag)];
            var drop = document.querySelector(this.selectors.drop_for_place(placeno));
            this.place_drag_in_drop(null, drop);
        };
                this.position_drag_items = function () {
            var drags = document.querySelectorAll(this.selectors.drags());
            for (var x = 0; x < drags.length; x++) {
                this.position_drag_item(drags[x]);
            }
        };
        this.position_drag_item = function (drag) {
            var groupno, choiceno, position, placeno;
            dragAng = angular.element(drag);
            placeno = this.placed[this.get_no(drag)];
            if (!placeno) {
                groupno = this.get_group(drag);
                choiceno = this.get_choice(drag);
                position = $mmUtil.getElementXY(document, this.selectors.drag_home(groupno, choiceno), 'answercontainer');
                dragAng.addClass('unplaced');
            } else {
                position = $mmUtil.getElementXY(document, this.selectors.drop_for_place(placeno), 'mma-qtype-ddwtos-container');
                dragAng.removeClass('unplaced');
            }
            if (position) {
                dragAng.css('left', position[0] + 'px').css('top', position[1] + 'px');
            }
        };
        this.initializer(question);
    }
    self.init_question = function(question, readonly, inputIds) {
        var qi = new question_instance(question, readonly, inputIds);
        return qi;
    };
    return self;
}]);
angular.module('mm.addons.qtype_description')
.directive('mmaQtypeDescription', ["$log", "$mmQuestionHelper", function($log, $mmQuestionHelper) {
	$log = $log.getInstance('mmaQtypeDescription');
    return {
        restrict: 'A',
        priority: 100,
        templateUrl: 'addons/qtype/description/template.html',
        link: function(scope) {
            var questionEl = $mmQuestionHelper.directiveInit(scope, $log),
                input;
            if (questionEl) {
                input = questionEl[0].querySelector('input[type="hidden"][name*=seen]');
                if (input) {
                    scope.seenInput = {
                        name: input.name,
                        value: input.value
                    };
                }
            }
        }
    };
}]);

angular.module('mm.addons.qtype_description')
.factory('$mmaQtypeDescriptionHandler', function() {
    var self = {};
        self.isEnabled = function() {
        return true;
    };
        self.getBehaviour = function(question, behaviour) {
        return 'informationitem';
    };
        self.getDirectiveName = function(question) {
        return 'mma-qtype-description';
    };
        self.validateSequenceCheck = function(question, offlineSeqCheck) {
        return true;
    };
    return self;
});

angular.module('mm.addons.qtype_essay')
.directive('mmaQtypeEssay', ["$log", "$mmQuestionHelper", "$mmText", "$mmUtil", function($log, $mmQuestionHelper, $mmText, $mmUtil) {
	$log = $log.getInstance('mmaQtypeEssay');
    return {
        restrict: 'A',
        priority: 100,
        templateUrl: 'addons/qtype/essay/template.html',
        link: function(scope) {
            var questionEl = $mmQuestionHelper.directiveInit(scope, $log),
                textarea;
            if (questionEl) {
                questionEl = questionEl[0] || questionEl;
                textarea = questionEl.querySelector('textarea[name*=_answer]');
                scope.allowsAttachments = !!questionEl.querySelector('div[id*=filemanager]');
                scope.isMonospaced = !!questionEl.querySelector('.qtype_essay_monospaced');
                scope.isPlainText = scope.isMonospaced || !!questionEl.querySelector('.qtype_essay_plain');
                scope.hasDraftFiles = $mmQuestionHelper.hasDraftFileUrls(questionEl.innerHTML);
                if (!textarea) {
                    scope.answer = $mmUtil.getContentsOfElement(angular.element(questionEl), '.qtype_essay_response');
                    scope.attachments = $mmQuestionHelper.getQuestionAttachmentsFromHtml(
                                            $mmUtil.getContentsOfElement(angular.element(questionEl), '.attachments'));
                } else {
                    var input = questionEl.querySelector('input[type="hidden"][name*=answerformat]'),
                        content = textarea.innerHTML;
                    scope.textarea = {
                        id: textarea.id,
                        name: textarea.name,
                        text: content ? $mmText.decodeHTML(content) : ''
                    };
                    if (input) {
                        scope.formatInput = {
                            name: input.name,
                            value: input.value
                        };
                    }
                }
            }
        }
    };
}]);

angular.module('mm.addons.qtype_essay')
.factory('$mmaQtypeEssayHandler', ["$mmUtil", "$mmQuestionHelper", function($mmUtil, $mmQuestionHelper) {
    var self = {};
        self.getBehaviour = function(question, behaviour) {
        return 'manualgraded';
    };
        self.getPreventSubmitMessage = function(question) {
        var questionEl = angular.element(question.html)[0];
        if (questionEl.querySelector('div[id*=filemanager]')) {
            return 'mm.question.errorattachmentsnotsupported';
        }
        if ($mmQuestionHelper.hasDraftFileUrls(questionEl.innerHTML)) {
            return 'mm.question.errorinlinefilesnotsupported';
        }
    };
        self.isCompleteResponse = function(question, answers) {
        var hasInlineText = answers['answer'] && answers['answer'] !== '',
            questionEl = angular.element(question.html)[0],
            allowsAttachments = !!questionEl.querySelector('div[id*=filemanager]');
        if (!allowsAttachments) {
            return hasInlineText;
        }
        return -1;
    };
        self.isEnabled = function() {
        return true;
    };
        self.isGradableResponse = function(question, answers) {
        return false;
    };
        self.isSameResponse = function(question, prevAnswers, newAnswers) {
        return $mmUtil.sameAtKeyMissingIsBlank(prevAnswers, newAnswers, 'answer');
    };
        self.getDirectiveName = function(question) {
        return 'mma-qtype-essay';
    };
    return self;
}]);

angular.module('mm.addons.qtype_gapselect')
.directive('mmaQtypeGapSelect', ["$log", "$mmQuestionHelper", "$mmUtil", function($log, $mmQuestionHelper, $mmUtil) {
	$log = $log.getInstance('mmaQtypeGapSelect');
    return {
        restrict: 'A',
        priority: 100,
        templateUrl: 'addons/qtype/gapselect/template.html',
        link: function(scope) {
            var question = scope.question,
                questionEl,
                content;
            if (!question) {
                $log.warn('Aborting because of no question received.');
                return $mmQuestionHelper.showDirectiveError(scope);
            }
            questionEl = angular.element(question.html);
            content = questionEl[0].querySelector('.qtext');
            if (!content) {
                log.warn('Aborting because of an error parsing question.', question.name);
                return $mmQuestionHelper.showDirectiveError(scope);
            }
            $mmUtil.removeElement(content, 'input[name*=sequencecheck]');
            $mmUtil.removeElement(content, '.validationerror');
            $mmQuestionHelper.replaceCorrectnessClasses(questionEl);
            $mmQuestionHelper.treatCorrectnessIcons(scope, questionEl);
            question.text = content.innerHTML;
        }
    };
}]);

angular.module('mm.addons.qtype_gapselect')
.factory('$mmaQtypeGapSelectHandler', ["$mmQuestion", function($mmQuestion) {
    var self = {};
        self.isCompleteResponse = function(question, answers) {
        var isComplete = true;
        angular.forEach(answers, function(value) {
            if (!value || value === '0') {
                isComplete = false;
            }
        });
        return isComplete;
    };
        self.isEnabled = function() {
        return true;
    };
        self.isGradableResponse = function(question, answers) {
        var hasReponse = false;
        angular.forEach(answers, function(value) {
            if (value) {
                hasReponse = true;
            }
        });
        return hasReponse;
    };
        self.isSameResponse = function(question, prevAnswers, newAnswers) {
        return $mmQuestion.compareAllAnswers(prevAnswers, newAnswers);
    };
        self.getBehaviour = function(question, behaviour) {
        if (behaviour === 'interactive') {
            return 'interactivecountback';
        }
        return behaviour;
    };
        self.getDirectiveName = function(question) {
        return 'mma-qtype-gap-select';
    };
    return self;
}]);

angular.module('mm.addons.qtype_match')
.directive('mmaQtypeMatch', ["$log", "$mmQuestionHelper", function($log, $mmQuestionHelper) {
	$log = $log.getInstance('mmaQtypeMatch');
    return {
        restrict: 'A',
        priority: 100,
        templateUrl: 'addons/qtype/match/template.html',
        link: function(scope) {
            $mmQuestionHelper.matchingDirective(scope, $log);
        }
    };
}]);

angular.module('mm.addons.qtype_match')
.factory('$mmaQtypeMatchHandler', ["$mmQuestion", function($mmQuestion) {
    var self = {};
        self.isCompleteResponse = function(question, answers) {
        var isComplete = true;
        angular.forEach(answers, function(value) {
            if (!value || value === '0') {
                isComplete = false;
            }
        });
        return isComplete;
    };
        self.isEnabled = function() {
        return true;
    };
        self.isGradableResponse = function(question, answers) {
        var isGradable = false;
        angular.forEach(answers, function(value) {
            if (value && value !== '0') {
                isGradable = true;
            }
        });
        return isGradable;
    };
        self.isSameResponse = function(question, prevAnswers, newAnswers) {
        return $mmQuestion.compareAllAnswers(prevAnswers, newAnswers);
    };
        self.getBehaviour = function(question, behaviour) {
        if (behaviour === 'interactive') {
            return 'interactivecountback';
        }
        return behaviour;
    };
        self.getDirectiveName = function(question) {
        return 'mma-qtype-match';
    };
    return self;
}]);

angular.module('mm.addons.qtype_multianswer')
.directive('mmaQtypeMultianswer', ["$log", "$mmQuestionHelper", "$mmUtil", function($log, $mmQuestionHelper, $mmUtil) {
	$log = $log.getInstance('mmaQtypeMultianswer');
    return {
        restrict: 'A',
        priority: 100,
        templateUrl: 'addons/qtype/multianswer/template.html',
        link: function(scope) {
            var question = scope.question,
                questionEl,
                content;
            if (!question) {
                $log.warn('Aborting because of no question received.');
                return $mmQuestionHelper.showDirectiveError(scope);
            }
            questionEl = angular.element(question.html);
            content = questionEl[0].querySelector('.formulation');
            if (!content) {
                log.warn('Aborting because of an error parsing question.', question.name);
                return $mmQuestionHelper.showDirectiveError(scope);
            }
            $mmUtil.removeElement(content, 'input[name*=sequencecheck]');
            $mmUtil.removeElement(content, '.validationerror');
            $mmQuestionHelper.replaceCorrectnessClasses(questionEl);
            $mmQuestionHelper.replaceFeedbackClasses(questionEl);
            $mmQuestionHelper.treatCorrectnessIcons(scope, questionEl);
            question.text = content.innerHTML;
        }
    };
}]);

angular.module('mm.addons.qtype_multianswer')
.factory('$mmaQtypeMultianswerHandler', ["$mmQuestion", "$mmQuestionHelper", function($mmQuestion, $mmQuestionHelper) {
    var self = {};
        self.isCompleteResponse = function(question, answers) {
        var names = $mmQuestion.getBasicAnswers($mmQuestionHelper.getAllInputNamesFromHtml(question.html));
        for (var name in names) {
            if (!answers[name] && answers[name] !== false && answers[name] !== 0) {
                return false;
            }
        }
        return true;
    };
        self.isEnabled = function() {
        return true;
    };
        self.isGradableResponse = function(question, answers) {
        var hasReponse = false;
        angular.forEach(answers, function(value) {
            if (value || value === false) {
                hasReponse = true;
            }
        });
        return hasReponse;
    };
        self.isSameResponse = function(question, prevAnswers, newAnswers) {
        return $mmQuestion.compareAllAnswers(prevAnswers, newAnswers);
    };
        self.getBehaviour = function(question, behaviour) {
        if (behaviour === 'interactive') {
            return 'interactivecountback';
        }
        return behaviour;
    };
        self.getDirectiveName = function(question) {
        return 'mma-qtype-multianswer';
    };
        self.validateSequenceCheck = function(question, offlineSeqCheck) {
        if (question.sequencecheck == offlineSeqCheck) {
            return true;
        }
        if (question.sequencecheck == 2 && question.state == 'todo' && offlineSeqCheck == 1) {
            return true;
        }
        return false;
    };
    return self;
}]);

angular.module('mm.addons.qtype_multichoice')
.directive('mmaQtypeMultichoice', ["$log", "$mmQuestionHelper", function($log, $mmQuestionHelper) {
	$log = $log.getInstance('mmaQtypeMultichoice');
    return {
        restrict: 'A',
        priority: 100,
        templateUrl: 'addons/qtype/multichoice/template.html',
        link: function(scope) {
        	$mmQuestionHelper.multiChoiceDirective(scope, $log);
        }
    };
}]);

angular.module('mm.addons.qtype_multichoice')
.factory('$mmaQtypeMultichoiceHandler', ["$mmUtil", function($mmUtil) {
    var self = {};
        self.isCompleteResponse = function(question, answers) {
        var isSingle = true,
            isMultiComplete = false;
        angular.forEach(answers, function(value, name) {
            if (name.indexOf('choice') != -1) {
                isSingle = false;
                if (value) {
                    isMultiComplete = true;
                }
            }
        });
        if (isSingle) {
            return self.isCompleteResponseSingle(answers);
        } else {
            return isMultiComplete;
        }
    };
        self.isCompleteResponseSingle = function(answers) {
        return answers['answer'] && answers['answer'] !== '';
    };
        self.isEnabled = function() {
        return true;
    };
        self.isGradableResponse = function(question, answers) {
        return self.isCompleteResponse(question, answers);
    };
        self.isGradableResponseSingle = function(answers) {
        return self.isCompleteResponseSingle(answers);
    };
        self.isSameResponse = function(question, prevAnswers, newAnswers) {
        var isSingle = true,
            isMultiSame = true;
        angular.forEach(newAnswers, function(value, name) {
            if (name.indexOf('choice') != -1) {
                isSingle = false;
                if (!$mmUtil.sameAtKeyMissingIsBlank(prevAnswers, newAnswers, name)) {
                    isMultiSame = false;
                }
            }
        });
        if (isSingle) {
            return self.isSameResponseSingle(prevAnswers, newAnswers);
        } else {
            return isMultiSame;
        }
    };
        self.isSameResponseSingle = function(prevAnswers, newAnswers) {
        return $mmUtil.sameAtKeyMissingIsBlank(prevAnswers, newAnswers, 'answer');
    };
        self.getDirectiveName = function(question) {
        return 'mma-qtype-multichoice';
    };
    return self;
}]);

angular.module('mm.addons.qtype_numerical')
.directive('mmaQtypeNumerical', ["$log", "$mmQuestionHelper", function($log, $mmQuestionHelper) {
	$log = $log.getInstance('mmaQtypeNumerical');
    return {
        restrict: 'A',
        priority: 100,
        templateUrl: 'addons/qtype/shortanswer/template.html',
        link: function(scope) {
            $mmQuestionHelper.inputTextDirective(scope, $log);
        }
    };
}]);

angular.module('mm.addons.qtype_numerical')
.factory('$mmaQtypeNumericalHandler', ["$mmUtil", function($mmUtil) {
    var self = {};
        self.isCompleteResponse = function(question, answers) {
        if (!self.isGradableResponse(question, answers) || !self.validateUnits(answers['answer'])) {
            return false;
        }
        return -1;
    };
        self.isEnabled = function() {
        return true;
    };
        self.isGradableResponse = function(question, answers) {
        return answers['answer'] || answers['answer'] === '0' || answers['answer'] === 0;
    };
        self.isSameResponse = function(question, prevAnswers, newAnswers) {
        return $mmUtil.sameAtKeyMissingIsBlank(prevAnswers, newAnswers, 'answer');
    };
        self.getDirectiveName = function(question) {
        return 'mma-qtype-numerical';
    };
        self.validateUnits = function(answer) {
        if (!answer) {
            return false;
        }
        var regexString = '[+-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[-+]?\\d+)?';
        answer = answer.replace(' ', '');
        answer = answer.replace(/(?:e|E|(?:x|\*|×)10(?:\^|\*\*))([+-]?\d+)/, 'e$1');
        if (answer.indexOf('.') != -1 || answer.split(',').length - 1 > 1) {
            answer = answer.replace(',', '');
        } else {
            answer = answer.replace(',', '.');
        }
        if (answer.match(new RegExp('^' + regexString)) === null || answer.match(new RegExp(regexString + '$')) === null) {
            return false;
        }
        return true;
    };
    return self;
}]);

angular.module('mm.addons.qtype_randomsamatch')
.directive('mmaQtypeRandomSaMatch', ["$log", "$mmQuestionHelper", function($log, $mmQuestionHelper) {
	$log = $log.getInstance('mmaQtypeRandomSaMatch');
    return {
        restrict: 'A',
        priority: 100,
        templateUrl: 'addons/qtype/match/template.html',
        link: function(scope) {
            $mmQuestionHelper.matchingDirective(scope, $log);
        }
    };
}]);

angular.module('mm.addons.qtype_randomsamatch')
.factory('$mmaQtypeRandomSaMatchHandler', ["$mmaQtypeMatchHandler", function($mmaQtypeMatchHandler) {
    var self = {};
        self.isCompleteResponse = function(question, answers) {
        return $mmaQtypeMatchHandler.isCompleteResponse(question, answers);
    };
        self.isEnabled = function() {
        return true;
    };
        self.isGradableResponse = function(question, answers) {
        return $mmaQtypeMatchHandler.isGradableResponse(question, answers);
    };
        self.isSameResponse = function(question, prevAnswers, newAnswers) {
        return $mmaQtypeMatchHandler.isSameResponse(question, prevAnswers, newAnswers);
    };
        self.getDirectiveName = function(question) {
        return 'mma-qtype-random-sa-match';
    };
    return self;
}]);

angular.module('mm.addons.qtype_shortanswer')
.directive('mmaQtypeShortAnswer', ["$log", "$mmQuestionHelper", function($log, $mmQuestionHelper) {
	$log = $log.getInstance('mmaQtypeShortAnswer');
    return {
        restrict: 'A',
        priority: 100,
        templateUrl: 'addons/qtype/shortanswer/template.html',
        link: function(scope) {
            $mmQuestionHelper.inputTextDirective(scope, $log);
        }
    };
}]);

angular.module('mm.addons.qtype_shortanswer')
.factory('$mmaQtypeShortAnswerHandler', ["$mmUtil", function($mmUtil) {
    var self = {};
        self.isCompleteResponse = function(question, answers) {
        return answers['answer'] || answers['answer'] === 0;
    };
        self.isEnabled = function() {
        return true;
    };
        self.isGradableResponse = function(question, answers) {
        return self.isCompleteResponse(question, answers);
    };
        self.isSameResponse = function(question, prevAnswers, newAnswers) {
        return $mmUtil.sameAtKeyMissingIsBlank(prevAnswers, newAnswers, 'answer');
    };
        self.getDirectiveName = function(question) {
        return 'mma-qtype-short-answer';
    };
    return self;
}]);

angular.module('mm.addons.qtype_truefalse')
.directive('mmaQtypeTruefalse', ["$log", "$mmQuestionHelper", function($log, $mmQuestionHelper) {
	$log = $log.getInstance('mmaQtypeTruefalse');
    return {
        restrict: 'A',
        priority: 100,
        templateUrl: 'addons/qtype/multichoice/template.html',
        link: function(scope) {
        	$mmQuestionHelper.multiChoiceDirective(scope, $log);
        }
    };
}]);

angular.module('mm.addons.qtype_truefalse')
.factory('$mmaQtypeTruefalseHandler', ["$mmUtil", function($mmUtil) {
    var self = {};
        self.isCompleteResponse = function(question, answers) {
        return !!answers['answer'];
    };
        self.isEnabled = function() {
        return true;
    };
        self.isGradableResponse = function(question, answers) {
        return self.isCompleteResponse(question, answers);
    };
        self.isSameResponse = function(question, prevAnswers, newAnswers) {
        return $mmUtil.sameAtKeyMissingIsBlank(prevAnswers, newAnswers, 'answer');
    };
        self.getDirectiveName = function(question) {
        return 'mma-qtype-truefalse';
    };
    return self;
}]);

angular.module('mm.addons.userprofilefield_checkbox')
.directive('mmaUserProfileFieldCheckbox', ["$log", function($log) {
    $log = $log.getInstance('mmaUserProfileFieldCheckbox');
    return {
        restrict: 'A',
        priority: 100,
        templateUrl: 'addons/userprofilefield/checkbox/template.html',
        link: function(scope, element) {
            var field = scope.field;
            if (field && scope.edit && scope.model) {
                field.modelName = 'profile_field_' + field.shortname;
                if (typeof field.defaultdata != 'undefined' && typeof scope.model[field.modelName] == 'undefined') {
                    scope.model[field.modelName] = field.defaultdata && field.defaultdata !== '0' && field.defaultdata !== 'false';
                }
            }
        }
    };
}]);

angular.module('mm.addons.userprofilefield_checkbox')
.factory('$mmaUserProfileFieldCheckboxHandler', function() {
    var self = {};
        self.isEnabled = function() {
        return true;
    };
        self.getData = function(field, signup, registerAuth, model) {
        var name = 'profile_field_' + field.shortname;
        if (typeof model[name] != 'undefined') {
            return {
                type: 'checkbox',
                name: name,
                value: model[name] ? 1 : 0
            };
        }
    };
        self.getDirectiveName = function(field) {
        return 'mma-user-profile-field-checkbox';
    };
    return self;
});

angular.module('mm.addons.userprofilefield_datetime')
.directive('mmaUserProfileFieldDatetime', ["$log", function($log) {
    $log = $log.getInstance('mmaUserProfileFieldDatetime');
    return {
        restrict: 'A',
        priority: 100,
        templateUrl: 'addons/userprofilefield/datetime/template.html',
        link: function(scope, element) {
            var field = scope.field,
                year;
            if (field && scope.edit && scope.model) {
                scope.isIOS = ionic.Platform.isIOS();
                field.modelName = 'profile_field_' + field.shortname;
                field.hasTime = field.param3 && field.param3 !== '0' && field.param3 !== 'false';
                field.inputType = field.hasTime ? 'datetime-local' : 'date';
                if (field.param1) {
                    year = parseInt(field.param1, 10);
                    if (year) {
                        field.min = year + '-01-01' + (field.hasTime && !scope.isIOS ? 'T00:00:00' : '');
                    }
                }
                if (field.param2) {
                    year = parseInt(field.param2, 10);
                    if (year) {
                        field.max = year + '-12-31' + (field.hasTime&& !scope.isIOS ? 'T23:59:59' : '');
                    }
                }
            }
        }
    };
}]);

angular.module('mm.addons.userprofilefield_datetime')
.factory('$mmaUserProfileFieldDatetimeHandler', function() {
    var self = {};
        self.isEnabled = function() {
        return true;
    };
        self.getData = function(field, signup, registerAuth, model) {
        var hasTime = field.param3 && field.param3 !== '0' && field.param3 !== 'false',
            modelName = 'profile_field_' + field.shortname,
            date = angular.copy(model[modelName + '_date']),
            time;
        if (date) {
            if (hasTime && ionic.Platform.isIOS()) {
                time = model[modelName + '_time'];
                if (!time) {
                    return;
                }
                date.setHours(time.getHours());
                date.setMinutes(time.getMinutes());
            }
            return {
                type: 'datetime',
                name: 'profile_field_' + field.shortname,
                value: Math.round(date.getTime() / 1000)
            };
        }
    };
        self.getDirectiveName = function(field) {
        return 'mma-user-profile-field-datetime';
    };
    return self;
});

angular.module('mm.addons.userprofilefield_menu')
.directive('mmaUserProfileFieldMenu', ["$log", function($log) {
    $log = $log.getInstance('mmaUserProfileFieldMenu');
    return {
        restrict: 'A',
        priority: 100,
        templateUrl: 'addons/userprofilefield/menu/template.html',
        link: function(scope, element) {
            var field = scope.field;
            if (field && scope.edit && scope.model) {
                field.modelName = 'profile_field_' + field.shortname;
                if (field.param1) {
                    field.options = field.param1.split(/\r\n|\r|\n/g);
                } else {
                    field.options = [];
                }
                if (typeof field.defaultdata != 'undefined' && typeof scope.model[field.modelName] == 'undefined') {
                    scope.model[field.modelName] = field.defaultdata;
                }
            }
        }
    };
}]);

angular.module('mm.addons.userprofilefield_menu')
.factory('$mmaUserProfileFieldMenuHandler', function() {
    var self = {};
        self.isEnabled = function() {
        return true;
    };
        self.getData = function(field, signup, registerAuth, model) {
        var name = 'profile_field_' + field.shortname;
        if (model[name]) {
            return {
                type: 'menu',
                name: name,
                value: model[name]
            };
        }
    };
        self.getDirectiveName = function(field) {
        return 'mma-user-profile-field-menu';
    };
    return self;
});

angular.module('mm.addons.userprofilefield_text')
.directive('mmaUserProfileFieldText', ["$log", function($log) {
    $log = $log.getInstance('mmaUserProfileFieldText');
    return {
        restrict: 'A',
        priority: 100,
        templateUrl: 'addons/userprofilefield/text/template.html',
        link: function(scope, element) {
            var field = scope.field;
            if (field && scope.edit && scope.model) {
                field.modelName = 'profile_field_' + field.shortname;
                if (field.param2) {
                    field.maxlength = parseInt(field.param2, 10) || '';
                }
                field.inputType = field.param3 && field.param3 !== '0' && field.param3 !== 'false' ? 'password' : 'text';
                if (typeof field.defaultdata != 'undefined' && typeof scope.model[field.modelName] == 'undefined') {
                    scope.model[field.modelName] = field.defaultdata;
                }
            }
        }
    };
}]);

angular.module('mm.addons.userprofilefield_text')
.factory('$mmaUserProfileFieldTextHandler', ["$mmText", function($mmText) {
    var self = {};
        self.isEnabled = function() {
        return true;
    };
        self.getData = function(field, signup, registerAuth, model) {
        var name = 'profile_field_' + field.shortname;
        return {
            type: 'text',
            name: name,
            value: $mmText.cleanTags(model[name])
        };
    };
        self.getDirectiveName = function(field) {
        return 'mma-user-profile-field-text';
    };
    return self;
}]);

angular.module('mm.addons.userprofilefield_textarea')
.directive('mmaUserProfileFieldTextarea', ["$log", function($log) {
    $log = $log.getInstance('mmaUserProfileFieldTextarea');
    return {
        restrict: 'A',
        priority: 100,
        templateUrl: 'addons/userprofilefield/textarea/template.html',
        link: function(scope, element) {
            var field = scope.field;
            if (field && scope.edit && scope.model) {
                field.modelName = 'profile_field_' + field.shortname;
                scope.model[field.modelName] = {
                    format: 1
                };
                if (typeof field.defaultdata != 'undefined' && typeof scope.model[field.modelName].text == 'undefined') {
                    scope.model[field.modelName].text = field.defaultdata;
                }
            }
        }
    };
}]);

angular.module('mm.addons.userprofilefield_textarea')
.factory('$mmaUserProfileFieldTextareaHandler', ["$mmUtil", "$mmText", function($mmUtil, $mmText) {
    var self = {};
        self.isEnabled = function() {
        return true;
    };
        self.getData = function(field, signup, registerAuth, model) {
        var name = 'profile_field_' + field.shortname;
        if (model[name]) {
            return $mmUtil.isRichTextEditorEnabled().then(function(enabled) {
                var text = model[name].text || '';
                if (!enabled) {
                    text = $mmText.formatHtmlLines(text);
                }
                return {
                    type: 'textarea',
                    name: name,
                    value: JSON.stringify({
                        text: text,
                        format: model[name].format || 1
                    })
                };
            });
        }
    };
        self.getDirectiveName = function(field) {
        return 'mma-user-profile-field-textarea';
    };
    return self;
}]);

angular.module('mm.addons.remotestyles')
.factory('$mmaRemoteStyles', ["$log", "$q", "$mmSite", "$mmSitesManager", "$mmFilepool", "$http", "$mmFS", "mmaRemoteStylesComponent", "mmCoreNotDownloaded", "$mmUtil", "md5", "$mmText", function($log, $q, $mmSite, $mmSitesManager, $mmFilepool, $http, $mmFS, mmaRemoteStylesComponent,
            mmCoreNotDownloaded, $mmUtil, md5, $mmText) {
    $log = $log.getInstance('$mmaRemoteStyles');
    var self = {},
        remoteStylesEls = {};
        self.addSite = function(siteId) {
        if (!siteId || remoteStylesEls[siteId]) {
            return $q.when();
        }
        var el = angular.element('<style id="mobilecssurl-' + siteId + '" disabled="disabled"></style>');
        angular.element(document.head).append(el);
        remoteStylesEls[siteId] = {
            element: el,
            hash: ''
        };
        return self.load(siteId, true);
    };
        self.clear = function() {
        angular.element(document.querySelectorAll('style[id*=mobilecssurl]')).attr('disabled', true);
    };
        function downloadFileAndRemoveOld(siteId, url) {
        return $mmFilepool.getFileStateByUrl(siteId, url).then(function(state) {
            return state !== mmCoreNotDownloaded;
        }).catch(function() {
            return true;
        }).then(function(isDownloaded) {
            if (!isDownloaded) {
                return $mmFilepool.removeFilesByComponent(siteId, mmaRemoteStylesComponent, 1);
            }
        }).then(function() {
            return $mmFilepool.downloadUrl(siteId, url, false, mmaRemoteStylesComponent, 1);
        });
    }
        self.enable = function(siteId) {
        siteId = siteId || $mmSite.getId();
        if (remoteStylesEls[siteId]) {
            remoteStylesEls[siteId].element.attr('disabled', false);
        }
    };
        self.get = function(siteId) {
        var fileUrl;
        siteId = siteId || $mmSite.getId();
        if (!siteId) {
            return $q.reject();
        }
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var infos = site.getInfo();
            if (infos && infos.mobilecssurl) {
                fileUrl = infos.mobilecssurl;
                if ($mmFS.isAvailable()) {
                    return downloadFileAndRemoveOld(siteId, infos.mobilecssurl);
                } else {
                    return infos.mobilecssurl;
                }
            } else {
                if (infos.mobilecssurl === '') {
                    $mmFilepool.removeFilesByComponent(siteId, mmaRemoteStylesComponent, 1);
                }
                return $q.reject();
            }
        }).then(function(url) {
            $log.debug('Loading styles from: '+url);
            return $http.get(url);
        }).then(function(response) {
            if (typeof response.data == 'string') {
                return {file: fileUrl, styles: response.data};
            } else {
                return $q.reject();
            }
        });
    };
        self.load = function(siteId, disabled) {
        siteId = siteId || $mmSite.getId();
        disabled = !!disabled;
        $log.debug('Load site: ', siteId, disabled);
        if (siteId && remoteStylesEls[siteId]) {
            remoteStylesEls[siteId].element.attr('disabled', disabled);
            return self.get(siteId).then(function(data) {
                var hash = md5.createHash(data.styles);
                if (remoteStylesEls[siteId].hash !== hash) {
                    remoteStylesEls[siteId].element.html(data.styles);
                    remoteStylesEls[siteId].hash = hash;
                    if (disabled && remoteStylesEls[siteId].element.attr('disabled') == 'disabled') {
                        remoteStylesEls[siteId].element.attr('disabled', true);
                    }
                }
                treatCSSCode(siteId, data.file, data.styles);
            });
        }
        return $q.reject();
    };
        self._preloadCurrentSite = function() {
        return $mmSitesManager.getStoredCurrentSiteId().then(function(siteId) {
            return self.addSite(siteId);
        });
    };
        self._preloadSites = function() {
        return $mmSitesManager.getSitesIds().then(function(ids) {
            var promises = [];
            angular.forEach(ids, function(siteId) {
                promises.push(self.addSite(siteId));
            });
            return $q.all(promises);
        });
    };
        self.removeSite = function(siteId) {
        if (siteId && remoteStylesEls[siteId]) {
            remoteStylesEls[siteId].element.remove();
            delete remoteStylesEls[siteId];
        }
    };
        function treatCSSCode(siteId, fileUrl, cssCode) {
        if (!$mmFS.isAvailable()) {
            return $q.reject();
        }
        var urls = $mmUtil.extractUrlsFromCSS(cssCode),
            promises = [],
            filePath,
            updated = false;
        promises.push($mmFilepool.getFilePathByUrl(siteId, fileUrl).then(function(path) {
            filePath = path;
        }));
        angular.forEach(urls, function(url) {
            if (url.indexOf('http') == 0) {
                promises.push($mmFilepool.downloadUrl(siteId, url, false, mmaRemoteStylesComponent, 2).then(function(fileUrl) {
                    if (fileUrl != url) {
                        cssCode = cssCode.replace(new RegExp($mmText.escapeForRegex(url), 'g'), fileUrl);
                        updated = true;
                    }
                }).catch(function(error) {
                    $log.warn('MMRMSTYLES Error treating file ', url, error);
                }));
            }
        });
        return $q.all(promises).then(function() {
            if (updated) {
                return $mmFS.writeFile(filePath, cssCode);
            }
        }).then(function() {
            return cssCode;
        });
    }
    return self;
}]);

angular.module('mm.addons.competency')
.controller('mmaCompetenciesListCtrl', ["$scope", "$mmaCompetency", "$mmUtil", "$stateParams", "$state", "$ionicPlatform", "$q", "$translate", "$mmaCompetencyHelper", function($scope, $mmaCompetency, $mmUtil, $stateParams, $state, $ionicPlatform, $q,
    $translate, $mmaCompetencyHelper) {
    var planId = parseInt($stateParams.pid) || false,
        courseId = parseInt($stateParams.cid) || false,
        competencyId = parseInt($stateParams.compid);
    $scope.userId = parseInt($stateParams.uid) || false;
    function fetchCompetencies() {
        var promise;
        if (planId) {
            promise = $mmaCompetency.getLearningPlan(planId);
        } else if (courseId){
            promise = $mmaCompetency.getCourseCompetencies(courseId);
        } else {
            promise = $q.reject();
        }
        return promise.then(function(response) {
            if (response.competencycount <= 0) {
                return $q.reject($translate.instant('mma.competency.errornocompetenciesfound'));
            }
            if (planId) {
                $scope.title = response.plan.name;
                $scope.id = response.plan.id;
                $scope.idname = 'planid';
                $scope.userId = response.plan.userid;
            } else {
                $scope.title = $translate.instant('mma.competency.coursecompetencies');
                $scope.id = response.courseid;
                $scope.idname = 'courseid';
            }
            $scope.competencies = response.competencies;
        }).catch(function(message) {
            if (message) {
                $mmUtil.showErrorModal(message);
            } else {
                $mmUtil.showErrorModal('Error getting competencies data.');
            }
            return $q.reject();
        });
    }
    $scope.gotoCompetency = function(competencyId) {
        if (planId) {
            $state.go('site.competency', {planid: planId, competencyid: competencyId});
        } else {
            $state.go('site.competency', {courseid: courseId, competencyid: competencyId, userid: $scope.userId});
        }
    };
    function refreshAllData() {
        var promise;
        if (planId) {
            promise = $mmaCompetency.invalidateLearningPlan(planId);
        } else {
            promise = $mmaCompetency.invalidateCourseCompetencies(courseId);
        }
        return promise.finally(function() {
            return fetchCompetencies();
        });
    }
    function autoloadCompetency() {
        if (competencyId) {
            if ($ionicPlatform.isTablet()) {
                angular.forEach($scope.competencies, function(competency, index) {
                    if (competency.competency.id == competencyId) {
                        $scope.competencyToLoad = index + 1;
                    }
                });
            } else {
                $scope.gotoCompetency(competencyId);
            }
        }
    }
    fetchCompetencies().finally(function() {
        autoloadCompetency();
        $scope.competenciesLoaded = true;
    });
    $scope.refreshCompetencies = function() {
        refreshAllData().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
}]);

angular.module('mm.addons.competency')
.controller('mmaCompetencyCtrl', ["$scope", "$stateParams", "$mmaCompetency", "$mmUtil", "$translate", "$q", "$mmSite", "mmaCompetencyReviewStatusIdle", "mmaCompetencyReviewStatusInReview", "mmaCompetencyReviewStatusWaitingForReview", function($scope, $stateParams, $mmaCompetency, $mmUtil, $translate, $q, $mmSite,
    mmaCompetencyReviewStatusIdle, mmaCompetencyReviewStatusInReview, mmaCompetencyReviewStatusWaitingForReview) {
    var competencyId = parseInt($stateParams.competencyid),
        planId = parseInt($stateParams.planid) || false,
        courseId = parseInt($stateParams.courseid) || false,
        userId = parseInt($stateParams.userid) || false,
        planStatus = false;
    function fetchCompetency() {
        if (planId) {
            planStatus = false;
            promise = $mmaCompetency.getCompetencyInPlan(planId, competencyId);
        } else if (courseId){
            promise = $mmaCompetency.getCompetencyInCourse(courseId, competencyId, userId);
        } else {
            promise = $q.reject();
        }
        return promise.then(function(competency) {
            if (planId) {
                planStatus = competency.plan.status;
                competency.usercompetencysummary.usercompetency.statusname = getStatusName(competency.usercompetencysummary.usercompetency.status);
            } else {
                competency.usercompetencysummary.usercompetency = competency.usercompetencysummary.usercompetencycourse;
                $scope.coursemodules = competency.coursemodules;
            }
            if (competency.usercompetencysummary.user.id != $mmSite.getUserId()) {
                competency.usercompetencysummary.user.profileimageurl = competency.usercompetencysummary.user.profileimageurl
                    || true;
                $scope.user = competency.usercompetencysummary.user;
            }
            angular.forEach(competency.usercompetencysummary.evidence, function(evidence) {
                if (evidence.descidentifier) {
                    evidence.description = $translate.instant('mma.competency.' + evidence.descidentifier, {a: evidence.desca});
                }
            });
            $scope.competency = competency.usercompetencysummary;
        }, function(message) {
            if (message) {
                $mmUtil.showErrorModal(message);
            } else {
                $mmUtil.showErrorModal('Error getting competency data.');
            }
            return $q.reject();
        });
    }
    function getStatusName(status) {
        var statusTranslateName;
        switch (status) {
            case mmaCompetencyReviewStatusIdle:
                statusTranslateName = 'idle';
                break;
            case mmaCompetencyReviewStatusInReview:
                statusTranslateName = 'inreview';
                break;
            case mmaCompetencyReviewStatusWaitingForReview:
                statusTranslateName = 'waitingforreview';
                break;
            default:
                return status;
        }
        return $translate.instant('mma.competency.usercompetencystatus_' + statusTranslateName);
    }
    function refreshAllData() {
        var promise;
        if (planId) {
            promise =  $mmaCompetency.invalidateCompetencyInPlan(planId, competencyId);
        } else {
            promise = $mmaCompetency.invalidateCompetencyInCourse(courseId, competencyId);
        }
        return promise.finally(function() {
            return fetchCompetency();
        });
    }
    fetchCompetency().then(function() {
        if (planId) {
            $mmaCompetency.logCompetencyInPlanView(planId, competencyId, planStatus, userId);
        } else {
            $mmaCompetency.logCompetencyInCourseView(courseId, competencyId, userId);
        }
    }).finally(function() {
        $scope.competencyLoaded = true;
    });
    $scope.refreshCompetency = function() {
        refreshAllData().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
}]);

angular.module('mm.addons.competency')
.controller('mmaCompetencySummaryCtrl', ["$scope", "$stateParams", "$mmaCompetency", "$mmUtil", "$q", function($scope, $stateParams, $mmaCompetency, $mmUtil, $q) {
    var competencyId = parseInt($stateParams.competencyid);
    function fetchCompetency() {
        return $mmaCompetency.getCompetencySummary(competencyId).then(function(competency) {
            $scope.competency = competency;
        }, function(message) {
            if (message) {
                $mmUtil.showErrorModal(message);
            } else {
                $mmUtil.showErrorModal('Error getting competency summary data.');
            }
            return $q.reject();
        });
    }
    function refreshAllData() {
        return $mmaCompetency.invalidateCompetencySummary(competencyId).finally(function() {
            return fetchCompetency();
        });
    }
    fetchCompetency().then(function() {
        $mmaCompetency.logCompetencyView(competencyId);
    }).finally(function() {
        $scope.competencyLoaded = true;
    });
    $scope.refreshCompetency = function() {
        refreshAllData().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
}]);

angular.module('mm.addons.competency')
.controller('mmaCourseCompetenciesCtrl', ["$scope", "$stateParams", "$mmaCompetency", "$mmUtil", "$state", "$ionicPlatform", "$q", "$mmaCompetencyHelper", function($scope, $stateParams, $mmaCompetency, $mmUtil, $state, $ionicPlatform, $q,
    $mmaCompetencyHelper) {
    var courseId = parseInt($stateParams.courseid);
        userId = parseInt($stateParams.userid) || false;
    function fetchCourseCompetencies() {
        return $mmaCompetency.getCourseCompetencies(courseId).then(function(competencies) {
            $scope.competencies = competencies;
            $mmaCompetencyHelper.getProfile(userId).then(function(user) {
                $scope.user = user;
            });
        }, function(message) {
            if (message) {
                $mmUtil.showErrorModal(message);
            } else {
                $mmUtil.showErrorModal('Error getting course competencies data.');
            }
            return $q.reject();
        });
    }
    $scope.gotoCompetency = function(competencyId) {
        if ($ionicPlatform.isTablet()) {
            $state.go('site.competencies', {cid: courseId, compid: competencyId, uid: userId});
        } else {
            $state.go('site.competency', {courseid: courseId, competencyid: competencyId, userid: userId});
        }
    };
    function refreshAllData() {
        return $mmaCompetency.invalidateCourseCompetencies(courseId).finally(function() {
            return fetchCourseCompetencies();
        });
    }
    fetchCourseCompetencies().finally(function() {
        $scope.competenciesLoaded = true;
    });
    $scope.refreshCourseCompetencies = function() {
        refreshAllData().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
}]);

angular.module('mm.addons.competency')
.controller('mmaLearningPlanCtrl', ["$scope", "$stateParams", "$mmaCompetency", "$mmUtil", "$translate", "mmaCompetencyStatusDraft", "mmaCompetencyStatusActive", "mmaCompetencyStatusComplete", "mmaCompetencyStatusWaitingForReview", "mmaCompetencyStatusInReview", "$state", "$ionicPlatform", "$q", "$mmaCompetencyHelper", function($scope, $stateParams, $mmaCompetency, $mmUtil, $translate,
    mmaCompetencyStatusDraft, mmaCompetencyStatusActive, mmaCompetencyStatusComplete, mmaCompetencyStatusWaitingForReview,
    mmaCompetencyStatusInReview, $state, $ionicPlatform, $q, $mmaCompetencyHelper) {
    var planId = parseInt($stateParams.id);
    function fetchLearningPlan() {
        return $mmaCompetency.getLearningPlan(planId).then(function(plan) {
            var statusName, userId;
            plan.plan.statusname = getStatusName(plan.plan.status);
            userId = plan.plan.userid;
            $mmaCompetencyHelper.getProfile(userId).then(function(user) {
                $scope.user = user;
            });
            $scope.plan = plan;
        }, function(message) {
            if (message) {
                $mmUtil.showErrorModal(message);
            } else {
                $mmUtil.showErrorModal('Error getting learning plan data.');
            }
            return $q.reject();
        });
    }
    $scope.gotoCompetency = function(competencyId) {
        if ($ionicPlatform.isTablet()) {
            $state.go('site.competencies', {pid: planId, compid: competencyId});
        } else {
            $state.go('site.competency', {planid: planId, competencyid: competencyId});
        }
    };
    function getStatusName(status) {
        var statusTranslateName;
        switch (status) {
            case mmaCompetencyStatusDraft:
                statusTranslateName = 'draft';
                break;
            case mmaCompetencyStatusInReview:
                statusTranslateName = 'inreview';
                break;
            case mmaCompetencyStatusWaitingForReview:
                statusTranslateName = 'waitingforreview';
                break;
            case mmaCompetencyStatusActive:
                statusTranslateName = 'active';
                break;
            case mmaCompetencyStatusComplete:
                statusTranslateName = 'complete';
                break;
            default:
                return status;
        }
        return $translate.instant('mma.competency.planstatus' + statusTranslateName);
    }
    function refreshAllData() {
        return $mmaCompetency.invalidateLearningPlan(planId).finally(function() {
            return fetchLearningPlan();
        });
    }
    fetchLearningPlan().finally(function() {
        $scope.planLoaded = true;
    });
    $scope.refreshLearningPlan = function() {
        refreshAllData().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
}]);

angular.module('mm.addons.competency')
.controller('mmaLearningPlansListCtrl', ["$scope", "$mmaCompetency", "$mmUtil", "$q", "$stateParams", "$mmaCompetencyHelper", function($scope, $mmaCompetency, $mmUtil, $q, $stateParams, $mmaCompetencyHelper) {
    var userId = parseInt($stateParams.userid) || false;
    function fetchLearningPlans() {
        return $mmaCompetency.getLearningPlans(userId).then(function(plans) {
            $scope.plans = plans;
        }).catch(function(message) {
            if (message) {
                $mmUtil.showErrorModal(message);
            } else {
                $mmUtil.showErrorModal('Error getting learning plans data.');
            }
            return $q.reject();
        });
    }
    function refreshAllData() {
        return $mmaCompetency.invalidateLearningPlans(userId).finally(function() {
            return fetchLearningPlans();
        });
    }
    fetchLearningPlans().finally(function() {
        $scope.plansLoaded = true;
    });
    $scope.refreshLearningPlans = function() {
        refreshAllData().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
}]);

angular.module('mm.addons.competency')
.factory('$mmaCompetency', ["$log", "$mmSite", "$mmSitesManager", "$q", "mmaCompetencyStatusComplete", function($log, $mmSite, $mmSitesManager, $q, mmaCompetencyStatusComplete) {
    $log = $log.getInstance('$mmaCompetency');
    var self = {};
        function getLearningPlansCacheKey(userId) {
        return 'mmaCompetency:userplans:' + userId;
    }
        function getLearningPlanCacheKey(planId) {
        return 'mmaCompetency:learningplan:' + planId;
    }
        function getCompetencyInPlanCacheKey(planId, competencyId) {
        return 'mmaCompetency:plancompetency:' + planId + ':' + competencyId;
    }
        function getCompetencyInCourseCacheKey(courseId, competencyId, userId) {
        return 'mmaCompetency:coursecompetency:' + userId + ':' + courseId + ':' + competencyId;
    }
        function getCompetencySummaryCacheKey(competencyId, userId) {
        return 'mmaCompetency:competencysummary:' + userId + ':' + competencyId;
    }
        function getCourseCompetenciesCacheKey(courseId) {
        return 'mmaCompetency:coursecompetencies:' + courseId;
    }
        self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            if (site.wsAvailable('core_competency_list_course_competencies') && site.wsAvailable('tool_lp_data_for_plans_page')) {
                return self.getLearningPlans(false, siteId);
            }
            return false;
        });
    };
        self.isPluginForCourseEnabled = function(courseId, siteId) {
        if (!$mmSite.isLoggedIn()) {
            return $q.when(false);
        }
        if (!self.isPluginEnabled(siteId)) {
            return $q.when(false);
        }
        return self.getCourseCompetencies(courseId, siteId).catch(function() {
            return false;
        });
    };
        self.getLearningPlans = function(userId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            $log.debug('Get plans for user ' + userId);
            var params = {
                    userid: userId
                },
                preSets = {
                    cacheKey: getLearningPlansCacheKey(userId)
                };
            return site.read('tool_lp_data_for_plans_page', params, preSets).then(function(response) {
                if (response.plans) {
                    return response.plans;
                }
                return $q.reject();
            });
        });
    };
        self.getLearningPlan = function(planId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            $log.debug('Get plan ' + planId);
            var params = {
                    planid: planId
                },
                preSets = {
                    cacheKey: getLearningPlanCacheKey(planId)
                };
            return site.read('tool_lp_data_for_plan_page', params, preSets).then(function(response) {
                if (response.plan) {
                    return response;
                }
                return $q.reject();
            });
        });
    };
        self.getCompetencyInPlan = function(planId, competencyId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            $log.debug('Get competency ' + competencyId + ' in plan ' + planId);
            var params = {
                    planid: planId,
                    competencyid: competencyId
                },
                preSets = {
                    cacheKey: getCompetencyInPlanCacheKey(planId, competencyId)
                };
            return site.read('tool_lp_data_for_user_competency_summary_in_plan', params, preSets).then(function(response) {
                if (response.usercompetencysummary) {
                    return response;
                }
                return $q.reject();
            });
        });
    };
        self.getCompetencyInCourse = function(courseId, competencyId, userId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            $log.debug('Get competency ' + competencyId + ' in course ' + courseId);
            var params = {
                    courseid: courseId,
                    competencyid: competencyId,
                    userid: userId
                },
                preSets = {
                    cacheKey: getCompetencyInCourseCacheKey(courseId, competencyId, userId)
                };
            return site.read('tool_lp_data_for_user_competency_summary_in_course', params, preSets).then(function(response) {
                if (response.usercompetencysummary) {
                    return response;
                }
                return $q.reject();
            });
        });
    };
        self.getCompetencySummary = function(competencyId, userId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            $log.debug('Get competency ' + competencyId + ' summary for user' + userId);
            var params = {
                    competencyid: competencyId,
                    userid: userId
                },
                preSets = {
                    cacheKey: getCompetencySummaryCacheKey(competencyId, userId)
                };
            return site.read('tool_lp_data_for_user_competency_summary', params, preSets).then(function(response) {
                if (response.competency) {
                    return response.competency;
                }
                return $q.reject();
            });
        });
    };
        self.getCourseCompetencies = function(courseId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            $log.debug('Get course competencies for course ' + courseId);
            var params = {
                    courseid: courseId
                },
                preSets = {
                    cacheKey: getCourseCompetenciesCacheKey(courseId)
                };
            return site.read('tool_lp_data_for_course_competencies_page', params, preSets).then(function(response) {
                if (response.competencies) {
                    return response;
                }
                return $q.reject();
            });
        });
    };
        self.invalidateLearningPlans = function(userId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(getLearningPlansCacheKey(userId));
        });
    };
        self.invalidateLearningPlan = function(planId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getLearningPlanCacheKey(planId));
        });
    };
        self.invalidateCompetencyInPlan = function(planId, competencyId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getCompetencyInPlanCacheKey(planId, competencyId));
        });
    };
        self.invalidateCompetencyInCourse = function(courseId, competencyId, userId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(getCompetencyInCourseCacheKey(courseId, competencyId, userId));
        });
    };
        self.invalidateCompetencySummary = function(competencyId, userId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(getCompetencySummaryCacheKey(competencyId, userId));
        });
    };
        self.invalidateCourseCompetencies = function(courseId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getCourseCompetenciesCacheKey(courseId));
        });
    };
        self.logCompetencyInPlanView = function(planId, competencyId, planStatus, userId, siteId) {
        if (planId && competencyId) {
            siteId = siteId || $mmSite.getId();
            return $mmSitesManager.getSite(siteId).then(function(site) {
                userId = userId || site.getUserId();
                var params = {
                    planid: planId,
                    competencyid: competencyId,
                    userid: userId
                };
                if (planStatus == mmaCompetencyStatusComplete) {
                    return site.write('core_competency_user_competency_plan_viewed', params);
                } else {
                    return site.write('core_competency_user_competency_viewed_in_plan', params);
                }
            });
        }
        return $q.reject();
    };
        self.logCompetencyInCourseView = function(courseId, competencyId, userId, siteId) {
        if (courseId && competencyId) {
            siteId = siteId || $mmSite.getId();
            return $mmSitesManager.getSite(siteId).then(function(site) {
                userId = userId || site.getUserId();
                var params = {
                    courseid: courseId,
                    competencyid: competencyId,
                    userid: userId
                };
                return site.write('core_competency_user_competency_viewed_in_course', params);
            });
        }
        return $q.reject();
    };
        self.logCompetencyView = function(competencyId, siteId) {
        if (competencyId) {
            siteId = siteId || $mmSite.getId();
            return $mmSitesManager.getSite(siteId).then(function(site) {
                var params = {
                    id: competencyId,
                };
                return site.write('core_competency_competency_viewed', params);
            });
        }
        return $q.reject();
    };
    return self;
}]);

angular.module('mm.addons.competency')
.factory('$mmaCompetencyHandlers', ["$log", "$mmaCompetency", "mmCoursesAccessMethods", "mmUserProfileHandlersTypeNewPage", function($log, $mmaCompetency, mmCoursesAccessMethods, mmUserProfileHandlersTypeNewPage) {
    $log = $log.getInstance('$mmaCompetencyHandlers');
    var self = {},
        coursesNavEnabledCache = {},
        participantsNavEnabledCache = {},
        usersNavEnabledCache = {};
        self.clearCoursesNavCache = function() {
        coursesNavEnabledCache = {};
    };
        self.clearUsersNavCache = function() {
        participantsNavEnabledCache = {};
        usersNavEnabledCache = {};
    };
        self.sideMenuNav = function() {
        var self = {};
                self.isEnabled = function(siteId) {
            return $mmaCompetency.isPluginEnabled(siteId).then(function(enabled) {
                if (!enabled) {
                    return false;
                }
                return $mmaCompetency.getLearningPlans(false, siteId).then(function(plans) {
                    return plans.length > 0;
                });
            });
        };
                self.getController = function() {
                        return function($scope) {
                $scope.icon = 'ion-map';
                $scope.title = 'mma.competency.myplans';
                $scope.state = 'site.learningplans';
                $scope.class = 'mma-competency-handler';
            };
        };
        return self;
    };
        self.coursesNav = function() {
        var self = {};
                self.isEnabled = function() {
            return $mmaCompetency.isPluginEnabled();
        };
                self.isEnabledForCourse = function(courseId, accessData, navOptions, admOptions) {
            if (accessData && accessData.type == mmCoursesAccessMethods.guest) {
                return false;
            }
            if (navOptions && typeof navOptions.competencies != 'undefined') {
                return navOptions.competencies;
            }
            if (typeof coursesNavEnabledCache[courseId] != 'undefined') {
                return coursesNavEnabledCache[courseId];
            }
            return $mmaCompetency.isPluginForCourseEnabled(courseId).then(function(competencies) {
                var enabled = competencies ? !competencies.canmanagecoursecompetencies : false;
                participantsNavEnabledCache[courseId] = !!competencies;
                coursesNavEnabledCache[courseId] = enabled;
                return enabled;
            });
        };
                self.getController = function(courseId) {
                        return function($scope, $state) {
                $scope.icon = 'ion-ribbon-a';
                $scope.title = 'mma.competency.competencies';
                $scope.class = 'mma-competency-handler';
                $scope.action = function($event, course) {
                    $event.preventDefault();
                    $event.stopPropagation();
                    $state.go('site.coursecompetencies', {
                        courseid: course.id
                    });
                };
            };
        };
        return self;
    };
        self.learningPlan = function() {
        var self = {
            type: mmUserProfileHandlersTypeNewPage
        };
                self.isEnabled = function() {
            return $mmaCompetency.isPluginEnabled();
        };
                self.isEnabledForUser = function(user, courseId, navOptions, admOptions) {
            if (courseId) {
                if (typeof participantsNavEnabledCache[courseId] != 'undefined') {
                    return participantsNavEnabledCache[courseId];
                }
                return $mmaCompetency.isPluginForCourseEnabled(courseId).then(function(competencies) {
                    var enabled = !!competencies;
                    coursesNavEnabledCache[courseId] = competencies ? !competencies.canmanagecoursecompetencies : false;
                    participantsNavEnabledCache[courseId] = enabled;
                    return enabled;
                });
            } else {
                if (typeof usersNavEnabledCache[user.id] != 'undefined') {
                    return usersNavEnabledCache[user.id];
                }
                return $mmaCompetency.getLearningPlans(user.id).then(function(plans) {
                    var enabled = plans.length > 0;
                    usersNavEnabledCache[user.id] = enabled;
                    return enabled;
                });
            }
        };
                self.getController = function(user, courseId) {
                        return function($scope, $state) {
                $scope.class = 'mma-competency-handler';
                if (courseId) {
                    $scope.icon = 'ion-ribbon-a';
                    $scope.title = 'mma.competency.competencies';
                    $scope.action = function($event) {
                        $event.preventDefault();
                        $event.stopPropagation();
                        $state.go('site.coursecompetencies', {
                            courseid: courseId,
                            userid: user.id
                        });
                    };
                } else {
                    $scope.icon = 'ion-map';
                    $scope.title = 'mma.competency.learningplans';
                    $scope.action = function($event) {
                        $event.preventDefault();
                        $event.stopPropagation();
                        $state.go('site.learningplans', {
                            userid: user.id
                        });
                    };
                }
            };
        };
        return self;
    };
    return self;
}])
.run(["$mmaCompetencyHandlers", "$mmEvents", "mmCoreEventLogout", "mmCoursesEventMyCoursesRefreshed", "mmUserEventProfileRefreshed", function($mmaCompetencyHandlers, $mmEvents, mmCoreEventLogout, mmCoursesEventMyCoursesRefreshed, mmUserEventProfileRefreshed) {
    $mmEvents.on(mmCoreEventLogout, function() {
        $mmaCompetencyHandlers.clearCoursesNavCache();
        $mmaCompetencyHandlers.clearUsersNavCache();
    });
    $mmEvents.on(mmCoursesEventMyCoursesRefreshed, $mmaCompetencyHandlers.clearCoursesNavCache);
    $mmEvents.on(mmUserEventProfileRefreshed, $mmaCompetencyHandlers.clearUsersNavCache);
}]);

angular.module('mm.addons.competency')
.factory('$mmaCompetencyHelper', ["$mmUser", "$mmSite", "$log", "$q", function($mmUser, $mmSite, $log, $q) {
    $log = $log.getInstance('$mmaCompetencyHelper');
    var self = {};
        self.getProfile = function(userId) {
        if (!userId || userId == $mmSite.getUserId()) {
            return $q.when(false);
        }
        return $mmUser.getProfile(userId, undefined, true).then(function(user) {
            user.profileimageurl = user.profileimageurl || true;
            return user;
        });
    };
    return self;
}]);

angular.module('mm.addons.notes')
.controller('mmaNotesListCtrl', ["$scope", "$stateParams", "$mmUtil", "$mmaNotes", "$mmSite", "$translate", "$mmEvents", "$mmaNotesSync", "$q", "$mmText", "$ionicScrollDelegate", "mmaNotesAutomSyncedEvent", function($scope, $stateParams, $mmUtil, $mmaNotes, $mmSite, $translate, $mmEvents, $mmaNotesSync,
            $q, $mmText, $ionicScrollDelegate, mmaNotesAutomSyncedEvent) {
    var courseid = $stateParams.courseid,
        type = $stateParams.type,
        syncObserver,
        scrollView;
    $scope.courseid = courseid;
    $scope.type = type;
    $scope.title = $translate.instant('mma.notes.' + type + 'notes');
    $scope.notesStr = $scope.title.toLowerCase();
    $scope.refreshIcon = 'spinner';
    $scope.syncIcon = 'spinner';
    function fetchNotes(sync, showErrors) {
        var promise = sync ? syncNotes(showErrors) : $q.when();
        return promise.catch(function() {
        }).then(function() {
            return $mmaNotes.getNotes(courseid).then(function(notes) {
                notes = notes[type + 'notes'];
                $scope.hasOffline = $mmaNotes.hasOfflineNote(notes);
                return $mmaNotes.getNotesUserData(notes, courseid).then(function(notes) {
                    $scope.notes = notes;
                });
            }, function(message) {
                $mmUtil.showErrorModal(message);
            });
        }).finally(function() {
            $scope.notesLoaded = true;
            $scope.refreshIcon = 'ion-refresh';
            $scope.syncIcon = 'ion-loop';
        });
    }
    fetchNotes(true, false).then(function() {
        $mmSite.write('core_notes_view_notes', {
            courseid: courseid,
            userid: 0
        });
    });
    $scope.refreshNotes = function(showErrors) {
        $scope.refreshIcon = 'spinner';
        $scope.syncIcon = 'spinner';
        $mmaNotes.invalidateNotes(courseid).finally(function() {
            fetchNotes(true, showErrors).finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };
    function syncNotes(showErrors) {
        return $mmaNotesSync.syncNotes(courseid).then(function(warnings) {
            showSyncWarnings(warnings);
        }).catch(function(error) {
            if (showErrors) {
                if (error) {
                    $mmUtil.showErrorModal(error);
                } else {
                    $mmUtil.showErrorModal('mm.core.errorsync', true);
                }
            }
            return $q.reject();
        });
    }
    function showSyncWarnings(warnings) {
        var message = $mmText.buildMessage(warnings);
        if (message) {
            $mmUtil.showErrorModal(message);
        }
    }
    function scrollTop() {
        if (!scrollView) {
            scrollView = $ionicScrollDelegate.$getByHandle('mmaNotesListScroll');
        }
        scrollView && scrollView.scrollTop && scrollView.scrollTop();
    }
    syncObserver = $mmEvents.on(mmaNotesAutomSyncedEvent, function(data) {
        if (data && data.siteid == $mmSite.getId() && data.courseid == courseid) {
            showSyncWarnings(data.warnings);
            $scope.notesLoaded = false;
            $scope.refreshIcon = 'spinner';
            $scope.syncIcon = 'spinner';
            scrollTop();
            fetchNotes(false);
        }
    });
    $scope.$on('$destroy', function() {
        syncObserver && syncObserver.off && syncObserver.off();
    });
}]);

angular.module('mm.addons.notes')
.controller('mmaNotesTypesCtrl', ["$scope", "$stateParams", "$mmaNotes", function($scope, $stateParams, $mmaNotes) {
    var course = $stateParams.course,
        courseid = course.id;
    $scope.courseid = courseid;
    $mmaNotes.isPluginAddNoteEnabledForCourse(courseid);
}]);

angular.module('mm.addons.notes')
.factory('$mmaNotesHandlers', ["$mmaNotes", "$mmSite", "$mmApp", "$ionicModal", "$mmUtil", "$q", "$mmaNotesSync", "mmCoursesAccessMethods", "mmUserProfileHandlersTypeCommunication", function($mmaNotes, $mmSite, $mmApp, $ionicModal, $mmUtil, $q, $mmaNotesSync,
            mmCoursesAccessMethods, mmUserProfileHandlersTypeCommunication) {
    var self = {},
        addNoteEnabledCache = {},
        coursesNavEnabledCache = {};
        self.clearAddNoteCache = function(courseId) {
        if (courseId) {
            delete addNoteEnabledCache[courseId];
        } else {
            addNoteEnabledCache = {};
        }
    };
        self.clearCoursesNavCache = function() {
        coursesNavEnabledCache = {};
    };
        self.addNote = function() {
        var self = {
            type: mmUserProfileHandlersTypeCommunication
        };
                self.isEnabled = function() {
            return $mmaNotes.isPluginAddNoteEnabled();
        };
                self.isEnabledForUser = function(user, courseId, navOptions, admOptions) {
            if (!courseId || user.id == $mmSite.getUserId()) {
                return $q.when(false);
            }
            if (typeof addNoteEnabledCache[courseId] != 'undefined') {
                return addNoteEnabledCache[courseId];
            }
            return $mmaNotes.isPluginAddNoteEnabledForCourse(courseId).then(function(enabled) {
                addNoteEnabledCache[courseId] = enabled;
                return enabled;
            });
        };
                self.getController = function(user, courseid) {
                        return function($scope) {
                $scope.title = 'mma.notes.addnewnote';
                $scope.class = 'mma-notes-add-handler';
                $scope.icon = 'ion-ios-list';
                $ionicModal.fromTemplateUrl('addons/notes/templates/add.html', {
                    scope: $scope,
                    animation: 'slide-in-up'
                }).then(function(m) {
                    $scope.modal = m;
                });
                $scope.closeModal = function(){
                    $scope.modal.hide();
                };
                $scope.addNote = function(){
                    $mmApp.closeKeyboard();
                    var loadingModal = $mmUtil.showModalLoading('mm.core.sending', true);
                    $scope.processing = true;
                    $mmaNotes.addNote(user.id, courseid, $scope.note.publishstate, $scope.note.text).then(function(sent) {
                        var message = sent ? 'mma.notes.eventnotecreated' : 'mm.core.datastoredoffline';
                        $scope.modal.hide().then(function() {
                            $mmUtil.showModal('mm.core.success', message);
                        });
                    }, function(error) {
                        $mmUtil.showErrorModal(error);
                        $scope.processing = false;
                    }).finally(function() {
                        loadingModal.dismiss();
                    });
                };
                $scope.action = function($event) {
                    $event.preventDefault();
                    $event.stopPropagation();
                    $scope.note = {
                        publishstate: 'personal',
                        text: ''
                    };
                    $scope.processing = false;
                    $scope.modal.show();
                };
            };
        };
        return self;
    };
        self.coursesNav = function() {
        var self = {};
                self.isEnabled = function() {
            return $mmaNotes.isPluginViewNotesEnabled();
        };
                self.isEnabledForCourse = function(courseId, accessData, navOptions, admOptions) {
            if (accessData && accessData.type == mmCoursesAccessMethods.guest) {
                return false;
            }
            if (navOptions && typeof navOptions.notes != 'undefined') {
                return navOptions.notes;
            }
            if (typeof coursesNavEnabledCache[courseId] != 'undefined') {
                return coursesNavEnabledCache[courseId];
            }
            return $mmaNotes.isPluginViewNotesEnabledForCourse(courseId).then(function(enabled) {
                coursesNavEnabledCache[courseId] = enabled;
                return enabled;
            });
        };
                self.getController = function(courseId) {
                        return function($scope, $state) {
                $scope.icon = 'ion-ios-list';
                $scope.title = 'mma.notes.notes';
                $scope.class = 'mma-notes-view-handler';
                $scope.action = function($event, course) {
                    $event.preventDefault();
                    $event.stopPropagation();
                    $state.go('site.notes-types', {
                        course: course
                    });
                };
            };
        };
        return self;
    };
        self.syncHandler = function() {
        var self = {};
                self.execute = function(siteId) {
            return $mmaNotesSync.syncAllNotes(siteId);
        };
                self.getInterval = function() {
            return 600000;
        };
                self.isSync = function() {
            return true;
        };
                self.usesNetwork = function() {
            return true;
        };
        return self;
    };
    return self;
}])
.run(["$mmaNotesHandlers", "$mmEvents", "mmCoreEventLogout", "mmCoursesEventMyCoursesRefreshed", "mmUserEventProfileRefreshed", function($mmaNotesHandlers, $mmEvents, mmCoreEventLogout, mmCoursesEventMyCoursesRefreshed, mmUserEventProfileRefreshed) {
    $mmEvents.on(mmCoreEventLogout, function() {
        $mmaNotesHandlers.clearAddNoteCache();
        $mmaNotesHandlers.clearCoursesNavCache();
    });
    $mmEvents.on(mmCoursesEventMyCoursesRefreshed, $mmaNotesHandlers.clearCoursesNavCache);
    $mmEvents.on(mmUserEventProfileRefreshed, function(data) {
        $mmaNotesHandlers.clearAddNoteCache(data.courseid);
    });
}]);

angular.module('mm.addons.notes')
.factory('$mmaNotes', ["$mmSite", "$log", "$q", "$mmUser", "$translate", "$mmApp", "$mmaNotesOffline", "$mmUtil", "$mmSitesManager", function($mmSite, $log, $q, $mmUser, $translate, $mmApp, $mmaNotesOffline, $mmUtil, $mmSitesManager) {
    $log = $log.getInstance('$mmaNotes');
    var self = {};
        self.addNote = function(userId, courseId, publishState, noteText, siteId) {
        siteId = siteId || $mmSite.getId();
        if (!$mmApp.isOnline()) {
            return storeOffline();
        }
        return self.addNoteOnline(userId, courseId, publishState, noteText, siteId).then(function() {
            return true;
        }).catch(function(data) {
            if (data.wserror) {
                return $q.reject(data.error);
            } else {
                return storeOffline();
            }
        });
        function storeOffline() {
            return $mmaNotesOffline.saveNote(userId, courseId, publishState, noteText, siteId).then(function() {
                return false;
            });
        }
    };
        self.addNoteOnline = function(userId, courseId, publishState, noteText, siteId) {
        var notes = [
                {
                    userid: userId,
                    publishstate: publishState,
                    courseid: courseId,
                    text: noteText,
                    format: 1
                }
            ];
        return self.addNotesOnline(notes, siteId).catch(function(error) {
            return $q.reject({
                error: error,
                wserror: $mmUtil.isWebServiceError(error)
            });
        }).then(function(response) {
            if (response && response[0] && response[0].noteid === -1) {
                return $q.reject({
                    error: response[0].errormessage,
                    wserror: true
                });
            }
            return self.invalidateNotes(courseId, siteId).catch(function() {
            });
        });
    };
        self.addNotesOnline = function(notes, siteId) {
        if (!notes || !notes.length) {
            return $q.when([]);
        }
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var data = {
                    notes: notes
                };
            return site.write('core_notes_create_notes', data);
        });
    };
        self.isPluginAddNoteEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            if (!site.canUseAdvancedFeature('enablenotes')) {
                return false;
            } else if (!site.wsAvailable('core_notes_create_notes')) {
                return false;
            }
            return true;
        });
    };
        self.isPluginAddNoteEnabledForCourse = function(courseId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var data = {
                    notes: [
                        {
                            userid: -1,
                            publishstate: 'personal',
                            courseid: courseId,
                            text: '',
                            format: 1
                        }
                    ]
                };
            return site.read('core_notes_create_notes', data).then(function() {
                return true;
            }).catch(function() {
                return false;
            });
        });
    };
        self.isPluginViewNotesEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            if (!site.canUseAdvancedFeature('enablenotes')) {
                return false;
            } else if (!site.wsAvailable('core_notes_get_course_notes')) {
                return false;
            }
            return true;
        });
    };
        self.isPluginViewNotesEnabledForCourse = function(courseId, siteId) {
        return self.getNotes(courseId, false, true, siteId).then(function() {
            return true;
        }).catch(function() {
            return false;
        });
    };
        function getNotesCacheKey(courseId) {
        return 'mmaNotes:notes:' + courseId;
    }
        self.getNotes = function(courseId, ignoreCache, onlyOnline, siteId) {
        siteId = siteId || $mmSite.getId();
        $log.debug('Get notes for course ' + courseId);
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var data = {
                    courseid : courseId
                },
                presets = {
                    cacheKey: getNotesCacheKey(courseId)
                };
            if (ignoreCache) {
                presets.getFromCache = false;
                preSets.emergencyCache = false;
            }
            return site.read('core_notes_get_course_notes', data, presets).then(function(notes) {
                if (onlyOnline) {
                    return notes;
                }
                return $mmaNotesOffline.getNotesForCourse(courseId, siteId).then(function(offlineNotes) {
                    angular.forEach(offlineNotes, function(note) {
                        var fieldName = note.publishstate + 'notes';
                        if (!notes[fieldName]) {
                            notes[fieldName] = [];
                        }
                        note.offline = true;
                        notes[fieldName].unshift(note);
                    });
                    return notes;
                });
            });
        });
    };
        self.getNotesUserData = function(notes, courseId) {
        var promises = [];
        angular.forEach(notes, function(note) {
            var promise = $mmUser.getProfile(note.userid, courseId, true).then(function(user) {
                note.userfullname = user.fullname;
                note.userprofileimageurl = user.profileimageurl;
            }, function() {
                return $translate('mma.notes.userwithid', {id: note.userid}).then(function(str) {
                    note.userfullname = str;
                });
            });
            promises.push(promise);
        });
        return $q.all(promises).then(function() {
            return notes;
        });
    };
        self.hasOfflineNote = function(notes) {
        if (!notes || !notes.length) {
            return false;
        }
        for (var i = 0, len = notes.length; i < len; i++) {
            if (notes[i].offline) {
                return true;
            }
        }
        return false;
    };
        self.invalidateNotes = function(courseId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getNotesCacheKey(courseId));
        });
    };
    return self;
}]);

angular.module('mm.addons.notes')
.constant('mmaNotesOfflineNotesStore', 'mma_notes_offline_notes')
.config(["$mmSitesFactoryProvider", "mmaNotesOfflineNotesStore", function($mmSitesFactoryProvider, mmaNotesOfflineNotesStore) {
    var stores = [
        {
            name: mmaNotesOfflineNotesStore,
            keyPath: ['userid', 'content', 'created'],
            indexes: [
                {
                    name: 'userid'
                },
                {
                    name: 'courseid'
                },
                {
                    name: 'publishstate'
                },
                {
                    name: 'created'
                }
            ]
        }
    ];
    $mmSitesFactoryProvider.registerStores(stores);
}])
.factory('$mmaNotesOffline', ["$mmSitesManager", "$log", "$mmSite", "$mmUtil", "mmaNotesOfflineNotesStore", function($mmSitesManager, $log, $mmSite, $mmUtil, mmaNotesOfflineNotesStore) {
    $log = $log.getInstance('$mmaNotesOffline');
    var self = {};
        self.deleteNote = function(userId, content, timecreated, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.getDb().remove(mmaNotesOfflineNotesStore, [userId, content, timecreated]);
        });
    };
        self.getAllNotes = function(siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.getDb().getAll(mmaNotesOfflineNotesStore);
        });
    };
        self.getNote = function(userId, content, timecreated, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.getDb().get(mmaNotesOfflineNotesStore, [userId, content, timecreated]);
        });
    };
        self.getNotesForCourse = function(courseId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.getDb().whereEqual(mmaNotesOfflineNotesStore, 'courseid', courseId);
        });
    };
        self.getNotesForUser = function(userId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.getDb().whereEqual(mmaNotesOfflineNotesStore, 'userid', userId);
        });
    };
        self.getNotesWithPublishState = function(state, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.getDb().whereEqual(mmaNotesOfflineNotesStore, 'publishstate', state);
        });
    };
        self.hasNotesForCourse = function(courseId, siteId) {
        return self.getNotesForCourse(courseId, siteId).then(function(notes) {
            return !!notes.length;
        });
    };
        self.hasNotesForUser = function(userId, siteId) {
        return self.getNotesForUser(userId, siteId).then(function(notes) {
            return !!notes.length;
        });
    };
        self.hasNotesWithPublishState = function(state, siteId) {
        return self.getNotesWithPublishState(state, siteId).then(function(notes) {
            return !!notes.length;
        });
    };
        self.saveNote = function(userId, courseId, state, content, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var now = $mmUtil.timestamp(),
                db = site.getDb(),
                entry = {
                    userid: userId,
                    courseid: courseId,
                    publishstate: state,
                    content: content,
                    format: 1,
                    created: now,
                    lastmodified: now
                };
            return db.insert(mmaNotesOfflineNotesStore, entry);
        });
    };
    return self;
}]);

angular.module('mm.addons.notes')
.factory('$mmaNotesSync', ["$log", "$mmSite", "$q", "$mmCourses", "$mmApp", "$translate", "$mmaNotes", "$mmaNotesOffline", "$mmUtil", "$mmLang", "$mmSitesManager", "$mmEvents", "mmaNotesAutomSyncedEvent", "$mmSync", "mmaNotesComponent", "mmaModNotesSyncTime", function($log, $mmSite, $q, $mmCourses, $mmApp, $translate, $mmaNotes, $mmaNotesOffline, $mmUtil, $mmLang,
            $mmSitesManager, $mmEvents, mmaNotesAutomSyncedEvent, $mmSync, mmaNotesComponent, mmaModNotesSyncTime) {
    $log = $log.getInstance('$mmaNotesSync');
    var self = $mmSync.createChild(mmaNotesComponent, mmaModNotesSyncTime);
        self.syncAllNotes = function(siteId) {
        if (!$mmApp.isOnline()) {
            $log.debug('Cannot sync all notes because device is offline.');
            return $q.reject();
        }
        var promise;
        if (!siteId) {
            $log.debug('Try to sync notes in all sites.');
            promise = $mmSitesManager.getSitesIds();
        } else {
            $log.debug('Try to sync notes in site ' + siteId);
            promise = $q.when([siteId]);
        }
        return promise.then(function(siteIds) {
            var sitePromises = [];
            angular.forEach(siteIds, function(siteId) {
                sitePromises.push($mmaNotesOffline.getAllNotes(siteId).then(function(notes) {
                    var courseIds = [],
                        promises = [];
                    angular.forEach(notes, function(note) {
                        if (courseIds.indexOf(note.courseid) == -1) {
                            courseIds.push(note.courseid);
                        }
                    });
                    angular.forEach(courseIds, function(courseId) {
                        promises.push(self.syncNotesIfNeeded(courseId, siteId).then(function(warnings) {
                            if (typeof warnings != 'undefined') {
                                $mmEvents.trigger(mmaNotesAutomSyncedEvent, {
                                    siteid: siteId,
                                    courseid: courseId,
                                    warnings: warnings
                                });
                            }
                        }));
                    });
                    return $q.all(promises);
                }));
            });
            return $q.all(sitePromises);
        });
    };
        self.syncNotesIfNeeded = function(courseId, siteId) {
        return self.isSyncNeeded(courseId, siteId).then(function(needed) {
            if (needed) {
                return self.syncNotes(courseId, siteId);
            }
        });
    };
        self.syncNotes = function(courseId, siteId) {
        siteId = siteId || $mmSite.getId();
        var syncPromise,
            warnings = [];
        if (self.isSyncing(courseId, siteId)) {
            return self.getOngoingSync(courseId, siteId);
        }
        $log.debug('Try to sync notes for course ' + courseId);
        syncPromise = $mmaNotesOffline.getNotesForCourse(courseId, siteId).then(function(notes) {
            if (!notes.length) {
                return [];
            } else if (!$mmApp.isOnline()) {
                return $mmLang.translateAndReject('mm.core.networkerrormsg');
            }
            var errors = [],
                notesToSend;
            notesToSend = notes.map(function(note) {
                return {
                    userid: note.userid,
                    publishstate: note.publishstate,
                    courseid: note.courseid,
                    text: note.content,
                    format: note.format
                };
            });
            return $mmaNotes.addNotesOnline(notesToSend, siteId).then(function(response) {
                angular.forEach(response, function(entry) {
                    if (entry.noteid === -1 && errors.indexOf(entry.errormessage) == -1) {
                        errors.push(entry.errormessage);
                    }
                });
                return $mmaNotes.invalidateNotes(courseId, siteId).then(function() {
                    return $mmaNotes.getNotes(courseId, false, true, siteId);
                }).catch(function() {
                });
            }).catch(function(error) {
                if ($mmUtil.isWebServiceError(error)) {
                    errors.push(error);
                } else {
                    return $q.reject(error);
                }
            }).then(function() {
                var promises = [];
                angular.forEach(notes, function(note) {
                    promises.push($mmaNotesOffline.deleteNote(note.userid, note.content, note.created, siteId));
                });
                return $q.all(promises);
            }).then(function() {
                if (errors && errors.length) {
                    return $mmCourses.getUserCourse(courseId, true, siteId).catch(function() {
                        return {};
                    }).then(function(course) {
                        angular.forEach(errors, function(error) {
                            warnings.push($translate.instant('mma.notes.warningnotenotsent', {
                                course: course.fullname ? course.fullname : courseId,
                                error: error
                            }));
                        });
                    });
                }
            });
        }).then(function() {
            return warnings;
        });
        return self.addOngoingSync(courseId, syncPromise, siteId);
    };
    return self;
}]);

angular.module('mm.addons.mod_book')
.controller('mmaModBookIndexCtrl', ["$scope", "$stateParams", "$mmUtil", "$mmCourseHelper", "$mmaModBook", "$log", "mmaModBookComponent", "$mmText", "$ionicPopover", "$mmApp", "$q", "$mmCourse", "$ionicScrollDelegate", "$translate", "$mmaModBookPrefetchHandler", function($scope, $stateParams, $mmUtil, $mmCourseHelper, $mmaModBook, $log, mmaModBookComponent,
            $mmText, $ionicPopover, $mmApp, $q, $mmCourse, $ionicScrollDelegate, $translate, $mmaModBookPrefetchHandler) {
    $log = $log.getInstance('mmaModBookIndexCtrl');
    var module = $stateParams.module || {},
        courseId = $stateParams.courseid,
        chapters,
        currentChapter,
        contentsMap;
    $scope.title = module.name;
    $scope.description = module.description;
    $scope.component = mmaModBookComponent;
    $scope.componentId = module.id;
    $scope.externalUrl = module.url;
    $scope.loaded = false;
    $scope.refreshIcon = 'spinner';
    function loadChapter(chapterId) {
        currentChapter = chapterId;
        $ionicScrollDelegate.scrollTop();
        return $mmaModBook.getChapterContent(contentsMap, chapterId, module.id).then(function(content) {
            $scope.content = content;
            $scope.previousChapter = $mmaModBook.getPreviousChapter(chapters, chapterId);
            $scope.nextChapter = $mmaModBook.getNextChapter(chapters, chapterId);
            $mmaModBook.logView(module.instance, chapterId).then(function() {
                if (!$scope.nextChapter) {
                    $mmCourse.checkModuleCompletion(courseId, module.completionstatus);
                }
            });
        }).catch(function() {
            $mmUtil.showErrorModal('mma.mod_book.errorchapter', true);
            return $q.reject();
        }).finally(function() {
            $scope.loaded = true;
            $scope.refreshIcon = 'ion-refresh';
            $ionicScrollDelegate.resize();
        });
    }
    function fetchContent(chapterId, refresh) {
        var downloadFailed = false,
            promises = [];
        promises.push($mmaModBook.getBook(courseId, module.id).then(function(book) {
            $scope.title = book.name || $scope.title;
            $scope.description = book.intro || $scope.description;
        }).catch(function() {
        }));
        promises.push($mmaModBookPrefetchHandler.download(module, courseId).catch(function() {
            downloadFailed = true;
            if (!module.contents.length) {
                return $mmCourse.loadModuleContents(module, courseId).catch(function(error) {
                    $scope.loaded = true;
                    $scope.refreshIcon = 'ion-refresh';
                    $mmUtil.showErrorModalDefault(error, 'mm.course.errorgetmodule', true);
                    return $q.reject();
                });
            }
        }));
        return $q.all(promises).then(function() {
            contentsMap = $mmaModBook.getContentsMap(module.contents);
            chapters = $mmaModBook.getTocList(module.contents);
            $scope.toc = chapters;
            if (typeof currentChapter == 'undefined') {
                currentChapter = $mmaModBook.getFirstChapter(chapters);
            }
            return loadChapter(chapterId || currentChapter).then(function() {
                if (downloadFailed && $mmApp.isOnline()) {
                    $mmUtil.showErrorModal('mm.core.errordownloadingsomefiles', true);
                }
                $mmCourseHelper.fillContextMenu($scope, module, courseId, refresh, mmaModBookComponent);
            });
        });
    }
    $scope.doRefresh = function() {
        if ($scope.loaded) {
            $scope.refreshIcon = 'spinner';
            return $mmaModBook.invalidateContent(module.id, courseId).finally(function() {
                return fetchContent(currentChapter, true);
            }).finally(function() {
                $scope.refreshIcon = 'ion-refresh';
                $scope.$broadcast('scroll.refreshComplete');
            });
        }
    };
    $scope.loadChapter = function(chapterId) {
        $scope.popover.hide();
        $scope.loaded = false;
        $scope.refreshIcon = 'spinner';
        loadChapter(chapterId);
    };
    $ionicPopover.fromTemplateUrl('addons/mod/book/templates/toc.html', {
        scope: $scope
    }).then(function(popover) {
        $scope.popover = popover;
        $scope.openToc = function($event) {
            popover.show($event);
        };
    });
    $scope.removeFiles = function() {
        $mmCourseHelper.confirmAndRemove(module, courseId);
    };
    $scope.prefetch = function() {
        $mmCourseHelper.contextMenuPrefetch($scope, module, courseId);
    };
    $scope.expandDescription = function() {
        $mmText.expandText($translate.instant('mm.core.description'), $scope.description, false, mmaModBookComponent, module.id);
    };
    fetchContent();
}]);

angular.module('mm.addons.mod_book')
.directive('mmaModBookArrows', function() {
    return {
        restrict: 'E',
        scope: {
            previous: '=?',
            next: '=?',
            action: '=?'
        },
        templateUrl: 'addons/mod/book/templates/arrows.html'
    };
});

angular.module('mm.addons.mod_book')
.factory('$mmaModBook', ["$mmFilepool", "$mmSite", "$mmFS", "$http", "$log", "$q", "$mmSitesManager", "$mmUtil", "mmaModBookComponent", "$mmCourse", "$mmText", function($mmFilepool, $mmSite, $mmFS, $http, $log, $q, $mmSitesManager, $mmUtil, mmaModBookComponent,
            $mmCourse, $mmText) {
    $log = $log.getInstance('$mmaModBook');
    var self = {};
        function getBookDataCacheKey(courseId) {
        return 'mmaModBook:book:' + courseId;
    }
        function getBook(siteId, courseId, key, value) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    courseids: [courseId]
                },
                preSets = {
                    cacheKey: getBookDataCacheKey(courseId)
                };
            return site.read('mod_book_get_books_by_courses', params, preSets).then(function(response) {
                if (response && response.books) {
                    var currentBook;
                    angular.forEach(response.books, function(book) {
                        if (!currentBook && book[key] == value) {
                            currentBook = book;
                        }
                    });
                    if (currentBook) {
                        return currentBook;
                    }
                }
                return $q.reject();
            });
        });
    }
        self.getBook = function(courseId, cmId, siteId) {
        siteId = siteId || $mmSite.getId();
        return getBook(siteId, courseId, 'coursemodule', cmId);
    };
        self.getToc = function(contents) {
        if (!contents || !contents.length) {
            return [];
        }
        return JSON.parse(contents[0].content);
    };
        self.getTocList = function(contents) {
        var chapters = [];
        var toc = self.getToc(contents);
        angular.forEach(toc, function(el) {
            var chapterId = el.href.replace('/index.html', '');
            chapters.push({id: chapterId, title: el.title, level: el.level});
            angular.forEach(el.subitems, function(sel) {
                chapterId = sel.href.replace('/index.html', '');
                chapters.push({id: chapterId, title: sel.title, level: sel.level});
            });
        });
        return chapters;
    };
        self.getFirstChapter = function(chapters) {
        if (!chapters || !chapters.length) {
            return;
        }
        return chapters[0].id;
    };
        self.getPreviousChapter = function(chapters, chapterId) {
        var previous = 0;
        for (var i = 0, len = chapters.length; i < len; i++) {
            if (chapters[i].id == chapterId) {
                break;
            }
            previous = chapters[i].id;
        }
        return previous;
    };
        self.getNextChapter = function(chapters, chapterId) {
        var next = 0;
        for (var i = 0, len = chapters.length; i < len; i++) {
            if (chapters[i].id == chapterId) {
                if (typeof chapters[i + 1] != 'undefined') {
                    next = chapters[i + 1].id;
                    break;
                }
            }
        }
        return next;
    };
        self.getChapterContent = function(contentsMap, chapterId, moduleId) {
        var indexUrl = contentsMap[chapterId] ? contentsMap[chapterId].indexUrl : undefined,
            promise;
        if (!indexUrl) {
            $log.debug('Could not locate the index chapter');
            return $q.reject();
        }
        if ($mmFS.isAvailable()) {
            promise = $mmFilepool.downloadUrl($mmSite.getId(), indexUrl, false, mmaModBookComponent, moduleId);
        } else {
            return $q.when($mmSite.fixPluginfileURL(indexUrl));
        }
        return promise.then(function(url) {
            return $http.get(url).then(function(response) {
                if (typeof response.data !== 'string') {
                    return $q.reject();
                } else {
                    return $mmUtil.restoreSourcesInHtml(response.data, contentsMap[chapterId].paths);
                }
            });
        });
    };
        self.getContentsMap = function(contents) {
        var map = {};
        angular.forEach(contents, function(content) {
            if (self.isFileDownloadable(content)) {
                var chapter,
                    matches,
                    split,
                    filepathIsChapter;
                matches = content.filepath.match(/\/(\d+)\//);
                if (matches && matches[1]) {
                    chapter = matches[1];
                    filepathIsChapter = content.filepath == '/' + chapter + '/';
                    map[chapter] = map[chapter] || { paths: {} };
                    if (content.filename == 'index.html' && filepathIsChapter) {
                        map[chapter].indexUrl = content.fileurl;
                    } else {
                        if (filepathIsChapter) {
                            split = content.fileurl.split('mod_book/chapter' + content.filepath);
                            key = split[1] || content.filename;
                        } else {
                            key = content.filepath.replace('/' + chapter + '/', '') + content.filename;
                        }
                        map[chapter].paths[$mmText.decodeURIComponent(key)] = content.fileurl;
                    }
                }
            }
        });
        return map;
    };
        self.invalidateBookData = function(courseId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getBookDataCacheKey(courseId));
        });
    };
        self.invalidateContent = function(moduleId, courseId, siteId) {
        siteId = siteId || $mmSite.getId();
        var promises = [];
        promises.push(self.invalidateBookData(courseId, siteId));
        promises.push($mmFilepool.invalidateFilesByComponent(siteId, mmaModBookComponent, moduleId));
        promises.push($mmCourse.invalidateModule(moduleId, siteId));
        return $mmUtil.allPromises(promises);
    };
        self.isFileDownloadable = function(file) {
        return file.type === 'file';
    };
        self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.isVersionGreaterEqualThan('2.9') && site.canDownloadFiles();
        });
    };
        self.logView = function(id, chapterId) {
        if (id) {
            var params = {
                bookid: id,
                chapterid: chapterId
            };
            return $mmSite.write('mod_book_view_book', params).then(function(response) {
                if (!response.status) {
                    return $q.reject();
                }
            });
        }
        return $q.reject();
    };
    return self;
}]);

angular.module('mm.addons.mod_book')
.factory('$mmaModBookHandlers', ["$mmCourse", "$mmaModBook", "$mmEvents", "$state", "$mmSite", "$mmCourseHelper", "$mmCoursePrefetchDelegate", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", "mmCoreDownloaded", "$mmUtil", "mmCoreEventPackageStatusChanged", "mmaModBookComponent", "$mmContentLinksHelper", "$mmaModBookPrefetchHandler", function($mmCourse, $mmaModBook, $mmEvents, $state, $mmSite, $mmCourseHelper,
            $mmCoursePrefetchDelegate, mmCoreDownloading, mmCoreNotDownloaded, mmCoreOutdated, mmCoreDownloaded, $mmUtil,
            mmCoreEventPackageStatusChanged, mmaModBookComponent, $mmContentLinksHelper, $mmaModBookPrefetchHandler) {
    var self = {};
        self.courseContentHandler = function() {
        var self = {};
                self.isEnabled = function() {
            return $mmaModBook.isPluginEnabled();
        };
                self.getController = function(module, courseid) {
            return function($scope) {
                var downloadBtn,
                    refreshBtn;
                downloadBtn = {
                    hidden: true,
                    icon: 'ion-ios-cloud-download-outline',
                    label: 'mm.core.download',
                    action: function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        download(false);
                    }
                };
                refreshBtn = {
                    icon: 'ion-android-refresh',
                    label: 'mm.core.refresh',
                    hidden: true,
                    action: function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        download(true);
                    }
                };
                $scope.title = module.name;
                $scope.icon = $mmCourse.getModuleIconSrc('book');
                $scope.class = 'mma-mod_book-handler';
                $scope.buttons = [downloadBtn, refreshBtn];
                $scope.spinner = true;
                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_book', {module: module, courseid: courseid});
                };
                function download(refresh) {
                    var dwnBtnHidden = downloadBtn.hidden,
                        rfrshBtnHidden = refreshBtn.hidden;
                    $scope.spinner = true;
                    downloadBtn.hidden = true;
                    refreshBtn.hidden = true;
                    $mmaModBookPrefetchHandler.getDownloadSize(module, courseid).then(function(size) {
                        $mmCourseHelper.prefetchModule($scope, $mmaModBookPrefetchHandler, module, size, refresh, courseid)
                                .catch(function() {
                            $scope.spinner = false;
                            downloadBtn.hidden = dwnBtnHidden;
                            refreshBtn.hidden = rfrshBtnHidden;
                        });
                    }).catch(function(error) {
                        $scope.spinner = false;
                        downloadBtn.hidden = dwnBtnHidden;
                        refreshBtn.hidden = rfrshBtnHidden;
                        if (error) {
                            $mmUtil.showErrorModal(error);
                        } else {
                            $mmUtil.showErrorModal('mm.core.errordownloading', true);
                        }
                    });
                }
                function showStatus(status) {
                    if (status) {
                        $scope.spinner = status === mmCoreDownloading;
                        downloadBtn.hidden = status !== mmCoreNotDownloaded;
                        refreshBtn.hidden = status !== mmCoreOutdated;
                        if (!$mmCoursePrefetchDelegate.canCheckUpdates()) {
                            refreshBtn.hidden = refreshBtn.hidden && status !== mmCoreDownloaded;
                        }
                    }
                }
                var statusObserver = $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
                    if (data.siteid === $mmSite.getId() && data.componentId === module.id && data.component === mmaModBookComponent) {
                        showStatus(data.status);
                    }
                });
                $mmCoursePrefetchDelegate.getModuleStatus(module, courseid).then(showStatus);
                $scope.$on('$destroy', function() {
                    statusObserver && statusObserver.off && statusObserver.off();
                });
            };
        };
        return self;
    };
        self.linksHandler = $mmContentLinksHelper.createModuleIndexLinkHandler('mmaModBook', 'book', $mmaModBook);
    return self;
}]);

angular.module('mm.addons.mod_book')
.factory('$mmaModBookPrefetchHandler', ["$mmaModBook", "$mmSite", "$mmPrefetchFactory", "$q", "mmCoreDownloaded", "mmCoreOutdated", "mmaModBookComponent", "$mmCourse", function($mmaModBook, $mmSite, $mmPrefetchFactory, $q, mmCoreDownloaded, mmCoreOutdated,
            mmaModBookComponent, $mmCourse) {
    var self = $mmPrefetchFactory.createPrefetchHandler(mmaModBookComponent, true);
    self.updatesNames = /^configuration$|^.*files$|^entries$/;
        self.determineStatus = function(status, canCheck) {
        if (!canCheck && status === mmCoreDownloaded) {
            return mmCoreOutdated;
        } else {
            return status;
        }
    };
        self.getIntroFiles = function(module, courseId) {
        return $mmaModBook.getBook(courseId, module.id).catch(function() {
        }).then(function(book) {
            return self.getIntroFilesFromInstance(module, book);
        });
    };
        self.getRevisionAndTimemodified = function(module, courseId, introFiles) {
        return $q.when({
            timemod: 0,
            revision: "0"
        });
    };
        self.invalidateContent = function(moduleId, courseId) {
        return $mmaModBook.invalidateContent(moduleId, courseId);
    };
        self.invalidateModule = function(module, courseId) {
        var promises = [];
        promises.push($mmaModBook.invalidateBookData(courseId));
        promises.push($mmCourse.invalidateModule(module.id));
        return $q.all(promises);
    };
        self.isEnabled = function() {
        if (!$mmSite.canDownloadFiles()) {
            return false;
        }
        return $mmaModBook.isPluginEnabled();
    };
    return self;
}]);

angular.module('mm.addons.mod_assign')
.directive('mmaModAssignFeedbackPlugin', ["$compile", "$mmaModAssignFeedbackDelegate", "$mmaModAssign", "mmaModAssignComponent", "$state", "$mmaModAssignHelper", function($compile, $mmaModAssignFeedbackDelegate, $mmaModAssign, mmaModAssignComponent,
        $state, $mmaModAssignHelper) {
    return {
        restrict: 'E',
        scope: {
            assign: '=',
            plugin: '=',
            userid: '=',
            submission: '=?',
            canEdit: '=?',
            edit: '@?'
        },
        templateUrl: 'addons/mod/assign/templates/feedbackplugin.html',
        link: function(scope, element) {
            var plugin = scope.plugin,
                container = element[0].querySelector('.mma-mod-assign-feedback-container'),
                directive;
            if (!plugin || !container) {
                return;
            }
            plugin.name = $mmaModAssignFeedbackDelegate.getPluginName(plugin);
            if (!plugin.name) {
                return;
            }
            scope.assignComponent = mmaModAssignComponent;
            scope.canEdit = scope.canEdit && scope.canEdit !== 'false';
            scope.edit = scope.edit && scope.edit !== 'false';
            directive = $mmaModAssignFeedbackDelegate.getDirectiveForPlugin(plugin);
            if (directive) {
                scope.configs = $mmaModAssignHelper.getPluginConfig(scope.assign, 'assignfeedback', plugin.type);
                scope.goToEdit = function() {
                    if (scope.canEdit) {
                        $state.go('site.mod_assign-feedback-edit', {
                            assignid: scope.assign.id,
                            userid: scope.userid,
                            plugintype: scope.plugin.type,
                            assign: scope.assign,
                            submission: scope.submission,
                            plugin: scope.plugin
                        });
                    }
                };
                container.setAttribute(directive, '');
                $compile(container)(scope);
            } else {
                scope.text = $mmaModAssign.getSubmissionPluginText(plugin);
                scope.files = $mmaModAssign.getSubmissionPluginAttachments(plugin);
                scope.notSupported = $mmaModAssignFeedbackDelegate.isPluginSupported(plugin.type);
            }
        }
    };
}]);

angular.module('mm.addons.mod_assign')
.directive('mmaModAssignSubmission', ["$mmaModAssign", "$translate", "$mmUser", "mmaModAssignAttemptReopenMethodNone", "$q", "$mmSite", "mmaModAssignUnlimitedAttempts", "mmUserProfileState", "mmaModAssignSubmissionStatusNew", "mmaModAssignSubmissionStatusSubmitted", "mmaModAssignSubmissionInvalidatedEvent", "$mmGroups", "$state", "$mmaModAssignHelper", "mmaModAssignSubmissionStatusReopened", "$mmEvents", "mmaModAssignSubmittedForGradingEvent", "$mmFileUploaderHelper", "$mmApp", "$mmText", "mmaModAssignComponent", "$mmUtil", "$mmaModAssignOffline", "mmaModAssignEventManualSynced", "$mmCourse", "$mmGrades", "mmaModAssignAttemptReopenMethodManual", "$mmLang", "$mmSyncBlock", "mmaModAssignEventSubmitGrade", "$ionicPlatform", "mmaModAssignGradedEvent", function($mmaModAssign, $translate, $mmUser, mmaModAssignAttemptReopenMethodNone, $q, $mmSite,
        mmaModAssignUnlimitedAttempts, mmUserProfileState, mmaModAssignSubmissionStatusNew, mmaModAssignSubmissionStatusSubmitted,
        mmaModAssignSubmissionInvalidatedEvent, $mmGroups, $state, $mmaModAssignHelper, mmaModAssignSubmissionStatusReopened,
        $mmEvents, mmaModAssignSubmittedForGradingEvent, $mmFileUploaderHelper, $mmApp, $mmText, mmaModAssignComponent, $mmUtil,
        $mmaModAssignOffline, mmaModAssignEventManualSynced, $mmCourse, $mmGrades, mmaModAssignAttemptReopenMethodManual,
        $mmLang, $mmSyncBlock, mmaModAssignEventSubmitGrade, $ionicPlatform, mmaModAssignGradedEvent) {
    var originalGrades =  {};
        function setStatusNameAndClass(scope, assign, status) {
        if (scope.hasOffline) {
            scope.statusTranslated = $translate.instant('mm.core.notsent');
            scope.statusClass = 'badge-energized';
        } else if (!assign.teamsubmission) {
            if (scope.userSubmission && scope.userSubmission.status != mmaModAssignSubmissionStatusNew) {
                scope.statusTranslated = $translate.instant('mma.mod_assign.submissionstatus_' + scope.userSubmission.status);
                scope.statusClass = $mmaModAssign.getSubmissionStatusClass(scope.userSubmission.status);
            } else {
                if (!status.lastattempt.submissionsenabled) {
                    scope.statusTranslated = $translate.instant('mma.mod_assign.noonlinesubmissions');
                    scope.statusClass = $mmaModAssign.getSubmissionStatusClass('noonlinesubmissions');
                } else {
                    scope.statusTranslated = $translate.instant('mma.mod_assign.noattempt');
                    scope.statusClass = $mmaModAssign.getSubmissionStatusClass('noattempt');
                }
            }
        } else {
            if (!status.lastattempt.submissiongroup && assign.preventsubmissionnotingroup) {
                scope.statusTranslated = $translate.instant('mma.mod_assign.nosubmission');
                scope.statusClass = $mmaModAssign.getSubmissionStatusClass('nosubmission');
            } else if (scope.userSubmission && scope.userSubmission.status != mmaModAssignSubmissionStatusNew) {
                scope.statusTranslated = $translate.instant('mma.mod_assign.submissionstatus_' + scope.userSubmission.status);
                scope.statusClass = $mmaModAssign.getSubmissionStatusClass(scope.userSubmission.status);
            } else {
                if (!status.lastattempt.submissionsenabled) {
                    scope.statusTranslated = $translate.instant('mma.mod_assign.noonlinesubmissions');
                    scope.statusClass = $mmaModAssign.getSubmissionStatusClass('noonlinesubmissions');
                } else {
                    scope.statusTranslated = $translate.instant('mma.mod_assign.nosubmission');
                    scope.statusClass = $mmaModAssign.getSubmissionStatusClass('nosubmission');
                }
            }
        }
    }
        function feedbackController(scope, assign, feedbackStatus, courseId, moduleId, userId) {
        scope.grade = {
            method: false,
            grade: false,
            modified: 0,
            gradingStatus: false,
            addAttempt : false,
            applyToAll: false,
            scale: false,
            lang: false
        };
        originalGrades =  {
            grade: false,
            addAttempt: false,
            applyToAll: false,
            outcomes: {}
        };
        if (feedbackStatus) {
            scope.feedback = feedbackStatus;
            if (feedbackStatus.grade && feedbackStatus.grade.grader) {
                $mmUser.getProfile(feedbackStatus.grade.grader, courseId).then(function(profile) {
                    scope.grader = profile;
                });
            }
            if (feedbackStatus.gradefordisplay) {
                var position = feedbackStatus.gradefordisplay.indexOf('class="advancedgrade"');
                if (position > -1) {
                    scope.feedback.advancedgrade = true;
                }
            }
            if (feedbackStatus.grade && feedbackStatus.grade.grade && !scope.grade.grade) {
                var parsedGrade = parseFloat(feedbackStatus.grade.grade);
                scope.grade.grade = parsedGrade || parsedGrade == 0 ? parsedGrade : null;
            }
        } else {
            scope.showSubmission = true;
        }
        scope.grade.gradingStatus = scope.lastAttempt.gradingstatus;
        return $mmaModAssign.isGradingEnabled().then(function(enabled) {
            if (!enabled) {
                return $q.when();
            }
            return $mmCourse.getModuleBasicGradeInfo(moduleId).then(function(gradeInfo) {
                if (!gradeInfo) {
                    return $q.when();
                }
                if (!scope.$$destroyed) {
                    $mmSyncBlock.blockOperation(mmaModAssignComponent, assign.id);
                }
                scope.gradeInfo = gradeInfo;
                if (gradeInfo.advancedgrading && gradeInfo.advancedgrading[0] &&
                        typeof gradeInfo.advancedgrading[0].method != 'undefined') {
                    scope.grade.method = gradeInfo.advancedgrading[0].method || 'simple';
                } else {
                    scope.grade.method = 'simple';
                }
                scope.isGrading = true;
                scope.canSaveGrades = scope.grade.method == 'simple';
                if (scope.gradeInfo.scale) {
                    scope.grade.scale = formatScaleOptions(scope.gradeInfo.scale, $translate.instant('mm.core.nograde'));
                } else {
                    $mmLang.getCurrentLanguage().then(function(lang) {
                        scope.grade.lang = lang;
                    });
                }
                if ($mmaModAssign.isOutcomesEditEnabled()) {
                    angular.forEach(scope.gradeInfo.outcomes, function(outcome) {
                        if (outcome.scale) {
                            outcome.options =
                                formatScaleOptions(outcome.scale, $translate.instant('mm.grades.nooutcome'));
                        }
                        outcome.selectedId = 0;
                        originalGrades.outcomes[outcome.id] = outcome.selectedId;
                    });
                }
                return $mmGrades.getGradeModuleItems(courseId, moduleId, userId).then(function(grades) {
                    var outcomes = {};
                    angular.forEach(grades, function(grade) {
                        if (!grade.outcomeid && !grade.scaleid) {
                            if (scope.grade.scale) {
                                scope.grade.grade = getSelectedScaleId(scope.grade.scale, grade.gradeformatted);
                            } else {
                                var parsedGrade = parseFloat(grade.gradeformatted);
                                scope.grade.grade = parsedGrade || parsedGrade == 0 ? parsedGrade : null;
                            }
                            scope.grade.modified = grade.gradedategraded;
                            originalGrades.grade = scope.grade.grade;
                        } else if (grade.outcomeid) {
                            angular.forEach(scope.gradeInfo.outcomes, function(outcome) {
                                if (outcome.id == grade.outcomeid) {
                                    outcome.selected = grade.gradeformatted;
                                    outcome.modified = grade.gradedategraded;
                                    if (outcome.options) {
                                        outcome.selectedId = getSelectedScaleId(outcome.options, outcome.selected);
                                        originalGrades.outcomes[outcome.id] = outcome.selectedId;
                                        outcome.itemNumber = grade.itemnumber;
                                    }
                                    outcomes[outcome.id] = outcome;
                                }
                            });
                        }
                    });
                    scope.gradeInfo.outcomes = outcomes;
                });
            }).then(function() {
                if (!scope.isGrading) {
                    return $q.when();
                }
                var isManual = assign.attemptreopenmethod == mmaModAssignAttemptReopenMethodManual,
                    isUnlimited = assign.maxattempts == mmaModAssignUnlimitedAttempts,
                    isLessThanMaxAttempts = scope.userSubmission &&
                        (scope.userSubmission.attemptnumber < (assign.maxattempts - 1));
                scope.allowAddAttempt = isManual && (!scope.userSubmission || isUnlimited || isLessThanMaxAttempts);
                if (assign.teamsubmission) {
                    scope.grade.applyToAll = true;
                    originalGrades.applyToAll = true;
                }
                if (assign.markingworkflow && scope.grade.gradingStatus) {
                    scope.workflowStatusTranslationId =
                        $mmaModAssign.getSubmissionGradingStatusTranslationId(scope.grade.gradingStatus);
                }
                if (!scope.feedback) {
                    scope.feedback = {};
                    scope.feedback.plugins = $mmaModAssignHelper.getPluginsEnabled(assign, 'assignfeedback');
                }
                if (scope.canSaveGrades) {
                    return $mmaModAssignOffline.getSubmissionGrade(assign.id, userId).then(function(data) {
                        if (data &&
                                (!feedbackStatus || !feedbackStatus.gradeddate || feedbackStatus.gradeddate < data.timemodified)) {
                            if (scope.grade.modified < data.timemodified) {
                                scope.grade.grade = data.grade;
                                scope.gradingStatusTranslationId = 'mma.mod_assign.gradenotsynced';
                                scope.gradingClass = "";
                            }
                            scope.grade.applyToAll = data.applytoall;
                            scope.grade.addAttempt = data.addattempt;
                            if (data.outcomes && Object.keys(data.outcomes).length) {
                                angular.forEach(scope.gradeInfo.outcomes, function(outcome) {
                                    if (typeof data.outcomes[outcome.itemNumber] != "undefined") {
                                        if (outcome.modified < data.timemodified) {
                                            outcome.selectedId = data.outcomes[outcome.itemNumber];
                                        }
                                    }
                                });
                            }
                        }
                    });
                } else {
                    return $mmCourse.getModule(moduleId, courseId, false, true).then(function(mod) {
                        scope.gradeUrl = mod.url + "&action=grader&userid=" + userId;
                    });
                }
            });
        });
    }
    function formatScaleOptions(options, defaultOption) {
        options = options.split(",");
        options = options.map(function (value) {return value.trim();});
        options.unshift(defaultOption);
        return options;
    }
    function getSelectedScaleId(options, selected) {
        var index = options.indexOf(selected) || 0;
        if (index < 0) {
            return 0;
        }
        return index;
    }
    function controller() {
        var self = this;
        self.load = function(scope, moduleId, courseId, submitId, blindId) {
            var isBlind = !!blindId,
                assign;
            scope.previousAttempt = false;
            if (!submitId) {
                submitId = $mmSite.getUserId();
                isBlind = false;
            }
            return $mmaModAssign.getAssignment(courseId, moduleId).then(function(assignData) {
                assign = assignData;
                var time = $mmUtil.timestamp(),
                    promises = [];
                scope.assign = assign;
                if (assign.allowsubmissionsfromdate && assign.allowsubmissionsfromdate >= time) {
                    scope.fromDate = moment(assign.allowsubmissionsfromdate * 1000)
                        .format($translate.instant('mm.core.dfmediumdate'));
                }
                scope.currentAttempt = 0;
                scope.attemptReopenMethodNone = mmaModAssignAttemptReopenMethodNone;
                scope.unlimitedAttempts = mmaModAssignUnlimitedAttempts;
                scope.maxAttemptsText = $translate.instant('mma.mod_assign.unlimitedattempts');
                scope.blindMarking = scope.isSubmittedForGrading && assign.blindmarking && !assign.revealidentities;
                if (!scope.blindMarking && submitId != $mmSite.getUserId()) {
                    promises.push($mmUser.getProfile(submitId, courseId).then(function(profile) {
                        scope.user = profile;
                    }));
                }
                promises.push($mmaModAssignOffline.getSubmission(assign.id, submitId).then(function(data) {
                    scope.hasOffline = data && data.plugindata && Object.keys(data.plugindata).length;
                    scope.submittedOffline = data && data.submitted;
                }).catch(function() {
                    scope.hasOffline = false;
                    scope.submittedOffline = false;
                }));
                return $q.all(promises);
            }).then(function() {
                return $mmaModAssign.getSubmissionStatus(assign.id, submitId, isBlind).then(function(response) {
                    var promises = [],
                        submissionStatementMissing = assign.requiresubmissionstatement &&
                            typeof assign.submissionstatement == 'undefined';
                    scope.submissionStatusAvailable = true;
                    scope.lastAttempt = response.lastattempt;
                    if (response.previousattempts && response.previousattempts.length > 0) {
                        var previousAttempts = response.previousattempts.sort(function(a, b) {
                            return a.attemptnumber - b.attemptnumber;
                        });
                        scope.previousAttempt = previousAttempts[previousAttempts.length - 1];
                    }
                    scope.membersToSubmit = [];
                    if (response.lastattempt) {
                        scope.canSubmit = !scope.isSubmittedForGrading && !scope.submittedOffline &&
                            (response.lastattempt.cansubmit ||
                                (scope.hasOffline && $mmaModAssign.canSubmitOffline(assign, response)));
                        scope.canEdit = !scope.isSubmittedForGrading && response.lastattempt.canedit &&
                                (!scope.submittedOffline || !assign.submissiondrafts);
                        if (assign.requiresubmissionstatement && assign.submissiondrafts && submitId == $mmSite.getUserId()) {
                            scope.submissionStatement = assign.submissionstatement;
                            scope.submitModel.submissionStatement = false;
                        } else {
                            scope.submissionStatement = false;
                            scope.submitModel.submissionStatement = true;
                        }
                        scope.showErrorStatementEdit = submissionStatementMissing && !assign.submissiondrafts &&
                                submitId == $mmSite.getUserId();
                        scope.showErrorStatementSubmit = submissionStatementMissing && assign.submissiondrafts;
                        scope.userSubmission = $mmaModAssign.getSubmissionObjectFromAttempt(assign, response.lastattempt);
                        if (assign.attemptreopenmethod != mmaModAssignAttemptReopenMethodNone) {
                            if (scope.userSubmission) {
                                scope.currentAttempt = scope.userSubmission.attemptnumber + 1;
                            }
                        }
                        setStatusNameAndClass(scope, assign, response);
                        if (assign.teamsubmission) {
                            if (response.lastattempt.submissiongroup) {
                                promises.push($mmGroups.getActivityAllowedGroups(assign.cmid).then(function(groups) {
                                    angular.forEach(groups, function(group) {
                                        if (group.id == response.lastattempt.submissiongroup) {
                                            scope.lastAttempt.submissiongroupname = group.name;
                                        }
                                    });
                                }));
                            }
                            if (scope.userSubmission && scope.userSubmission.status != mmaModAssignSubmissionStatusNew) {
                                scope.userStateName = mmUserProfileState;
                                angular.forEach(response.lastattempt.submissiongroupmemberswhoneedtosubmit, function(member) {
                                    if (scope.blindMarking) {
                                        promises.push($mmaModAssign.getAssignmentUserMappings(assign.id, member).then(function(blindId) {
                                            scope.membersToSubmit.push(blindId);
                                        }).catch(function() {
                                        }));
                                    } else {
                                        promises.push($mmUser.getProfile(member, courseId).then(function(profile) {
                                            scope.membersToSubmit.push(profile);
                                        }));
                                    }
                                });
                                angular.forEach(response.lastattempt.submissiongroupmemberswhoneedtosubmitblind, function(member) {
                                    scope.membersToSubmit.push(member);
                                });
                            }
                        }
                        scope.gradingStatusTranslationId =
                                    $mmaModAssign.getSubmissionGradingStatusTranslationId(response.lastattempt.gradingstatus);
                        scope.gradingClass = $mmaModAssign.getSubmissionGradingStatusClass(response.lastattempt.gradingstatus);
                        if (scope.userSubmission) {
                            if (!assign.teamsubmission || !response.lastattempt.submissiongroup ||
                                    !assign.preventsubmissionnotingroup) {
                                if (scope.previousAttempt && scope.previousAttempt.submission.plugins &&
                                        scope.userSubmission.status == mmaModAssignSubmissionStatusReopened) {
                                    scope.submissionPlugins = scope.previousAttempt.submission.plugins;
                                } else {
                                    scope.submissionPlugins = scope.userSubmission.plugins;
                                }
                            }
                        }
                    }
                    if (assign.duedate > 0) {
                        var duedate = response.lastattempt && response.lastattempt.extensionduedate ?
                            response.lastattempt.extensionduedate: assign.duedate,
                            time = $mmUtil.timestamp();
                            timeRemaining = duedate - time;
                        if (timeRemaining <= 0) {
                            if (!scope.userSubmission || scope.userSubmission.status != mmaModAssignSubmissionStatusSubmitted) {
                                if ((response.lastattempt && response.lastattempt.submissionsenabled) ||
                                    (response.gradingsummary && response.gradingsummary.submissionsenabled)) {
                                    scope.timeRemaining = $translate.instant('mma.mod_assign.overdue',
                                        {'$a': $mmUtil.formatDuration(-timeRemaining, 3) });
                                    scope.timeRemainingClass = 'overdue';
                                } else {
                                    scope.timeRemaining = $translate.instant('mma.mod_assign.duedatereached');
                                }
                            } else {
                                var timeSubmittedDiff = scope.userSubmission.timemodified - duedate;
                                if (timeSubmittedDiff > 0) {
                                    scope.timeRemaining = $translate.instant('mma.mod_assign.submittedlate',
                                        {'$a': $mmUtil.formatDuration(timeSubmittedDiff, 2) });
                                    scope.timeRemainingClass = 'latesubmission';
                                } else {
                                    scope.timeRemaining = $translate.instant('mma.mod_assign.submittedearly',
                                        {'$a': $mmUtil.formatDuration(-timeSubmittedDiff, 2) });
                                    scope.timeRemainingClass = 'earlysubmission';
                                }
                            }
                        } else {
                            scope.timeRemaining = $mmUtil.formatDuration(timeRemaining, 3);
                        }
                    }
                    promises.push(feedbackController(scope, assign, response.feedback, courseId, moduleId, submitId));
                    if (!scope.userSubmission) {
                        scope.userSubmission = {};
                        scope.userSubmission.plugins = $mmaModAssignHelper.getPluginsEnabled(assign, 'assignsubmission');
                    }
                    promises.push($mmaModAssign.getUnsupportedEditPlugins(scope.userSubmission.plugins).then(function(list) {
                        scope.unsupportedEditPlugins = list;
                    }));
                    return $q.all(promises);
                }).catch(function(error) {
                    if (typeof error != "undefined") {
                        if (error == 'error/nopermission') {
                            $mmUtil.showModal('mm.core.notice', 'mma.mod_assign.errorshowinginformation');
                            return $q.when();
                        }
                        return $q.reject(error);
                    }
                    if (assign.duedate > 0) {
                        var time = $mmUtil.timestamp();
                        if (assign.duedate - time <= 0) {
                            scope.timeRemaining = $translate.instant('mma.mod_assign.duedatereached');
                        } else {
                            scope.timeRemaining = $mmUtil.formatDuration(assign.duedate - time, 3);
                        }
                    }
                    return $mmaModAssign.getSubmissions(assign.id).then(function(data) {
                        scope.canSubmit = !data.canviewsubmissions;
                        if (data.submissions) {
                            scope.userSubmission = false;
                            angular.forEach(data.submissions, function(submission) {
                                if (submission.userid == submitId) {
                                    scope.userSubmission = submission;
                                    scope.statusTranslated = $translate.instant('mma.mod_assign.submissionstatus_' +
                                        submission.status);
                                    scope.statusClass = $mmaModAssign.getSubmissionStatusClass(submission.status);
                                    scope.currentAttempt = scope.userSubmission.attemptnumber + 1;
                                    scope.submissionPlugins = submission.plugins;
                                }
                            });
                        }
                    });
                });
            }).catch(function(message) {
                $mmUtil.showErrorModalDefault(message, 'Error getting assigment data.');
                return $q.reject();
            }).finally(function() {
                scope.loaded = true;
            });
        };
    }
    return {
        scope: {
            courseid: '@',
            moduleid: '@',
            submitid: '@?',
            blindid: '@?',
            scrollHandle: '@?',
            showSubmission: '@?'
        },
        restrict: 'E',
        controller: controller,
        templateUrl: 'addons/mod/assign/templates/submission.html',
        link: function(scope, element, attributes, controller) {
            var moduleId = parseInt(attributes.moduleid, 10),
                courseId = parseInt(attributes.courseid, 10),
                submitId = parseInt(attributes.submitid, 10),
                blindId = parseInt(attributes.blindid, 10),
                blockData,
                obsInvalidated, obsManualSync, obsSubmitGrade;
            blockData = $mmUtil.blockLeaveView(scope, cancel);
            scope.isSubmittedForGrading = !!submitId;
            scope.statusNew = mmaModAssignSubmissionStatusNew;
            scope.statusReopened = mmaModAssignSubmissionStatusReopened;
            scope.showSubmission = typeof attributes.showSubmission != 'undefined' ? attributes.showSubmission : true;
            scope.submitId = submitId;
            scope.courseId = courseId;
            scope.blindId = blindId;
            scope.loaded = false;
            scope.submitModel = {};
            obsInvalidated = scope.$on(mmaModAssignSubmissionInvalidatedEvent, function() {
                invalidateAndRefresh();
            });
            obsManualSync = $mmEvents.on(mmaModAssignEventManualSynced, function(data) {
                if (data && scope.assign && data.siteid == $mmSite.getId() && data.assignid == scope.assign.id) {
                    controller.load(scope, moduleId, courseId, submitId, blindId);
                }
            });
            obsSubmitGrade = $mmEvents.on(mmaModAssignEventSubmitGrade, function() {
                submitGrade().then(function() {
                    if (!$ionicPlatform.isTablet()) {
                        blockData && blockData.back();
                    }
                });
            });
            $mmaModAssign.isSaveAndSubmitSupported().then(function(enabled) {
                scope.submitSupported = enabled;
            });
            scope.$on('$destroy', function() {
                obsInvalidated && obsInvalidated();
                obsManualSync && obsManualSync.off && obsManualSync.off();
                obsSubmitGrade && obsSubmitGrade.off && obsSubmitGrade.off();
                if (scope.assign && scope.isGrading) {
                    $mmSyncBlock.unblockOperation(mmaModAssignComponent, scope.assign.id);
                }
            });
            controller.load(scope, moduleId, courseId, submitId, blindId);
            scope.goToEdit = function() {
                $state.go('site.mod_assign-submission-edit', {
                    moduleid: moduleId,
                    courseid: courseId,
                    userid: submitId,
                    blindid: blindId
                });
            };
            scope.copyPrevious = function() {
                if (!$mmApp.isOnline()) {
                    $mmUtil.showErrorModal('mm.core.networkerrormsg', true);
                    return;
                }
                if (!scope.previousAttempt) {
                    scope.goToEdit();
                    return;
                }
                var modal = $mmUtil.showModalLoading(),
                    previousSubmission = $mmaModAssign.getSubmissionObjectFromAttempt(scope.assign, scope.previousAttempt);
                $mmaModAssignHelper.getSubmissionSizeForCopy(scope.assign, previousSubmission).catch(function() {
                    return -1;
                }).then(function(size) {
                    modal.dismiss();
                    return $mmFileUploaderHelper.confirmUploadFile(size, true);
                }).then(function() {
                    modal = $mmUtil.showModalLoading('mm.core.sending', true);
                    $mmaModAssignHelper.copyPreviousAttempt(scope.assign, previousSubmission).then(function() {
                        scope.goToEdit();
                        invalidateAndRefresh();
                        if (!scope.assign.submissiondrafts) {
                            $mmEvents.trigger(mmaModAssignSubmittedForGradingEvent, {
                                assignmentId: scope.assign.id,
                                submissionId: scope.userSubmission.id,
                                userId: $mmSite.getUserId(),
                                siteId: $mmSite.getId()
                            });
                        }
                    }).catch(function(err) {
                        alert(err);
                    }).finally(function() {
                        modal.dismiss();
                    });
                });
            };
            scope.showAdvancedGrade = function() {
                if (scope.feedback.advancedgrade) {
                    $mmText.expandText($translate.instant('mm.grades.grade'), scope.feedback.gradefordisplay, false,
                            mmaModAssignComponent, moduleId);
                }
            };
            scope.changeShowSubmission = function(show) {
                scope.showSubmission = show;
            };
            function submitGrade() {
                return hasDataToSave().then(function(modified) {
                    if (!modified) {
                        return $q.when();
                    }
                    var attemptNumber = scope.userSubmission ? scope.userSubmission.attemptnumber : -1,
                        outcomes = {},
                        modal,
                        pluginPromise,
                        grade = scope.grade.scale && scope.grade.grade == 0 ? -1 : $mmUtil.unformatFloat(scope.grade.grade);
                    if (grade === false) {
                        $mmUtil.showErrorModal('mm.grades.badgrade', true);
                        return $q.reject();
                    }
                    modal = $mmUtil.showModalLoading('mm.core.sending', true);
                    angular.forEach(scope.gradeInfo.outcomes, function(outcome) {
                        if (outcome.itemNumber) {
                            outcomes[outcome.itemNumber] = outcome.selectedId;
                        }
                    });
                    if (scope.feedback && scope.feedback.plugins) {
                        pluginPromise = $mmaModAssignHelper.prepareFeedbackPluginData(scope.assign.id, submitId, scope.feedback);
                    } else {
                        pluginPromise = $q.when({});
                    }
                    return pluginPromise.then(function(pluginData) {
                        return $mmaModAssign.submitGradingForm(scope.assign.id, submitId, grade, attemptNumber,
                                scope.grade.addAttempt, scope.grade.gradingStatus, scope.grade.applyToAll, outcomes, pluginData,
                                courseId).then(function() {
                            discardDrafts().finally(function() {
                                invalidateAndRefresh();
                                $mmEvents.trigger(mmaModAssignGradedEvent, {
                                    assignmentId: scope.assign.id,
                                    submissionId: submitId,
                                    userId: $mmSite.getUserId(),
                                    siteId: $mmSite.getId()
                                });
                            });
                        });
                    }).catch(function(error) {
                        $mmUtil.showErrorModal(error);
                    }).finally(function() {
                        scope.showSubmission = true;
                        modal.dismiss();
                    });
                });
            }
            scope.submitForGrading = function(acceptStatement) {
                if (scope.assign.requiresubmissionstatement && !acceptStatement) {
                    $mmUtil.showErrorModal('mma.mod_assign.acceptsubmissionstatement', true);
                    return $q.reject();
                }
                $mmUtil.showConfirm($translate('mma.mod_assign.confirmsubmission')).then(function() {
                    var modal = $mmUtil.showModalLoading('mm.core.sending', true);
                    $mmaModAssign.submitForGrading(scope.assign.id, courseId, acceptStatement,
                                scope.userSubmission.timemodified, scope.hasOffline).then(function() {
                        invalidateAndRefresh();
                        $mmEvents.trigger(mmaModAssignSubmittedForGradingEvent, {
                            assignmentId: scope.assign.id,
                            submissionId: scope.userSubmission.id,
                            userId: $mmSite.getUserId(),
                            siteId: $mmSite.getId()
                        });
                    }).catch(function(error) {
                        $mmUtil.showErrorModal(error);
                    }).finally(function() {
                        modal.dismiss();
                    });
                });
            };
            function invalidateAndRefresh() {
                scope.loaded = false;
                var promises = [$mmaModAssign.invalidateAssignmentData(courseId)];
                if (scope.assign) {
                    promises.push($mmaModAssign.invalidateSubmissionStatusData(scope.assign.id, submitId, !!blindId));
                    promises.push($mmaModAssign.invalidateAssignmentUserMappingsData(scope.assign.id));
                    promises.push($mmaModAssign.invalidateListParticipantsData(scope.assign.id));
                }
                promises.push($mmGrades.invalidateGradeModuleItems(courseId, submitId));
                promises.push($mmCourse.invalidateModule(moduleId));
                return $q.all(promises).finally(function() {
                    return controller.load(scope, moduleId, courseId, submitId, blindId);
                });
            }
            function hasDataToSave() {
                if (!scope.canSaveGrades) {
                    return $q.when(false);
                }
                var modified = originalGrades.grade != scope.grade.grade ||
                    originalGrades.addAttempt != scope.grade.addAttempt ||
                    originalGrades.applyToAll != scope.grade.applyToAll;
                if (scope.gradeInfo && scope.gradeInfo.outcomes) {
                    for (var x in scope.gradeInfo.outcomes) {
                        if (modified) {
                            return $q.when(true);
                        }
                        var outcome = scope.gradeInfo.outcomes[x];
                        modified = originalGrades.outcomes[outcome.id] == 'undefined' ||
                            originalGrades.outcomes[outcome.id] != outcome.selectedId;
                    }
                }
                if (modified) {
                    return $q.when(true);
                }
                if (scope.feedback && scope.feedback.plugins) {
                    return $mmaModAssignHelper.hasFeedbackDraftData(scope.assign.id, submitId, scope.feedback).catch(function() {
                        return $q.when(false);
                    });
                }
                return $q.when(false);
            }
            function discardDrafts() {
                if (scope.feedback && scope.feedback.plugins) {
                    return $mmaModAssignHelper.discardFeedbackPluginData(scope.assign.id, submitId, scope.feedback);
                }
                return $q.when();
            }
            function cancel() {
                return hasDataToSave().then(function(modified) {
                    if (modified) {
                        return $mmUtil.showConfirm($translate('mm.core.confirmcanceledit')).then(function() {
                            return discardDrafts().catch(function() {
                            });
                        });
                    }
                });
            }
        }
    };
}]);

angular.module('mm.addons.mod_assign')
.directive('mmaModAssignSubmissionPlugin', ["$compile", "$mmaModAssignSubmissionDelegate", "$mmaModAssign", "$mmaModAssignHelper", "mmaModAssignComponent", function($compile, $mmaModAssignSubmissionDelegate, $mmaModAssign, $mmaModAssignHelper,
            mmaModAssignComponent) {
    return {
        restrict: 'E',
        scope: {
            assign: '=',
            plugin: '=',
            submission: '=',
            edit: '@?',
            scrollHandle: '@?',
            allowOffline: '@?'
        },
        templateUrl: 'addons/mod/assign/templates/submissionplugin.html',
        link: function(scope, element, attributes) {
            var plugin = scope.plugin,
                container = element[0].querySelector('.mma-mod-assign-submission-container'),
                directive;
            if (!plugin || !container) {
                return;
            }
            plugin.name = $mmaModAssignSubmissionDelegate.getPluginName(plugin);
            if (!plugin.name) {
                return;
            }
            scope.assignComponent = mmaModAssignComponent;
            scope.edit = scope.edit && scope.edit !== 'false';
            scope.allowOffline = scope.allowOffline && scope.allowOffline !== 'false';
            directive = $mmaModAssignSubmissionDelegate.getDirectiveForPlugin(plugin, scope.edit);
            if (directive) {
                scope.configs = $mmaModAssignHelper.getPluginConfig(scope.assign, 'assignsubmission', plugin.type);
                container.setAttribute(directive, '');
                $compile(container)(scope);
            } else {
                scope.text = $mmaModAssign.getSubmissionPluginText(plugin);
                scope.files = $mmaModAssign.getSubmissionPluginAttachments(plugin);
                scope.notSupported = $mmaModAssignSubmissionDelegate.isPluginSupported(plugin.type);
            }
        }
    };
}]);

angular.module('mm.addons.mod_assign')
.controller('mmaModAssignDescriptionCtrl', ["$scope", "$stateParams", "mmaModAssignComponent", function($scope, $stateParams, mmaModAssignComponent) {
    $scope.description = $stateParams.description;
    $scope.moduleId = $stateParams.moduleid;
    $scope.assignComponent = mmaModAssignComponent;
    $scope.files = $stateParams.files;
}]);

angular.module('mm.addons.mod_assign')
.controller('mmaModAssignEditCtrl', ["$scope", "$stateParams", "$mmaModAssign", "$mmUtil", "$translate", "mmaModAssignComponent", "$q", "$mmSite", "$mmaModAssignHelper", "$timeout", "$mmEvents", "$mmaModAssignOffline", "$mmFileUploaderHelper", "$mmaModAssignSync", "mmaModAssignSubmissionSavedEvent", "mmaModAssignSubmittedForGradingEvent", "$mmSyncBlock", function($scope, $stateParams, $mmaModAssign, $mmUtil, $translate, mmaModAssignComponent, $q,
        $mmSite, $mmaModAssignHelper, $timeout, $mmEvents, $mmaModAssignOffline, $mmFileUploaderHelper, $mmaModAssignSync,
        mmaModAssignSubmissionSavedEvent, mmaModAssignSubmittedForGradingEvent, $mmSyncBlock) {
    var courseId = $stateParams.courseid,
        userId = $mmSite.getUserId(),
        isBlind = !!$stateParams.blindid,
        editStr = $translate.instant('mma.mod_assign.editsubmission'),
        saveOffline = false,
        hasOffline = false,
        blockData;
    blockData = $mmUtil.blockLeaveView($scope, leaveView);
    $scope.title = editStr;
    $scope.assignComponent = mmaModAssignComponent;
    $scope.courseId = courseId;
    $scope.moduleId = $stateParams.moduleid;
    $scope.allowOffline = false;
    function fetchAssignment() {
        var assign;
        return $mmaModAssign.getAssignment(courseId, $scope.moduleId).then(function(assignData) {
            assign = assignData;
            $scope.title = assign.name || $scope.title;
            $scope.assign = assign;
            if (!$scope.$$destroyed) {
                $mmSyncBlock.blockOperation(mmaModAssignComponent, assign.id);
            }
            return $mmaModAssignSync.waitForSync(assign.id);
        }).then(function() {
            return $mmaModAssign.getSubmissionStatus(assign.id, userId, isBlind, false, true).catch(function(error) {
                return $mmaModAssign.getSubmissionStatus(assign.id, userId, isBlind).then(function(response) {
                    var userSubmission = $mmaModAssign.getSubmissionObjectFromAttempt(assign, response.lastattempt);
                    if ($mmaModAssignHelper.canEditSubmissionOffline(assign, userSubmission)) {
                        return response;
                    }
                    $scope.allowOffline = false;
                    return $q.reject(error);
                });
            }).then(function(response) {
                if (!response.lastattempt.canedit) {
                    return $q.reject($translate.instant('mm.core.nopermissions', {$a: editStr}));
                }
                $scope.userSubmission = $mmaModAssign.getSubmissionObjectFromAttempt(assign, response.lastattempt);
                $scope.allowOffline = true;
                if (assign.requiresubmissionstatement && !assign.submissiondrafts && userId == $mmSite.getUserId()) {
                    $scope.submissionStatement = assign.submissionstatement;
                } else {
                    $scope.submissionStatement = false;
                }
                return $mmaModAssignOffline.getSubmission(assign.id, userId).then(function(data) {
                    hasOffline = data && data.plugindata && Object.keys(data.plugindata).length;
                }).catch(function() {
                    hasOffline = false;
                });
            });
        }).catch(function(message) {
            $mmUtil.showErrorModalDefault(message, 'Error getting assigment data.');
            blockData && blockData.back();
            return $q.reject();
        });
    }
    function getInputData() {
        return $mmaModAssignHelper.getAnswersFromForm(document.forms['mma-mod_assign-edit-form']);
    }
    function prepareSubmissionData(inputData) {
        saveOffline = hasOffline;
        return $mmaModAssignHelper.prepareSubmissionPluginData($scope.assign, $scope.userSubmission, inputData, hasOffline)
                .catch(function(e) {
            if ($scope.allowOffline && !saveOffline) {
                saveOffline = true;
                return $mmaModAssignHelper.prepareSubmissionPluginData($scope.assign, $scope.userSubmission, inputData, true);
            }
            return $q.reject(e);
        });
    }
    function hasDataChanged() {
        return $mmaModAssignHelper.hasSubmissionDataChanged($scope.assign, $scope.userSubmission, getInputData());
    }
    function saveSubmission() {
        var modal,
            inputData = getInputData();
        if ($scope.submissionStatement && !inputData.submissionstatement) {
            $mmUtil.showErrorModal('mma.mod_assign.acceptsubmissionstatement', true);
            return $q.reject();
        }
        modal = $mmUtil.showModalLoading();
        return $mmaModAssignHelper.getSubmissionSizeForEdit($scope.assign, $scope.userSubmission, inputData).catch(function() {
            return -1;
        }).then(function(size) {
            modal.dismiss();
            return $mmFileUploaderHelper.confirmUploadFile(size, true, $scope.allowOffline).catch(function(message) {
                if (message) {
                    $mmUtil.showErrorModal(message);
                }
                return $q.reject();
            });
        }).then(function() {
            modal = $mmUtil.showModalLoading('mm.core.sending', true);
            return prepareSubmissionData(inputData).then(function(pluginData) {
                if (!Object.keys(pluginData).length) {
                    return;
                }
                var assignId = $scope.assign.id,
                    timemod = $scope.userSubmission.timemodified,
                    drafts = $scope.assign.submissiondrafts,
                    promise;
                if (saveOffline) {
                    promise = $mmaModAssignOffline.saveSubmission(assignId, courseId, pluginData, timemod, !drafts, userId);
                } else {
                    promise = $mmaModAssign.saveSubmission(
                                assignId, courseId, pluginData, $scope.allowOffline, timemod, drafts, userId);
                }
                return promise.then(function() {
                    var params = {
                        assignmentId: assignId,
                        submissionId: $scope.userSubmission.id,
                        userId: userId,
                        siteId: $mmSite.getId()
                    };
                    $mmEvents.trigger(mmaModAssignSubmissionSavedEvent, params);
                    if (!drafts) {
                        $mmEvents.trigger(mmaModAssignSubmittedForGradingEvent, params);
                    }
                });
            }).catch(function(message) {
                $mmUtil.showErrorModalDefault(message, 'Error saving submission.');
                return $q.reject();
            }).finally(function() {
                modal.dismiss();
            });
        });
    }
    function leaveView() {
        var modal,
            showModal = true;
        $timeout(function() {
            if (showModal) {
                modal = $mmUtil.showModalLoading();
            }
        }, 100);
        return hasDataChanged().then(function(changed) {
           if (modal) {
                modal.dismiss();
            } else {
                showModal = false;
            }
            if (changed) {
                return $mmUtil.showConfirm($translate('mm.core.confirmcanceledit'));
            }
        }).then(function() {
            $mmaModAssignHelper.clearSubmissionPluginTmpData($scope.assign, $scope.userSubmission, getInputData());
        }).catch(function(message) {
            if (message) {
                $mmUtil.showErrorModal(message);
            }
            return $q.reject();
        }).finally(function() {
           if (modal) {
                modal.dismiss();
            } else {
                showModal = false;
            }
        });
    }
    fetchAssignment().finally(function() {
        $scope.assignmentLoaded = true;
    });
    $scope.save = function() {
        hasDataChanged().then(function(changed) {
            if (changed) {
                saveSubmission().then(function() {
                    blockData && blockData.back();
                });
            } else {
                blockData && blockData.back();
            }
        });
    };
    $scope.$on('$destroy', function() {
        if ($scope.assign) {
            $mmSyncBlock.unblockOperation(mmaModAssignComponent, $scope.assign.id);
        }
    });
}]);

angular.module('mm.addons.mod_assign')
.controller('mmaModAssignFeedbackEditCtrl', ["$scope", "$stateParams", "$mmaModAssignHelper", "$q", "$mmUtil", "$translate", "$mmSite", "$mmaModAssignFeedbackDelegate", "$mmEvents", "mmaModAssignFeedbackSavedEvent", function($scope, $stateParams, $mmaModAssignHelper, $q, $mmUtil, $translate, $mmSite,
        $mmaModAssignFeedbackDelegate, $mmEvents, mmaModAssignFeedbackSavedEvent) {
    var blockData = $mmUtil.blockLeaveView($scope, leaveView);
    $scope.assign = $stateParams.assign;
    $scope.plugin = $stateParams.plugin;
    $scope.userId = $stateParams.userid;
    $scope.submission = $stateParams.submission;
    function leaveView() {
        return hasDataChanged().then(function(changed) {
            if (changed) {
                return $mmUtil.showConfirm($translate('mm.core.confirmcanceledit'));
            }
        }).catch(function(message) {
            if (message) {
                $mmUtil.showErrorModal(message);
            }
            return $q.reject();
        });
    }
    function getInputData() {
        return $mmaModAssignHelper.getAnswersFromForm(document.forms['mma-mod_assign-edit-form']);
    }
    function hasDataChanged() {
        return $mmaModAssignFeedbackDelegate.hasPluginDataChanged($scope.assign, $scope.plugin, getInputData()).catch(function() {
            return true;
        });
    }
    function saveFeedback() {
        return $mmaModAssignFeedbackDelegate.getFeedbackDataToDraft($scope.plugin, getInputData()).then(function(pluginData) {
            if (!pluginData) {
                return;
            }
            var assignId = $scope.assign.id;
            return $mmaModAssignFeedbackDelegate.saveFeedbackDraft(assignId, $scope.userId, $scope.plugin, pluginData)
                    .then(function() {
                var params = {
                    assignmentId: assignId,
                    userId: $scope.userId,
                    pluginType: $scope.plugin.type,
                    siteId: $mmSite.getId()
                };
                $mmEvents.trigger(mmaModAssignFeedbackSavedEvent, params);
            });
        }).catch(function(message) {
            $mmUtil.showErrorModalDefault(message, 'Error saving feedback.');
            return $q.reject();
        });
    }
    $scope.done = function() {
        hasDataChanged().then(function(changed) {
            if (changed) {
                saveFeedback().then(function() {
                    blockData && blockData.back();
                });
            } else {
                blockData && blockData.back();
            }
        });
    };
}]);

angular.module('mm.addons.mod_assign')
.controller('mmaModAssignIndexCtrl', ["$scope", "$stateParams", "$mmaModAssign", "$mmUtil", "$mmCourseHelper", "$mmaModAssignOffline", "mmaModAssignComponent", "$q", "$state", "mmaModAssignSubmissionInvalidatedEvent", "$mmEvents", "$mmSite", "mmaModAssignGradedEvent", "mmaModAssignSubmissionSavedEvent", "$mmCourse", "$mmApp", "mmaModAssignSubmittedForGradingEvent", "$mmaModAssignSync", "$mmText", "mmaModAssignEventAutomSynced", "$ionicScrollDelegate", "mmCoreEventOnlineStatusChanged", "mmaModAssignEventManualSynced", "mmaModAssignSubmissionStatusSubmitted", "mmaModAssignSubmissionStatusDraft", "mmaModAssignNeedGrading", "$translate", "$mmGroups", function($scope, $stateParams, $mmaModAssign, $mmUtil, $mmCourseHelper, $mmaModAssignOffline,
        mmaModAssignComponent, $q, $state, mmaModAssignSubmissionInvalidatedEvent, $mmEvents, $mmSite, mmaModAssignGradedEvent,
        mmaModAssignSubmissionSavedEvent, $mmCourse, $mmApp, mmaModAssignSubmittedForGradingEvent, $mmaModAssignSync, $mmText,
        mmaModAssignEventAutomSynced, $ionicScrollDelegate, mmCoreEventOnlineStatusChanged, mmaModAssignEventManualSynced,
        mmaModAssignSubmissionStatusSubmitted, mmaModAssignSubmissionStatusDraft, mmaModAssignNeedGrading, $translate, $mmGroups) {
    var module = $stateParams.module || {},
        courseId = $stateParams.courseid,
        siteId = $mmSite.getId(),
        userId = $mmSite.getUserId(),
        scrollView, obsSaved, obsSubmitted, syncObserver, onlineObserver, obsGraded;
    $scope.title = module.name;
    $scope.description = module.description;
    $scope.assignComponent = mmaModAssignComponent;
    $scope.moduleUrl = module.url;
    $scope.courseid = courseId;
    $scope.moduleid = module.id;
    $scope.refreshIcon = 'spinner';
    $scope.syncIcon = 'spinner';
    $scope.moduleName = $mmCourse.translateModuleName('assign');
    $scope.mmaModAssignSubmissionStatusSubmitted = mmaModAssignSubmissionStatusSubmitted;
    $scope.mmaModAssignSubmissionStatusDraft = mmaModAssignSubmissionStatusDraft;
    $scope.mmaModAssignNeedGrading = mmaModAssignNeedGrading;
    $scope.showNumbers = true;
    $mmaModAssign.isSaveAndSubmitSupported().then(function(enabled) {
        $scope.submitSupported = enabled;
    });
    $scope.gotoSubmissionList = function(status, count) {
        if (typeof status == 'undefined') {
            $state.go('site.mod_assign-submission-list', {courseid: courseId, moduleid: module.id, modulename: module.name});
        } else if (count || !$scope.showNumbers) {
            $state.go('site.mod_assign-submission-list', {status: status, courseid: courseId, moduleid: module.id, modulename: module.name});
        }
    };
    function fetchAssignment(refresh, sync, showErrors) {
        $scope.isOnline = $mmApp.isOnline();
        var assign;
        return $mmaModAssign.getAssignment(courseId, module.id).then(function(assignData) {
            assign = assignData;
            $scope.title = assign.name || $scope.title;
            $scope.description = assign.intro || $scope.description;
            $scope.assign = assign;
            if (sync) {
                return syncAssign(showErrors).catch(function() {
                });
            }
        }).then(function() {
            return $mmaModAssignOffline.hasAssignOfflineData(assign.id);
        }).then(function(hasOffline) {
            $scope.hasOffline = hasOffline;
            return $mmaModAssign.getSubmissions(assign.id).then(function(data) {
                var time = $mmUtil.timestamp();
                $scope.canviewsubmissions = data.canviewsubmissions;
                if (data.canviewsubmissions) {
                    if (assign.duedate > 0) {
                        if (assign.duedate - time <= 0) {
                            $scope.timeRemaining = $translate.instant('mma.mod_assign.assignmentisdue');
                        } else {
                            $scope.timeRemaining = $mmUtil.formatDuration(assign.duedate - time, 3);
                            if (assign.cutoffdate) {
                                if (assign.cutoffdate > time) {
                                    $scope.lateSubmissions = $translate.instant('mma.mod_assign.latesubmissionsaccepted',
                                        {'$a': moment(assign.cutoffdate*1000).format($translate.instant('mm.core.dfmediumdate'))});
                                } else {
                                    $scope.lateSubmissions = $translate.instant('mma.mod_assign.nomoresubmissionsaccepted');
                                }
                            }
                        }
                    }
                    return $mmGroups.activityHasGroups(assign.cmid).then(function(hasGroups) {
                        $scope.showNumbers = !hasGroups;
                        return $mmaModAssign.getSubmissionStatus(assign.id).then(function(response) {
                            $scope.summary = response.gradingsummary;
                            $scope.needsGradingAvalaible = response.gradingsummary.submissionsneedgradingcount > 0 &&
                                $mmSite.isVersionGreaterEqualThan('3.2');
                        }).catch(function() {
                            return $q.when();
                        });
                    });
                }
            });
        }).then(function() {
            $mmCourseHelper.fillContextMenu($scope, module, courseId, refresh, mmaModAssignComponent);
        }).catch(function(message) {
            if (!refresh && !assign) {
                return refreshAllData(sync, showErrors);
            }
            $mmUtil.showErrorModalDefault(message, 'Error getting assigment data.');
            return $q.reject();
        });
    }
    function refreshAllData(sync, showErrors) {
        var promises = [$mmaModAssign.invalidateAssignmentData(courseId)];
        if ($scope.assign) {
            promises.push($mmaModAssign.invalidateAllSubmissionData($scope.assign.id));
            if ($scope.canviewsubmissions) {
                promises.push($mmaModAssign.invalidateSubmissionStatusData($scope.assign.id));
            }
        }
        return $q.all(promises).finally(function() {
            $scope.$broadcast(mmaModAssignSubmissionInvalidatedEvent);
            return fetchAssignment(true, sync, showErrors);
        });
    }
    fetchAssignment(false, true, false).then(function() {
        $mmaModAssign.logView($scope.assign.id).then(function() {
            $mmCourse.checkModuleCompletion(courseId, module.completionstatus);
        }).catch(function() {
        });
        if (!$scope.canviewsubmissions) {
            $mmaModAssign.logSubmissionView($scope.assign.id).catch(function() {
            });
        } else {
            $mmaModAssign.logGradingView($scope.assign.id).catch(function() {
            });
        }
    }).finally(function() {
        $scope.assignmentLoaded = true;
        $scope.refreshIcon = 'ion-refresh';
        $scope.syncIcon = 'ion-loop';
    });
    $scope.removeFiles = function() {
        $mmCourseHelper.confirmAndRemove(module, courseId);
    };
    $scope.prefetch = function() {
        $mmCourseHelper.contextMenuPrefetch($scope, module, courseId);
    };
    $scope.expandDescription = function() {
        if ($scope.assign.id && ($scope.description || $scope.assign.introattachments)) {
            $state.go('site.mod_assign-description', {
                moduleid: module.id,
                description: $scope.description,
                files: $scope.assign.introattachments
            });
        }
    };
    $scope.refreshAssignment = function(showErrors) {
        if ($scope.assignmentLoaded) {
            $scope.refreshIcon = 'spinner';
            $scope.syncIcon = 'spinner';
            return refreshAllData(true, showErrors).finally(function() {
                $scope.refreshIcon = 'ion-refresh';
                $scope.syncIcon = 'ion-loop';
                $scope.$broadcast('scroll.refreshComplete');
            });
        }
    };
    function syncAssign(showErrors) {
        return $mmaModAssignSync.syncAssign($scope.assign.id).then(function(result) {
            if (result.warnings && result.warnings.length) {
                $mmUtil.showErrorModal($mmText.buildMessage(result.warnings));
            }
            if (result.updated) {
                $mmEvents.trigger(mmaModAssignEventManualSynced, {
                    siteid: $mmSite.getId(),
                    assignid: $scope.assign.id,
                    warnings: result.warnings
                });
            }
            return result.updated;
        }).catch(function(error) {
            if (showErrors) {
                if (error) {
                    $mmUtil.showErrorModal(error);
                } else {
                    $mmUtil.showErrorModal('mm.core.errorsync', true);
                }
            }
            return $q.reject();
        });
    }
    function showSpinnerAndRefresh(sync, showErrors) {
        $scope.refreshIcon = 'spinner';
        $scope.syncIcon = 'spinner';
        $scope.assignmentLoaded = false;
        scrollTop();
        refreshAllData(sync, showErrors).finally(function() {
            $scope.refreshIcon = 'ion-refresh';
            $scope.syncIcon = 'ion-loop';
            $scope.assignmentLoaded = true;
        });
    }
    function scrollTop() {
        if (!scrollView) {
            scrollView = $ionicScrollDelegate.$getByHandle('mmaModAssignIndexScroll');
        }
        scrollView && scrollView.scrollTop && scrollView.scrollTop();
    }
    obsSaved = $mmEvents.on(mmaModAssignSubmissionSavedEvent, function(data) {
        if ($scope.assign && data.assignmentId == $scope.assign.id && data.siteId == siteId && data.userId == userId) {
            showSpinnerAndRefresh(true, false);
        }
    });
    obsSubmitted = $mmEvents.on(mmaModAssignSubmittedForGradingEvent, function(data) {
        if ($scope.assign && data.assignmentId == $scope.assign.id && data.siteId == siteId && data.userId == userId) {
            $mmCourse.checkModuleCompletion(courseId, module.completionstatus);
        }
    });
    obsGraded = $mmEvents.on(mmaModAssignGradedEvent, function(data) {
        if ($scope.assign && data.assignmentId == $scope.assign.id && data.siteId == siteId && data.userId == userId) {
            showSpinnerAndRefresh(true, false);
        }
    });
    syncObserver = $mmEvents.on(mmaModAssignEventAutomSynced, function(data) {
        if (data && $scope.assign && data.siteid == $mmSite.getId() && data.assignid == $scope.assign.id) {
            if (data.warnings && data.warnings.length) {
                $mmUtil.showErrorModal($mmText.buildMessage(data.warnings));
            }
            showSpinnerAndRefresh(false, false);
        }
    });
    onlineObserver = $mmEvents.on(mmCoreEventOnlineStatusChanged, function(online) {
        $scope.isOnline = online;
    });
    $scope.$on('$destroy', function() {
        obsSaved && obsSaved.off && obsSaved.off();
        obsSubmitted && obsSubmitted.off && obsSubmitted.off();
        obsGraded  && obsGraded.off && obsGraded.off();
        syncObserver && syncObserver.off && syncObserver.off();
        onlineObserver && onlineObserver.off && onlineObserver.off();
    });
}]);

angular.module('mm.addons.mod_assign')
.controller('mmaModAssignSubmissionListCtrl', ["$scope", "$stateParams", "$mmaModAssign", "$mmUtil", "$translate", "$q", "$mmEvents", "mmaModAssignComponent", "mmaModAssignSubmissionInvalidatedEvent", "mmaModAssignSubmissionStatusSubmitted", "$mmaModAssignOffline", "mmaModAssignNeedGrading", "mmaModAssignGradedEvent", "$mmSite", "$mmaModAssignHelper", function($scope, $stateParams, $mmaModAssign, $mmUtil, $translate, $q, $mmEvents,
        mmaModAssignComponent, mmaModAssignSubmissionInvalidatedEvent, mmaModAssignSubmissionStatusSubmitted, $mmaModAssignOffline,
        mmaModAssignNeedGrading, mmaModAssignGradedEvent, $mmSite, $mmaModAssignHelper) {
    var courseId = $stateParams.courseid,
        selectedStatus = $stateParams.status,
        obsGraded;
    if (selectedStatus) {
        if (selectedStatus == mmaModAssignNeedGrading) {
            $scope.title = $translate.instant('mma.mod_assign.numberofsubmissionsneedgrading');
        } else {
            $scope.title = $translate.instant('mma.mod_assign.submissionstatus_' + selectedStatus);
        }
    } else {
        $scope.title = $translate.instant('mma.mod_assign.numberofparticipants');
    }
    $scope.assignComponent = mmaModAssignComponent;
    $scope.courseId = courseId;
    $scope.moduleId = $stateParams.moduleid;
    function fetchAssignment() {
        return $mmaModAssign.getAssignment(courseId, $scope.moduleId).then(function(assign) {
            $scope.title = assign.name || $scope.title;
            $scope.assign = assign;
            $scope.haveAllParticipants = true;
            return $mmaModAssign.getSubmissions(assign.id).then(function(data) {
                var participants = false,
                    blindMarking = assign.blindmarking && !assign.revealidentities;
                if (!data.canviewsubmissions) {
                    return $q.reject();
                }
                return $mmaModAssignHelper.getParticipants(assign).then(function(p) {
                    $scope.haveAllParticipants = true;
                    participants = p;
                }).catch(function() {
                    $scope.haveAllParticipants = false;
                    return $q.when();
                }).finally(function() {
                    return $mmaModAssign.getSubmissionsUserData(data.submissions, courseId, assign.id, blindMarking, participants)
                            .then(function(submissions) {
                        var searchStatus = mmaModAssignNeedGrading == selectedStatus ?
                                mmaModAssignSubmissionStatusSubmitted : selectedStatus,
                            promises = [];
                        $scope.submissions = [];
                        angular.forEach(submissions, function(submission) {
                            if (!searchStatus || searchStatus == submission.status) {
                                promises.push($mmaModAssignOffline.getSubmissionGrade(assign.id, submission.userid)
                                        .catch(function() {
                                }).then(function(data) {
                                    var promise,
                                        notSynced = false;
                                    if (data && submission.timemodified < data.timemodified) {
                                        notSynced = true;
                                    }
                                    if (mmaModAssignNeedGrading == selectedStatus) {
                                        promise = $mmaModAssign.needsSubmissionToBeGraded(submission, assign.id);
                                    } else {
                                        promise = $q.when(true);
                                    }
                                    return promise.then(function(add) {
                                        if (!add) {
                                            return;
                                        }
                                        submission.statusClass = $mmaModAssign.getSubmissionStatusClass(submission.status);
                                        submission.gradingClass =
                                            $mmaModAssign.getSubmissionGradingStatusClass(submission.gradingstatus);
                                        if (submission.statusClass != 'badge-balanced' || !submission.gradingstatus) {
                                            submission.statusTranslated = $translate.instant('mma.mod_assign.submissionstatus_' +
                                                submission.status);
                                        } else {
                                            submission.statusTranslated = false;
                                        }
                                        if (notSynced) {
                                            submission.gradingStatusTranslationId = 'mma.mod_assign.gradenotsynced';
                                            submission.gradingClass = "";
                                        } else if (submission.statusClass != 'badge-assertive' ||
                                                submission.gradingClass != 'badge-assertive') {
                                            submission.gradingStatusTranslationId =
                                                $mmaModAssign.getSubmissionGradingStatusTranslationId(submission.gradingstatus);
                                        } else {
                                            submission.gradingStatusTranslationId = false;
                                        }
                                        $scope.submissions.push(submission);
                                    });
                                }));
                            }
                        });
                        return $q.all(promises);
                    });
                });
            });
        }).catch(function(message) {
            $mmUtil.showErrorModalDefault(message, 'Error getting assigment data.');
            return $q.reject();
        });
    }
    function refreshAllData() {
        var promises = [$mmaModAssign.invalidateAssignmentData(courseId)];
        if ($scope.assign) {
            promises.push($mmaModAssign.invalidateAllSubmissionData($scope.assign.id));
            promises.push($mmaModAssign.invalidateAssignmentUserMappingsData($scope.assign.id));
            promises.push($mmaModAssign.invalidateListParticipantsData($scope.assign.id));
        }
        return $q.all(promises).finally(function() {
            $scope.$broadcast(mmaModAssignSubmissionInvalidatedEvent);
            return fetchAssignment();
        });
    }
    fetchAssignment().finally(function() {
        $scope.assignmentLoaded = true;
    });
    obsGraded = $mmEvents.on(mmaModAssignGradedEvent, function(data) {
        if ($scope.assign && data.assignmentId == $scope.assign.id && data.siteId == $mmSite.getId() &&
                data.userId == $mmSite.getUserId()) {
            refreshAllData();
        }
    });
    $scope.refreshSubmissionList = function() {
        refreshAllData().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
    $scope.$on('$destroy', function() {
        obsGraded && obsGraded.off && obsGraded.off();
    });
}]);

angular.module('mm.addons.mod_assign')
.controller('mmaModAssignSubmissionReviewCtrl', ["$scope", "$stateParams", "$q", "$mmaModAssign", "$mmCourse", "$mmEvents", "mmaModAssignSubmissionInvalidatedEvent", "mmaModAssignEventSubmitGrade", function($scope, $stateParams, $q, $mmaModAssign, $mmCourse, $mmEvents,
        mmaModAssignSubmissionInvalidatedEvent, mmaModAssignEventSubmitGrade) {
    var assign,
        blindMarking;
    $scope.courseid = $stateParams.courseid;
    $scope.moduleid = $stateParams.moduleid;
    $scope.submitid = $stateParams.submitid;
    $scope.blindid = $stateParams.blindid;
    $scope.showSubmission = typeof $stateParams.showSubmission != 'undefined' ? $stateParams.showSubmission : true;
    function fetchSubmission() {
        return $mmaModAssign.getAssignment($scope.courseid, $scope.moduleid).then(function(assignment) {
            assign = assignment;
            $scope.title = assign.name;
            blindMarking = assign.blindmarking && !assign.revealidentities;
            return $mmaModAssign.isGradingEnabled().then(function(enabled) {
                if (enabled) {
                    return $mmCourse.getModuleBasicGradeInfo($scope.moduleid).then(function(gradeInfo) {
                        if (gradeInfo) {
                            if (gradeInfo.advancedgrading && gradeInfo.advancedgrading[0] &&
                                    typeof gradeInfo.advancedgrading[0].method != 'undefined') {
                                var method = gradeInfo.advancedgrading[0].method || 'simple';
                                $scope.canSaveGrades = method == 'simple';
                            } else {
                                $scope.canSaveGrades = true;
                            }
                        }
                    });
                }
            });
        });
    }
    $scope.submitGrade = function() {
        $mmEvents.trigger(mmaModAssignEventSubmitGrade);
    };
    function refreshAllData() {
        var promises = [$mmaModAssign.invalidateAssignmentData($scope.courseid)];
        if (assign) {
            promises.push($mmaModAssign.invalidateSubmissionData(assign.id));
            promises.push($mmaModAssign.invalidateAssignmentUserMappingsData(assign.id));
            promises.push($mmaModAssign.invalidateSubmissionStatusData(assign.id, $scope.submitid, blindMarking));
        }
        return $q.all(promises).finally(function() {
            $scope.$broadcast(mmaModAssignSubmissionInvalidatedEvent);
            return fetchSubmission();
        });
    }
    fetchSubmission().finally(function() {
        $scope.assignmentSubmissionLoaded = true;
    });
    $scope.refreshSubmission = function() {
        refreshAllData().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
}]);

angular.module('mm.addons.mod_assign')
.factory('$mmaModAssign', ["$mmSite", "$q", "$mmUser", "$mmSitesManager", "mmaModAssignComponent", "$mmFilepool", "$mmComments", "$mmUtil", "$mmaModAssignSubmissionDelegate", "mmaModAssignSubmissionStatusNew", "mmaModAssignSubmissionStatusSubmitted", "$mmText", "$mmApp", "$mmaModAssignOffline", "mmaModAssignGradingStatusGraded", "mmaModAssignGradingStatusNotGraded", "$mmGrades", "mmaModMarkingWorkflowStateReleased", function($mmSite, $q, $mmUser, $mmSitesManager, mmaModAssignComponent, $mmFilepool, $mmComments, $mmUtil,
        $mmaModAssignSubmissionDelegate, mmaModAssignSubmissionStatusNew, mmaModAssignSubmissionStatusSubmitted, $mmText, $mmApp,
        $mmaModAssignOffline, mmaModAssignGradingStatusGraded, mmaModAssignGradingStatusNotGraded, $mmGrades,
        mmaModMarkingWorkflowStateReleased) {
    var self = {},
        gradingOfflineEnabled = {};
        self.canSubmitOffline = function(assign, submissionStatus) {
        if (!self.isSubmissionOpen(assign, submissionStatus)) {
            return false;
        }
        var userSubmission = submissionStatus.lastattempt.submission,
            teamSubmission = submissionStatus.lastattempt.teamsubmission;
        if (teamSubmission) {
            if (teamSubmission.status === mmaModAssignSubmissionStatusSubmitted) {
                return false;
            } else if (userSubmission && userSubmission.status === mmaModAssignSubmissionStatusSubmitted) {
                return false;
            } else if (assign.preventsubmissionnotingroup && !submissionStatus.lastattempt.submissiongroup) {
                return false;
            }
        } else if (userSubmission) {
            if (userSubmission.status === mmaModAssignSubmissionStatusSubmitted) {
                return false;
            }
        } else {
            return false;
        }
        return assign.submissiondrafts;
    };
        function getAssignmentCacheKey(courseId) {
        return 'mmaModAssign:assignment:' + courseId;
    }
        function getAssignmentUserMappingsCacheKey(assignmentId) {
        return 'mmaModAssign:usermappings:' + assignmentId;
    }
        function getSubmissionsCacheKey(assignId) {
        return 'mmaModAssign:submissions:' + assignId;
    }
        function listParticipantsCacheKey(assignId, groupId) {
        return listParticipantsPrefixCacheKey(assignId) + ':' + groupId;
    }
        function listParticipantsPrefixCacheKey(assignId) {
        return 'mmaModAssign:participants:' + assignId;
    }
        function getSubmissionStatusCacheKey(assignId, userId, isBlind) {
        if (!userId) {
            isBlind = 0;
            userId = $mmSite.getUserId();
        }
        isBlind = isBlind ? 1 : 0;
        return getSubmissionsCacheKey(assignId) + ':' + userId + ':' + isBlind;
    }
        function getAssignment(siteId, courseId, key, value) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    'courseids': [courseId]
                },
                preSets = {
                    cacheKey: getAssignmentCacheKey(courseId)
                };
            return site.read('mod_assign_get_assignments', params, preSets).then(function(response) {
                if (response.courses && response.courses.length) {
                    var assignments = response.courses[0].assignments;
                    for (var i = 0; i < assignments.length; i++) {
                        if (assignments[i][key] == value) {
                            return assignments[i];
                        }
                    }
                }
                return $q.reject();
            });
        });
    }
        self.getAssignment = function(courseId, cmId, siteId) {
        return getAssignment(siteId, courseId, 'cmid', cmId);
    };
        self.getAssignmentById = function(courseId, id, siteId) {
        return getAssignment(siteId, courseId, 'id', id);
    };
        self.getAssignmentUserMappings = function(assignmentId, userId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    "assignmentids": [assignmentId]
                },
                preSets = {
                    cacheKey: getAssignmentUserMappingsCacheKey(assignmentId)
                };
            return site.read('mod_assign_get_user_mappings', params, preSets).then(function(response) {
                if (userId && userId > 0 && response.assignments && response.assignments.length) {
                    var assignment = response.assignments[0];
                    if (assignment.assignmentid == assignmentId) {
                        var mappings = assignment.mappings;
                        for (var i = 0; i < mappings.length; i++) {
                            if (mappings[i].userid == userId) {
                                return mappings[i].id;
                            }
                        }
                    }
                }
                return $q.reject();
            });
        });
    };
        self.getSubmissionObjectFromAttempt = function(assign, attempt) {
        return assign.teamsubmission ? attempt.teamsubmission : attempt.submission;
    };
        self.getSubmissionPluginAttachments = function(submissionPlugin) {
        var files = [];
        if (submissionPlugin.fileareas) {
            angular.forEach(submissionPlugin.fileareas, function(filearea) {
                angular.forEach(filearea.files, function(file) {
                    var filename;
                    if (file.filename) {
                        filename = file.filename;
                    } else {
                        filename = file.filepath[0] == '/' ? file.filepath.substr(1) : file.filepath;
                    }
                    files.push({
                        'filename' : filename,
                        'fileurl': file.fileurl
                    });
                });
            });
        }
        return files;
    };
        self.getSubmissionPluginText = function(submissionPlugin, keepUrls) {
        var text = '';
        if (submissionPlugin.editorfields) {
            angular.forEach(submissionPlugin.editorfields, function(field) {
                text += field.text;
            });
            if (!keepUrls && submissionPlugin.fileareas && submissionPlugin.fileareas[0]) {
                text = $mmText.replacePluginfileUrls(text, submissionPlugin.fileareas[0].files);
            }
        }
        return text;
    };
        self.getSubmissions = function(assignId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    "assignmentids": [assignId]
                },
                preSets = {
                    cacheKey: getSubmissionsCacheKey(assignId)
                };
            return site.read('mod_assign_get_submissions', params, preSets).then(function(response) {
                if (response.warnings.length > 0 && response.warnings[0].warningcode == 1) {
                    return {canviewsubmissions: false};
                }
                if (response.assignments && response.assignments.length) {
                    return {
                        canviewsubmissions: true,
                        submissions: response.assignments[0].submissions
                    };
                }
                return $q.reject();
            });
        });
    };
    function getParticipantFromUserId(participants, id) {
        if (participants) {
            for (var x in participants) {
                if (participants[x].id == id) {
                    var participant = participants[x];
                    delete participants[x];
                    return participant;
                }
            }
        }
        return false;
    }
        self.getSubmissionsUserData = function(submissions, courseId, assignId, blind, participants) {
        var promises = [],
            subs = [];
        if (participants && participants.length == 0) {
            participants = false;
        }
        angular.forEach(submissions, function(submission) {
            submission.submitid = submission.userid > 0 ? submission.userid : submission.blindid;
            if (submission.submitid <= 0) {
                return;
            }
            var participant = getParticipantFromUserId(participants, submission.submitid);
            if (participants && !participant) {
                return;
            }
            if (participant) {
                if (!blind) {
                    submission.userfullname = participant.fullname;
                    submission.userprofileimageurl = participant.profileimageurl;
                }
                submission.manyGroups = !!participant.groups && participant.groups.length > 1;
                if (participant.groupname) {
                    submission.groupid = participant.groupid;
                    submission.groupname = participant.groupname;
                }
            }
            var promise = $q.when();
            if (submission.userid > 0) {
                if (blind) {
                    delete submission.userid;
                    promise = self.getAssignmentUserMappings(assignId, submission.submitid).then(function(blindId) {
                        submission.blindid = blindId;
                    }).catch(function() {
                    });
                } else if (!participant) {
                    promise = $mmUser.getProfile(submission.userid, courseId, true).then(function(user) {
                        submission.userfullname = user.fullname;
                        submission.userprofileimageurl = user.profileimageurl;
                    }).catch(function() {
                    });
                }
            }
            promises.push(promise.then(function() {
                if (submission.userfullname || submission.blindid) {
                    subs.push(submission);
                }
            }));
        });
        return $q.all(promises).then(function() {
            if (participants) {
                angular.forEach(participants, function(participant) {
                    var submission = {
                        submitid: participant.id
                    };
                    if (!blind) {
                        submission.userid = participant.id;
                        submission.userfullname = participant.fullname;
                        submission.userprofileimageurl = participant.profileimageurl;
                    } else {
                        submission.blindid = participant.id;
                    }
                    if (participant.groupname) {
                        submission.groupid = participant.groupid;
                        submission.groupname = participant.groupname;
                    }
                    submission.status = participant.submitted ? mmaModAssignSubmissionStatusSubmitted : mmaModAssignSubmissionStatusNew;
                    subs.push(submission);
                });
            }
            return subs;
        });
    };
        self.getUnsupportedEditPlugins = function(plugins) {
        var notSupported = [],
            promises = [];
        angular.forEach(plugins, function(plugin) {
            promises.push($q.when($mmaModAssignSubmissionDelegate.isPluginSupportedForEdit(plugin.type)).then(function(enabled) {
                if (!enabled) {
                    notSupported.push(plugin.name);
                }
            }));
        });
        return $q.all(promises).then(function() {
            return notSupported;
        });
    };
        self.listParticipants = function(assignId, groupId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            if (!site.wsAvailable('mod_assign_list_participants')) {
                return $q.reject();
            }
            groupId = groupId || 0;
            var params = {
                    "assignid": assignId,
                    "groupid": groupId,
                    "filter": "",
                },
                preSets = {
                    cacheKey: listParticipantsCacheKey(assignId, groupId)
                };
            return site.read('mod_assign_list_participants', params, preSets);
        });
    };
        self.getSubmissionStatus = function(assignId, userId, isBlind, filter, ignoreCache, siteId) {
        if (typeof filter == 'undefined') {
            filter = true;
        }
        return $mmSitesManager.getSite(siteId).then(function(site) {
            if (!site.wsAvailable('mod_assign_get_submission_status')) {
                return $q.reject();
            }
            userId = userId || 0;
            var params = {
                    assignid: assignId,
                    userid: userId
                },
                preSets = {
                    cacheKey: getSubmissionStatusCacheKey(assignId, userId, isBlind),
                    getCacheUsingCacheKey: true,
                    filter: filter,
                    rewriteurls: filter
                };
            if (ignoreCache) {
                preSets.getFromCache = 0;
                preSets.emergencyCache = 0;
            }
            if (!filter) {
                preSets.saveToCache = 0;
            }
            return site.read('mod_assign_get_submission_status', params, preSets);
        });
    };
        self.invalidateAssignmentData = function(courseId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getAssignmentCacheKey(courseId));
        });
    };
        self.invalidateAssignmentUserMappingsData = function(assignmentId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getAssignmentUserMappingsCacheKey(assignmentId));
        });
    };
        self.invalidateSubmissionData = function(assignId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getSubmissionsCacheKey(assignId));
        });
    };
        self.invalidateAllSubmissionData = function(assignId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKeyStartingWith(getSubmissionsCacheKey(assignId));
        });
    };
        self.invalidateSubmissionStatusData = function(assignId, userId, isBlind, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getSubmissionStatusCacheKey(assignId, userId, isBlind));
        });
    };
        self.invalidateListParticipantsData = function(assignId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKeyStartingWith(listParticipantsPrefixCacheKey(assignId));
        });
    };
        self.invalidateContent = function(moduleId, courseId, siteId) {
        siteId = siteId || $mmSite.getId();
        return self.getAssignment(courseId, moduleId, siteId).then(function(assign) {
            var ps = [];
            ps.push(self.invalidateAllSubmissionData(assign.id, siteId));
            ps.push(self.invalidateAssignmentUserMappingsData(assign.id, siteId));
            ps.push(self.invalidateListParticipantsData(assign.id, siteId));
            ps.push($mmComments.invalidateCommentsByInstance('module', assign.id, siteId));
            return $q.all(ps);
        }).finally(function() {
            var ps = [];
            ps.push(self.invalidateAssignmentData(courseId, siteId));
            ps.push($mmGrades.invalidateGradeCourseItems(courseId));
            return $q.all(ps);
        });
    };
         self.invalidateFiles = function(moduleId) {
         return $mmFilepool.invalidateFilesByComponent($mmSite.getId(), mmaModAssignComponent, moduleId);
     };
        self.isPluginEnabled = function(siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.wsAvailable('mod_assign_get_assignments') && site.wsAvailable('mod_assign_get_submissions');
        });
    };
        self.isGradingEnabled = function(siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.wsAvailable('mod_assign_submit_grading_form') || site.wsAvailable('mod_assign_save_grade');
        });
    };
        self.isOutcomesEditEnabled = function(siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.wsAvailable('mod_assign_submit_grading_form');
        });
    };
        self.isPrefetchEnabled = function() {
        return $mmSite.wsAvailable('mod_assign_get_assignments') && $mmSite.wsAvailable('mod_assign_get_submissions') &&
            $mmSite.wsAvailable('mod_assign_get_submission_status');
    };
        self.isSaveAndSubmitSupported = function(siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.wsAvailable('mod_assign_get_submission_status') && site.wsAvailable('mod_assign_save_submission') &&
                   site.wsAvailable('mod_assign_submit_for_grading');
        }).catch(function() {
            return false;
        });
    };
        self.isSubmissionOpen = function(assign, submissionStatus) {
        if (!assign || !submissionStatus) {
            return false;
        }
        var time = $mmUtil.timestamp(),
            dateOpen = true,
            finalDate = false,
            lastAttempt = submissionStatus.lastattempt,
            submission = self.getSubmissionObjectFromAttempt(assign, lastAttempt);
        if (assign.cutoffdate) {
            finalDate = assign.cutoffdate;
        }
        if (lastAttempt && lastAttempt.locked) {
            return false;
        }
        if (finalDate) {
            if (lastAttempt && lastAttempt.extensionduedate) {
                if (lastAttempt.extensionduedate > finalDate) {
                    finalDate = lastAttempt.extensionduedate;
                }
            }
        }
        if (finalDate) {
            dateOpen = assign.allowsubmissionsfromdate <= time && time <= finalDate;
        } else {
            dateOpen = assign.allowsubmissionsfromdate <= time;
        }
        if (!dateOpen) {
            return false;
        }
        if (submission) {
            if (assign.submissiondrafts && submission.status == mmaModAssignSubmissionStatusSubmitted) {
                return false;
            }
        }
        return true;
    };
        self.logSubmissionView = function(assignId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                assignid: assignId
            };
            return site.write('mod_assign_view_submission_status', params);
        });
    };
        self.logGradingView = function(assignId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                assignid: assignId
            };
            return site.write('mod_assign_view_grading_table', params);
        });
    };
        self.logView = function(assignId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                assignid: assignId
            };
            return site.write('mod_assign_view_assign', params);
        });
    };
        self.getSubmissionStatusClass = function(status) {
        switch (status) {
            case 'submitted':
                return 'badge-balanced';
            case 'draft':
                return 'badge-positive';
            case 'new':
            case 'noattempt':
            case 'noonlinesubmissions':
            case 'nosubmission':
                return 'badge-assertive';
        }
        return "";
    };
        self.getSubmissionGradingStatusClass = function(status) {
        if (!status) {
            return '';
        }
        if (status == mmaModAssignGradingStatusGraded || status == mmaModMarkingWorkflowStateReleased) {
            return 'badge-balanced';
        }
        return 'badge-assertive';
    };
        self.getSubmissionGradingStatusTranslationId = function(status) {
        if (!status) {
            return false;
        }
        if (status == mmaModAssignGradingStatusGraded || status == mmaModAssignGradingStatusNotGraded) {
            return 'mma.mod_assign.' + status;
        }
        return 'mma.mod_assign.markingworkflowstate' + status;
    };
        self.needsSubmissionToBeGraded = function(submission, assignId) {
        if (!submission.gradingstatus) {
            return $q.when(true);
        }
        if (submission.gradingstatus != mmaModAssignGradingStatusGraded &&
                submission.gradingstatus != mmaModMarkingWorkflowStateReleased) {
            return $q.when(true);
        }
        return self.getSubmissionStatus(assignId, submission.submitid, submission.blindid).then(function(response) {
            if (!response.feedback || !response.feedback.gradeddate) {
                return true;
            }
            return response.feedback.gradeddate < submission.timemodified;
        });
    };
        self.saveSubmission = function(assignmentId, courseId, pluginData, allowOffline, timemodified, allowsDrafts, userId, siteId) {
        if (allowOffline && !$mmApp.isOnline()) {
            return storeOffline();
        }
        siteId = siteId || $mmSite.getId();
        return $mmaModAssignOffline.deleteSubmission(assignmentId, userId, siteId).then(function() {
            return self.saveSubmissionOnline(assignmentId, pluginData, siteId).then(function() {
                return true;
            }).catch(function(error) {
                if (allowOffline && error && !error.wserror) {
                    return storeOffline();
                } else {
                    return $q.reject(error.error);
                }
            });
        });
        function storeOffline() {
            return $mmaModAssignOffline.saveSubmission(assignmentId, courseId, pluginData,
                    timemodified, !allowsDrafts, userId, siteId).then(function() {
                return false;
            });
        }
    };
        self.saveSubmissionOnline = function(assignmentId, pluginData, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                assignmentid: assignmentId,
                plugindata: pluginData
            };
            return site.write('mod_assign_save_submission', params).catch(function(error) {
                return $q.reject({
                    error: error,
                    wserror: $mmUtil.isWebServiceError(error)
                });
            }).then(function(warnings) {
                if (warnings && warnings.length) {
                    return $q.reject({
                        wserror: true,
                        error: warnings[0].message
                    });
                }
            });
        });
    };
        self.submitForGrading = function(assignmentId, courseId, acceptStatement, timemodified, forceOffline, siteId) {
        if (forceOffline || !$mmApp.isOnline()) {
            return storeOffline();
        }
        siteId = siteId || $mmSite.getId();
        return $mmaModAssignOffline.deleteSubmission(assignmentId, undefined, siteId).then(function() {
            return self.submitForGradingOnline(assignmentId, acceptStatement, siteId).then(function() {
                return true;
            }).catch(function(error) {
                if (error && !error.wserror) {
                    return storeOffline();
                } else {
                    return $q.reject(error.error);
                }
            });
        });
        function storeOffline() {
            return $mmaModAssignOffline.markSubmitted(
                        assignmentId, courseId, true, acceptStatement, timemodified, undefined, siteId).then(function() {
                return false;
            });
        }
    };
        self.submitForGradingOnline = function(assignmentId, acceptStatement, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                assignmentid: assignmentId,
                acceptsubmissionstatement: acceptStatement ? 1 : 0
            };
            return site.write('mod_assign_submit_for_grading', params).catch(function(error) {
                return $q.reject({
                    error: error,
                    wserror: $mmUtil.isWebServiceError(error)
                });
            }).then(function(warnings) {
                if (warnings && warnings.length) {
                    return $q.reject({
                        wserror: true,
                        error: warnings[0].message
                    });
                }
            });
        });
    };
    function isGradingOfflineEnabled(siteId) {
        if (typeof gradingOfflineEnabled[siteId] != 'undefined') {
            return $q.when(gradingOfflineEnabled[siteId]);
        }
        return $mmGrades.isGradeItemsAvalaible(siteId).then(function(enabled) {
            gradingOfflineEnabled[siteId] = enabled;
            return enabled;
        });
    }
        self.submitGradingForm = function(assignmentId, userId, grade, attemptNumber, addAttempt, workflowState, applyToAll, outcomes,
            pluginData, courseId, siteId) {
        siteId = siteId || $mmSite.getId();
        return isGradingOfflineEnabled(siteId).then(function (enabled) {
            if (!enabled) {
                return self.submitGradingFormOnline(assignmentId, userId, grade, attemptNumber, addAttempt, workflowState,
                    applyToAll, outcomes, pluginData, siteId);
            }
            if (!$mmApp.isOnline()) {
                return storeOffline();
            }
            return $mmaModAssignOffline.deleteSubmissionGrade(assignmentId, userId, siteId).then(function() {
                return self.submitGradingFormOnline(assignmentId, userId, grade, attemptNumber, addAttempt, workflowState, applyToAll,
                        outcomes, pluginData, siteId).then(function() {
                    return true;
                }).catch(function(error) {
                    if (error && !error.wserror) {
                        return storeOffline();
                    } else {
                        return $q.reject(error.error);
                    }
                });
            });
        });
        function storeOffline() {
            return $mmaModAssignOffline.submitGradingForm(assignmentId, userId, grade, attemptNumber, addAttempt, workflowState,
                    applyToAll, outcomes, pluginData, courseId, siteId).then(function() {
                return false;
            });
        }
    };
        self.submitGradingFormOnline = function(assignmentId, userId, grade, attemptNumber, addAttempt, workflowState, applyToAll,
            outcomes, pluginData, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            if (site.wsAvailable('mod_assign_submit_grading_form')) {
                return submitGradingForm(assignmentId, userId, grade, attemptNumber, addAttempt, workflowState, applyToAll,
                    outcomes, pluginData, site);
            } else if(site.wsAvailable('mod_assign_save_grade')) {
                return saveGrade(assignmentId, userId, grade, attemptNumber, addAttempt, workflowState, applyToAll, pluginData,
                    site);
            } else {
                return $q.reject();
            }
        });
    };
    function saveGrade(assignmentId, userId, grade, attemptNumber, addAttempt, workflowState, applyToAll, pluginData, site) {
        var params = {
                assignmentid: assignmentId,
                userid: userId ? userId : site.getUserId(),
                grade: grade,
                attemptnumber: attemptNumber,
                addattempt: addAttempt ? 1 : 0,
                workflowstate: workflowState,
                applytoall: applyToAll ? 1 : 0,
                plugindata: pluginData
            },
            preSets = {
                responseExpected: false
            };
        return site.write('mod_assign_save_grade', params, preSets).catch(function(error) {
            return $q.reject({
                error: error,
                wserror: $mmUtil.isWebServiceError(error)
            });
        });
    }
    function submitGradingForm(assignmentId, userId, grade, attemptNumber, addAttempt, workflowState, applyToAll, outcomes,
            pluginData, site) {
        var jsondata, serialized, params;
        jsondata = {
                grade: grade,
                attemptnumber: attemptNumber,
                addattempt: addAttempt ? 1 : 0,
                workflowstate: workflowState,
                applytoall: applyToAll ? 1 : 0
            };
        angular.forEach(outcomes, function(outcome, index) {
            jsondata['outcome_' + index + '[' + userId + ']'] = outcome;
        });
        angular.forEach(pluginData, function(data, index) {
            jsondata[index] = data;
        });
        serialized = $mmUtil.param(jsondata, true);
        params = {
            assignmentid: assignmentId,
            userid: userId || site.getUserId(),
            jsonformdata: JSON.stringify(serialized)
        };
        return site.write('mod_assign_submit_grading_form', params).catch(function(error) {
            return $q.reject({
                error: error,
                wserror: $mmUtil.isWebServiceError(error)
            });
        }).then(function(warnings) {
            if (warnings && warnings.length) {
                return $q.reject({
                    wserror: true,
                    error: warnings[0].message
                });
            }
        });
    }
    return self;
}]);

angular.module('mm.addons.mod_assign')
.constant('mmaModAssignSubmissionsStore', 'mma_mod_assign_submissions')
.constant('mmaModAssignSubmissionsGradeStore', 'mma_mod_assign_submissions_grading')
.config(["$mmSitesFactoryProvider", "mmaModAssignSubmissionsStore", "mmaModAssignSubmissionsGradeStore", function($mmSitesFactoryProvider, mmaModAssignSubmissionsStore, mmaModAssignSubmissionsGradeStore) {
    var stores = [
        {
            name: mmaModAssignSubmissionsStore,
            keyPath: ['assignmentid', 'userid'],
            indexes: [
                {
                    name: 'assignmentid'
                },
                {
                    name: 'userid'
                },
                {
                    name: 'courseid'
                },
                {
                    name: 'timemodified'
                },
                {
                    name: 'onlinetimemodified'
                }
            ]
        },
        {
            name: mmaModAssignSubmissionsGradeStore,
            keyPath: ['assignmentid', 'userid'],
            indexes: [
                {
                    name: 'assignmentid'
                },
                {
                    name: 'userid'
                },
                {
                    name: 'timemodified'
                }
            ]
        }
    ];
    $mmSitesFactoryProvider.registerStores(stores);
}])
.factory('$mmaModAssignOffline', ["$mmSitesManager", "$log", "$mmFS", "$q", "mmaModAssignSubmissionsStore", "$mmUtil", "mmaModAssignSubmissionsGradeStore", function($mmSitesManager, $log, $mmFS, $q, mmaModAssignSubmissionsStore, $mmUtil,
        mmaModAssignSubmissionsGradeStore) {
    $log = $log.getInstance('$mmaModAssignOffline');
    var self = {};
        self.getAllAssigns = function(siteId) {
        var promises = [];
        promises.push(getAllSubmissions(siteId));
        promises.push(getAllSubmissionsGrade(siteId));
        return $q.all(promises).then(function(objects) {
            objects = [].concat.apply([], objects);
            objects = objects.map(function(object) {
              return object.assignmentid;
            });
            objects = objects.filter(function(item, pos) {
                return objects.indexOf(item) == pos;
            });
            return objects;
        });
    };
        self.hasAssignOfflineData = function(assignId, siteId) {
        var promises = [];
        promises.push(self.getAssignSubmissions(assignId, siteId));
        promises.push(self.getAssignSubmissionsGrade(assignId, siteId));
        return $q.all(promises).then(function(objects) {
            for (var i = 0; i < objects.length; i++) {
                var result = objects[i];
                if (result && result.length) {
                    return true;
                }
            }
            return false;
        }).catch(function() {
            return false;
        });
    };
        self.deleteSubmission = function(assignId, userId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            return site.getDb().remove(mmaModAssignSubmissionsStore, [assignId, userId]);
        });
    };
        function getAllSubmissions(siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.getDb().getAll(mmaModAssignSubmissionsStore);
        });
    };
        self.getAssignSubmissions = function(assignId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.getDb().whereEqual(mmaModAssignSubmissionsStore, 'assignmentid', assignId);
        });
    };
        self.getSubmission = function(assignId, userId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            return site.getDb().get(mmaModAssignSubmissionsStore, [assignId, userId]);
        });
    };
        self.getSubmissionFolder = function(assignId, userId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            var siteFolderPath = $mmFS.getSiteFolder(site.getId()),
                submissionFolderPath = 'offlineassign/' + assignId + '/' + userId;
            return $mmFS.concatenatePaths(siteFolderPath, submissionFolderPath);
        });
    };
        self.getSubmissionPluginFolder = function(assignId, pluginName, userId, siteId) {
        return self.getSubmissionFolder(assignId, userId, siteId).then(function(folderPath) {
            return $mmFS.concatenatePaths(folderPath, pluginName);
        });
    };
        self.deleteSubmissionGrade = function(assignId, userId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            return site.getDb().remove(mmaModAssignSubmissionsGradeStore, [assignId, userId]);
        });
    };
        function getAllSubmissionsGrade(siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.getDb().getAll(mmaModAssignSubmissionsGradeStore);
        });
    };
        self.getAssignSubmissionsGrade = function(assignId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.getDb().whereEqual(mmaModAssignSubmissionsGradeStore, 'assignmentid', assignId);
        });
    };
        self.getSubmissionGrade = function(assignId, userId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            return site.getDb().get(mmaModAssignSubmissionsGradeStore, [assignId, userId]);
        });
    };
        self.markSubmitted = function(assignId, courseId, submitted, acceptStatement, timemodified, userId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            return self.getSubmission(assignId, userId, site.getId()).catch(function() {
                var now = $mmUtil.timestamp();
                return {
                    assignmentid: assignId,
                    courseid: courseId,
                    plugindata: {},
                    userid: userId,
                    onlinetimemodified: timemodified,
                    timecreated: now,
                    timemodified: now
                };
            }).then(function(submission) {
                submission.submitted = !!submitted;
                submission.submissionstatement = !!acceptStatement;
                return site.getDb().insert(mmaModAssignSubmissionsStore, submission);
            });
        });
    };
        self.saveSubmission = function(assignId, courseId, pluginData, timemodified, submitted, userId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            var now = $mmUtil.timestamp(),
                entry = {
                    assignmentid: assignId,
                    courseid: courseId,
                    plugindata: pluginData,
                    userid: userId,
                    submitted: !!submitted,
                    timecreated: now,
                    timemodified: now,
                    onlinetimemodified: timemodified
                };
            return site.getDb().insert(mmaModAssignSubmissionsStore, entry);
        });
    };
        self.submitGradingForm = function(assignId, userId, grade, attemptNumber, addAttempt, workflowState, applyToAll, outcomes,
            pluginData, courseId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var now = $mmUtil.timestamp(),
                entry = {
                    assignmentid: assignId,
                    userid: userId,
                    courseid: courseId,
                    grade: grade,
                    attemptnumber: attemptNumber,
                    addattempt: !!addAttempt,
                    workflowstate: workflowState,
                    applytoall: !!applyToAll,
                    outcomes: outcomes,
                    plugindata: pluginData,
                    timemodified: now
                };
            return site.getDb().insert(mmaModAssignSubmissionsGradeStore, entry);
        });
    };
    return self;
}]);
angular.module('mm.addons.mod_assign')
.factory('$mmaModAssignSync', ["$log", "$mmaModAssign", "$mmSite", "$mmSitesManager", "$q", "$mmaModAssignOffline", "$mmCourse", "$mmUtil", "$mmApp", "$mmEvents", "$translate", "mmaModAssignSyncTime", "$mmSync", "mmaModAssignEventAutomSynced", "mmaModAssignComponent", "$mmaModAssignSubmissionDelegate", "$mmSyncBlock", "$mmLang", "$mmGrades", function($log, $mmaModAssign, $mmSite, $mmSitesManager, $q, $mmaModAssignOffline, $mmCourse, $mmUtil,
            $mmApp, $mmEvents, $translate, mmaModAssignSyncTime, $mmSync, mmaModAssignEventAutomSynced, mmaModAssignComponent,
            $mmaModAssignSubmissionDelegate, $mmSyncBlock, $mmLang, $mmGrades) {
    $log = $log.getInstance('$mmaModAssignSync');
    var self = $mmSync.createChild(mmaModAssignComponent, mmaModAssignSyncTime);
        self.hasDataToSync = function(assignId, siteId) {
        return $mmaModAssignOffline.getAllAssigns(assignId, siteId).then(function(assigns) {
            return !!assigns.length;
        }).catch(function() {
            return false;
        });
    };
        self.syncAllAssignments = function(siteId) {
        if (!$mmApp.isOnline()) {
            $log.debug('Cannot sync all assignments because device is offline.');
            return $q.reject();
        }
        var promise;
        if (!siteId) {
            $log.debug('Try to sync assignments in all sites.');
            promise = $mmSitesManager.getSitesIds();
        } else {
            $log.debug('Try to sync assignments in site ' + siteId);
            promise = $q.when([siteId]);
        }
        return promise.then(function(siteIds) {
            var sitePromises = [];
            angular.forEach(siteIds, function(siteId) {
                sitePromises.push($mmaModAssignOffline.getAllAssigns(siteId).then(function(assignIds) {
                    var promises = [];
                    angular.forEach(assignIds, function(assignId) {
                        promises.push(self.syncAssignIfNeeded(assignId, siteId).then(function(data) {
                            if (data && data.updated) {
                                $mmEvents.trigger(mmaModAssignEventAutomSynced, {
                                    siteid: siteId,
                                    assignid: assignId,
                                    warnings: data.warnings
                                });
                            }
                        }));
                    });
                    return $q.all(promises);
                }));
            });
            return $q.all(sitePromises);
        });
    };
        self.syncAssignIfNeeded = function(assignId, siteId) {
        return self.isSyncNeeded(assignId, siteId).then(function(needed) {
            if (needed) {
                return self.syncAssign(assignId, siteId);
            }
        });
    };
        self.syncAssign = function(assignId, siteId) {
        siteId = siteId || $mmSite.getId();
        var syncPromise,
            syncPromises = [],
            assign,
            courseId,
            result = {
                warnings: [],
                updated: false
            };
        if (self.isSyncing(assignId, siteId)) {
            return self.getOngoingSync(assignId, siteId);
        }
        if ($mmSyncBlock.isBlocked(mmaModAssignComponent, assignId, siteId)) {
            $log.debug('Cannot sync assign ' + assignId + ' because it is blocked.');
            var modulename = $mmCourse.translateModuleName('assign');
            return $mmLang.translateAndReject('mm.core.errorsyncblocked', {$a: modulename});
        }
        $log.debug('Try to sync assign ' + assignId);
        syncPromises.push($mmaModAssignOffline.getAssignSubmissions(assignId, siteId).catch(function() {
            return [];
        }));
        syncPromises.push($mmaModAssignOffline.getAssignSubmissionsGrade(assignId, siteId).catch(function() {
            return [];
        }));
        syncPromise = $q.all(syncPromises).then(function(syncs) {
            var submissions = syncs[0],
                grades = syncs[1];
            if (!submissions.length && !grades.length) {
                return;
            } else if (!$mmApp.isOnline()) {
                return $q.reject();
            }
            courseId = submissions.length > 0 ? submissions[0].courseid : grades[0].courseid;
            return $mmaModAssign.getAssignmentById(courseId, assignId, siteId).then(function(assignData) {
                assign = assignData;
                 var promises = [];
                angular.forEach(submissions, function(submission) {
                    promises.push(syncSubmission(assign, submission, result.warnings, siteId).then(function() {
                        result.updated = true;
                    }));
                });
                angular.forEach(grades, function(grade) {
                    promises.push(syncSubmissionGrade(assign, grade, result.warnings, courseId, siteId).then(function() {
                        result.updated = true;
                    }));
                });
                return $q.all(promises);
            }).then(function() {
                if (result.updated) {
                    return $mmaModAssign.invalidateContent(assign.cmid, courseId, siteId).catch(function() {
                    });
                }
            });
        }).then(function() {
            return self.setSyncTime(assignId, siteId).catch(function() {
            });
        }).then(function() {
            return result;
        });
        return self.addOngoingSync(assignId, syncPromise, siteId);
    };
        function syncSubmission(assign, offlineData, warnings, siteId) {
        var discardError,
            userId = offlineData.userid,
            submission,
            pluginData = {};
        return $mmaModAssign.getSubmissionStatus(assign.id, userId, false, true, true, siteId).then(function(status) {
            var promises = [];
            submission = $mmaModAssign.getSubmissionObjectFromAttempt(assign, status.lastattempt);
            if (submission.timemodified != offlineData.onlinetimemodified) {
                discardError = $translate.instant('mma.mod_assign.warningsubmissionmodified');
                return;
            }
            angular.forEach(submission.plugins, function(plugin) {
                promises.push($mmaModAssignSubmissionDelegate.preparePluginSyncData(
                        assign, submission, plugin, offlineData, pluginData, siteId));
            });
            return $q.all(promises).then(function() {
                var promise;
                if (!Object.keys(pluginData).length) {
                    promise = $q.when();
                } else {
                    promise = $mmaModAssign.saveSubmissionOnline(assign.id, pluginData, siteId);
                }
                return promise.then(function() {
                    if (assign.submissiondrafts && offlineData.submitted) {
                        return $mmaModAssign.submitForGradingOnline(assign.id, offlineData.submissionstatement, siteId);
                    }
                }).then(function() {
                    $mmaModAssign.getSubmissionStatus(assign.id, userId, false, true, true, siteId);
                }).catch(function(error) {
                    if (error && error.wserror) {
                        discardError = error.error;
                    } else {
                        return $q.reject(error && error.error);
                    }
                });
            }, function(error) {
                if ($mmUtil.isWebServiceError(error)) {
                    discardError = error;
                } else {
                    return $q.reject(error);
                }
            });
        }).then(function() {
            return $mmaModAssignOffline.deleteSubmission(assign.id, userId, siteId).then(function() {
                var promises = [];
                angular.forEach(submission.plugins, function(plugin) {
                    promises.push($mmaModAssignSubmissionDelegate.deletePluginOfflineData(
                        assign, submission, plugin, offlineData, siteId));
                });
                return $q.all(promises);
            });
        }).then(function() {
            if (discardError) {
                var message = $translate.instant('mm.core.warningofflinedatadeleted', {
                    component: $mmCourse.translateModuleName('assign'),
                    name: assign.name,
                    error: discardError
                });
                if (warnings.indexOf(message) == -1) {
                    warnings.push(message);
                }
            }
        });
    }
    function getSelectedScaleId(options, selected) {
        options = options.split(",");
        options = options.map(function (value) {return value.trim();});
        options.unshift("");
        var index = options.indexOf(selected) || 0;
        if (index < 0) {
            return 0;
        }
        return index;
    }
        function syncSubmissionGrade(assign, offlineData, warnings, courseId, siteId) {
        var discardError,
            userId = offlineData.userid;
        return $mmaModAssign.getSubmissionStatus(assign.id, userId, false, true, true, siteId).then(function(status) {
            var timemodified = status.feedback && (status.feedback.gradeddate || (status.feedback.grade.timemodified));
            if (timemodified > offlineData.timemodified) {
                discardError = $translate.instant('mma.mod_assign.warningsubmissiongrademodified');
                return;
            }
            return $mmGrades.getGradeModuleItems(courseId, assign.cmid, userId, false, siteId, true).then(function(grades) {
                return $mmCourse.getModuleBasicGradeInfo(assign.cmid, siteId).then(function(gradeInfo) {
                    angular.forEach(grades, function(grade) {
                        if (grade.gradedategraded >= offlineData.timemodified) {
                            if (!grade.outcomeid && !grade.scaleid) {
                                if (scope.grade.scale && gradeInfo && gradeInfo.scale) {
                                    offlineData.grade = getSelectedScaleId(gradeInfo.scale, grade.gradeformatted);
                                } else if (!scope.grade.scale) {
                                    offlineData.grade = parseFloat(grade.gradeformatted) || null;
                                }
                            } else if (grade.outcomeid && $mmaModAssign.isOutcomesEditEnabled() && gradeInfo.outcomes) {
                                angular.forEach(gradeInfo.outcomes, function(outcome, itemNumber) {
                                    if (outcome.scale && grade.itemnumber == itemNumber) {
                                        offlineData.outcomes[grade.itemnumber] = getSelectedScaleId(outcome.scale, outcome.selected);
                                    }
                                });
                            }
                        }
                    });
                });
            }).then(function() {
                return $mmaModAssign.submitGradingFormOnline(assign.id, userId, offlineData.grade, offlineData.attemptnumber,
                        offlineData.addattempt, offlineData.workflowstate, offlineData.applytoall, offlineData.outcomes,
                        offlineData.plugindata, siteId).then(function() {
                    $mmaModAssign.getSubmissionStatus(assign.id, userId, false, true, true, siteId);
                }).catch(function(error) {
                    if (error && error.wserror) {
                        discardError = error.error;
                    } else {
                        return $q.reject(error && error.error);
                    }
                });
            });
        }).then(function() {
            return $mmaModAssignOffline.deleteSubmissionGrade(assign.id, userId, siteId);
        }).then(function() {
            if (discardError) {
                var message = $translate.instant('mm.core.warningofflinedatadeleted', {
                    component: $mmCourse.translateModuleName('assign'),
                    name: assign.name,
                    error: discardError
                });
                if (warnings.indexOf(message) == -1) {
                    warnings.push(message);
                }
            }
        });
    }
    return self;
}]);

angular.module('mm.addons.mod_assign')
.factory('$mmaModAssignFeedbackDelegate', ["$log", "$mmSite", "$mmUtil", "$q", "$translate", function($log, $mmSite, $mmUtil, $q, $translate) {
    $log = $log.getInstance('$mmaModAssignFeedbackDelegate');
    var handlers = {},
        enabledHandlers = {},
        self = {},
        updatePromises = {},
        lastUpdateHandlersStart;
        self.getDirectiveForPlugin = function(plugin) {
        var handler = self.getPluginHandler(plugin.type);
        if (handler && handler.getDirectiveName) {
            return handler.getDirectiveName(plugin);
        }
    };
        self.getPluginName = function(plugin) {
        var handler = self.getPluginHandler(plugin.type);
        if (handler && handler.getPluginName) {
            return handler.getPluginName(plugin);
        }
        var translationId = 'mma.mod_assign_feedback_' + plugin.type + '.pluginname',
            translation = $translate.instant(translationId);
        if (translationId != translation) {
            return translation;
        }
        if (plugin.name) {
            return plugin.name;
        }
    };
        self.getPluginHandler = function(pluginType) {
        if (typeof enabledHandlers[pluginType] != 'undefined') {
            return enabledHandlers[pluginType];
        }
    };
        self.hasPluginDataChanged = function(assign, plugin, inputData) {
        var handler = self.getPluginHandler(plugin.type);
        if (handler && handler.hasDataChanged) {
            return $q.when(handler.hasDataChanged(assign, plugin, inputData));
        }
        return $q.when(false);
    };
        self.hasPluginDraftData = function(assignId, userId, plugin, siteId) {
        var handler = self.getPluginHandler(plugin.type);
        if (handler && handler.hasDraftData) {
            return $q.when(handler.hasDraftData(assignId, userId, siteId));
        }
        return $q.when(false);
    };
        self.preparePluginFeedbackData = function(assignId, userId, plugin, pluginData, siteId) {
        var handler = self.getPluginHandler(plugin.type);
        if (handler && handler.prepareFeedbackData) {
            return $q.when(handler.prepareFeedbackData(assignId, userId, pluginData, siteId));
        }
        return $q.when();
    };
        self.getFeedbackDataToDraft = function(plugin, inputData) {
        var handler = self.getPluginHandler(plugin.type);
        if (handler && handler.getFeedbackDataToDraft) {
            return $q.when(handler.getFeedbackDataToDraft(plugin, inputData));
        }
        return $q.when();
    };
        self.saveFeedbackDraft = function(assignId, userId, plugin, inputData, siteId) {
        var handler = self.getPluginHandler(plugin.type);
        if (handler && handler.saveDraft) {
            return $q.when(handler.saveDraft(assignId, userId, inputData, siteId));
        }
        return $q.when();
    };
        self.discardPluginFeedbackData = function(assignId, userId, plugin, siteId) {
        var handler = self.getPluginHandler(plugin.type);
        if (handler && handler.discardDraft) {
            return $q.when(handler.discardDraft(assignId, userId, siteId));
        }
        return $q.when();
    };
        self.getPluginFiles = function(assign, submission, plugin, siteId) {
        siteId = siteId || $mmSite.getId();
        var handler = self.getPluginHandler(plugin.type);
        if (handler && handler.getPluginFiles) {
            return $q.when(handler.getPluginFiles(assign, submission, plugin, siteId));
        }
        return $q.when([]);
    };
        self.isLastUpdateCall = function(time) {
        if (!lastUpdateHandlersStart) {
            return true;
        }
        return time == lastUpdateHandlersStart;
    };
        self.isPluginSupported = function(pluginType) {
        return typeof enabledHandlers[pluginType] != 'undefined';
    };
        self.isPluginSupportedForEdit = function(pluginType) {
        var handler = self.getPluginHandler(pluginType);
        if (handler && handler.isEnabledForEdit) {
            return handler.isEnabledForEdit();
        }
        return false;
    };
        self.prefetch = function(assign, submission, plugin, siteId) {
        siteId = siteId || $mmSite.getId();
        var handler = self.getPluginHandler(plugin.type);
        if (handler && handler.prefetch) {
            return $q.when(handler.prefetch(assign, submission, plugin, siteId));
        }
        return $q.when();
    };
        self.registerHandler = function(addon, pluginType, handler) {
        if (typeof handlers[pluginType] !== 'undefined') {
            $log.debug("Addon '" + addon + "' already registered as handler for '" + pluginType + "'");
            return false;
        }
        $log.debug("Registered handler '" + addon + "' for feedback plugin '" + pluginType + "'");
        handlers[pluginType] = {
            addon: addon,
            instance: undefined,
            handler: handler
        };
        if ($mmSite.isLoggedIn()) {
            self.updateHandler(pluginType, handlers[pluginType]);
        }
    };
        self.updateHandler = function(pluginType, handlerInfo, time) {
        var promise,
            deleted = false,
            siteId = $mmSite.getId();
        if (updatePromises[siteId] && updatePromises[siteId][pluginType]) {
            return updatePromises[siteId][pluginType];
        } else if (!updatePromises[siteId]) {
            updatePromises[siteId] = {};
        }
        if (typeof handlerInfo.instance === 'undefined') {
            handlerInfo.instance = $mmUtil.resolveObject(handlerInfo.handler, true);
        }
        if (!$mmSite.isLoggedIn()) {
            promise = $q.reject();
        } else {
            promise = $q.when(handlerInfo.instance.isEnabled());
        }
        promise = promise.catch(function() {
            return false;
        }).then(function(enabled) {
            if (self.isLastUpdateCall(time) && $mmSite.isLoggedIn() && $mmSite.getId() === siteId) {
                if (enabled) {
                    enabledHandlers[pluginType] = handlerInfo.instance;
                } else {
                    delete enabledHandlers[pluginType];
                }
            }
        }).finally(function() {
            delete updatePromises[siteId][pluginType];
            deleted = true;
        });
        if (!deleted) {
            updatePromises[siteId][pluginType] = promise;
        }
        return promise;
    };
        self.updateHandlers = function() {
        var promises = [],
            now = new Date().getTime();
        $log.debug('Updating handlers for current site.');
        lastUpdateHandlersStart = now;
        angular.forEach(handlers, function(handlerInfo, pluginType) {
            promises.push(self.updateHandler(pluginType, handlerInfo, now));
        });
        return $q.all(promises).then(function() {
            return true;
        }, function() {
            return true;
        });
    };
    return self;
}])
.run(["$mmEvents", "mmCoreEventLogin", "mmCoreEventSiteUpdated", "$mmaModAssignFeedbackDelegate", "mmCoreEventRemoteAddonsLoaded", function($mmEvents, mmCoreEventLogin, mmCoreEventSiteUpdated, $mmaModAssignFeedbackDelegate, mmCoreEventRemoteAddonsLoaded) {
    $mmEvents.on(mmCoreEventLogin, $mmaModAssignFeedbackDelegate.updateHandlers);
    $mmEvents.on(mmCoreEventSiteUpdated, $mmaModAssignFeedbackDelegate.updateHandlers);
    $mmEvents.on(mmCoreEventRemoteAddonsLoaded, $mmaModAssignFeedbackDelegate.updateHandlers);
}]);

angular.module('mm.addons.mod_assign')
.factory('$mmaModAssignHandlers', ["$mmCourse", "$mmaModAssign", "$state", "$mmContentLinksHelper", "$mmUtil", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", "$mmEvents", "mmCoreEventPackageStatusChanged", "$mmSite", "mmaModAssignComponent", "$mmCoursePrefetchDelegate", "$mmaModAssignPrefetchHandler", "$mmaModAssignSync", function($mmCourse, $mmaModAssign, $state, $mmContentLinksHelper, $mmUtil, mmCoreDownloading,
        mmCoreNotDownloaded, mmCoreOutdated, $mmEvents, mmCoreEventPackageStatusChanged, $mmSite, mmaModAssignComponent,
        $mmCoursePrefetchDelegate, $mmaModAssignPrefetchHandler, $mmaModAssignSync) {
    var self = {};
        self.courseContent = function() {
        var self = {};
                self.isEnabled = function() {
            return $mmaModAssign.isPluginEnabled();
        };
                self.getController = function(module, courseId) {
            return function($scope) {
                var downloadBtn = {
                        hidden: true,
                        icon: 'ion-ios-cloud-download-outline',
                        label: 'mm.core.download',
                        action: function(e) {
                            if (e) {
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            download();
                        }
                    },
                    refreshBtn = {
                        hidden: true,
                        icon: 'ion-android-refresh',
                        label: 'mm.core.refresh',
                        action: function(e) {
                            if (e) {
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            $mmaModAssign.invalidateContent(module.id, courseId).finally(function() {
                                download();
                            });
                        }
                    };
                $scope.title = module.name;
                $scope.icon = $mmCourse.getModuleIconSrc('assign');
                $scope.class = 'mma-mod_assign-handler';
                $scope.buttons = $mmaModAssign.isPrefetchEnabled() ? [downloadBtn, refreshBtn] :  [];
                $scope.spinner = true;
                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_assign', {module: module, courseid: courseId});
                };
                function download() {
                    $scope.spinner = true;
                    $mmaModAssignPrefetchHandler.getDownloadSize(module, courseId).then(function(size) {
                        $mmUtil.confirmDownloadSize(size).then(function() {
                            $mmaModAssignPrefetchHandler.prefetch(module, courseId).catch(function() {
                                if (!$scope.$$destroyed) {
                                    $mmUtil.showErrorModal('mm.core.errordownloading', true);
                                }
                            });
                        }).catch(function() {
                            $scope.spinner = false;
                        });
                    }).catch(function(error) {
                        $scope.spinner = false;
                        if (error) {
                            $mmUtil.showErrorModal(error);
                        } else {
                            $mmUtil.showErrorModal('mm.core.errordownloading', true);
                        }
                    });
                }
                function showStatus(status) {
                    if (status) {
                        $scope.spinner = status === mmCoreDownloading;
                        downloadBtn.hidden = status !== mmCoreNotDownloaded;
                        refreshBtn.hidden = status !== mmCoreOutdated;
                    }
                }
                var statusObserver = $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
                    if (data.siteid === $mmSite.getId() && data.componentId === module.id &&
                            data.component === mmaModAssignComponent) {
                        showStatus(data.status);
                    }
                });
                $mmCoursePrefetchDelegate.getModuleStatus(module, courseId).then(showStatus);
                $scope.$on('$destroy', function() {
                    statusObserver && statusObserver.off && statusObserver.off();
                });
            };
        };
        return self;
    };
        self.linksHandler = $mmContentLinksHelper.createModuleIndexLinkHandler('mmaModAssign', 'assign', $mmaModAssign);
        self.syncHandler = function() {
        var self = {};
                self.execute = function(siteId) {
            return $mmaModAssignSync.syncAllAssignments(siteId);
        };
                self.getInterval = function() {
            return 600000;
        };
                self.isSync = function() {
            return true;
        };
                self.usesNetwork = function() {
            return true;
        };
        return self;
    };
    return self;
}]);

angular.module('mm.addons.mod_assign')
.factory('$mmaModAssignHelper', ["$mmUtil", "$mmaModAssignSubmissionDelegate", "$q", "$mmSite", "$mmFS", "$mmaModAssign", "$mmGroups", "$mmFileUploader", "mmaModAssignComponent", "$mmaModAssignOffline", "$mmaModAssignFeedbackDelegate", "mmaModAssignSubmissionStatusNew", "mmaModAssignSubmissionStatusReopened", function($mmUtil, $mmaModAssignSubmissionDelegate, $q, $mmSite, $mmFS, $mmaModAssign, $mmGroups,
            $mmFileUploader, mmaModAssignComponent, $mmaModAssignOffline, $mmaModAssignFeedbackDelegate,
            mmaModAssignSubmissionStatusNew, mmaModAssignSubmissionStatusReopened) {
    var self = {};
        self.canEditSubmissionOffline = function(assign, submission) {
        if (!submission) {
            return false;
        }
        if (submission.status == mmaModAssignSubmissionStatusNew || submission.status == mmaModAssignSubmissionStatusReopened) {
            return true;
        }
        for (var i = 0; i < submission.plugins.length; i++) {
            var plugin = submission.plugins[i];
            if (!$mmaModAssignSubmissionDelegate.canPluginEditOffline(assign, submission, plugin)) {
                return false;
            }
        }
        return true;
    };
        self.clearSubmissionPluginTmpData = function(assign, submission, inputData) {
        angular.forEach(submission.plugins, function(plugin) {
            $mmaModAssignSubmissionDelegate.clearTmpData(assign, submission, plugin, inputData);
        });
    };
        self.copyPreviousAttempt = function(assign, previousSubmission) {
        var pluginData = {},
            promises = [],
            errorMessage;
        angular.forEach(previousSubmission.plugins, function(plugin) {
            promises.push($mmaModAssignSubmissionDelegate.copyPluginSubmissionData(assign, plugin, pluginData).catch(function(err) {
                errorMessage = err;
                return $q.reject();
            }));
        });
        return $q.all(promises).then(function() {
            if (Object.keys(pluginData).length) {
                return $mmaModAssign.saveSubmissionOnline(assign.id, pluginData);
            }
        }).catch(function() {
            return $q.reject(errorMessage);
        });
    };
        self.deleteStoredSubmissionFiles = function(assignId, pluginName, userId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmaModAssignOffline.getSubmissionPluginFolder(assignId, pluginName, userId, siteId).then(function(folderPath) {
            return $mmFS.removeDir(folderPath);
        });
    };
        self.getAnswersFromForm = function(form) {
        if (!form || !form.elements) {
            return {};
        }
        var answers = {};
        angular.forEach(form.elements, function(element) {
            var name = element.name || '';
            if (!name || element.type == 'submit' || element.tagName == 'BUTTON') {
                return;
            }
            if (element.type == 'checkbox') {
                answers[name] = !!element.checked;
            } else if (element.type == 'radio') {
                if (element.checked) {
                    answers[name] = element.value;
                }
            } else {
                answers[name] = element.value;
            }
        });
        return answers;
    };
        self.getStoredSubmissionFiles = function(assignId, pluginName, userId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmaModAssignOffline.getSubmissionPluginFolder(assignId, pluginName, userId, siteId).then(function(folderPath) {
            return $mmFS.getDirectoryContents(folderPath);
        });
    };
        self.getSubmissionSizeForCopy = function(assign, previousSubmission) {
        var totalSize = 0,
            promises = [];
        angular.forEach(previousSubmission.plugins, function(plugin) {
            promises.push($q.when($mmaModAssignSubmissionDelegate.getPluginSizeForCopy(assign, plugin)).then(function(size) {
                totalSize += size;
            }));
        });
        return $q.all(promises).then(function() {
            return totalSize;
        });
    };
        self.getSubmissionSizeForEdit = function(assign, submission, inputData) {
        var totalSize = 0,
            promises = [];
        angular.forEach(submission.plugins, function(plugin) {
            var promise = $q.when($mmaModAssignSubmissionDelegate.getPluginSizeForEdit(assign, submission, plugin, inputData));
            promises.push(promise.then(function(size) {
                totalSize += size;
            }));
        });
        return $q.all(promises).then(function() {
            return totalSize;
        });
    };
        self.hasSubmissionDataChanged = function(assign, submission, inputData) {
        var hasChanged = false,
            promises = [];
        angular.forEach(submission.plugins, function(plugin) {
            promises.push($mmaModAssignSubmissionDelegate.hasPluginDataChanged(assign, submission, plugin, inputData)
                    .then(function(changed) {
                if (changed) {
                    hasChanged = true;
                }
            }).catch(function() {
            }));
        });
        return $mmUtil.allPromises(promises).then(function() {
            return hasChanged;
        });
    };
        self.hasFeedbackDraftData = function(assignId, userId, feedback, siteId) {
        var hasDraft = false,
            promises = [];
        angular.forEach(feedback.plugins, function(plugin) {
            promises.push($mmaModAssignFeedbackDelegate.hasPluginDraftData(assignId, userId, plugin, siteId)
                    .then(function(draft) {
                if (draft) {
                    hasDraft = true;
                }
            }).catch(function() {
            }));
        });
        return $mmUtil.allPromises(promises).then(function() {
            return hasDraft;
        });
    };
        self.prepareSubmissionPluginData = function(assign, submission, inputData, offline) {
        var pluginData = {},
            promises = [],
            error;
        angular.forEach(submission.plugins, function(plugin) {
            promises.push($mmaModAssignSubmissionDelegate.preparePluginSubmissionData(
                    assign, submission, plugin, inputData, pluginData, offline).catch(function(message) {
                error = message;
                return $q.reject();
            }));
        });
        return $mmUtil.allPromises(promises).then(function() {
            return pluginData;
        }).catch(function() {
            return $q.reject(error);
        });
    };
        self.prepareFeedbackPluginData = function(assignId, userId, feedback, siteId) {
        var pluginData = {},
            promises = [],
            error;
        angular.forEach(feedback.plugins, function(plugin) {
            promises.push($mmaModAssignFeedbackDelegate.preparePluginFeedbackData(assignId, userId, plugin, pluginData, siteId)
                    .catch(function(message) {
                error = message;
                return $q.reject();
            }));
        });
        return $mmUtil.allPromises(promises).then(function() {
            return pluginData;
        }).catch(function() {
            return $q.reject(error);
        });
    };
        self.discardFeedbackPluginData = function(assignId, userId, feedback, siteId) {
        var promises = [];
        angular.forEach(feedback.plugins, function(plugin) {
            promises.push($mmaModAssignFeedbackDelegate.discardPluginFeedbackData(assignId, userId, plugin, siteId));
        });
        return $q.all(promises);
    };
        self.storeSubmissionFiles = function(assignId, pluginName, files, userId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmaModAssignOffline.getSubmissionPluginFolder(assignId, pluginName, userId, siteId).then(function(folderPath) {
            return $mmFileUploader.storeFilesToUpload(folderPath, files);
        });
    };
        self.uploadFile = function(assignId, file, itemId, siteId) {
        return $mmFileUploader.uploadOrReuploadFile(file, itemId, mmaModAssignComponent, assignId, siteId);
    };
        self.uploadFiles = function(assignId, files, siteId) {
        return $mmFileUploader.uploadOrReuploadFiles(files, mmaModAssignComponent, assignId, siteId);
    };
        self.uploadOrStoreFiles = function(assignId, pluginName, files, offline, userId, siteId) {
        if (offline) {
            return self.storeSubmissionFiles(assignId, pluginName, files, userId, siteId);
        } else {
            return self.uploadFiles(assignId, files, siteId);
        }
    };
        self.getPluginsEnabled = function(assign, subtype) {
        var enabled = [];
        angular.forEach(assign.configs, function(config) {
            if (config.subtype == subtype && config.name == 'enabled' && parseInt(config.value, 10) === 1) {
                enabled.push({
                    type: config.plugin
                });
            }
        });
        return enabled;
    };
        self.getPluginConfig = function(assign, subtype, type) {
        var configs = {};
        angular.forEach(assign.configs, function(config) {
            if (config.subtype == subtype && config.plugin == type) {
                configs[config.name] = config.value;
            }
        });
        return configs;
    };
        self.getParticipants = function(assign, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmaModAssign.listParticipants(assign.id, undefined, siteId).then(function(participants) {
            if (participants && participants.length > 0) {
                return participants;
            }
            return $mmGroups.getActivityAllowedGroupsIfEnabled(assign.cmid, undefined, siteId).then(function(userGroups) {
                var promises = [],
                    particips = {};
                angular.forEach(userGroups, function(userGroup) {
                    promises.push($mmaModAssign.listParticipants(assign.id, userGroup.id, siteId).then(function(parts) {
                        angular.forEach(parts, function(p) {
                            particips[p.id] = p;
                        });
                    }));
                });
                return $q.all(promises).then(function() {
                    return $mmUtil.objectToArray(particips);
                });
            });
        });
    };
    return self;
}]);

angular.module('mm.addons.mod_assign')
.factory('$mmaModAssignPrefetchHandler', ["$mmaModAssign", "mmaModAssignComponent", "$mmSite", "$mmFilepool", "$q", "$mmCourseHelper", "$mmCourse", "$mmGroups", "$mmUser", "$mmaModAssignSubmissionDelegate", "$mmaModAssignFeedbackDelegate", "$mmPrefetchFactory", "$mmGrades", "$mmSitesManager", "$mmaModAssignHelper", function($mmaModAssign, mmaModAssignComponent, $mmSite, $mmFilepool, $q, $mmCourseHelper,
        $mmCourse, $mmGroups, $mmUser, $mmaModAssignSubmissionDelegate, $mmaModAssignFeedbackDelegate, $mmPrefetchFactory,
        $mmGrades, $mmSitesManager, $mmaModAssignHelper) {
    var self = $mmPrefetchFactory.createPrefetchHandler(mmaModAssignComponent, false);
    self.updatesNames = /^configuration$|^.*files$|^submissions$|^grades$|^gradeitems$|^outcomes$|^comments$/;
        self.canUseCheckUpdates = function(module, courseId) {
        return $mmaModAssign.getAssignment(courseId, module.id).then(function(assign) {
            return $mmaModAssign.getSubmissions(assign.id);
        }).then(function(data) {
            return !data.canviewsubmissions;
        });
    };
        self.download = function(module, courseId) {
        return self.prefetch(module, courseId);
    };
        self.getFiles = function(module, courseId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmaModAssign.getAssignment(courseId, module.id, siteId).then(function(assign) {
            var files = assign.introattachments || [];
            files = files.concat(self.getIntroFilesFromInstance(module, assign));
            return $mmaModAssign.getSubmissions(assign.id, siteId).then(function(data) {
                var blindMarking = assign.blindmarking && !assign.revealidentities;
                if (data.canviewsubmissions) {
                    return $mmaModAssign.getSubmissionsUserData(data.submissions, courseId, assign.id, blindMarking, false, siteId)
                            .then(function(submissions) {
                        var promises = [];
                        angular.forEach(submissions, function(submission) {
                            promises.push(getSubmissionFiles(assign, submission.submitid, !!submission.blindid,
                                    submission.plugins, siteId).then(function(submissionFiles) {
                                files = files.concat(submissionFiles);
                            }));
                        });
                        return $q.all(promises).then(function() {
                            return files;
                        });
                    });
                } else {
                    var userId = $mmSite.getUserId();
                    return getSubmissionFiles(assign, userId, blindMarking, [], siteId).then(function(submissionFiles) {
                        files = files.concat(submissionFiles);
                        return files;
                    });
                }
            });
        }).catch(function() {
            return [];
        });
    };
        function getSubmissionFiles(assign, submitId, blindMarking, plugins, siteId) {
        return $mmaModAssign.getSubmissionStatus(assign.id, submitId, blindMarking, true, false, siteId).then(function(response) {
            var promises = [];
            if (response.lastattempt) {
                var userSubmission = $mmaModAssign.getSubmissionObjectFromAttempt(assign, response.lastattempt);
                if (userSubmission) {
                    angular.forEach(userSubmission.plugins, function(plugin) {
                        promises.push($mmaModAssignSubmissionDelegate.getPluginFiles(assign, userSubmission, plugin, siteId));
                    });
                }
            }
            if (response.feedback) {
                angular.forEach(response.feedback.plugins, function(plugin) {
                    promises.push($mmaModAssignFeedbackDelegate.getPluginFiles(assign, response, plugin, siteId));
                });
            }
            return $q.all(promises);
        }).catch(function(error) {
            var promises = [];
            if (typeof error != "undefined") {
                return [];
            }
            angular.forEach(plugins, function(plugin) {
                promises.push($mmaModAssign.getSubmissionPluginAttachments(plugin));
            });
            return $q.all(promises);
        }).then(function(filePromises) {
            var files = [];
            angular.forEach(filePromises, function(filePromise) {
                files = files.concat(filePromise);
            });
            return files;
        });
    }
        self.getRevision = function(module, courseId) {
        return "0";
    };
        self.getTimemodified = function(module, courseId, siteId) {
        var lastModified = 0;
        siteId = siteId || $mmSite.getId();
        return $mmaModAssign.getAssignment(courseId, module.id, siteId).then(function(assign) {
            lastModified = assign.timemodified;
            return $mmaModAssign.getSubmissions(assign.id, siteId).then(function(data) {
                var blindMarking = assign.blindmarking && !assign.revealidentities,
                    promise;
                if (data.canviewsubmissions) {
                    promise = $mmaModAssign.getSubmissionsUserData(data.submissions, courseId, assign.id, blindMarking, false,
                            siteId).then(function(submissions) {
                        var promises = [];
                        angular.forEach(submissions, function(submission) {
                            promises.push(getSubmissionTimemodified(assign, courseId, module.id, submission.submitid,
                                    !!submission.blindid, siteId, submission.timemodified));
                        });
                        return $q.all(promises).then(function(lastmodifiedTimes) {
                            return Math.max.apply(null, lastmodifiedTimes);
                        });
                    });
                } else {
                    promise = $mmSitesManager.getSite(siteId).then(function(site) {
                        return getSubmissionTimemodified(assign, courseId, module.id, site.getUserId(), blindMarking, siteId);
                    });
                }
                return promise.then(function(submissionTimemodified) {
                    lastModified = Math.max(lastModified, submissionTimemodified);
                    return self.getFiles(module, courseId, siteId).then(function(files) {
                        var lastModifiedFiles = $mmFilepool.getTimemodifiedFromFileList(files);
                        return Math.max(lastModified, lastModifiedFiles);
                    });
                });
            });
        }).catch(function() {
            return lastModified;
        });
    };
        function getSubmissionTimemodified(assign, courseId, moduleId, submitId, blindMarking, siteId, timemodified) {
        return $mmaModAssign.getSubmissionStatus(assign.id, submitId, blindMarking, true, false, siteId)
                .then(function(response) {
            var lastModified = 0;
            if (response.lastattempt) {
                var userSubmission = $mmaModAssign.getSubmissionObjectFromAttempt(assign, response.lastattempt);
                if (userSubmission && lastModified < userSubmission.timemodified) {
                    lastModified = userSubmission.timemodified;
                }
            }
            if (response.feedback && lastModified < response.feedback.gradeddate) {
                lastModified = response.feedback.gradeddate;
            }
            if (submitId) {
                return $mmGrades.getGradeModuleItems(courseId, moduleId, submitId, null, siteId).then(function(gradeitems) {
                    var lastmodifiedTimes = gradeitems.map(function (value) {return value.gradedategraded || 0;});
                    lastmodifiedTimes.unshift(lastModified);
                    return Math.max.apply(null, lastmodifiedTimes);
                });
            }
            return lastModified;
        }).catch(function(error) {
            if (typeof error != 'undefined' || !timemodified) {
                return 0;
            }
            return timemodified;
        });
    }
        self.invalidateContent = function(moduleId, courseId) {
        return $mmaModAssign.invalidateContent(moduleId, courseId);
    };
        self.invalidateModule = function(module, courseId) {
        var siteId = $mmSite.getId();
        return $mmaModAssign.getAssignment(courseId, module.id, siteId).then(function(assign) {
            var promises = [];
            promises.push($mmaModAssign.invalidateAssignmentData(courseId, siteId));
            promises.push($mmaModAssign.invalidateAllSubmissionData(assign.id, siteId));
            promises.push($mmaModAssign.invalidateAssignmentUserMappingsData(assign.id, siteId));
            return $q.all(promises);
        });
    };
        self.isDownloadable = function(module, courseId) {
        return $mmaModAssign.isPrefetchEnabled();
    };
        self.isEnabled = function() {
        return $mmaModAssign.isPluginEnabled();
    };
        self.prefetch = function(module, courseId, single) {
        return self.prefetchPackage(module, courseId, single, prefetchAssign);
    };
        function prefetchAssign(module, courseId, single, siteId) {
        var userId = $mmSite.getUserId(),
            revision,
            timemod,
            promises = [];
        siteId = siteId || $mmSite.getId();
        promises.push($mmCourse.getModuleBasicInfo(module.id, siteId));
        promises.push($mmaModAssign.getAssignment(courseId, module.id, siteId).then(function(assign) {
            var subPromises = [],
                blindMarking = assign.blindmarking && !assign.revealidentities;
            if (blindMarking) {
                subPromises.push($mmaModAssign.getAssignmentUserMappings(assign.id, false, siteId).catch(function() {
                }));
            }
            subPromises.push(prefetchSubmissions(assign, courseId, module.id, siteId, userId));
            subPromises.push($mmCourseHelper.getModuleCourseIdByInstance(assign.id, 'assign', siteId));
            subPromises.push(self.getFiles(module, courseId, siteId).then(function(files) {
                var filePromises = [];
                revision = self.getRevision(module, courseId);
                angular.forEach(files, function(file) {
                    var url = file.fileurl;
                    filePromises.push($mmFilepool.addToQueueByUrl(siteId, url, self.component, module.id, file.timemodified));
                });
                return $q.all(filePromises);
            }));
            return $q.all(subPromises);
        }));
        promises.push(self.getTimemodified(module, courseId, siteId).then(function(timemodified) {
            timemod = timemodified;
        }));
        return $q.all(promises).then(function() {
            return {
                revision: revision,
                timemod: timemod
            };
        });
    }
        function prefetchSubmissions(assign, courseId, moduleId, siteId, userId) {
        return $mmaModAssign.getSubmissions(assign.id, siteId).then(function(data) {
            var promises = [],
                blindMarking = assign.blindmarking && !assign.revealidentities;
            if (data.canviewsubmissions) {
                promises.push($mmaModAssign.getSubmissionsUserData(data.submissions, courseId, assign.id, blindMarking, false)
                        .then(function(submissions) {
                    var subPromises = [];
                    angular.forEach(submissions, function(submission) {
                        subPromises.push($mmaModAssign.getSubmissionStatus(
                                assign.id, submission.submitid, !!submission.blindid, true, false, siteId).then(function(subm) {
                            return prefetchSubmission(assign, courseId, moduleId, subm, siteId, submission.submitid);
                        }));
                    });
                    return $q.all(subPromises).catch(function() {
                    });
                }));
                promises.push($mmaModAssignHelper.getParticipants(assign, siteId).then(function (participants) {
                    angular.forEach(participants, function(participant) {
                        if (participant.profileimageurl) {
                            $mmFilepool.addToQueueByUrl(siteId, participant.profileimageurl);
                        }
                    });
                }).catch(function() {
                }));
            } else {
                promises.push($mmaModAssign.getSubmissionStatus(assign.id, userId, false, true, false, siteId).then(function(subm) {
                    return prefetchSubmission(assign, courseId, moduleId, subm, siteId, userId);
                }));
            }
            promises.push($mmGroups.activityHasGroups(assign.cmid));
            promises.push($mmGroups.getActivityAllowedGroups(assign.cmid, false, siteId));
            return $q.all(promises);
        });
    }
        function prefetchSubmission(assign, courseId, moduleId, submission, siteId, userId) {
        var promises = [],
            blindMarking = assign.blindmarking && !assign.revealidentities,
            userIds = [];
        if (submission.lastattempt) {
            var userSubmission = $mmaModAssign.getSubmissionObjectFromAttempt(assign, submission.lastattempt);
            if (!blindMarking && submission.lastattempt.submissiongroupmemberswhoneedtosubmit) {
                userIds = userIds.concat(submission.lastattempt.submissiongroupmemberswhoneedtosubmit);
            }
            if (userSubmission && userSubmission.id) {
                angular.forEach(userSubmission.plugins, function(plugin) {
                    promises.push($mmaModAssignSubmissionDelegate.prefetch(assign, userSubmission, plugin, siteId));
                });
                if (userSubmission.userid) {
                    userIds.push(userSubmission.userid);
                }
            }
        }
        if (submission.feedback) {
            if (submission.feedback.grade && submission.feedback.grade.grader) {
                userIds.push(submission.feedback.grade.grader);
            }
            if (userId) {
                promises.push($mmGrades.getGradeModuleItems(courseId, moduleId, userId, null, siteId));
            }
            angular.forEach(submission.feedback.plugins, function(plugin) {
                promises.push($mmaModAssignFeedbackDelegate.prefetch(assign, submission, plugin, siteId));
            });
        }
        promises.push($mmUser.prefetchProfiles(userIds, courseId, siteId));
        return $q.all(promises);
    }
    return self;
}]);

angular.module('mm.addons.mod_assign')
.factory('$mmaModAssignSubmissionDelegate', ["$log", "$mmSite", "$mmUtil", "$q", "$translate", function($log, $mmSite, $mmUtil, $q, $translate) {
    $log = $log.getInstance('$mmaModAssignSubmissionDelegate');
    var handlers = {},
        enabledHandlers = {},
        self = {},
        updatePromises = {},
        lastUpdateHandlersStart;
        self.canPluginEditOffline = function(assign, submission, plugin) {
        var handler = self.getPluginHandler(plugin.type);
        if (handler && handler.canEditOffline) {
            return handler.canEditOffline(assign, submission, plugin);
        }
        return false;
    };
        self.clearTmpData = function(assign, submission, plugin, inputData) {
        var handler = self.getPluginHandler(plugin.type);
        if (handler && handler.clearTmpData) {
            handler.clearTmpData(assign, submission, plugin, inputData);
        }
    };
        self.copyPluginSubmissionData = function(assign, plugin, pluginData) {
        var handler = self.getPluginHandler(plugin.type);
        if (handler && handler.copySubmissionData) {
            return $q.when(handler.copySubmissionData(assign, plugin, pluginData));
        }
        return $q.when();
    };
        self.deletePluginOfflineData = function(assign, submission, plugin, offlineData, siteId) {
        var handler = self.getPluginHandler(plugin.type);
        if (handler && handler.deleteOfflineData) {
            return $q.when(handler.deleteOfflineData(assign, submission, plugin, offlineData, siteId));
        }
        return $q.when();
    };
        self.getDirectiveForPlugin = function(plugin, edit) {
        var handler = self.getPluginHandler(plugin.type);
        if (handler && handler.getDirectiveName) {
            return handler.getDirectiveName(plugin, edit);
        }
    };
        self.getPluginName = function(plugin) {
        var handler = self.getPluginHandler(plugin.type);
        if (handler && handler.getPluginName) {
            return handler.getPluginName(plugin);
        }
        var translationId = 'mma.mod_assign_submission_' + plugin.type + '.pluginname',
            translation = $translate.instant(translationId);
        if (translationId != translation) {
            return translation;
        }
        if (plugin.name) {
            return plugin.name;
        }
    };
        self.getPluginHandler = function(pluginType) {
        if (typeof enabledHandlers[pluginType] != 'undefined') {
            return enabledHandlers[pluginType];
        }
    };
        self.hasPluginDataChanged = function(assign, submission, plugin, inputData) {
        var handler = self.getPluginHandler(plugin.type);
        if (handler && handler.hasDataChanged) {
            return $q.when(handler.hasDataChanged(assign, submission, plugin, inputData));
        }
        return $q.when(false);
    };
        self.getPluginFiles = function(assign, submission, plugin, siteId) {
        siteId = siteId || $mmSite.getId();
        var handler = self.getPluginHandler(plugin.type);
        if (handler && handler.getPluginFiles) {
            return $q.when(handler.getPluginFiles(assign, submission, plugin, siteId));
        }
        return $q.when([]);
    };
        self.getPluginSizeForCopy = function(assign, plugin) {
        var handler = self.getPluginHandler(plugin.type);
        if (handler && handler.getSizeForCopy) {
            return $q.when(handler.getSizeForCopy(assign, plugin));
        }
        return $q.when(0);
    };
        self.getPluginSizeForEdit = function(assign, submission, plugin, inputData) {
        var handler = self.getPluginHandler(plugin.type);
        if (handler && handler.getSizeForEdit) {
            return $q.when(handler.getSizeForEdit(assign, submission, plugin, inputData));
        }
        return $q.when(0);
    };
        self.isLastUpdateCall = function(time) {
        if (!lastUpdateHandlersStart) {
            return true;
        }
        return time == lastUpdateHandlersStart;
    };
        self.isPluginSupported = function(pluginType) {
        return typeof enabledHandlers[pluginType] != 'undefined';
    };
        self.isPluginSupportedForEdit = function(pluginType) {
        var handler = self.getPluginHandler(pluginType);
        if (handler && handler.isEnabledForEdit) {
            return handler.isEnabledForEdit();
        }
        return false;
    };
        self.prefetch = function(assign, submission, plugin, siteId) {
        siteId = siteId || $mmSite.getId();
        var handler = self.getPluginHandler(plugin.type);
        if (handler && handler.prefetch) {
            return $q.when(handler.prefetch(assign, submission, plugin, siteId));
        }
        return $q.when();
    };
        self.preparePluginSubmissionData = function(assign, submission, plugin, inputData, pluginData, offline, userId, siteId) {
        var handler = self.getPluginHandler(plugin.type);
        if (handler && handler.prepareSubmissionData) {
            return $q.when(handler.prepareSubmissionData(
                    assign, submission, plugin, inputData, pluginData, offline, userId, siteId));
        }
        return $q.when();
    };
        self.preparePluginSyncData = function(assign, submission, plugin, offlineData, pluginData, siteId) {
        var handler = self.getPluginHandler(plugin.type);
        if (handler && handler.prepareSyncData) {
            return $q.when(handler.prepareSyncData(assign, submission, plugin, offlineData, pluginData, siteId));
        }
        return $q.when();
    };
        self.registerHandler = function(addon, pluginType, handler) {
        if (typeof handlers[pluginType] !== 'undefined') {
            $log.debug("Addon '" + addon + "' already registered as handler for '" + pluginType + "'");
            return false;
        }
        $log.debug("Registered handler '" + addon + "' for submission plugin '" + pluginType + "'");
        handlers[pluginType] = {
            addon: addon,
            instance: undefined,
            handler: handler
        };
        if ($mmSite.isLoggedIn()) {
            self.updateHandler(pluginType, handlers[pluginType]);
        }
    };
        self.updateHandler = function(pluginType, handlerInfo, time) {
        var promise,
            deleted = false,
            siteId = $mmSite.getId();
        if (updatePromises[siteId] && updatePromises[siteId][pluginType]) {
            return updatePromises[siteId][pluginType];
        } else if (!updatePromises[siteId]) {
            updatePromises[siteId] = {};
        }
        if (typeof handlerInfo.instance === 'undefined') {
            handlerInfo.instance = $mmUtil.resolveObject(handlerInfo.handler, true);
        }
        if (!$mmSite.isLoggedIn()) {
            promise = $q.reject();
        } else {
            promise = $q.when(handlerInfo.instance.isEnabled());
        }
        promise = promise.catch(function() {
            return false;
        }).then(function(enabled) {
            if (self.isLastUpdateCall(time) && $mmSite.isLoggedIn() && $mmSite.getId() === siteId) {
                if (enabled) {
                    enabledHandlers[pluginType] = handlerInfo.instance;
                } else {
                    delete enabledHandlers[pluginType];
                }
            }
        }).finally(function() {
            delete updatePromises[siteId][pluginType];
            deleted = true;
        });
        if (!deleted) {
            updatePromises[siteId][pluginType] = promise;
        }
        return promise;
    };
        self.updateHandlers = function() {
        var promises = [],
            now = new Date().getTime();
        $log.debug('Updating handlers for current site.');
        lastUpdateHandlersStart = now;
        angular.forEach(handlers, function(handlerInfo, pluginType) {
            promises.push(self.updateHandler(pluginType, handlerInfo, now));
        });
        return $q.all(promises).then(function() {
            return true;
        }, function() {
            return true;
        });
    };
    return self;
}])
.run(["$mmEvents", "mmCoreEventLogin", "mmCoreEventSiteUpdated", "$mmaModAssignSubmissionDelegate", "mmCoreEventRemoteAddonsLoaded", function($mmEvents, mmCoreEventLogin, mmCoreEventSiteUpdated, $mmaModAssignSubmissionDelegate, mmCoreEventRemoteAddonsLoaded) {
    $mmEvents.on(mmCoreEventLogin, $mmaModAssignSubmissionDelegate.updateHandlers);
    $mmEvents.on(mmCoreEventSiteUpdated, $mmaModAssignSubmissionDelegate.updateHandlers);
    $mmEvents.on(mmCoreEventRemoteAddonsLoaded, $mmaModAssignSubmissionDelegate.updateHandlers);
}]);

angular.module('mm.addons.mod_chat')
.controller('mmaModChatChatCtrl', ["$scope", "$stateParams", "$mmApp", "$mmaModChat", "$log", "$ionicModal", "$mmUtil", "$ionicHistory", "$ionicScrollDelegate", "$timeout", "$mmSite", "$interval", "mmaChatPollInterval", "$q", "$mmText", function($scope, $stateParams, $mmApp, $mmaModChat, $log, $ionicModal, $mmUtil, $ionicHistory,
            $ionicScrollDelegate, $timeout, $mmSite, $interval, mmaChatPollInterval, $q, $mmText) {
    $log = $log.getInstance('mmaModChatChatCtrl');
    var chatId = $stateParams.chatid,
        courseId = $stateParams.courseid,
        title = $stateParams.title,
        chatLastTime = 0,
        pollingRunning = false;
    $scope.loaded = false;
    $scope.title = title;
    $scope.currentUserId = $mmSite.getUserId();
    $scope.currentUserBeep = 'beep ' + $scope.currentUserId;
    $scope.messages = [];
    $scope.chatUsers = [];
    $scope.newMessage = {
        text: ''
    };
    $ionicModal.fromTemplateUrl('addons/mod/chat/templates/users.html', {
        scope: $scope,
        animation: 'slide-in-up'
    }).then(function(m) {
        $scope.modal = m;
    });
    $scope.closeModal = function(){
        $scope.modal.hide();
    };
    $scope.showChatUsers = function() {
        $scope.usersLoaded = false;
        $scope.modal.show();
        $mmaModChat.getChatUsers($scope.chatsid).then(function(data) {
            $scope.chatUsers = data.users;
        }).catch(function(error) {
            showError(error, 'mma.mod_chat.errorwhilegettingchatusers');
        }).finally(function() {
            $scope.usersLoaded = true;
        });
    };
    $scope.talkTo = function(user) {
        $scope.newMessage.text = "To " + user + ": ";
        $scope.modal.hide();
    };
    $scope.beepTo = function(userId) {
        $scope.sendMessage('', userId);
        $scope.modal.hide();
    };
    $scope.isAppOffline = function() {
        return !$mmApp.isOnline();
    };
    function loginUser() {
        return $mmaModChat.loginUser(chatId).then(function(chatsid) {
            $scope.chatsid = chatsid;
        });
    }
    function getMessages() {
        return $mmaModChat.getLatestMessages($scope.chatsid, chatLastTime).then(function(messagesInfo) {
            chatLastTime = messagesInfo.chatnewlasttime;
            return $mmaModChat.getMessagesUserData(messagesInfo.messages, courseId).then(function(messages) {
                $scope.messages = $scope.messages.concat(messages);
            });
        });
    }
    function showError(error, defaultMessage) {
        if (typeof error === 'string') {
            $mmUtil.showErrorModal(error);
        } else {
            $mmUtil.showErrorModal(defaultMessage, true);
        }
        return $q.reject();
    }
    function startPolling() {
        if ($scope.polling) {
            return;
        }
        $scope.polling = $interval(getMessagesInterval, mmaChatPollInterval);
    }
    function getMessagesInterval() {
        $log.debug('Polling for messages');
        if (!$mmApp.isOnline() || pollingRunning) {
            return $q.reject();
        }
        pollingRunning = true;
        return getMessages().catch(function() {
            return loginUser().then(function() {
                return getMessages();
            }).catch(function(error) {
                if ($scope.polling) {
                    $interval.cancel($scope.polling);
                    $scope.polling = undefined;
                }
                return showError(error, 'mma.mod_chat.errorwhileretrievingmessages');
            });
        }).finally(function() {
            pollingRunning = false;
        });
    }
    $scope.showDate = function(message, prevMessage) {
        if (!prevMessage) {
            return true;
        }
        return !moment(message.timestamp * 1000).isSame(prevMessage.timestamp * 1000, 'day');
    };
    $scope.sendMessage = function(text, beep) {
        beep = beep || '';
        if (!$mmApp.isOnline()) {
            return;
        } else if (beep === '' && !text.trim()) {
            return;
        }
        text = $mmText.replaceNewLines(text, '<br>');
        $mmaModChat.sendMessage($scope.chatsid, text, beep).then(function() {
            if (beep === '') {
                $scope.newMessage.text = '';
            }
            getMessagesInterval();
        }, function(error) {
            $mmApp.closeKeyboard();
            showError(error, 'mma.mod_chat.errorwhilesendingmessage');
        });
    };
    $scope.reconnect = function() {
        var modal = $mmUtil.showModalLoading();
        return getMessagesInterval().then(function() {
            startPolling();
        }).finally(function() {
            modal.dismiss();
        });
    };
    loginUser().then(function() {
        return getMessages().then(function() {
            startPolling();
        }).catch(function(error) {
            return showError(error, 'mma.mod_chat.errorwhileretrievingmessages');
        });
    }, function(error) {
        showError(error, 'mma.mod_chat.errorwhileconnecting');
        $ionicHistory.goBack();
    }).finally(function() {
        $scope.loaded = true;
    });
    $scope.scrollAfterRender = function(scope) {
        if (scope.$last === true) {
            $timeout(function() {
                var scrollView = $ionicScrollDelegate.$getByHandle('mmaChatScroll');
                scrollView.scrollBottom();
            });
        }
    };
    $scope.$on('$ionicView.leave', function() {
        if ($scope.polling) {
            $log.debug('Cancelling polling for conversation');
            $interval.cancel($scope.polling);
        }
    });
}]);

angular.module('mm.addons.mod_chat')
.controller('mmaModChatIndexCtrl', ["$scope", "$stateParams", "$mmaModChat", "$mmUtil", "$q", "$mmCourse", "$mmText", "$translate", "mmaModChatComponent", function($scope, $stateParams, $mmaModChat, $mmUtil, $q, $mmCourse, $mmText, $translate,
            mmaModChatComponent) {
    var module = $stateParams.module || {},
        courseid = $stateParams.courseid,
        chat;
    $scope.title = module.name;
    $scope.description = module.description;
    $scope.moduleUrl = module.url;
    $scope.courseid = courseid;
    $scope.refreshIcon = 'spinner';
    $scope.component = mmaModChatComponent;
    $scope.componentId = module.id;
    function fetchChatData(refresh) {
        return $mmaModChat.getChat(courseid, module.id, refresh).then(function(chatdata) {
            chat = chatdata;
            $scope.title = chat.name || $scope.title;
            $scope.description = chat.intro || $scope.description;
            $scope.chatId = chat.id;
            $scope.chatScheduled = '';
            var now = $mmUtil.timestamp();
            var span = chat.chattime - now;
            if (chat.chattime && chat.schedule > 0 && span > 0) {
                $mmUtil.formatTime(span).then(function(time) {
                    $scope.chatScheduled = time;
                });
            }
        }, function(error) {
            if (!refresh) {
                return fetchChatData(true);
            }
            if (error) {
                $mmUtil.showErrorModal(error);
            } else {
                $mmUtil.showErrorModal('mma.mod_chat.errorwhilegettingchatdata', true);
            }
            return $q.reject();
        });
    }
    fetchChatData().then(function() {
        $mmaModChat.logView(chat.id).then(function() {
            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
        });
    }).finally(function() {
        $scope.chatLoaded = true;
        $scope.refreshIcon = 'ion-refresh';
    });
    $scope.expandDescription = function() {
        $mmText.expandText($translate.instant('mm.core.description'), $scope.description, false, mmaModChatComponent, module.id);
    };
    $scope.refreshChat = function() {
        if ($scope.chatLoaded) {
            $scope.refreshIcon = 'spinner';
            return fetchChatData(true).finally(function() {
                $scope.refreshIcon = 'ion-refresh';
                $scope.$broadcast('scroll.refreshComplete');
            });
        }
    };
}]);
angular.module('mm.addons.mod_chat')
.factory('$mmaModChat', ["$q", "$mmSite", "$mmUser", "$mmSitesManager", function($q, $mmSite, $mmUser, $mmSitesManager) {
    var self = {};
        self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return  site.wsAvailable('mod_chat_get_chats_by_courses') &&
                    site.wsAvailable('mod_chat_login_user') &&
                    site.wsAvailable('mod_chat_get_chat_users') &&
                    site.wsAvailable('mod_chat_send_chat_message') &&
                    site.wsAvailable('mod_chat_get_chat_latest_messages');
        });
    };
        self.getChat = function(courseid, cmid, refresh) {
        var params = {
            courseids: [courseid]
            },
            preSets = {};
        if (refresh) {
            preSets.getFromCache = false;
        }
        return $mmSite.read('mod_chat_get_chats_by_courses', params, preSets).then(function(response) {
            if (response.chats) {
                var currentChat;
                angular.forEach(response.chats, function(chat) {
                    if (chat.coursemodule == cmid) {
                        currentChat = chat;
                    }
                });
                if (currentChat) {
                    return currentChat;
                }
            }
            return $q.reject();
        });
    };
        self.loginUser = function(chatId) {
        var params = {
            chatid: chatId
        };
        return $mmSite.write('mod_chat_login_user', params).then(function(response) {
            if (response.chatsid) {
                return response.chatsid;
            }
            return $q.reject();
        });
    };
        self.logView = function(id) {
        if (id) {
            var params = {
                chatid: id
            };
            return $mmSite.write('mod_chat_view_chat', params);
        }
        return $q.reject();
    };
        self.sendMessage = function(chatsid, message, beep) {
        var params = {
            chatsid: chatsid,
            messagetext: message,
            beepid: beep
        };
        return $mmSite.write('mod_chat_send_chat_message', params).then(function(response) {
            if (response.messageid) {
                return response.messageid;
            }
            return $q.reject();
        });
    };
        self.getLatestMessages = function(chatsid, lasttime) {
        var params = {
            chatsid: chatsid,
            chatlasttime: lasttime
        };
        return $mmSite.write('mod_chat_get_chat_latest_messages', params);
    };
        self.getMessagesUserData = function(messages, courseid) {
        var promises = [];
        angular.forEach(messages, function(message) {
            var promise = $mmUser.getProfile(message.userid, courseid, true).then(function(user) {
                message.userfullname = user.fullname;
                message.userprofileimageurl = user.profileimageurl;
            }, function() {
                message.userfullname = message.userid;
            });
            promises.push(promise);
        });
        return $q.all(promises).then(function() {
            return messages;
        });
    };
        self.getChatUsers = function(chatsid) {
        var params = {
            chatsid: chatsid
        };
        var preSets = {
            getFromCache: false
        };
        return $mmSite.read('mod_chat_get_chat_users', params, preSets);
    };
    return self;
}]);
angular.module('mm.addons.mod_chat')
.factory('$mmaModChatHandlers', ["$mmCourse", "$mmaModChat", "$state", "$mmContentLinksHelper", function($mmCourse, $mmaModChat, $state, $mmContentLinksHelper) {
    var self = {};
        self.courseContent = function() {
        var self = {};
                self.isEnabled = function() {
            return $mmaModChat.isPluginEnabled();
        };
                self.getController = function(module, courseid) {
            return function($scope) {
                $scope.title = module.name;
                $scope.icon = $mmCourse.getModuleIconSrc('chat');
                $scope.class = 'mma-mod_chat-handler';
                $scope.action = function(e) {
                    $state.go('site.mod_chat', {module: module, courseid: courseid});
                };
            };
        };
        return self;
    };
        self.linksHandler = $mmContentLinksHelper.createModuleIndexLinkHandler('mmaModChat', 'chat', $mmaModChat);
    return self;
}]);
angular.module('mm.addons.mod_choice')
.controller('mmaModChoiceIndexCtrl', ["$scope", "$stateParams", "$mmaModChoice", "$mmUtil", "$mmCourseHelper", "$q", "$mmCourse", "$mmText", "mmaModChoiceComponent", "mmaModChoiceAutomSyncedEvent", "$mmSite", "$mmEvents", "$mmaModChoiceSync", "$ionicScrollDelegate", "$mmaModChoiceOffline", "$mmApp", "$translate", "mmCoreEventOnlineStatusChanged", function($scope, $stateParams, $mmaModChoice, $mmUtil, $mmCourseHelper, $q, $mmCourse, $mmText,
            mmaModChoiceComponent, mmaModChoiceAutomSyncedEvent, $mmSite, $mmEvents, $mmaModChoiceSync, $ionicScrollDelegate,
            $mmaModChoiceOffline, $mmApp, $translate, mmCoreEventOnlineStatusChanged) {
    var module = $stateParams.module || {},
        courseId = $stateParams.courseid,
        choice,
        userId = $mmSite.getUserId(),
        scrollView,
        syncObserver, onlineObserver,
        hasAnsweredOnline = false;
    $scope.title = module.name;
    $scope.description = module.description;
    $scope.moduleUrl = module.url;
    $scope.moduleName = $mmCourse.translateModuleName('choice');
    $scope.courseId = courseId;
    $scope.refreshIcon = 'spinner';
    $scope.syncIcon = 'spinner';
    $scope.component = mmaModChoiceComponent;
    $scope.componentId = module.id;
    function fetchChoiceData(refresh, sync, showErrors) {
        $scope.isOnline = $mmApp.isOnline();
        $scope.now = new Date().getTime();
        return $mmaModChoice.getChoice(courseId, module.id).then(function(choicedata) {
            choice = choicedata;
            choice.timeopen = parseInt(choice.timeopen) * 1000;
            choice.openTimeReadable = moment(choice.timeopen).format('LLL');
            choice.timeclose = parseInt(choice.timeclose) * 1000;
            choice.closeTimeReadable = moment(choice.timeclose).format('LLL');
            $scope.title = choice.name || $scope.title;
            $scope.description = choice.intro || $scope.description;
            $scope.choice = choice;
            if (sync) {
                return syncChoice(showErrors).catch(function() {
                });
            }
        }).then(function() {
            return $mmaModChoiceOffline.hasResponse(choice.id);
        }).then(function(hasOffline) {
            $scope.hasOffline = hasOffline;
            return fetchOptions(hasOffline).then(function() {
                return fetchResults();
            });
        }).then(function() {
            $mmCourseHelper.fillContextMenu($scope, module, courseId, refresh, mmaModChoiceComponent);
        }).catch(function(message) {
            if (!refresh) {
                return refreshAllData(sync);
            }
            if (message) {
                $mmUtil.showErrorModal(message);
            } else {
                $mmUtil.showErrorModal('mma.mod_choice.errorgetchoice', true);
            }
            return $q.reject();
        });
    }
    function fetchOptions(hasOffline) {
        return $mmaModChoice.getOptions(choice.id).then(function(options) {
            var promise;
            hasAnsweredOnline = false;
            angular.forEach(options, function(option) {
                hasAnsweredOnline = hasAnsweredOnline || option.checked;
            });
            if (hasOffline) {
                promise = $mmaModChoiceOffline.getResponse(choice.id).then(function(response) {
                    var optionsKeys = {};
                    angular.forEach(options, function(option) {
                        optionsKeys[option.id] = option;
                    });
                    if (response.deleting) {
                        if (response.responses.length > 0) {
                            angular.forEach(response.responses, function(selected) {
                                if (optionsKeys[selected] && optionsKeys[selected].checked) {
                                    optionsKeys[selected].checked = false;
                                    optionsKeys[selected].countanswers--;
                                }
                            });
                        } else {
                            angular.forEach(optionsKeys, function(option) {
                                if (option.checked) {
                                    option.checked = false;
                                    option.countanswers--;
                                }
                            });
                        }
                    } else {
                        angular.forEach(optionsKeys, function(option) {
                            if (option.checked) {
                                option.checked = false;
                                option.countanswers--;
                            }
                        });
                        angular.forEach(response.responses, function(selected) {
                            if (optionsKeys[selected]) {
                                optionsKeys[selected].checked = true;
                                optionsKeys[selected].countanswers++;
                            }
                        });
                    }
                    return Object.keys(optionsKeys).map(function (key) {return optionsKeys[key]});
                });
            } else {
                promise = $q.when(options);
            }
            promise.then(function(options) {
                var isOpen = isChoiceOpen();
                var hasAnswered = false;
                $scope.selectedOption = {id: -1};
                angular.forEach(options, function(option) {
                    if (option.checked) {
                        hasAnswered = true;
                        if (!choice.allowmultiple) {
                            $scope.selectedOption.id = option.id;
                        }
                    }
                });
                $scope.canEdit = isOpen && (choice.allowupdate || !hasAnswered);
                $scope.canDelete = $mmaModChoice.isDeleteResponsesEnabled() && isOpen && choice.allowupdate && hasAnswered;
                $scope.options = options;
            });
        });
    }
    function fetchResults() {
        return $mmaModChoice.getResults(choice.id).then(function(results) {
            var hasVotes = false;
            $scope.data = [];
            $scope.labels = [];
            angular.forEach(results, function(result) {
                if (result.numberofuser > 0) {
                    hasVotes = true;
                }
                result.percentageamount = parseFloat(result.percentageamount).toFixed(1);
                $scope.data.push(result.numberofuser);
                $scope.labels.push(result.text);
            });
            $scope.canSeeResults = hasVotes || $mmaModChoice.canStudentSeeResults(choice, hasAnsweredOnline);
            $scope.results = results;
        });
    }
        function isChoiceOpen() {
        return (choice.timeopen === 0 || choice.timeopen <= $scope.now) &&
                (choice.timeclose === 0 || choice.timeclose > $scope.now);
    }
    function refreshAllData(sync, showErrors) {
        var p1 = $mmaModChoice.invalidateChoiceData(courseId),
            p2 = choice ? $mmaModChoice.invalidateOptions(choice.id) : $q.when(),
            p3 = choice ? $mmaModChoice.invalidateResults(choice.id) : $q.when();
        return $q.all([p1, p2, p3]).finally(function() {
            return fetchChoiceData(true, sync, showErrors);
        });
    }
    fetchChoiceData(false, true).then(function() {
        $mmaModChoice.logView(choice.id).then(function() {
            $mmCourse.checkModuleCompletion(courseId, module.completionstatus);
        });
    }).finally(function() {
        $scope.choiceLoaded = true;
        $scope.refreshIcon = 'ion-refresh';
        $scope.syncIcon = 'ion-loop';
    });
    $scope.save = function() {
        var promise = choice.allowupdate ? $q.when() : $mmUtil.showConfirm($translate('mm.core.areyousure'));
        promise.then(function() {
            var responses = [];
            if (choice.allowmultiple) {
                angular.forEach($scope.options, function(option) {
                    if (option.checked) {
                        responses.push(option.id);
                    }
                });
            } else {
                responses.push($scope.selectedOption.id);
            }
            var modal = $mmUtil.showModalLoading('mm.core.sending', true);
            $mmaModChoice.submitResponse(choice.id, choice.name, courseId, responses).then(function() {
                $mmCourse.checkModuleCompletion(courseId, module.completionstatus);
                scrollTop();
                return refreshAllData(false);
            }).catch(function(message) {
                if (message) {
                    $mmUtil.showErrorModal(message);
                } else {
                    $mmUtil.showErrorModal('mma.mod_choice.cannotsubmit', true);
                }
            }).finally(function() {
                modal.dismiss();
            });
        });
    };
    $scope.delete = function() {
        $mmUtil.showConfirm($translate('mm.core.areyousure')).then(function() {
            var modal = $mmUtil.showModalLoading('mm.core.sending', true);
            $mmaModChoice.deleteResponses(choice.id, choice.name, courseId).then(function() {
                scrollTop();
                return refreshAllData(false);
            }).catch(function(message) {
                if (message) {
                    $mmUtil.showErrorModal(message);
                } else {
                    $mmUtil.showErrorModal('mma.mod_choice.cannotsubmit', true);
                }
            }).finally(function() {
                modal.dismiss();
            });
        });
    };
    $scope.removeFiles = function() {
        $mmCourseHelper.confirmAndRemove(module, courseId);
    };
    $scope.prefetch = function() {
        $mmCourseHelper.contextMenuPrefetch($scope, module, courseId);
    };
    $scope.expandDescription = function() {
        $mmText.expandText($translate.instant('mm.core.description'), $scope.description, false, mmaModChoiceComponent, module.id);
    };
    $scope.refreshChoice = function(showErrors) {
        if ($scope.choiceLoaded) {
            $scope.refreshIcon = 'spinner';
            $scope.syncIcon = 'spinner';
            return refreshAllData(true, showErrors).finally(function() {
                $scope.refreshIcon = 'ion-refresh';
                $scope.syncIcon = 'ion-loop';
                $scope.$broadcast('scroll.refreshComplete');
            });
        }
    };
    function scrollTop() {
        if (!scrollView) {
            scrollView = $ionicScrollDelegate.$getByHandle('mmaModChoiceScroll');
        }
        scrollView && scrollView.scrollTop && scrollView.scrollTop();
    }
    function syncChoice(showErrors) {
        return $mmaModChoiceSync.syncChoice(choice.id, userId).then(function(result) {
            if (result.warnings && result.warnings.length) {
                $mmUtil.showErrorModal(result.warnings[0]);
            }
            return result.updated;
        }).catch(function(error) {
            if (showErrors) {
                if (error) {
                    $mmUtil.showErrorModal(error);
                } else {
                    $mmUtil.showErrorModal('mm.core.errorsync', true);
                }
            }
            return $q.reject();
        });
    }
    onlineObserver = $mmEvents.on(mmCoreEventOnlineStatusChanged, function(online) {
        $scope.isOnline = online;
    });
    syncObserver = $mmEvents.on(mmaModChoiceAutomSyncedEvent, function(data) {
        if (choice && data && data.siteid == $mmSite.getId() && data.choiceid == choice.id && data.userid == userId) {
            $scope.choiceLoaded = false;
            $scope.refreshIcon = 'spinner';
            $scope.syncIcon = 'spinner';
            scrollTop();
            refreshAllData(false).finally(function() {
                $scope.choiceLoaded = true;
                $scope.refreshIcon = 'ion-refresh';
                $scope.syncIcon = 'ion-loop';
            });
        }
    });
    $scope.$on('$destroy', function() {
        syncObserver && syncObserver.off && syncObserver.off();
        onlineObserver && onlineObserver.off && onlineObserver.off();
    });
}]);
angular.module('mm.addons.mod_choice')
.factory('$mmaModChoice', ["$q", "$mmSite", "$mmSitesManager", "mmaModChoiceResultsAfterAnswer", "mmaModChoiceResultsAfterClose", "mmaModChoiceResultsAlways", "mmaModChoiceComponent", "$mmFilepool", "$mmApp", "$mmaModChoiceOffline", "$mmUtil", function($q, $mmSite, $mmSitesManager, mmaModChoiceResultsAfterAnswer, mmaModChoiceResultsAfterClose,
            mmaModChoiceResultsAlways, mmaModChoiceComponent, $mmFilepool, $mmApp, $mmaModChoiceOffline, $mmUtil) {
    var self = {};
        self.canStudentSeeResults = function(choice, hasAnswered) {
        var now = new Date().getTime();
        return  choice.showresults === mmaModChoiceResultsAlways ||
                choice.showresults === mmaModChoiceResultsAfterClose && choice.timeclose !== 0 && choice.timeclose <= now ||
                choice.showresults === mmaModChoiceResultsAfterAnswer && hasAnswered;
    };
        self.deleteResponses = function(choiceId, name, courseId, responses, siteId) {
        siteId = siteId || $mmSite.getId();
        responses = responses || [];
        if (!$mmApp.isOnline()) {
            return storeOffline();
        }
        return $mmaModChoiceOffline.deleteResponse(choiceId, siteId).then(function() {
            return self.deleteResponsesOnline(choiceId, responses, siteId).then(function() {
                return true;
            }).catch(function(error) {
                if (error && error.wserror) {
                    return $q.reject(error.error);
                } else {
                    return storeOffline();
                }
            });
        });
        function storeOffline() {
            return $mmaModChoiceOffline.saveResponse(choiceId, name, courseId, responses, true, siteId).then(function() {
                return false;
            });
        }
    };
        self.deleteResponsesOnline = function(choiceId, responses, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                choiceid: choiceId,
                responses: responses
            };
            return site.write('mod_choice_delete_choice_responses', params).catch(function(error) {
                return $q.reject({
                    error: error,
                    wserror: $mmUtil.isWebServiceError(error)
                });
            }).then(function(response) {
                if (!response || response.status === false) {
                    return $q.reject({
                        wserror: true
                    });
                }
                var promises = [
                    self.invalidateOptions(choiceId, siteId),
                    self.invalidateResults(choiceId, siteId)
                ];
                return $q.all(promises).catch(function() {
                });
            });
        });
    };
        function getChoiceDataCacheKey(courseid) {
        return 'mmaModChoice:choice:' + courseid;
    }
        function getChoiceOptionsCacheKey(choiceid) {
        return 'mmaModChoice:options:' + choiceid;
    }
        function getChoiceResultsCacheKey(choiceid) {
        return 'mmaModChoice:results:' + choiceid;
    }
        self.isDeleteResponsesEnabled = function() {
        return $mmSite.wsAvailable('mod_choice_delete_choice_responses');
    };
        self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return  site.wsAvailable('mod_choice_get_choice_options') &&
                    site.wsAvailable('mod_choice_get_choice_results') &&
                    site.wsAvailable('mod_choice_get_choices_by_courses') &&
                    site.wsAvailable('mod_choice_submit_choice_response');
        });
    };
        function getChoice(siteId, courseId, key, value, forceCache) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    courseids: [courseId]
                },
                preSets = {
                    cacheKey: getChoiceDataCacheKey(courseId)
                };
            if (forceCache) {
                preSets.omitExpires = true;
            }
            return site.read('mod_choice_get_choices_by_courses', params, preSets).then(function(response) {
                if (response && response.choices) {
                    var currentChoice;
                    angular.forEach(response.choices, function(choice) {
                        if (!currentChoice && choice[key] == value) {
                            currentChoice = choice;
                        }
                    });
                    if (currentChoice) {
                        return currentChoice;
                    }
                }
                return $q.reject();
            });
        });
    }
        self.getChoice = function(courseId, cmId, siteId, forceCache) {
        siteId = siteId || $mmSite.getId();
        return getChoice(siteId, courseId, 'coursemodule', cmId, forceCache);
    };
        self.getChoiceById = function(courseId, id, siteId, forceCache) {
        siteId = siteId || $mmSite.getId();
        return getChoice(siteId, courseId, 'id', id, forceCache);
    };
        self.getOptions = function(choiceid) {
        var params = {
                choiceid: choiceid
            },
            preSets = {
                cacheKey: getChoiceOptionsCacheKey(choiceid)
            };
        return $mmSite.read('mod_choice_get_choice_options', params, preSets).then(function(response) {
            if (response.options) {
                return response.options;
            }
            return $q.reject();
        });
    };
        self.getResults = function(choiceid) {
        var params = {
                choiceid: choiceid
            },
            preSets = {
                cacheKey: getChoiceResultsCacheKey(choiceid)
            };
        return $mmSite.read('mod_choice_get_choice_results', params, preSets).then(function(response) {
            if (response.options) {
                return response.options;
            }
            return $q.reject();
        });
    };
        self.invalidateChoiceData = function(courseid) {
        return $mmSite.invalidateWsCacheForKey(getChoiceDataCacheKey(courseid));
    };
        self.invalidateContent = function(moduleId, courseId) {
        var promises = [],
            siteId = $mmSite.getId();
        promises.push(self.getChoice(courseId, moduleId).then(function(choice) {
            var ps = [];
            ps.push(self.invalidateChoiceData(courseId));
            ps.push(self.invalidateOptions(choice.id));
            ps.push(self.invalidateResults(choice.id));
            return $q.all(ps);
        }));
        promises.push($mmFilepool.invalidateFilesByComponent(siteId, mmaModChoiceComponent, moduleId));
        return $q.all(promises);
    };
        self.invalidateOptions = function(choiceId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getChoiceOptionsCacheKey(choiceId));
        });
    };
        self.invalidateResults = function(choiceId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getChoiceResultsCacheKey(choiceId));
        });
    };
        self.logView = function(id) {
        if (id) {
            var params = {
                choiceid: id
            };
            return $mmSite.write('mod_choice_view_choice', params);
        }
        return $q.reject();
    };
        self.submitResponse = function(choiceId, name, courseId, responses, siteId) {
        siteId = siteId || $mmSite.getId();
        if (!$mmApp.isOnline()) {
            return storeOffline();
        }
        return $mmaModChoiceOffline.deleteResponse(choiceId, siteId).then(function() {
            return self.submitResponseOnline(choiceId, responses, siteId).then(function() {
                return true;
            }).catch(function(error) {
                if (error && error.wserror) {
                    return $q.reject(error.error);
                } else {
                    return storeOffline();
                }
            });
        });
        function storeOffline() {
            return $mmaModChoiceOffline.saveResponse(choiceId, name, courseId, responses, false, siteId).then(function() {
                return false;
            });
        }
    };
        self.submitResponseOnline = function(choiceId, responses, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                choiceid: choiceId,
                responses: responses
            };
            return site.write('mod_choice_submit_choice_response', params).catch(function(error) {
                return $q.reject({
                    error: error,
                    wserror: $mmUtil.isWebServiceError(error)
                });
            }).then(function() {
                var promises = [
                    self.invalidateOptions(choiceId, siteId),
                    self.invalidateResults(choiceId, siteId)
                ];
                return $q.all(promises).catch(function() {
                });
            });
        });
    };
    return self;
}]);

angular.module('mm.addons.mod_choice')
.constant('mmaModChoiceOfflineResponsesStore', 'mma_mod_choice_offline_responses')
.config(["$mmSitesFactoryProvider", "mmaModChoiceOfflineResponsesStore", function($mmSitesFactoryProvider, mmaModChoiceOfflineResponsesStore) {
    var stores = [
        {
            name: mmaModChoiceOfflineResponsesStore,
            keyPath: ['choiceid', 'userid'],
            indexes: [
                {
                    name: 'choiceid'
                },
                {
                    name: 'courseid'
                },
                {
                    name: 'userid'
                },
                {
                    name: 'timecreated'
                }
            ]
        }
    ];
    $mmSitesFactoryProvider.registerStores(stores);
}])
.factory('$mmaModChoiceOffline', ["$log", "mmaModChoiceOfflineResponsesStore", "$mmSitesManager", "$mmSite", function($log, mmaModChoiceOfflineResponsesStore, $mmSitesManager, $mmSite) {
    $log = $log.getInstance('$mmaModChoiceOffline');
    var self = {};
        self.deleteResponse = function(choiceId, siteId, userId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            return site.getDb().remove(mmaModChoiceOfflineResponsesStore, [choiceId, userId]);
        });
    };
        self.getResponses = function(siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.getDb().getAll(mmaModChoiceOfflineResponsesStore);
        });
    };
        self.hasResponse = function(choiceId, siteId, userId) {
        return self.getResponse(choiceId, siteId, userId).then(function(response) {
            return !!response.choiceid;
        }).catch(function(error) {
            return false;
        });;
    };
        self.getResponse = function(choiceId, siteId, userId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            return site.getDb().get(mmaModChoiceOfflineResponsesStore, [choiceId, userId]);
        });
    };
        self.saveResponse = function(choiceId, name, courseId, responses, deleting, siteId, userId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            var db = site.getDb(),
                response = {
                    choiceid: choiceId,
                    name: name,
                    courseid: courseId,
                    userid: userId,
                    responses: responses,
                    deleting: !!deleting,
                    timecreated: new Date().getTime()
                };
            return db.insert(mmaModChoiceOfflineResponsesStore, response);
        });
    };
    return self;
}]);

angular.module('mm.addons.mod_choice')
.factory('$mmaModChoiceSync', ["$q", "$log", "$mmApp", "$mmSitesManager", "$mmaModChoiceOffline", "$mmSite", "$mmEvents", "$mmSync", "mmaModChoiceComponent", "$mmaModChoice", "$translate", "$mmCourse", "mmaModChoiceAutomSyncedEvent", function($q, $log, $mmApp, $mmSitesManager, $mmaModChoiceOffline, $mmSite, $mmEvents, $mmSync,
        mmaModChoiceComponent, $mmaModChoice, $translate, $mmCourse, mmaModChoiceAutomSyncedEvent) {
    $log = $log.getInstance('$mmaModChoiceSync');
    var self = $mmSync.createChild(mmaModChoiceComponent);
        self.syncAllChoices = function(siteId) {
        if (!$mmApp.isOnline()) {
            $log.debug('Cannot sync all choices because device is offline.');
            return $q.reject();
        }
        var promise;
        if (!siteId) {
            $log.debug('Try to sync choices in all sites.');
            promise = $mmSitesManager.getSitesIds();
        } else {
            $log.debug('Try to sync choices in site ' + siteId);
            promise = $q.when([siteId]);
        }
        return promise.then(function(siteIds) {
            var sitePromises = [];
            angular.forEach(siteIds, function(siteId) {
                sitePromises.push($mmaModChoiceOffline.getResponses(siteId).then(function(responses) {
                    var promises = [];
                    angular.forEach(responses, function(response) {
                        promises.push(self.syncChoice(response.choiceid, response.userid, siteId).then(function(result) {
                            if (result && result.updated) {
                                $mmEvents.trigger(mmaModChoiceAutomSyncedEvent, {
                                    siteid: siteId,
                                    choiceid: response.choiceid,
                                    userid: response.userid,
                                    warnings: result.warnings
                                });
                            }
                        }));
                    });
                    return $q.all(promises);
                }));
            });
            return $q.all(sitePromises);
        });
    };
        self.syncChoice = function(choiceId, userId, siteId) {
        siteId = siteId || $mmSite.getId();
        var syncPromise,
            courseId,
            syncId = self._getSyncId(choiceId, userId),
            result = {
                warnings: [],
                updated: false
            };
        if (self.isSyncing(syncId, siteId)) {
            return self.getOngoingSync(syncId, siteId);
        }
        $log.debug('Try to sync choice ' + choiceId + ' for user ' + userId);
        syncPromise = $mmaModChoiceOffline.getResponse(choiceId, siteId, userId).catch(function() {
            return {};
        }).then(function(data) {
            if (!data.choiceid) {
                return;
            } else if (!$mmApp.isOnline()) {
                return $q.reject();
            }
            var promise;
            courseId = data.courseid;
            if (data.deleting) {
                promise = $mmaModChoice.deleteResponsesOnline(choiceId, data.responses, siteId);
            } else {
                promise = $mmaModChoice.submitResponseOnline(choiceId, data.responses, siteId);
            }
            return promise.then(function() {
                result.updated = true;
                return $mmaModChoiceOffline.deleteResponse(choiceId, siteId, userId);
            }).catch(function(error) {
                if (error && error.wserror) {
                    result.updated = true;
                    return $mmaModChoiceOffline.deleteResponse(choiceId, siteId, userId).then(function() {
                        result.warnings.push($translate.instant('mm.core.warningofflinedatadeleted', {
                            component: $mmCourse.translateModuleName('choice'),
                            name: data.name,
                            error: error.error
                        }));
                    });
                } else {
                    return $q.reject(error && error.error);
                }
            });
        }).then(function() {
            if (courseId) {
                var p1 = $mmaModChoice.invalidateChoiceData(courseId),
                    p2 = choiceId ? $mmaModChoice.invalidateOptions(choiceId) : $q.when(),
                    p3 = choiceId ? $mmaModChoice.invalidateResults(choiceId) : $q.when();
                return $q.all([p1, p2, p3]).then(function() {
                    return $mmaModChoice.getChoiceById(courseId, choiceId, siteId);
                }).catch(function() {
                });
            }
        }).then(function() {
            return self.setSyncTime(syncId, siteId).catch(function() {
            });
        }).then(function() {
            return result;
        });
        return self.addOngoingSync(syncId, syncPromise, siteId);
    };
        self._getSyncId = function(choiceId, userId) {
        return choiceId + '#' + userId;
    };
    return self;
}]);

angular.module('mm.addons.mod_choice')
.factory('$mmaModChoiceHandlers', ["$mmCourse", "$mmaModChoice", "$state", "$mmContentLinksHelper", "$mmUtil", "$mmEvents", "$mmSite", "$mmaModChoicePrefetchHandler", "$mmCoursePrefetchDelegate", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", "mmaModChoiceComponent", "mmCoreEventPackageStatusChanged", "mmCoreDownloaded", "$mmaModChoiceSync", function($mmCourse, $mmaModChoice, $state, $mmContentLinksHelper, $mmUtil, $mmEvents, $mmSite,
            $mmaModChoicePrefetchHandler, $mmCoursePrefetchDelegate, mmCoreDownloading, mmCoreNotDownloaded, mmCoreOutdated,
            mmaModChoiceComponent, mmCoreEventPackageStatusChanged, mmCoreDownloaded, $mmaModChoiceSync) {
    var self = {};
        self.courseContent = function() {
        var self = {};
                self.isEnabled = function() {
            return $mmaModChoice.isPluginEnabled();
        };
                self.getController = function(module, courseId) {
            return function($scope) {
                var downloadBtn = {
                        hidden: true,
                        icon: 'ion-ios-cloud-download-outline',
                        label: 'mm.core.download',
                        action: function(e) {
                            if (e) {
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            download();
                        }
                    },
                    refreshBtn = {
                        hidden: true,
                        icon: 'ion-android-refresh',
                        label: 'mm.core.refresh',
                        action: function(e) {
                            if (e) {
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            $mmaModChoice.invalidateContent(module.id, courseId).finally(function() {
                                download();
                            });
                        }
                    };
                $scope.title = module.name;
                $scope.icon = $mmCourse.getModuleIconSrc('choice');
                $scope.class = 'mma-mod_choice-handler';
                $scope.buttons = [downloadBtn, refreshBtn];
                $scope.spinner = true;
                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_choice', {module: module, courseid: courseId});
                };
                function download() {
                    $scope.spinner = true;
                    $mmaModChoicePrefetchHandler.getDownloadSize(module, courseId).then(function(size) {
                        $mmUtil.confirmDownloadSize(size).then(function() {
                            $mmaModChoicePrefetchHandler.prefetch(module, courseId).catch(function() {
                                if (!$scope.$$destroyed) {
                                    $mmUtil.showErrorModal('mm.core.errordownloading', true);
                                }
                            });
                        }).catch(function() {
                            $scope.spinner = false;
                        });
                    }).catch(function(error) {
                        $scope.spinner = false;
                        if (error) {
                            $mmUtil.showErrorModal(error);
                        } else {
                            $mmUtil.showErrorModal('mm.core.errordownloading', true);
                        }
                    });
                }
                function showStatus(status) {
                    if (status) {
                        $scope.spinner = status === mmCoreDownloading;
                        downloadBtn.hidden = status !== mmCoreNotDownloaded;
                        refreshBtn.hidden = status !== mmCoreOutdated;
                        if (!$mmCoursePrefetchDelegate.canCheckUpdates()) {
                            refreshBtn.hidden = refreshBtn.hidden && status !== mmCoreDownloaded;
                        }
                    }
                }
                var statusObserver = $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
                    if (data.siteid === $mmSite.getId() && data.componentId === module.id &&
                            data.component === mmaModChoiceComponent) {
                        showStatus(data.status);
                    }
                });
                $mmCoursePrefetchDelegate.getModuleStatus(module, courseId).then(showStatus);
                $scope.$on('$destroy', function() {
                    statusObserver && statusObserver.off && statusObserver.off();
                });
            };
        };
        return self;
    };
        self.linksHandler = $mmContentLinksHelper.createModuleIndexLinkHandler('mmaModChoice', 'choice', $mmaModChoice);
        self.syncHandler = function() {
        var self = {};
                self.execute = function(siteId) {
            return $mmaModChoiceSync.syncAllChoices(siteId);
        };
                self.getInterval = function() {
            return 600000;
        };
                self.isSync = function() {
            return true;
        };
                self.usesNetwork = function() {
            return true;
        };
        return self;
    };
    return self;
}]);

angular.module('mm.addons.mod_choice')
.factory('$mmaModChoicePrefetchHandler', ["$mmaModChoice", "mmaModChoiceComponent", "$mmFilepool", "$q", "$mmUtil", "mmCoreDownloaded", "mmCoreOutdated", "$mmUser", "$mmPrefetchFactory", function($mmaModChoice, mmaModChoiceComponent, $mmFilepool, $q, $mmUtil,
            mmCoreDownloaded, mmCoreOutdated, $mmUser, $mmPrefetchFactory) {
    var self = $mmPrefetchFactory.createPrefetchHandler(mmaModChoiceComponent);
    self.updatesNames = /^configuration$|^.*files$|^answers$/;
        self.determineStatus = function(status, canCheck) {
        if (!canCheck && status === mmCoreDownloaded) {
            return mmCoreOutdated;
        } else {
            return status;
        }
    };
        self.download = function(module, courseId) {
        return self.prefetch(module, courseId);
    };
        self.getFiles = function(module, courseId) {
        return self.getIntroFiles(module, courseId);
    };
        self.getIntroFiles = function(module, courseId) {
        return $mmaModChoice.getChoice(courseId, module.id).catch(function() {
        }).then(function(choice) {
            return self.getIntroFilesFromInstance(module, choice);
        });
    };
        self.getRevision = function(module, courseId) {
        return "0";
    };
        self.getTimemodified = function(module, courseId) {
        return 0;
    };
        self.invalidateContent = function(moduleId, courseId) {
        return $mmaModChoice.invalidateContent(moduleId, courseId);
    };
        self.invalidateModule = function(module, courseId) {
        return $mmaModChoice.invalidateChoiceData(courseId);
    };
        self.isDownloadable = function(module, courseId) {
        return $mmaModChoice.getChoice(courseId, module.id, false, true).then(function(choice) {
            var now = $mmUtil.timestamp();
            if (choice.timeopen && choice.timeopen > now) {
                return false;
            }
            return true;
        });
    };
        self.isEnabled = function() {
        return $mmaModChoice.isPluginEnabled();
    };
        self.prefetch = function(module, courseId, single) {
        return self.prefetchPackage(module, courseId, single, prefetchChoice);
    };
        function prefetchChoice(module, courseId, single, siteId) {
        return $mmaModChoice.getChoice(courseId, module.id).then(function(choice) {
            var promises = [],
                files = self.getIntroFilesFromInstance(module, choice);
            angular.forEach(files, function(file) {
                promises.push($mmFilepool.addToQueueByUrl(siteId, file.fileurl, self.component, module.id, file.timemodified));
            });
            promises.push($mmaModChoice.getOptions(choice.id));
            promises.push($mmaModChoice.getResults(choice.id).then(function(options) {
                var subPromises = [];
                angular.forEach(options, function(option) {
                    angular.forEach(option.userresponses, function(response) {
                        if (response.userid) {
                            subPromises.push($mmUser.getProfile(response.userid, courseId));
                        }
                        if (response.profileimageurl) {
                            subPromises.push($mmFilepool.addToQueueByUrl(siteId, response.profileimageurl).catch(function() {
                            }));
                        }
                    });
                });
                return $q.all(subPromises);
            }));
            return $q.all(promises);
        }).then(function() {
            return {};
        });
    }
    return self;
}]);

angular.module('mm.addons.mod_folder')
.controller('mmaModFolderIndexCtrl', ["$scope", "$stateParams", "$mmaModFolder", "$mmCourse", "$mmUtil", "$q", "$mmText", "$translate", "mmaModFolderComponent", "$mmCourseHelper", "$mmApp", function($scope, $stateParams, $mmaModFolder, $mmCourse, $mmUtil, $q, $mmText, $translate,
            mmaModFolderComponent, $mmCourseHelper, $mmApp) {
    var module = $stateParams.module || {},
        courseId = $stateParams.courseid,
        sectionId = $stateParams.sectionid,
        path = $stateParams.path;
    $scope.title = module.name;
    $scope.description = module.description;
    $scope.moduleUrl = module.url;
    $scope.refreshIcon = 'spinner';
    $scope.component = mmaModFolderComponent;
    $scope.componentId = module.id;
    function showModuleData(module) {
        $scope.title = module.name;
        $scope.description = module.description;
        if (path) {
            $scope.contents = module.contents;
        } else {
            $scope.contents = $mmaModFolder.formatContents(module.contents);
        }
    }
    function fetchFolder(refresh) {
        return $mmCourse.getModule(module.id, courseId, sectionId).then(function(mod) {
            if (!mod.contents.length && module.contents.length && !$mmApp.isOnline()) {
                mod.contents = module.contents;
            }
            module = mod;
            showModuleData(module);
            $mmCourseHelper.fillContextMenu($scope, module, courseId, refresh, mmaModFolderComponent);
        }).catch(function(error) {
            $mmUtil.showErrorModalDefault(error, 'mma.mod_folder.errorwhilegettingfolder', true);
            return $q.reject();
        });
    }
    if (path) {
        showModuleData(module);
        $scope.folderLoaded = true;
        $scope.canReload = false;
        $scope.refreshIcon = 'ion-refresh';
    } else {
        fetchFolder().then(function() {
            $mmaModFolder.logView(module.instance).then(function() {
                $mmCourse.checkModuleCompletion(courseId, module.completionstatus);
            });
        }).finally(function() {
            $scope.folderLoaded = true;
            $scope.canReload = true;
            $scope.refreshIcon = 'ion-refresh';
        });
    }
    $scope.removeFiles = function() {
        $mmCourseHelper.confirmAndRemove(module, courseId);
    };
    $scope.prefetch = function() {
        $mmCourseHelper.contextMenuPrefetch($scope, module, courseId);
    };
    $scope.expandDescription = function() {
        $mmText.expandText($translate.instant('mm.core.description'), $scope.description, false, mmaModFolderComponent, module.id);
    };
    $scope.refreshFolder = function() {
        if ($scope.canReload) {
            $scope.refreshIcon = 'spinner';
            return $mmCourse.invalidateModule(module.id).finally(function() {
                return fetchFolder(true).finally(function() {
                    $scope.refreshIcon = 'ion-refresh';
                    $scope.$broadcast('scroll.refreshComplete');
                });
            });
        }
    };
}]);

angular.module('mm.addons.mod_folder')
.factory('$mmaModFolder', ["$mmSite", "$mmCourse", "$q", function($mmSite, $mmCourse, $q) {
    var self = {};
        self.formatContents = function(contents) {
        var files = [],
            folders = [],
            foldericon = $mmCourse.getModuleIconSrc('folder');
        angular.forEach(contents, function(entry) {
            if (entry.filepath !== '/') {
                var directories,
                    currentList = folders,
                    path = entry.filepath,
                    subpath = '';
                if (path.substr(0, 1) === '/') {
                    path = path.substr(1);
                }
                if (path.substr(path.length - 1) === '/') {
                    path = path.slice(0, -1);
                }
                directories = path.split('/');
                angular.forEach(directories, function(directory) {
                    subpath = subpath + '/' + directory;
                    var found = false;
                    for (var i = 0; i < currentList.length; i++) {
                        if (currentList[i].name === directory) {
                            currentList = currentList[i].contents;
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        var newFolder = {
                            name: directory,
                            fileicon: foldericon,
                            contents: [],
                            filepath: subpath,
                            type: 'folder'
                        };
                        currentList.push(newFolder);
                        currentList = newFolder.contents;
                    }
                });
                currentList.push(entry);
            } else {
                files.push(entry);
            }
        });
        return folders.concat(files);
    };
        self.logView = function(id) {
        if (id) {
            var params = {
                folderid: id
            };
            return $mmSite.write('mod_folder_view_folder', params);
        }
        return $q.reject();
    };
    return self;
}]);

angular.module('mm.addons.mod_folder')
.factory('$mmaModFolderHandlers', ["$mmCourse", "$mmEvents", "$state", "$mmSite", "$mmCourseHelper", "$mmaModFolder", "$mmCoursePrefetchDelegate", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", "mmCoreEventPackageStatusChanged", "mmaModFolderComponent", "$mmContentLinksHelper", "$mmaModFolderPrefetchHandler", "$mmUtil", function($mmCourse, $mmEvents, $state, $mmSite, $mmCourseHelper, $mmaModFolder,
            $mmCoursePrefetchDelegate, mmCoreDownloading, mmCoreNotDownloaded, mmCoreOutdated, mmCoreEventPackageStatusChanged,
            mmaModFolderComponent, $mmContentLinksHelper, $mmaModFolderPrefetchHandler, $mmUtil) {
    var self = {};
        self.courseContent = function() {
        var self = {};
                self.isEnabled = function() {
            return true;
        };
                self.getController = function(module, courseid, sectionid) {
            return function($scope) {
                var downloadBtn,
                    refreshBtn;
                function prefetchFolder(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    var dwnBtnHidden = downloadBtn.hidden,
                        rfrshBtnHidden = refreshBtn.hidden;
                    $scope.spinner = true;
                    downloadBtn.hidden = true;
                    refreshBtn.hidden = true;
                    $mmaModFolderPrefetchHandler.getDownloadSize(module, courseid).then(function(size) {
                        $mmCourseHelper.prefetchModule($scope, $mmaModFolderPrefetchHandler, module, size, false, courseid)
                                .catch(function() {
                            $scope.spinner = false;
                            downloadBtn.hidden = dwnBtnHidden;
                            refreshBtn.hidden = rfrshBtnHidden;
                        });
                    }).catch(function(error) {
                        $scope.spinner = false;
                        downloadBtn.hidden = dwnBtnHidden;
                        refreshBtn.hidden = rfrshBtnHidden;
                        if (error) {
                            $mmUtil.showErrorModal(error);
                        } else {
                            $mmUtil.showErrorModal('mm.core.errordownloading', true);
                        }
                    });
                }
                downloadBtn = {
                    hidden: true,
                    icon: 'ion-ios-cloud-download-outline',
                    label: 'mm.core.download',
                    action: prefetchFolder
                };
                refreshBtn = {
                    hidden: true,
                    icon: 'ion-android-refresh',
                    label: 'mm.core.refresh',
                    action: prefetchFolder
                };
                $scope.icon = $mmCourse.getModuleIconSrc('folder');
                $scope.title = module.name;
                $scope.class = 'mma-mod_folder-handler';
                $scope.buttons = [downloadBtn, refreshBtn];
                $scope.spinner = true;
                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_folder', {module: module, courseid: courseid, sectionid: sectionid});
                };
                function showStatus(status) {
                    if (status) {
                        $scope.spinner = status === mmCoreDownloading;
                        downloadBtn.hidden = status !== mmCoreNotDownloaded;
                        refreshBtn.hidden = status !== mmCoreOutdated;
                    }
                }
                var statusObserver = $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
                    if (data.siteid === $mmSite.getId() && data.componentId === module.id && data.component === mmaModFolderComponent) {
                        showStatus(data.status);
                    }
                });
                $mmCoursePrefetchDelegate.getModuleStatus(module, courseid).then(showStatus);
                $scope.$on('$destroy', function() {
                    statusObserver && statusObserver.off && statusObserver.off();
                });
            };
        };
        return self;
    };
        self.linksHandler = $mmContentLinksHelper.createModuleIndexLinkHandler('mmaModFolder', 'folder', $mmaModFolder);
    return self;
}]);

angular.module('mm.addons.mod_folder')
.factory('$mmaModFolderPrefetchHandler', ["$mmPrefetchFactory", "mmaModFolderComponent", function($mmPrefetchFactory, mmaModFolderComponent) {
    var self = $mmPrefetchFactory.createPrefetchHandler(mmaModFolderComponent, true);
    return self;
}]);

angular.module('mm.addons.mod_forum')
.controller('mmaModForumDiscussionCtrl', ["$q", "$scope", "$stateParams", "$mmaModForum", "$mmSite", "$mmUtil", "$translate", "$mmEvents", "$ionicScrollDelegate", "mmaModForumComponent", "mmaModForumReplyDiscussionEvent", "$mmaModForumOffline", "$mmaModForumSync", "mmaModForumAutomSyncedEvent", "mmaModForumManualSyncedEvent", "$mmApp", "$ionicPlatform", "mmCoreEventOnlineStatusChanged", "$mmaModForumHelper", "$mmFileUploaderHelper", function($q, $scope, $stateParams, $mmaModForum, $mmSite, $mmUtil, $translate, $mmEvents,
            $ionicScrollDelegate, mmaModForumComponent, mmaModForumReplyDiscussionEvent, $mmaModForumOffline, $mmaModForumSync,
            mmaModForumAutomSyncedEvent, mmaModForumManualSyncedEvent, $mmApp, $ionicPlatform, mmCoreEventOnlineStatusChanged,
            $mmaModForumHelper, $mmFileUploaderHelper) {
    var discussionId = $stateParams.discussionid,
        courseId = $stateParams.cid,
        forumId = $stateParams.forumid,
        cmid = $stateParams.cmid,
        scrollView,
        syncObserver, syncManualObserver, onlineObserver;
    $mmUtil.blockLeaveView($scope, leaveView);
    $scope.sortTypeFlatNewest = 'flat-newest';
    $scope.sortTypeFlatOldest = 'flat-oldest';
    $scope.sortTypeNested = 'nested';
    $scope.discussionId = discussionId;
    $scope.trackPosts = $stateParams.trackposts;
    $scope.component = mmaModForumComponent;
    $scope.discussionStr = $translate.instant('discussion');
    $scope.componentId = cmid;
    $scope.courseId = courseId;
    $scope.refreshPostsIcon = 'spinner';
    $scope.syncIcon = 'spinner';
    $scope.newPost = {
        replyingto: undefined,
        editing: undefined,
        subject: '',
        text: '',
        isEditing: false,
        files: []
    };
    $scope.sort = $scope.sortTypeFlatOldest;
    $scope.locked = !!$stateParams.locked;
    $scope.originalData = {};
    function fetchForum() {
        if (courseId && cmid) {
            return $mmaModForum.getForum(courseId, cmid);
        } else if (courseId && forumId) {
            return $mmaModForum.getForumById(courseId, forumId);
        } else {
            return $q.reject();
        }
    }
    function fetchPosts(sync, showErrors) {
        var syncPromise,
            onlinePosts = [],
            offlineReplies = [];
        $scope.isOnline = $mmApp.isOnline();
        $scope.isTablet = $ionicPlatform.isTablet();
        if (sync) {
            syncPromise = syncDiscussion(showErrors).catch(function() {
            });
        } else {
            syncPromise = $q.when();
        }
        return syncPromise.then(function() {
            return $mmaModForum.getDiscussionPosts(discussionId).then(function(posts) {
                onlinePosts = posts;
            }).then(function() {
                return $mmaModForumOffline.getDiscussionReplies(discussionId).then(function(replies) {
                    $scope.postHasOffline = !!replies.length;
                    var convertPromises = [];
                    var posts = {};
                    angular.forEach(onlinePosts, function(post) {
                        posts[post.id] = post;
                    });
                    angular.forEach(replies, function(offlineReply) {
                        if (!forumId) {
                            forumId = offlineReply.forumid;
                        }
                        if (!courseId) {
                            courseId = offlineReply.courseid;
                            $scope.courseId = courseId;
                        }
                        convertPromises.push($mmaModForumHelper.convertOfflineReplyToOnline(offlineReply).then(function(reply) {
                            offlineReplies.push(reply);
                            posts[reply.parent].canreply = false;
                        }));
                    });
                    return $q.all(convertPromises).then(function() {
                        onlinePosts = Object.keys(posts).map(function (key) {return posts[key];});
                    });
                });
            });
        }).then(function() {
            var posts = offlineReplies.concat(onlinePosts);
            $scope.discussion = $mmaModForum.extractStartingPost(posts);
            if ($scope.sort == $scope.sortTypeNested) {
                posts = $mmaModForum.sortDiscussionPosts(posts, 'ASC');
                $scope.posts = $mmUtil.formatTree(posts, 'parent', 'id', $scope.discussion.id);
            } else {
                var direction = $scope.sort == $scope.sortTypeFlatNewest ? 'DESC' : 'ASC';
                $scope.posts = $mmaModForum.sortDiscussionPosts(posts, direction);
            }
            $scope.defaultSubject = $translate.instant('mma.mod_forum.re') + ' ' + $scope.discussion.subject;
            $scope.newPost.subject = $scope.defaultSubject;
            return fetchForum().then(function(forum) {
                if ($scope.discussion.userfullname && $scope.discussion.parent == 0 && forum.type == 'single') {
                    $scope.discussion.userfullname = null;
                }
                forumId = forum.id;
                cmid = forum.cmid;
                $scope.componentId = cmid;
                $scope.forum = forum;
            }).catch(function() {
            });
        }).catch(function(message) {
            $mmUtil.showErrorModal(message);
            return $q.reject();
        }).finally(function() {
            $scope.discussionLoaded = true;
            $scope.refreshPostsIcon = 'ion-refresh';
            $scope.syncIcon = 'ion-loop';
        });
    }
    $scope.changeSort = function(type) {
        $scope.discussionLoaded = false;
        scrollTop();
        $scope.sort = type;
        return fetchPosts();
    };
    function syncDiscussion(showErrors) {
        return $mmaModForumSync.syncDiscussionReplies(discussionId).then(function(result) {
            if (result.warnings && result.warnings.length) {
                $mmUtil.showErrorModal(result.warnings[0]);
            }
            if (result && result.updated) {
                $mmEvents.trigger(mmaModForumManualSyncedEvent, {
                    siteid: $mmSite.getId(),
                    forumid: forumId,
                    userid: $mmSite.getUserId(),
                    warnings: result.warnings
                });
            }
            return result.updated;
        }).catch(function(error) {
            if (showErrors) {
                if (error) {
                    $mmUtil.showErrorModal(error);
                } else {
                    $mmUtil.showErrorModal('mm.core.errorsync', true);
                }
            }
            return $q.reject();
        });
    }
    function refreshPosts(sync, showErrors) {
        scrollTop();
        $scope.refreshPostsIcon = 'spinner';
        $scope.syncIcon = 'spinner';
        return $mmaModForum.invalidateDiscussionPosts(discussionId).finally(function() {
            return fetchPosts(sync, showErrors);
        });
    }
    function notifyPostListChanged() {
        var data = {
            forumid: forumId,
            discussionid: discussionId,
            cmid: cmid
        };
        $mmEvents.trigger(mmaModForumReplyDiscussionEvent, data);
    }
    fetchPosts(true).then(function() {
        $mmaModForum.logDiscussionView(discussionId);
    });
    $scope.refreshPosts = function(showErrors) {
        if ($scope.discussionLoaded) {
            return refreshPosts(true, showErrors).finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        }
    };
    syncObserver = $mmEvents.on(mmaModForumAutomSyncedEvent, function(data) {
        if (data && data.siteid == $mmSite.getId() && data.forumid == forumId && data.userid == $mmSite.getUserId() &&
                discussionId == data.discussionid) {
            $scope.discussionLoaded = false;
            refreshPosts(false);
        }
    });
    onlineObserver = $mmEvents.on(mmCoreEventOnlineStatusChanged, function(online) {
        $scope.isOnline = online;
    });
    syncManualObserver = $mmEvents.on(mmaModForumManualSyncedEvent, function(data) {
        if (data && data.siteid == $mmSite.getId() && data.forumid == forumId && data.userid == $mmSite.getUserId()) {
            $scope.discussionLoaded = false;
            refreshPosts(false);
        }
    });
    function leaveView() {
        var promise;
        if (!$mmaModForumHelper.hasPostDataChanged($scope.newPost, $scope.originalData)) {
            promise = $q.when();
        } else {
            promise = $mmUtil.showConfirm($translate('mm.core.confirmcanceledit'));
        }
        return promise.then(function() {
            $mmFileUploaderHelper.clearTmpFiles($scope.newPost.files);
        });
    }
    function scrollTop() {
        if (!scrollView) {
            scrollView = $ionicScrollDelegate.$getByHandle('mmaModForumPostsScroll');
        }
        scrollView && scrollView.scrollTop && scrollView.scrollTop();
    }
    $scope.postListChanged = function() {
        notifyPostListChanged();
        $scope.discussionLoaded = false;
        refreshPosts(false).finally(function() {
            $scope.discussionLoaded = true;
        });
    };
    $scope.$on('$destroy', function(){
        syncObserver && syncObserver.off && syncObserver.off();
        syncManualObserver && syncManualObserver.off && syncManualObserver.off();
        onlineObserver && onlineObserver.off && onlineObserver.off();
    });
}]);

angular.module('mm.addons.mod_forum')
.controller('mmaModForumDiscussionsCtrl', ["$q", "$scope", "$stateParams", "$mmaModForum", "$mmCourse", "$mmUtil", "$mmGroups", "$mmUser", "$mmEvents", "$ionicScrollDelegate", "$ionicPlatform", "mmUserProfileState", "mmaModForumNewDiscussionEvent", "$mmSite", "$translate", "mmaModForumReplyDiscussionEvent", "$mmText", "mmaModForumComponent", "$mmaModForumOffline", "$mmaModForumSync", "$mmCourseHelper", "mmaModForumAutomSyncedEvent", "mmaModForumManualSyncedEvent", "$mmApp", "mmCoreEventOnlineStatusChanged", function($q, $scope, $stateParams, $mmaModForum, $mmCourse, $mmUtil, $mmGroups, $mmUser,
            $mmEvents, $ionicScrollDelegate, $ionicPlatform, mmUserProfileState, mmaModForumNewDiscussionEvent, $mmSite, $translate,
            mmaModForumReplyDiscussionEvent, $mmText, mmaModForumComponent, $mmaModForumOffline, $mmaModForumSync, $mmCourseHelper,
            mmaModForumAutomSyncedEvent, mmaModForumManualSyncedEvent, $mmApp, mmCoreEventOnlineStatusChanged) {
    var module = $stateParams.module || {},
        courseid = $stateParams.courseid,
        forum,
        page = 0,
        scrollView,
        shouldScrollTop = false,
        usesGroups = false,
        obsNewDisc, obsReply, syncObserver, syncManualObserver, onlineObserver;
    $scope.title = module.name;
    $scope.description = module.description;
    $scope.moduleUrl = module.url;
    $scope.moduleName = $mmCourse.translateModuleName('forum');
    $scope.courseid = courseid;
    $scope.userStateName = mmUserProfileState;
    $scope.isCreateEnabled = $mmaModForum.isCreateDiscussionEnabled();
    $scope.refreshIcon = 'spinner';
    $scope.syncIcon = 'spinner';
    $scope.component = mmaModForumComponent;
    $scope.componentId = module.id;
    function fetchForumDataAndDiscussions(refresh, sync, showErrors) {
        $scope.isOnline = $mmApp.isOnline();
        return $mmaModForum.getForum(courseid, module.id).then(function(forumdata) {
            forum = forumdata;
            $scope.title = forum.name || $scope.title;
            $scope.description = forum.intro || $scope.description;
            $scope.forum = forum;
            if (!$scope.linkToLoad) {
                $scope.linkToLoad = $scope.isCreateEnabled && forum.cancreatediscussions ? 2 : 1;
            }
            if (sync) {
                return syncForum(showErrors).catch(function() {
                });
            }
        }).then(function() {
            if ($mmGroups.canGetActivityGroupMode()) {
                return $mmGroups.getActivityGroupMode(forum.cmid).then(function(mode) {
                    usesGroups = mode === $mmGroups.SEPARATEGROUPS || mode === $mmGroups.VISIBLEGROUPS;
                });
            }
        }).then(function() {
            var promises = [];
            promises.push($mmaModForumOffline.getNewDiscussions(forum.id).then(function(offlineDiscussions) {
                $scope.hasOffline = !!offlineDiscussions.length;
                if ($scope.hasOffline) {
                    var promise = usesGroups ?
                        $mmaModForum.formatDiscussionsGroups(forum.cmid, offlineDiscussions) : $q.when(offlineDiscussions);
                    return promise.then(function(offlineDiscussions) {
                        var userPromises = [];
                        angular.forEach(offlineDiscussions, function(discussion) {
                            if (discussion.parent != 0 || forum.type != 'single') {
                                userPromises.push($mmUser.getProfile(discussion.userid, courseid, true).then(function(user) {
                                    discussion.userfullname = user.fullname;
                                    discussion.userpictureurl = user.profileimageurl;
                                }));
                            }
                        });
                        return $q.all(userPromises).then(function() {
                            $scope.offlineDiscussions = offlineDiscussions;
                        });
                    });
                } else {
                    $scope.offlineDiscussions = [];
                }
            }));
            promises.push(fetchDiscussions(refresh));
            return $q.all(promises);
        }).then(function() {
            $mmCourseHelper.fillContextMenu($scope, module, courseid, refresh, mmaModForumComponent);
        }).catch(function(message) {
            if (!refresh) {
                return refreshData(sync);
            }
            if (message) {
                $mmUtil.showErrorModal(message);
            } else {
                $mmUtil.showErrorModal('mma.mod_forum.errorgetforum', true);
            }
            $scope.canLoadMore = false;
            return $q.reject();
        });
    }
    function fetchDiscussions(refresh) {
        if (refresh) {
            page = 0;
        }
        return $mmaModForum.getDiscussions(forum.id, page).then(function(response) {
            var promise = usesGroups ?
                    $mmaModForum.formatDiscussionsGroups(forum.cmid, response.discussions) : $q.when(response.discussions);
            return promise.then(function(discussions) {
                if (forum.type == 'single') {
                    for (var x in discussions) {
                        if (discussions[x].userfullname && discussions[x].parent == 0) {
                            discussions[x].userfullname = false;
                            break;
                        }
                    }
                }
                if (page == 0) {
                    $scope.discussions = discussions;
                } else {
                    $scope.discussions = $scope.discussions.concat(discussions);
                }
                $scope.count = $scope.discussions.length;
                $scope.canLoadMore = response.canLoadMore;
                page++;
                return $mmaModForumOffline.hasForumReplies(forum.id).then(function(hasOffline) {
                    var offlinePromises = [];
                    $scope.hasOffline = $scope.hasOffline || hasOffline;
                    if (hasOffline) {
                        angular.forEach(discussions, function(discussion) {
                            offlinePromises.push($mmaModForumOffline.getDiscussionReplies(discussion.discussion).then(function(replies) {
                                discussion.numreplies = parseInt(discussion.numreplies, 10) + parseInt(replies.length, 10);
                            }));
                        });
                    }
                    return $q.all(offlinePromises);
                });
            });
        }, function(message) {
            $mmUtil.showErrorModal(message);
            $scope.canLoadMore = false;
            return $q.reject();
        });
    }
    function syncForum(showErrors) {
        var promises = [],
            warnings = [];
        promises.push($mmaModForumSync.syncForumDiscussions(forum.id).then(function(result) {
            if (result.warnings && result.warnings.length) {
                warnings = warnings.concat(result.warnings);
                $mmUtil.showErrorModal(result.warnings[0]);
            }
            return result.updated;
        }));
        promises.push($mmaModForumSync.syncForumReplies(forum.id).then(function(result) {
            if (result.warnings && result.warnings.length) {
                warnings = warnings.concat(result.warnings);
                $mmUtil.showErrorModal(result.warnings[0]);
            }
            return result.updated;
        }));
        return $q.all(promises).then(function(results) {
            var updated = results.reduce(function(a, b) {
                return a || b;
            }, false);
            if (updated) {
                $mmEvents.trigger(mmaModForumManualSyncedEvent, {
                    siteid: $mmSite.getId(),
                    forumid: forum.id,
                    userid: $mmSite.getUserId(),
                    warnings: warnings
                });
            }
            return updated;
        }).catch(function(error) {
            if (showErrors) {
                if (error) {
                    $mmUtil.showErrorModal(error);
                } else {
                    $mmUtil.showErrorModal('mm.core.errorsync', true);
                }
            }
            return $q.reject();
        });
    }
    function scrollTop() {
        if (!scrollView) {
            scrollView = $ionicScrollDelegate.$getByHandle('mmaModForumDiscussionsScroll');
        }
        scrollView && scrollView.scrollTop && scrollView.scrollTop();
    }
    function refreshData(sync, showErrors) {
        var promises = [];
        promises.push($mmaModForum.invalidateForumData(courseid));
        if (forum) {
            promises.push($mmaModForum.invalidateDiscussionsList(forum.id));
            promises.push($mmGroups.invalidateActivityGroupMode(forum.cmid));
        }
        return $q.all(promises).finally(function() {
            return fetchForumDataAndDiscussions(true, sync, showErrors);
        });
    }
    function eventReceived(data) {
        if ((forum && forum.id === data.forumid) || data.cmid === module.id) {
            if ($ionicPlatform.isTablet()) {
                scrollTop();
            } else {
                shouldScrollTop = true;
            }
            $scope.discussionsLoaded = false;
            showSpinnerAndFetch(false);
            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
        }
    }
    fetchForumDataAndDiscussions(false, true).then(function() {
        $mmaModForum.logView(forum.id).then(function() {
            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
        });
    }).finally(function() {
        $scope.refreshIcon = 'ion-refresh';
        $scope.syncIcon = 'ion-loop';
        $scope.discussionsLoaded = true;
    });
    $scope.loadMoreDiscussions = function() {
        fetchDiscussions().finally(function() {
            $scope.$broadcast('scroll.infiniteScrollComplete');
        });
    };
    $scope.refreshDiscussions = function(showErrors) {
        if ($scope.discussionsLoaded) {
            return showSpinnerAndFetch(true, showErrors);
        }
    };
    function showSpinnerAndFetch(sync, showErrors) {
        $scope.refreshIcon = 'spinner';
        $scope.syncIcon = 'spinner';
        return refreshData(sync, showErrors).finally(function() {
            $scope.discussionsLoaded = true;
            $scope.refreshIcon = 'ion-refresh';
            $scope.syncIcon = 'ion-loop';
            $scope.$broadcast('scroll.refreshComplete');
        });
    }
    $scope.removeFiles = function() {
        $mmCourseHelper.confirmAndRemove(module, courseid);
    };
    $scope.prefetch = function() {
        $mmCourseHelper.contextMenuPrefetch($scope, module, courseid);
    };
    $scope.expandDescription = function() {
        $mmText.expandText($translate.instant('mm.core.description'), $scope.description, false, mmaModForumComponent, module.id);
    };
    onlineObserver = $mmEvents.on(mmCoreEventOnlineStatusChanged, function(online) {
        $scope.isOnline = online;
    });
    syncObserver = $mmEvents.on(mmaModForumAutomSyncedEvent, function(data) {
        if (forum && data && data.siteid == $mmSite.getId() && data.forumid == forum.id && data.userid == $mmSite.getUserId()) {
            $scope.discussionsLoaded = false;
            return showSpinnerAndFetch(false);
        }
    });
    syncManualObserver = $mmEvents.on(mmaModForumManualSyncedEvent, function(data) {
        if (forum && data && data.siteid == $mmSite.getId() && data.forumid == forum.id && data.userid == $mmSite.getUserId()) {
            $scope.discussionsLoaded = false;
            return showSpinnerAndFetch(false);
        }
    });
    obsNewDisc = $mmEvents.on(mmaModForumNewDiscussionEvent, eventReceived);
    obsReply = $mmEvents.on(mmaModForumReplyDiscussionEvent, eventReceived);
    $scope.$on('$ionicView.enter', function() {
        if (shouldScrollTop) {
            shouldScrollTop = false;
            scrollTop();
        }
    });
    $scope.$on('$destroy', function(){
        obsNewDisc && obsNewDisc.off && obsNewDisc.off();
        obsReply && obsReply.off && obsReply.off();
        syncObserver && syncObserver.off && syncObserver.off();
        syncManualObserver && syncManualObserver.off && syncManualObserver.off();
        onlineObserver && onlineObserver.off && onlineObserver.off();
    });
}]);

angular.module('mm.addons.mod_forum')
.controller('mmaModForumNewDiscussionCtrl', ["$scope", "$stateParams", "$mmGroups", "$q", "$mmaModForum", "$mmEvents", "$ionicPlatform", "$mmUtil", "$ionicHistory", "$translate", "mmaModForumNewDiscussionEvent", "$mmaModForumOffline", "$mmSite", "mmaModForumComponent", "mmaModForumAutomSyncedEvent", "$mmSyncBlock", "$mmaModForumSync", "$mmText", "$mmaModForumHelper", "$mmFileUploaderHelper", function($scope, $stateParams, $mmGroups, $q, $mmaModForum, $mmEvents, $ionicPlatform,
            $mmUtil, $ionicHistory, $translate, mmaModForumNewDiscussionEvent, $mmaModForumOffline, $mmSite, mmaModForumComponent,
            mmaModForumAutomSyncedEvent, $mmSyncBlock, $mmaModForumSync, $mmText, $mmaModForumHelper, $mmFileUploaderHelper) {
    var courseId = $stateParams.cid,
        forumId = $stateParams.forumid,
        cmId = $stateParams.cmid,
        timecreated = $stateParams.timecreated,
        syncObserver,
        syncId,
        originalData;
    $mmUtil.blockLeaveView($scope, leaveView);
    $scope.newDiscussion = {
        subject: '',
        text: '',
        subscribe: true,
        files: []
    };
    $scope.hasOffline = false;
    $scope.component = mmaModForumComponent;
    $scope.canAddAttachments = $mmaModForum.canAddAttachments();
    function fetchDiscussionData(refresh) {
        return $mmGroups.getActivityGroupMode(cmId).then(function(mode) {
            var promises = [];
            if (mode === $mmGroups.SEPARATEGROUPS || mode === $mmGroups.VISIBLEGROUPS) {
                promises.push($mmGroups.getActivityAllowedGroups(cmId).then(function(forumgroups) {
                    var promise;
                    if (mode === $mmGroups.VISIBLEGROUPS) {
                        promise = validateVisibleGroups(forumgroups, refresh);
                    } else {
                        promise = addAllParticipantsOption(forumgroups, true);
                    }
                    return promise.then(function(forumgroups) {
                        if (forumgroups.length > 0) {
                            $scope.groups = forumgroups;
                            $scope.newDiscussion.groupid = $scope.newDiscussion.groupid ?
                                $scope.newDiscussion.groupid : forumgroups[0].id;
                            $scope.showGroups = true;
                        } else {
                            var message = mode === $mmGroups.SEPARATEGROUPS ?
                                                'mma.mod_forum.cannotadddiscussionall' : 'mma.mod_forum.cannotadddiscussion';
                            return $q.reject($translate.instant(message));
                        }
                    });
                }));
            } else {
                $scope.showGroups = false;
            }
            promises.push($mmaModForum.getForum(courseId, cmId).then(function(forum) {
                $scope.forum = forum;
            }));
            if (timecreated && !refresh) {
                syncId = $mmaModForumSync.getForumSyncId(forumId);
                promises.push($mmaModForumSync.waitForSync(syncId).then(function() {
                    if (!$scope.$$destroyed) {
                        $mmSyncBlock.blockOperation(mmaModForumComponent, syncId);
                    }
                    return $mmaModForumOffline.getNewDiscussion(forumId, timecreated).then(function(discussion) {
                        $scope.hasOffline = true;
                        $scope.newDiscussion.groupid = discussion.groupid ? discussion.groupid : $scope.newDiscussion.groupid;
                        $scope.newDiscussion.subject = discussion.subject;
                        $scope.newDiscussion.text = discussion.message;
                        $scope.newDiscussion.subscribe = discussion.subscribe;
                        if (discussion.attachments && discussion.attachments.offline) {
                            return $mmaModForumHelper.getNewDiscussionStoredFiles(forumId, timecreated).then(function(files) {
                                $scope.newDiscussion.files = files;
                            });
                        }
                    });
                }));
            }
            return $q.all(promises);
        }).then(function() {
            if (!originalData) {
                originalData = angular.copy($scope.newDiscussion);
            }
            $scope.showForm = true;
        }).catch(function(message) {
            $mmUtil.showErrorModalDefault(message, 'mma.mod_forum.errorgetgroups', true);
            $scope.showForm = false;
            return $q.reject();
        });
    }
    function validateVisibleGroups(forumgroups, refresh) {
        if ($mmaModForum.isCanAddDiscussionAvailable()) {
            return $mmaModForum.canAddDiscussionToAll(forumId).catch(function() {
                return false;
            }).then(function(canAdd) {
                if (canAdd) {
                    return addAllParticipantsOption(forumgroups);
                } else {
                    var promises = [],
                        filtered = [];
                    angular.forEach(forumgroups, function(group) {
                        promises.push($mmaModForum.canAddDiscussion(forumId, group.id).catch(function() {
                            return true;
                        }).then(function(canAdd) {
                            if (canAdd) {
                                filtered.push(group);
                            }
                        }));
                    });
                    return $q.all(promises).then(function() {
                        return filtered;
                    });
                }
            });
        } else {
            return $mmGroups.getUserGroupsInCourse(courseId, refresh).then(function(usergroups) {
                if (usergroups.length === 0) {
                    return forumgroups;
                }
                return filterGroups(forumgroups, usergroups);
            });
        }
    }
    function filterGroups(forumgroups, usergroups) {
        var filtered = [],
            usergroupsids = usergroups.map(function(g) {
                return g.id;
            });
        angular.forEach(forumgroups, function(fg) {
            if (usergroupsids.indexOf(fg.id) > -1) {
                filtered.push(fg);
            }
        });
        return filtered;
    }
    function addAllParticipantsOption(groups, check) {
        var promise;
        if (!$mmaModForum.isAllParticipantsFixed()) {
            return $q.when(groups);
        } else if (check) {
            promise = $mmaModForum.canAddDiscussionToAll(forumId).catch(function() {
                return false;
            });
        } else {
            promise = $q.when(true);
        }
        return promise.then(function(canAdd) {
            if (canAdd) {
                groups.unshift({
                    courseid: courseId,
                    id: -1,
                    name: $translate.instant('mm.core.allparticipants')
                });
            }
            return groups;
        });
    }
    fetchDiscussionData().finally(function() {
        $scope.groupsLoaded = true;
    });
    $scope.refreshGroups = function() {
        var p1 = $mmGroups.invalidateActivityGroupMode(cmId),
            p2 = $mmGroups.invalidateActivityAllowedGroups(cmId),
            p3 = $mmaModForum.invalidateCanAddDiscussion(forumId);
        $q.all([p1, p2, p3]).finally(function() {
            fetchDiscussionData(true).finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };
    function returnToDiscussions(discussionId) {
        var data = {
            forumid: forumId,
            cmid: cmId
        };
        if (discussionId) {
            data.discussionid = discussionId;
        }
        $mmEvents.trigger(mmaModForumNewDiscussionEvent, data);
        $mmFileUploaderHelper.clearTmpFiles($scope.newDiscussion.files);
        if ($ionicPlatform.isTablet()) {
            $scope.hasOffline = false;
            $scope.newDiscussion.subject = '';
            $scope.newDiscussion.text = '';
            $scope.newDiscussion.files = [];
            originalData = angular.copy($scope.newDiscussion);
        } else {
            $ionicHistory.goBack();
        }
    }
    function leaveView() {
        var promise;
        if (!$mmaModForumHelper.hasPostDataChanged($scope.newDiscussion, originalData)) {
            promise = $q.when();
        } else {
            promise = $mmUtil.showConfirm($translate('mm.core.confirmcanceledit'));
        }
        return promise.then(function() {
            $mmFileUploaderHelper.clearTmpFiles($scope.newDiscussion.files);
        });
    }
    $scope.add = function() {
        var modal,
            forumName = $scope.forum.name,
            subject = $scope.newDiscussion.subject,
            message = $scope.newDiscussion.text,
            subscribe = $scope.newDiscussion.subscribe,
            groupId = $scope.newDiscussion.groupid,
            attachments = $scope.newDiscussion.files,
            discTimecreated = timecreated || Date.now(),
            saveOffline = false;
        if (!subject) {
            $mmUtil.showErrorModal('mma.mod_forum.erroremptysubject', true);
            return;
        }
        if (!message) {
            $mmUtil.showErrorModal('mma.mod_forum.erroremptymessage', true);
            return;
        }
        modal = $mmUtil.showModalLoading('mm.core.sending', true);
        $mmUtil.isRichTextEditorEnabled().then(function(enabled) {
            if (!enabled) {
                message = $mmText.formatHtmlLines(message);
            }
            if (attachments.length) {
                return $mmaModForumHelper.uploadOrStoreNewDiscussionFiles(forumId, discTimecreated, attachments, false)
                        .catch(function() {
                    saveOffline = true;
                    return $mmaModForumHelper.uploadOrStoreNewDiscussionFiles(forumId, discTimecreated, attachments, true);
                });
            }
        }).then(function(attach) {
            if (saveOffline) {
                return $mmaModForumOffline.addNewDiscussion(forumId, forumName, courseId, subject,
                        message, subscribe, groupId, attach, discTimecreated).then(function() {
                });
            } else {
                return $mmaModForum.addNewDiscussion(forumId, forumName, courseId, subject, message, subscribe,
                        groupId, attach, undefined, discTimecreated, !attachments.length);
            }
        }).then(function(discussionId) {
            if (discussionId) {
                $mmaModForumHelper.deleteNewDiscussionStoredFiles(forumId, discTimecreated);
            }
            returnToDiscussions(discussionId);
        }).catch(function(message) {
            $mmUtil.showErrorModalDefault(message, 'mma.mod_forum.cannotcreatediscussion', true);
        }).finally(function() {
            modal.dismiss();
        });
    };
    if (timecreated) {
        syncObserver = $mmEvents.on(mmaModForumAutomSyncedEvent, function(data) {
            if (data && data.siteid == $mmSite.getId() && data.forumid == forumId && data.userid == $mmSite.getUserId()) {
                $mmUtil.showModal('mm.core.notice', 'mm.core.contenteditingsynced');
                returnToDiscussions();
            }
        });
    }
    $scope.discard = function() {
        return $mmUtil.showConfirm($translate('mm.core.areyousure')).then(function() {
            var promises = [];
            promises.push($mmaModForumOffline.deleteNewDiscussion(forumId, timecreated));
            promises.push($mmaModForumHelper.deleteNewDiscussionStoredFiles(forumId, timecreated).catch(function() {
            }));
            return $q.all(promises).then(function() {
                returnToDiscussions();
            });
        });
    };
    $scope.firstRender = function() {
        if (originalData) {
            originalData.text = $scope.newDiscussion.text;
        }
    };
    $scope.$on('$destroy', function(){
        syncObserver && syncObserver.off && syncObserver.off();
        if (syncId) {
            $mmSyncBlock.unblockOperation(mmaModForumComponent, syncId);
        }
    });
}]);

angular.module('mm.addons.mod_forum')
.directive('mmaModForumDiscussionPost', ["$mmaModForum", "$mmUtil", "$translate", "$q", "$mmaModForumOffline", "$mmSyncBlock", "mmaModForumComponent", "$mmaModForumSync", "$mmText", "$mmaModForumHelper", "$ionicScrollDelegate", "$mmFileUploaderHelper", function($mmaModForum, $mmUtil, $translate, $q, $mmaModForumOffline, $mmSyncBlock,
        mmaModForumComponent, $mmaModForumSync, $mmText, $mmaModForumHelper, $ionicScrollDelegate, $mmFileUploaderHelper) {
    function confirmDiscard(scope) {
        if (!$mmaModForumHelper.hasPostDataChanged(scope.newpost, scope.originalData)) {
            return $q.when();
        } else {
            return $mmUtil.showConfirm($translate('mm.core.confirmloss'));
        }
    }
    function setPostData(scope, scrollView, replyingTo, editing, isEditing, subject, text, files) {
        $mmFileUploaderHelper.clearTmpFiles(scope.newpost.files);
        scope.newpost.replyingto = replyingTo;
        scope.newpost.editing = editing;
        scope.newpost.isEditing = !!isEditing;
        scope.newpost.subject = subject || scope.defaultsubject || '';
        scope.newpost.text = text || '';
        scope.newpost.files = files || [];
        $mmUtil.copyProperties(scope.newpost, scope.originalData);
        scrollView && scrollView.resize();
    }
    return {
        restrict: 'E',
        scope: {
            post: '=',
            courseid: '=',
            discussionId: '=',
            title: '=',
            subject: '=',
            component: '=',
            componentId: '=',
            newpost: '=',
            showdivider: '=?',
            titleimportant: '=?',
            unread: '=?',
            forum: '=?',
            onpostchange: '&?',
            defaultsubject: '=?',
            scrollHandle: '@?',
            originalData: '=?'
        },
        templateUrl: 'addons/mod/forum/templates/discussionpost.html',
        transclude: true,
        link: function(scope) {
            var syncId,
                scrollView = $ionicScrollDelegate.$getByHandle(scope.scrollHandle);
            scope.isReplyEnabled = $mmaModForum.isReplyPostEnabled();
            scope.canAddAttachments = $mmaModForum.canAddAttachments();
            scope.uniqueid = scope.post.id ? 'reply' + scope.post.id : 'edit' + scope.post.parent;
            scope.showReply = function() {
                var uniqueId = 'reply' + scope.post.id,
                    wasReplying = typeof scope.newpost.replyingto != 'undefined';
                if (scope.newpost.isEditing) {
                    confirmDiscard(scope).then(function() {
                        setPostData(scope, scrollView, scope.post.id, uniqueId, false);
                    });
                } else if (!wasReplying) {
                    setPostData(scope, scrollView, scope.post.id, uniqueId, false);
                } else {
                    scope.newpost.replyingto = scope.post.id;
                    scope.newpost.editing = 'reply' + scope.post.id;
                }
            };
            scope.editReply = function() {
                confirmDiscard(scope).then(function() {
                    var uniqueId = 'edit' + scope.post.parent;
                    syncId = $mmaModForumSync.getDiscussionSyncId(scope.discussionId);
                    $mmSyncBlock.blockOperation(mmaModForumComponent, syncId);
                    setPostData(scope, scrollView, scope.post.parent, uniqueId, true, scope.post.subject,
                            scope.post.message, scope.post.attachments);
                });
            };
            scope.reply = function() {
                if (!scope.newpost.subject) {
                    $mmUtil.showErrorModal('mma.mod_forum.erroremptysubject', true);
                    return;
                }
                if (!scope.newpost.text) {
                    $mmUtil.showErrorModal('mma.mod_forum.erroremptymessage', true);
                    return;
                }
                var forum = scope.forum || {},
                    subject = scope.newpost.subject,
                    message = scope.newpost.text,
                    replyingTo = scope.newpost.replyingto,
                    files = scope.newpost.files || [],
                    modal = $mmUtil.showModalLoading('mm.core.sending', true),
                    saveOffline = false;
                $mmUtil.isRichTextEditorEnabled().then(function(enabled) {
                    if (!enabled) {
                        message = $mmText.formatHtmlLines(message);
                    }
                    if (files.length) {
                        return $mmaModForumHelper.uploadOrStoreReplyFiles(forum.id, replyingTo, files, false).catch(function(err) {
                            if (!forum.id) {
                                return $q.reject(err);
                            }
                            saveOffline = true;
                            return $mmaModForumHelper.uploadOrStoreReplyFiles(forum.id, replyingTo, files, true);
                        });
                    }
                }).then(function(attach) {
                    if (saveOffline) {
                        return $mmaModForumOffline.replyPost(replyingTo, scope.discussionId, forum.id, forum.name,
                                scope.courseid, subject, message, attach).then(function() {
                            return false;
                        });
                    } else {
                        return $mmaModForum.replyPost(replyingTo, scope.discussionId, forum.id, forum.name,
                                scope.courseid, subject, message, attach, undefined, !files.length);
                    }
                }).then(function(sent) {
                    if (sent && forum.id) {
                        $mmaModForumHelper.deleteReplyStoredFiles(forum.id, replyingTo);
                    }
                    setPostData(scope, scrollView);
                    if (scope.onpostchange) {
                        scope.onpostchange();
                    }
                    if (syncId) {
                        $mmSyncBlock.unblockOperation(mmaModForumComponent, syncId);
                    }
                }).catch(function(message) {
                    $mmUtil.showErrorModalDefault(message, 'mma.mod_forum.couldnotadd', true);
                }).finally(function() {
                    modal.dismiss();
                });
            };
            scope.cancel = function() {
                confirmDiscard(scope).then(function() {
                    setPostData(scope, scrollView);
                    if (syncId) {
                        $mmSyncBlock.unblockOperation(mmaModForumComponent, syncId);
                    }
                });
            };
            scope.discard = function() {
                $mmUtil.showConfirm($translate('mm.core.areyousure')).then(function() {
                    var promises = [],
                        forum = scope.forum || {};
                    promises.push($mmaModForumOffline.deleteReply(scope.post.parent));
                    if (forum.id) {
                        promises.push($mmaModForumHelper.deleteReplyStoredFiles(forum.id, scope.post.parent).catch(function() {
                        }));
                    }
                    return $q.all(promises).finally(function() {
                        setPostData(scope, scrollView);
                        if (scope.onpostchange) {
                            scope.onpostchange();
                        }
                        if (syncId) {
                            $mmSyncBlock.unblockOperation(mmaModForumComponent, syncId);
                        }
                    });
                });
            };
            scope.firstRender = function() {
                if (scope.newpost.isEditing) {
                    $mmUtil.copyProperties(scope.newpost, scope.originalData);
                }
            };
            scope.$on('$destroy', function(){
                if (syncId) {
                    $mmSyncBlock.unblockOperation(mmaModForumComponent, syncId);
                }
            });
        }
    };
}]);

angular.module('mm.addons.mod_forum')
.factory('$mmaModForum', ["$q", "$mmSite", "$mmUser", "$mmGroups", "$translate", "$mmSitesManager", "mmaModForumDiscPerPage", "mmaModForumComponent", "$mmaModForumOffline", "$mmApp", "$mmUtil", "$mmLang", function($q, $mmSite, $mmUser, $mmGroups, $translate, $mmSitesManager, mmaModForumDiscPerPage,
            mmaModForumComponent, $mmaModForumOffline, $mmApp, $mmUtil, $mmLang) {
    var self = {};
        function getCanAddDiscussionCacheKey(forumid, groupid) {
        return getCommonCanAddDiscussionCacheKey(forumid) + ':' + groupid;
    }
        function getCommonCanAddDiscussionCacheKey(forumid) {
        return 'mmaModForum:canadddiscussion:' + forumid;
    }
        function getForumDataCacheKey(courseid) {
        return 'mmaModForum:forum:' + courseid;
    }
        function getDiscussionPostsCacheKey(discussionid) {
        return 'mmaModForum:discussion:' + discussionid;
    }
        function getDiscussionsListCacheKey(forumid) {
        return 'mmaModForum:discussions:' + forumid;
    }
        self.addNewDiscussion = function(forumId, name, courseId, subject, message, subscribe, groupId, attach, siteId,
                timecreated, allowOffline) {
        siteId = siteId || $mmSite.getId();
        var discardPromise = timecreated ? $mmaModForumOffline.deleteNewDiscussion(forumId, timecreated, siteId) : $q.when();
        return discardPromise.then(function() {
            if (!$mmApp.isOnline() && allowOffline) {
                return storeOffline();
            }
            return self.addNewDiscussionOnline(forumId, subject, message, subscribe, groupId, attach, siteId).then(function(id) {
                return id;
            }).catch(function(error) {
                if (allowOffline && error && !error.wserror) {
                    return storeOffline();
                } else {
                    return $q.reject(error.error);
                }
            });
        });
        function storeOffline() {
            return $mmaModForumOffline.addNewDiscussion(forumId, name, courseId, subject, message, subscribe,
                    groupId, attach, timecreated, siteId).then(function() {
                return false;
            });
        }
    };
        self.addNewDiscussionOnline = function(forumId, subject, message, subscribe, groupId, attachId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                forumid: forumId,
                subject: subject,
                message: message,
                options: [
                    {
                        name: 'discussionsubscribe',
                        value: !!subscribe
                    }
                ]
            };
            if (groupId) {
                params.groupid = groupId;
            }
            if (attachId) {
                params.options.push({
                    name: 'attachmentsid',
                    value: attachId
                });
            }
            return site.write('mod_forum_add_discussion', params).catch(function(error) {
                return $q.reject({
                    error: error,
                    wserror: $mmUtil.isWebServiceError(error)
                });
            }).then(function(response) {
                if (!response || !response.discussionid) {
                    return $q.reject({
                        wserror: true
                    });
                } else {
                    return response.discussionid;
                }
            });
        });
    };
        self.canAddAttachments = function(siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.isVersionGreaterEqualThan('3.1');
        });
    };
        self.canAddDiscussion = function(forumid, groupid) {
        var params = {
                forumid: forumid,
                groupid: groupid
            },
            preSets = {
                cacheKey: getCanAddDiscussionCacheKey(forumid, groupid)
            };
        return $mmSite.read('mod_forum_can_add_discussion', params, preSets).then(function(result) {
            if (result) {
                return !!result.status;
            }
            return $q.reject();
        });
    };
        self.canAddDiscussionToAll = function(forumid) {
        return self.canAddDiscussion(forumid, -1);
    };
        self.extractStartingPost = function(posts) {
        for (var i = posts.length - 1; i >= 0; i--) {
            if (posts[i].parent == 0) {
                return posts.splice(i, 1).pop();
            }
        }
        return undefined;
    };
        self.isAllParticipantsFixed = function() {
        return $mmSite.isVersionGreaterEqualThan(['3.1.5', '3.2.2']);
    };
        self.isCanAddDiscussionAvailable = function() {
        return $mmSite.wsAvailable('mod_forum_can_add_discussion');
    };
        self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return  site.wsAvailable('mod_forum_get_forums_by_courses') &&
                    site.wsAvailable('mod_forum_get_forum_discussions_paginated') &&
                    site.wsAvailable('mod_forum_get_forum_discussion_posts');
        });
    };
        self.formatDiscussionsGroups = function(cmid, discussions) {
        discussions = angular.copy(discussions);
        var strAllParts = $translate.instant('mm.core.allparticipants');
        return $mmGroups.getActivityAllowedGroups(cmid).then(function(forumgroups) {
            var groups = {};
            angular.forEach(forumgroups, function(fg) {
                groups[fg.id] = fg;
            });
            angular.forEach(discussions, function(disc) {
                if (disc.groupid === -1) {
                    disc.groupname = strAllParts;
                } else {
                    var group = groups[disc.groupid];
                    if (group) {
                        disc.groupname = group.name;
                    }
                }
            });
            return discussions;
        }).catch(function() {
            return discussions;
        });
    };
        self.getCourseForums = function(courseId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    courseids: [courseId]
                },
                preSets = {
                    cacheKey: getForumDataCacheKey(courseId)
                };
            return site.read('mod_forum_get_forums_by_courses', params, preSets);
        });
    };
        self.getForum = function(courseId, cmId, siteId) {
        return self.getCourseForums(courseId, siteId).then(function(forums) {
            for (var x in forums) {
                if (forums[x].cmid == cmId) {
                    return forums[x];
                }
            }
            return $q.reject();
        });
    };
        self.getForumById = function(courseId, forumId, siteId) {
        return self.getCourseForums(courseId, siteId).then(function(forums) {
            for (var x in forums) {
                if (forums[x].id == forumId) {
                    return forums[x];
                }
            }
            return $q.reject();
        });
    };
        self.getDiscussionPosts = function(discussionid) {
        var params = {
                discussionid: discussionid
            },
            preSets = {
                cacheKey: getDiscussionPostsCacheKey(discussionid)
            };
        return $mmSite.read('mod_forum_get_forum_discussion_posts', params, preSets).then(function(response) {
            if (response) {
                storeUserData(response.posts);
                return response.posts;
            } else {
                return $q.reject();
            }
        });
    };
        self.sortDiscussionPosts = function(posts, direction) {
        return posts.sort(function (a, b) {
            a = parseInt(a.created, 10);
            b = parseInt(b.created, 10);
            if (direction == 'ASC') {
                return a >= b ? 1 : -1;
            } else {
                return a <= b ? 1 : -1;
            }
        });
    };
        self.getDiscussions = function(forumId, page, forceCache, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            page = page || 0;
            var params = {
                    forumid: forumId,
                    sortby:  'timemodified',
                    sortdirection:  'DESC',
                    page: page,
                    perpage: mmaModForumDiscPerPage
                },
                preSets = {
                    cacheKey: getDiscussionsListCacheKey(forumId)
                };
            if (forceCache) {
                preSets.omitExpires = true;
            }
            return site.read('mod_forum_get_forum_discussions_paginated', params, preSets).then(function(response) {
                if (response) {
                    var canLoadMore = response.discussions.length >= mmaModForumDiscPerPage;
                    storeUserData(response.discussions);
                    return {discussions: response.discussions, canLoadMore: canLoadMore};
                } else {
                    return $q.reject();
                }
            });
        });
    };
        self.getDiscussionsInPages = function(forumId, forceCache, numPages, startPage, siteId) {
        if (typeof numPages == 'undefined') {
            numPages = -1;
        }
        startPage = startPage || 0;
        numPages = parseInt(numPages, 10);
        var result = {
            discussions: [],
            error: false
        };
        if (!numPages) {
            return result;
        }
        return getPage(startPage);
        function getPage(page) {
            return self.getDiscussions(forumId, page, forceCache, siteId).then(function(response) {
                result.discussions = result.discussions.concat(response.discussions);
                numPages--;
                if (response.canLoadMore && numPages !== 0) {
                    return getPage(page + 1);
                } else {
                    return result;
                }
            }).catch(function() {
                result.error = true;
                return result;
            });
        }
    };
        self.invalidateCanAddDiscussion = function(forumId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKeyStartingWith(getCommonCanAddDiscussionCacheKey(forumId));
        });
    };
        self.invalidateContent = function(moduleId, courseId) {
        return self.getForum(courseId, moduleId).then(function(forum) {
            return self.getDiscussionsInPages(forum.id, true).then(function(response) {
                var promises = [];
                promises.push(self.invalidateForumData(courseId));
                promises.push(self.invalidateDiscussionsList(forum.id));
                promises.push(self.invalidateCanAddDiscussion(forum.id));
                angular.forEach(response.discussions, function(discussion) {
                    promises.push(self.invalidateDiscussionPosts(discussion.discussion));
                });
                return $q.all(promises);
            });
        });
    };
        self.invalidateDiscussionPosts = function(discussionId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getDiscussionPostsCacheKey(discussionId));
        });
    };
        self.invalidateDiscussionsList = function(forumId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getDiscussionsListCacheKey(forumId));
        });
    };
        self.invalidateFiles = function(moduleId) {
        return $mmFilepool.invalidateFilesByComponent($mmSite.getId(), mmaModForumComponent, moduleId);
    };
        self.invalidateForumData = function(courseid) {
        return $mmSite.invalidateWsCacheForKey(getForumDataCacheKey(courseid));
    };
        self.isCreateDiscussionEnabled = function() {
        return $mmSite.wsAvailable('core_group_get_activity_groupmode') &&
                $mmSite.wsAvailable('core_group_get_activity_allowed_groups') &&
                $mmSite.wsAvailable('mod_forum_add_discussion');
    };
        self.isReplyPostEnabled = function() {
        return $mmSite.wsAvailable('mod_forum_add_discussion_post');
    };
        self.logView = function(id) {
        if (id) {
            var params = {
                forumid: id
            };
            return $mmSite.write('mod_forum_view_forum', params);
        }
        return $q.reject();
    };
        self.logDiscussionView = function(id) {
        if (id) {
            var params = {
                discussionid: id
            };
            return $mmSite.write('mod_forum_view_forum_discussion', params);
        }
        return $q.reject();
    };
        self.replyPost = function(postId, discussionId, forumId, name, courseId, subject, message, attach, siteId, allowOffline) {
        siteId = siteId || $mmSite.getId();
        if (!$mmApp.isOnline() && allowOffline) {
            return storeOffline();
        }
        return $mmaModForumOffline.deleteReply(postId, siteId).then(function() {
            return self.replyPostOnline(postId, subject, message, attach, siteId).then(function() {
                return true;
            }).catch(function(error) {
                if (allowOffline && error && !error.wserror) {
                    return storeOffline();
                } else {
                    return $q.reject(error.error);
                }
            });
        });
        function storeOffline() {
            if (!forumId) {
                return $mmLang.translateAndReject('mm.core.networkerrormsg');
            }
            return $mmaModForumOffline.replyPost(postId, discussionId, forumId, name, courseId, subject, message, attach, siteId)
                    .then(function() {
                return false;
            });
        }
    };
        self.replyPostOnline = function(postId, subject, message, attachId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                postid: postId,
                subject: subject,
                message: message,
                options: []
            };
            if (attachId) {
                params.options.push({
                    name: 'attachmentsid',
                    value: attachId
                });
            }
            return site.write('mod_forum_add_discussion_post', params).catch(function(error) {
                return $q.reject({
                    error: error,
                    wserror: $mmUtil.isWebServiceError(error)
                });
            }).then(function(response) {
                if (!response || !response.postid) {
                    return $q.reject({
                        wserror: true
                    });
                } else {
                    return response.postid;
                }
            });
        });
    };
        function storeUserData(list) {
        var ids = [];
        angular.forEach(list, function(entry) {
            var id = parseInt(entry.userid);
            if (!isNaN(id) && ids.indexOf(id) === -1) {
                ids.push(id);
                $mmUser.storeUser(id, entry.userfullname, entry.userpictureurl);
            }
            if (typeof entry.usermodified != 'undefined') {
                id = parseInt(entry.usermodified);
                if(!isNaN(id) && ids.indexOf(id) === -1) {
                    ids.push(id);
                    $mmUser.storeUser(id, entry.usermodifiedfullname, entry.usermodifiedpictureurl);
                }
            }
        });
    }
    return self;
}]);

angular.module('mm.addons.mod_forum')
.constant('mmaModForumOfflineDiscussionsStore', 'mma_mod_forum_offline_discussions')
.constant('mmaModForumOfflineRepliesStore', 'mma_mod_forum_offline_replies')
.config(["$mmSitesFactoryProvider", "mmaModForumOfflineDiscussionsStore", "mmaModForumOfflineRepliesStore", function($mmSitesFactoryProvider, mmaModForumOfflineDiscussionsStore, mmaModForumOfflineRepliesStore) {
    var stores = [
        {
            name: mmaModForumOfflineDiscussionsStore,
            keyPath: ['forumid', 'userid', 'timecreated'],
            indexes: [
                {
                    name: 'forumid'
                },
                {
                    name: 'courseid'
                },
                {
                    name: 'userid'
                },
                {
                    name: 'timecreated'
                },
                {
                    name: 'forumAndUser',
                    keyPath: ['forumid', 'userid']
                }
            ]
        },
        {
            name: mmaModForumOfflineRepliesStore,
            keyPath: ['postid', 'userid'],
            indexes: [
                {
                    name: 'postid'
                },
                {
                    name: 'courseid'
                },
                {
                    name: 'userid'
                },
                {
                    name: 'timecreated'
                },
                {
                    name: 'discussionAndUser',
                    keyPath: ['discussionid', 'userid']
                },
                {
                    name: 'forumAndUser',
                    keyPath: ['forumid', 'userid']
                }
            ]
        }
    ];
    $mmSitesFactoryProvider.registerStores(stores);
}])
.factory('$mmaModForumOffline', ["$log", "mmaModForumOfflineDiscussionsStore", "$mmSitesManager", "mmaModForumOfflineRepliesStore", "$mmSite", "$mmFS", function($log, mmaModForumOfflineDiscussionsStore, $mmSitesManager, mmaModForumOfflineRepliesStore,
        $mmSite, $mmFS) {
    $log = $log.getInstance('$mmaModForumOffline');
    var self = {};
        self.deleteNewDiscussion = function(forumId, timecreated, siteId, userId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            return site.getDb().remove(mmaModForumOfflineDiscussionsStore, [forumId, userId, timecreated]);
        });
    };
        self.getNewDiscussion = function(forumId, timecreated, siteId, userId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            return site.getDb().get(mmaModForumOfflineDiscussionsStore, [forumId, userId, timecreated]);
        });
    };
        self.getAllNewDiscussions = function(siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.getDb().getAll(mmaModForumOfflineDiscussionsStore);
        });
    };
        self.hasNewDiscussions = function(forumId, siteId, userId) {
        return self.getNewDiscussions(forumId, siteId, userId).then(function(discussions) {
            return !!discussions.length;
        }).catch(function() {
            return false;
        });
    };
        self.getNewDiscussions = function(forumId, siteId, userId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            return site.getDb().whereEqual(mmaModForumOfflineDiscussionsStore, 'forumAndUser', [forumId, userId]);
        });
    };
        self.addNewDiscussion = function(forumId, name, courseId, subject, message, subscribe, groupId, attach, timecreated,
                siteId, userId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            var db = site.getDb(),
                entry = {
                    forumid: forumId,
                    name: name,
                    courseid: courseId,
                    subject: subject,
                    message: message,
                    subscribe: subscribe,
                    groupid: groupId || -1,
                    userid: userId,
                    timecreated: timecreated || new Date().getTime()
                };
            if (attach) {
                entry.attachments = attach;
            }
            return db.insert(mmaModForumOfflineDiscussionsStore, entry);
        });
    };
        self.deleteReply = function(postId, siteId, userId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            return site.getDb().remove(mmaModForumOfflineRepliesStore, [postId, userId]);
        });
    };
        self.getAllReplies = function(siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.getDb().getAll(mmaModForumOfflineRepliesStore);
        });
    };
        self.hasForumReplies = function(forumId, siteId, userId) {
        return self.getForumReplies(forumId, siteId, userId).then(function(replies) {
            return !!replies.length;
        }).catch(function() {
            return false;
        });
    };
        self.getForumReplies = function(forumId, siteId, userId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            return site.getDb().whereEqual(mmaModForumOfflineRepliesStore, 'forumAndUser', [forumId, userId]);
        });
    };
        self.hasDiscussionReplies = function(discussionId, siteId, userId) {
        return self.getDiscussionReplies(discussionId, siteId, userId).then(function(replies) {
            return !!replies.length;
        }).catch(function() {
            return false;
        });
    };
        self.getDiscussionReplies = function(discussionId, siteId, userId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            return site.getDb().whereEqual(mmaModForumOfflineRepliesStore, 'discussionAndUser', [discussionId, userId]);
        });
    };
        self.getForumFolder = function(forumId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var siteFolderPath = $mmFS.getSiteFolder(site.getId()),
                forumFolderPath = 'offlineforum/' + forumId;
            return $mmFS.concatenatePaths(siteFolderPath, forumFolderPath);
        });
    };
        self.getNewDiscussionFolder = function(forumId, timecreated, siteId) {
        return self.getForumFolder(forumId, siteId).then(function(folderPath) {
            return $mmFS.concatenatePaths(folderPath, 'newdisc_' + timecreated);
        });
    };
        self.getReplyFolder = function(forumId, postId, siteId, userId) {
        return self.getForumFolder(forumId, siteId).then(function(folderPath) {
            return $mmSitesManager.getSite(siteId).then(function(site) {
                userId = userId || site.getUserId();
                return $mmFS.concatenatePaths(folderPath, 'reply_' + postId + '_' + userId);
            });
        });
    };
        self.replyPost = function(postId, discussionId, forumId, name, courseId, subject, message, attach, siteId, userId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            var db = site.getDb(),
                discussion = {
                    postid: postId,
                    discussionid: discussionId,
                    forumid: forumId,
                    name: name,
                    courseid: courseId,
                    subject: subject,
                    message: message,
                    userid: userId,
                    timecreated: new Date().getTime()
                };
            if (attach) {
                discussion.attachments = attach;
            }
            return db.insert(mmaModForumOfflineRepliesStore, discussion);
        });
    };
    return self;
}]);

angular.module('mm.addons.mod_forum')
.factory('$mmaModForumSync', ["$q", "$log", "$mmApp", "$mmSitesManager", "$mmaModForumOffline", "$mmSite", "$mmEvents", "$mmSync", "$mmLang", "mmaModForumComponent", "$mmaModForum", "$translate", "mmaModForumAutomSyncedEvent", "mmaModForumSyncTime", "$mmCourse", "$mmSyncBlock", "$mmaModForumHelper", "$mmFileUploader", function($q, $log, $mmApp, $mmSitesManager, $mmaModForumOffline, $mmSite, $mmEvents, $mmSync, $mmLang,
        mmaModForumComponent, $mmaModForum, $translate, mmaModForumAutomSyncedEvent, mmaModForumSyncTime, $mmCourse, $mmSyncBlock,
        $mmaModForumHelper, $mmFileUploader) {
    $log = $log.getInstance('$mmaModForumSync');
    var self = $mmSync.createChild(mmaModForumComponent, mmaModForumSyncTime);
        self.syncAllForums = function(siteId) {
        if (!$mmApp.isOnline()) {
            $log.debug('Cannot sync all forums because device is offline.');
            return $q.reject();
        }
        var promise;
        if (!siteId) {
            $log.debug('Try to sync forums in all sites.');
            promise = $mmSitesManager.getSitesIds();
        } else {
            $log.debug('Try to sync forums in site ' + siteId);
            promise = $q.when([siteId]);
        }
        return promise.then(function(siteIds) {
            var sitePromises = [];
            angular.forEach(siteIds, function(siteId) {
                sitePromises.push($mmaModForumOffline.getAllNewDiscussions(siteId).then(function(discussions) {
                    var promises = {};
                    for (var i in discussions) {
                        var discussion = discussions[i];
                        if (typeof promises[discussion.forumid] != 'undefined') {
                            continue;
                        }
                        promises[discussion.forumid] = self.syncForumDiscussionsIfNeeded(discussion.forumid, discussion.userid, siteId)
                                .then(function(result) {
                            if (result && result.updated) {
                                $mmEvents.trigger(mmaModForumAutomSyncedEvent, {
                                    siteid: siteId,
                                    forumid: discussion.forumid,
                                    userid: discussion.userid,
                                    warnings: result.warnings
                                });
                            }
                        });
                    }
                    promises = Object.keys(promises).map(function (key) {return promises[key];});
                    return $q.all(promises);
                }));
                sitePromises.push($mmaModForumOffline.getAllReplies(siteId).then(function(replies) {
                    var promises = {};
                    for (var i in replies) {
                        var reply = replies[i];
                        if (typeof promises[reply.discussionid] != 'undefined') {
                            continue;
                        }
                        promises[reply.discussionid] = self.syncDiscussionRepliesIfNeeded(reply.discussionid, reply.userid, siteId)
                                .then(function(result) {
                            if (result && result.updated) {
                                $mmEvents.trigger(mmaModForumAutomSyncedEvent, {
                                    siteid: siteId,
                                    forumid: reply.forumid,
                                    discussionid: reply.discussionid,
                                    userid: reply.userid,
                                    warnings: result.warnings
                                });
                            }
                        });
                    }
                    promises = Object.keys(promises).map(function (key) {return promises[key];});
                    return $q.all(promises);
                }));
            });
            return $q.all(sitePromises);
        });
    };
        self.syncForumDiscussionsIfNeeded = function(forumId, userId, siteId) {
        siteId = siteId || $mmSite.getId();
        var syncId = self.getForumSyncId(forumId, userId);
        return self.isSyncNeeded(syncId, siteId).then(function(needed) {
            if (needed) {
                return self.syncForumDiscussions(forumId, userId, siteId);
            }
        });
    };
        self.syncForumDiscussions = function(forumId, userId, siteId) {
        userId = userId || $mmSite.getUserId();
        siteId = siteId || $mmSite.getId();
        var syncPromise,
            courseId,
            syncId = self.getForumSyncId(forumId, userId),
            result = {
                warnings: [],
                updated: false
            };
        if (self.isSyncing(syncId, siteId)) {
            return self.getOngoingSync(syncId, siteId);
        }
        if ($mmSyncBlock.isBlocked(mmaModForumComponent, syncId, siteId)) {
            $log.debug('Cannot sync forum ' + forumId + ' because it is blocked.');
            var modulename = $mmCourse.translateModuleName('forum');
            return $mmLang.translateAndReject('mm.core.errorsyncblocked', {$a: modulename});
        }
        $log.debug('Try to sync forum ' + forumId + ' for user ' + userId);
        syncPromise = $mmaModForumOffline.getNewDiscussions(forumId, siteId, userId).catch(function() {
            return [];
        }).then(function(discussions) {
            if (!discussions.length) {
                return;
            } else if (!$mmApp.isOnline()) {
                return $q.reject();
            }
            var promises = [];
            angular.forEach(discussions, function(data) {
                var promise;
                courseId = data.courseid;
                promise = uploadAttachments(forumId, data, true, siteId, userId).then(function(itemId) {
                    return $mmaModForum.addNewDiscussionOnline(forumId, data.subject, data.message,
                            data.subscribe, data.groupid, itemId, siteId);
                });
                promises.push(promise.then(function() {
                    result.updated = true;
                    return deleteNewDiscussion(forumId, data.timecreated, siteId, userId);
                }).catch(function(error) {
                    if (error && error.wserror) {
                        result.updated = true;
                        return deleteNewDiscussion(forumId, data.timecreated, siteId, userId).then(function() {
                            result.warnings.push($translate.instant('mm.core.warningofflinedatadeleted', {
                                component: $mmCourse.translateModuleName('forum'),
                                name: data.name,
                                error: error.error
                            }));
                        });
                    } else {
                        return $q.reject(error && error.error);
                    }
                }));
            });
            return $q.all(promises);
        }).then(function() {
            if (result.updated) {
                var promises = [];
                promises.push($mmaModForum.invalidateDiscussionsList(forumId, siteId));
                promises.push($mmaModForum.invalidateCanAddDiscussion(forumId, siteId));
                return $q.all(promises).catch(function() {
                });
            }
        }).then(function() {
            return self.setSyncTime(syncId, siteId).catch(function() {
            });
        }).then(function() {
            return result;
        });
        return self.addOngoingSync(syncId, syncPromise, siteId);
    };
        function deleteNewDiscussion(forumId, timecreated, siteId, userId) {
        var promises = [];
        promises.push($mmaModForumOffline.deleteNewDiscussion(forumId, timecreated, siteId, userId));
        promises.push($mmaModForumHelper.deleteNewDiscussionStoredFiles(forumId, timecreated, siteId).catch(function() {
        }));
        return $q.all(promises);
    }
        function deleteReply(forumId, postId, siteId, userId) {
        var promises = [];
        promises.push($mmaModForumOffline.deleteReply(postId, siteId, userId));
        promises.push($mmaModForumHelper.deleteReplyStoredFiles(forumId, postId, siteId, userId).catch(function() {
        }));
        return $q.all(promises);
    }
        self.syncForumReplies = function(forumId, userId, siteId) {
        return $mmaModForumOffline.getForumReplies(forumId, siteId, userId).catch(function() {
            return {};
        }).then(function(replies) {
            if (!replies.length) {
                return { warnings: [], updated: false };
            } else if (!$mmApp.isOnline()) {
                return $q.reject();
            }
            var promises = {};
            for (var i in replies) {
                var reply = replies[i];
                if (typeof promises[reply.discussionid] != 'undefined') {
                    continue;
                }
                promises[reply.discussionid] = self.syncDiscussionReplies(reply.discussionid, userId, siteId);
            }
            promises = Object.keys(promises).map(function (key) {return promises[key];});
            return $q.all(promises).then(function(results) {
                return results.reduce(function(a, b) {
                    a.warnings = a.warnings.concat(b.warnings);
                    a.updated = a.updated || b.updated;
                    return a;
                }, { warnings: [], updated: false });
            });
        });
    };
        self.syncDiscussionRepliesIfNeeded = function(discussionId, userId, siteId) {
        siteId = siteId || $mmSite.getId();
        var syncId = self.getDiscussionSyncId(discussionId, userId);
        return self.isSyncNeeded(syncId, siteId).then(function(needed) {
            if (needed) {
                return self.syncDiscussionReplies(discussionId, userId, siteId);
            }
        });
    };
        self.syncDiscussionReplies = function(discussionId, userId, siteId) {
        userId = userId || $mmSite.getUserId();
        siteId = siteId || $mmSite.getId();
        var syncPromise,
            courseId,
            forumId,
            syncId = self.getDiscussionSyncId(discussionId, userId),
            result = {
                warnings: [],
                updated: false
            };
        if (self.isSyncing(syncId, siteId)) {
            return self.getOngoingSync(syncId, siteId);
        }
        if ($mmSyncBlock.isBlocked(this.component, syncId, siteId)) {
            $log.debug('Cannot sync forum discussion ' + discussionId + ' because it is blocked.');
            var modulename = $mmCourse.translateModuleName('forum');
            return $mmLang.translateAndReject('mm.core.errorsyncblocked', {$a: modulename});
        }
        $log.debug('Try to sync forum discussion ' + discussionId + ' for user ' + userId);
        syncPromise = $mmaModForumOffline.getDiscussionReplies(discussionId, siteId, userId).catch(function() {
            return [];
        }).then(function(replies) {
            if (!replies.length) {
                return;
            } else if (!$mmApp.isOnline()) {
                return $q.reject();
            }
            var promises = [];
            angular.forEach(replies, function(data) {
                var promise;
                courseId = data.courseid;
                forumId = data.forumid;
                promise = uploadAttachments(forumId, data, false, siteId, userId).then(function(itemId) {
                    return $mmaModForum.replyPostOnline(data.postid, data.subject, data.message, itemId, siteId);
                });
                promises.push(promise.then(function() {
                    result.updated = true;
                    return deleteReply(forumId, data.postid, siteId, userId);
                }).catch(function(error) {
                    if (error && error.wserror) {
                        result.updated = true;
                        return deleteReply(forumId, data.postid, siteId, userId).then(function() {
                            result.warnings.push($translate.instant('mm.core.warningofflinedatadeleted', {
                                component: $mmCourse.translateModuleName('forum'),
                                name: data.name,
                                error: error.error
                            }));
                        });
                    } else {
                        return $q.reject(error && error.error);
                    }
                }));
            });
            return $q.all(promises);
        }).then(function() {
            var promises = [];
            if (forumId) {
                promises.push($mmaModForum.invalidateDiscussionsList(forumId, siteId));
            }
            promises.push($mmaModForum.invalidateDiscussionPosts(discussionId, siteId));
            return $q.all(promises).catch(function() {
            });
        }).then(function() {
            return self.setSyncTime(syncId, siteId).catch(function() {
            });
        }).then(function() {
            return result;
        });
        return self.addOngoingSync(syncId, syncPromise, siteId);
    };
        function uploadAttachments(forumId, post, isDisc, siteId, userId) {
        var attachments = post && post.attachments;
        if (attachments) {
            var files = attachments.online || [],
                promise;
            if (attachments.offline) {
                if (isDisc) {
                    promise = $mmaModForumHelper.getNewDiscussionStoredFiles(forumId, post.timecreated, siteId);
                } else {
                    promise = $mmaModForumHelper.getReplyStoredFiles(forumId, post.postid, siteId, userId);
                }
                promise.then(function(atts) {
                    files = files.concat(atts);
                }).catch(function() {
                });
            } else {
                promise = $q.when();
            }
            return promise.then(function() {
                return $mmFileUploader.uploadOrReuploadFiles(files, mmaModForumComponent, forumId, siteId);
            });
        }
        return $q.when();
    }
        self.getForumSyncId = function(forumId, userId) {
        userId = userId || $mmSite.getUserId();
        return 'forum#' + forumId + '#' + userId;
    };
        self.getDiscussionSyncId = function(discussionId, userId) {
        userId = userId || $mmSite.getUserId();
        return 'discussion#' + discussionId + '#' + userId;
    };
    return self;
}]);

angular.module('mm.addons.mod_forum')
.factory('$mmaModForumHandlers', ["$mmCourse", "$mmaModForum", "$state", "$mmUtil", "$mmContentLinksHelper", "$mmEvents", "$mmSite", "$mmaModForumPrefetchHandler", "$mmCoursePrefetchDelegate", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", "mmaModForumComponent", "mmCoreEventPackageStatusChanged", "$mmaModForumSync", "$mmContentLinkHandlerFactory", function($mmCourse, $mmaModForum, $state, $mmUtil, $mmContentLinksHelper, $mmEvents, $mmSite,
            $mmaModForumPrefetchHandler, $mmCoursePrefetchDelegate, mmCoreDownloading, mmCoreNotDownloaded, mmCoreOutdated,
            mmaModForumComponent, mmCoreEventPackageStatusChanged, $mmaModForumSync, $mmContentLinkHandlerFactory) {
    var self = {};
        self.courseContent = function() {
        var self = {};
                self.isEnabled = function() {
            return $mmaModForum.isPluginEnabled();
        };
                self.getController = function(module, courseId) {
            return function($scope) {
                var downloadBtn = {
                        hidden: true,
                        icon: 'ion-ios-cloud-download-outline',
                        label: 'mm.core.download',
                        action: function(e) {
                            if (e) {
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            download();
                        }
                    },
                    refreshBtn = {
                        hidden: true,
                        icon: 'ion-android-refresh',
                        label: 'mm.core.refresh',
                        action: function(e) {
                            if (e) {
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            $scope.spinner = true;
                            $mmaModForum.invalidateContent(module.id, courseId).finally(function() {
                                download();
                            });
                        }
                    };
                $scope.title = module.name;
                $scope.icon = $mmCourse.getModuleIconSrc('forum');
                $scope.class = 'mma-mod_forum-handler';
                $scope.buttons = [downloadBtn, refreshBtn];
                $scope.spinner = true;
                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_forum', {module: module, courseid: courseId});
                };
                function download() {
                    $scope.spinner = true;
                    $mmaModForumPrefetchHandler.getDownloadSize(module, courseId).then(function(size) {
                        $mmUtil.confirmDownloadSize(size).then(function() {
                            $mmaModForumPrefetchHandler.prefetch(module, courseId).catch(function() {
                                if (!$scope.$$destroyed) {
                                    $mmUtil.showErrorModal('mm.core.errordownloading', true);
                                }
                            });
                        }).catch(function() {
                            $scope.spinner = false;
                        });
                    }).catch(function(error) {
                        $scope.spinner = false;
                        if (error) {
                            $mmUtil.showErrorModal(error);
                        } else {
                            $mmUtil.showErrorModal('mm.core.errordownloading', true);
                        }
                    });
                }
                function showStatus(status) {
                    if (status) {
                        $scope.spinner = status === mmCoreDownloading;
                        downloadBtn.hidden = status !== mmCoreNotDownloaded;
                        refreshBtn.hidden = status !== mmCoreOutdated;
                    }
                }
                var statusObserver = $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
                    if (data.siteid === $mmSite.getId() && data.componentId === module.id &&
                            data.component === mmaModForumComponent) {
                        showStatus(data.status);
                    }
                });
                $mmCoursePrefetchDelegate.getModuleStatus(module, courseId).then(showStatus);
                $scope.$on('$destroy', function() {
                    statusObserver && statusObserver.off && statusObserver.off();
                });
            };
        };
        return self;
    };
        self.indexLinksHandler = $mmContentLinksHelper.createModuleIndexLinkHandler('mmaModForum', 'forum', $mmaModForum);
        self.discussionLinksHandler = $mmContentLinkHandlerFactory.createChild(
                /\/mod\/forum\/discuss\.php.*([\&\?]d=\d+)/, '$mmCourseDelegate_mmaModForum');
    self.discussionLinksHandler.isEnabled = $mmaModForum.isPluginEnabled;
    self.discussionLinksHandler.getActions = function(siteIds, url, params, courseId) {
        courseId = courseId || params.courseid || params.cid;
        return [{
            action: function(siteId) {
                var stateParams = {
                    discussionid: parseInt(params.d, 10),
                    cid: courseId ? parseInt(courseId, 10) : courseId
                };
                $mmContentLinksHelper.goInSite('site.mod_forum-discussion', stateParams, siteId);
            }
        }];
    };
        self.syncHandler = function() {
        var self = {};
                self.execute = function(siteId) {
            return $mmaModForumSync.syncAllForums(siteId);
        };
                self.getInterval = function() {
            return 600000;
        };
                self.isSync = function() {
            return true;
        };
                self.usesNetwork = function() {
            return true;
        };
        return self;
    };
    return self;
}]);

angular.module('mm.addons.mod_forum')
.factory('$mmaModForumHelper', ["$mmaModForumOffline", "$mmSite", "$mmFileUploader", "$mmFS", "mmaModForumComponent", "$mmUser", "$q", "$mmFileUploaderHelper", function($mmaModForumOffline, $mmSite, $mmFileUploader, $mmFS, mmaModForumComponent, $mmUser, $q,
        $mmFileUploaderHelper) {
    var self = {};
        self.convertOfflineReplyToOnline = function(offlineReply, siteId) {
        var reply = {
                attachments: [],
                canreply: false,
                children: [],
                created: offlineReply.timecreated,
                discussion: offlineReply.discussionid,
                id: false,
                mailed: 0,
                mailnow: 0,
                message: offlineReply.message,
                messageformat: 1,
                messagetrust: 0,
                modified: false,
                parent: offlineReply.postid,
                postread: false,
                subject: offlineReply.subject,
                totalscore: 0,
                userid: offlineReply.userid
            },
            promises = [];
        if (offlineReply.attachments) {
            reply.attachments = offlineReply.attachments.online || [];
            if (offlineReply.attachments.offline) {
                promises.push(self.getReplyStoredFiles(offlineReply.forumid, reply.parent, siteId, reply.userid)
                            .then(function(files) {
                    reply.attachments = reply.attachments.concat(files);
                }));
            }
        }
        promises.push($mmUser.getProfile(offlineReply.userid, offlineReply.courseid, true).then(function(user) {
            reply.userfullname = user.fullname;
            reply.userpictureurl = user.profileimageurl;
        }).catch(function() {
        }));
        return $q.all(promises).then(function() {
            reply.attachment = reply.attachments.length > 0 ? 1 : 0;
            return reply;
        });
    };
        self.deleteNewDiscussionStoredFiles = function(forumId, timecreated, siteId) {
        return $mmaModForumOffline.getNewDiscussionFolder(forumId, timecreated, siteId).then(function(folderPath) {
            return $mmFS.removeDir(folderPath);
        });
    };
        self.deleteReplyStoredFiles = function(forumId, postId, siteId, userId) {
        return $mmaModForumOffline.getReplyFolder(forumId, postId, siteId, userId).then(function(folderPath) {
            return $mmFS.removeDir(folderPath);
        });
    };
        self.getNewDiscussionStoredFiles = function(forumId, timecreated, siteId) {
        return $mmaModForumOffline.getNewDiscussionFolder(forumId, timecreated, siteId).then(function(folderPath) {
            return $mmFileUploaderHelper.getStoredFiles(folderPath);
        });
    };
        self.getReplyStoredFiles = function(forumId, postId, siteId, userId) {
        return $mmaModForumOffline.getReplyFolder(forumId, postId, siteId, userId).then(function(folderPath) {
            return $mmFileUploaderHelper.getStoredFiles(folderPath);
        });
    };
        self.hasPostDataChanged = function(post, original) {
        if (!original || typeof original.subject == 'undefined') {
            return false;
        }
        if (original.subject != post.subject || original.text != post.text) {
            return true;
        }
        return $mmFileUploaderHelper.areFileListDifferent(post.files, original.files);
    };
        self.storeNewDiscussionFiles = function(forumId, timecreated, files, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmaModForumOffline.getNewDiscussionFolder(forumId, timecreated, siteId).then(function(folderPath) {
            return $mmFileUploader.storeFilesToUpload(folderPath, files);
        });
    };
        self.storeReplyFiles = function(forumId, postId, files, siteId, userId) {
        return $mmaModForumOffline.getReplyFolder(forumId, postId, siteId, userId).then(function(folderPath) {
            return $mmFileUploader.storeFilesToUpload(folderPath, files);
        });
    };
        self.uploadOrStoreNewDiscussionFiles = function(forumId, timecreated, files, offline, siteId) {
        if (offline) {
            return self.storeNewDiscussionFiles(forumId, timecreated, files, siteId);
        } else {
            return $mmFileUploader.uploadOrReuploadFiles(files, mmaModForumComponent, forumId, siteId);
        }
    };
        self.uploadOrStoreReplyFiles = function(forumId, postId, files, offline, siteId, userId) {
        if (offline) {
            return self.storeReplyFiles(forumId, postId, files, siteId, userId);
        } else {
            return $mmFileUploader.uploadOrReuploadFiles(files, mmaModForumComponent, forumId, siteId);
        }
    };
    return self;
}]);

angular.module('mm.addons.mod_forum')
.factory('$mmaModForumPrefetchHandler', ["$mmaModForum", "mmaModForumComponent", "$mmFilepool", "$q", "$mmUtil", "$mmUser", "$mmGroups", "md5", "$mmPrefetchFactory", "$mmCoursePrefetchDelegate", function($mmaModForum, mmaModForumComponent, $mmFilepool, $q, $mmUtil, $mmUser,
            $mmGroups, md5, $mmPrefetchFactory, $mmCoursePrefetchDelegate) {
    var self = $mmPrefetchFactory.createPrefetchHandler(mmaModForumComponent);
    self.updatesNames = /^configuration$|^.*files$|^discussions$/;
        self.download = function(module, courseId) {
        return self.prefetch(module, courseId);
    };
        self.getFiles = function(module, courseId) {
        var files;
        return $mmaModForum.getForum(courseId, module.id).then(function(forum) {
            files = self.getIntroFilesFromInstance(module, forum);
            return getPostsForPrefetch(forum.id);
        }).then(function(posts) {
            return files.concat(getPostsFiles(posts));
        }).catch(function() {
            return [];
        });
    };
        function getPostsFiles(posts) {
        var files = [];
        angular.forEach(posts, function(post) {
            if (post.attachments && post.attachments.length) {
                files = files.concat(post.attachments);
            }
            if (post.message) {
                files = files.concat($mmUtil.extractDownloadableFilesFromHtmlAsFakeFileObjects(post.message));
            }
        });
        return files;
    }
        function getPostsForPrefetch(forumId) {
        return $mmaModForum.getDiscussionsInPages(forumId, false, 2).then(function(response) {
            if (response.error) {
                return $q.reject();
            }
            var promises = [],
                posts = [];
            angular.forEach(response.discussions, function(discussion) {
                promises.push($mmaModForum.getDiscussionPosts(discussion.discussion).then(function(ps) {
                    posts = posts.concat(ps);
                }));
            });
            return $q.all(promises).then(function() {
                return posts;
            });
        });
    }
        self.getRevision = function(module, courseId) {
        return $mmaModForum.getForum(courseId, module.id).then(function(forum) {
            return getRevisionFromForum(forum);
        });
    };
        function getRevisionFromForum(forum) {
        var revision = '' + forum.numdiscussions;
        if (typeof forum.introfiles == 'undefined' && forum.intro) {
            var urls = $mmUtil.extractDownloadableFilesFromHtml(forum.intro);
            urls = urls.sort(function (a, b) {
                return a > b;
            });
            return revision + '#' + md5.createHash(JSON.stringify(urls));
        }
        return revision;
    }
        self.getTimemodified = function(module, courseId) {
        return $mmaModForum.getForum(courseId, module.id).then(function(forum) {
            return getTimemodifiedFromForum(module, forum);
        });
    };
        function getTimemodifiedFromForum(module, forum) {
        var timemodified = forum.timemodified || 0,
            introFiles = self.getIntroFilesFromInstance(module, forum);
        timemodified = Math.max(timemodified, $mmFilepool.getTimemodifiedFromFileList(introFiles));
        return $mmaModForum.getDiscussions(forum.id, 0).then(function(response) {
            if (response.discussions && response.discussions[0]) {
                var discussionTime =  parseInt(response.discussions[0].timemodified, 10);
                if (!isNaN(discussionTime)) {
                    timemodified = Math.max(timemodified, discussionTime);
                }
            }
            return timemodified;
        });
    }
        self.invalidateContent = function(moduleId, courseId) {
        return $mmaModForum.invalidateContent(moduleId, courseId);
    };
        self.invalidateModule = function(module, courseId) {
        if ($mmCoursePrefetchDelegate.canCheckUpdates()) {
            return $q.when();
        }
        return $mmaModForum.getForum(courseId, module.id).then(function(forum) {
            var promises = [];
            promises.push($mmaModForum.invalidateForumData(courseId));
            promises.push($mmaModForum.invalidateDiscussionsList(forum.id));
            return $q.all(promises);
        });
    };
        self.isEnabled = function() {
        return $mmaModForum.isPluginEnabled();
    };
        self.prefetch = function(module, courseId, single) {
        return self.prefetchPackage(module, courseId, single, prefetchForum);
    };
        function prefetchForum(module, courseId, single, siteId) {
        var revision,
            timemod,
            forum;
        return $mmaModForum.getForum(courseId, module.id).then(function(f) {
            forum = f;
            revision = getRevisionFromForum(forum);
            return getTimemodifiedFromForum(module, forum);
        }).then(function(time) {
            timemod = time;
            return getPostsForPrefetch(forum.id);
        }).then(function(posts) {
            var promises = [],
                files = self.getIntroFilesFromInstance(module, forum),
                userIds = [],
                canCreateDiscussions = $mmaModForum.isCreateDiscussionEnabled() && forum.cancreatediscussions;
            files = files.concat(getPostsFiles(posts));
            angular.forEach(posts, function(post) {
                if (post.userid && userIds.indexOf(post.userid) == -1) {
                    userIds.push(post.userid);
                    promises.push($mmUser.getProfile(post.userid, courseId));
                    if (post.userpictureurl) {
                        promises.push($mmFilepool.addToQueueByUrl(siteId, post.userpictureurl).catch(function() {
                        }));
                    }
                }
            });
            angular.forEach(files, function(file) {
                promises.push($mmFilepool.addToQueueByUrl(siteId, file.fileurl, self.component, module.id, file.timemodified));
            });
            promises.push(prefetchGroupsInfo(forum, courseId, canCreateDiscussions));
            return $q.all(promises);
        }).then(function() {
            return {
                revision: revision,
                timemod: timemod
            };
        });
    }
        function prefetchGroupsInfo(forum, courseId, canCreateDiscussions) {
        return $mmGroups.getActivityGroupMode(forum.cmid).then(function(mode) {
            if (mode !== $mmGroups.SEPARATEGROUPS && mode !== $mmGroups.VISIBLEGROUPS) {
                return;
            }
            return $mmGroups.getActivityAllowedGroups(forum.cmid).then(function(groups) {
                if (mode === $mmGroups.SEPARATEGROUPS) {
                    return;
                }
                if (canCreateDiscussions) {
                    if ($mmaModForum.isCanAddDiscussionAvailable()) {
                        return $mmaModForum.canAddDiscussionToAll(forum.id).catch(function() {
                            return false;
                        }).then(function(canAdd) {
                            if (canAdd) {
                                return;
                            }
                            var groupPromises = [];
                            angular.forEach(groups, function(group) {
                                groupPromises.push($mmaModForum.canAddDiscussion(forum.id, group.id).catch(function() {
                                }));
                            });
                            return $q.all(groupPromises);
                        });
                    } else {
                        return $mmGroups.getUserGroupsInCourse(courseId, true);
                    }
                }
            });
        }, function(error) {
            if (canCreateDiscussions) {
                return $q.reject(error);
            }
        });
    }
    return self;
}]);

angular.module('mm.addons.mod_glossary')
.controller('mmaModGlossaryEditCtrl', ["$stateParams", "$scope", "mmaModGlossaryComponent", "$mmUtil", "$q", "$mmaModGlossary", "$mmText", "$translate", "$ionicHistory", "$mmEvents", "mmaModGlossaryAddEntryEvent", "$mmaModGlossaryOffline", "$mmaModGlossaryHelper", "$mmLang", "$mmFileUploaderHelper", function($stateParams, $scope, mmaModGlossaryComponent, $mmUtil, $q, $mmaModGlossary, $mmText,
        $translate, $ionicHistory, $mmEvents, mmaModGlossaryAddEntryEvent, $mmaModGlossaryOffline, $mmaModGlossaryHelper, $mmLang,
        $mmFileUploaderHelper) {
    var module = $stateParams.module,
        courseId = $stateParams.courseid,
        cmid = $stateParams.cmid,
        glossaryId = $stateParams.glossaryid,
        glossary = $stateParams.glossary || {},
        originalData = null,
        entry = $stateParams.entry || false,
        allowDuplicateEntries = !!glossary.allowduplicatedentries;
    $scope.entry = {
        concept: '',
        text: ''
    };
    $scope.title = module.name;
    $scope.component = mmaModGlossaryComponent;
    $scope.componentId = module.id;
    $scope.autolinking = !!glossary.usedynalink;
    $scope.options = {
        categories: null,
        aliases: "",
        usedynalink: false,
        casesensitive: false,
        fullmatch: false
    };
    $scope.attachments = [];
    if (entry) {
        $scope.entry.concept = entry.concept || '';
        $scope.entry.text = entry.definition || '';
        originalData = {};
        originalData.text = $scope.entry.text;
        originalData.concept = $scope.entry.concept;
        originalData.files = [];
        if (entry.options) {
            $scope.options.categories = entry.options.categories || null;
            $scope.options.aliases = entry.options.aliases || "";
            $scope.options.usedynalink = !!entry.options.usedynalink;
            if ($scope.options.usedynalink) {
                $scope.options.casesensitive = !!entry.options.casesensitive;
                $scope.options.fullmatch = !!entry.options.fullmatch;
            }
        }
        if (entry.attachments && entry.attachments.offline) {
            $mmaModGlossaryHelper.getStoredFiles(glossaryId, entry.concept, entry.timecreated).then(function(files) {
                $scope.attachments = files;
                originalData.files = angular.copy(files);
            });
        }
    }
    $mmUtil.blockLeaveView($scope, cancel);
    function fetchGlossaryData() {
        return $mmaModGlossary.getAllCategories(glossaryId).then(function(categories) {
            $scope.categories = categories;
            if ($scope.options.categories) {
                var cats = $scope.options.categories.split(",");
                angular.forEach(cats, function(catId) {
                    angular.forEach($scope.categories, function(category) {
                        if (category.id == catId) {
                            category.selected = true;
                        }
                    });
                });
            }
        });
    }
    function cancel() {
        var promise;
        if (!$mmaModGlossaryHelper.hasEntryDataChanged($scope.entry, $scope.attachments, originalData)) {
           promise = $q.when();
        } else {
            promise =  $mmUtil.showConfirm($translate('mm.core.confirmcanceledit'));
        }
        return promise.then(function() {
            $mmFileUploaderHelper.clearTmpFiles($scope.attachments);
        });
    }
    $scope.save = function() {
        var concept = $scope.entry.concept,
            definition = $scope.entry.text,
            modal,
            attachments,
            timecreated = entry && entry.timecreated || Date.now(),
            saveOffline = false;
        if (!concept || !definition) {
            $mmUtil.showErrorModal('mma.mod_glossary.fillfields', true);
            return;
        }
        modal = $mmUtil.showModalLoading('mm.core.sending', true);
        $mmUtil.isRichTextEditorEnabled().then(function(enabled) {
            if (!enabled) {
                definition = $mmText.formatHtmlLines(definition);
            }
            attachments = $scope.attachments;
            if (!!attachments.length) {
                return $mmaModGlossaryHelper.uploadOrStoreFiles(glossaryId, concept, timecreated, attachments, false)
                        .catch(function() {
                    saveOffline = true;
                    return $mmaModGlossaryHelper.uploadOrStoreFiles(glossaryId, concept, timecreated, attachments, true);
                });
            }
        }).then(function(attach) {
            var cats = [];
            if ($scope.categories) {
                cats = $scope.categories.filter(function(category) {
                    return category.selected;
                }).map(function(category) {
                    return category.id;
                });
            }
            var options = {
                aliases: $scope.options.aliases || "",
                categories: cats.join(',') || ""
            };
            if ($scope.autolinking) {
                options.usedynalink = $scope.options.usedynalink ? 1 : 0;
                if ($scope.options.usedynalink) {
                    options.casesensitive = $scope.options.casesensitive ? 1 : 0;
                    options.fullmatch = $scope.options.fullmatch ? 1 : 0;
                }
            }
            if (saveOffline) {
                var promise;
                if (entry && !allowDuplicateEntries) {
                    promise = $mmaModGlossary.isConceptUsed(glossaryId, concept, entry.timecreated).then(function(used) {
                        if (used) {
                            return $mmLang.translateAndReject('mma.mod_glossary.errconceptalreadyexists');
                        }
                    });
                } else {
                    promise = $q.when();
                }
                return promise.then(function() {
                    return $mmaModGlossaryOffline.saveAddEntry(glossaryId, concept, definition, courseId, options, attach,
                            timecreated, undefined, undefined, entry).then(function() {
                    });
                });
            } else {
                return $mmaModGlossary.addEntry(glossaryId, concept, definition, courseId, options, attach, timecreated, undefined,
                    entry, !attachments.length, !allowDuplicateEntries);
            }
        }).then(function(entryId) {
            if (entryId) {
                $scope.entry.id = entryId;
                $mmaModGlossaryHelper.deleteStoredFiles(glossaryId, concept, timecreated);
            }
            $scope.entry.glossaryid = glossaryId;
            $scope.entry.definition = definition;
            return returnToEntryList();
        }).catch(function(error) {
            $mmUtil.showErrorModalDefault(error, 'mma.mod_glossary.cannoteditentry', true);
        }).finally(function() {
            modal.dismiss();
        });
    };
    function returnToEntryList() {
        var data = {
            glossaryid: glossaryId,
            cmid: cmid,
            entry: $scope.entry
        };
        $mmFileUploaderHelper.clearTmpFiles($scope.attachments);
        $mmEvents.trigger(mmaModGlossaryAddEntryEvent, data);
        $ionicHistory.goBack();
    }
    fetchGlossaryData().finally(function() {
        $scope.glossaryLoaded = true;
    });
}]);

angular.module('mm.addons.mod_glossary')
.controller('mmaModGlossaryEntryCtrl', ["$scope", "$stateParams", "$mmaModGlossary", "$translate", "mmaModGlossaryComponent", "mmUserProfileState", "$mmUtil", function($scope, $stateParams, $mmaModGlossary, $translate, mmaModGlossaryComponent,
        mmUserProfileState, $mmUtil) {
    var entryId = $stateParams.entryid,
        courseId = $stateParams.cid || 0,
        glossary,
        entry;
    if (!courseId) {
        $mmUtil.showErrorModal('mma.mod_glossary.errorloadingentry', true);
        return;
    }
    $scope.refreshEntry = function() {
        return $mmaModGlossary.invalidateEntry(entry.id).then(function() {
            return fetchEntry(true);
        }).finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
    function fetchEntry(refresh) {
        return $mmaModGlossary.getEntry(entryId).then(function(result) {
            entry = result;
            $scope.entry = entry;
            $scope.title = entry.concept;
            if (!refresh) {
                return $mmaModGlossary.getGlossaryById(courseId, entry.glossaryid).then(function(gloss) {
                    glossary = gloss;
                    var displayFormat = glossary.displayformat;
                    $scope.courseId = courseId;
                    $scope.userStateName = mmUserProfileState;
                    $scope.component = mmaModGlossaryComponent;
                    $scope.componentId = glossary.coursemodule;
                    if (displayFormat == 'fullwithauthor' || displayFormat == 'encyclopedia') {
                        $scope.showAuthor = true;
                        $scope.showDate = true;
                    } else if (displayFormat == 'fullwithoutauthor') {
                        $scope.showAuthor = false;
                        $scope.showDate = true;
                    } else {
                        $scope.showAuthor = false;
                        $scope.showDate = false;
                    }
                });
            }
        }).catch(function(error) {
            $mmUtil.showErrorModalDefault(error, 'mma.mod_glossary.errorloadingentry', true);
            return $q.reject();
        });
    }
    fetchEntry().then(function() {
        $mmaModGlossary.logEntryView(entry.id);
    }).finally(function() {
        $scope.entryLoaded = true;
    });
}]);

angular.module('mm.addons.mod_glossary')
.controller('mmaModGlossaryIndexCtrl', ["$q", "$scope", "$stateParams", "$ionicPopover", "$mmUtil", "$mmCourseHelper", "$mmaModGlossary", "$ionicScrollDelegate", "$translate", "$mmText", "mmaModGlossaryComponent", "mmaModGlossaryLimitEntriesNum", "$state", "$mmCourse", "$mmaModGlossaryOffline", "$mmEvents", "mmaModGlossaryAddEntryEvent", "mmCoreEventOnlineStatusChanged", "$mmApp", "$mmSite", "mmaModGlossaryAutomSyncedEvent", "$mmaModGlossarySync", "mmaModGlossaryShowAllCategories", function($q, $scope, $stateParams, $ionicPopover, $mmUtil, $mmCourseHelper, $mmaModGlossary,
        $ionicScrollDelegate, $translate, $mmText, mmaModGlossaryComponent, mmaModGlossaryLimitEntriesNum, $state, $mmCourse,
        $mmaModGlossaryOffline, $mmEvents, mmaModGlossaryAddEntryEvent, mmCoreEventOnlineStatusChanged, $mmApp, $mmSite,
        mmaModGlossaryAutomSyncedEvent, $mmaModGlossarySync, mmaModGlossaryShowAllCategories) {
    var module = $stateParams.module || {},
        courseId = $stateParams.courseid,
        glossary,
        noop = function(){},
        limitFrom = 0,
        limitNum = mmaModGlossaryLimitEntriesNum,
        popover,
        popoverScope,
        viewMode,  
        fetchMode,      
        fetchFunction,
        fetchInvalidate,
        fetchArguments,
        obsAddEntry, onlineObserver, syncObserver,
        searchingMessage = $translate.instant('mm.core.searching'),
        loadingMessage = $translate.instant('mm.core.loading');
    $scope.title = module.name;
    $scope.description = module.description;
    $scope.externalUrl = module.url;
    $scope.courseid = courseId;
    $scope.loaded = false;
    $scope.refreshIcon = 'spinner';
    $scope.syncIcon = 'spinner';
    $scope.entries = [];
    $scope.getDivider = noop;
    $scope.showDivider = noop;
    $scope.canLoadMore = false;
    $scope.searchData = {
        searchQuery: ''
    };
    $scope.loadingMessage = loadingMessage;
    $scope.component = mmaModGlossaryComponent;
    $scope.componentId = module.id;
    $scope.moduleName = $mmCourse.translateModuleName('glossary');
    $scope.offlineEntries = [];
    function fetchGlossary(refresh, sync, showErrors) {
        $scope.isOnline = $mmApp.isOnline();
        return $mmaModGlossary.getGlossary(courseId, module.id).then(function(mod) {
            glossary = mod;
            $scope.description = glossary.intro || module.description;
            $scope.canAdd = ($mmaModGlossary.isPluginEnabledForEditing() && glossary.canaddentry) || false;
            var browseModes = [
                    {key: 'search', langkey: 'mma.mod_glossary.bysearch'}
                ];
            angular.forEach(glossary.browsemodes, function(mode) {
                switch (mode) {
                    case 'letter' :
                        browseModes.push({key: 'letter_all', langkey: 'mma.mod_glossary.byalphabet'});
                        break;
                    case 'cat' :
                        browseModes.push({key: 'cat_all', langkey: 'mma.mod_glossary.bycategory'});
                        break;
                    case 'date' :
                        browseModes.push({key: 'newest_first', langkey: 'mma.mod_glossary.bynewestfirst'});
                        browseModes.push({key: 'recently_updated', langkey: 'mma.mod_glossary.byrecentlyupdated'});
                        break;
                    case 'author' :
                        browseModes.push({key: 'author_all', langkey: 'mma.mod_glossary.byauthor'});
                        break;
                }
            });
            if (!popoverScope) {
                initSortMenu();
            }
            popoverScope.modes = browseModes;
            if (sync) {
                return syncGlossary(showErrors).catch(function() {
                });
            }
        }).then(function() {
            return fetchEntries().then(function() {
                $mmCourseHelper.fillContextMenu($scope, module, courseId, false, mmaModGlossaryComponent);
                return $mmaModGlossaryOffline.getGlossaryAddEntries(glossary.id).then(function(offlineEntries) {
                    $scope.hasOffline = !!offlineEntries.length;
                    if ($scope.hasOffline) {
                        $scope.offlineEntries = offlineEntries;
                        $scope.showNoEntries = ($scope.entries.length + offlineEntries.length) <= 0;
                    } else {
                        $scope.offlineEntries = [];
                    }
                });
            });
        }).catch(function(error) {
            if (!refresh) {
                return refreshData(sync);
            }
            $mmUtil.showErrorModalDefault(error, 'mma.mod_glossary.errorloadingglossary', true);
            $scope.canLoadMore = false;
            return $q.reject();
        }).finally(function() {
            $scope.loaded = true;
            $scope.refreshIcon = 'ion-refresh';
            $scope.syncIcon = 'ion-loop';
        });
    }
    function syncGlossary(showErrors) {
        return $mmaModGlossarySync.syncGlossaryEntries(glossary.id).then(function(result) {
            if (result.warnings && result.warnings.length) {
                $mmUtil.showErrorModal(result.warnings[0]);
            }
            return result.updated;
        }).catch(function(error) {
            if (showErrors) {
                $mmUtil.showErrorModalDefault(error, 'mm.core.errorsync', true);
            }
            return $q.reject();
        });
    }
    $scope.loadMoreEntries = function() {
        loadMoreEntries().finally(function() {
            $scope.$broadcast('scroll.infiniteScrollComplete');
        });
    };
    function refreshData(sync, showErrors) {
        var promises = [];
        if (fetchMode != 'search' || $scope.searchQuery) {
            var args = angular.extend([], fetchArguments);
            promises.push(fetchInvalidate.apply(this, args));
            promises.push($mmaModGlossary.invalidateCourseGlossaries(courseId));
        }
        if (glossary && glossary.id) {
            promises.push($mmaModGlossary.invalidateCategories(glossary.id));
        }
        return $q.all(promises).then(function() {
            limitFrom = 0;
            return fetchGlossary(true, sync, showErrors);
        });
    }
    $scope.refreshEntries = function(showErrors) {
        return showSpinnerAndFetch(true, showErrors);
    };
    function showSpinnerAndFetch(sync, showErrors, onlyFetch) {
        $scope.refreshIcon = 'spinner';
        $scope.syncIcon = 'spinner';
        var promise;
        if (onlyFetch) {
            limitFrom = 0;
            promise = fetchGlossary(true, sync, showErrors);
        } else {
            promise = refreshData(sync, showErrors);
        }
        return promise.finally(function() {
            $scope.loaded = true;
            $scope.refreshIcon = 'ion-refresh';
            $scope.syncIcon = 'ion-loop';
            $scope.$broadcast('scroll.refreshComplete');
        });
    }
    $scope.pickMode = function(e) {
        popover.show(e);
    };
    $scope.search = function(query) {
        $scope.loadingMessage = searchingMessage;
        fetchArguments = [glossary.id, query, 1, 'CONCEPT', 'ASC'];
        $scope.loaded = false;
        showSpinnerAndFetch(false, false, true);
    };
    $scope.removeFiles = function() {
        $mmCourseHelper.confirmAndRemove(module, courseId);
    };
    $scope.prefetch = function() {
        $mmCourseHelper.contextMenuPrefetch($scope, module, courseId);
    };
    $scope.expandDescription = function() {
        $mmText.expandText($translate.instant('mm.core.description'), $scope.description, false,
                mmaModGlossaryComponent, module.id);
    };
    $scope.gotoAddEntry = function() {
        if ($scope.canAdd) {
            var stateParams = {
                module: module,
                cmid: module.id,
                glossary: glossary,
                glossaryid: glossary.id,
                courseid: courseId
            };
            return $state.go('site.mod_glossary-edit', stateParams);
        }
    };
    $scope.gotoEditEntry = function(entry) {
        if ($scope.canAdd) {
            var stateParams = {
                module: module,
                cmid: module.id,
                glossary: glossary,
                glossaryid: glossary.id,
                courseid: courseId,
                entry: entry
            };
            return $state.go('site.mod_glossary-edit', stateParams);
        }
    };
    function eventReceived(data) {
        if ((glossary && glossary.id === data.glossaryid) || data.cmid === module.id) {
            $scope.loaded = false;
            showSpinnerAndFetch(false);
            $mmCourse.checkModuleCompletion(courseId, module.completionstatus);
        }
    }
    fetchGlossary(false, true).then(function() {
        $mmaModGlossary.logView(glossary.id, viewMode).then(function() {
            $mmCourse.checkModuleCompletion(courseId, module.completionstatus);
        });
    }).finally(function() {
        $scope.refreshIcon = 'ion-refresh';
        $scope.syncIcon = 'ion-loop';
        $scope.loaded = true;
    });
    obsAddEntry = $mmEvents.on(mmaModGlossaryAddEntryEvent, eventReceived);
    onlineObserver = $mmEvents.on(mmCoreEventOnlineStatusChanged, function(online) {
        $scope.isOnline = online;
    });
    syncObserver = $mmEvents.on(mmaModGlossaryAutomSyncedEvent, function(data) {
        if (glossary && data && data.siteid == $mmSite.getId() && data.glossaryid == glossary.id &&
                data.userid == $mmSite.getUserId()) {
            $scope.loaded = false;
            return showSpinnerAndFetch(false);
        }
    });
    function initSortMenu() {
        switchMode('letter_all');
        popoverScope = $scope.$new(true);
        popoverScope.data = { selectedMode: fetchMode };
        popoverScope.modePicked = function(mode) {
            $scope.loadingMessage = loadingMessage;
            $ionicScrollDelegate.$getByHandle('mmaModGlossaryIndex').scrollTop(false);
            if (switchMode(mode)) {
                $scope.loaded = false;
                showSpinnerAndFetch(false, false, true);
            } else {
                $scope.loaded = true;
                $scope.refreshIcon = 'ion-refresh';
                $scope.syncIcon = 'ion-loop';
                $scope.entries = [];
                $scope.canLoadMore = false;
                $scope.showNoEntries = false;
            }
            popoverScope.data.selectedMode = fetchMode;
            popover.hide();
        };
        return $ionicPopover.fromTemplateUrl('addons/mod/glossary/templates/mode_picker.html', {
            scope: popoverScope
        }).then(function(po) {
            popover = po;
            $scope.sortMenuInit = true;
        });
    }
    function fetchEntries(append) {
        if (!append) {
            limitFrom = 0;
        }
        var args = angular.extend([], fetchArguments);
        args.push(limitFrom);
        args.push(limitNum);
        return fetchFunction.apply(this, args).then(function(result) {
            if (append) {
                $scope.entries = $scope.entries.concat(result.entries);
            } else {
                $scope.entries = result.entries;
            }
            $scope.canLoadMore = (limitFrom + limitNum) < result.count;
            $scope.showNoEntries = ($scope.entries.length + $scope.offlineEntries.length) <= 0;
        }).catch(function() {
            if (append) {
                $mmUtil.showErrorModal('mma.mod_glossary.errorloadingentries', true);
            }
            $scope.canLoadMore = false;
            return $q.reject();
        });
    }
    function loadMoreEntries() {
        limitFrom += limitNum;
        return fetchEntries(true);
    }
    function switchMode(mode) {
        if (mode == fetchMode) {
            return false;
        }
        var instantFetch = true;
        fetchMode = mode;
        $scope.isSearch = false;
        switch (mode) {
            case 'author_all':
                viewMode = 'author';
                fetchFunction = $mmaModGlossary.getEntriesByAuthor;
                fetchInvalidate = $mmaModGlossary.invalidateEntriesByAuthor;
                fetchArguments = [glossary.id, 'ALL', 'LASTNAME', 'ASC'];
                $scope.getDivider = function(entry) {
                    return entry.userfullname;
                };
                $scope.showDivider = function(entry, previous) {
                    if (typeof previous === 'undefined') {
                        return true;
                    }
                    return entry.userid != previous.userid;
                };
                break;
            case 'cat_all':
                viewMode = 'cat';
                fetchFunction = $mmaModGlossary.getEntriesByCategory;
                fetchInvalidate = $mmaModGlossary.invalidateEntriesByCategory;
                fetchArguments = [glossary.id, mmaModGlossaryShowAllCategories];
                $scope.getDivider = function(entry) {
                    return entry.categoryname;
                };
                $scope.showDivider = function(entry, previous) {
                    if (typeof previous === 'undefined') {
                        return true;
                    }
                    return $scope.getDivider(entry) != $scope.getDivider(previous);
                };
                break;
            case 'newest_first':
                viewMode = 'date';
                fetchFunction = $mmaModGlossary.getEntriesByDate;
                fetchInvalidate = $mmaModGlossary.invalidateEntriesByDate;
                fetchArguments = [glossary.id, 'CREATION', 'DESC'];
                $scope.getDivider = noop;
                $scope.showDivider = function() { return false; };
                break;
            case 'recently_updated':
                viewMode = 'date';
                fetchFunction = $mmaModGlossary.getEntriesByDate;
                fetchInvalidate = $mmaModGlossary.invalidateEntriesByDate;
                fetchArguments = [glossary.id, 'UPDATE', 'DESC'];
                $scope.getDivider = noop;
                $scope.showDivider = function() { return false; };
                break;
            case 'search':
                viewMode = 'search';
                fetchFunction = $mmaModGlossary.getEntriesBySearch;
                fetchInvalidate = $mmaModGlossary.invalidateEntriesBySearch;
                fetchArguments = false;
                $scope.isSearch = true;
                $scope.getDivider = noop;
                $scope.showDivider = function() { return false; };
                instantFetch = false;
                break;
            case 'letter_all':
            default:
                viewMode = 'letter';
                fetchMode = 'letter_all';
                fetchFunction = $mmaModGlossary.getEntriesByLetter;
                fetchInvalidate = $mmaModGlossary.invalidateEntriesByLetter;
                fetchArguments = [glossary.id, 'ALL'];
                $scope.getDivider = function(entry) {
                    return entry.concept.substr(0, 1).toUpperCase();
                };
                $scope.showDivider = function(entry, previous) {
                    if (typeof previous === 'undefined') {
                        return true;
                    }
                    return $scope.getDivider(entry) != $scope.getDivider(previous);
                };
                break;
            }
        return instantFetch;
    }
    $scope.$on('$destroy', function() {
        obsAddEntry && obsAddEntry.off && obsAddEntry.off();
        onlineObserver && onlineObserver.off && onlineObserver.off();
        syncObserver && syncObserver.off && syncObserver.off();
        if (popover && popoverScope) {
            popover.remove();
            popoverScope.$destroy();
        }
    });
}]);

angular.module('mm.addons.mod_glossary')
.factory('$mmaModGlossary', ["$mmSite", "$q", "$mmSitesManager", "$mmFilepool", "mmaModGlossaryComponent", "$mmaModGlossaryOffline", "mmaModGlossaryLimitEntriesNum", "$mmApp", "$mmUtil", "mmaModGlossaryLimitCategoriesNum", "$mmText", "$mmLang", "mmaModGlossaryShowAllCategories", function($mmSite, $q, $mmSitesManager, $mmFilepool, mmaModGlossaryComponent, $mmaModGlossaryOffline,
        mmaModGlossaryLimitEntriesNum, $mmApp, $mmUtil, mmaModGlossaryLimitCategoriesNum, $mmText, $mmLang,
        mmaModGlossaryShowAllCategories) {
    var self = {};
        self._getCourseGlossariesCacheKey = function(courseId) {
        return 'mmaModGlossary:courseGlossaries:' + courseId;
    };
        self.getCourseGlossaries = function(courseId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    courseids: [courseId]
                },
                preSets = {
                    cacheKey: self._getCourseGlossariesCacheKey(courseId)
                };
            return site.read('mod_glossary_get_glossaries_by_courses', params, preSets).then(function(result) {
                return result.glossaries;
            });
        });
    };
        self.invalidateCourseGlossaries = function(courseId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var key = self._getCourseGlossariesCacheKey(courseId);
            return site.invalidateWsCacheForKey(key);
        });
    };
        self._getEntriesByAuthorCacheKey = function(glossaryId, letter, field, sort) {
        return 'mmaModGlossary:entriesByAuthor:' + glossaryId + ":" + letter + ":" + field + ":" + sort;
    };
        self.getEntriesByAuthor = function(glossaryId, letter, field, sort, from, limit, forceCache, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    id: glossaryId,
                    letter: letter,
                    field: field,
                    sort: sort,
                    from: from,
                    limit: limit
                },
                preSets = {
                    cacheKey: self._getEntriesByAuthorCacheKey(glossaryId, letter, field, sort)
                };
            if (forceCache) {
                preSets.omitExpires = true;
            }
            return site.read('mod_glossary_get_entries_by_author', params, preSets);
        });
    };
        self.invalidateEntriesByAuthor = function(glossaryId, letter, field, sort, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var key = self._getEntriesByAuthorCacheKey(glossaryId, letter, field, sort);
            return site.invalidateWsCacheForKey(key);
        });
    };
        self.getEntriesByCategory = function(glossaryId, categoryId, from, limit, forceCache, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    id: glossaryId,
                    categoryid: categoryId,
                    from: from,
                    limit: limit
                },
                preSets = {
                    cacheKey: self._getEntriesByCategoryCacheKey(glossaryId, categoryId)
                };
            if (forceCache) {
                preSets.omitExpires = true;
            }
            return site.read('mod_glossary_get_entries_by_category', params, preSets);
        });
    };
        self.invalidateEntriesByCategory = function(glossaryId, categoryId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var key = self._getEntriesByCategoryCacheKey(glossaryId, categoryId);
            return site.invalidateWsCacheForKey(key);
        });
    };
        self._getEntriesByCategoryCacheKey = function(glossaryId, categoryId) {
        return 'mmaModGlossary:entriesByCategory:' + glossaryId + ":" + categoryId;
    };
        self._getEntriesByDateCacheKey = function(glossaryId, order, sort) {
        return 'mmaModGlossary:entriesByDate:' + glossaryId + ":" + order + ":" + sort;
    };
        self.getEntriesByDate = function(glossaryId, order, sort, from, limit, forceCache, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    id: glossaryId,
                    order: order,
                    sort: sort,
                    from: from,
                    limit: limit
                },
                preSets = {
                    cacheKey: self._getEntriesByDateCacheKey(glossaryId, order, sort)
                };
            if (forceCache) {
                preSets.omitExpires = true;
            }
            return site.read('mod_glossary_get_entries_by_date', params, preSets);
        });
    };
        self.invalidateEntriesByDate = function(glossaryId, order, sort, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var key = self._getEntriesByDateCacheKey(glossaryId, order, sort);
            return site.invalidateWsCacheForKey(key);
        });
    };
        self._getEntriesByLetterCacheKey = function(glossaryId, letter) {
        return 'mmaModGlossary:entriesByLetter:' + glossaryId + ":" + letter;
    };
        self.getEntriesByLetter = function(glossaryId, letter, from, limit, forceCache, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    id: glossaryId,
                    letter: letter,
                    from: from,
                    limit: limit
                },
                preSets = {
                    cacheKey: self._getEntriesByLetterCacheKey(glossaryId, letter)
                };
            if (forceCache) {
                preSets.omitExpires = true;
            }
            return site.read('mod_glossary_get_entries_by_letter', params, preSets);
        });
    };
        self.invalidateEntriesByLetter = function(glossaryId, letter, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var key = self._getEntriesByLetterCacheKey(glossaryId, letter);
            return site.invalidateWsCacheForKey(key);
        });
    };
        self._getEntriesBySearchCacheKey = function(glossaryId, query, fullsearch, order, sort) {
        return 'mmaModGlossary:entriesBySearch:' + glossaryId + ":" + fullsearch + ":" + order + ":" + sort + ":" + query;
    };
        self.getEntriesBySearch = function(glossaryId, query, fullsearch, order, sort, from, limit, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    id: glossaryId,
                    query: query,
                    fullsearch: fullsearch,
                    order: order,
                    sort: sort,
                    from: from,
                    limit: limit
                },
                preSets = {
                    cacheKey: self._getEntriesBySearchCacheKey(glossaryId, query, fullsearch, order, sort)
                };
            return site.read('mod_glossary_get_entries_by_search', params, preSets);
        });
    };
        self.invalidateEntriesBySearch = function(glossaryId, query, fullsearch, order, sort, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var key = self._getEntriesBySearchCacheKey(glossaryId, query, fullsearch, order, sort);
            return site.invalidateWsCacheForKey(key);
        });
    };
        function getCategoriesCacheKey(glossaryId) {
        return 'mmaModGlossary:categories:' + glossaryId;
    }
        self.getAllCategories = function(glossaryId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return getCategories(glossaryId, 0, mmaModGlossaryLimitCategoriesNum, [], site);
        });
    };
        function getCategories(glossaryId, from, limit, categories, site) {
        var params = {
                id: glossaryId,
                from: from,
                limit: limit
            },
            preSets = {
                cacheKey: getCategoriesCacheKey(glossaryId)
            };
        return site.read('mod_glossary_get_categories', params, preSets).then(function(response) {
            categories = categories.concat(response.categories);
            canLoadMore = (from + limit) < response.count;
            if (canLoadMore) {
                from += limit;
                return getCategories(glossaryId, from, limit, categories, site);
            }
            return categories;
        });
    }
        self.invalidateCategories = function(glossaryId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getCategoriesCacheKey(glossaryId));
        });
    };
        self._getEntryCacheKey = function(entryId) {
        return 'mmaModGlossary:getEntry:' + entryId;
    };
        self.getEntry = function(entryId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    id: entryId
                },
                preSets = {
                    cacheKey: self._getEntryCacheKey(entryId)
                };
            return site.read('mod_glossary_get_entry_by_id', params, preSets).then(function(response) {
                if (response && response.entry) {
                    return response.entry;
                } else {
                    return $q.reject();
                }
            });
        });
    };
        self.fetchAllEntries = function(fetchFunction, fetchArguments, forceCache, entries, limitFrom, siteId) {
        var limitNum = mmaModGlossaryLimitEntriesNum;
        siteId = siteId || $mmSite.getId();
        if (typeof limitFrom == 'undefined' || typeof entries == 'undefined') {
            limitFrom = 0;
            entries = [];
        }
        var args = angular.extend([], fetchArguments);
        args.push(limitFrom);
        args.push(limitNum);
        args.push(siteId);
        return fetchFunction.apply(this, args).then(function(result) {
            entries = entries.concat(result.entries);
            canLoadMore = (limitFrom + limitNum) < result.count;
            if (canLoadMore) {
                limitFrom += limitNum;
                return self.fetchAllEntries(fetchFunction, fetchArguments, forceCache, entries, limitFrom, siteId);
            }
            return entries;
        });
    };
        self.invalidateEntry = function(entryId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(self._getEntryCacheKey(entryId));
        });
    };
        function invalidateEntries(entries, siteId) {
        var keys = [];
        angular.forEach(entries, function(entry) {
            keys.push(self._getEntryCacheKey(entry.id));
        });
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateMultipleWsCacheForKey(keys);
        });
    }
         self.invalidateContent = function(moduleId, courseId) {
        return self.getGlossary(courseId, moduleId).then(function(glossary) {
            return self.invalidateGlossaryEntries(glossary).finally(function() {
                var promises = [];
                promises.push(self.invalidateCourseGlossaries(courseId));
                promises.push(self.invalidateCategories(glossary.id));
                return $q.all(promises);
            });
        });
    };
        self.invalidateGlossaryEntries = function(glossary, onlyEntriesList) {
        var promises = [];
        if (!onlyEntriesList) {
            promises.push(self.fetchAllEntries(self.getEntriesByLetter, [glossary.id, 'ALL'], true).then(function(entries) {
                return invalidateEntries(entries);
            }));
        }
        angular.forEach(glossary.browsemodes, function(mode) {
            switch(mode) {
                case 'letter':
                    promises.push(self.invalidateEntriesByLetter(glossary.id, 'ALL'));
                    break;
                case 'cat':
                    promises.push(self.invalidateEntriesByCategory(glossary.id, mmaModGlossaryShowAllCategories));
                    break;
                case 'date':
                    promises.push(self.invalidateEntriesByDate(glossary.id, 'CREATION', 'DESC'));
                    promises.push(self.invalidateEntriesByDate(glossary.id, 'UPDATE', 'DESC'));
                    break;
                case 'author':
                    promises.push(self.invalidateEntriesByAuthor(glossary.id, 'ALL', 'LASTNAME', 'ASC'));
                    break;
            }
        });
        return $q.all(promises);
    };
         self.invalidateFiles = function(moduleId, siteId) {
         return $mmFilepool.invalidateFilesByComponent(siteId, mmaModGlossaryComponent, moduleId);
     };
        self.getGlossary = function(courseId, cmId, siteId) {
        return self.getCourseGlossaries(courseId, siteId).then(function(glossaries) {
            var result = $q.reject();
            angular.forEach(glossaries, function(glossary) {
                if (glossary.coursemodule == cmId) {
                    result = glossary;
                }
            });
            return result;
        });
    };
        self.getGlossaryById = function(courseId, glossaryId, siteId) {
        return self.getCourseGlossaries(courseId, siteId).then(function(glossaries) {
            var result = $q.reject();
            angular.forEach(glossaries, function(glossary) {
                if (glossary.id == glossaryId) {
                    result = glossary;
                }
            });
            return result;
        });
    };
        self.addEntry = function(glossaryId, concept, definition, courseId, options, attach, timecreated, siteId, discardEntry,
            allowOffline, checkDuplicates) {
        siteId = siteId || $mmSite.getId();
        if (!$mmApp.isOnline() && allowOffline) {
            return storeOffline();
        }
        var discardPromise = discardEntry ?
            $mmaModGlossaryOffline.deleteAddEntry(glossaryId, discardEntry.concept, discardEntry.timecreated, siteId) : $q.when();
        return discardPromise.then(function() {
            return self.addEntryOnline(glossaryId, concept, definition, options, attach, siteId).then(function(entryId) {
                return entryId;
            }).catch(function(error) {
                if (allowOffline && error && !error.wserror) {
                    return storeOffline();
                } else {
                    return $q.reject(error.error);
                }
            });
        });
        function storeOffline() {
            var discardTime = discardEntry && discardEntry.timecreated,
                duplicatesPromise = checkDuplicates ? self.isConceptUsed(glossaryId, concept, discardTime, siteId) : $q.when(false);
            return duplicatesPromise.then(function(used) {
                if (used) {
                    return $mmLang.translateAndReject('mma.mod_glossary.errconceptalreadyexists');
                }
                return $mmaModGlossaryOffline.saveAddEntry(glossaryId, concept, definition, courseId, options, attach, timecreated,
                        siteId, undefined, discardEntry).then(function() {
                    return false;
                });
            });
        }
    };
        self.addEntryOnline = function(glossaryId, concept, definition, options, attachId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    glossaryid: glossaryId,
                    concept: concept,
                    definition: definition,
                    definitionformat: 1
                };
            if (options) {
                params.options = $mmUtil.objectToArrayOfObjects(options, 'name', 'value');
            }
            if (attachId) {
                params.options.push({
                    name: 'attachmentsid',
                    value: attachId
                });
            }
            return addEntryOnline(site, params).then(function(response) {
                if (response.entryid) {
                    return response.entryid;
                }
                return $q.reject({
                    wserror: true
                });
            });
        });
        function addEntryOnline(site, params) {
            return site.write('mod_glossary_add_entry', params).catch(function(error) {
                var wserror = $mmUtil.isWebServiceError(error);
                if (wserror && error == "Invalid parameter value detected") {
                    var definition = $mmText.cleanTags(params.definition);
                    if (definition != params.definition) {
                        params.definition = definition;
                        return addEntryOnline(site, params);
                    }
                }
                return $q.reject({
                    error: error,
                    wserror: wserror
                });
            });
        }
    };
        self.isConceptUsed = function(glossaryId, concept, timecreated, siteId) {
        return $mmaModGlossaryOffline.isConceptUsed(glossaryId, concept, timecreated, siteId).then(function(exists) {
            if (exists) {
                return true;
            }
            return self.fetchAllEntries(self.getEntriesByLetter, [glossaryId, 'ALL'], true, undefined, undefined, siteId)
                    .then(function(entries) {
                for (var i = 0, len = entries.length; i < len; i++) {
                    if (entries[i].concept == concept) {
                        return true;
                    }
                }
                return false;
            });
        }).catch(function() {
            return false;
        });
    };
        self.isPluginEnabled = function(siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.wsAvailable('mod_glossary_get_glossaries_by_courses');
        });
    };
        self.isPluginEnabledForEditing = function() {
        return  $mmSite.wsAvailable('mod_glossary_add_entry');
    };
        self.logView = function(glossaryId, mode) {
        var params = {
            id: glossaryId,
            mode: mode
        };
        return $mmSite.write('mod_glossary_view_glossary', params);
    };
        self.logEntryView = function(entryId) {
        var params = {
            id: entryId
        };
        return $mmSite.write('mod_glossary_view_entry', params);
    };
    return self;
}]);

angular.module('mm.addons.mod_glossary')
.constant('mmaModGlossaryAddEntryStore', 'mma_mod_glossary_add_entry')
.config(["$mmSitesFactoryProvider", "mmaModGlossaryAddEntryStore", function($mmSitesFactoryProvider, mmaModGlossaryAddEntryStore) {
    var stores = [
        {
            name: mmaModGlossaryAddEntryStore,
            keyPath: ['glossaryid', 'concept', 'timecreated'],
            indexes: [
                {
                    name: 'glossaryid'
                },
                {
                    name: 'concept'
                },
                {
                    name: 'userid'
                },
                {
                    name: 'glossaryAndConcept',
                    keyPath: ['glossaryid', 'concept']
                },
                {
                    name: 'glossaryAndUser',
                    keyPath: ['glossaryid', 'userid']
                }
            ]
        }
    ];
    $mmSitesFactoryProvider.registerStores(stores);
}])
.factory('$mmaModGlossaryOffline', ["$mmSitesManager", "$log", "mmaModGlossaryAddEntryStore", "$mmFS", "$q", "$mmUtil", function($mmSitesManager, $log, mmaModGlossaryAddEntryStore, $mmFS, $q, $mmUtil) {
    $log = $log.getInstance('$mmaModGlossaryOffline');
    var self = {};
        self.deleteAddEntry = function(glossaryId, concept, timecreated, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.getDb().remove(mmaModGlossaryAddEntryStore, [glossaryId, concept, timecreated]);
        });
    };
        self.getAllAddEntries = function(siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.getDb().getAll(mmaModGlossaryAddEntryStore);
        });
    };
        self.getAddEntry = function(glossaryId, concept, timecreated, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.getDb().get(mmaModGlossaryAddEntryStore, [glossaryId, concept, timecreated]);
        });
    };
        self.getGlossaryAddEntries = function(glossaryId, siteId, userId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            return site.getDb().whereEqual(mmaModGlossaryAddEntryStore, 'glossaryAndUser', [glossaryId, userId]);
        });
    };
        self.isConceptUsed = function(glossaryId, concept, timecreated, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.getDb().whereEqual(mmaModGlossaryAddEntryStore, 'glossaryAndConcept', [glossaryId, concept])
                    .then(function(entries) {
                if (!!entries.length) {
                    if (entries.length > 1 || !timecreated) {
                        return true;
                    }
                    return $mmUtil.promiseFails(self.getAddEntry(glossaryId, concept, timecreated, siteId));
                }
                return false;
            });
        }).catch(function() {
            return false;
        });
    };
        self.saveAddEntry = function(glossaryId, concept, definition, courseId, options, attach, timecreated, siteId, userId,
            discardEntry) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            var entry = {
                    glossaryid: glossaryId,
                    courseid: courseId,
                    concept: concept,
                    definition: definition,
                    definitionformat: 'html',
                    options: options,
                    userid: userId,
                    timecreated: timecreated || new Date().getTime()
                };
            if (attach) {
                entry.attachments = attach;
            }
            var discardPromise = discardEntry ?
                self.deleteAddEntry(glossaryId, discardEntry.concept, discardEntry.timecreated, site.getId()) : $q.when();
            return discardPromise.then(function() {
                return site.getDb().insert(mmaModGlossaryAddEntryStore, entry);
            });
        });
    };
        self.getGlossaryFolder = function(glossaryId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var siteFolderPath = $mmFS.getSiteFolder(site.getId()),
                folderPath = 'offlineglossary/' + glossaryId;
            return $mmFS.concatenatePaths(siteFolderPath, folderPath);
        });
    };
        self.getEntryFolder = function(glossaryId, entryName, timecreated, siteId) {
        return self.getGlossaryFolder(glossaryId, siteId).then(function(folderPath) {
            return $mmFS.concatenatePaths(folderPath, 'newentry_' + entryName + '_' + timecreated);
        });
    };
    return self;
}]);

angular.module('mm.addons.mod_glossary')
.factory('$mmaModGlossarySync', ["$q", "$log", "$mmApp", "$mmSitesManager", "$mmaModGlossaryOffline", "$mmSite", "$mmEvents", "$mmSync", "$mmLang", "mmaModGlossaryComponent", "$mmaModGlossary", "$translate", "mmaModGlossaryAutomSyncedEvent", "mmaModGlossarySyncTime", "$mmCourse", "$mmSyncBlock", "$mmUtil", "$mmaModGlossaryHelper", "$mmFileUploader", function($q, $log, $mmApp, $mmSitesManager, $mmaModGlossaryOffline, $mmSite, $mmEvents, $mmSync,
        $mmLang, mmaModGlossaryComponent, $mmaModGlossary, $translate, mmaModGlossaryAutomSyncedEvent, mmaModGlossarySyncTime,
        $mmCourse, $mmSyncBlock, $mmUtil, $mmaModGlossaryHelper, $mmFileUploader) {
    $log = $log.getInstance('$mmaModGlossarySync');
    var self = $mmSync.createChild(mmaModGlossaryComponent, mmaModGlossarySyncTime);
        self.syncAllGlossaries = function(siteId) {
        if (!$mmApp.isOnline()) {
            $log.debug('Cannot sync all glossaries because device is offline.');
            return $q.reject();
        }
        var promise;
        if (!siteId) {
            $log.debug('Try to sync glossaries in all sites.');
            promise = $mmSitesManager.getSitesIds();
        } else {
            $log.debug('Try to sync glossaries in site ' + siteId);
            promise = $q.when([siteId]);
        }
        return promise.then(function(siteIds) {
            var sitePromises = [];
            angular.forEach(siteIds, function(siteId) {
                sitePromises.push($mmaModGlossaryOffline.getAllAddEntries(siteId).then(function(entries) {
                    var promises = {};
                    for (var i in entries) {
                        var entry = entries[i];
                        if (typeof promises[entry.glossaryid] != 'undefined') {
                            continue;
                        }
                        promises[entry.glossaryid] = self.syncGlossaryEntriesIfNeeded(entry.glossaryid, entry.userid, siteId)
                                .then(function(result) {
                            if (result && result.updated) {
                                $mmEvents.trigger(mmaModGlossaryAutomSyncedEvent, {
                                    siteid: siteId,
                                    glossaryid: entry.glossaryid,
                                    userid: entry.userid,
                                    warnings: result.warnings
                                });
                            }
                        });
                    }
                    promises = $mmUtil.objectToArray(promises);
                    return $q.all(promises);
                }));
            });
            return $q.all(sitePromises);
        });
    };
        self.syncGlossaryEntriesIfNeeded = function(glossaryId, userId, siteId) {
        siteId = siteId || $mmSite.getId();
        var syncId = self.getGlossarySyncId(glossaryId, userId);
        return self.isSyncNeeded(syncId, siteId).then(function(needed) {
            if (needed) {
                return self.syncGlossaryEntries(glossaryId, userId, siteId);
            }
        });
    };
        self.syncGlossaryEntries = function(glossaryId, userId, siteId) {
        userId = userId || $mmSite.getUserId();
        siteId = siteId || $mmSite.getId();
        var syncPromise,
            courseId,
            syncId = self.getGlossarySyncId(glossaryId, userId),
            result = {
                warnings: [],
                updated: false
            };
        if (self.isSyncing(syncId, siteId)) {
            return self.getOngoingSync(syncId, siteId);
        }
        if ($mmSyncBlock.isBlocked(mmaModGlossaryComponent, syncId, siteId)) {
            $log.debug('Cannot sync glossary ' + glossaryId + ' because it is blocked.');
            var modulename = $mmCourse.translateModuleName('glossary');
            return $mmLang.translateAndReject('mm.core.errorsyncblocked', {$a: modulename});
        }
        $log.debug('Try to sync glossary ' + glossaryId + ' for user ' + userId);
        syncPromise = $mmaModGlossaryOffline.getGlossaryAddEntries(glossaryId, siteId, userId).catch(function() {
            return [];
        }).then(function(entries) {
            if (!entries.length) {
                return;
            } else if (!$mmApp.isOnline()) {
                return $q.reject();
            }
            var promises = [];
            angular.forEach(entries, function(data) {
                var promise;
                courseId = data.courseid;
                promise = uploadAttachments(glossaryId, data, siteId).then(function(itemId) {
                    return $mmaModGlossary.addEntryOnline(glossaryId, data.concept, data.definition, data.options, itemId, siteId);
                });
                promises.push(promise.then(function() {
                    result.updated = true;
                    return deleteAddEntry(glossaryId, data.concept, data.timecreated, siteId);
                }).catch(function(error) {
                    if (error && error.wserror) {
                        result.updated = true;
                        return deleteAddEntry(glossaryId, data.concept, data.timecreated, siteId).then(function() {
                            result.warnings.push($translate.instant('mm.core.warningofflinedatadeleted', {
                                component: $mmCourse.translateModuleName('glossary'),
                                name: data.concept,
                                error: error.error
                            }));
                        });
                    } else {
                        return $q.reject(error && error.error);
                    }
                }));
            });
            return $q.all(promises);
        }).then(function() {
            if (result.updated && courseId) {
                return $mmaModGlossary.getGlossaryById(courseId, glossaryId).then(function(glossary) {
                    return $mmaModGlossary.invalidateGlossaryEntries(glossary, true);
                }).catch(function() {
                });
            }
        }).then(function() {
            return self.setSyncTime(syncId, siteId).catch(function() {
            });
        }).then(function() {
            return result;
        });
        return self.addOngoingSync(syncId, syncPromise, siteId);
    };
         function deleteAddEntry(glossaryId, concept, timecreated, siteId) {
        var promises = [];
        promises.push($mmaModGlossaryOffline.deleteAddEntry(glossaryId, concept, timecreated, siteId));
        promises.push($mmaModGlossaryHelper.deleteStoredFiles(glossaryId, concept, timecreated, siteId).catch(function() {
        }));
        return $q.all(promises);
    }
        function uploadAttachments(glossaryId, entry, siteId) {
        var attachments = entry && entry.attachments;
        if (attachments) {
            var files = attachments.online || [],
                promise;
            if (attachments.offline) {
                promise = $mmaModGlossaryHelper.getStoredFiles(glossaryId, entry.concept, entry.timecreated, siteId).then(function(atts) {
                    files = files.concat(atts);
                }).catch(function() {
                });
            } else {
                promise = $q.when();
            }
            return promise.then(function() {
                return $mmFileUploader.uploadOrReuploadFiles(files, mmaModGlossaryComponent, glossaryId, siteId);
            });
        }
        return $q.when();
    }
        self.getGlossarySyncId = function(glossaryId, userId) {
        userId = userId || $mmSite.getUserId();
        return 'glossary#' + glossaryId + '#' + userId;
    };
    return self;
}]);

angular.module('mm.addons.mod_glossary')
.factory('$mmaModGlossaryHandlers', ["$mmCourse", "$mmaModGlossary", "$state", "$q", "$mmContentLinksHelper", "$mmUtil", "$mmEvents", "$mmCourseHelper", "$mmaModGlossaryPrefetchHandler", "mmaModGlossaryComponent", "mmCoreEventPackageStatusChanged", "$mmCoursePrefetchDelegate", "mmCoreDownloading", "mmCoreDownloaded", "mmCoreNotDownloaded", "mmCoreOutdated", "$mmSite", "$mmaModGlossarySync", "$mmContentLinkHandlerFactory", function($mmCourse, $mmaModGlossary, $state, $q, $mmContentLinksHelper, $mmUtil, $mmEvents,
            $mmCourseHelper, $mmaModGlossaryPrefetchHandler, mmaModGlossaryComponent, mmCoreEventPackageStatusChanged,
            $mmCoursePrefetchDelegate, mmCoreDownloading, mmCoreDownloaded, mmCoreNotDownloaded, mmCoreOutdated, $mmSite,
            $mmaModGlossarySync, $mmContentLinkHandlerFactory) {
    var self = {};
        self.courseContent = function() {
        var self = {};
                self.isEnabled = function() {
            return $mmaModGlossary.isPluginEnabled();
        };
                self.getController = function(module, courseId) {
            return function($scope) {
                var downloadBtn = {
                        hidden: true,
                        icon: 'ion-ios-cloud-download-outline',
                        label: 'mm.core.download',
                        action: function(e) {
                            if (e) {
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            download();
                        }
                    },
                    refreshBtn = {
                        hidden: true,
                        icon: 'ion-android-refresh',
                        label: 'mm.core.refresh',
                        action: function(e) {
                            if (e) {
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            $scope.spinner = true;
                            $mmaModGlossary.invalidateContent(module.id, courseId).finally(function() {
                                download();
                            });
                        }
                    };
                $scope.title = module.name;
                $scope.icon = $mmCourse.getModuleIconSrc('glossary');
                $scope.class = 'mma-mod_glossary-handler';
                $scope.buttons = [downloadBtn, refreshBtn];
                $scope.spinner = true;
                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_glossary', {module: module, courseid: courseId});
                };
                function download() {
                    $scope.spinner = true;
                    $mmaModGlossaryPrefetchHandler.getDownloadSize(module, courseId).then(function(size) {
                        $mmUtil.confirmDownloadSize(size).then(function() {
                            $mmaModGlossaryPrefetchHandler.prefetch(module, courseId).catch(function() {
                                if (!$scope.$$destroyed) {
                                    $mmUtil.showErrorModal('mm.core.errordownloading', true);
                                }
                            });
                        }).catch(function() {
                            $scope.spinner = false;
                        });
                    }).catch(function(error) {
                        $scope.spinner = false;
                        $mmUtil.showErrorModalDefault(error, 'mm.core.errordownloading', true);
                    });
                }
                function showStatus(status) {
                    if (status) {
                        $scope.spinner = status === mmCoreDownloading;
                        downloadBtn.hidden = status !== mmCoreNotDownloaded;
                        refreshBtn.hidden = status !== mmCoreOutdated;
                        if (!$mmCoursePrefetchDelegate.canCheckUpdates()) {
                            refreshBtn.hidden = refreshBtn.hidden && status !== mmCoreDownloaded;
                        }
                    }
                }
                var statusObserver = $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
                    if (data.siteid === $mmSite.getId() && data.componentId === module.id &&
                            data.component === mmaModGlossaryComponent) {
                        showStatus(data.status);
                    }
                });
                $mmCoursePrefetchDelegate.getModuleStatus(module, courseId).then(showStatus);
                $scope.$on('$destroy', function() {
                    statusObserver && statusObserver.off && statusObserver.off();
                });
            };
        };
        return self;
    };
        self.indexLinksHandler = $mmContentLinksHelper.createModuleIndexLinkHandler('mmaModGlossary', 'glossary', $mmaModGlossary);
        self.entryLinksHandler = $mmContentLinkHandlerFactory.createChild(
                /\/mod\/glossary\/showentry\.php.*([\&\?]eid=\d+)/, '$mmCourseDelegate_mmaModGlossary');
    self.entryLinksHandler.isEnabled = function(siteId, url, params, courseId) {
        courseId = courseId || params.courseid || params.cid;
        return $mmContentLinksHelper.isModuleIndexEnabled($mmaModGlossary, siteId, courseId);
    };
    self.entryLinksHandler.getActions = function(siteIds, url, params, courseId) {
        courseId = courseId || params.courseid || params.cid;
        return [{
            action: function(siteId) {
                var modal = $mmUtil.showModalLoading(),
                    entryId = parseInt(params.eid, 10),
                    promise;
                if (courseId) {
                    promise = $q.when(courseId);
                } else {
                    promise = getEntry(entryId, siteId).then(function(entry) {
                        return $mmCourseHelper.getModuleCourseIdByInstance(entry.glossaryid, 'glossary', siteId);
                    });
                }
                return promise.then(function(courseId) {
                    var stateParams = {
                        entryid: entryId,
                        cid: courseId
                    };
                    $mmContentLinksHelper.goInSite('site.mod_glossary-entry', stateParams, siteId);
                }).finally(function() {
                    modal.dismiss();
                });
            }
        }];
    };
        function getEntry(entryId, siteId) {
        return $mmaModGlossary.getEntry(entryId, siteId).catch(function(error) {
            $mmUtil.showErrorModalDefault(error, 'mma.mod_glossary.errorloadingentry', true);
            return $q.reject();
        });
    }
        self.syncHandler = function() {
        var self = {};
                self.execute = function(siteId) {
            return $mmaModGlossarySync.syncAllGlossaries(siteId);
        };
                self.getInterval = function() {
            return 600000;
        };
                self.isSync = function() {
            return true;
        };
                self.usesNetwork = function() {
            return true;
        };
        return self;
    };
    return self;
}]);

angular.module('mm.addons.mod_glossary')
.factory('$mmaModGlossaryHelper', ["$mmaModGlossaryOffline", "$mmSite", "$mmFileUploader", "$mmFS", "mmaModGlossaryComponent", "$mmFileUploaderHelper", function($mmaModGlossaryOffline, $mmSite, $mmFileUploader, $mmFS, mmaModGlossaryComponent,
        $mmFileUploaderHelper) {
    var self = {};
        self.deleteStoredFiles = function(glossaryId, entryName, timecreated, siteId) {
        return $mmaModGlossaryOffline.getEntryFolder(glossaryId, entryName, timecreated, siteId).then(function(folderPath) {
            return $mmFS.removeDir(folderPath);
        });
    };
        self.getStoredFiles = function(glossaryId, entryName, timecreated, siteId) {
        return $mmaModGlossaryOffline.getEntryFolder(glossaryId, entryName, timecreated, siteId).then(function(folderPath) {
            return $mmFileUploaderHelper.getStoredFiles(folderPath);
        });
    };
        self.hasEntryDataChanged = function(entry, files, original) {
        if (!original || typeof original.concept == 'undefined') {
            return entry.text || entry.concept || files.length > 0;
        }
        if (original.text != entry.text || original.concept != entry.concept) {
            return true;
        }
        return $mmFileUploaderHelper.areFileListDifferent(files, original.files);
    };
        self.storeFiles = function(glossaryId, entryName, timecreated, files, siteId) {
        return $mmaModGlossaryOffline.getEntryFolder(glossaryId, entryName, timecreated, siteId).then(function(folderPath) {
            return $mmFileUploader.storeFilesToUpload(folderPath, files);
        });
    };
        self.uploadOrStoreFiles = function(glossaryId, entryName, timecreated, files, offline, siteId) {
        if (offline) {
            return self.storeFiles(glossaryId, entryName, timecreated, files, siteId);
        } else {
            return $mmFileUploader.uploadOrReuploadFiles(files, mmaModGlossaryComponent, glossaryId, siteId);
        }
    };
    return self;
}]);
angular.module('mm.addons.mod_glossary')
.factory('$mmaModGlossaryPrefetchHandler', ["$mmaModGlossary", "mmaModGlossaryComponent", "$mmFilepool", "$q", "$mmUser", "mmCoreDownloaded", "mmCoreOutdated", "$mmUtil", "$mmPrefetchFactory", "$mmCoursePrefetchDelegate", "mmaModGlossaryShowAllCategories", function($mmaModGlossary, mmaModGlossaryComponent, $mmFilepool, $q, $mmUser,
            mmCoreDownloaded, mmCoreOutdated, $mmUtil, $mmPrefetchFactory, $mmCoursePrefetchDelegate,
            mmaModGlossaryShowAllCategories) {
    var self = $mmPrefetchFactory.createPrefetchHandler(mmaModGlossaryComponent, false);
    self.updatesNames = /^configuration$|^.*files$|^entries$/;
        self.determineStatus = function(status, canCheck) {
        if (!canCheck && status === mmCoreDownloaded) {
            return mmCoreOutdated;
        } else {
            return status;
        }
    };
        self.download = function(module, courseId) {
        return self.prefetch(module, courseId);
    };
        self.getFiles = function(module, courseId) {
        return $mmaModGlossary.getGlossary(courseId, module.id).then(function(glossary) {
            return $mmaModGlossary.fetchAllEntries($mmaModGlossary.getEntriesByLetter, [glossary.id, 'ALL'])
                    .then(function(entries) {
                return getFilesFromGlossaryAndEntries(module, glossary, entries);
            });
        }).catch(function() {
            return [];
        });
    };
        function getFilesFromGlossaryAndEntries(module, glossary, entries) {
        var files = self.getIntroFilesFromInstance(module, glossary);
        angular.forEach(entries, function(entry) {
            files = files.concat($mmUtil.extractDownloadableFilesFromHtmlAsFakeFileObjects(entry.definition));
            files = files.concat(entry.attachments);
        });
        return files;
    }
        self.getRevision = function(module, courseId) {
        return "0";
    };
        self.getTimemodified = function(module, courseId) {
        return 0;
    };
        self.invalidateContent = function(moduleId, courseId) {
        return $mmaModGlossary.invalidateContent(moduleId, courseId);
    };
        self.invalidateModule = function(module, courseId) {
        if ($mmCoursePrefetchDelegate.canCheckUpdates()) {
            return $q.when();
        }
        return $mmaModGlossary.getGlossary(courseId, module.id).then(function(glossary) {
            var promises = [];
            promises.push($mmaModGlossary.invalidateEntriesByLetter(glossary.id, 'ALL'));
            promises.push($mmaModGlossary.invalidateCourseGlossaries(courseId));
            return $q.all(promises);
        });
    };
        self.isEnabled = function() {
        return $mmaModGlossary.isPluginEnabled();
    };
        self.prefetch = function(module, courseId, single) {
        return self.prefetchPackage(module, courseId, single, prefetchGlossary);
    };
        function prefetchGlossary(module, courseId, single, siteId) {
        var revision,
            timemod;
        siteId = siteId || $mmSite.getId();
        return $mmaModGlossary.getGlossary(courseId, module.id, siteId).then(function(glossary) {
            var promises = [];
            angular.forEach(glossary.browsemodes, function(mode) {
                switch(mode) {
                    case 'letter':
                        break;
                    case 'cat':
                        promises.push($mmaModGlossary.fetchAllEntries($mmaModGlossary.getEntriesByCategory,
                            [glossary.id, mmaModGlossaryShowAllCategories], false, undefined, undefined, siteId));
                        break;
                    case 'date':
                        promises.push($mmaModGlossary.fetchAllEntries($mmaModGlossary.getEntriesByDate,
                            [glossary.id, 'CREATION', 'DESC'], false, undefined, undefined, siteId));
                        promises.push($mmaModGlossary.fetchAllEntries($mmaModGlossary.getEntriesByDate,
                            [glossary.id, 'UPDATE', 'DESC'], false, undefined, undefined, siteId));
                        break;
                    case 'author':
                        promises.push($mmaModGlossary.fetchAllEntries($mmaModGlossary.getEntriesByAuthor,
                            [glossary.id, 'ALL', 'LASTNAME', 'ASC'], false, undefined, undefined, siteId));
                        break;
                }
            });
            promises.push($mmaModGlossary.fetchAllEntries($mmaModGlossary.getEntriesByLetter, [glossary.id, 'ALL'], false,
                    undefined, undefined, siteId).then(function(entries) {
                var promises = [],
                    files = getFilesFromGlossaryAndEntries(module, glossary, entries),
                    userIds = [];
                angular.forEach(entries, function(entry) {
                    promises.push($mmaModGlossary.getEntry(entry.id, siteId));
                    userIds.push(entry.userid);
                });
                promises.push($mmUser.prefetchProfiles(userIds, courseId, siteId));
                angular.forEach(files, function(file) {
                    promises.push($mmFilepool.addToQueueByUrl(siteId, file.fileurl, self.component, module.id, file.timemodified));
                });
                return $q.all(promises);
            }));
            revision = self.getRevision(module, courseId);
            timemod = self.getTimemodified(module, courseId);
            return $q.all(promises);
        }).then(function() {
            return {
                revision: revision,
                timemod: timemod
            };
        });
    }
    return self;
}]);

angular.module('mm.addons.mod_imscp')
.controller('mmaModImscpIndexCtrl', ["$scope", "$stateParams", "$mmUtil", "$mmCourseHelper", "$mmaModImscp", "mmaModImscpComponent", "$log", "$ionicPopover", "$timeout", "$q", "$mmCourse", "$mmApp", "$mmText", "$translate", "$mmaModImscpPrefetchHandler", function($scope, $stateParams, $mmUtil, $mmCourseHelper, $mmaModImscp, mmaModImscpComponent,
            $log, $ionicPopover, $timeout, $q, $mmCourse, $mmApp, $mmText, $translate, $mmaModImscpPrefetchHandler) {
    $log = $log.getInstance('mmaModImscpIndexCtrl');
    var module = $stateParams.module || {},
        courseId = $stateParams.courseid,
        currentItem;
    $scope.title = module.name;
    $scope.description = module.description;
    $scope.component = mmaModImscpComponent;
    $scope.componentId = module.id;
    $scope.externalUrl = module.url;
    $scope.loaded = false;
    $scope.refreshIcon = 'spinner';
    $scope.previousItem = '';
    $scope.nextItem = '';
    function loadItem(itemId) {
        currentItem = itemId;
        $scope.previousItem = $mmaModImscp.getPreviousItem($scope.items, itemId);
        $scope.nextItem = $mmaModImscp.getNextItem($scope.items, itemId);
        var src = $mmaModImscp.getFileSrc(module, itemId);
        if ($scope.src && src.toString() == $scope.src.toString()) {
            $scope.src = '';
            $timeout(function() {
                $scope.src = src;
            });
        } else {
            $scope.src = src;
        }
    }
    function fetchContent(refresh) {
        var downloadFailed = false,
            promises = [];
        promises.push($mmaModImscp.getImscp(courseId, module.id).then(function(imscp) {
            $scope.title = imscp.name || $scope.title;
            $scope.description = imscp.intro || $scope.description;
        }).catch(function() {
        }));
        promises.push($mmaModImscpPrefetchHandler.download(module, courseId).catch(function() {
            downloadFailed = true;
            if (!module.contents.length) {
                return $mmCourse.loadModuleContents(module, courseId).catch(function(error) {
                    $mmUtil.showErrorModalDefault(error, 'mm.course.errorgetmodule', true);
                    return $q.reject();
                });
            }
        }));
        return $q.all(promises).then(function() {
            $scope.items = $mmaModImscp.createItemList(module.contents);
            if ($scope.items.length && typeof currentItem == 'undefined') {
                currentItem = $scope.items[0].href;
            }
            return $mmaModImscp.getIframeSrc(module).then(function() {
                $mmCourseHelper.fillContextMenu($scope, module, courseId, refresh, mmaModImscpComponent);
                loadItem(currentItem);
                if (downloadFailed && $mmApp.isOnline()) {
                    $mmUtil.showErrorModal('mm.core.errordownloadingsomefiles', true);
                }
            }).catch(function() {
                $mmUtil.showErrorModal('mma.mod_imscp.deploymenterror', true);
                return $q.reject();
            });
        }).finally(function() {
            $scope.loaded = true;
            $scope.refreshIcon = 'ion-refresh';
        });
    }
    $scope.doRefresh = function() {
        if ($scope.loaded) {
            $scope.refreshIcon = 'spinner';
            return $mmaModImscp.invalidateContent(module.id, courseId).finally(function() {
                return fetchContent(true);
            }).finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        }
    };
    $scope.loadItem = function(itemId) {
        if (!itemId) {
            return;
        }
        $scope.popover.hide();
        loadItem(itemId);
    };
    $scope.getNumberForPadding = function(n) {
        return new Array(n);
    };
    $scope.removeFiles = function() {
        $mmCourseHelper.confirmAndRemove(module, courseId);
    };
    $scope.prefetch = function() {
        $mmCourseHelper.contextMenuPrefetch($scope, module, courseId);
    };
    $scope.expandDescription = function() {
        $mmText.expandText($translate.instant('mm.core.description'), $scope.description, false, mmaModImscpComponent, module.id);
    };
    $timeout(function() {
        $ionicPopover.fromTemplateUrl('addons/mod/imscp/templates/toc.html', {
            scope: $scope
        }).then(function(popover) {
            $scope.popover = popover;
        });
    });
    fetchContent().then(function() {
        $mmaModImscp.logView(module.instance).then(function() {
            $mmCourse.checkModuleCompletion(courseId, module.completionstatus);
        });
    });
}]);

angular.module('mm.addons.mod_imscp')
.factory('$mmaModImscpHandlers', ["$mmCourse", "$mmaModImscp", "$mmEvents", "$state", "$mmSite", "$mmCourseHelper", "$mmCoursePrefetchDelegate", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", "mmCoreEventPackageStatusChanged", "mmaModImscpComponent", "$mmContentLinksHelper", "$q", "$mmaModImscpPrefetchHandler", "$mmUtil", function($mmCourse, $mmaModImscp, $mmEvents, $state, $mmSite, $mmCourseHelper,
            $mmCoursePrefetchDelegate, mmCoreDownloading, mmCoreNotDownloaded, mmCoreOutdated, mmCoreEventPackageStatusChanged,
            mmaModImscpComponent, $mmContentLinksHelper, $q, $mmaModImscpPrefetchHandler, $mmUtil) {
    var self = {};
        self.courseContent = function() {
        var self = {};
                self.isEnabled = function() {
            return $mmaModImscp.isPluginEnabled();
        };
                self.getController = function(module, courseid) {
            return function($scope) {
                var downloadBtn,
                    refreshBtn;
                downloadBtn = {
                    hidden: true,
                    icon: 'ion-ios-cloud-download-outline',
                    label: 'mm.core.download',
                    action: function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        download(false);
                    }
                };
                refreshBtn = {
                    icon: 'ion-android-refresh',
                    label: 'mm.core.refresh',
                    hidden: true,
                    action: function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        download(true);
                    }
                };
                $scope.title = module.name;
                $scope.icon = $mmCourse.getModuleIconSrc('imscp');
                $scope.class = 'mma-mod_imscp-handler';
                $scope.buttons = [downloadBtn, refreshBtn];
                $scope.spinner = true;
                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_imscp', {module: module, courseid: courseid});
                };
                function download(refresh) {
                    var dwnBtnHidden = downloadBtn.hidden,
                        rfrshBtnHidden = refreshBtn.hidden;
                    $scope.spinner = true;
                    downloadBtn.hidden = true;
                    refreshBtn.hidden = true;
                    $mmaModImscpPrefetchHandler.getDownloadSize(module, courseid).then(function(size) {
                        $mmCourseHelper.prefetchModule($scope, $mmaModImscpPrefetchHandler, module, size, refresh, courseid)
                                .catch(function() {
                            $scope.spinner = false;
                            downloadBtn.hidden = dwnBtnHidden;
                            refreshBtn.hidden = rfrshBtnHidden;
                        });
                    }).catch(function(error) {
                        $scope.spinner = false;
                        downloadBtn.hidden = dwnBtnHidden;
                        refreshBtn.hidden = rfrshBtnHidden;
                        if (error) {
                            $mmUtil.showErrorModal(error);
                        } else {
                            $mmUtil.showErrorModal('mm.core.errordownloading', true);
                        }
                    });
                }
                function showStatus(status) {
                    if (status) {
                        $scope.spinner = status === mmCoreDownloading;
                        downloadBtn.hidden = status !== mmCoreNotDownloaded;
                        refreshBtn.hidden = status !== mmCoreOutdated;
                    }
                }
                var statusObserver = $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
                    if (data.siteid === $mmSite.getId() && data.componentId === module.id && data.component === mmaModImscpComponent) {
                        showStatus(data.status);
                    }
                });
                $mmCoursePrefetchDelegate.getModuleStatus(module, courseid).then(showStatus);
                $scope.$on('$destroy', function() {
                    statusObserver && statusObserver.off && statusObserver.off();
                });
            };
        };
        return self;
    };
        self.linksHandler = $mmContentLinksHelper.createModuleIndexLinkHandler('mmaModImscp', 'imscp', $mmaModImscp);
    return self;
}]);

angular.module('mm.addons.mod_imscp')
.factory('$mmaModImscp', ["$mmFilepool", "$mmSite", "$mmFS", "$log", "$q", "$sce", "$mmApp", "$mmSitesManager", "$mmUtil", "$mmCourse", "mmaModImscpComponent", function($mmFilepool, $mmSite, $mmFS, $log, $q, $sce, $mmApp, $mmSitesManager, $mmUtil, $mmCourse,
            mmaModImscpComponent) {
    $log = $log.getInstance('$mmaModImscp');
    var self = {},
        currentDirPath;
        self.getToc = function(contents) {
        if (!contents || !contents.length) {
            return [];
        }
        return JSON.parse(contents[0].content);
    };
        self.createItemList = function(contents) {
        var items = [];
        var toc = self.getToc(contents);
        angular.forEach(toc, function(el) {
            items.push({href: el.href, title: el.title, level: el.level});
            angular.forEach(el.subitems, function(sel) {
                items.push({href: sel.href, title: sel.title, level: sel.level});
            });
        });
        return items;
    };
        self.getPreviousItem = function(items, itemId) {
        var position = getItemPosition(items, itemId);
        if (position != -1) {
            for (var i = position - 1; i >= 0; i--) {
                if (items[i] && items[i].href) {
                    return items[i].href;
                }
            }
        }
        return '';
    };
        self.getNextItem = function(items, itemId) {
        var position = getItemPosition(items, itemId);
        if (position != -1) {
            for (var i = position + 1, len = items.length; i < len; i++) {
                if (items[i] && items[i].href) {
                    return items[i].href;
                }
            }
        }
        return '';
    };
        function getItemPosition(items, itemId) {
        for (var i = 0, len = items.length; i < len; i++) {
            if (items[i].href == itemId) {
                return i;
            }
        }
        return -1;
    }
        self.checkSpecialFiles = function(fileName) {
        return fileName == 'imsmanifest.xml';
    };
        function getImscpDataCacheKey(courseId) {
        return 'mmaModImscp:imscp:' + courseId;
    }
        function getImscp(siteId, courseId, key, value) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    courseids: [courseId]
                },
                preSets = {
                    cacheKey: getImscpDataCacheKey(courseId)
                };
            return site.read('mod_imscp_get_imscps_by_courses', params, preSets).then(function(response) {
                if (response && response.imscps) {
                    var currentImscp;
                    angular.forEach(response.imscps, function(imscp) {
                        if (!currentImscp && imscp[key] == value) {
                            currentImscp = imscp;
                        }
                    });
                    if (currentImscp) {
                        return currentImscp;
                    }
                }
                return $q.reject();
            });
        });
    }
        self.getImscp = function(courseId, cmId, siteId) {
        siteId = siteId || $mmSite.getId();
        return getImscp(siteId, courseId, 'coursemodule', cmId);
    };
        self._getFileUrlFromContents = function(contents, targetFilepath) {
        var indexUrl;
        angular.forEach(contents, function(content) {
            if (content.type == 'file' && !indexUrl) {
                var filepath = $mmFS.concatenatePaths(content.filepath, content.filename),
                    filepathalt = filepath.charAt(0) === '/' ? filepath.substr(1) : '/' + filepath;
                if (filepath === targetFilepath || filepathalt === targetFilepath) {
                    indexUrl = content.fileurl;
                }
            }
        });
        return indexUrl;
    };
        self.getIframeSrc = function(module) {
        var toc = self.getToc(module.contents),
            mainFilePath;
        if (!toc.length) {
            return $q.reject();
        }
        mainFilePath = toc[0].href;
        return $mmFilepool.getPackageDirUrlByUrl($mmSite.getId(), module.url).then(function(dirPath) {
            currentDirPath = dirPath;
            return $sce.trustAsResourceUrl($mmFS.concatenatePaths(dirPath, mainFilePath));
        }, function() {
            if ($mmApp.isOnline()) {
                var indexUrl = self._getFileUrlFromContents(module.contents, mainFilePath);
                if (indexUrl) {
                    return $sce.trustAsResourceUrl($mmSite.fixPluginfileURL(indexUrl));
                }
            }
            return $q.reject();
        });
    };
        self.getFileSrc = function(module, itemId) {
        if (currentDirPath) {
            return $sce.trustAsResourceUrl($mmFS.concatenatePaths(currentDirPath, itemId));
        } else {
            if ($mmApp.isOnline()) {
                var indexUrl = self._getFileUrlFromContents(module.contents, itemId);
                if (indexUrl) {
                    return $sce.trustAsResourceUrl($mmSite.fixPluginfileURL(indexUrl));
                }
            }
        }
    };
        self.invalidateContent = function(moduleId, courseId, siteId) {
        siteId = siteId || $mmSite.getId();
        var promises = [];
        promises.push(self.invalidateImscpData(courseId, siteId));
        promises.push($mmFilepool.invalidateFilesByComponent(siteId, mmaModImscpComponent, moduleId));
        promises.push($mmCourse.invalidateModule(moduleId, siteId));
        return $mmUtil.allPromises(promises);
    };
        self.invalidateImscpData = function(courseId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getImscpDataCacheKey(courseId));
        });
    };
        self.isFileDownloadable = function(file) {
        return file.type === 'file' && !self.checkSpecialFiles(file.filename);
    };
        self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.isVersionGreaterEqualThan('2.9') && site.canDownloadFiles();
        });
    };
        self.logView = function(id) {
        if (id) {
            var params = {
                imscpid: id
            };
            return $mmSite.write('mod_imscp_view_imscp', params);
        }
        return $q.reject();
    };
    return self;
}]);

angular.module('mm.addons.mod_imscp')
.factory('$mmaModImscpPrefetchHandler', ["$mmaModImscp", "$mmSite", "$mmFilepool", "$mmPrefetchFactory", "mmaModImscpComponent", "$mmCourse", "$q", function($mmaModImscp, $mmSite, $mmFilepool, $mmPrefetchFactory, mmaModImscpComponent,
            $mmCourse, $q) {
    var self = $mmPrefetchFactory.createPrefetchHandler(mmaModImscpComponent, true);
        self.download = function(module, courseId, single) {
        return downloadOrPrefetch(module, courseId, true);
    };
        function downloadOrPrefetch(module, courseId, prefetch) {
        return $mmFilepool.getPackageDirPathByUrl($mmSite.getId(), module.url).then(function(dirPath) {
            return self.downloadOrPrefetch(module, courseId, prefetch, dirPath);
        });
    }
        self.getIntroFiles = function(module, courseId) {
        return $mmaModImscp.getImscp(courseId, module.id).catch(function() {
        }).then(function(imscp) {
            return self.getIntroFilesFromInstance(module, imscp);
        });
    };
        self.invalidateContent = function(moduleId, courseId) {
        return $mmaModImscp.invalidateContent(moduleId, courseId);
    };
        self.invalidateModule = function(module, courseId) {
        var promises = [];
        promises.push($mmaModImscp.invalidateImscpData(courseId));
        promises.push($mmCourse.invalidateModule(module.id));
        return $q.all(promises);
    };
        self.isEnabled = function() {
        if (!$mmSite.canDownloadFiles()) {
            return false;
        }
        return $mmaModImscp.isPluginEnabled();
    };
        self.isFileDownloadable = function(file) {
        return $mmaModImscp.isFileDownloadable(file);
    };
        self.prefetch = function(module, courseId, single) {
        return downloadOrPrefetch(module, courseId, true);
    };
    return self;
}]);

angular.module('mm.addons.mod_label')
.factory('$mmaModLabelHandlers', ["$mmContentLinksHelper", function($mmContentLinksHelper) {
    var self = {};
        self.courseContent = function() {
        var self = {};
                self.isEnabled = function() {
            return true;
        };
                self.getController = function(module) {
            return function($scope) {
                $scope.title = module.description || module.descriptioncopy;
                module.descriptioncopy = module.description;
                module.description = "";
                $scope.icon = false;
                $scope.class = 'mma-mod_label-handler';
                $scope.action = false;
            };
        };
        return self;
    };
        self.linksHandler = $mmContentLinksHelper.createModuleIndexLinkHandler('mmaModLabel', 'label', {});
    return self;
}]);

angular.module('mm.addons.mod_lti')
.controller('mmaModLtiIndexCtrl', ["$scope", "$stateParams", "$mmaModLti", "$mmUtil", "$q", "$mmCourse", "$mmText", "$translate", "mmaModLtiComponent", function($scope, $stateParams, $mmaModLti, $mmUtil, $q, $mmCourse, $mmText, $translate,
            mmaModLtiComponent) {
    var module = $stateParams.module || {},
        courseid = $stateParams.courseid,
        lti;
    $scope.title = module.name;
    $scope.description = module.description;
    $scope.moduleUrl = module.url;
    $scope.courseid = courseid;
    $scope.refreshIcon = 'spinner';
    $scope.component = mmaModLtiComponent;
    $scope.componentId = module.id;
    function fetchLTI(refresh) {
        return $mmaModLti.getLti(courseid, module.id).then(function(ltidata) {
            lti = ltidata;
            return $mmaModLti.getLtiLaunchData(lti.id).then(function(launchdata) {
                lti.launchdata = launchdata;
                $scope.title = lti.name || $scope.title;
                $scope.description = lti.intro || $scope.description;
                $scope.isValidUrl = $mmUtil.isValidURL(launchdata.endpoint);
            });
        }).catch(function(message) {
            if (!refresh) {
                return refreshAllData();
            }
            if (message) {
                $mmUtil.showErrorModal(message);
            } else {
                $mmUtil.showErrorModal('mma.mod_lti.errorgetlti', true);
            }
            return $q.reject();
        });
    }
    function refreshAllData() {
        var p1 = $mmaModLti.invalidateLti(courseid),
            p2 = lti ? $mmaModLti.invalidateLtiLaunchData(lti.id) : $q.when();
        return $q.all([p1, p2]).finally(function() {
            return fetchLTI(true);
        });
    }
    fetchLTI().finally(function() {
        $scope.ltiLoaded = true;
        $scope.refreshIcon = 'ion-refresh';
    });
    $scope.doRefresh = function() {
        if ($scope.ltiLoaded) {
            $scope.refreshIcon = 'spinner';
            return refreshAllData().finally(function() {
                $scope.refreshIcon = 'ion-refresh';
                $scope.$broadcast('scroll.refreshComplete');
            });
        }
    };
    $scope.launch = function() {
        $mmaModLti.logView(lti.id).then(function() {
            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
        });
        $mmaModLti.launch(lti.launchdata.endpoint, lti.launchdata.parameters).catch(function(message) {
            if (message) {
                $mmUtil.showErrorModal(message);
            }
        });
    };
    $scope.expandDescription = function() {
        $mmText.expandText($translate.instant('mm.core.description'), $scope.description, false, mmaModLtiComponent, module.id);
    };
}]);

angular.module('mm.addons.mod_lti')
.factory('$mmaModLtiHandlers', ["$mmCourse", "$mmaModLti", "$state", "$mmSite", "$mmFilepool", "$mmApp", "$mmUtil", "mmaModLtiComponent", "$mmContentLinksHelper", function($mmCourse, $mmaModLti, $state, $mmSite, $mmFilepool, $mmApp, $mmUtil,
            mmaModLtiComponent, $mmContentLinksHelper) {
    var self = {};
        self.courseContent = function() {
        var self = {};
                self.isEnabled = function() {
            return $mmaModLti.isPluginEnabled();
        };
                self.getController = function(module, courseid) {
            return function($scope) {
                $scope.title = module.name;
                $scope.icon = $mmCourse.getModuleIconSrc('lti');
                $scope.class = 'mma-mod_lti-handler';
                $scope.action = function() {
                    $state.go('site.mod_lti', {module: module, courseid: courseid});
                };
                var promise = $mmaModLti.getLti(courseid, module.id);
                promise.then(function(ltidata) {
                    var icon = ltidata.secureicon || ltidata.icon;
                    if (icon) {
                        $mmFilepool.downloadUrl($mmSite.getId(), icon, false, mmaModLtiComponent, module.id).then(function(url) {
                            $scope.icon = url;
                        }).catch(function() {
                            if ($mmApp.isOnline()) {
                                $scope.icon = icon;
                            }
                        });
                    }
                });
                $scope.buttons = [{
                    icon: 'ion-link',
                    label: 'mma.mod_lti.launchactivity',
                    action: function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        var modal = $mmUtil.showModalLoading('mm.core.loading', true);
                        promise.then(function(ltidata) {
                            return $mmaModLti.getLtiLaunchData(ltidata.id).then(function(launchdata) {
                                $mmaModLti.logView(ltidata.id).then(function() {
                                    $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
                                });
                                return $mmaModLti.launch(launchdata.endpoint, launchdata.parameters);
                            });
                        }).catch(function(message) {
                            if (message) {
                                $mmUtil.showErrorModal(message);
                            } else {
                                $mmUtil.showErrorModal('mma.mod_lti.errorgetlti', true);
                            }
                        }).finally(function() {
                            modal.dismiss();
                        });
                    }
                }];
            };
        };
        return self;
    };
        self.linksHandler = $mmContentLinksHelper.createModuleIndexLinkHandler('mmaModLti', 'lti', $mmaModLti);
    return self;
}]);

angular.module('mm.addons.mod_lti')
.factory('$mmaModLti', ["$q", "$mmSite", "$mmFS", "$mmText", "$mmUtil", "$mmLang", "$mmSitesManager", function($q, $mmSite, $mmFS, $mmText, $mmUtil, $mmLang, $mmSitesManager) {
    var self = {},
        launcherFileName = 'lti_launcher.html';
        self.deleteLauncher = function() {
        return $mmFS.removeFile(launcherFileName);
    };
        self.generateLauncher = function(url, params) {
        if (!$mmFS.isAvailable()) {
            return $q.when(url);
        }
        var text = '<form action="' + url + '" name="ltiLaunchForm" ' +
                    'method="post" encType="application/x-www-form-urlencoded">\n';
        angular.forEach(params, function(p) {
            if (p.name == 'ext_submit') {
                text += '    <input type="submit"';
            } else {
                text += '    <input type="hidden" name="' + $mmText.escapeHTML(p.name) + '"';
            }
            text += ' value="' + $mmText.escapeHTML(p.value) + '"/>\n';
        });
        text += '</form>\n';
        text += '<script type="text/javascript"> \n' +
            '    document.ltiLaunchForm.submit(); \n' +
            '</script> \n';
        return $mmFS.writeFile(launcherFileName, text).then(function(entry) {
            return entry.toURL();
        });
    };
        self.getLti = function(courseid, cmid) {
        var params = {
                courseids: [courseid]
            },
            preSets = {
                cacheKey: getLtiCacheKey(courseid)
            };
        return $mmSite.read('mod_lti_get_ltis_by_courses', params, preSets).then(function(response) {
            if (response.ltis) {
                var currentLti;
                angular.forEach(response.ltis, function(lti) {
                    if (lti.coursemodule == cmid) {
                        currentLti = lti;
                    }
                });
                if (currentLti) {
                    return currentLti;
                }
            }
            return $q.reject();
        });
    };
        function getLtiCacheKey(courseid) {
        return 'mmaModLti:lti:' + courseid;
    }
        self.getLtiLaunchData = function(id) {
        var params = {
                toolid: id
            },
            preSets = {
                cacheKey: getLtiLaunchDataCacheKey(id)
            };
        return $mmSite.read('mod_lti_get_tool_launch_data', params, preSets).then(function(response) {
            if (response.endpoint) {
                return response;
            }
            return $q.reject();
        });
    };
        function getLtiLaunchDataCacheKey(id) {
        return 'mmaModLti:launch:' + id;
    }
        self.invalidateLti = function(courseid) {
        return $mmSite.invalidateWsCacheForKey(getLtiCacheKey(courseid));
    };
        self.invalidateLtiLaunchData = function(id) {
        return $mmSite.invalidateWsCacheForKey(getLtiLaunchDataCacheKey(id));
    };
        self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return  site.wsAvailable('mod_lti_get_ltis_by_courses') &&
                    site.wsAvailable('mod_lti_get_tool_launch_data');
        });
    };
        self.launch = function(url, params) {
        if (!$mmUtil.isValidURL(url)) {
            return $mmLang.translateAndReject('mma.mod_lti.errorinvalidlaunchurl');
        }
        return self.generateLauncher(url, params).then(function(url) {
            $mmUtil.openInApp(url);
        });
    };
        self.logView = function(id) {
        if (id) {
            var params = {
                ltiid: id
            };
            return $mmSite.write('mod_lti_view_lti', params);
        }
        return $q.reject();
    };
    return self;
}]);

angular.module('mm.addons.mod_page')
.controller('mmaModPageIndexCtrl', ["$scope", "$stateParams", "$translate", "$mmUtil", "$mmaModPage", "$mmCourse", "$q", "$log", "$mmApp", "mmaModPageComponent", "$mmText", "$mmaModPagePrefetchHandler", "$mmCourseHelper", function($scope, $stateParams, $translate, $mmUtil, $mmaModPage, $mmCourse, $q, $log, $mmApp,
            mmaModPageComponent, $mmText, $mmaModPagePrefetchHandler, $mmCourseHelper) {
    $log = $log.getInstance('mmaModPageIndexCtrl');
    var module = $stateParams.module || {},
        courseId = $stateParams.courseid;
    $scope.title = module.name;
    $scope.description = module.description;
    $scope.component = mmaModPageComponent;
    $scope.componentId = module.id;
    $scope.externalUrl = module.url;
    $scope.loaded = false;
    $scope.refreshIcon = 'spinner';
    function fetchContent(refresh) {
        var downloadFailed = false;
        return $mmaModPagePrefetchHandler.download(module, courseId).catch(function() {
            downloadFailed = true;
            if (!module.contents.length) {
                return $mmCourse.loadModuleContents(module, courseId);
            }
        }).then(function() {
            var promises = [];
            promises.push($mmCourse.getModule(module.id, courseId).then(function(mod) {
                $scope.title = mod.name;
                $scope.description = mod.description;
            }).catch(function() {
            }));
            promises.push($mmaModPage.getPageHtml(module.contents, module.id).then(function(content) {
                $mmCourseHelper.fillContextMenu($scope, module, courseId, refresh, mmaModPageComponent);
                $scope.content = content;
                if (downloadFailed && $mmApp.isOnline()) {
                    $mmUtil.showErrorModal('mm.core.errordownloadingsomefiles', true);
                }
            }));
            return $q.all(promises);
        }).catch(function(error) {
            $mmUtil.showErrorModalDefault(error, 'mma.mod_page.errorwhileloadingthepage', true);
            return $q.reject();
        }).finally(function() {
            $scope.loaded = true;
            $scope.refreshIcon = 'ion-refresh';
        });
    }
    $scope.removeFiles = function() {
        $mmCourseHelper.confirmAndRemove(module, courseId);
    };
    $scope.prefetch = function() {
        $mmCourseHelper.contextMenuPrefetch($scope, module, courseId);
    };
    $scope.expandDescription = function() {
        $mmText.expandText($translate.instant('mm.core.description'), $scope.description, false, mmaModPageComponent, module.id);
    };
    $scope.doRefresh = function() {
        if ($scope.loaded) {
            $scope.refreshIcon = 'spinner';
            return $mmaModPagePrefetchHandler.invalidateContent(module.id).then(function() {
                return fetchContent(true);
            }).finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        }
    };
    fetchContent().then(function() {
        $mmaModPage.logView(module.instance).then(function() {
            $mmCourse.checkModuleCompletion(courseId, module.completionstatus);
        });
    });
}]);

angular.module('mm.addons.mod_page')
.factory('$mmaModPageHandlers', ["$mmCourse", "$mmaModPage", "$mmEvents", "$state", "$mmSite", "$mmCourseHelper", "$mmUtil", "$mmCoursePrefetchDelegate", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", "mmCoreEventPackageStatusChanged", "mmaModPageComponent", "$mmContentLinksHelper", "$mmaModPagePrefetchHandler", function($mmCourse, $mmaModPage, $mmEvents, $state, $mmSite, $mmCourseHelper, $mmUtil,
            $mmCoursePrefetchDelegate, mmCoreDownloading, mmCoreNotDownloaded, mmCoreOutdated, mmCoreEventPackageStatusChanged,
            mmaModPageComponent, $mmContentLinksHelper, $mmaModPagePrefetchHandler) {
    var self = {};
        self.courseContent = function() {
        var self = {};
                self.isEnabled = function() {
            return $mmaModPage.isPluginEnabled();
        };
                self.getController = function(module, courseid) {
            return function($scope) {
                var downloadBtn,
                    refreshBtn;
                downloadBtn = {
                    hidden: true,
                    icon: 'ion-ios-cloud-download-outline',
                    label: 'mm.core.download',
                    action: function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        download(false);
                    }
                };
                refreshBtn = {
                    icon: 'ion-android-refresh',
                    label: 'mm.core.refresh',
                    hidden: true,
                    action: function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        download(true);
                    }
                };
                $scope.title = module.name;
                $scope.icon = $mmCourse.getModuleIconSrc('page');
                $scope.class = 'mma-mod_page-handler';
                $scope.buttons = [downloadBtn, refreshBtn];
                $scope.spinner = true;
                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_page', {module: module, courseid: courseid});
                };
                function download(refresh) {
                    var dwnBtnHidden = downloadBtn.hidden,
                        rfrshBtnHidden = refreshBtn.hidden;
                    $scope.spinner = true;
                    downloadBtn.hidden = true;
                    refreshBtn.hidden = true;
                    $mmaModPagePrefetchHandler.getDownloadSize(module, courseid).then(function(size) {
                        $mmCourseHelper.prefetchModule($scope, $mmaModPagePrefetchHandler, module, size, refresh, courseid)
                                .catch(function() {
                            $scope.spinner = false;
                            downloadBtn.hidden = dwnBtnHidden;
                            refreshBtn.hidden = rfrshBtnHidden;
                        });
                    }).catch(function(error) {
                        $scope.spinner = false;
                        downloadBtn.hidden = dwnBtnHidden;
                        refreshBtn.hidden = rfrshBtnHidden;
                        if (error) {
                            $mmUtil.showErrorModal(error);
                        } else {
                            $mmUtil.showErrorModal('mm.core.errordownloading', true);
                        }
                    });
                }
                function showStatus(status) {
                    if (status) {
                        $scope.spinner = status === mmCoreDownloading;
                        downloadBtn.hidden = status !== mmCoreNotDownloaded;
                        refreshBtn.hidden = status !== mmCoreOutdated;
                    }
                }
                var statusObserver = $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
                    if (data.siteid === $mmSite.getId() && data.componentId === module.id && data.component === mmaModPageComponent) {
                        showStatus(data.status);
                    }
                });
                $mmCoursePrefetchDelegate.getModuleStatus(module, courseid).then(showStatus);
                $scope.$on('$destroy', function() {
                    statusObserver && statusObserver.off && statusObserver.off();
                });
            };
        };
        return self;
    };
        self.linksHandler = $mmContentLinksHelper.createModuleIndexLinkHandler('mmaModPage', 'page', $mmaModPage);
    return self;
}]);

angular.module('mm.addons.mod_page')
.factory('$mmaModPage', ["$mmFilepool", "$mmSite", "$mmFS", "$http", "$log", "$q", "$mmSitesManager", "$mmUtil", "$mmText", "mmaModPageComponent", function($mmFilepool, $mmSite, $mmFS, $http, $log, $q, $mmSitesManager, $mmUtil, $mmText,
            mmaModPageComponent) {
    $log = $log.getInstance('$mmaModPage');
    var self = {};
        self.getPageHtml = function(contents, moduleId) {
        var indexUrl,
            paths = {},
            promise;
        angular.forEach(contents, function(content) {
            var key,
                url = content.fileurl;
            if (self._isMainPage(content)) {
                indexUrl = url;
            } else {
                key = content.filename;
                if (content.filepath !== '/') {
                    key = content.filepath.substr(1) + key;
                }
                paths[$mmText.decodeURIComponent(key)] = url;
            }
        });
        promise = (function() {
            if (!indexUrl) {
                $log.debug('Could not locate the index page');
                return $q.reject();
            } else if ($mmFS.isAvailable()) {
                return $mmFilepool.downloadUrl($mmSite.getId(), indexUrl, false, mmaModPageComponent, moduleId);
            } else {
                return $q.when($mmSite.fixPluginfileURL(indexUrl));
            }
        })();
        return promise.then(function(url) {
            return $http.get(url).then(function(response) {
                if (typeof response.data !== 'string') {
                    return $q.reject();
                } else {
                    return $mmUtil.restoreSourcesInHtml(response.data, paths);
                }
            });
        });
    };
        self._isMainPage = function(file) {
        var filename = file.filename || undefined,
            fileurl = file.fileurl || '',
            url = '/mod_page/content/index.html',
            encodedUrl = encodeURIComponent(url);
        return (filename === 'index.html' && (fileurl.indexOf(url) > 0 || fileurl.indexOf(encodedUrl) > 0 ));
    };
        self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.canDownloadFiles();
        });
    };
        self.logView = function(id) {
        if (id) {
            var params = {
                pageid: id
            };
            return $mmSite.write('mod_page_view_page', params);
        }
        return $q.reject();
    };
    return self;
}]);

angular.module('mm.addons.mod_page')
.factory('$mmaModPagePrefetchHandler', ["$mmPrefetchFactory", "mmaModPageComponent", function($mmPrefetchFactory, mmaModPageComponent) {
    var self = $mmPrefetchFactory.createPrefetchHandler(mmaModPageComponent, true);
    self.updatesNames = /^configuration$|^.*files$/;
    return self;
}]);

angular.module('mm.addons.mod_quiz')
.controller('mmaModQuizAttemptCtrl', ["$scope", "$stateParams", "$mmaModQuiz", "$q", "$mmaModQuizHelper", "mmaModQuizComponent", function($scope, $stateParams, $mmaModQuiz, $q, $mmaModQuizHelper, mmaModQuizComponent) {
    var attemptId = $stateParams.attemptid,
        quizId = $stateParams.quizid,
        courseId = $stateParams.courseid,
        quiz,
        attempt;
    $scope.courseId = courseId;
    function fetchData() {
        return $mmaModQuiz.getQuizById(courseId, quizId).then(function(quizData) {
            quiz = quizData;
            $scope.quiz = quiz;
            $scope.component = mmaModQuizComponent;
            $scope.componentId = quiz.coursemodule;
            return fetchAttempt();
        }).catch(function(message) {
            return $mmaModQuizHelper.showError(message, 'mma.mod_quiz.errorgetattempt');
        });
    }
    function fetchAttempt() {
        var promises = [],
            options,
            accessInfo;
        promises.push($mmaModQuiz.getUserAttempts(quiz.id).then(function(attempts) {
            angular.forEach(attempts, function(att) {
                if (att.id == attemptId) {
                    attempt = att;
                }
            });
            if (!attempt) {
                return $q.reject();
            }
            return $mmaModQuiz.loadFinishedOfflineData([attempt]);
        }));
        promises.push($mmaModQuiz.getCombinedReviewOptions(quiz.id).then(function(opts) {
            options = opts;
        }));
        promises.push($mmaModQuiz.getQuizAccessInformation(quiz.id).then(function(aI) {
            accessInfo = aI;
            if (accessInfo.canreviewmyattempts) {
                return $mmaModQuiz.getAttemptReview(attemptId, -1).catch(function() {
                    accessInfo.canreviewmyattempts = false;
                });
            }
        }));
        return $q.all(promises).then(function() {
            $mmaModQuizHelper.setQuizCalculatedData(quiz, options);
            quiz.showReviewColumn = accessInfo.canreviewmyattempts;
            $mmaModQuizHelper.setAttemptCalculatedData(quiz, attempt, false);
            if (quiz.showFeedbackColumn && $mmaModQuiz.isAttemptFinished(attempt.state) &&
                        options.someoptions.overallfeedback && angular.isNumber(attempt.rescaledGrade)) {
                return $mmaModQuiz.getFeedbackForGrade(quiz.id, attempt.rescaledGrade).then(function(response) {
                    attempt.feedback = response.feedbacktext;
                });
            } else {
                delete attempt.feedback;
            }
        }).then(function() {
            $scope.attempt = attempt;
        });
    }
    function refreshData() {
        var promises = [];
        promises.push($mmaModQuiz.invalidateQuizData(courseId));
        promises.push($mmaModQuiz.invalidateUserAttemptsForUser(quizId));
        promises.push($mmaModQuiz.invalidateQuizAccessInformation(quizId));
        promises.push($mmaModQuiz.invalidateCombinedReviewOptionsForUser(quizId));
        promises.push($mmaModQuiz.invalidateAttemptReview(attemptId));
        if (typeof attempt.feedback != 'undefined') {
            promises.push($mmaModQuiz.invalidateFeedback(quizId));
        }
        return $q.all(promises).finally(function() {
            return fetchData();
        });
    }
    fetchData().finally(function() {
        $scope.attemptLoaded = true;
    });
    $scope.refreshAttempt = function() {
        refreshData().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
}]);

angular.module('mm.addons.mod_quiz')
.controller('mmaModQuizIndexCtrl', ["$scope", "$stateParams", "$mmaModQuiz", "$mmCourse", "$ionicPlatform", "$q", "$translate", "$mmaModQuizHelper", "$ionicHistory", "$ionicScrollDelegate", "$mmEvents", "mmaModQuizEventAttemptFinished", "$state", "$mmQuestionBehaviourDelegate", "$mmaModQuizSync", "$mmText", "$mmUtil", "$mmCourseHelper", "mmaModQuizEventAutomSynced", "$mmSite", "$mmCoursePrefetchDelegate", "mmCoreDownloaded", "mmCoreDownloading", "mmCoreEventPackageStatusChanged", "mmaModQuizComponent", "$mmaModQuizPrefetchHandler", "$mmApp", "mmCoreEventOnlineStatusChanged", function($scope, $stateParams, $mmaModQuiz, $mmCourse, $ionicPlatform, $q, $translate,
            $mmaModQuizHelper, $ionicHistory, $ionicScrollDelegate, $mmEvents, mmaModQuizEventAttemptFinished, $state,
            $mmQuestionBehaviourDelegate, $mmaModQuizSync, $mmText, $mmUtil, $mmCourseHelper, mmaModQuizEventAutomSynced, $mmSite,
            $mmCoursePrefetchDelegate, mmCoreDownloaded, mmCoreDownloading, mmCoreEventPackageStatusChanged,
            mmaModQuizComponent, $mmaModQuizPrefetchHandler, $mmApp, mmCoreEventOnlineStatusChanged) {
    var module = $stateParams.module || {},
        courseId = $stateParams.courseid,
        quiz,
        overallStats,
        attempts,
        options,
        bestGrade,
        gradebookData,
        quizAccessInfo,
        attemptAccessInfo,
        moreAttempts,
        scrollView = $ionicScrollDelegate.$getByHandle('mmaModQuizIndexScroll'),
        autoReview,
        currentStatus,
        statusObserver, obsFinished, syncObserver, onlineObserver;
    $scope.title = module.name;
    $scope.description = module.description;
    $scope.moduleUrl = module.url;
    $scope.moduleName = $mmCourse.translateModuleName('quiz');
    $scope.isTablet = $ionicPlatform.isTablet();
    $scope.courseId = courseId;
    $scope.refreshIcon = 'spinner';
    $scope.syncIcon = 'spinner';
    $scope.component = mmaModQuizComponent;
    $scope.componentId = module.id;
    function fetchQuizData(refresh, showErrors) {
        $scope.isOnline = $mmApp.isOnline();
        return $mmaModQuiz.getQuiz(courseId, module.id).then(function(quizData) {
            quiz = quizData;
            quiz.gradeMethodReadable = $mmaModQuiz.getQuizGradeMethod(quiz.grademethod);
            $scope.now = new Date().getTime();
            $scope.title = quiz.name || $scope.title;
            $scope.description = quiz.intro || $scope.description;
            return $mmaModQuizSync.getSyncWarnings(quiz.id).then(function(warnings) {
                if (warnings && warnings.length) {
                    $mmUtil.showErrorModal($mmText.buildMessage(warnings));
                    return $mmaModQuizSync.setSyncWarnings(quiz.id, []);
                }
            });
        }).then(function() {
            if ($mmaModQuiz.isQuizOffline(quiz)) {
                return syncQuiz(showErrors).catch(function() {
                    autoReview = undefined;
                });
            } else {
                autoReview = undefined;
            }
        }).then(function() {
            if ($mmaModQuiz.isQuizOffline(quiz)) {
                $mmaModQuizHelper.getQuizReadableSyncTime(quiz.id).then(function(syncTime) {
                    $scope.syncTime = syncTime;
                });
                $mmaModQuizSync.hasDataToSync(quiz.id).then(function(hasOffline) {
                    $scope.hasOffline = hasOffline;
                });
            }
            return $mmaModQuiz.getQuizAccessInformation(quiz.id).then(function(info) {
                quizAccessInfo = info;
                $scope.accessRules = quizAccessInfo.accessrules;
                quiz.showReviewColumn = quizAccessInfo.canreviewmyattempts;
                $scope.unsupportedRules = $mmaModQuiz.getUnsupportedRules(quizAccessInfo.activerulenames);
                if (quiz.preferredbehaviour) {
                    $scope.behaviourSupported = $mmQuestionBehaviourDelegate.isBehaviourSupported(quiz.preferredbehaviour);
                }
                return $mmaModQuiz.getQuizRequiredQtypes(quiz.id).then(function(types) {
                    $scope.unsupportedQuestions = $mmaModQuiz.getUnsupportedQuestions(types);
                    return getAttempts();
                });
            });
        }).then(function() {
            $scope.quiz = quiz;
            $mmCourseHelper.fillContextMenu($scope, module, courseId, refresh, mmaModQuizComponent);
        }).catch(function(message) {
            if (!refresh && !quiz) {
                return refreshData();
            }
            return $mmaModQuizHelper.showError(message);
        });
    }
    function getAttempts() {
        return $mmaModQuiz.getAttemptAccessInformation(quiz.id, 0).then(function(info) {
            attemptAccessInfo = info;
            return $mmaModQuiz.getUserAttempts(quiz.id).then(function(atts) {
                attempts = atts;
                if ($mmaModQuiz.isQuizOffline(quiz)) {
                    setStatusListener();
                    getStatus().then(showStatus);
                }
                return treatAttempts().then(function() {
                    if (attempts.length) {
                        var lastAttempt = attempts[attempts.length - 1];
                        moreAttempts = !$mmaModQuiz.isAttemptFinished(lastAttempt.state) || !attemptAccessInfo.isfinished;
                    } else {
                        moreAttempts = !attemptAccessInfo.isfinished;
                    }
                    $scope.attempts = attempts;
                    getButtonText();
                    return getResultInfo();
                });
            });
        });
    }
    function treatAttempts() {
        if (!attempts || !attempts.length) {
            return $q.when();
        }
        var lastFinished = $mmaModQuiz.getLastFinishedAttemptFromList(attempts),
            promises = [];
        if (autoReview && lastFinished && lastFinished.id >= autoReview.attemptId) {
            if (!$scope.$$destroyed && $state.current.name == 'site.mod_quiz') {
                promises.push(goToAutoReview());
            }
            autoReview = undefined;
        }
        promises.push($mmaModQuiz.loadFinishedOfflineData(attempts));
        promises.push($mmaModQuiz.getCombinedReviewOptions(quiz.id).then(function(result) {
            options = result;
        }));
        promises.push($mmaModQuiz.getUserBestGrade(quiz.id).then(function(best) {
            bestGrade = best;
            return $mmaModQuiz.getGradeFromGradebook(courseId, module.id).then(function(data) {
                gradebookData = {
                    grade: data.gradeformatted,
                    feedback: data.feedback
                };
            }).catch(function() {
                gradebookData = {
                    grade: bestGrade.grade
                };
            });
        }));
        return $q.all(promises).then(function() {
            var quizGrade = typeof gradebookData.grade != 'undefined' ? gradebookData.grade : bestGrade.grade;
            quizGrade = $mmaModQuiz.formatGrade(quizGrade, quiz.decimalpoints);
            $mmaModQuizHelper.setQuizCalculatedData(quiz, options);
            overallStats = lastFinished && options.alloptions.marks >= $mmaModQuiz.QUESTION_OPTIONS_MARK_AND_MAX;
            angular.forEach(attempts, function(attempt) {
                var shouldHighlight = overallStats && quiz.grademethod == $mmaModQuiz.GRADEHIGHEST && attempts.length > 1;
                $mmaModQuizHelper.setAttemptCalculatedData(quiz, attempt, shouldHighlight, quizGrade);
            });
        });
    }
    function getResultInfo() {
        if (attempts.length && quiz.showGradeColumn && bestGrade.hasgrade && typeof gradebookData.grade != 'undefined') {
            var formattedGradebookGrade = $mmaModQuiz.formatGrade(gradebookData.grade, quiz.decimalpoints),
                formattedBestGrade = $mmaModQuiz.formatGrade(bestGrade.grade, quiz.decimalpoints),
                gradeToShow = formattedGradebookGrade;
            $scope.showResults = true;
            $scope.gradeOverridden = formattedGradebookGrade != formattedBestGrade;
            $scope.gradebookFeedback = gradebookData.feedback;
            if (formattedBestGrade > formattedGradebookGrade && formattedGradebookGrade == quiz.grade) {
                $scope.gradeOverridden = false;
                gradeToShow = formattedBestGrade;
            }
            if (overallStats) {
                if (moreAttempts) {
                    $scope.gradeResult = $translate.instant('mma.mod_quiz.gradesofar', {$a: {
                        method: quiz.gradeMethodReadable,
                        mygrade: gradeToShow,
                        quizgrade: quiz.gradeFormatted
                    }});
                } else {
                    var outOfShort = $translate.instant('mma.mod_quiz.outofshort', {$a: {
                        grade: gradeToShow,
                        maxgrade: quiz.gradeFormatted
                    }});
                    $scope.gradeResult = $translate.instant('mma.mod_quiz.yourfinalgradeis', {$a: outOfShort});
                }
            }
            if (quiz.showFeedbackColumn) {
                return $mmaModQuiz.getFeedbackForGrade(quiz.id, gradebookData.grade).then(function(response) {
                    $scope.overallFeedback = response.feedbacktext;
                });
            }
        } else {
            $scope.showResults = false;
        }
        return $q.when();
    }
    function getButtonText() {
        $scope.buttonText = '';
        if (quiz.hasquestions !== 0) {
            if (attempts.length && !$mmaModQuiz.isAttemptFinished(attempts[attempts.length - 1].state)) {
                if (quizAccessInfo.canattempt) {
                    $scope.buttonText = 'mma.mod_quiz.continueattemptquiz';
                } else if (quizAccessInfo.canpreview) {
                    $scope.buttonText = 'mma.mod_quiz.continuepreview';
                }
            } else {
                if (quizAccessInfo.canattempt) {
                    $scope.preventMessages = attemptAccessInfo.preventnewattemptreasons;
                    if (!$scope.preventMessages.length) {
                        if (!attempts.length) {
                            $scope.buttonText = 'mma.mod_quiz.attemptquiznow';
                        } else {
                            $scope.buttonText = 'mma.mod_quiz.reattemptquiz';
                        }
                    }
                } else if (quizAccessInfo.canpreview) {
                    $scope.buttonText = 'mma.mod_quiz.previewquiznow';
                }
            }
        }
        if ($scope.buttonText) {
            $scope.preventMessages = quizAccessInfo.preventaccessreasons;
            if (!moreAttempts) {
                $scope.buttonText = '';
            } else if (quizAccessInfo.canattempt && $scope.preventMessages.length) {
                $scope.buttonText = '';
            } else if ($scope.unsupportedQuestions.length || $scope.unsupportedRules.length || !$scope.behaviourSupported) {
                $scope.buttonText = '';
            }
        }
    }
    function refreshData(dontForceSync) {
        var promises = [];
        promises.push($mmaModQuiz.invalidateQuizData(courseId));
        if (quiz) {
            promises.push($mmaModQuiz.invalidateUserAttemptsForUser(quiz.id));
            promises.push($mmaModQuiz.invalidateQuizAccessInformation(quiz.id));
            promises.push($mmaModQuiz.invalidateQuizRequiredQtypes(quiz.id));
            promises.push($mmaModQuiz.invalidateAttemptAccessInformation(quiz.id));
            promises.push($mmaModQuiz.invalidateCombinedReviewOptionsForUser(quiz.id));
            promises.push($mmaModQuiz.invalidateUserBestGradeForUser(quiz.id));
            promises.push($mmaModQuiz.invalidateGradeFromGradebook(courseId));
        }
        return $q.all(promises).finally(function() {
            return fetchQuizData(!dontForceSync);
        });
    }
    function syncQuiz(showErrors) {
        return $mmaModQuizSync.syncQuiz(quiz, true).then(function(data) {
            if (data) {
                var message = $mmText.buildMessage(data.warnings);
                if (message) {
                    $mmUtil.showErrorModal(message);
                }
                if (data.attemptFinished) {
                    $mmCourse.checkModuleCompletion(courseId, module.completionstatus);
                }
            }
        }).catch(function(err) {
            if (showErrors) {
                return $mmaModQuizHelper.showError(err, 'mma.mod_quiz.errorsyncquiz');
            }
            return $q.reject();
        });
    }
    function goToAutoReview() {
        $mmCourse.checkModuleCompletion(courseId, module.completionstatus);
        var attemptId = autoReview.attemptId;
        if (quizAccessInfo.canreviewmyattempts) {
            return $mmaModQuiz.getAttemptReview(attemptId, -1).then(function() {
                return $state.go('site.mod_quiz-review', {courseid: courseId, quizid: quiz.id, attemptid: attemptId});
            }).catch(function() {
            });
        }
        return $q.when();
    }
    function openQuiz() {
        $state.go('site.mod_quiz-player', {
            courseid: courseId,
            quizid: quiz.id,
            moduleurl: module.url
        });
    }
    function getStatus() {
        var revision = $mmaModQuizPrefetchHandler.getRevisionFromAttempts(attempts),
            timemodified = $mmaModQuizPrefetchHandler.getTimemodifiedFromAttempts(attempts);
        return $mmCoursePrefetchDelegate.getModuleStatus(module, courseId, revision, timemodified);
    }
    function setStatusListener() {
        if (typeof statusObserver !== 'undefined') {
            return;
        }
        statusObserver = $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
            if (data.siteid === $mmSite.getId() && data.componentId === module.id &&
                    data.component === mmaModQuizComponent) {
                showStatus(data.status);
            }
        });
    }
    function showStatus(status) {
        currentStatus = status;
        if (status == mmCoreDownloading) {
            $scope.showSpinner = true;
        }
    }
    fetchQuizData().then(function() {
        $mmaModQuiz.logViewQuiz(quiz.id).then(function() {
            $mmCourse.checkModuleCompletion(courseId, module.completionstatus);
        });
    }).finally(function() {
        $scope.quizLoaded = true;
        $scope.refreshIcon = 'ion-refresh';
        $scope.syncIcon = 'ion-loop';
    });
    $scope.refreshQuiz = function(showErrors) {
        if ($scope.quizLoaded) {
            $scope.refreshIcon = 'spinner';
            $scope.syncIcon = 'spinner';
            return refreshData(false, showErrors).finally(function() {
                $scope.refreshIcon = 'ion-refresh';
                $scope.syncIcon = 'ion-loop';
                $scope.$broadcast('scroll.refreshComplete');
            });
        }
    };
    $scope.attemptQuiz = function() {
        if ($scope.showSpinner) {
            return;
        }
        if ($mmaModQuiz.isQuizOffline(quiz)) {
            if (currentStatus != mmCoreDownloaded) {
                $scope.showSpinner = true;
                return $mmaModQuizPrefetchHandler.prefetch(module, courseId, true).then(function() {
                    openQuiz();
                }).catch(function(error) {
                    $mmaModQuizHelper.showError(error, 'mma.mod_quiz.errordownloading');
                }).finally(function() {
                    $scope.showSpinner = false;
                });
            } else {
                openQuiz();
            }
        } else {
            openQuiz();
        }
    };
    $scope.removeFiles = function() {
        $mmCourseHelper.confirmAndRemove(module, courseId);
    };
    $scope.prefetch = function() {
        $mmCourseHelper.contextMenuPrefetch($scope, module, courseId);
    };
    $scope.expandDescription = function() {
        $mmText.expandText($translate.instant('mm.core.description'), $scope.description, false, mmaModQuizComponent, module.id);
    };
    var skip = true;
    $scope.$on('$ionicView.enter', function() {
        if (skip) {
            skip = false;
            return;
        }
        var forwardView = $ionicHistory.forwardView(),
            promise;
        if (forwardView && forwardView.stateName === 'site.mod_quiz-player') {
            if (autoReview && autoReview.synced) {
                promise = goToAutoReview();
                autoReview = undefined;
            } else {
                promise = $q.when();
            }
            $scope.quizLoaded = false;
            $scope.refreshIcon = 'spinner';
            $scope.syncIcon = 'spinner';
            scrollView.scrollTop();
            promise.then(function() {
                refreshData().finally(function() {
                    $scope.quizLoaded = true;
                    $scope.refreshIcon = 'ion-refresh';
                    $scope.syncIcon = 'ion-loop';
                });
            });
        } else {
            autoReview = undefined;
        }
    });
    $scope.$on('$ionicView.leave', function() {
        autoReview = undefined;
    });
    onlineObserver = $mmEvents.on(mmCoreEventOnlineStatusChanged, function(online) {
        $scope.isOnline = online;
    });
    obsFinished = $mmEvents.on(mmaModQuizEventAttemptFinished, function(data) {
        if (data.quizId === quiz.id) {
            autoReview = data;
        }
    });
    syncObserver = $mmEvents.on(mmaModQuizEventAutomSynced, function(data) {
        if (data && data.siteid == $mmSite.getId() && data.quizid == quiz.id) {
            $scope.quizLoaded = false;
            $scope.refreshIcon = 'spinner';
            $scope.syncIcon = 'spinner';
            scrollView.scrollTop();
            fetchQuizData().finally(function() {
                $scope.quizLoaded = true;
                $scope.refreshIcon = 'ion-refresh';
                $scope.syncIcon = 'ion-loop';
            });
            if (data.attemptFinished) {
                $mmCourse.checkModuleCompletion(courseId, module.completionstatus);
            }
        }
    });
    $scope.$on('$destroy', function() {
        obsFinished && obsFinished.off && obsFinished.off();
        syncObserver && syncObserver.off && syncObserver.off();
        statusObserver && statusObserver.off && statusObserver.off();
        onlineObserver && onlineObserver.off && onlineObserver.off();
    });
}]);

angular.module('mm.addons.mod_quiz')
.controller('mmaModQuizPlayerCtrl', ["$log", "$scope", "$stateParams", "$mmaModQuiz", "$mmaModQuizHelper", "$q", "$mmUtil", "$mmSyncBlock", "$ionicPopover", "$ionicScrollDelegate", "$translate", "$timeout", "$mmQuestionHelper", "$mmaModQuizAutoSave", "$mmEvents", "mmaModQuizEventAttemptFinished", "$mmSideMenu", "mmaModQuizComponent", "$mmaModQuizSync", function($log, $scope, $stateParams, $mmaModQuiz, $mmaModQuizHelper, $q, $mmUtil, $mmSyncBlock,
            $ionicPopover, $ionicScrollDelegate, $translate, $timeout, $mmQuestionHelper, $mmaModQuizAutoSave, $mmEvents,
            mmaModQuizEventAttemptFinished, $mmSideMenu, mmaModQuizComponent, $mmaModQuizSync) {
    $log = $log.getInstance('mmaModQuizPlayerCtrl');
    var quizId = $stateParams.quizid,
        courseId = $stateParams.courseid,
        moduleUrl = $stateParams.moduleurl,
        quiz,
        quizAccessInfo,
        attemptAccessInfo,
        attempt,
        newAttempt,
        timeUpCalled = false,
        scrollView = $ionicScrollDelegate.$getByHandle('mmaModQuizPlayerScroll'),
        offline,
        blockData;
    $mmSyncBlock.blockOperation(mmaModQuizComponent, quizId);
    blockData = $mmUtil.blockLeaveView($scope, leavePlayer);
    $scope.moduleUrl = moduleUrl;
    $scope.component = mmaModQuizComponent;
    $scope.quizAborted = false;
    $scope.preflightData = {};
    $scope.preflightModalTitle = 'mma.mod_quiz.startattempt';
    function start(fromModal) {
        var promise;
        $scope.dataLoaded = false;
        if (typeof password != 'undefined') {
            promise = startOrContinueAttempt(fromModal);
        } else {
            promise = fetchData().then(function() {
                return startOrContinueAttempt(fromModal);
            });
        }
        promise.finally(function() {
            $scope.dataLoaded = true;
        });
    }
    function fetchData() {
        return $mmaModQuizSync.waitForSync(quizId).then(function() {
            return $mmaModQuiz.getQuizById(courseId, quizId);
        }).then(function(quizData) {
            quiz = quizData;
            quiz.isSequential = $mmaModQuiz.isNavigationSequential(quiz);
            if ($mmaModQuiz.isQuizOffline(quiz)) {
                return true;
            } else {
                return $mmaModQuiz.isLastAttemptOfflineUnfinished(quiz);
            }
        }).then(function(offlineMode) {
            offline = offlineMode;
            $scope.offline = offline;
            if (quiz.timelimit > 0) {
                $scope.isTimed = true;
                $mmUtil.formatTime(quiz.timelimit).then(function(time) {
                    quiz.readableTimeLimit = time;
                });
            }
            $scope.quiz = quiz;
            return $mmaModQuiz.getQuizAccessInformation(quiz.id, offline, true);
        }).then(function(info) {
            quizAccessInfo = info;
            return $mmaModQuiz.getUserAttempts(quiz.id, 'all', true, offline, true);
        }).then(function(attempts) {
            if (!attempts.length) {
                newAttempt = true;
            } else {
                var promises = [];
                attempt = attempts[attempts.length - 1];
                newAttempt = $mmaModQuiz.isAttemptFinished(attempt.state);
                promises.push($mmaModQuizSync.getSyncTime(quiz.id).then(function(time) {
                    attempt.quizSyncTime = time;
                    quiz.syncTimeReadable = $mmaModQuizHelper.getReadableTimeFromTimestamp(time);
                }));
                promises.push($mmaModQuiz.loadFinishedOfflineData(attempts));
                return $q.all(promises);
            }
        }).catch(function(message) {
            return $mmaModQuizHelper.showError(message);
        });
    }
    function startOrContinueAttempt(fromModal) {
        var att = newAttempt ? undefined : attempt;
        return $mmaModQuiz.checkPreflightData($scope, quiz, quizAccessInfo, att, offline, fromModal).then(function(att) {
            return $mmaModQuiz.getAttemptAccessInformation(quiz.id, att.id, offline, true).then(function(info) {
                attemptAccessInfo = info;
                attempt = att;
                $scope.attempt = attempt;
                return loadToc();
            }).catch(function(message) {
                return $mmaModQuizHelper.showError(message, 'mm.core.error');
            }).then(function() {
                if (attempt.state != $mmaModQuiz.ATTEMPT_OVERDUE && !attempt.finishedOffline) {
                    return loadPage(attempt.currentpage).then(function() {
                        initTimer();
                    }).catch(function(message) {
                        return $mmaModQuizHelper.showError(message, 'mm.core.error');
                    });
                } else {
                    return loadSummary();
                }
            });
        }).catch(function(error) {
            if (error) {
                return $mmaModQuizHelper.showError(error, 'mm.core.error');
            }
        });
    }
    function loadToc() {
        return $mmaModQuiz.getAttemptSummary(attempt.id, $scope.preflightData, offline).then(function(questions) {
            $scope.toc = questions;
        });
    }
    function loadPage(page) {
        return $mmaModQuiz.getAttemptData(attempt.id, page, $scope.preflightData, offline, true).then(function(data) {
            attempt = data.attempt;
            attempt.currentpage = page;
            $scope.attempt = attempt;
            $scope.questions = data.questions;
            $scope.nextPage = data.nextpage;
            $scope.previousPage = quiz.isSequential ? -1 : page - 1;
            $scope.showSummary = false;
            angular.forEach($scope.questions, function(question) {
                question.readableMark = $mmaModQuizHelper.getQuestionMarkFromHtml(question.html);
                $mmQuestionHelper.extractQuestionInfoBox(question, '.info');
                question.preferredBehaviour = quiz.preferredbehaviour;
                if ($mmaModQuiz.isQuestionBlocked(question)) {
                    question.type = 'description';
                }
            });
            $mmaModQuiz.logViewAttempt(attempt.id, page, $scope.preflightData, offline);
            $mmaModQuizAutoSave.startCheckChangesProcess($scope, quiz, attempt);
        });
    }
    function loadSummary() {
        $scope.showSummary = true;
        $scope.summaryQuestions = [];
        return $mmaModQuiz.getAttemptSummary(attempt.id, $scope.preflightData, offline, true, true).then(function(questions) {
            $scope.summaryQuestions = questions;
            $scope.canReturn = attempt.state == $mmaModQuiz.ATTEMPT_IN_PROGRESS && !attempt.finishedOffline;
            $scope.preventSubmitMessages = $mmaModQuiz.getPreventSubmitMessages(questions);
            attempt.dueDateWarning = $mmaModQuiz.getAttemptDueDateWarning(quiz, attempt);
            $mmaModQuiz.logViewAttemptSummary(attempt.id, $scope.preflightData);
        }).catch(function(message) {
            $scope.showSummary = false;
            return $mmaModQuizHelper.showError(message, 'mma.mod_quiz.errorgetquestions');
        });
    }
    function getAnswers() {
        return $mmQuestionHelper.getAnswersFromForm(document.forms['mma-mod_quiz-player-form']);
    }
    function processAttempt(finish, timeup) {
        return $mmaModQuiz.processAttempt(quiz, attempt, getAnswers(), $scope.preflightData, finish, timeup, offline)
                .then(function() {
            $mmaModQuizAutoSave.cancelAutoSave();
            $mmaModQuizAutoSave.hideAutoSaveError($scope);
        });
    }
    function leavePlayer() {
        var promise,
            modal;
        if ($scope.questions && $scope.questions.length && !$scope.showSummary) {
            modal = $mmUtil.showModalLoading('mm.core.sending', true);
            promise = processAttempt(false, false);
        } else {
            promise = $q.when();
        }
        return promise.catch(function() {
            modal && modal.dismiss();
            return $mmUtil.showConfirm($translate('mma.mod_quiz.confirmleavequizonerror'));
        }).finally(function() {
            modal && modal.dismiss();
        });
    }
    function finishAttempt(finish, timeup) {
        var promise;
        if (!timeup && attempt.state == $mmaModQuiz.ATTEMPT_IN_PROGRESS) {
            promise = $mmUtil.showConfirm($translate('mma.mod_quiz.confirmclose'));
        } else {
            promise = $q.when();
        }
        return promise.then(function() {
            var modal = $mmUtil.showModalLoading('mm.core.sending', true);
            return processAttempt(finish, timeup).then(function() {
                $mmEvents.trigger(mmaModQuizEventAttemptFinished, {quizId: quiz.id, attemptId: attempt.id, synced: !offline});
                blockData && blockData.back();
            }).catch(function(message) {
                return $mmaModQuizHelper.showError(message, 'mma.mod_quiz.errorsaveattempt');
            }).finally(function() {
                modal.dismiss();
            });
        });
    }
    function initTimer() {
        if (attemptAccessInfo.endtime > 0) {
            if ($mmaModQuiz.shouldShowTimeLeft(quizAccessInfo.activerulenames, attempt, attemptAccessInfo.endtime)) {
                $scope.endTime = attemptAccessInfo.endtime;
            } else {
                delete $scope.endTime;
            }
        }
    }
    function scrollToQuestion(slot) {
        $mmUtil.scrollToElement(document, '#mma-mod_quiz-question-' + slot, scrollView);
    }
    $mmaModQuizAutoSave.init($scope, 'mma-mod_quiz-player-form', 'conErrPopover', '#mma-mod_quiz-connectionerror-button');
    start();
    $scope.start = function(fromModal) {
        start(fromModal);
    };
    $scope.abortQuiz = function() {
        $scope.quizAborted = true;
    };
    $scope.behaviourButtonClicked = function(name, value) {
        $mmUtil.showConfirm($translate('mm.core.areyousure')).then(function() {
            var modal = $mmUtil.showModalLoading('mm.core.sending', true),
                answers = getAnswers();
            answers[name] = value;
            $mmaModQuiz.processAttempt(quiz, attempt, answers, $scope.preflightData, false, false, false).then(function() {
                var scrollPos = scrollView.getScrollPosition();
                $scope.dataLoaded = false;
                scrollView.scrollTop();
                return loadPage(attempt.currentpage).finally(function() {
                    $scope.dataLoaded = true;
                    scrollView.resize();
                    if (scrollPos) {
                        scrollView.scrollTo(scrollPos.left, scrollPos.top);
                    }
                });
            }).catch(function(message) {
                return $mmaModQuizHelper.showError(message, 'Error performing action.');
            }).finally(function() {
                modal.dismiss();
            });
        });
    };
    $scope.loadPage = function(page, fromToc, slot) {
        if (page != -1 && (attempt.state == $mmaModQuiz.ATTEMPT_OVERDUE || attempt.finishedOffline)) {
            return;
        } else if (page == attempt.currentpage && !$scope.showSummary && typeof slot != 'undefined') {
            scrollToQuestion(slot);
            return;
        } else if ((page == attempt.currentpage && !$scope.showSummary) || (fromToc && quiz.isSequential && page != -1)) {
            return;
        } else if (page === -1 && $scope.showSummary) {
            return;
        }
        var promise;
        $scope.dataLoaded = false;
        scrollView.scrollTop();
        promise = $scope.showSummary ? $q.when() : processAttempt(false, false);
        promise.catch(function(message) {
            return $mmaModQuizHelper.showError(message, 'mma.mod_quiz.errorsaveattempt');
        }).then(function() {
            if (page === -1) {
                return loadSummary();
            } else {
                $mmaModQuizAutoSave.stopCheckChangesProcess();
                return loadPage(page).catch(function(message) {
                    $mmaModQuizAutoSave.startCheckChangesProcess($scope, quiz, attempt);
                    return $mmaModQuizHelper.showError(message, 'mma.mod_quiz.errorgetquestions');
                });
            }
        }).finally(function() {
            $scope.dataLoaded = true;
            scrollView.resize();
            if (typeof slot != 'undefined') {
                $timeout(function() {
                    scrollToQuestion(slot);
                }, 2000);
            }
        });
    };
    $scope.finishAttempt = function() {
        finishAttempt(true);
    };
    $scope.timeUp = function() {
        if (timeUpCalled) {
            return;
        }
        timeUpCalled = true;
        var modal = $mmUtil.showModalLoading('mm.core.sending', true);
        finishAttempt(false, true).finally(function() {
            modal.dismiss();
        });
    };
    $mmSideMenu.showRightSideMenu('addons/mod/quiz/templates/toc.html', $scope);
    $ionicPopover.fromTemplateUrl('addons/mod/quiz/templates/connectionerror.html', {
        scope: $scope,
    }).then(function(popover) {
        $scope.conErrPopover = popover;
    });
    $scope.$on('$destroy', function() {
        $mmaModQuizAutoSave.stopAutoSaving();
        $mmaModQuizAutoSave.stopCheckChangesProcess();
        $mmSyncBlock.unblockOperation(mmaModQuizComponent, quizId);
    });
}]);

angular.module('mm.addons.mod_quiz')
.controller('mmaModQuizReviewCtrl', ["$log", "$scope", "$stateParams", "$mmaModQuiz", "$mmaModQuizHelper", "$mmUtil", "$ionicScrollDelegate", "$translate", "$q", "mmaModQuizComponent", "$mmQuestionHelper", "$mmSideMenu", "$timeout", function($log, $scope, $stateParams, $mmaModQuiz, $mmaModQuizHelper, $mmUtil,
            $ionicScrollDelegate, $translate, $q, mmaModQuizComponent, $mmQuestionHelper, $mmSideMenu, $timeout) {
    $log = $log.getInstance('mmaModQuizReviewCtrl');
    var quizId = $stateParams.quizid,
        courseId = $stateParams.courseid,
        attemptId = $stateParams.attemptid,
        currentPage = $stateParams.page,
        quiz,
        options,
        attempt,
        errorPasing = false,
        scrollView = $ionicScrollDelegate.$getByHandle('mmaModQuizReviewScroll');
    $scope.isReview = true;
    $scope.component = mmaModQuizComponent;
    $scope.showAll = currentPage == -1;
    function fetchData() {
        return $mmaModQuiz.getQuizById(courseId, quizId).then(function(quizData) {
            quiz = quizData;
            $scope.componentId = quiz.coursemodule;
            return $mmaModQuiz.getCombinedReviewOptions(quiz.id).then(function(result) {
                options = result;
                return loadToc().then(function() {
                    return loadPage(currentPage);
                });
            });
        }).catch(function(message) {
            return $mmaModQuizHelper.showError(message);
        });
    }
    function loadToc() {
        return $mmaModQuiz.getAttemptReview(attemptId, -1).then(function(reviewData) {
            var lastQuestion = reviewData.questions[reviewData.questions.length - 1];
            angular.forEach(reviewData.questions, function(question) {
                question.stateClass = $mmQuestionHelper.getQuestionStateClass(question.state);
            });
            $scope.toc = reviewData.questions;
            $scope.numPages = lastQuestion ? lastQuestion.page + 1 : 0;
        });
    }
    function loadPage(page) {
        return $mmaModQuiz.getAttemptReview(attemptId, page).then(function(reviewData) {
            currentPage = page;
            attempt = reviewData.attempt;
            setSummaryCalculatedData(reviewData);
            $scope.attempt = attempt;
            $scope.questions = reviewData.questions;
            $scope.nextPage = page == -1 ? undefined : page + 1;
            $scope.previousPage = page - 1;
            attempt.currentpage = page;
            angular.forEach($scope.questions, function(question) {
                question.readableMark = $mmaModQuizHelper.getQuestionMarkFromHtml(question.html);
                $mmQuestionHelper.extractQuestionInfoBox(question, '.info');
                question.preferredBehaviour = quiz.preferredbehaviour;
            });
        });
    }
    function setSummaryCalculatedData(reviewData) {
        var timeTaken,
            grade = reviewData.grade,
            gradeObject;
        attempt.readableState = $mmaModQuiz.getAttemptReadableStateName(attempt.state);
        if (attempt.state == $mmaModQuiz.ATTEMPT_FINISHED) {
            $scope.showCompleted = true;
            $scope.additionalData = reviewData.additionaldata;
            timeTaken = attempt.timefinish - attempt.timestart;
            if (timeTaken) {
                $mmUtil.formatTime(timeTaken).then(function(takenTime) {
                    attempt.timeTaken = takenTime;
                });
                if (quiz.timelimit && timeTaken > quiz.timelimit + 60) {
                    $mmUtil.formatTime(timeTaken - quiz.timelimit).then(function(overTime) {
                        attempt.overTime = overTime;
                    });
                }
            }
            if (options.someoptions.marks >= $mmaModQuiz.QUESTION_OPTIONS_MARK_AND_MAX && $mmaModQuiz.quizHasGrades(quiz)) {
                if (grade === null || typeof grade == 'undefined') {
                    attempt.readableGrade = $mmaModQuiz.formatGrade(grade, quiz.decimalpoints);
                } else {
                    if (quiz.grade != quiz.sumgrades) {
                        attempt.readableMark = $translate.instant('mma.mod_quiz.outofshort', {$a: {
                            grade: $mmaModQuiz.formatGrade(attempt.sumgrades, quiz.decimalpoints),
                            maxgrade: $mmaModQuiz.formatGrade(quiz.sumgrades, quiz.decimalpoints)
                        }});
                    }
                    gradeObject = {
                        grade: $mmaModQuiz.formatGrade(grade, quiz.decimalpoints),
                        maxgrade: $mmaModQuiz.formatGrade(quiz.grade, quiz.decimalpoints)
                    };
                    if (quiz.grade != 100) {
                        gradeObject.percent = $mmUtil.roundToDecimals(attempt.sumgrades * 100 / quiz.sumgrades, 0);
                        attempt.readableGrade = $translate.instant('mma.mod_quiz.outofpercent', {$a: gradeObject});
                    } else {
                        attempt.readableGrade = $translate.instant('mma.mod_quiz.outof', {$a: gradeObject});
                    }
                }
            }
            angular.forEach($scope.additionalData, function(data) {
                data.content = $mmUtil.removeElementFromHtml(data.content, '.helptooltip');
            });
        }
    }
    function refreshData() {
        var promises = [];
        promises.push($mmaModQuiz.invalidateQuizData(courseId));
        promises.push($mmaModQuiz.invalidateCombinedReviewOptionsForUser(quizId));
        promises.push($mmaModQuiz.invalidateAttemptReview(attemptId));
        return $q.all(promises).finally(function() {
            return fetchData();
        });
    }
    function scrollToQuestion(slot) {
        $mmUtil.scrollToElement(document, '#mma-mod_quiz-question-' + slot, scrollView);
    }
    fetchData().then(function() {
        $mmaModQuiz.logViewAttemptReview(attemptId);
    }).finally(function() {
        $scope.dataLoaded = true;
    });
    $scope.loadPage = function(page, fromToc, slot) {
        if (typeof slot != 'undefined' && (attempt.currentpage == -1 || page == currentPage)) {
            scrollToQuestion(slot);
            return;
        } else if (page == currentPage) {
            return;
        }
        $scope.dataLoaded = false;
        scrollView.scrollTop();
        return loadPage(page).catch(function(message) {
            return $mmaModQuizHelper.showError(message);
        }).finally(function() {
            $scope.dataLoaded = true;
            scrollView.resize();
            if (typeof slot != 'undefined') {
                $timeout(function() {
                    scrollToQuestion(slot);
                }, 2000);
            }
        });
    };
    $scope.switchMode = function() {
        $scope.showAll = !$scope.showAll;
        $scope.loadPage($scope.showAll ? -1 : 0);
    };
    $scope.refreshData = function() {
        refreshData().finally(function() {
            $scope.$broadcast('scroll.refreshComplete');
        });
    };
    $scope.abortQuiz = function() {
        if (!errorPasing) {
            errorPasing = true;
            $mmUtil.showErrorModal('mma.mod_quiz.errorparsequestions', true);
        }
    };
    $mmSideMenu.showRightSideMenu('addons/mod/quiz/templates/toc.html', $scope);
}]);

angular.module('mm.addons.mod_quiz')
.directive('mmaQuizAccessRule', ["$log", "$compile", function($log, $compile) {
    $log = $log.getInstance('mmaQuizAccessRule');
    return {
        restrict: 'E',
        templateUrl: 'addons/mod/quiz/templates/accessrule.html',
        link: function(scope, element) {
            var directive = scope.directive,
                container = element[0].querySelector('.mma-quiz-accessrule-container');
            if (directive && container) {
                container.setAttribute(directive, '');
                $compile(container)(scope);
            }
        }
    };
}]);

angular.module('mm.addons.mod_quiz')
.directive('mmaModQuizArrows', function() {
    return {
        restrict: 'E',
        scope: {
            previous: '=?',
            next: '=?',
            action: '=?'
        },
        templateUrl: 'addons/mod/quiz/templates/arrows.html'
    };
});

angular.module('mm.addons.mod_quiz')
.factory('$mmaModQuizAccessRulesDelegate', ["$log", "$q", "$mmUtil", "$mmSite", function($log, $q, $mmUtil, $mmSite) {
    $log = $log.getInstance('$mmaModQuizAccessRulesDelegate');
    var handlers = {},
        enabledHandlers = {},
        self = {},
        updatePromises = {},
        lastUpdateHandlersStart;
        self.getAccessRuleHandler = function(ruleName) {
        if (typeof enabledHandlers[ruleName] != 'undefined') {
            return enabledHandlers[ruleName];
        }
    };
        self.getFixedPreflightData = function(rules, quiz, attempt, preflightData, prefetch, siteId) {
        var promises = [];
        angular.forEach(rules, function(rule) {
            var handler = self.getAccessRuleHandler(rule);
            if (handler && handler.getFixedPreflightData) {
                promises.push($q.when(handler.getFixedPreflightData(quiz, attempt, preflightData, prefetch, siteId)));
            }
        });
        return $mmUtil.allPromises(promises).catch(function() {
        });
    };
        self.isAccessRuleSupported = function(ruleName) {
        return typeof enabledHandlers[ruleName] != 'undefined';
    };
        self.isLastUpdateCall = function(time) {
        if (!lastUpdateHandlersStart) {
            return true;
        }
        return time == lastUpdateHandlersStart;
    };
        self.isPreflightCheckRequired = function(rules, quiz, attempt, prefetch, siteId) {
        var isRequired = false,
            promises = [];
        angular.forEach(rules, function(rule) {
            var handler = self.getAccessRuleHandler(rule);
            if (handler) {
                promises.push($q.when(handler.isPreflightCheckRequired(quiz, attempt, prefetch, siteId)).then(function(required) {
                    if (required) {
                        isRequired = true;
                    }
                }));
            }
        });
        return $mmUtil.allPromises(promises).then(function() {
            return isRequired;
        }).catch(function() {
            return isRequired;
        });
    };
         self.notifyPreflightCheckPassed = function(rules, quiz, attempt, preflightData, prefetch, siteId) {
        var promises = [];
        angular.forEach(rules, function(rule) {
            var handler = self.getAccessRuleHandler(rule);
            if (handler && handler.notifyPreflightCheckPassed) {
                promises.push($q.when(handler.notifyPreflightCheckPassed(quiz, attempt, preflightData, prefetch, siteId)));
            }
        });
        return $mmUtil.allPromises(promises).catch(function() {
        });
    };
         self.notifyPreflightCheckFailed = function(rules, quiz, attempt, preflightData, prefetch, siteId) {
        var promises = [];
        angular.forEach(rules, function(rule) {
            var handler = self.getAccessRuleHandler(rule);
            if (handler && handler.notifyPreflightCheckFailed) {
                promises.push($q.when(handler.notifyPreflightCheckFailed(quiz, attempt, preflightData, prefetch, siteId)));
            }
        });
        return $mmUtil.allPromises(promises).catch(function() {
        });
    };
        self.registerHandler = function(addon, ruleName, handler) {
        if (typeof handlers[ruleName] !== 'undefined') {
            $log.debug("Addon '" + addon + "' already registered as handler for '" + ruleName + "'");
            return false;
        }
        $log.debug("Registered handler '" + addon + "' for access rule '" + ruleName + "'");
        handlers[ruleName] = {
            addon: addon,
            instance: undefined,
            handler: handler
        };
        if ($mmSite.isLoggedIn()) {
            self.updateHandler(ruleName, handlers[ruleName]);
        }
    };
        self.shouldShowTimeLeft = function(rules, attempt, endTime, timeNow) {
        var show = false;
        angular.forEach(rules, function(ruleName) {
            var handler = self.getAccessRuleHandler(ruleName);
            if (handler && handler.shouldShowTimeLeft && handler.shouldShowTimeLeft(attempt, endTime, timeNow)) {
                show = true;
            }
        });
        return show;
    };
        self.updateHandler = function(ruleName, handlerInfo, time) {
        var promise,
            deleted = false,
            siteId = $mmSite.getId();
        if (updatePromises[siteId] && updatePromises[siteId][ruleName]) {
            return updatePromises[siteId][ruleName];
        } else if (!updatePromises[siteId]) {
            updatePromises[siteId] = {};
        }
        if (typeof handlerInfo.instance === 'undefined') {
            handlerInfo.instance = $mmUtil.resolveObject(handlerInfo.handler, true);
        }
        if (!$mmSite.isLoggedIn()) {
            promise = $q.reject();
        } else {
            promise = $q.when(handlerInfo.instance.isEnabled());
        }
        promise = promise.catch(function() {
            return false;
        }).then(function(enabled) {
            if (self.isLastUpdateCall(time) && $mmSite.isLoggedIn() && $mmSite.getId() === siteId) {
                if (enabled) {
                    enabledHandlers[ruleName] = handlerInfo.instance;
                } else {
                    delete enabledHandlers[ruleName];
                }
            }
        }).finally(function() {
            delete updatePromises[siteId][ruleName];
            deleted = true;
        });
        if (!deleted) {
            updatePromises[siteId][ruleName] = promise;
        }
        return promise;
    };
        self.updateHandlers = function() {
        var promises = [],
            now = new Date().getTime();
        $log.debug('Updating handlers for current site.');
        lastUpdateHandlersStart = now;
        angular.forEach(handlers, function(handlerInfo, ruleName) {
            promises.push(self.updateHandler(ruleName, handlerInfo, now));
        });
        return $q.all(promises).then(function() {
            return true;
        }, function() {
            return true;
        });
    };
    return self;
}])
.run(["$mmEvents", "mmCoreEventLogin", "mmCoreEventSiteUpdated", "$mmaModQuizAccessRulesDelegate", "mmCoreEventRemoteAddonsLoaded", function($mmEvents, mmCoreEventLogin, mmCoreEventSiteUpdated, $mmaModQuizAccessRulesDelegate, mmCoreEventRemoteAddonsLoaded) {
    $mmEvents.on(mmCoreEventLogin, $mmaModQuizAccessRulesDelegate.updateHandlers);
    $mmEvents.on(mmCoreEventSiteUpdated, $mmaModQuizAccessRulesDelegate.updateHandlers);
    $mmEvents.on(mmCoreEventRemoteAddonsLoaded, $mmaModQuizAccessRulesDelegate.updateHandlers);
}]);

angular.module('mm.addons.mod_quiz')
.factory('$mmaModQuizAutoSave', ["$log", "$timeout", "$mmaModQuiz", "$interval", "$mmQuestionHelper", "mmaModQuizCheckChangesInterval", function($log, $timeout, $mmaModQuiz, $interval, $mmQuestionHelper,
            mmaModQuizCheckChangesInterval) {
    $log = $log.getInstance('$mmaModQuizAutoSave');
    var self = {},
        autoSavePromise,
        loadPreviousAnswersPromise,
        checkChangesProcess,
        previousAnswers,
        formName,
        popoverName,
        offline,
        connectionErrorButtonSelector;
        self.cancelAutoSave = function() {
        if (autoSavePromise) {
            $timeout.cancel(autoSavePromise);
        }
        autoSavePromise = undefined;
    };
        self.checkChanges = function(scope, quiz, attempt) {
        var answers,
            equal = true;
        if (scope.showSummary || autoSavePromise) {
            return;
        }
        answers = getAnswers();
        if (!previousAnswers) {
            previousAnswers = answers;
        } else {
            angular.forEach(answers, function(value, name) {
                if (previousAnswers[name] != value) {
                    equal = false;
                }
            });
            if (!equal) {
                self.setAutoSaveTimer(scope, quiz, attempt);
                previousAnswers = answers;
            }
        }
    };
        self.hideAutoSaveError = function(scope) {
        scope.autoSaveError = false;
        if (scope[popoverName]) {
            scope[popoverName].hide();
        }
    };
        function getAnswers() {
        return $mmQuestionHelper.getAnswersFromForm(document.forms[formName]);
    }
        self.init = function(scope, formNm, popoverNm, connErrorButtonSel, offlineMode) {
        self.cancelAutoSave();
        self.stopCheckChangesProcess();
        previousAnswers = undefined;
        scope.autoSaveError = false;
        formName = formNm;
        popoverName = popoverNm;
        connectionErrorButtonSelector = connErrorButtonSel;
        offline = offlineMode;
    };
        self.setAutoSaveTimer = function(scope, quiz, attempt) {
        if (quiz.autosaveperiod && !autoSavePromise && !$mmaModQuiz.isAttemptTimeNearlyOver(quiz, attempt)) {
            autoSavePromise = $timeout(function() {
                var answers = getAnswers();
                self.cancelAutoSave();
                previousAnswers = answers;
                $mmaModQuiz.saveAttempt(quiz, attempt, answers, scope.preflightData, offline).then(function() {
                    self.hideAutoSaveError(scope);
                }).catch(function(message) {
                    $log.warn('Error auto-saving data.', message);
                    self.showAutoSaveError(scope);
                    self.setAutoSaveTimer(scope, quiz, attempt);
                });
            }, quiz.autosaveperiod * 1000);
        }
    };
        self.showAutoSaveError = function(scope) {
        if (!scope.autoSaveError) {
            scope.autoSaveError = true;
            $timeout(function() {
                if (scope[popoverName]) {
                    scope[popoverName].show(document.querySelector(connectionErrorButtonSelector));
                }
            });
        }
    };
        self.startCheckChangesProcess = function(scope, quiz, attempt) {
        if (checkChangesProcess || !quiz.autosaveperiod) {
            return;
        }
        function checkChanges() {
            self.checkChanges(scope, quiz, attempt);
        }
        previousAnswers = undefined;
        loadPreviousAnswersPromise = $timeout(checkChanges, 2500);
        checkChangesProcess = $interval(checkChanges, mmaModQuizCheckChangesInterval);
    };
        self.stopAutoSaving = function() {
        self.cancelAutoSave();
        autoSavePromise = true;
    };
        self.stopCheckChangesProcess = function() {
        if (checkChangesProcess) {
            $interval.cancel(checkChangesProcess);
        }
        if (loadPreviousAnswersPromise) {
            $timeout.cancel(loadPreviousAnswersPromise);
        }
        loadPreviousAnswersPromise = undefined;
        checkChangesProcess = undefined;
    };
    return self;
}]);

angular.module('mm.addons.mod_quiz')
.factory('$mmaModQuizHandlers', ["$mmCourse", "$mmaModQuiz", "$state", "$q", "$mmContentLinksHelper", "$mmUtil", "$mmCourseHelper", "$mmSite", "$mmCoursePrefetchDelegate", "$mmaModQuizPrefetchHandler", "$mmEvents", "mmCoreEventPackageStatusChanged", "mmaModQuizComponent", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", "$mmaModQuizHelper", "$mmaModQuizSync", "$mmContentLinkHandlerFactory", function($mmCourse, $mmaModQuiz, $state, $q, $mmContentLinksHelper, $mmUtil, $mmCourseHelper,
            $mmSite, $mmCoursePrefetchDelegate, $mmaModQuizPrefetchHandler, $mmEvents, mmCoreEventPackageStatusChanged,
            mmaModQuizComponent, mmCoreDownloading, mmCoreNotDownloaded, mmCoreOutdated, $mmaModQuizHelper, $mmaModQuizSync,
            $mmContentLinkHandlerFactory) {
    var self = {};
        self.courseContentHandler = function() {
        var self = {};
                self.isEnabled = function() {
            return $mmaModQuiz.isPluginEnabled();
        };
                self.getController = function(module, courseId) {
            return function($scope) {
                var downloadBtn,
                    refreshBtn;
                downloadBtn = {
                    hidden: true,
                    icon: 'ion-ios-cloud-download-outline',
                    label: 'mm.core.download',
                    action: download
                };
                refreshBtn = {
                    icon: 'ion-android-refresh',
                    label: 'mm.core.refresh',
                    hidden: true,
                    action: download
                };
                $scope.icon = $mmCourse.getModuleIconSrc('quiz');
                $scope.title = module.name;
                $scope.buttons = [downloadBtn, refreshBtn];
                $scope.spinner = true;
                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_quiz', {module: module, courseid: courseId});
                };
                function download(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $scope.spinner = true;
                    $mmaModQuizPrefetchHandler.prefetch(module, courseId, true).catch(function(error) {
                        $scope.spinner = false;
                        if (!$scope.$$destroyed) {
                            $mmaModQuizHelper.showError(error, 'mm.core.errordownloading');
                        }
                    });
                }
                function showStatus(status) {
                    if (status) {
                        $scope.spinner = status === mmCoreDownloading;
                        downloadBtn.hidden = status !== mmCoreNotDownloaded;
                        refreshBtn.hidden = status !== mmCoreOutdated;
                    }
                }
                var statusObserver = $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
                    if (data.siteid === $mmSite.getId() && data.componentId === module.id &&
                            data.component === mmaModQuizComponent) {
                        showStatus(data.status);
                    }
                });
                $mmCoursePrefetchDelegate.getModuleStatus(module, courseId).then(showStatus);
                $scope.$on('$destroy', function() {
                    statusObserver && statusObserver.off && statusObserver.off();
                });
            };
        };
        return self;
    };
        self.indexLinksHandler = $mmContentLinksHelper.createModuleIndexLinkHandler('mmaModQuiz', 'quiz', $mmaModQuiz);
        self.gradeLinksHandler = $mmContentLinksHelper.createModuleGradeLinkHandler('mmaModQuiz', 'quiz', $mmaModQuiz);
        self.reviewLinksHandler = $mmContentLinkHandlerFactory.createChild(
                /\/mod\/quiz\/review\.php.*([\&\?]attempt=\d+)/, '$mmCourseDelegate_mmaModQuiz');
    self.reviewLinksHandler.isEnabled = function(siteId, url, params, courseId) {
        courseId = courseId || params.courseid || params.cid;
        return $mmContentLinksHelper.isModuleIndexEnabled($mmaModQuiz, siteId, courseId);
    };
    self.reviewLinksHandler.getActions = function(siteIds, url, params, courseId) {
        courseId = courseId || params.courseid || params.cid;
        var attemptId = parseInt(params.attempt, 10),
            page = parseInt(params.page, 10);
        return [{
            action: function(siteId) {
                var modal = $mmUtil.showModalLoading(),
                    quizId;
                return getQuizIdByAttemptId(attemptId).then(function(qid) {
                    quizId = qid;
                    if (courseId) {
                        return $q.when(courseId);
                    } else {
                        return $mmCourseHelper.getModuleCourseIdByInstance(quizId, 'quiz', siteId);
                    }
                }).then(function(courseId) {
                    var stateParams = {
                        quizid: quizId,
                        attemptid: attemptId,
                        courseid: courseId,
                        page: params.showall ? -1 : (isNaN(page) ? -1 : page)
                    };
                    $mmContentLinksHelper.goInSite('site.mod_quiz-review', stateParams, siteId);
                }).finally(function() {
                    modal.dismiss();
                });
            }
        }];
    };
        function getQuizIdByAttemptId(attemptId) {
        return $mmaModQuiz.getAttemptReview(attemptId).then(function(reviewData) {
            if (reviewData.attempt && reviewData.attempt.quiz) {
                return reviewData.attempt.quiz;
            }
            return $q.reject();
        }).catch(function(error) {
            error = error || 'An error occurred while loading the required data.';
            $mmUtil.showErrorModal(error);
            return $q.reject();
        });
    }
        self.syncHandler = function() {
        var self = {};
                self.execute = function(siteId) {
            return $mmaModQuizSync.syncAllQuizzes(siteId);
        };
                self.getInterval = function() {
            return 600000;
        };
                self.isSync = function() {
            return true;
        };
                self.usesNetwork = function() {
            return true;
        };
        return self;
    };
    return self;
}]);

angular.module('mm.addons.mod_quiz')
.factory('$mmaModQuizHelper', ["$mmaModQuiz", "$mmUtil", "$q", "$translate", "$mmaModQuizSync", function($mmaModQuiz, $mmUtil, $q, $translate, $mmaModQuizSync) {
    var self = {};
        self.getQuestionMarkFromHtml = function(html) {
        return $mmUtil.getContentsOfElement(angular.element(html), '.grade');
    };
        self.getQuizReadableSyncTime = function(quizId, siteId) {
        return $mmaModQuizSync.getSyncTime(quizId, siteId).then(function(time) {
            return self.getReadableTimeFromTimestamp(time);
        });
    };
        self.getReadableTimeFromTimestamp = function(timestamp) {
        if (!timestamp) {
            return $translate.instant('mm.core.never');
        } else {
            return moment(timestamp).format('LLL');
        }
    };
        self.setAttemptCalculatedData = function(quiz, attempt, highlight, bestGrade) {
        attempt.rescaledGrade = $mmaModQuiz.rescaleGrade(attempt.sumgrades, quiz, false);
        attempt.finished = $mmaModQuiz.isAttemptFinished(attempt.state);
        attempt.readableState = $mmaModQuiz.getAttemptReadableState(quiz, attempt);
        if (quiz.showMarkColumn && attempt.finished) {
            attempt.readableMark = $mmaModQuiz.formatGrade(attempt.sumgrades, quiz.decimalpoints);
        } else {
            attempt.readableMark = '';
        }
        if (quiz.showGradeColumn && attempt.finished) {
            attempt.readableGrade = $mmaModQuiz.formatGrade(attempt.rescaledGrade, quiz.decimalpoints);
            attempt.highlightGrade = highlight && !attempt.preview && attempt.state == $mmaModQuiz.ATTEMPT_FINISHED &&
                                        attempt.readableGrade == bestGrade;
        } else {
            attempt.readableGrade = '';
        }
    };
        self.setQuizCalculatedData = function(quiz, options) {
        quiz.sumGradesFormatted = $mmaModQuiz.formatGrade(quiz.sumgrades, quiz.decimalpoints);
        quiz.gradeFormatted = $mmaModQuiz.formatGrade(quiz.grade, quiz.decimalpoints);
        quiz.showAttemptColumn = quiz.attempts != 1;
        quiz.showGradeColumn = options.someoptions.marks >= $mmaModQuiz.QUESTION_OPTIONS_MARK_AND_MAX &&
                                    $mmaModQuiz.quizHasGrades(quiz);
        quiz.showMarkColumn = quiz.showGradeColumn && quiz.grade != quiz.sumgrades;
        quiz.showFeedbackColumn = quiz.hasfeedback && options.alloptions.overallfeedback;
    };
        self.showError = function(message, defaultMessage) {
        defaultMessage = defaultMessage || 'mma.mod_quiz.errorgetquiz';
        if (message) {
            $mmUtil.showErrorModal(message);
        } else {
            $mmUtil.showErrorModal(defaultMessage, true);
        }
        return $q.reject();
    };
    return self;
}]);
angular.module('mm.addons.mod_quiz')
.factory('$mmaModQuizPrefetchHandler', ["$mmaModQuiz", "$q", "$mmPrefetchFactory", "mmaModQuizComponent", "$mmText", "$injector", "$mmSite", "$mmaModQuizAccessRulesDelegate", "$mmQuestionHelper", "$mmFilepool", "mmCoreDownloaded", "mmCoreNotDownloaded", "$rootScope", "$timeout", function($mmaModQuiz, $q, $mmPrefetchFactory, mmaModQuizComponent, $mmText, $injector,
    $mmSite, $mmaModQuizAccessRulesDelegate, $mmQuestionHelper, $mmFilepool, mmCoreDownloaded, mmCoreNotDownloaded, $rootScope,
    $timeout) {
    var self = $mmPrefetchFactory.createPrefetchHandler(mmaModQuizComponent, false),
        $mmaModQuizSync;
    self.updatesNames = /^configuration$|^.*files$|^grades$|^gradeitems$|^questions$|^attempts$/;
        self.download = function(module, courseId) {
        return self.prefetch(module, courseId);
    };
        self.gatherPreflightData = function(quiz, quizAccessInfo, attempt, preflightData, siteId, askPreflight, modalTitle) {
        if (askPreflight) {
            scope = $rootScope.$new();
            scope.preflightData = preflightData;
            scope.preflightModalTitle = modalTitle;
            return getPreflightDataForPrefetch(scope, quiz, quizAccessInfo, attempt, false, siteId).then(function() {
                return scope;
            });
        } else {
            var rules = quizAccessInfo.activerulenames;
            return $mmaModQuizAccessRulesDelegate.getFixedPreflightData(rules, quiz, attempt, preflightData, true, siteId)
                    .then(function() {
                if (!attempt) {
                    return $mmaModQuiz.startAttempt(quiz.id, preflightData).then(function() {
                    });
                }
            });
        }
    };
        function getPreflightDataForPrefetch(scope, quiz, quizAccessInfo, attempt, fromModal, siteId) {
        return $mmaModQuiz.checkPreflightData(scope, quiz, quizAccessInfo, attempt, false, fromModal, true, siteId).catch(function(error) {
            if (error) {
                return $q.reject(error);
            } else {
                var deferred = $q.defer(),
                    resolved = false;
                scope.start = function() {
                    resolved = true;
                    deferred.resolve(getPreflightDataForPrefetch(scope, quiz, quizAccessInfo, attempt, true, siteId));
                };
                scope.$on('modal.hidden', function() {
                    if (!resolved) {
                        $timeout(deferred.reject, 400);
                    }
                });
                scope.$on('modal.removed', function() {
                    if (!resolved) {
                        deferred.reject();
                    }
                });
                return deferred.promise;
            }
        });
    }
        self.getDownloadSize = function(module, courseId, siteId) {
        return {size: -1, total: false};
    };
        self.getDownloadedSize = function(module, courseId) {
        return $mmFilepool.getFilesSizeByComponent($mmSite.getId(), self.component, module.id);
    };
        self.getFiles = function(module, courseId, siteId) {
        return [];
    };
        self.getRevision = function(module, courseId) {
        return $mmaModQuiz.getQuizIdFromModule(module, courseId).then(function(quizId) {
            return $mmaModQuiz.getUserAttempts(quizId).then(function(attempts) {
                return self.getRevisionFromAttempts(attempts);
            });
        });
    };
        self.getRevisionFromAttempts = function(attempts) {
        if (attempts.length) {
            return attempts[attempts.length - 1].id;
        } else {
            return 0;
        }
    };
        self.getTimemodified = function(module, courseId) {
        return $mmaModQuiz.getQuizIdFromModule(module, courseId).then(function(quizId) {
            return $mmaModQuiz.getUserAttempts(quizId).then(function(attempts) {
                return self.getTimemodifiedFromAttempts(attempts);
            });
        });
    };
        self.getTimemodifiedFromAttempts = function(attempts) {
        if (attempts.length) {
            return attempts[attempts.length - 1].timemodified;
        } else {
            return 0;
        }
    };
        self.invalidateContent = function(moduleId, courseId) {
        return $mmaModQuiz.invalidateContent(moduleId, courseId);
    };
        self.invalidateModule = function(module, courseId) {
        return $mmaModQuiz.getQuizIdFromModule(module, courseId).then(function(quizId) {
            var promises = [];
            promises.push($mmaModQuiz.invalidateQuizData(courseId));
            promises.push($mmaModQuiz.invalidateUserAttemptsForUser(quizId));
            return $q.all(promises);
        });
    };
        self.isDownloadable = function(module, courseId) {
        return $mmaModQuiz.getQuiz(courseId, module.id, false, true).then(function(quiz) {
            if (quiz.allowofflineattempts !== 1 || quiz.hasquestions === 0) {
                return false;
            }
            return $mmaModQuiz.getUserAttempts(quiz.id).then(function(attempts) {
                var isLastFinished = !attempts.length || $mmaModQuiz.isAttemptFinished(attempts[attempts.length - 1].state);
                return quiz.attempts === 0 || quiz.attempts > attempts.length || !isLastFinished;
            });
        });
    };
        self.isEnabled = function() {
        return $mmaModQuiz.isPluginEnabled();
    };
        self.prefetch = function(module, courseId, single) {
        return self.prefetchPackage(module, courseId, single, prefetchQuiz, $mmSite.getId());
    };
        function prefetchQuiz(module, courseId, single, siteId) {
        var attempts,
            startAttempt,
            quiz,
            quizAccessInfo,
            attemptAccessInfo,
            preflightData = {},
            scope;
        return $mmaModQuiz.getQuiz(courseId, module.id, siteId).then(function(q) {
            quiz = q;
            var promises = [],
                introFiles = self.getIntroFilesFromInstance(module, quiz);
            promises.push($mmaModQuiz.getQuizAccessInformation(quiz.id, false, true, siteId).then(function(info) {
                quizAccessInfo = info;
            }));
            promises.push($mmaModQuiz.getQuizRequiredQtypes(quiz.id, true, siteId));
            promises.push($mmaModQuiz.getUserAttempts(quiz.id, 'all', true, false, true, siteId).then(function(atts) {
                attempts = atts;
            }));
            promises.push($mmaModQuiz.getAttemptAccessInformation(quiz.id, 0, false, true, siteId).then(function(info) {
                attemptAccessInfo = info;
            }));
            angular.forEach(introFiles, function(file) {
                var url = file.fileurl;
                promises.push($mmFilepool.addToQueueByUrl(siteId, url, self.component, module.id, file.timemodified));
            });
            return $q.all(promises);
        }).then(function() {
            var attempt = attempts[attempts.length - 1];
            if (!attempt || $mmaModQuiz.isAttemptFinished(attempt.state)) {
                if (attemptAccessInfo.preventnewattemptreasons.length) {
                    return $q.reject($mmText.buildMessage(attemptAccessInfo.preventnewattemptreasons));
                }
                startAttempt = true;
                attempt = undefined;
            }
            return self.gatherPreflightData(quiz, quizAccessInfo, attempt, preflightData, siteId, single, 'mm.core.download');
        }).then(function(scp) {
            scope = scp;
            promises = [];
            if (startAttempt) {
                promises.push($mmaModQuiz.getUserAttempts(quiz.id, 'all', true, false, true, siteId).then(function(atts) {
                    attempts = atts;
                }));
            }
            promises.push($mmaModQuiz.getCombinedReviewOptions(quiz.id, true, siteId));
            promises.push($mmaModQuiz.getUserBestGrade(quiz.id, true, siteId));
            promises.push($mmaModQuiz.getGradeFromGradebook(courseId, module.id, true, siteId).then(function(gradebookData) {
                if (typeof gradebookData.grade != 'undefined') {
                    return $mmaModQuiz.getFeedbackForGrade(quiz.id, gradebookData.grade, true, siteId);
                }
            }).catch(function() {
            }));
            promises.push($mmaModQuiz.getAttemptAccessInformation(quiz.id, 0, false, true, siteId));
            return $q.all(promises);
        }).then(function() {
            promises = [];
            angular.forEach(attempts, function(attempt) {
                promises.push(self.prefetchAttempt(quiz, attempt, preflightData, siteId));
            });
            return $q.all(promises);
        }).then(function() {
            if (!$mmaModQuizSync) {
                $mmaModQuizSync = $injector.get('$mmaModQuizSync');
            }
            $mmaModQuizSync.hasDataToSync(quiz.id, siteId).then(function(hasData) {
                if (!hasData) {
                    $mmaModQuizSync.setSyncTime(quiz.id, siteId);
                }
            });
        }).then(function() {
            return {
                revision: self.getRevisionFromAttempts(attempts),
                timemod: self.getTimemodifiedFromAttempts(attempts)
            };
        }).finally(function() {
            if (scope) {
                scope.$destroy();
            }
        });
    }
        self.prefetchAttempt = function(quiz, attempt, preflightData, siteId) {
        var pages = $mmaModQuiz.getPagesFromLayout(attempt.layout),
            promises = [],
            isSequential = $mmaModQuiz.isNavigationSequential(quiz),
            attemptGrade;
        if ($mmaModQuiz.isAttemptFinished(attempt.state)) {
            attemptGrade = $mmaModQuiz.rescaleGrade(attempt.sumgrades, quiz, false);
            if (typeof attemptGrade != 'undefined') {
                promises.push($mmaModQuiz.getFeedbackForGrade(quiz.id, attemptGrade, true, siteId));
            }
            angular.forEach(pages, function(page) {
                promises.push($mmaModQuiz.getAttemptReview(attempt.id, page, true, siteId).catch(function() {
                }));
            });
            promises.push($mmaModQuiz.getAttemptReview(attempt.id, -1, true, siteId).then(function(data) {
                var questionPromises = [];
                angular.forEach(data.questions, function(question) {
                    questionPromises.push($mmQuestionHelper.prefetchQuestionFiles(
                                question, siteId, self.component, quiz.coursemodule));
                });
                return $q.all(questionPromises);
            }, function() {
            }));
        } else {
            promises.push($mmaModQuiz.getAttemptAccessInformation(quiz.id, attempt.id, false, true, siteId));
            promises.push($mmaModQuiz.getAttemptSummary(attempt.id, preflightData, false, true, false, siteId));
            if (attempt.state == $mmaModQuiz.ATTEMPT_IN_PROGRESS) {
                angular.forEach(pages, function(page) {
                    if (isSequential && page < attempt.currentpage) {
                        return;
                    }
                    promises.push($mmaModQuiz.getAttemptData(attempt.id, page, preflightData, false, true, siteId).then(function(data) {
                        var questionPromises = [];
                        angular.forEach(data.questions, function(question) {
                            questionPromises.push($mmQuestionHelper.prefetchQuestionFiles(
                                        question, siteId, self.component, quiz.coursemodule));
                        });
                        return $q.all(questionPromises);
                    }));
                });
            }
        }
        return $q.all(promises);
    };
        self.prefetchQuizAndLastAttempt = function(quiz, siteId, askPreflight) {
        siteId = siteId || $mmSite.getId();
        var attempts,
            promises = [],
            revision,
            timemod,
            quizAccessInfo,
            preflightData = {},
            scope;
        promises.push($mmaModQuiz.getQuizAccessInformation(quiz.id, false, true, siteId).then(function(info) {
            quizAccessInfo = info;
        }));
        promises.push($mmaModQuiz.getQuizRequiredQtypes(quiz.id, true, siteId));
        promises.push($mmaModQuiz.getCombinedReviewOptions(quiz.id, true, siteId));
        promises.push($mmaModQuiz.getUserBestGrade(quiz.id, true, siteId));
        promises.push($mmaModQuiz.getUserAttempts(quiz.id, 'all', true, false, true, siteId).then(function(atts) {
            attempts = atts;
        }));
        promises.push($mmaModQuiz.getGradeFromGradebook(quiz.course, quiz.coursemodule, true, siteId).then(function(gradebookData) {
            if (typeof gradebookData.grade != 'undefined') {
                return $mmaModQuiz.getFeedbackForGrade(quiz.id, gradebookData.grade, true, siteId);
            }
        }));
        promises.push($mmaModQuiz.getAttemptAccessInformation(quiz.id, 0, false, true, siteId));
        return $q.all(promises).then(function() {
            var attempt = attempts[attempts.length - 1];
            if (!attempt) {
                return;
            }
            return self.gatherPreflightData(quiz, quizAccessInfo, attempt, preflightData, siteId, askPreflight, 'mm.core.download');
        }).then(function(scp) {
            scope = scp;
            if (attempts && attempts.length) {
                return self.prefetchAttempt(quiz, attempts[attempts.length - 1], preflightData, siteId);
            }
        }).then(function() {
            revision = self.getRevisionFromAttempts(attempts);
            timemod = self.getTimemodifiedFromAttempts(attempts);
            return $mmFilepool.getPackageStatus(siteId, self.component, quiz.coursemodule, revision, timemod);
        }).then(function(status) {
            if (status !== mmCoreNotDownloaded) {
                var isLastFinished = !attempts.length || $mmaModQuiz.isAttemptFinished(attempts[attempts.length - 1].state),
                    newStatus = isLastFinished ? mmCoreNotDownloaded : mmCoreDownloaded;
                return $mmFilepool.storePackageStatus(siteId, self.component, quiz.coursemodule, newStatus, revision, timemod);
            }
        }).finally(function() {
            if (scope) {
                scope.$destroy();
            }
        });
    };
    return self;
}]);

angular.module('mm.addons.mod_quiz')
.factory('$mmaModQuiz', ["$log", "$mmSite", "$mmSitesManager", "$q", "$translate", "$mmUtil", "$mmText", "$mmQuestionDelegate", "$timeout", "$mmaModQuizAccessRulesDelegate", "$mmFilepool", "$mmaModQuizOnline", "$mmaModQuizOffline", "mmaModQuizComponent", "$ionicModal", "$mmGrades", function($log, $mmSite, $mmSitesManager, $q, $translate, $mmUtil, $mmText, $mmQuestionDelegate, $timeout,
            $mmaModQuizAccessRulesDelegate, $mmFilepool, $mmaModQuizOnline, $mmaModQuizOffline, mmaModQuizComponent, $ionicModal,
            $mmGrades) {
    $log = $log.getInstance('$mmaModQuiz');
    var self = {};
    self.GRADEHIGHEST = 1;
    self.GRADEAVERAGE = 2;
    self.ATTEMPTFIRST = 3;
    self.ATTEMPTLAST  = 4;
    self.QUESTION_OPTIONS_MAX_ONLY = 1;
    self.QUESTION_OPTIONS_MARK_AND_MAX = 2;
    self.ATTEMPT_IN_PROGRESS = 'inprogress';
    self.ATTEMPT_OVERDUE     = 'overdue';
    self.ATTEMPT_FINISHED    = 'finished';
    self.ATTEMPT_ABANDONED   = 'abandoned';
    self.QUIZ_SHOW_TIME_BEFORE_DEADLINE = 3600;
        self.checkPreflightData = function(scope, quiz, quizAccessInfo, attempt, offline, fromModal, prefetch, siteId) {
        var promise,
            rules = quizAccessInfo.activerulenames;
        return $mmaModQuizAccessRulesDelegate.isPreflightCheckRequired(rules, quiz, attempt, prefetch, siteId)
                .then(function(preflightRequired) {
            if (preflightRequired && !fromModal) {
                return self.initPreflightModal(scope, quiz, quizAccessInfo, attempt, prefetch, siteId).catch(function(error) {
                    return $q.reject(error || 'Error initializing preflight modal.');
                }).then(function() {
                    scope.modal.show();
                    return $q.reject();
                });
            }
            promise = scope.modal ? scope.modal.hide() : $q.when();
            return promise.then(function() {
                return $mmaModQuizAccessRulesDelegate.getFixedPreflightData(
                            rules, quiz, attempt, scope.preflightData, prefetch, siteId);
            });
        }).then(function() {
            if (attempt) {
                if (attempt.state != self.ATTEMPT_OVERDUE && !attempt.finishedOffline) {
                    var page = attempt.currentpage;
                    promise = self.getAttemptData(attempt.id, page, scope.preflightData, offline, true).then(function() {
                        if (offline) {
                            return $mmaModQuizOffline.getAttemptById(attempt.id).then(function(localAttempt) {
                                attempt.currentpage = localAttempt.currentpage;
                            }).catch(function() {
                            });
                        }
                    });
                } else {
                    promise = self.getAttemptSummary(attempt.id, scope.preflightData, offline, true);
                }
            } else {
                promise = self.startAttempt(quiz.id, scope.preflightData).then(function(att) {
                    attempt = att;
                });
            }
            return promise.then(function() {
                $mmaModQuizAccessRulesDelegate.notifyPreflightCheckPassed(rules, quiz, attempt,
                                                                scope.preflightData, prefetch, siteId);
                return attempt;
            }).catch(function(error) {
                if ($mmUtil.isWebServiceError(error)) {
                    $mmaModQuizAccessRulesDelegate.notifyPreflightCheckFailed(rules, quiz, attempt,
                                                                scope.preflightData, prefetch, siteId);
                }
                if (prefetch) {
                    return $q.reject(error);
                } else {
                    $timeout(function() {
                        scope.modal && scope.modal.show();
                    }, 500);
                    if (error) {
                        $mmUtil.showErrorModal(error);
                    } else {
                        $mmUtil.showErrorModal('mm.core.error', true);
                    }
                    return $q.reject();
                }
            });
        });
    };
        self.formatGrade = function(grade, decimals) {
        if (typeof grade == 'undefined' || grade == -1 || grade === null) {
            return $translate.instant('mma.mod_quiz.notyetgraded');
        }
        return $mmUtil.roundToDecimals(grade, decimals);
    };
        self.getAllQuestionsData = function(quiz, attempt, preflightData, pages, offline, ignoreCache, siteId) {
        var promises = [],
            questions = {},
            isSequential = self.isNavigationSequential(quiz);
        if (!pages) {
            pages = self.getPagesFromLayout(attempt.layout);
        }
        pages.forEach(function(page) {
            if (isSequential && page < attempt.currentpage) {
                return;
            }
            promises.push(self.getAttemptData(attempt.id, page, preflightData, offline, ignoreCache, siteId).then(function(data) {
                angular.forEach(data.questions, function(question) {
                    questions[question.slot] = question;
                });
            }));
        });
        return $q.all(promises).then(function() {
            return questions;
        });
    };
        function getAttemptAccessInformationCacheKey(quizId, attemptId) {
        return getAttemptAccessInformationCommonCacheKey(quizId) + ':' + attemptId;
    }
        function getAttemptAccessInformationCommonCacheKey(quizId) {
        return 'mmaModQuiz:attemptAccessInformation:' + quizId;
    }
        self.getAttemptAccessInformation = function(quizId, attemptId, offline, ignoreCache, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    quizid: quizId,
                    attemptid: attemptId
                },
                preSets = {
                    cacheKey: getAttemptAccessInformationCacheKey(quizId, attemptId)
                };
            if (offline) {
                preSets.omitExpires = true;
            } else if (ignoreCache) {
                preSets.getFromCache = 0;
                preSets.emergencyCache = 0;
            }
            return site.read('mod_quiz_get_attempt_access_information', params, preSets);
        });
    };
        function getAttemptDataCacheKey(attemptId, page) {
        return getAttemptDataCommonCacheKey(attemptId) + ':' + page;
    }
        function getAttemptDataCommonCacheKey(attemptId) {
        return 'mmaModQuiz:attemptData:' + attemptId;
    }
        self.getAttemptData = function(attemptId, page, preflightData, offline, ignoreCache, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    attemptid: attemptId,
                    page: page,
                    preflightdata: $mmUtil.objectToArrayOfObjects(preflightData, 'name', 'value', true)
                },
                preSets = {
                    cacheKey: getAttemptDataCacheKey(attemptId, page)
                };
            if (offline) {
                preSets.omitExpires = true;
            } else if (ignoreCache) {
                preSets.getFromCache = 0;
                preSets.emergencyCache = 0;
            }
            return site.read('mod_quiz_get_attempt_data', params, preSets);
        });
    };
        self.getAttemptDueDate = function(quiz, attempt) {
        var deadlines = [],
            dueDate;
        if (quiz.timelimit) {
            deadlines.push(parseInt(attempt.timestart, 10) + parseInt(quiz.timelimit, 10));
        }
        if (quiz.timeclose) {
            deadlines.push(parseInt(quiz.timeclose, 10));
        }
        if (!deadlines.length) {
            return 0;
        }
        dueDate = Math.min.apply(null, deadlines);
        if (!dueDate) {
            return 0;
        }
        switch (attempt.state) {
            case self.ATTEMPT_IN_PROGRESS:
                return dueDate * 1000;
            case self.ATTEMPT_OVERDUE:
                return (dueDate + parseInt(quiz.graceperiod, 10)) * 1000;
            default:
                $log.warn('Unexpected state when getting due date: ' + attempt.state);
                return 0;
        }
    };
        self.getAttemptDueDateWarning = function(quiz, attempt) {
        var dueDate = self.getAttemptDueDate(quiz, attempt);
        if (attempt.state === self.ATTEMPT_OVERDUE) {
            return $translate.instant('mma.mod_quiz.overduemustbesubmittedby', {$a: moment(dueDate).format('LLL')});
        } else if (dueDate) {
            return $translate.instant('mma.mod_quiz.mustbesubmittedby', {$a: moment(dueDate).format('LLL')});
        }
    };
        self.getAttemptReadableState = function(quiz, attempt) {
        if (attempt.finishedOffline) {
            return [$translate.instant('mma.mod_quiz.finishnotsynced')];
        }
        switch (attempt.state) {
            case self.ATTEMPT_IN_PROGRESS:
                return [$translate.instant('mma.mod_quiz.stateinprogress')];
            case self.ATTEMPT_OVERDUE:
                var sentences = [],
                    dueDate = self.getAttemptDueDate(quiz, attempt);
                sentences.push($translate.instant('mma.mod_quiz.stateoverdue'));
                if (dueDate) {
                    dueDate = moment(dueDate).format('LLL');
                    sentences.push($translate.instant('mma.mod_quiz.stateoverduedetails', {$a: dueDate}));
                }
                return sentences;
            case self.ATTEMPT_FINISHED:
                return [
                    $translate.instant('mma.mod_quiz.statefinished'),
                    $translate.instant('mma.mod_quiz.statefinisheddetails', {$a: moment(attempt.timefinish * 1000).format('LLL')})
                ];
            case self.ATTEMPT_ABANDONED:
                return [$translate.instant('mma.mod_quiz.stateabandoned')];
        }
        return [];
    };
        self.getAttemptReadableStateName = function(state) {
        switch (state) {
            case self.ATTEMPT_IN_PROGRESS:
                return $translate.instant('mma.mod_quiz.stateinprogress');
            case self.ATTEMPT_OVERDUE:
                return $translate.instant('mma.mod_quiz.stateoverdue');
            case self.ATTEMPT_FINISHED:
                return $translate.instant('mma.mod_quiz.statefinished');
            case self.ATTEMPT_ABANDONED:
                return $translate.instant('mma.mod_quiz.stateabandoned');
        }
        return '';
    };
        function getAttemptReviewCacheKey(attemptId, page) {
        return getAttemptReviewCommonCacheKey(attemptId) + ':' + page;
    }
        function getAttemptReviewCommonCacheKey(attemptId) {
        return 'mmaModQuiz:attemptReview:' + attemptId;
    }
        self.getAttemptReview = function(attemptId, page, ignoreCache, siteId) {
        if (typeof page == 'undefined') {
            page = -1;
        }
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    attemptid: attemptId,
                    page: page
                },
                preSets = {
                    cacheKey: getAttemptReviewCacheKey(attemptId, page)
                };
            if (ignoreCache) {
                preSets.getFromCache = 0;
                preSets.emergencyCache = 0;
            }
            return site.read('mod_quiz_get_attempt_review', params, preSets);
        });
    };
        function getAttemptSummaryCacheKey(attemptId) {
        return 'mmaModQuiz:attemptSummary:' + attemptId;
    }
        self.getAttemptSummary = function(attemptId, preflightData, offline, ignoreCache, loadLocal, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    attemptid: attemptId,
                    preflightdata: $mmUtil.objectToArrayOfObjects(preflightData, 'name', 'value', true)
                },
                preSets = {
                    cacheKey: getAttemptSummaryCacheKey(attemptId)
                };
            if (offline) {
                preSets.omitExpires = true;
            } else if (ignoreCache) {
                preSets.getFromCache = 0;
                preSets.emergencyCache = 0;
            }
            return site.read('mod_quiz_get_attempt_summary', params, preSets).then(function(response) {
                if (response && response.questions) {
                    if (offline && loadLocal) {
                        return $mmaModQuizOffline.loadQuestionsLocalStates(attemptId, response.questions, site.getId());
                    }
                    return response.questions;
                }
                return $q.reject();
            });
        });
    };
        function getCombinedReviewOptionsCacheKey(quizId, userId) {
        return getCombinedReviewOptionsCommonCacheKey(quizId) + ':' + userId;
    }
        function getCombinedReviewOptionsCommonCacheKey(quizId) {
        return 'mmaModQuiz:combinedReviewOptions:' + quizId;
    }
        self.getCombinedReviewOptions = function(quizId, ignoreCache, siteId, userId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            var params = {
                    quizid: quizId,
                    userid: userId
                },
                preSets = {
                    cacheKey: getCombinedReviewOptionsCacheKey(quizId, userId)
                };
            if (ignoreCache) {
                preSets.getFromCache = 0;
                preSets.emergencyCache = 0;
            }
            return site.read('mod_quiz_get_combined_review_options', params, preSets).then(function(response) {
                if (response && response.someoptions && response.alloptions) {
                    var someOptions = {},
                        allOptions = {};
                    angular.forEach(response.someoptions, function(entry) {
                        someOptions[entry.name] = entry.value;
                    });
                    angular.forEach(response.alloptions, function(entry) {
                        allOptions[entry.name] = entry.value;
                    });
                    response.someoptions = someOptions;
                    response.alloptions = allOptions;
                    return response;
                }
                return $q.reject();
            });
        });
    };
        function getFeedbackForGradeCacheKey(quizId, grade) {
        return getFeedbackForGradeCommonCacheKey(quizId) + ':' + grade;
    }
        function getFeedbackForGradeCommonCacheKey(quizId) {
        return 'mmaModQuiz:feedbackForGrade:' + quizId;
    }
        self.getFeedbackForGrade = function(quizId, grade, ignoreCache, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    quizid: quizId,
                    grade: grade
                },
                preSets = {
                    cacheKey: getFeedbackForGradeCacheKey(quizId, grade)
                };
            if (ignoreCache) {
                preSets.getFromCache = 0;
                preSets.emergencyCache = 0;
            }
            return site.read('mod_quiz_get_quiz_feedback_for_grade', params, preSets);
        });
    };
        self.getGradeDecimals = function(quiz) {
        if (typeof quiz.questiondecimalpoints == 'undefined') {
            quiz.questiondecimalpoints = -1;
        }
        if (quiz.questiondecimalpoints == -1) {
            return quiz.decimalpoints;
        }
        return quiz.questiondecimalpoints;
    };
        self.getGradeFromGradebook = function(courseId, moduleId, ignoreCache, siteId, userId) {
        return $mmGrades.getGradeModuleItems(courseId, moduleId, userId, null, siteId, ignoreCache).then(function(items) {
            return items.shift();
        });
    };
        self.getLastFinishedAttemptFromList = function(attempts) {
        if (attempts && attempts.length) {
            for (var i = attempts.length - 1; i >= 0; i--) {
                var attempt = attempts[i];
                if (self.isAttemptFinished(attempt.state)) {
                    return attempt;
                }
            }
        }
    };
        self.getPreventSubmitMessages = function(questions) {
        var messages = [];
        angular.forEach(questions, function(question) {
            var message = $mmQuestionDelegate.getPreventSubmitMessage(question);
            if (message) {
                message = $translate.instant(message);
                messages.push($translate.instant('mm.question.questionmessage', {$a: question.slot, $b: message}));
            }
        });
        return messages;
    };
        function getQuizDataCacheKey(courseId) {
        return 'mmaModQuiz:quiz:' + courseId;
    }
        function getQuiz(siteId, courseId, key, value, forceCache) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    courseids: [courseId]
                },
                preSets = {
                    cacheKey: getQuizDataCacheKey(courseId)
                };
            if (forceCache) {
                preSets.omitExpires = true;
            }
            return site.read('mod_quiz_get_quizzes_by_courses', params, preSets).then(function(response) {
                if (response && response.quizzes) {
                    var currentQuiz;
                    angular.forEach(response.quizzes, function(quiz) {
                        if (!currentQuiz && quiz[key] == value) {
                            currentQuiz = quiz;
                        }
                    });
                    if (currentQuiz) {
                        return currentQuiz;
                    }
                }
                return $q.reject();
            });
        });
    }
        self.getQuiz = function(courseId, cmid, siteId, forceCache) {
        return getQuiz(siteId, courseId, 'coursemodule', cmid, forceCache);
    };
        self.getQuizById = function(courseId, id, siteId, forceCache) {
        return getQuiz(siteId, courseId, 'id', id, forceCache);
    };
        function getQuizAccessInformationCacheKey(quizId) {
        return 'mmaModQuiz:quizAccessInformation:' + quizId;
    }
        self.getQuizAccessInformation = function(quizId, offline, ignoreCache, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    quizid: quizId
                },
                preSets = {
                    cacheKey: getQuizAccessInformationCacheKey(quizId)
                };
            if (offline) {
                preSets.omitExpires = true;
            } else if (ignoreCache) {
                preSets.getFromCache = 0;
                preSets.emergencyCache = 0;
            }
            return site.read('mod_quiz_get_quiz_access_information', params, preSets);
        });
    };
        self.getQuizIdFromModule = function(module, courseId, siteId) {
        if (module.instance) {
            return $q.when(module.instance);
        } else {
            return self.getQuiz(courseId, module.id, siteId).then(function(quiz) {
                return quiz.id;
            });
        }
    };
        self.getQuizGradeMethod = function(method) {
        switch (parseInt(method, 10)) {
            case self.GRADEHIGHEST:
                return $translate.instant('mma.mod_quiz.gradehighest');
            case self.GRADEAVERAGE:
                return $translate.instant('mma.mod_quiz.gradeaverage');
            case self.ATTEMPTFIRST:
                return $translate.instant('mma.mod_quiz.attemptfirst');
            case self.ATTEMPTLAST:
                return $translate.instant('mma.mod_quiz.attemptlast');
        }
        return '';
    };
        function getQuizRequiredQtypesCacheKey(quizId) {
        return 'mmaModQuiz:quizRequiredQtypes:' + quizId;
    }
        self.getQuizRequiredQtypes = function(quizId, ignoreCache, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    quizid: quizId
                },
                preSets = {
                    cacheKey: getQuizRequiredQtypesCacheKey(quizId)
                };
            if (ignoreCache) {
                preSets.getFromCache = 0;
                preSets.emergencyCache = 0;
            }
            return site.read('mod_quiz_get_quiz_required_qtypes', params, preSets).then(function(response) {
                if (response && response.questiontypes) {
                    return response.questiontypes;
                }
                return $q.reject();
            });
        });
    };
        self.getPagesFromLayout = function(layout) {
        var split = layout.split(','),
            page = 0,
            pages = [];
        for (var i = 0; i < split.length; i++) {
            if (split[i] == 0) {
                pages.push(page);
                page++;
            }
        }
        return pages;
    };
        self.getPagesFromLayoutAndQuestions = function(layout, questions) {
        var split = layout.split(','),
            page = 0,
            pageAdded = false,
            pages = [];
        for (var i = 0; i < split.length; i++) {
            var value = split[i];
            if (value == 0) {
                page++;
                pageAdded = false;
            } else if (!pageAdded && questions[value]) {
                pages.push(page);
                pageAdded = true;
            }
        }
        return pages;
    };
        self.getUnsupportedQuestions = function(questionTypes) {
        var notSupported = [];
        angular.forEach(questionTypes, function(type) {
            if (type != 'random' && !$mmQuestionDelegate.isQuestionSupported(type)) {
                notSupported.push(type);
            }
        });
        return notSupported;
    };
        self.getUnsupportedRules = function(rulesNames) {
        var notSupported = [];
        angular.forEach(rulesNames, function(name) {
            if (!$mmaModQuizAccessRulesDelegate.isAccessRuleSupported(name)) {
                notSupported.push(name);
            }
        });
        return notSupported;
    };
        function getUserAttemptsCacheKey(quizId, userId) {
        return getUserAttemptsCommonCacheKey(quizId) + ':' + userId;
    }
        function getUserAttemptsCommonCacheKey(quizId) {
        return 'mmaModQuiz:userAttempts:' + quizId;
    }
        self.getUserAttempts = function(quizId, status, includePreviews, offline, ignoreCache, siteId, userId) {
        status = status || 'all';
        if (typeof includePreviews == 'undefined') {
            includePreviews = true;
        }
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            var params = {
                    quizid: quizId,
                    userid: userId,
                    status: status,
                    includepreviews: includePreviews ? 1 : 0
                },
                preSets = {
                    cacheKey: getUserAttemptsCacheKey(quizId, userId)
                };
            if (offline) {
                preSets.omitExpires = true;
            } else if (ignoreCache) {
                preSets.getFromCache = 0;
                preSets.emergencyCache = 0;
            }
            return site.read('mod_quiz_get_user_attempts', params, preSets).then(function(response) {
                if (response && response.attempts) {
                    return response.attempts;
                }
                return $q.reject();
            });
        });
    };
        function getUserBestGradeCacheKey(quizId, userId) {
        return getUserBestGradeCommonCacheKey(quizId) + ':' + userId;
    }
        function getUserBestGradeCommonCacheKey(quizId) {
        return 'mmaModQuiz:userBestGrade:' + quizId;
    }
        self.getUserBestGrade = function(quizId, ignoreCache, siteId, userId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            var params = {
                    quizid: quizId,
                    userid: userId
                },
                preSets = {
                    cacheKey: getUserBestGradeCacheKey(quizId, userId)
                };
            if (ignoreCache) {
                preSets.getFromCache = 0;
                preSets.emergencyCache = 0;
            }
            return site.read('mod_quiz_get_user_best_grade', params, preSets);
        });
    };
        self.initPreflightModal = function(scope, quiz, quizAccessInfo, attempt, prefetch, siteId) {
        var promises = [],
            notSupported = [],
            directives = [],
            handlers = [];
        angular.forEach(quizAccessInfo.activerulenames, function(rule) {
            var handler = $mmaModQuizAccessRulesDelegate.getAccessRuleHandler(rule);
            if (handler) {
                promises.push($q.when(handler.isPreflightCheckRequired(quiz, attempt, prefetch, siteId)).then(function(required) {
                    if (required) {
                        handlers.push(handler);
                        directives.push(handler.getPreflightDirectiveName());
                    }
                }));
            } else {
                notSupported.push(rule);
            }
        });
        if (notSupported.length) {
            var error = $translate.instant('mma.mod_quiz.errorrulesnotsupported') + ' ' + JSON.stringify(notSupported);
            return $q.reject(error);
        }
        return $mmUtil.allPromises(promises).catch(function() {
        }).then(function() {
            var promise;
            scope.accessRulesDirectives = directives;
            if (scope.modal) {
                promise = $q.when(scope.modal);
            } else {
                promise = $ionicModal.fromTemplateUrl('addons/mod/quiz/templates/preflight-modal.html', {
                    scope: scope,
                    animation: 'slide-in-up'
                });
            }
            return promise.then(function(modal) {
                scope.modal = modal;
                scope.closeModal = function() {
                    modal.hide();
                    handlers.forEach(function(handler) {
                        if (typeof handler.cleanPreflight == 'function') {
                            handler.cleanPreflight(scope.preflightData);
                        }
                    });
                };
                scope.$on('$destroy', function() {
                    modal.remove();
                });
            });
        });
    };
        self.invalidateAllQuizData = function(quizId, courseId, attemptId, siteId, userId) {
        siteId = siteId || $mmSite.getId();
        var promises = [];
        promises.push(self.invalidateAttemptAccessInformation(quizId, siteId));
        promises.push(self.invalidateCombinedReviewOptionsForUser(quizId, siteId, userId));
        promises.push(self.invalidateFeedback(quizId, siteId));
        promises.push(self.invalidateQuizAccessInformation(quizId, siteId));
        promises.push(self.invalidateQuizRequiredQtypes(quizId, siteId));
        promises.push(self.invalidateUserAttemptsForUser(quizId, siteId, userId));
        promises.push(self.invalidateUserBestGradeForUser(quizId, siteId, userId));
        if (attemptId) {
            promises.push(self.invalidateAttemptData(attemptId, siteId));
            promises.push(self.invalidateAttemptReview(attemptId, siteId));
            promises.push(self.invalidateAttemptSummary(attemptId, siteId));
        }
        if (courseId) {
            promises.push(self.invalidateGradeFromGradebook(courseId, siteId, userId));
        }
        return $q.all(promises);
    };
        self.invalidateAttemptAccessInformation = function(quizId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKeyStartingWith(getAttemptAccessInformationCommonCacheKey(quizId));
        });
    };
        self.invalidateAttemptAccessInformationForAttempt = function(quizId, attemptId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getAttemptAccessInformationCacheKey(quizId, attemptId));
        });
    };
        self.invalidateAttemptData = function(attemptId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKeyStartingWith(getAttemptDataCommonCacheKey(attemptId));
        });
    };
        self.invalidateAttemptDataForPage = function(attemptId, page, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getAttemptDataCacheKey(attemptId, page));
        });
    };
        self.invalidateAttemptReview = function(attemptId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKeyStartingWith(getAttemptReviewCommonCacheKey(attemptId));
        });
    };
        self.invalidateAttemptReviewForPage = function(attemptId, page, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getAttemptReviewCacheKey(attemptId, page));
        });
    };
        self.invalidateAttemptSummary = function(attemptId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getAttemptSummaryCacheKey(attemptId));
        });
    };
        self.invalidateCombinedReviewOptions = function(quizId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKeyStartingWith(getCombinedReviewOptionsCommonCacheKey(quizId));
        });
    };
        self.invalidateCombinedReviewOptionsForUser = function(quizId, siteId, userId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(getCombinedReviewOptionsCacheKey(quizId, userId));
        });
    };
        self.invalidateContent = function(moduleId, courseId, siteId) {
        siteId = siteId || $mmSite.getId();
       return self.getQuiz(courseId, moduleId, siteId).then(function(quiz) {
            return $mmaModQuiz.getUserAttempts(quiz.id, 'all', true, false, false, siteId).then(function(attempts) {
                var lastAttemptId = attempts.length ? attempts[attempts.length - 1].id : undefined;
                return self.invalidateAllQuizData(quiz.id, courseId, lastAttemptId, siteId);
            });
        });
    };
        self.invalidateFeedback = function(quizId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKeyStartingWith(getFeedbackForGradeCommonCacheKey(quizId));
        });
    };
        self.invalidateFeedbackForGrade = function(quizId, grade, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getFeedbackForGradeCacheKey(quizId, grade));
        });
    };
        self.invalidateFiles = function(moduleId) {
        return $mmFilepool.invalidateFilesByComponent($mmSite.getId(), mmaModQuizComponent, moduleId);
    };
         self.invalidateGradeFromGradebook = function(courseId, siteId, userId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            return $mmGrades.invalidateGradeModuleItems(courseId, userId, null, siteId);
        });
    };
        self.invalidateQuizAccessInformation = function(quizId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getQuizAccessInformationCacheKey(quizId));
        });
    };
        self.invalidateQuizRequiredQtypes = function(quizId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getQuizRequiredQtypesCacheKey(quizId));
        });
    };
        self.invalidateUserAttempts = function(quizId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKeyStartingWith(getUserAttemptsCommonCacheKey(quizId));
        });
    };
        self.invalidateUserAttemptsForUser = function(quizId, siteId, userId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(getUserAttemptsCacheKey(quizId, userId));
        });
    };
        self.invalidateUserBestGrade = function(quizId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKeyStartingWith(getUserBestGradeCommonCacheKey(quizId));
        });
    };
        self.invalidateUserBestGradeForUser = function(quizId, siteId, userId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(getUserBestGradeCacheKey(quizId, userId));
        });
    };
        self.invalidateQuizData = function(courseId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getQuizDataCacheKey(courseId));
        });
    };
        self.isAttemptFinished = function(state) {
        return state == self.ATTEMPT_FINISHED || state == self.ATTEMPT_ABANDONED;
    };
        self.isAttemptFinishedOffline = function(attemptId, siteId) {
        return $mmaModQuizOffline.getAttemptById(attemptId, siteId).then(function(attempt) {
            return !!attempt.finished;
        }).catch(function() {
            return false;
        });
    };
        self.isAttemptTimeNearlyOver = function(quiz, attempt) {
        if (attempt.state != self.ATTEMPT_IN_PROGRESS) {
            return true;
        }
        var dueDate = self.getAttemptDueDate(quiz, attempt),
            autoSavePeriod = quiz.autosaveperiod || 0;
        if (dueDate > 0 && new Date().getTime() + autoSavePeriod >= dueDate) {
            return true;
        }
        return false;
    };
        self.isLastAttemptOfflineUnfinished = function(quiz, siteId, userId) {
        return $mmaModQuizOffline.getQuizAttempts(quiz.id, siteId, userId).then(function(attempts) {
            var last = attempts.pop();
            return last && !last.finished;
        }).catch(function() {
            return false;
        });
    };
        self.isNavigationSequential = function(quiz) {
        return quiz.navmethod == "sequential";
    };
        self.isPluginEnabled = function(siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.wsAvailable('mod_quiz_get_attempt_review');
        });
    };
        self.isQuestionBlocked = function(question) {
        var div = document.createElement('div');
        div.innerHTML = question.html;
        return !!div.querySelector('.mod_quiz-blocked_question_warning');
    };
        self.isQuizOffline = function(quiz) {
        return !!quiz.allowofflineattempts;
    };
        self.loadFinishedOfflineData = function(attempts, siteId) {
        if (attempts.length) {
            var lastAttempt = attempts[attempts.length - 1];
            return self.isAttemptFinishedOffline(lastAttempt.id, siteId).then(function(finished) {
                lastAttempt.finishedOffline = finished;
            });
        }
        return $q.when();
    };
        self.logViewAttempt = function(attemptId, page, preflightData, offline) {
        if (typeof page == 'undefined') {
            page = 0;
        }
        var params = {
                attemptid: attemptId,
                page: page,
                preflightdata: $mmUtil.objectToArrayOfObjects(preflightData, 'name', 'value', true)
            },
            promises = [];
        promises.push($mmSite.write('mod_quiz_view_attempt', params));
        if (offline) {
            promises.push($mmaModQuizOffline.setAttemptCurrentPage(attemptId, page));
        }
        return $q.all(promises);
    };
        self.logViewAttemptReview = function(attemptId) {
        var params = {
            attemptid: attemptId
        };
        return $mmSite.write('mod_quiz_view_attempt_review', params);
    };
        self.logViewAttemptSummary = function(attemptId, preflightData) {
        var params = {
            attemptid: attemptId,
            preflightdata: $mmUtil.objectToArrayOfObjects(preflightData, 'name', 'value', true)
        };
        return $mmSite.write('mod_quiz_view_attempt_summary', params);
    };
        self.logViewQuiz = function(id) {
        if (id) {
            var params = {
                quizid: id
            };
            return $mmSite.write('mod_quiz_view_quiz', params);
        }
        return $q.reject();
    };
        self.processAttempt = function(quiz, attempt, data, preflightData, finish, timeup, offline, siteId) {
        try {
            if (offline) {
                return processOfflineAttempt(quiz, attempt, data, preflightData, finish, siteId);
            }
            return $mmaModQuizOnline.processAttempt(attempt.id, data, preflightData, finish, timeup, siteId);
        } catch(ex) {
            console.error(ex);
            return $q.reject();
        }
    };
        function processOfflineAttempt(quiz, attempt, data, preflightData, finish, siteId) {
        return self.getAttemptSummary(attempt.id, preflightData, true, false, siteId).then(function(questionArray) {
            var questions = {};
            questionArray.forEach(function(question) {
                questions[question.slot] = question;
            });
            return $mmaModQuizOffline.processAttempt(quiz, attempt, questions, data, finish, siteId);
        });
    }
        self.quizHasGrades = function(quiz) {
        return quiz.grade >= 0.000005 && quiz.sumgrades >= 0.000005;
    };
        self.rescaleGrade = function(rawGrade, quiz, format) {
        var grade;
        if (typeof format == 'undefined') {
            format = true;
        }
        rawGrade = parseFloat(rawGrade);
        if (!isNaN(rawGrade)) {
            if (quiz.sumgrades >= 0.000005) {
                grade = rawGrade * quiz.grade / quiz.sumgrades;
            } else {
                grade = 0;
            }
        }
        if (format === 'question') {
            grade = self.formatGrade(grade, self.getGradeDecimals(quiz));
        } else if (format) {
            grade = self.formatGrade(grade, quiz.decimalpoints);
        }
        return grade;
    };
        self.saveAttempt = function(quiz, attempt, data, preflightData, offline, siteId) {
        try {
            if (offline) {
                return processOfflineAttempt(quiz, attempt, data, preflightData, false, siteId);
            }
            return $mmaModQuizOnline.saveAttempt(attempt.id, data, preflightData, siteId);
        } catch(ex) {
            console.error(ex);
            return $q.reject();
        }
    };
        self.shouldShowTimeLeft = function(rules, attempt, endTime) {
        var timeNow = $mmUtil.timestamp();
        if (attempt.state != self.ATTEMPT_IN_PROGRESS) {
            return false;
        }
        return $mmaModQuizAccessRulesDelegate.shouldShowTimeLeft(rules, attempt, endTime, timeNow);
    };
        self.startAttempt = function(quizId, preflightData, forceNew, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    quizid: quizId,
                    preflightdata: $mmUtil.objectToArrayOfObjects(preflightData, 'name', 'value', true),
                    forcenew: forceNew ? 1 : 0
                };
            return site.write('mod_quiz_start_attempt', params).then(function(response) {
                if (response && response.warnings && response.warnings.length) {
                    return $q.reject(response.warnings[0].message);
                } else if (response && response.attempt) {
                    return response.attempt;
                }
                return $q.reject();
            });
        });
    };
    return self;
}]);

angular.module('mm.addons.mod_quiz')
.constant('mmaModQuizAttemptsStore', 'mod_quiz_attempts')
.config(["$mmSitesFactoryProvider", "mmaModQuizAttemptsStore", function($mmSitesFactoryProvider, mmaModQuizAttemptsStore) {
    var stores = [
        {
            name: mmaModQuizAttemptsStore,
            keyPath: 'id',
            indexes: [
                {
                    name: 'attempt'
                },
                {
                    name: 'userid'
                },
                {
                    name: 'quizid'
                },
                {
                    name: 'courseid'
                },
                {
                    name: 'timemodified'
                },
                {
                    name: 'finished'
                },
                {
                    name: 'quizAndUser',
                    keyPath: ['quizid', 'userid']
                }
            ]
        }
    ];
    $mmSitesFactoryProvider.registerStores(stores);
}])
.factory('$mmaModQuizOffline', ["$log", "$mmSite", "$mmSitesManager", "$mmUtil", "$q", "$mmQuestion", "$mmQuestionBehaviourDelegate", "$translate", "mmaModQuizAttemptsStore", "mmaModQuizComponent", function($log, $mmSite, $mmSitesManager, $mmUtil, $q, $mmQuestion, $mmQuestionBehaviourDelegate,
            $translate, mmaModQuizAttemptsStore, mmaModQuizComponent) {
    $log = $log.getInstance('$mmaModQuizOffline');
    var self = {};
        self.classifyAnswersInQuestions = function(answers) {
        var questionsWithAnswers = {};
        angular.forEach(answers, function(value, name) {
            var slot = $mmQuestion.getQuestionSlotFromName(name),
                nameWithoutPrefix = $mmQuestion.removeQuestionPrefix(name);
            if (!questionsWithAnswers[slot]) {
                questionsWithAnswers[slot] = {
                    answers: {},
                    prefix: name.substr(0, name.indexOf(nameWithoutPrefix))
                };
            }
            questionsWithAnswers[slot].answers[nameWithoutPrefix] = value;
        });
        return questionsWithAnswers;
    };
        self.extractAnswersFromQuestions = function(questions) {
        var answers = {};
        angular.forEach(questions, function(question) {
            angular.forEach(question.answers, function(value, name) {
                answers[question.prefix + name] = value;
            });
        });
        return answers;
    };
        self.getAllAttempts = function(siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSiteDb(siteId).then(function(db) {
            if (!db) {
                return $q.reject();
            }
            return db.getAll(mmaModQuizAttemptsStore);
        });
    };
        self.getAttemptAnswers = function(attemptId, siteId) {
        return $mmQuestion.getAttemptAnswers(mmaModQuizComponent, attemptId, siteId);
    };
        self.getAttemptById = function(attemptId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.getDb().get(mmaModQuizAttemptsStore, attemptId);
        });
    };
        self.getQuizAttempts = function(quizId, siteId, userId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            return site.getDb().whereEqual(mmaModQuizAttemptsStore, 'quizAndUser', [quizId, userId]);
        });
    };
        self.loadQuestionsLocalStates = function(attemptId, questions, siteId) {
        var promises = [];
        angular.forEach(questions, function(question) {
            promises.push($mmQuestion.getQuestion(mmaModQuizComponent, attemptId, question.slot, siteId).then(function(q) {
                var state = $mmQuestion.getState(q.state);
                question.state = q.state;
                question.status = $translate.instant('mm.question.' + state.status);
            }).catch(function() {
            }));
        });
        return $q.all(promises).then(function() {
            return questions;
        });
    };
        self.processAttempt = function(quiz, attempt, questions, data, finish, siteId) {
        siteId = siteId || $mmSite.getId();
        var now = $mmUtil.timestamp(),
            db;
        return $mmSitesManager.getSite(siteId).then(function(site) {
            db = site.getDb();
            return self.getAttemptById(attempt.id, siteId).catch(function() {
                return {
                    quizid: quiz.id,
                    userid: attempt.userid,
                    id: attempt.id,
                    courseid: quiz.course,
                    timecreated: now,
                    attempt: attempt.attempt,
                    currentpage: attempt.currentpage
                };
            });
        }).then(function(entry) {
            entry.timemodified = now;
            entry.finished = !!finish;
            return db.insert(mmaModQuizAttemptsStore, entry);
        }).then(function() {
            return self.saveAnswers(quiz, attempt, questions, data, now, siteId);
        });
    };
        self.removeAttemptAndAnswers = function(attemptId, siteId) {
        siteId = siteId || $mmSite.getId();
        var promises = [];
        promises.push($mmQuestion.removeAttemptAnswers(mmaModQuizComponent, attemptId, siteId));
        promises.push($mmQuestion.removeAttemptQuestions(mmaModQuizComponent, attemptId, siteId));
        promises.push($mmSitesManager.getSite(siteId).then(function(site) {
            return site.getDb().remove(mmaModQuizAttemptsStore, attemptId);
        }));
        return $q.all(promises);
    };
        self.removeQuestionAndAnswers = function(attemptId, slot, siteId) {
        siteId = siteId || $mmSite.getId();
        var promises = [];
        promises.push($mmQuestion.removeQuestion(mmaModQuizComponent, attemptId, slot, siteId));
        promises.push($mmQuestion.removeQuestionAnswers(mmaModQuizComponent, attemptId, slot, siteId));
        return $q.all(promises);
    };
        self.saveAnswers = function(quiz, attempt, questions, answers, timemod, siteId) {
        siteId = siteId || $mmSite.getId();
        timemod = timemod || $mmUtil.timestamp();
        var promises = [],
            questionsWithAnswers = {},
            newStates = {};
        angular.forEach(answers, function(value, name) {
            var slot = $mmQuestion.getQuestionSlotFromName(name),
                nameWithoutPrefix = $mmQuestion.removeQuestionPrefix(name);
            if (questions[slot]) {
                if (!questionsWithAnswers[slot]) {
                    questionsWithAnswers[slot] = questions[slot];
                    questionsWithAnswers[slot].answers = {};
                }
                questionsWithAnswers[slot].answers[nameWithoutPrefix] = value;
            }
        });
        angular.forEach(questionsWithAnswers, function(question) {
            promises.push($mmQuestionBehaviourDelegate.determineQuestionState(
                        quiz.preferredbehaviour, mmaModQuizComponent, attempt.id, question, siteId).then(function(state) {
                if (state) {
                    newStates[question.slot] = state.name;
                }
            }));
        });
        return $q.all(promises).then(function() {
            return $mmQuestion.saveAnswers(mmaModQuizComponent, quiz.id, attempt.id, attempt.userid, answers, timemod, siteId);
        }).then(function() {
            promises = [];
            angular.forEach(newStates, function(state, slot) {
                var question = questionsWithAnswers[slot];
                promises.push(
                    $mmQuestion.saveQuestion(mmaModQuizComponent, quiz.id, attempt.id, attempt.userid, question, state, siteId)
                );
            });
            return $mmUtil.allPromises(promises).catch(function() {
                $log.error('Error saveQuestion');
            });
        });
    };
        self.setAttemptCurrentPage = function(attemptId, page, siteId) {
        siteId = siteId || $mmSite.getId();
        var entry;
        return self.getAttemptById(attemptId, siteId).then(function(e) {
            entry = e;
            return $mmSitesManager.getSite(siteId);
        }).then(function(site) {
            entry.currentpage = page;
            return site.getDb().insert(mmaModQuizAttemptsStore, entry);
        });
    };
    return self;
}]);

angular.module('mm.addons.mod_quiz')
.factory('$mmaModQuizOnline', ["$log", "$mmSite", "$mmSitesManager", "$q", "$mmUtil", function($log, $mmSite, $mmSitesManager, $q, $mmUtil) {
    $log = $log.getInstance('$mmaModQuizOnline');
    var self = {};
        self.processAttempt = function(attemptId, data, preflightData, finish, timeup, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                attemptid: attemptId,
                data: $mmUtil.objectToArrayOfObjects(data, 'name', 'value'),
                finishattempt: finish ? 1 : 0,
                timeup: timeup ? 1 : 0,
                preflightdata: $mmUtil.objectToArrayOfObjects(preflightData, 'name', 'value')
            };
            return site.write('mod_quiz_process_attempt', params).then(function(response) {
                if (response && response.warnings && response.warnings.length) {
                    return $q.reject(response.warnings[0].message);
                } else if (response && response.state) {
                    return response.state;
                }
                return $q.reject();
            });
        });
    };
        self.saveAttempt = function(attemptId, data, preflightData, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                attemptid: attemptId,
                data: $mmUtil.objectToArrayOfObjects(data, 'name', 'value'),
                preflightdata: $mmUtil.objectToArrayOfObjects(preflightData, 'name', 'value')
            };
            return site.write('mod_quiz_save_attempt', params).then(function(response) {
                if (response && response.warnings && response.warnings.length) {
                    return $q.reject(response.warnings[0].message);
                } else if (!response || !response.status) {
                    return $q.reject();
                }
            });
        });
    };
    return self;
}]);

angular.module('mm.addons.mod_quiz')
.factory('$mmaModQuizSync', ["$log", "$mmaModQuiz", "$mmSite", "$mmSitesManager", "$q", "$mmaModQuizOffline", "$mmQuestion", "$mmLang", "$mmQuestionDelegate", "$mmApp", "$mmEvents", "$translate", "mmaModQuizSyncTime", "$mmSync", "mmaModQuizEventAutomSynced", "mmaModQuizComponent", "$mmaModQuizPrefetchHandler", "$mmCourse", "$mmSyncBlock", function($log, $mmaModQuiz, $mmSite, $mmSitesManager, $q, $mmaModQuizOffline, $mmQuestion, $mmLang,
            $mmQuestionDelegate, $mmApp, $mmEvents, $translate, mmaModQuizSyncTime, $mmSync, mmaModQuizEventAutomSynced,
            mmaModQuizComponent, $mmaModQuizPrefetchHandler, $mmCourse, $mmSyncBlock) {
    $log = $log.getInstance('$mmaModQuizSync');
    var self = $mmSync.createChild(mmaModQuizComponent, mmaModQuizSyncTime);
        self.hasDataToSync = function(quizId, siteId) {
        return $mmaModQuizOffline.getQuizAttempts(quizId, siteId).then(function(attempts) {
            return !!attempts.length;
        }).catch(function() {
            return false;
        });
    };
        self.syncAllQuizzes = function(siteId) {
        if (!$mmApp.isOnline()) {
            $log.debug('Cannot sync all quizzes because device is offline.');
            return $q.reject();
        }
        var promise;
        if (!siteId) {
            $log.debug('Try to sync quizzes in all sites.');
            promise = $mmSitesManager.getSitesIds();
        } else {
            $log.debug('Try to sync quizzes in site ' + siteId);
            promise = $q.when([siteId]);
        }
        return promise.then(function(siteIds) {
            var sitePromises = [];
            angular.forEach(siteIds, function(siteId) {
                sitePromises.push($mmaModQuizOffline.getAllAttempts(siteId).then(function(attempts) {
                    var quizzes = [],
                        ids = [],
                        promises = [];
                    angular.forEach(attempts, function(attempt) {
                        if (ids.indexOf(attempt.quizid) == -1) {
                            ids.push(attempt.quizid);
                            quizzes.push({
                                id: attempt.quizid,
                                courseid: attempt.courseid
                            });
                        }
                    });
                    angular.forEach(quizzes, function(quiz) {
                        if (!$mmSyncBlock.isBlocked(mmaModQuizComponent, quiz.id, siteId)) {
                            promises.push($mmaModQuiz.getQuizById(quiz.courseid, quiz.id, siteId).then(function(quiz) {
                                return self.syncQuizIfNeeded(quiz, false, siteId).then(function(data) {
                                    if (data && data.warnings && data.warnings.length) {
                                        return self.setSyncWarnings(quiz.id, data.warnings, siteId).then(function() {
                                            return data;
                                        });
                                    }
                                    return data;
                                }).then(function(data) {
                                    if (typeof data != 'undefined') {
                                        $mmEvents.trigger(mmaModQuizEventAutomSynced, {
                                            siteid: siteId,
                                            quizid: quiz.id,
                                            attemptFinished: data.attemptFinished,
                                            warnings: data.warnings
                                        });
                                    }
                                });
                            }));
                        }
                    });
                    return $q.all(promises);
                }));
            });
            return $q.all(sitePromises);
        });
    };
        self.syncQuizIfNeeded = function(quiz, askPreflight, siteId) {
        return self.isSyncNeeded(quiz.id, siteId).then(function(needed) {
            if (needed) {
                return self.syncQuiz(quiz, askPreflight, siteId);
            }
        });
    };
        self.syncQuiz = function(quiz, askPreflight, siteId) {
        siteId = siteId || $mmSite.getId();
        var warnings = [],
            syncPromise,
            courseId = quiz.course,
            offlineAttempt,
            onlineAttempt,
            preflightData = {};
        if (self.isSyncing(quiz.id, siteId)) {
            return self.getOngoingSync(quiz.id, siteId);
        }
        if ($mmSyncBlock.isBlocked(mmaModQuizComponent, quiz.id, siteId)) {
            $log.debug('Cannot sync quiz ' + quiz.id + ' because it is blocked.');
            var modulename = $mmCourse.translateModuleName('quiz');
            return $mmLang.translateAndReject('mm.core.errorsyncblocked', {$a: modulename});
        }
        $log.debug('Try to sync quiz ' + quiz.id + ' in site ' + siteId);
        function finishSync(attemptId, removeAttempt, updated) {
            return $mmaModQuiz.invalidateAllQuizData(quiz.id, courseId, attemptId, siteId).catch(function() {}).then(function() {
                if (removeAttempt && offlineAttempt) {
                    return $mmaModQuizOffline.removeAttemptAndAnswers(offlineAttempt.id, siteId);
                }
            }).then(function() {
                if (updated) {
                    return $mmaModQuizPrefetchHandler.prefetchQuizAndLastAttempt(quiz, siteId);
                }
            }).then(function() {
                return self.setSyncTime(quiz.id, siteId).catch(function() {
                });
            }).then(function() {
                if (onlineAttempt && !$mmaModQuiz.isAttemptFinished(onlineAttempt.state)) {
                    return $mmaModQuiz.getUserAttempts(quiz.id, 'all', true, false, false, siteId).then(function(attempts) {
                        var isFinishedNow = true;
                        angular.forEach(attempts, function(attempt) {
                            if (attempt.id == onlineAttempt.id) {
                                isFinishedNow = $mmaModQuiz.isAttemptFinished(attempt.state);
                            }
                        });
                        return isFinishedNow;
                    });
                }
                return false;
            }).then(function(attemptFinished) {
                return {
                    warnings: warnings,
                    attemptFinished: attemptFinished
                };
            });
        }
        syncPromise = $mmaModQuizOffline.getQuizAttempts(quiz.id, siteId).then(function(attempts) {
            if (!attempts.length) {
                return finishSync();
            }
            offlineAttempt = attempts.pop();
            return $mmaModQuiz.getUserAttempts(quiz.id, 'all', true, false, true, siteId).then(function(attempts) {
                var lastAttemptId = attempts.length ? attempts[attempts.length - 1].id : undefined;
                angular.forEach(attempts, function(attempt) {
                    if (attempt.id == offlineAttempt.id) {
                        onlineAttempt = attempt;
                    }
                });
                if (!onlineAttempt || $mmaModQuiz.isAttemptFinished(onlineAttempt.state)) {
                    warnings.push($translate.instant('mma.mod_quiz.warningattemptfinished'));
                    return finishSync(lastAttemptId, true);
                }
                return $mmaModQuizOffline.getAttemptAnswers(offlineAttempt.id, siteId).then(function(answers) {
                    var offlineQuestions,
                        pages,
                        finish;
                    if (!answers.length) {
                        return finishSync(lastAttemptId, true);
                    }
                    answers = $mmQuestion.convertAnswersArrayToObject(answers);
                    offlineQuestions = $mmaModQuizOffline.classifyAnswersInQuestions(answers);
                    return $mmaModQuiz.getQuizAccessInformation(quiz.id, false, true, siteId).then(function(info) {
                        return $mmaModQuizPrefetchHandler.gatherPreflightData(quiz, info, onlineAttempt,
                                                preflightData, siteId, askPreflight, 'mm.settings.synchronization');
                    }).then(function() {
                        pages = $mmaModQuiz.getPagesFromLayoutAndQuestions(onlineAttempt.layout, offlineQuestions);
                        return $mmaModQuiz.getAllQuestionsData(quiz, onlineAttempt, preflightData, pages, false, true, siteId);
                    }).then(function(onlineQuestions) {
                        return self.validateQuestions(onlineAttempt.id, onlineQuestions, offlineQuestions, siteId);
                    }).then(function(discardedData) {
                        var answers = $mmaModQuizOffline.extractAnswersFromQuestions(offlineQuestions);
                        finish = offlineAttempt.finished && !discardedData;
                        if (discardedData) {
                            if (offlineAttempt.finished) {
                                warnings.push($translate.instant('mma.mod_quiz.warningdatadiscardedfromfinished'));
                            } else {
                                warnings.push($translate.instant('mma.mod_quiz.warningdatadiscarded'));
                            }
                        }
                        return $mmaModQuiz.processAttempt(quiz, onlineAttempt, answers, preflightData, finish, false, false, siteId);
                    }).then(function() {
                        if (!finish) {
                            return $mmaModQuiz.logViewAttempt(onlineAttempt.id, offlineAttempt.currentpage, preflightData, false)
                                    .catch(function() {
                            });
                        }
                    }).then(function() {
                        return finishSync(lastAttemptId, true, true);
                    });
                });
            });
        });
        return self.addOngoingSync(quiz.id, syncPromise, siteId);
    };
        self.validateQuestions = function(attemptId, onlineQuestions, offlineQuestions, siteId) {
        var discardedData = false,
            promises = [];
        angular.forEach(offlineQuestions, function(offlineQuestion, slot) {
            var onlineQuestion = onlineQuestions[slot],
                offlineSequenceCheck = offlineQuestion.answers[':sequencecheck'];
            if (onlineQuestion) {
                if (!$mmQuestionDelegate.validateSequenceCheck(onlineQuestion, offlineSequenceCheck)) {
                    discardedData = true;
                    promises.push($mmaModQuizOffline.removeQuestionAndAnswers(attemptId, slot, siteId));
                    delete offlineQuestions[slot];
                } else {
                    offlineQuestion.answers[':sequencecheck'] = onlineQuestion.sequencecheck;
                }
            } else {
                discardedData = true;
                promises.push($mmaModQuizOffline.removeQuestionAndAnswers(attemptId, slot, siteId));
                delete offlineQuestions[slot];
            }
        });
        return $q.all(promises).then(function() {
            return discardedData;
        });
    };
    return self;
}]);

angular.module('mm.addons.mod_resource')
.controller('mmaModResourceIndexCtrl', ["$scope", "$stateParams", "$mmUtil", "$mmaModResource", "$log", "$mmApp", "$mmCourse", "$timeout", "$mmText", "$translate", "mmaModResourceComponent", "$mmaModResourcePrefetchHandler", "$mmCourseHelper", "$mmaModResourceHelper", function($scope, $stateParams, $mmUtil, $mmaModResource, $log, $mmApp, $mmCourse, $timeout,
        $mmText, $translate, mmaModResourceComponent, $mmaModResourcePrefetchHandler, $mmCourseHelper, $mmaModResourceHelper) {
    $log = $log.getInstance('mmaModResourceIndexCtrl');
    var module = $stateParams.module || {},
        courseId = $stateParams.courseid;
    $scope.title = module.name;
    $scope.description = module.description;
    $scope.externalUrl = module.url;
    $scope.mode = false;
    $scope.loaded = false;
    $scope.refreshIcon = 'spinner';
    $scope.component = mmaModResourceComponent;
    $scope.componentId = module.id;
    function fetchContent(refresh) {
        return $mmCourse.loadModuleContents(module, courseId, null, false, refresh).then(function() {
            if (!module.contents || !module.contents.length) {
                return $q.reject();
            }
            if ($mmaModResource.isDisplayedInIframe(module)) {
                $scope.mode = 'iframe';
                var downloadFailed = false;
                return $mmaModResourcePrefetchHandler.download(module).catch(function() {
                    downloadFailed = true;
                }).then(function() {
                    return $mmaModResource.getIframeSrc(module).then(function(src) {
                        if ($scope.src && src.toString() == $scope.src.toString()) {
                            $scope.src = '';
                            $timeout(function() {
                                $scope.src = src;
                            });
                        } else {
                            $scope.src = src;
                        }
                        if (downloadFailed && $mmApp.isOnline()) {
                            $mmUtil.showErrorModal('mm.core.errordownloadingsomefiles', true);
                        }
                    });
                });
            } else {
                $scope.mode = 'external';
                $scope.open = function() {
                    $mmaModResourceHelper.openFile(module, courseId);
                };
            }
        }).then(function() {
            return $mmCourse.getModule(module.id, courseId).then(function(mod) {
                $scope.title = mod.name;
                $scope.description = mod.description;
            }).catch(function() {
            });
        }).then(function() {
            $mmCourseHelper.fillContextMenu($scope, module, courseId, refresh, mmaModResourceComponent);
        }).catch(function(error) {
            $mmUtil.showErrorModalDefault(error, 'mma.mod_resource.errorwhileloadingthecontent', true);
            return $q.reject();
        }).finally(function() {
            $scope.loaded = true;
            $scope.refreshIcon = 'ion-refresh';
        });
    }
    $scope.removeFiles = function() {
        $mmCourseHelper.confirmAndRemove(module, courseId);
    };
    $scope.prefetch = function() {
        $mmCourseHelper.contextMenuPrefetch($scope, module, courseId);
    };
    $scope.expandDescription = function() {
        $mmText.expandText($translate.instant('mm.core.description'), $scope.description, false,
                    mmaModResourceComponent, module.id);
    };
    $scope.doRefresh = function() {
        if ($scope.loaded) {
            $scope.refreshIcon = 'spinner';
            return $mmaModResourcePrefetchHandler.invalidateContent(module.id).then(function() {
                return fetchContent(true);
            }).finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        }
    };
    fetchContent().then(function() {
        $mmaModResource.logView(module.instance).then(function() {
            $mmCourse.checkModuleCompletion(courseId, module.completionstatus);
        });
    });
}]);

angular.module('mm.addons.mod_resource')
.directive('mmaModResourceHtmlLink', function() {
    return {
        restrict: 'A',
        priority: 99,  
        link: function(scope, element, attrs) {
            element.on('click', function(event) {
                var href = element[0].getAttribute('data-href');
                if (!href) {
                    return;
                }
                event.stopImmediatePropagation();
                event.preventDefault();
                scope.$emit('mmaModResourceHtmlLinkClicked', href);
            });
        }
    };
});

angular.module('mm.addons.mod_resource')
.factory('$mmaModResourceHandlers', ["$mmCourse", "$mmaModResource", "$mmEvents", "$state", "$mmSite", "$mmCourseHelper", "$mmUtil", "$mmCoursePrefetchDelegate", "$mmFS", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", "$mmaModResourceHelper", "mmCoreEventPackageStatusChanged", "mmaModResourceComponent", "$mmContentLinksHelper", "$mmaModResourcePrefetchHandler", "mmCoreDownloaded", function($mmCourse, $mmaModResource, $mmEvents, $state, $mmSite, $mmCourseHelper, $mmUtil,
            $mmCoursePrefetchDelegate, $mmFS, mmCoreDownloading, mmCoreNotDownloaded, mmCoreOutdated, $mmaModResourceHelper,
            mmCoreEventPackageStatusChanged, mmaModResourceComponent, $mmContentLinksHelper, $mmaModResourcePrefetchHandler,
            mmCoreDownloaded) {
    var self = {};
        self.courseContent = function() {
        var self = {};
                self.isEnabled = function() {
            return $mmaModResource.isPluginEnabled();
        };
                self.getController = function(module, courseId) {
            return function($scope) {
                var downloadBtn,
                    refreshBtn,
                    openBtn;
                downloadBtn = {
                    hidden: true,
                    icon: 'ion-ios-cloud-download-outline',
                    label: 'mm.core.download',
                    action: function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        download(false);
                    }
                };
                refreshBtn = {
                    icon: 'ion-android-refresh',
                    label: 'mm.core.refresh',
                    hidden: true,
                    action: function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        download(true);
                    }
                };
                openBtn = {
                    hidden: true,
                    icon: 'ion-document',
                    label: 'mma.mod_resource.openthefile',
                    action: function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        $mmaModResourceHelper.openFile(module, courseId);
                    }
                };
                $scope.title = module.name;
                $scope.class = 'mma-mod_resource-handler';
                $scope.buttons = [downloadBtn, refreshBtn, openBtn];
                $scope.spinner = true;
                $scope.icon = $mmCourse.getModuleIconSrc('resource');
                $mmCourse.loadModuleContents(module, courseId).then(function() {
                    if (module.contents.length) {
                        var filename = module.contents[0].filename,
                            extension = $mmFS.getFileExtension(filename);
                        if (module.contents.length == 1 || (extension != "html" && extension != "htm")) {
                            $scope.icon = $mmFS.getFileIcon(filename);
                        } else {
                            $scope.icon = $mmCourse.getModuleIconSrc('resource');
                        }
                    } else {
                        $scope.icon = $mmCourse.getModuleIconSrc('resource');
                    }
                });
                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_resource', {module: module, courseid: courseId});
                };
                function download(refresh) {
                    var dwnBtnHidden = downloadBtn.hidden,
                        rfrshBtnHidden = refreshBtn.hidden,
                        openBtnHidden = openBtn.hidden;
                    $scope.spinner = true;
                    downloadBtn.hidden = true;
                    refreshBtn.hidden = true;
                    openBtn.hidden = true;
                    $mmaModResourcePrefetchHandler.getDownloadSize(module, courseId).then(function(size) {
                        $mmCourseHelper.prefetchModule($scope, $mmaModResourcePrefetchHandler, module, size, refresh, courseId)
                                .catch(function() {
                            $scope.spinner = false;
                            downloadBtn.hidden = dwnBtnHidden;
                            refreshBtn.hidden = rfrshBtnHidden;
                            openBtn.hidden = openBtnHidden;
                        });
                    }).catch(function(error) {
                        $scope.spinner = false;
                        downloadBtn.hidden = dwnBtnHidden;
                        refreshBtn.hidden = rfrshBtnHidden;
                        openBtn.hidden = openBtnHidden;
                        $mmUtil.showErrorModalDefault(error, 'mm.core.errordownloading', true);
                    });
                }
                function showStatus(status) {
                    if (status) {
                        $scope.spinner = status === mmCoreDownloading;
                        downloadBtn.hidden = status !== mmCoreNotDownloaded;
                        refreshBtn.hidden = status !== mmCoreOutdated;
                        openBtn.hidden = status !== mmCoreDownloaded || $mmaModResource.isDisplayedInIframe(module);
                    }
                }
                var statusObserver = $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
                    if (data.siteid === $mmSite.getId() && data.componentId === module.id &&
                            data.component === mmaModResourceComponent) {
                        showStatus(data.status);
                    }
                });
                $mmCoursePrefetchDelegate.getModuleStatus(module, courseId).then(showStatus);
                $scope.$on('$destroy', function() {
                    statusObserver && statusObserver.off && statusObserver.off();
                });
            };
        };
        return self;
    };
        self.linksHandler = $mmContentLinksHelper.createModuleIndexLinkHandler('mmaModResource', 'resource', $mmaModResource);
    return self;
}]);

angular.module('mm.addons.mod_resource')
.factory('$mmaModResourceHelper', ["$mmUtil", "$mmaModResource", "$mmCourse", function($mmUtil, $mmaModResource, $mmCourse) {
    var self = {};
        self.openFile = function(module, courseId) {
        var modal = $mmUtil.showModalLoading();
        return $mmaModResource.openFile(module.contents, module.id).then(function() {
            $mmaModResource.logView(module.instance).then(function() {
                $mmCourse.checkModuleCompletion(courseId, module.completionstatus);
            });
        }).catch(function(error) {
            $mmUtil.showErrorModalDefault(error, 'mma.mod_resource.errorwhileloadingthecontent', true);
        }).finally(function() {
            modal.dismiss();
        });
    };
    return self;
}]);
angular.module('mm.addons.mod_resource')
.factory('$mmaModResourcePrefetchHandler', ["$mmaModResource", "$mmSite", "$mmFilepool", "$mmPrefetchFactory", "$q", "mmaModResourceComponent", function($mmaModResource, $mmSite, $mmFilepool, $mmPrefetchFactory, $q,
            mmaModResourceComponent) {
    var self = $mmPrefetchFactory.createPrefetchHandler(mmaModResourceComponent, true);
        self.download = function(module, courseId, single) {
        return downloadOrPrefetch(module, courseId, false);
    };
        function downloadOrPrefetch(module, courseId, prefetch) {
        var promise;
        if ($mmaModResource.isDisplayedInIframe(module)) {
            promise = $mmFilepool.getPackageDirPathByUrl($mmSite.getId(), module.url);
        } else {
            promise = $q.when();
        }
        return promise.then(function(dirPath) {
            return self.downloadOrPrefetch(module, courseId, prefetch, dirPath);
        });
    }
        self.prefetch = function(module, courseId, single) {
        return downloadOrPrefetch(module, courseId, true);
    };
    return self;
}]);

angular.module('mm.addons.mod_resource')
.factory('$mmaModResource', ["$mmFilepool", "$mmSite", "$mmUtil", "$mmFS", "$http", "$log", "$q", "$sce", "$mmApp", "$mmSitesManager", "$mmText", "mmaModResourceComponent", "mmCoreNotDownloaded", "mmCoreDownloading", "mmCoreDownloaded", function($mmFilepool, $mmSite, $mmUtil, $mmFS, $http, $log, $q, $sce, $mmApp, $mmSitesManager,
            $mmText, mmaModResourceComponent, mmCoreNotDownloaded, mmCoreDownloading, mmCoreDownloaded) {
    $log = $log.getInstance('$mmaModResource');
    var self = {};
        self.getIframeSrc = function(module) {
        if (!module.contents.length) {
            return $q.reject();
        }
        var mainFile = module.contents[0],
            mainFilePath = mainFile.filename;
        if (mainFile.filepath !== '/') {
            mainFilePath = mainFile.filepath.substr(1) + mainFilePath;
        }
        return $mmFilepool.getPackageDirUrlByUrl($mmSite.getId(), module.url).then(function(dirPath) {
            return $sce.trustAsResourceUrl($mmFS.concatenatePaths(dirPath, mainFilePath));
        }, function() {
            if ($mmApp.isOnline() && mainFile.fileurl) {
                return $sce.trustAsResourceUrl($mmSite.fixPluginfileURL(mainFile.fileurl));
            }
            return $q.reject();
        });
    };
        self.getResourceHtml = function(contents, moduleId, target) {
        var indexUrl,
            paths = {},
            promise;
        angular.forEach(contents, function(content, index) {
            var url = content.fileurl,
                fullpath = content.filename;
            if (content.filepath !== '/') {
                fullpath = content.filepath.substr(1) + fullpath;
            }
            if (typeof target !== 'undefined' && target == fullpath) {
                indexUrl = url;
            } else if (typeof target === 'undefined' && index === 0) {
                indexUrl = url;
            } else {
                paths[$mmText.decodeURIComponent(fullpath)] = url;
            }
        });
        promise = (function() {
            if (!indexUrl) {
                $log.debug('Could not locate the index page');
                return $q.reject();
            }
            if ($mmFS.isAvailable()) {
                return $mmFilepool.downloadUrl($mmSite.getId(), indexUrl, false, mmaModResourceComponent, moduleId);
            } else {
                return $q.when($mmSite.fixPluginfileURL(indexUrl));
            }
        })();
        return promise.then(function(url) {
            return $http.get(url).then(function(response) {
                if (typeof response.data !== 'string') {
                    return $q.reject();
                } else {
                    return $mmUtil.restoreSourcesInHtml(response.data, paths, function(anchor, href) {
                        var ext = $mmFS.getFileExtension(href);
                        if (ext == 'html' || ext == 'html') {
                            anchor.setAttribute('mma-mod-resource-html-link', 1);
                            anchor.setAttribute('data-href', href);
                        }
                    });
                }
            });
        });
    };
        self.isDisplayedInIframe = function(module) {
        if (!module.contents.length) {
            return false;
        }
        var ext = $mmFS.getFileExtension(module.contents[0].filename);
        return (ext === 'htm' || ext === 'html') && $mmFS.isAvailable();
    };
        self.isDisplayedInline = function(module) {
        return self.isDisplayedInIframe(module);
    };
        self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.canDownloadFiles();
        });
    };
        self.logView = function(id) {
        if (id) {
            var params = {
                resourceid: id
            };
            return $mmSite.write('mod_resource_view_resource', params);
        }
        return $q.reject();
    };
        self.openFile = function(contents, moduleId) {
        if (!contents || !contents.length) {
            return $q.reject();
        }
        var files = [contents[0]],
            siteId = $mmSite.getId(),
            revision = $mmFilepool.getRevisionFromFileList(files),
            timeMod = $mmFilepool.getTimemodifiedFromFileList(files),
            component = mmaModResourceComponent,
            url = contents[0].fileurl,
            fixedUrl = $mmSite.fixPluginfileURL(url),
            promise;
        if ($mmFS.isAvailable()) {
            promise = $mmFilepool.getPackageStatus(siteId, component, moduleId, revision, timeMod).then(function(status) {
                var isWifi = !$mmApp.isNetworkAccessLimited(),
                    isOnline = $mmApp.isOnline();
                if (status === mmCoreDownloaded) {
                    return $mmFilepool.getUrlByUrl(siteId, url, component, moduleId, timeMod);
                } else if (status === mmCoreDownloading) {
                    return fixedUrl;
                } else {
                    if (!isOnline && status === mmCoreNotDownloaded) {
                        return $q.reject();
                    }
                    return $mmFilepool.shouldDownloadBeforeOpen(fixedUrl, contents[0].filesize).then(function() {
                        return $mmFilepool.downloadPackage(siteId, files, component, moduleId, revision, timeMod).then(function() {
                            return $mmFilepool.getUrlByUrl(siteId, url, component, moduleId, timeMod);
                        });
                    }, function() {
                        if (isWifi && isOnline) {
                            $mmFilepool.downloadPackage(siteId, files, component, moduleId, revision, timeMod);
                        }
                        if (status === mmCoreNotDownloaded || isOnline) {
                            return fixedUrl;
                        } else {
                            return $mmFilepool.getUrlByUrl(siteId, url, component, moduleId, timeMod);
                        }
                    });
                }
            });
        } else {
            promise = $q.when(fixedUrl);
        }
        return promise.then(function(url) {
            if (url.indexOf('http') === 0) {
                return $mmUtil.openOnlineFile(url);
            } else {
                return $mmUtil.openFile(url);
            }
        });
    };
    return self;
}]);

angular.module('mm.addons.mod_scorm')
.controller('mmaModScormIndexCtrl', ["$scope", "$stateParams", "$mmaModScorm", "$mmUtil", "$q", "$mmCourse", "$ionicScrollDelegate", "$mmCoursePrefetchDelegate", "$mmaModScormHelper", "$mmEvents", "$mmSite", "$state", "mmCoreOutdated", "mmCoreNotDownloaded", "mmCoreDownloading", "mmaModScormComponent", "mmCoreEventPackageStatusChanged", "$ionicHistory", "mmaModScormEventAutomSynced", "$mmaModScormSync", "$timeout", "$mmText", "$translate", "$mmaModScormPrefetchHandler", "$mmApp", "$mmCourseHelper", "mmCoreEventOnlineStatusChanged", function($scope, $stateParams, $mmaModScorm, $mmUtil, $q, $mmCourse, $ionicScrollDelegate,
            $mmCoursePrefetchDelegate, $mmaModScormHelper, $mmEvents, $mmSite, $state, mmCoreOutdated, mmCoreNotDownloaded,
            mmCoreDownloading, mmaModScormComponent, mmCoreEventPackageStatusChanged, $ionicHistory, mmaModScormEventAutomSynced,
            $mmaModScormSync, $timeout, $mmText, $translate, $mmaModScormPrefetchHandler, $mmApp, $mmCourseHelper,
            mmCoreEventOnlineStatusChanged) {
    var module = $stateParams.module || {},
        courseid = $stateParams.courseid,
        scorm,
        statusObserver, syncObserver, onlineObserver,
        currentStatus,
        lastAttempt,
        lastOffline = false,
        attempts,
        scrollView = $ionicScrollDelegate.$getByHandle('mmaModScormIndexScroll');
    $scope.title = module.name;
    $scope.description = module.description;
    $scope.moduleUrl = module.url;
    $scope.moduleName = $mmCourse.translateModuleName('scorm');
    $scope.currentOrganization = {};
    $scope.scormOptions = {
        mode: $mmaModScorm.MODENORMAL
    };
    $scope.refreshIcon = 'spinner';
    $scope.syncIcon = 'spinner';
    $scope.component = mmaModScormComponent;
    $scope.componentId = module.id;
    $scope.modenormal = $mmaModScorm.MODENORMAL;
    $scope.modebrowse = $mmaModScorm.MODEBROWSE;
    function fetchScormData(refresh, checkCompletion, showErrors) {
        $scope.isOnline = $mmApp.isOnline();
        return $mmaModScorm.getScorm(courseid, module.id, module.url).then(function(scormData) {
            scorm = scormData;
            $scope.title = scorm.name || $scope.title;
            $scope.description = scorm.intro || $scope.description;
            $scope.scorm = scorm;
            var result = $mmaModScorm.isScormSupported(scorm);
            if (result === true) {
                $scope.errorMessage = '';
            } else {
                $scope.errorMessage = result;
            }
            if (scorm.warningmessage) {
                return;
            }
            return syncScorm(showErrors).catch(function() {
            }).then(function() {
                $mmaModScormHelper.getScormReadableSyncTime(scorm.id).then(function(syncTime) {
                    $scope.syncTime = syncTime;
                });
                if (checkCompletion) {
                    $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
                }
                return $mmaModScorm.getAttemptCount(scorm.id).then(function(attemptsData) {
                    attempts = attemptsData;
                    $scope.hasOffline = attempts.offline.length;
                    return $mmaModScormHelper.determineAttemptToContinue(scorm, attempts).then(function(attempt) {
                        lastAttempt = attempt.number;
                        lastOffline = attempt.offline;
                        if (lastAttempt != attempts.lastAttempt.number) {
                            $scope.attemptToContinue = lastAttempt;
                        } else {
                            delete $scope.attemptToContinue;
                        }
                        return $mmaModScorm.isAttemptIncomplete(scorm.id, lastAttempt, lastOffline).then(function(incomplete) {
                            var promises = [];
                            scorm.incomplete = incomplete;
                            scorm.numAttempts = attempts.total;
                            scorm.grademethodReadable = $mmaModScorm.getScormGradeMethod(scorm);
                            scorm.attemptsLeft = $mmaModScorm.countAttemptsLeft(scorm, attempts.lastAttempt.number);
                            if (scorm.forceattempt && scorm.incomplete) {
                                $scope.scormOptions.newAttempt = true;
                            }
                            promises.push(getReportedGrades());
                            promises.push(fetchStructure());
                            if (!scorm.packagesize && $scope.errorMessage === '') {
                                promises.push($mmaModScorm.calculateScormSize(scorm).then(function(size) {
                                    scorm.packagesize = size;
                                }));
                            }
                            setStatusListener();
                            getStatus().then(showStatus);
                            return $q.all(promises);
                        });
                    });
                }).catch(function(message) {
                    return showError(message);
                });
            });
        }, function(message) {
            if (!refresh) {
                return refreshData();
            }
            return showError(message);
        }).then(function() {
            $scope.allDataLoaded = true;
            $mmCourseHelper.fillContextMenu($scope, module, courseid, refresh, mmaModScormComponent);
        });
    }
    function showError(message, defaultMessage) {
        defaultMessage = defaultMessage || 'mma.mod_scorm.errorgetscorm';
        if (message) {
            $mmUtil.showErrorModal(message);
        } else {
            $mmUtil.showErrorModal(defaultMessage, true);
        }
        return $q.reject();
    }
    function getReportedGrades() {
        var promises = [];
        scorm.onlineAttempts = {};
        scorm.offlineAttempts = {};
        attempts.online.forEach(function(attempt) {
            if (attempts.offline.indexOf(attempt) == -1) {
                promises.push(getAttemptGrade(scorm, attempt));
            }
        });
        attempts.offline.forEach(function(attempt) {
            promises.push(getAttemptGrade(scorm, attempt, true));
        });
        return $q.all(promises).then(function() {
            scorm.grade = $mmaModScorm.calculateScormGrade(scorm, scorm.onlineAttempts);
            angular.forEach(scorm.onlineAttempts, function(attempt) {
                attempt.grade = $mmaModScorm.formatGrade(scorm, attempt.grade);
            });
            angular.forEach(scorm.offlineAttempts, function(attempt) {
                attempt.grade = $mmaModScorm.formatGrade(scorm, attempt.grade);
            });
            scorm.grade = $mmaModScorm.formatGrade(scorm, scorm.grade);
        });
    }
    function getAttemptGrade(scorm, attempt, offline) {
        return $mmaModScorm.getAttemptGrade(scorm, attempt, offline).then(function(grade) {
            var entry = {
                number: attempt,
                grade: grade
            };
            if (offline) {
                scorm.offlineAttempts[attempt] = entry;
            } else {
                scorm.onlineAttempts[attempt] = entry;
            }
        });
    }
    function fetchStructure() {
        return $mmaModScorm.getOrganizations(scorm.id).then(function(organizations) {
            $scope.organizations = organizations;
            if (!$scope.currentOrganization.identifier) {
                if (organizations.length) {
                    $scope.currentOrganization.identifier = organizations[0].identifier;
                } else {
                    $scope.currentOrganization.identifier = '';
                }
            }
            return loadOrganizationToc($scope.currentOrganization.identifier);
        });
    }
    function loadOrganizationToc(organizationId) {
        if (!scorm.displaycoursestructure) {
            return $q.when();
        }
        $scope.loadingToc = true;
        return $mmaModScorm.getOrganizationToc(scorm.id, organizationId, lastAttempt, lastOffline).then(function(toc) {
            $scope.toc = $mmaModScorm.formatTocToArray(toc);
            angular.forEach($scope.toc, function(sco) {
                sco.image = $mmaModScorm.getScoStatusIcon(sco, scorm.incomplete);
            });
            angular.forEach($scope.organizations, function(org) {
                if (org.identifier == organizationId) {
                    $scope.currentOrganization.title = org.title;
                }
            });
            $ionicScrollDelegate.resize();
        }).finally(function() {
            $scope.loadingToc = false;
        });
    }
    function getStatus() {
        return $mmCoursePrefetchDelegate.getModuleStatus(module, courseid, scorm.sha1hash, 0);
    }
    function setStatusListener() {
        if (typeof statusObserver !== 'undefined') {
            return;
        }
        statusObserver = $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
            if (data.siteid === $mmSite.getId() && data.componentId === scorm.coursemodule &&
                    data.component === mmaModScormComponent) {
                showStatus(data.status);
            }
        });
    }
    function showStatus(status) {
        currentStatus = status;
        if (status == mmCoreOutdated && scorm) {
            $mmaModScorm.shouldDownloadMainFile(scorm, true).then(function(download) {
                $scope.statusMessage = download ? 'mma.mod_scorm.scormstatusoutdated' : '';
            });
        } else if (status == mmCoreNotDownloaded) {
            $scope.statusMessage = 'mma.mod_scorm.scormstatusnotdownloaded';
        } else if (status == mmCoreDownloading) {
            if (!$scope.downloading) {
                downloadScormPackage(true);
            }
        } else {
            $scope.statusMessage = '';
        }
    }
    function refreshData(dontForceSync, checkCompletion, showErrors) {
        var promises = [];
        promises.push($mmaModScorm.invalidateScormData(courseid));
        if (scorm) {
            promises.push($mmaModScorm.invalidateAllScormData(scorm.id));
        }
        return $q.all(promises).finally(function() {
            return fetchScormData(!dontForceSync, checkCompletion, showErrors);
        });
    }
    function downloadScormPackage() {
        $scope.downloading = true;
        return $mmaModScormPrefetchHandler.download(module, courseid).then(undefined, undefined, function(progress) {
            if (!progress) {
                return;
            }
            if (progress.packageDownload) {
                if (scorm.packagesize) {
                    $scope.percentage = (parseFloat(progress.loaded / scorm.packagesize) * 100).toFixed(1);
                }
            } else if (progress.message) {
                $scope.progressMessage = progress.message;
            } else if (progress.loaded && progress.total) {
                $scope.percentage = (parseFloat(progress.loaded / progress.total) * 100).toFixed(1);
            } else {
                $scope.percentage = undefined;
            }
        }).finally(function() {
            $scope.progressMessage = undefined;
            $scope.percentage = undefined;
            $scope.downloading = false;
        });
    }
    function openScorm(scoId) {
        $state.go('site.mod_scorm-player', {
            scorm: scorm,
            mode: $scope.scormOptions.mode,
            newAttempt: !!$scope.scormOptions.newAttempt,
            organizationId: $scope.currentOrganization.identifier,
            scoId: scoId
        });
    }
    function syncScorm(showErrors) {
        return $mmaModScormSync.syncScorm(scorm).then(function(data) {
            if (data) {
                var message = $mmText.buildMessage(data.warnings);
                if (message) {
                    $mmUtil.showErrorModal(message);
                }
            }
        }).catch(function(err) {
            if (showErrors) {
                return showError(err, 'mma.mod_scorm.errorsyncscorm');
            }
            return $q.reject();
        });
    }
    fetchScormData().then(function() {
        $mmaModScorm.logView(scorm.id).then(function() {
            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
        });
    }).finally(function() {
        $scope.scormLoaded = true;
        $scope.refreshIcon = 'ion-refresh';
        $scope.syncIcon = 'ion-loop';
    });
    $scope.loadOrg = function() {
        loadOrganizationToc($scope.currentOrganization.identifier).catch(function(message) {
            return showError(message);
        });
    };
    $scope.refreshScorm = function(showErrors) {
        if ($scope.scormLoaded) {
            $scope.refreshIcon = 'spinner';
            $scope.syncIcon = 'spinner';
            return refreshData(false, $scope.hasOffline, showErrors).finally(function() {
                $scope.refreshIcon = 'ion-refresh';
                $scope.syncIcon = 'ion-loop';
                $scope.$broadcast('scroll.refreshComplete');
            });
        }
    };
    $scope.open = function(e, scoId) {
        e.preventDefault();
        e.stopPropagation();
        if ($scope.downloading) {
            return;
        }
        var isOutdated = currentStatus == mmCoreOutdated;
        if (isOutdated || currentStatus == mmCoreNotDownloaded) {
            $mmaModScormHelper.confirmDownload(scorm, isOutdated).then(function() {
                var promise = isOutdated ? $mmaModScorm.invalidateAllScormData(scorm.id) : $q.when();
                promise.finally(function() {
                    downloadScormPackage().then(function() {
                        if (!$scope.$$destroyed) {
                            openScorm(scoId);
                        }
                    }).catch(function() {
                        if (!$scope.$$destroyed) {
                            $mmaModScormHelper.showDownloadError(scorm);
                        }
                    });
                });
            });
        } else {
            openScorm(scoId);
        }
    };
    $scope.removeFiles = function() {
        $mmCourseHelper.confirmAndRemove(module, courseid);
    };
    $scope.prefetch = function() {
        $mmCourseHelper.contextMenuPrefetch($scope, module, courseid);
    };
    $scope.expandDescription = function() {
        $mmText.expandText($translate.instant('mm.core.description'), $scope.description, false, mmaModScormComponent, module.id);
    };
    var skip = true;
    $scope.$on('$ionicView.enter', function() {
        if (skip) {
            skip = false;
            return;
        }
        $scope.scormOptions.newAttempt = false;
        var forwardView = $ionicHistory.forwardView();
        if (forwardView && forwardView.stateName === 'site.mod_scorm-player') {
            $scope.scormLoaded = false;
            $scope.refreshIcon = 'spinner';
            $scope.syncIcon = 'spinner';
            scrollView.scrollTop();
            $timeout(function() {
                refreshData(false, true).finally(function() {
                    $scope.scormLoaded = true;
                    $scope.refreshIcon = 'ion-refresh';
                    $scope.syncIcon = 'ion-loop';
                });
            }, 500);
        }
    });
    onlineObserver = $mmEvents.on(mmCoreEventOnlineStatusChanged, function(online) {
        $scope.isOnline = online;
    });
    syncObserver = $mmEvents.on(mmaModScormEventAutomSynced, function(data) {
        if (data && data.siteid == $mmSite.getId() && data.scormid == scorm.id) {
            $scope.scormLoaded = false;
            $scope.refreshIcon = 'spinner';
            $scope.syncIcon = 'spinner';
            scrollView.scrollTop();
            fetchScormData(false, true).finally(function() {
                $scope.scormLoaded = true;
                $scope.refreshIcon = 'ion-refresh';
                $scope.syncIcon = 'ion-loop';
            });
        }
    });
    $scope.$on('$destroy', function() {
        statusObserver && statusObserver.off && statusObserver.off();
        syncObserver && syncObserver.off && syncObserver.off();
        onlineObserver && onlineObserver.off && onlineObserver.off();
    });
}]);

angular.module('mm.addons.mod_scorm')
.controller('mmaModScormPlayerCtrl', ["$scope", "$stateParams", "$mmaModScorm", "$mmUtil", "$ionicPopover", "$mmaModScormHelper", "$mmEvents", "$timeout", "$q", "mmaModScormEventUpdateToc", "mmaModScormEventLaunchNextSco", "mmaModScormEventLaunchPrevSco", "$mmaModScormDataModel12", "mmaModScormEventGoOffline", "$mmaModScormSync", "$mmSyncBlock", "mmaModScormComponent", function($scope, $stateParams, $mmaModScorm, $mmUtil, $ionicPopover, $mmaModScormHelper,
            $mmEvents, $timeout, $q, mmaModScormEventUpdateToc, mmaModScormEventLaunchNextSco, mmaModScormEventLaunchPrevSco,
            $mmaModScormDataModel12, mmaModScormEventGoOffline, $mmaModScormSync, $mmSyncBlock, mmaModScormComponent) {
    var scorm = $stateParams.scorm || {},
        mode = $stateParams.mode || $mmaModScorm.MODENORMAL,
        newAttempt = $stateParams.newAttempt,
        organizationId = $stateParams.organizationId,
        currentSco,
        attempt,
        userData,
        apiInitialized = false,
        offline = false;
    $mmSyncBlock.blockOperation(mmaModScormComponent, scorm.id, 'playerCtrl');
    $scope.title = scorm.name;
    $scope.scorm = scorm;
    $scope.loadingToc = true;
    if (scorm.popup) {
        if (scorm.width <= 100) {
            scorm.width = scorm.width + '%';
        }
        if (scorm.height <= 100) {
            scorm.height = scorm.height + '%';
        }
    }
    function fetchData() {
        return $mmaModScormSync.waitForSync(scorm.id).then(function() {
            return $mmaModScorm.getAttemptCount(scorm.id).then(function(attemptsData) {
                return determineAttemptAndMode(attemptsData).then(function() {
                    var promises = [];
                    promises.push(fetchToc());
                    promises.push($mmaModScorm.getScormUserData(scorm.id, attempt, offline).then(function(data) {
                        userData = data;
                    }));
                    return $q.all(promises);
                });
            }).catch(showError);
        });
    }
    function determineAttemptAndMode(attemptsData) {
        return $mmaModScormHelper.determineAttemptToContinue(scorm, attemptsData).then(function(data) {
            attempt = data.number;
            offline = data.offline;
            if (attempt != attemptsData.lastAttempt.number) {
                $scope.attemptToContinue = attempt;
            }
            var promise;
            if (attempt > 0) {
                promise = $mmaModScorm.isAttemptIncomplete(scorm.id, attempt, offline);
            } else {
                promise = $q.when(false);
            }
            return promise.then(function(incomplete) {
                var result = $mmaModScorm.determineAttemptAndMode(scorm, mode, attempt, newAttempt, incomplete);
                if (result.attempt > attempt) {
                    if (offline) {
                        promise = $mmaModScormHelper.createOfflineAttempt(scorm, result.attempt, attemptsData.online.length);
                    } else {
                        promise = $mmaModScorm.getScormUserData(scorm.id, result.attempt, false, undefined, undefined, true)
                                    .catch(function() {
                            offline = true;
                            return $mmaModScormHelper.createOfflineAttempt(scorm, result.attempt, attemptsData.online.length);
                        });
                    }
                } else {
                    promise = $q.when();
                }
                return promise.then(function() {
                    mode = result.mode;
                    newAttempt = result.newAttempt;
                    attempt = result.attempt;
                    $scope.isBrowse = mode === $mmaModScorm.MODEBROWSE;
                    $scope.isReview = mode === $mmaModScorm.MODEREVIEW;
                });
            });
        });
    }
    function showError(message) {
        if (message) {
            $mmUtil.showErrorModal(message);
        } else {
            $mmUtil.showErrorModal('mma.mod_scorm.errorgetscorm', true);
        }
        return $q.reject();
    }
    function fetchToc() {
        $scope.loadingToc = true;
        return $mmaModScorm.isAttemptIncomplete(scorm.id, attempt, offline).then(function(incomplete) {
            scorm.incomplete = incomplete;
            return $mmaModScorm.getOrganizationToc(scorm.id, organizationId, attempt, offline).then(function(toc) {
                $scope.toc = $mmaModScorm.formatTocToArray(toc);
                angular.forEach($scope.toc, function(sco) {
                    sco.image = $mmaModScorm.getScoStatusIcon(sco, scorm.incomplete);
                });
                if ($stateParams.scoId > 0) {
                    currentSco = $mmaModScormHelper.getScoFromToc($scope.toc, $stateParams.scoId);
                }
                if (!currentSco) {
                    return $mmaModScormHelper.getFirstSco(scorm.id, $scope.toc, organizationId, attempt, offline)
                            .then(function(sco) {
                        if (sco) {
                            currentSco = sco;
                        } else {
                            $scope.errorMessage = 'mma.mod_scorm.errornovalidsco';
                        }
                    });
                }
            });
        }).finally(function() {
            $scope.loadingToc = false;
        });
    }
    function calculateNextAndPreviousSco(scoId) {
        $scope.previousSco = $mmaModScormHelper.getPreviousScoFromToc($scope.toc, scoId);
        $scope.nextSco = $mmaModScormHelper.getNextScoFromToc($scope.toc, scoId);
    }
    function loadSco(sco) {
        if (!apiInitialized) {
            $mmaModScormDataModel12.initAPI(scorm, sco.id, attempt, userData, mode, offline);
            apiInitialized = true;
        } else {
            $mmaModScormDataModel12.loadSco(sco.id);
        }
        currentSco = sco;
        $scope.title = sco.title || scorm.name;
        calculateNextAndPreviousSco(sco.id);
        $mmaModScorm.getScoSrc(scorm, sco).then(function(src) {
            if ($scope.src && src.toString() == $scope.src.toString()) {
                $scope.src = '';
                $timeout(function() {
                    $scope.src = src;
                });
            } else {
                $scope.src = src;
            }
        });
        if (sco.scormtype == 'asset') {
            var tracks = [{
                element: 'cmi.core.lesson_status',
                value: 'completed'
            }];
            $mmaModScorm.saveTracks(sco.id, attempt, tracks, offline, scorm).catch(function() {
                if (!offline) {
                    return $mmaModScorm.getScormUserData(scorm.id, attempt, offline).then(function(data) {
                        if (!data[sco.id] || data[sco.id].userdata['cmi.core.lesson_status'] != 'completed') {
                            return $mmaModScormHelper.convertAttemptToOffline(scorm, attempt).then(function() {
                                offline = true;
                                $mmaModScormDataModel12.setOffline(true);
                                return $mmaModScorm.saveTracks(sco.id, attempt, tracks, offline, scorm);
                            }).catch(showError);
                        }
                    });
                }
            }).then(function() {
                refreshToc();
            });
        }
        $mmaModScorm.logLaunchSco(scorm.id, sco.id);
    }
    function refreshToc() {
        $mmaModScorm.invalidateAllScormData(scorm.id).finally(function() {
            fetchToc().catch(showError);
        });
    }
    function setStartTime(scoId) {
        var tracks = [{
            element: 'x.start.time',
            value: $mmUtil.timestamp()
        }];
        return $mmaModScorm.saveTracks(scoId, attempt, tracks, offline, scorm).then(function() {
            if (!offline) {
                $mmaModScorm.getAttemptCount(scorm.id, undefined, undefined, false, true);
            }
        });
    }
    $scope.showToc = $mmaModScorm.displayTocInPlayer(scorm);
    if ($scope.showToc) {
        $ionicPopover.fromTemplateUrl('addons/mod/scorm/templates/toc.html', {
            scope: $scope,
        }).then(function(popover) {
            $scope.popover = popover;
        });
    }
    fetchData().then(function() {
        if (currentSco) {
            var promise = newAttempt ? setStartTime(currentSco.id) : $q.when();
            return promise.catch(showError).finally(function() {
                loadSco(currentSco);
            });
        }
    }).finally(function() {
        $scope.loaded = true;
    });
    $scope.loadSco = function(sco) {
        if (!sco.prereq || !sco.isvisible || !sco.launch) {
            return;
        }
        $scope.popover.hide();
        loadSco(sco);
    };
    var tocObserver = $mmEvents.on(mmaModScormEventUpdateToc, function(data) {
        if (data.scormid === scorm.id) {
            if (offline) {
                $timeout(refreshToc, 100);
            } else {
                refreshToc();
            }
        }
    });
    var launchNextObserver = $mmEvents.on(mmaModScormEventLaunchNextSco, function(data) {
        if (data.scormid === scorm.id && $scope.nextSco) {
            loadSco($scope.nextSco);
        }
    });
    var launchPrevObserver = $mmEvents.on(mmaModScormEventLaunchPrevSco, function(data) {
        if (data.scormid === scorm.id && $scope.previousSco) {
            loadSco($scope.previousSco);
        }
    });
    var goOfflineObserver = $mmEvents.on(mmaModScormEventGoOffline, function(data) {
        if (data.scormid === scorm.id && !offline) {
            offline = true;
            $timeout(function() {
                $mmaModScormHelper.convertAttemptToOffline(scorm, attempt).catch(showError).finally(function() {
                    refreshToc();
                });
            }, 200);
        }
    });
    $scope.$on('$ionicView.beforeLeave', function() {
        $scope.src = '';
    });
    $scope.$on('$destroy', function() {
        tocObserver && tocObserver.off && tocObserver.off();
        launchNextObserver && launchNextObserver.off && launchNextObserver.off();
        launchPrevObserver && launchPrevObserver.off && launchPrevObserver.off();
        goOfflineObserver && goOfflineObserver.off && goOfflineObserver.off();
        $mmSyncBlock.unblockOperation(mmaModScormComponent, scorm.id, 'playerCtrl');
    });
}]);

angular.module('mm.addons.mod_scorm')
.factory('$mmaModScormDataModel12', ["$mmaModScorm", "$mmEvents", "$window", "mmaModScormEventLaunchNextSco", "mmaModScormEventLaunchPrevSco", "mmaModScormEventUpdateToc", "mmaModScormEventGoOffline", function($mmaModScorm, $mmEvents, $window, mmaModScormEventLaunchNextSco,
            mmaModScormEventLaunchPrevSco, mmaModScormEventUpdateToc, mmaModScormEventGoOffline) {
    var self = {};
        function SCORMAPI(scorm, scoId, attempt, userData, mode, offline) {
        var currentUserData = {},
            self = this;
        self.scoId = scoId;
        self.offline = offline;
        function triggerEvent(name) {
            $mmEvents.trigger(name, {
                scormid: scorm.id,
                scoid: self.scoId,
                attempt: attempt
            });
        }
        var CMIString256 = '^[\\u0000-\\uFFFF]{0,255}$';
        var CMIString4096 = '^[\\u0000-\\uFFFF]{0,4096}$';
        var CMITime = '^([0-2]{1}[0-9]{1}):([0-5]{1}[0-9]{1}):([0-5]{1}[0-9]{1})(\.[0-9]{1,2})?$';
        var CMITimespan = '^([0-9]{2,4}):([0-9]{2}):([0-9]{2})(\.[0-9]{1,2})?$';
        var CMIInteger = '^\\d+$';
        var CMISInteger = '^-?([0-9]+)$';
        var CMIDecimal = '^-?([0-9]{0,3})(\.[0-9]*)?$';
        var CMIIdentifier = '^[\\u0021-\\u007E]{0,255}$';
        var CMIFeedback = CMIString256;
        var CMIIndex = '[._](\\d+).';
        var CMIStatus = '^passed$|^completed$|^failed$|^incomplete$|^browsed$';
        var CMIStatus2 = '^passed$|^completed$|^failed$|^incomplete$|^browsed$|^not attempted$';
        var CMIExit = '^time-out$|^suspend$|^logout$|^$';
        var CMIType = '^true-false$|^choice$|^fill-in$|^matching$|^performance$|^sequencing$|^likert$|^numeric$';
        var CMIResult = '^correct$|^wrong$|^unanticipated$|^neutral$|^([0-9]{0,3})?(\.[0-9]*)?$';
        var NAVEvent = '^previous$|^continue$';
        var cmi_children = 'core,suspend_data,launch_data,comments,objectives,student_data,student_preference,interactions';
        var core_children = 'student_id,student_name,lesson_location,credit,lesson_status,entry,score,total_time,lesson_mode,exit,session_time';
        var score_children = 'raw,min,max';
        var comments_children = 'content,location,time';
        var objectives_children = 'id,score,status';
        var correct_responses_children = 'pattern';
        var student_data_children = 'mastery_score,max_time_allowed,time_limit_action';
        var student_preference_children = 'audio,language,speed,text';
        var interactions_children = 'id,objectives,time,type,correct_responses,weighting,student_response,result,latency';
        var score_range = '0#100';
        var audio_range = '-1#100';
        var speed_range = '-100#100';
        var weighting_range = '-100#100';
        var text_range = '-1#1';
        var def = {};
        var defExtra = {};
        angular.forEach(userData, function(sco) {
            def[sco.scoid] = sco.defaultdata;
            defExtra[sco.scoid] = sco.userdata;
        });
        var datamodel = {};
        for (var scoid in def) {
            datamodel[scoid] = {
                'cmi._children':{'defaultvalue':cmi_children, 'mod':'r', 'writeerror':'402'},
                'cmi._version':{'defaultvalue':'3.4', 'mod':'r', 'writeerror':'402'},
                'cmi.core._children':{'defaultvalue':core_children, 'mod':'r', 'writeerror':'402'},
                'cmi.core.student_id':{'defaultvalue':def[scoid]['cmi.core.student_id'], 'mod':'r', 'writeerror':'403'},
                'cmi.core.student_name':{'defaultvalue':def[scoid]['cmi.core.student_name'], 'mod':'r', 'writeerror':'403'},
                'cmi.core.lesson_location':{'defaultvalue':def[scoid]['cmi.core.lesson_location'], 'format':CMIString256, 'mod':'rw', 'writeerror':'405'},
                'cmi.core.credit':{'defaultvalue':def[scoid]['cmi.core.credit'], 'mod':'r', 'writeerror':'403'},
                'cmi.core.lesson_status':{'defaultvalue':def[scoid]['cmi.core.lesson_status'], 'format':CMIStatus, 'mod':'rw', 'writeerror':'405'},
                'cmi.core.entry':{'defaultvalue':def[scoid]['cmi.core.entry'], 'mod':'r', 'writeerror':'403'},
                'cmi.core.score._children':{'defaultvalue':score_children, 'mod':'r', 'writeerror':'402'},
                'cmi.core.score.raw':{'defaultvalue':def[scoid]['cmi.core.score.raw'], 'format':CMIDecimal, 'range':score_range, 'mod':'rw', 'writeerror':'405'},
                'cmi.core.score.max':{'defaultvalue':def[scoid]['cmi.core.score.max'], 'format':CMIDecimal, 'range':score_range, 'mod':'rw', 'writeerror':'405'},
                'cmi.core.score.min':{'defaultvalue':def[scoid]['cmi.core.score.min'], 'format':CMIDecimal, 'range':score_range, 'mod':'rw', 'writeerror':'405'},
                'cmi.core.total_time':{'defaultvalue':def[scoid]['cmi.core.total_time'], 'mod':'r', 'writeerror':'403'},
                'cmi.core.lesson_mode':{'defaultvalue':def[scoid]['cmi.core.lesson_mode'], 'mod':'r', 'writeerror':'403'},
                'cmi.core.exit':{'defaultvalue':def[scoid]['cmi.core.exit'], 'format':CMIExit, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'cmi.core.session_time':{'format':CMITimespan, 'mod':'w', 'defaultvalue':'00:00:00', 'readerror':'404', 'writeerror':'405'},
                'cmi.suspend_data':{'defaultvalue':def[scoid]['cmi.suspend_data'], 'format':CMIString4096, 'mod':'rw', 'writeerror':'405'},
                'cmi.launch_data':{'defaultvalue':def[scoid]['cmi.launch_data'], 'mod':'r', 'writeerror':'403'},
                'cmi.comments':{'defaultvalue':def[scoid]['cmi.comments'], 'format':CMIString4096, 'mod':'rw', 'writeerror':'405'},
                'cmi.evaluation.comments._count':{'defaultvalue':'0', 'mod':'r', 'writeerror':'402'},
                'cmi.evaluation.comments._children':{'defaultvalue':comments_children, 'mod':'r', 'writeerror':'402'},
                'cmi.evaluation.comments.n.content':{'defaultvalue':'', 'pattern':CMIIndex, 'format':CMIString256, 'mod':'rw', 'writeerror':'405'},
                'cmi.evaluation.comments.n.location':{'defaultvalue':'', 'pattern':CMIIndex, 'format':CMIString256, 'mod':'rw', 'writeerror':'405'},
                'cmi.evaluation.comments.n.time':{'defaultvalue':'', 'pattern':CMIIndex, 'format':CMITime, 'mod':'rw', 'writeerror':'405'},
                'cmi.comments_from_lms':{'mod':'r', 'writeerror':'403'},
                'cmi.objectives._children':{'defaultvalue':objectives_children, 'mod':'r', 'writeerror':'402'},
                'cmi.objectives._count':{'mod':'r', 'defaultvalue':'0', 'writeerror':'402'},
                'cmi.objectives.n.id':{'pattern':CMIIndex, 'format':CMIIdentifier, 'mod':'rw', 'writeerror':'405'},
                'cmi.objectives.n.score._children':{'pattern':CMIIndex, 'mod':'r', 'writeerror':'402'},
                'cmi.objectives.n.score.raw':{'defaultvalue':'', 'pattern':CMIIndex, 'format':CMIDecimal, 'range':score_range, 'mod':'rw', 'writeerror':'405'},
                'cmi.objectives.n.score.min':{'defaultvalue':'', 'pattern':CMIIndex, 'format':CMIDecimal, 'range':score_range, 'mod':'rw', 'writeerror':'405'},
                'cmi.objectives.n.score.max':{'defaultvalue':'', 'pattern':CMIIndex, 'format':CMIDecimal, 'range':score_range, 'mod':'rw', 'writeerror':'405'},
                'cmi.objectives.n.status':{'pattern':CMIIndex, 'format':CMIStatus2, 'mod':'rw', 'writeerror':'405'},
                'cmi.student_data._children':{'defaultvalue':student_data_children, 'mod':'r', 'writeerror':'402'},
                'cmi.student_data.mastery_score':{'defaultvalue':def[scoid]['cmi.student_data.mastery_score'], 'mod':'r', 'writeerror':'403'},
                'cmi.student_data.max_time_allowed':{'defaultvalue':def[scoid]['cmi.student_data.max_time_allowed'], 'mod':'r', 'writeerror':'403'},
                'cmi.student_data.time_limit_action':{'defaultvalue':def[scoid]['cmi.student_data.time_limit_action'], 'mod':'r', 'writeerror':'403'},
                'cmi.student_preference._children':{'defaultvalue':student_preference_children, 'mod':'r', 'writeerror':'402'},
                'cmi.student_preference.audio':{'defaultvalue':def[scoid]['cmi.student_preference.audio'], 'format':CMISInteger, 'range':audio_range, 'mod':'rw', 'writeerror':'405'},
                'cmi.student_preference.language':{'defaultvalue':def[scoid]['cmi.student_preference.language'], 'format':CMIString256, 'mod':'rw', 'writeerror':'405'},
                'cmi.student_preference.speed':{'defaultvalue':def[scoid]['cmi.student_preference.speed'], 'format':CMISInteger, 'range':speed_range, 'mod':'rw', 'writeerror':'405'},
                'cmi.student_preference.text':{'defaultvalue':def[scoid]['cmi.student_preference.text'], 'format':CMISInteger, 'range':text_range, 'mod':'rw', 'writeerror':'405'},
                'cmi.interactions._children':{'defaultvalue':interactions_children, 'mod':'r', 'writeerror':'402'},
                'cmi.interactions._count':{'mod':'r', 'defaultvalue':'0', 'writeerror':'402'},
                'cmi.interactions.n.id':{'pattern':CMIIndex, 'format':CMIIdentifier, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'cmi.interactions.n.objectives._count':{'pattern':CMIIndex, 'mod':'r', 'defaultvalue':'0', 'writeerror':'402'},
                'cmi.interactions.n.objectives.n.id':{'pattern':CMIIndex, 'format':CMIIdentifier, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'cmi.interactions.n.time':{'pattern':CMIIndex, 'format':CMITime, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'cmi.interactions.n.type':{'pattern':CMIIndex, 'format':CMIType, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'cmi.interactions.n.correct_responses._count':{'pattern':CMIIndex, 'mod':'r', 'defaultvalue':'0', 'writeerror':'402'},
                'cmi.interactions.n.correct_responses.n.pattern':{'pattern':CMIIndex, 'format':CMIFeedback, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'cmi.interactions.n.weighting':{'pattern':CMIIndex, 'format':CMIDecimal, 'range':weighting_range, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'cmi.interactions.n.student_response':{'pattern':CMIIndex, 'format':CMIFeedback, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'cmi.interactions.n.result':{'pattern':CMIIndex, 'format':CMIResult, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'cmi.interactions.n.latency':{'pattern':CMIIndex, 'format':CMITimespan, 'mod':'w', 'readerror':'404', 'writeerror':'405'},
                'nav.event':{'defaultvalue':'', 'format':NAVEvent, 'mod':'w', 'readerror':'404', 'writeerror':'405'}
            };
            currentUserData[scoid] = {};
            for (var element in datamodel[scoid]) {
                if (element.match(/\.n\./) === null) {
                    if (typeof datamodel[scoid][element].defaultvalue != 'undefined') {
                        currentUserData[scoid][element] = datamodel[scoid][element].defaultvalue;
                    }
                }
            }
            for (element in def[scoid]) {
                if (element.match(/\.n\./) === null) {
                    if (typeof datamodel[scoid][element].defaultvalue != 'undefined') {
                        currentUserData[scoid][element] = datamodel[scoid][element].defaultvalue;
                    } else if (typeof defExtra[scoid][element] != 'undefined') {
                        currentUserData[scoid][element] = defExtra[scoid][element];
                    } else {
                        currentUserData[scoid][element] = '';
                    }
                }
            }
            var expression = new RegExp(CMIIndex,'g');
            var elementDotFormat, counterElement, currentCounterIndex, currentN;
            for (element in defExtra[scoid]) {
                counterElement = '';
                currentCounterIndex = 0;
                if (element.match(expression)) {
                    elementDotFormat = element.replace(expression, ".$1.");
                    currentUserData[scoid][elementDotFormat] = defExtra[scoid][element];
                    if (elementDotFormat.indexOf("cmi.evaluation.comments") === 0) {
                        counterElement = "cmi.evaluation.comments._count";
                        currentCounterIndex = elementDotFormat.match(/.(\d+)./)[1];
                    } else if (elementDotFormat.indexOf("cmi.objectives") === 0) {
                        counterElement = "cmi.objectives._count";
                        currentCounterIndex = elementDotFormat.match(/.(\d+)./)[1];
                    } else if (elementDotFormat.indexOf("cmi.interactions") === 0) {
                        if (elementDotFormat.indexOf(".objectives.") > 0) {
                            currentN = elementDotFormat.match(/cmi.interactions.(\d+)./)[1];
                            currentCounterIndex = elementDotFormat.match(/objectives.(\d+)./)[1];
                            counterElement = "cmi.interactions." + currentN + ".objectives._count";
                        } else if (elementDotFormat.indexOf(".correct_responses.") > 0) {
                            currentN = elementDotFormat.match(/cmi.interactions.(\d+)./)[1];
                            currentCounterIndex = elementDotFormat.match(/correct_responses.(\d+)./)[1];
                            counterElement = "cmi.interactions." + currentN + ".correct_responses._count";
                        } else {
                            counterElement = "cmi.interactions._count";
                            currentCounterIndex = elementDotFormat.match(/.(\d+)./)[1];
                        }
                    }
                    if (counterElement) {
                        if (typeof currentUserData[scoid][counterElement] == "undefined") {
                            currentUserData[scoid][counterElement] = 0;
                        }
                        if (parseInt(currentCounterIndex) == parseInt(currentUserData[scoid][counterElement])) {
                            currentUserData[scoid][counterElement] = parseInt(currentUserData[scoid][counterElement]) + 1;
                        }
                        if (parseInt(currentCounterIndex) > parseInt(currentUserData[scoid][counterElement])) {
                            currentUserData[scoid][counterElement] = parseInt(currentCounterIndex) - 1;
                        }
                    }
                }
            }
            if (currentUserData[scoid]['cmi.core.lesson_status'] === '') {
                currentUserData[scoid]['cmi.core.lesson_status'] = 'not attempted';
            }
            currentUserData[scoid]['cmi.core.credit'] = mode == $mmaModScorm.MODENORMAL ? 'credit' : 'no-credit';
            currentUserData[scoid]['cmi.core.lesson_mode'] = mode;
        }
                function getEl(el) {
            if (typeof currentUserData[self.scoId] != 'undefined' && typeof currentUserData[self.scoId][el] != 'undefined') {
                return currentUserData[self.scoId][el];
            }
            return '';
        }
                function setEl(el, value) {
            if (typeof currentUserData[self.scoId] == 'undefined') {
                currentUserData[self.scoId] = {};
            }
            currentUserData[self.scoId][el] = value;
        }
                function CloneObj(obj){
            if(obj == null || typeof(obj) != 'object') {
                return obj;
            }
            var temp = new obj.constructor();
            for(var key in obj) {
                temp[key] = CloneObj(obj[key]);
            }
            return temp;
        }
                function AddTime (first, second) {
            var sFirst = first.split(":");
            var sSecond = second.split(":");
            var cFirst = sFirst[2].split(".");
            var cSecond = sSecond[2].split(".");
            var change = 0;
            FirstCents = 0; 
            if (cFirst.length > 1) {
                FirstCents = parseInt(cFirst[1],10);
            }
            SecondCents = 0;
            if (cSecond.length > 1) {
                SecondCents = parseInt(cSecond[1],10);
            }
            var cents = FirstCents + SecondCents;
            change = Math.floor(cents / 100);
            cents = cents - (change * 100);
            if (Math.floor(cents) < 10) {
                cents = "0" + cents.toString();
            }
            var secs = parseInt(cFirst[0],10) + parseInt(cSecond[0],10) + change; 
            change = Math.floor(secs / 60);
            secs = secs - (change * 60);
            if (Math.floor(secs) < 10) {
                secs = "0" + secs.toString();
            }
            mins = parseInt(sFirst[1],10) + parseInt(sSecond[1],10) + change;  
            change = Math.floor(mins / 60);
            mins = mins - (change * 60);
            if (mins < 10) {
                mins = "0" + mins.toString();
            }
            hours = parseInt(sFirst[0],10) + parseInt(sSecond[0],10) + change; 
            if (hours < 10) {
                hours = "0" + hours.toString();
            }
            if (cents != '0') {
                return hours + ":" + mins + ":" + secs + '.' + cents;
            } else {
                return hours + ":" + mins + ":" + secs;
            }
        }
                function TotalTime() {
            total_time = AddTime(getEl('cmi.core.total_time'), getEl('cmi.core.session_time'));
            return {'element': 'cmi.core.total_time', value: total_time};
        }
                function StoreData(storetotaltime) {
            if (storetotaltime) {
                if (getEl('cmi.core.lesson_status') == 'not attempted') {
                    setEl('cmi.core.lesson_status', 'completed');
                }
                if (getEl('cmi.core.lesson_mode') == $mmaModScorm.MODENORMAL) {
                    if (getEl('cmi.core.credit') == 'credit') {
                        if (getEl('cmi.student_data.mastery_score') !== '' && getEl('cmi.core.score.raw') !== '') {
                            if (parseFloat(getEl('cmi.core.score.raw')) >= parseFloat(getEl('cmi.student_data.mastery_score'))) {
                                setEl('cmi.core.lesson_status', 'passed');
                            } else {
                                setEl('cmi.core.lesson_status', 'failed');
                            }
                        }
                    }
                }
                if (getEl('cmi.core.lesson_mode') == $mmaModScorm.MODEBROWSE) {
                    if (datamodel[self.scoId]['cmi.core.lesson_status'].defaultvalue == '' && getEl('cmi.core.lesson_status') == 'not attempted') {
                        setEl('cmi.core.lesson_status', 'browsed');
                    }
                }
                tracks = CollectData();
                tracks.push(TotalTime());
            } else {
                tracks = CollectData();
            }
            var success = $mmaModScorm.saveTracksSync(self.scoId, attempt, tracks, self.offline, scorm, currentUserData);
            if (!self.offline && !success) {
                self.offline = true;
                triggerEvent(mmaModScormEventGoOffline);
                return $mmaModScorm.saveTracksSync(self.scoId, attempt, tracks, self.offline, scorm, currentUserData);
            }
            return success;
        }
                function CollectData() {
            var data = [];
            for (var element in currentUserData[self.scoId]) {
                if (element.substr(0, 3) == 'cmi') {
                    expression = new RegExp(CMIIndex,'g');
                    elementmodel = String(element).replace(expression,'.n.');
                    if (element != "cmi.core.session_time") {
                        if (typeof datamodel[self.scoId][element] == "undefined" &&
                                typeof datamodel[self.scoId][elementmodel] != "undefined") {
                            datamodel[self.scoId][element] = CloneObj(datamodel[self.scoId][elementmodel]);
                        }
                        if (typeof datamodel[self.scoId][element] != "undefined") {
                            if (datamodel[self.scoId][element].mod != 'r') {
                                var el = {
                                    'element': element.replace(expression, "_$1."),
                                    'value': getEl(element)
                                };
                                if (typeof datamodel[self.scoId][element].defaultvalue != "undefined") {
                                    if (datamodel[self.scoId][element].defaultvalue != el['value'] ||
                                            typeof datamodel[self.scoId][element].defaultvalue != typeof(el['value'])) {
                                        data.push(el);
                                        datamodel[self.scoId][element].defaultvalue = el['value'];
                                    }
                                } else {
                                    data.push(el);
                                    datamodel[self.scoId][element].defaultvalue = el['value'];
                                }
                            }
                        }
                    }
                }
            }
            return data;
        }
        var initialized = false;
        var errorCode;
        var timeout;
        self.LMSInitialize = function(param) {
            errorCode = "0";
            if (param == "") {
                if (!initialized) {
                    initialized = true;
                    errorCode = "0";
                    return "true";
                } else {
                    errorCode = "101";
                }
            } else {
                errorCode = "201";
            }
            return "false";
        };
        self.LMSFinish = function(param) {
            errorCode = "0";
            if (param == "") {
                if (initialized) {
                    initialized = false;
                    result = StoreData(true);
                    if (getEl('nav.event') != '') {
                        if (getEl('nav.event') == 'continue') {
                            triggerEvent(mmaModScormEventLaunchNextSco);
                        } else {
                            triggerEvent(mmaModScormEventLaunchPrevSco);
                        }
                    } else {
                        if (scorm.auto == '1') {
                            triggerEvent(mmaModScormEventLaunchNextSco);
                        }
                    }
                    errorCode = (result) ? '0' : '101';
                    triggerEvent(mmaModScormEventUpdateToc);
                    result = result ? "true" : "false";
                    return result;
                } else {
                    errorCode = "301";
                }
            } else {
                errorCode = "201";
            }
            return "false";
        };
        self.LMSGetValue = function(element) {
            errorCode = "0";
            if (initialized) {
                if (element != "") {
                    expression = new RegExp(CMIIndex,'g');
                    elementmodel = String(element).replace(expression,'.n.');
                    if (typeof datamodel[self.scoId][elementmodel] != "undefined") {
                        if (datamodel[self.scoId][elementmodel].mod != 'w') {
                            errorCode = "0";
                            return getEl(element);
                        } else {
                            errorCode = datamodel[self.scoId][elementmodel].readerror;
                        }
                    } else {
                        childrenstr = '._children';
                        countstr = '._count';
                        if (elementmodel.substr(elementmodel.length - childrenstr.length,elementmodel.length) == childrenstr) {
                            parentmodel = elementmodel.substr(0,elementmodel.length - childrenstr.length);
                            if (typeof datamodel[self.scoId][parentmodel] != "undefined") {
                                errorCode = "202";
                            } else {
                                errorCode = "201";
                            }
                        } else if (elementmodel.substr(elementmodel.length - countstr.length,elementmodel.length) == countstr) {
                            parentmodel = elementmodel.substr(0,elementmodel.length - countstr.length);
                            if (typeof datamodel[self.scoId][parentmodel] != "undefined") {
                                errorCode = "203";
                            } else {
                                errorCode = "201";
                            }
                        } else {
                            errorCode = "201";
                        }
                    }
                } else {
                    errorCode = "201";
                }
            } else {
                errorCode = "301";
            }
            return "";
        };
        self.LMSSetValue = function(element, value) {
            errorCode = "0";
            if (initialized) {
                if (element != "") {
                    expression = new RegExp(CMIIndex,'g');
                    elementmodel = String(element).replace(expression,'.n.');
                    if (typeof datamodel[self.scoId][elementmodel] != "undefined") {
                        if (datamodel[self.scoId][elementmodel].mod != 'r') {
                            expression = new RegExp(datamodel[self.scoId][elementmodel].format);
                            value = value + '';
                            matches = value.match(expression);
                            if (matches != null) {
                                if (element != elementmodel) {
                                    if (element.indexOf("cmi.objectives") === 0) {
                                        currentN = element.match(/cmi.objectives.(\d+)./)[1];
                                        counterElement = "cmi.objectives." + currentN + ".score";
                                        if (typeof currentUserData[self.scoId][counterElement + '._children'] == "undefined") {
                                            setEl(currentUserData[self.scoId][counterElement + '._children'], score_children);
                                            setEl(currentUserData[self.scoId][counterElement + '.raw'], '');
                                            setEl(currentUserData[self.scoId][counterElement + '.min'], '');
                                            setEl(currentUserData[self.scoId][counterElement + '.max'], '');
                                        }
                                    } else if (element.indexOf("cmi.interactions") === 0) {
                                        currentN = element.match(/cmi.interactions.(\d+)./)[1];
                                        counterElement = "cmi.interactions." + currentN + ".objectives._count";
                                        if (typeof currentUserData[self.scoId][counterElement] == "undefined") {
                                            setEl(counterElement, 0);
                                        }
                                        counterElement = "cmi.interactions." + currentN + ".correct_responses._count";
                                        if (typeof currentUserData[self.scoId][counterElement] == "undefined") {
                                            setEl(counterElement, 0);
                                        }
                                    }
                                    elementIndexes = element.split('.');
                                    subelement = 'cmi';
                                    for (i = 1; i < elementIndexes.length - 1; i++) {
                                        elementIndex = elementIndexes[i];
                                        if (elementIndexes[i + 1].match(/^\d+$/)) {
                                            if (typeof currentUserData[self.scoId][subelement + '.' + elementIndex + '._count'] == "undefined") {
                                                setEl(subelement + '.' + elementIndex + '._count', 0);
                                            }
                                            if (elementIndexes[i + 1] == getEl(subelement + '.' + elementIndex + '._count')) {
                                                var count = getEl(subelement + '.' + elementIndex + '._count');
                                                setEl(subelement + '.' + elementIndex + '._count', parseInt(count) + 1);
                                            }
                                            if (elementIndexes[i + 1] > getEl(subelement + '.' + elementIndex + '._count')) {
                                                errorCode = "201";
                                            }
                                            subelement = subelement.concat('.' + elementIndex + '.' + elementIndexes[i + 1]);
                                            i++;
                                        } else {
                                            subelement = subelement.concat('.' + elementIndex);
                                        }
                                    }
                                    element = subelement.concat('.' + elementIndexes[elementIndexes.length - 1]);
                                }
                                if (errorCode == "0") {
                                    if (scorm.autocommit && !(timeout)) {
                                        timeout = setTimeout(self.LMSCommit, 60000, [""]);
                                    }
                                    if (typeof datamodel[self.scoId][elementmodel].range != "undefined") {
                                        range = datamodel[self.scoId][elementmodel].range;
                                        ranges = range.split('#');
                                        value = value * 1.0;
                                        if ((value >= ranges[0]) && (value <= ranges[1])) {
                                            setEl(element, value);
                                            errorCode = "0";
                                            return "true";
                                        } else {
                                            errorCode = datamodel[self.scoId][elementmodel].writeerror;
                                        }
                                    } else {
                                        if (element == 'cmi.comments') {
                                            setEl('cmi.comments', getEl('cmi.comments') + value);
                                        } else {
                                            setEl(element, value);
                                        }
                                        errorCode = "0";
                                        return "true";
                                    }
                                }
                            } else {
                                errorCode = datamodel[self.scoId][elementmodel].writeerror;
                            }
                        } else {
                            errorCode = datamodel[self.scoId][elementmodel].writeerror;
                        }
                    } else {
                        errorCode = "201";
                    }
                } else {
                    errorCode = "201";
                }
            } else {
                errorCode = "301";
            }
            return "false";
        };
        self.LMSCommit = function(param) {
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            errorCode = "0";
            if (param == "") {
                if (initialized) {
                    result = StoreData(false);
                    triggerEvent(mmaModScormEventUpdateToc);
                    errorCode = result ? '0' : '101';
                    result = result ? "true" : "false";
                    return result;
                } else {
                    errorCode = "301";
                }
            } else {
                errorCode = "201";
            }
            return "false";
        };
        self.LMSGetLastError = function() {
            return errorCode;
        };
        var errorString = [];
        errorString["0"] = "No error";
        errorString["101"] = "General exception";
        errorString["201"] = "Invalid argument error";
        errorString["202"] = "Element cannot have children";
        errorString["203"] = "Element not an array - cannot have count";
        errorString["301"] = "Not initialized";
        errorString["401"] = "Not implemented error";
        errorString["402"] = "Invalid set value, element is a keyword";
        errorString["403"] = "Element is read only";
        errorString["404"] = "Element is write only";
        errorString["405"] = "Incorrect data type";
        self.LMSGetErrorString = function(param) {
            if (param != "") {
                return errorString[param];
            } else {
               return "";
            }
        };
        self.LMSGetDiagnostic = function(param) {
            if (param == "") {
                param = errorCode;
            }
            return param;
        };
    }
        self.initAPI = function(scorm, scoId, attempt, userData, mode, offline) {
        mode = mode || $mmaModScorm.MODENORMAL;
        $window.API = new SCORMAPI(scorm, scoId, attempt, userData, mode, offline);
    };
        self.loadSco = function(scoId) {
        $window.API.scoId = scoId;
    };
        self.setOffline = function(offline) {
        $window.API.offline = offline;
    };
    return self;
}]);

angular.module('mm.addons.mod_scorm')
.factory('$mmaModScormHandlers', ["$mmCourse", "$mmaModScorm", "$mmEvents", "$state", "$mmSite", "$mmaModScormHelper", "$mmCoursePrefetchDelegate", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", "mmCoreEventPackageStatusChanged", "mmaModScormComponent", "$q", "$mmContentLinksHelper", "$mmUtil", "$mmaModScormSync", "$mmaModScormPrefetchHandler", function($mmCourse, $mmaModScorm, $mmEvents, $state, $mmSite, $mmaModScormHelper,
        $mmCoursePrefetchDelegate, mmCoreDownloading, mmCoreNotDownloaded, mmCoreOutdated, mmCoreEventPackageStatusChanged,
        mmaModScormComponent, $q, $mmContentLinksHelper, $mmUtil, $mmaModScormSync, $mmaModScormPrefetchHandler) {
    var self = {};
        self.courseContent = function() {
        var self = {};
                self.isEnabled = function() {
            return $mmaModScorm.isPluginEnabled();
        };
                self.getController = function(module, courseid) {
            return function($scope) {
                var downloadBtn,
                    refreshBtn;
                downloadBtn = {
                    hidden: true,
                    icon: 'ion-ios-cloud-download-outline',
                    label: 'mm.core.download'
                };
                refreshBtn = {
                    icon: 'ion-android-refresh',
                    label: 'mm.core.refresh',
                    hidden: true
                };
                $scope.icon = $mmCourse.getModuleIconSrc('scorm');
                $scope.title = module.name;
                $scope.class = 'mma-mod_scorm-handler';
                $scope.buttons = [downloadBtn, refreshBtn];
                $scope.spinner = true;
                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_scorm', {module: module, courseid: courseid});
                };
                $mmaModScorm.getScorm(courseid, module.id, module.url).then(function(scorm) {
                    var revision = scorm.sha1hash,
                        timemodified = 0;
                    function download(isOutdated) {
                        $scope.spinner = true;
                        $mmaModScorm.getScorm(courseid, module.id, module.url).then(function(scorm) {
                            $mmaModScormHelper.confirmDownload(scorm, isOutdated).then(function() {
                                $mmaModScormPrefetchHandler.prefetch(module, courseid).catch(function() {
                                    if (!$scope.$$destroyed) {
                                        $mmaModScormHelper.showDownloadError(scorm);
                                    }
                                });
                            }).catch(function() {
                                $scope.spinner = false;
                            });
                        }).catch(function(error) {
                            $scope.spinner = false;
                            if (error) {
                                $mmUtil.showErrorModal(error);
                            } else {
                                $mmaModScormHelper.showDownloadError(scorm);
                            }
                        });
                    }
                    downloadBtn.action = function(e) {
                        if (e) {
                            e.preventDefault();
                            e.stopPropagation();
                        }
                        download();
                    };
                    refreshBtn.action = function(e) {
                        if (e) {
                            e.preventDefault();
                            e.stopPropagation();
                        }
                        $mmaModScorm.invalidateAllScormData(scorm.id).finally(function() {
                            download(true);
                        });
                    };
                    function showStatus(status) {
                        if (status) {
                            $scope.spinner = status === mmCoreDownloading;
                            downloadBtn.hidden = status !== mmCoreNotDownloaded;
                            refreshBtn.hidden = status !== mmCoreOutdated;
                        }
                    }
                    var statusObserver = $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
                        if (data.siteid === $mmSite.getId() && data.componentId === scorm.coursemodule &&
                                data.component === mmaModScormComponent) {
                            showStatus(data.status);
                        }
                    });
                    $mmCoursePrefetchDelegate.getModuleStatus(module, courseid, revision, timemodified).then(showStatus);
                    $scope.$on('$destroy', function() {
                        statusObserver && statusObserver.off && statusObserver.off();
                    });
                });
            };
        };
        return self;
    };
        self.indexLinksHandler = $mmContentLinksHelper.createModuleIndexLinkHandler('mmaModScorm', 'scorm', $mmaModScorm);
        self.gradeLinksHandler = $mmContentLinksHelper.createModuleGradeLinkHandler('mmaModScorm', 'scorm', $mmaModScorm);
        self.syncHandler = function() {
        var self = {};
                self.execute = function(siteId) {
            return $mmaModScormSync.syncAllScorms(siteId);
        };
                self.getInterval = function() {
            return 600000;
        };
                self.isSync = function() {
            return true;
        };
                self.usesNetwork = function() {
            return true;
        };
        return self;
    };
    return self;
}]);

angular.module('mm.addons.mod_scorm')
.factory('$mmaModScormHelper', ["$mmaModScorm", "$mmUtil", "$translate", "$q", "$mmaModScormOffline", "$mmaModScormSync", "$mmSite", function($mmaModScorm, $mmUtil, $translate, $q, $mmaModScormOffline, $mmaModScormSync, $mmSite) {
    var self = {},
        elementsToIgnore = ['status', 'score_raw', 'total_time', 'session_time', 'student_id', 'student_name', 'credit',
                            'mode', 'entry'];
        self.convertAttemptToOffline = function(scorm, attempt, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmaModScorm.getScormUserData(scorm.id, attempt, false, siteId).then(function(onlineData) {
            return $mmaModScormOffline.getScormUserData(siteId, scorm.id, attempt).catch(function() {
            }).then(function(offlineData) {
                var dataToStore = angular.copy(onlineData);
                angular.forEach(dataToStore, function(sco) {
                    elementsToIgnore.forEach(function(el) {
                        delete sco.userdata[el];
                    });
                    if (offlineData && offlineData[sco.scoid] && offlineData[sco.scoid].userdata) {
                        var scoUserData = {};
                        angular.forEach(sco.userdata, function(value, element) {
                            if (!offlineData[sco.scoid].userdata[element]) {
                                scoUserData[element] = value;
                            }
                        });
                        sco.userdata = scoUserData;
                    }
                });
                return $mmaModScormOffline.createNewAttempt(siteId, scorm, undefined, attempt, dataToStore, onlineData);
            });
        }).catch(function() {
            return $q.reject($translate.instant('mma.mod_scorm.errorcreateofflineattempt'));
        });
    };
        self.createOfflineAttempt = function(scorm, newAttempt, lastOnline, siteId) {
        siteId = siteId || $mmSite.getId();
        return self.searchOnlineAttemptUserData(scorm.id, lastOnline, siteId).then(function(userData) {
            angular.forEach(userData, function(sco) {
                var filtered = {};
                angular.forEach(sco.userdata, function(value, element) {
                    if (element.indexOf('.') == -1 && elementsToIgnore.indexOf(element) == -1) {
                        filtered[element] = value;
                    }
                });
                sco.userdata = filtered;
            });
            return $mmaModScormOffline.createNewAttempt(siteId, scorm, undefined, newAttempt, userData);
        }).catch(function() {
            return $q.reject($translate.instant('mma.mod_scorm.errorcreateofflineattempt'));
        });
    };
        self.confirmDownload = function(scorm, isOutdated) {
        return $mmaModScorm.shouldDownloadMainFile(scorm, isOutdated, $mmSite.getId()).then(function(download) {
            if (download) {
                var subPromise;
                if (!scorm.packagesize) {
                    subPromise = $mmaModScorm.calculateScormSize(scorm).then(function(size) {
                        scorm.packagesize = size;
                        return size;
                    });
                } else {
                    subPromise = $q.when(scorm.packagesize);
                }
                return subPromise.then(function(size) {
                    return $mmUtil.confirmDownloadSize({size: size, total: true});
                });
            }
        });
    };
        self.determineAttemptToContinue = function(scorm, attempts, siteId) {
        siteId = siteId || $mmSite.getId();
        var lastOnline,
            result = {
                number: 0,
                offline: false
            };
        function getLastBeforeMax() {
            if (scorm.maxattempt != 0 && attempts.lastAttempt.number > scorm.maxattempt) {
                result.number = scorm.maxattempt;
                result.offline = attempts.offline.indexOf(scorm.maxattempt) > -1;
            } else {
                result.number = attempts.lastAttempt.number;
                result.offline = attempts.lastAttempt.offline;
            }
        }
        if (attempts.online.length) {
            lastOnline = Math.max.apply(Math, attempts.online);
        }
        if (lastOnline) {
            var hasOffline = attempts.offline.indexOf(lastOnline) > -1;
            return $mmaModScorm.isAttemptIncomplete(scorm.id, lastOnline, hasOffline, false, siteId).then(function(incomplete) {
                if (incomplete) {
                    result.number = lastOnline;
                    result.offline = hasOffline;
                } else {
                    getLastBeforeMax();
                }
                return result;
            });
        } else {
            getLastBeforeMax();
            return $q.when(result);
        }
    };
        self.getFirstSco = function(scormId, toc, organization, attempt, offline, siteId) {
        siteId = siteId || $mmSite.getId();
        var promise;
        if (toc && toc.length) {
            promise = $q.when(toc);
        } else {
            promise = $mmaModScorm.getScosWithData(scormId, organization, attempt, offline, false, siteId);
        }
        return promise.then(function(scos) {
            for (var i = 0; i < scos.length; i++) {
                var sco = scos[i];
                if (sco.isvisible && sco.prereq && sco.launch) {
                    return sco;
                }
            }
        });
    };
        self.getNextScoFromToc = function(toc, scoId) {
        for (var i = 0, len = toc.length; i < len; i++) {
            if (toc[i].id == scoId) {
                for (var j = i + 1; j < len; j++) {
                    if (toc[j].isvisible && toc[j].prereq && toc[j].launch) {
                        return toc[j];
                    }
                }
                break;
            }
        }
    };
        self.getPreviousScoFromToc = function(toc, scoId) {
        for (var i = 0, len = toc.length; i < len; i++) {
            if (toc[i].id == scoId) {
                for (var j = i - 1; j >= 0; j--) {
                    if (toc[j].isvisible && toc[j].prereq && toc[j].launch) {
                        return toc[j];
                    }
                }
                break;
            }
        }
    };
        self.getScoFromToc = function(toc, scoId) {
        for (var i = 0, len = toc.length; i < len; i++) {
            if (toc[i].id == scoId) {
                return toc[i];
            }
        }
    };
        self.getScormReadableSyncTime = function(scormId, siteId) {
        return $mmaModScormSync.getSyncTime(scormId, siteId).then(function(time) {
            if (time == 0) {
                return $translate('mm.core.none');
            } else {
                return moment(time).format('LLL');
            }
        });
    };
        self.searchOnlineAttemptUserData = function(scormId, attempt, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmaModScorm.getScormUserData(scormId, attempt, false, siteId).catch(function() {
            if (attempt > 0) {
                return self.searchOnlineAttemptUserData(scormId, attempt - 1, siteId);
            } else {
                return $q.reject();
            }
        });
    };
        self.showDownloadError = function(scorm) {
        $translate('mma.mod_scorm.errordownloadscorm', {name: scorm.name}).then(function(message) {
            $mmUtil.showErrorModal(message);
        });
    };
    return self;
}]);

angular.module('mm.addons.mod_scorm')
.factory('$mmaModScormPrefetchHandler', ["$mmaModScorm", "$mmFS", "$mmFilepool", "$q", "$mmSite", "$mmPrefetchFactory", "$mmLang", "$mmaModScormOnline", "mmaModScormComponent", function($mmaModScorm, $mmFS, $mmFilepool, $q, $mmSite, $mmPrefetchFactory, $mmLang,
    $mmaModScormOnline, mmaModScormComponent) {
    var self = $mmPrefetchFactory.createPrefetchHandler(mmaModScormComponent, false);
    self.updatesNames = /^configuration$|^.*files$|^tracks$/;
        self.download = function(module, courseId) {
        return self.prefetchPackage(module, courseId, true, downloadOrPrefetchScorm, $mmSite.getId(), false);
    };
        function downloadOrPrefetchScorm(module, courseId, single, siteId, prefetch) {
        var scorm,
            deferred = $q.defer();
        $mmaModScorm.getScorm(courseId, module.id, module.url, siteId).then(function(scormData) {
            scorm = scormData;
            var promises = [],
                introFiles = self.getIntroFilesFromInstance(module, scorm);
            promises.push(self.downloadWSData(scorm, siteId).catch(function() {
            }));
            promises.push(self._downloadOrPrefetchPackage(scorm, prefetch, siteId).then(undefined, undefined, deferred.notify));
            angular.forEach(introFiles, function(file) {
                var promise;
                if (prefetch) {
                    promise = $mmFilepool.addToQueueByUrl(siteId, file.fileurl, self.component, module.id, file.timemodified);
                } else {
                    promise = $mmFilepool.downloadUrl(siteId, file.fileurl, false, self.component, module.id, file.timemodified);
                }
                promises.push(promise.catch(function() {
                }));
            });
            return $q.all(promises);
        }).then(function() {
            deferred.resolve({
                revision: scorm.sha1hash,
                timemod: 0
            });
        }).catch(deferred.reject);
        return deferred.promise;
    }
        self._downloadOrPrefetchPackage = function(scorm, prefetch, siteId) {
        siteId = siteId || $mmSite.getId();
        var result = $mmaModScorm.isScormSupported(scorm);
        if (result !== true) {
            return $mmLang.translateAndReject(result);
        }
        return $mmaModScorm.shouldDownloadMainFile(scorm, undefined, siteId).then(function(download) {
            if (download) {
                return downloadMainFile(scorm, prefetch, siteId);
            }
        });
    };
        function downloadMainFile(scorm, prefetch, siteId) {
        var dirPath,
            deferred = $q.defer(),
            packageUrl = $mmaModScorm.getPackageUrl(scorm);
        $mmaModScorm.getScormFolder(scorm.moduleurl).then(function(path) {
            dirPath = path;
            deferred.notify({message: 'mm.core.downloading'});
            var promise;
            if (prefetch) {
                promise = $mmFilepool.addToQueueByUrl(siteId, packageUrl, self.component, scorm.coursemodule);
            } else {
                promise = $mmFilepool.downloadUrl(siteId, packageUrl, true, self.component, scorm.coursemodule);
            }
            return promise.then(undefined, undefined, function(progress) {
                if (progress && progress.loaded) {
                    deferred.notify({
                        packageDownload: true,
                        loaded: progress.loaded,
                        fileProgress: progress
                    });
                }
            });
        }).then(function() {
            return $mmFS.removeDir(dirPath).catch(function() {
            });
        }).then(function() {
            return $mmFilepool.getFilePathByUrl(siteId, packageUrl);
        }).then(function(zippath) {
            deferred.notify({message: 'mm.core.unzipping'});
            return $mmFS.unzipFile(zippath, dirPath).then(function() {
                return $mmFilepool.removeFileByUrl(siteId, packageUrl).catch(function() {
                });
            }, undefined, deferred.notify);
        }).then(deferred.resolve, deferred.reject);
        return deferred.promise;
    }
        self.downloadWSData = function(scorm, siteId) {
        siteId = siteId || $mmSite.getId();
        var promises = [];
        promises.push($mmaModScormOnline.getAttemptCount(siteId, scorm.id).catch(function() {
            return 0;
        }).then(function(numAttempts) {
            if (numAttempts > 0) {
                var datapromises = [],
                    attempts = [];
                for (var i = 1; i <= numAttempts; i++) {
                    attempts.push(i);
                }
                attempts.forEach(function(attempt) {
                    datapromises.push($mmaModScormOnline.getScormUserData(siteId, scorm.id, attempt).catch(function(err) {
                        if (attempt == numAttempts) {
                            return $q.reject(err);
                        }
                    }));
                });
                return $q.all(datapromises);
            } else {
                return $mmaModScormOnline.getScormUserData(siteId, scorm.id, 0);
            }
        }));
        promises.push($mmaModScorm.getScos(scorm.id, siteId));
        return $q.all(promises);
    };
        self.getDownloadSize = function(module, courseId) {
        return $mmaModScorm.getScorm(courseId, module.id, module.url).then(function(scorm) {
            if ($mmaModScorm.isScormSupported(scorm) !== true) {
                return {size: -1, total: false};
            } else if (!scorm.packagesize) {
                return $mmaModScorm.calculateScormSize(scorm).then(function(size) {
                    return {size: size, total: true};
                });
            } else {
                return {size: scorm.packagesize, total: true};
            }
        });
    };
        self.getDownloadedSize = function(module, courseId) {
        return $mmaModScorm.getScorm(courseId, module.id, module.url).then(function(scorm) {
            return $mmaModScorm.getScormFolder(scorm.moduleurl);
        }).then(function(path) {
            return $mmFS.getDirectorySize(path);
        });
    };
        self.getFiles = function(module, courseid) {
        return $mmaModScorm.getScorm(courseid, module.id, module.url).then(function(scorm) {
            return $mmaModScorm.getScormFileList(scorm);
        }).catch(function() {
            return [];
        });
    };
        self.getRevision = function(module, courseid) {
        return $mmaModScorm.getScorm(courseid, module.id, module.url).then(function(scorm) {
            return scorm.sha1hash;
        });
    };
        self.getTimemodified = function(module, courseid) {
        return 0;
    };
        self.invalidateContent = function(moduleId, courseId) {
        return $mmaModScorm.invalidateContent(moduleId, courseId);
    };
        self.invalidateModule = function(module, courseId) {
        return $mmaModScorm.invalidateScormData(courseId);
    };
        self.isDownloadable = function(module, courseId) {
        return $mmaModScorm.getScorm(courseId, module.id, module.url, false, true).then(function(scorm) {
            if (scorm.warningmessage) {
                return false;
            }
            if ($mmaModScorm.isScormSupported(scorm) !== true) {
                return false;
            }
            return true;
        });
    };
        self.isEnabled = function() {
        return $mmaModScorm.isPluginEnabled();
    };
        self.prefetch = function(module, courseId) {
        return self.prefetchPackage(module, courseId, true, downloadOrPrefetchScorm, $mmSite.getId(), true);
    };
        self.removeFiles = function(module, courseId) {
        var siteId = $mmSite.getId(),
            scorm;
        return $mmaModScorm.getScorm(courseId, module.id, module.url).then(function(s) {
            scorm = s;
            return $mmaModScorm.getScormFolder(scorm.moduleurl);
        }).then(function(path) {
            var promises = [];
            promises.push($mmFS.removeDir(path).catch(function(error) {
                if (error && error.code == 1) {
                } else {
                    return $q.reject(error);
                }
            }));
            promises.push($mmFilepool.removeFileByUrl(siteId, $mmaModScorm.getPackageUrl(scorm)).catch(function() {
            }));
            return $q.all(promises);
        });
    };
    return self;
}]);

angular.module('mm.addons.mod_scorm')
.factory('$mmaModScorm', ["$mmSite", "$q", "$translate", "$mmFilepool", "$mmFS", "$mmWS", "$sce", "$mmaModScormOnline", "$mmaModScormOffline", "$mmUtil", "$log", "$mmSitesManager", "mmaModScormComponent", "mmCoreOutdated", "mmCoreDownloading", function($mmSite, $q, $translate, $mmFilepool, $mmFS, $mmWS, $sce, $mmaModScormOnline,
            $mmaModScormOffline, $mmUtil, $log, $mmSitesManager, mmaModScormComponent, mmCoreOutdated, mmCoreDownloading) {
    $log = $log.getInstance('$mmaModScorm');
    var self = {},
        statuses = ['notattempted', 'passed', 'completed', 'failed', 'incomplete', 'browsed', 'suspend'];
    self.GRADESCOES     = 0;
    self.GRADEHIGHEST   = 1;
    self.GRADEAVERAGE   = 2;
    self.GRADESUM       = 3;
    self.HIGHESTATTEMPT = 0;
    self.AVERAGEATTEMPT = 1;
    self.FIRSTATTEMPT   = 2;
    self.LASTATTEMPT    = 3;
    self.MODEBROWSE = 'browse';
    self.MODENORMAL = 'normal';
    self.MODEREVIEW = 'review';
        self.calculateScormGrade = function(scorm, onlineAttempts) {
        if (!onlineAttempts || !Object.keys(onlineAttempts).length) {
            return -1;
        }
        switch (scorm.whatgrade) {
            case self.FIRSTATTEMPT:
                return onlineAttempts[1] ? onlineAttempts[1].grade : -1;
            case self.LASTATTEMPT:
                var max = 0;
                angular.forEach(Object.keys(onlineAttempts), function(number) {
                    max = Math.max(number, max);
                });
                if (max > 0) {
                    return onlineAttempts[max].grade;
                }
                return -1;
            case self.HIGHESTATTEMPT:
                var grade = 0;
                angular.forEach(onlineAttempts, function(attempt) {
                    grade = Math.max(attempt.grade, grade);
                });
                return grade;
            case self.AVERAGEATTEMPT:
                var sumgrades = 0,
                    total = 0;
                angular.forEach(onlineAttempts, function(attempt) {
                    sumgrades += attempt.grade;
                    total++;
                });
                return Math.round(sumgrades / total);
        }
        return -1;
    };
        self.calculateScormSize = function(scorm) {
        if (scorm.packagesize) {
            return $q.when(scorm.packagesize);
        }
        return $mmWS.getRemoteFileSize(self.getPackageUrl(scorm));
    };
        self.countAttemptsLeft = function(scorm, attemptsCount) {
        if (scorm.maxattempt == 0) {
            return Number.MAX_VALUE;
        }
        attemptsCount = parseInt(attemptsCount, 10);
        if (isNaN(attemptsCount)) {
            return -1;
        }
        return scorm.maxattempt - attemptsCount;
    };
        self.determineAttemptAndMode = function(scorm, mode, attempt, newAttempt, incomplete) {
        if (mode == self.MODEBROWSE) {
            if (scorm.hidebrowse) {
                mode = self.MODENORMAL;
            } else {
                if (attempt == 0) {
                    attempt = 1;
                    newAttempt = true;
                }
                return {
                    mode: mode,
                    attempt: attempt,
                    newAttempt: newAttempt
                };
            }
        }
        if (attempt == 0) {
            newAttempt = true;
        } else if (incomplete) {
            newAttempt = false;
        } else if (scorm.forcenewattempt) {
            newAttempt = true;
        }
        if (newAttempt && (scorm.maxattempt == 0 || attempt < scorm.maxattempt)) {
            attempt++;
            mode = self.MODENORMAL;
        } else {
            if (incomplete) {
                mode = self.MODENORMAL;
            } else {
                mode = self.MODEREVIEW;
            }
        }
        return {
            mode: mode,
            attempt: attempt,
            newAttempt: newAttempt
        };
    };
        self.displayTocInPlayer = function(scorm) {
        return scorm.hidetoc !== 3;
    };
        self.evalPrerequisites = function(prerequisites, trackData) {
        var stack = [],
            statuses = {
                'passed': 'passed',
                'completed': 'completed',
                'failed': 'failed',
                'incomplete': 'incomplete',
                'browsed': 'browsed',
                'not attempted': 'notattempted',
                'p': 'passed',
                'c': 'completed',
                'f': 'failed',
                'i': 'incomplete',
                'b': 'browsed',
                'n': 'notattempted'
            };
        prerequisites = prerequisites.replace(/&amp;/gi, '&');
        prerequisites = prerequisites.replace(/(&|\||\(|\)|\~)/gi, '\t$1\t');
        prerequisites = prerequisites.replace(/&/gi, '&&');
        prerequisites = prerequisites.replace(/\|/gi, '||');
        var elements = prerequisites.trim().split('\t');
        angular.forEach(elements, function(element) {
            element = element.trim();
            if (!element) {
                return;
            }
            if (!element.match(/^(&&|\|\||\(|\))$/gi)) {
                var re = /^(\d+)\*\{(.+)\}$/,
                    reOther = /^(.+)(\=|\<\>)(.+)$/,
                    matches;
                if (re.test(element)) {
                    matches = element.match(re);
                    var repeat = matches[1],
                        set = matches[2].split(','),
                        count = 0;
                    angular.forEach(set, function(setelement) {
                        setelement = setelement.trim();
                        if (typeof trackData[setelement] != 'undefined' &&
                                (trackData[setelement].status == 'completed' || trackData[setelement].status == 'passed')) {
                            count++;
                        }
                    });
                    if (count >= repeat) {
                        element = 'true';
                    } else {
                        element = 'false';
                    }
                } else if (element == '~') {
                    element = '!';
                } else if (reOther.test(element)) {
                    matches = element.match(reOther);
                    element = matches[1].trim();
                    if (typeof trackData[element] != 'undefined') {
                        value = matches[3].trim().replace(/(\'|\")/gi);
                        if (typeof statuses[value] != 'undefined') {
                            value = statuses[value];
                        }
                        if (matches[2] == '<>') {
                            oper = '!=';
                        } else {
                            oper = '==';
                        }
                        element = '(\'' + trackData[element].status + '\' ' + oper + ' \'' + value + '\')';
                    } else {
                        element = 'false';
                    }
                } else {
                    if (typeof trackData[element] != 'undefined' &&
                            (trackData[element].status == 'completed' || trackData[element].status == 'passed')) {
                        element = 'true';
                    } else {
                        element = 'false';
                    }
                }
            }
            stack.push(' ' + element + ' ');
        });
        return eval(stack.join('') + ';');
    };
        self.formatGrade = function(scorm, grade) {
        if (typeof grade == 'undefined' || grade == -1) {
            return $translate.instant('mm.core.none');
        }
        if (scorm.grademethod !== self.GRADESCOES && scorm.maxgrade > 0) {
            grade = (grade / scorm.maxgrade) * 100;
            return $translate.instant('mm.core.percentagenumber', {$a: $mmUtil.roundToDecimals(grade, 2)});
        }
        return grade;
    };
        self.formatTocToArray = function(toc, level) {
        if (!toc || !toc.length) {
            return [];
        }
        if (typeof level == 'undefined') {
            level = 0;
        }
        var formatted = [];
        angular.forEach(toc, function(node) {
            node.level = level;
            formatted.push(node);
            formatted = formatted.concat(self.formatTocToArray(node.children, level + 1));
        });
        return formatted;
    };
        self.getAttemptCount = function(scormId, siteId, userId, ignoreMissing, ignoreCache) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            var result = {
                    lastAttempt: {
                        number: 0,
                        offline: false
                    }
                },
                promises = [];
            promises.push($mmaModScormOnline.getAttemptCount(siteId, scormId, userId, ignoreMissing, ignoreCache)
                        .then(function(count) {
                result.online = [];
                for (var i = 1; i <= count; i++) {
                    result.online.push(i);
                }
                if (count > result.lastAttempt.number) {
                    result.lastAttempt.number = count;
                    result.lastAttempt.offline = false;
                }
            }));
            promises.push($mmaModScormOffline.getAttempts(siteId, scormId, userId).then(function(attempts) {
                result.offline = attempts.map(function(entry) {
                    if (entry.attempt >= result.lastAttempt.number) {
                        result.lastAttempt.number = entry.attempt;
                        result.lastAttempt.offline = true;
                    }
                    return entry.attempt;
                });
            }));
            return $q.all(promises).then(function() {
                var total = result.online.length;
                result.offline.forEach(function(attempt) {
                    if (result.online.indexOf(attempt) == -1) {
                        total++;
                    }
                });
                result.total = total;
                return result;
            });
        });
    };
        self.getAttemptGrade = function(scorm, attempt, offline, siteId) {
        var attemptscore = {
            scos: 0,
            values: 0,
            max: 0,
            sum: 0
        };
        return self.getScormUserData(scorm.id, attempt, offline, siteId).then(function(data) {
            angular.forEach(data, function(scodata) {
                var userdata = scodata.userdata;
                if (userdata.status == 'completed' || userdata.status == 'passed') {
                    attemptscore.scos++;
                }
                if (userdata.score_raw || (typeof scorm.scormtype != 'undefined' &&
                            scorm.scormtype == 'sco' && typeof userdata.score_raw != 'undefined')) {
                    var scoreraw = parseFloat(userdata.score_raw);
                    attemptscore.values++;
                    attemptscore.sum += scoreraw;
                    attemptscore.max = Math.max(scoreraw, attemptscore.max);
                }
            });
            var score = 0;
            switch (scorm.grademethod) {
                case self.GRADEHIGHEST:
                    score = attemptscore.max;
                break;
                case self.GRADEAVERAGE:
                    if (attemptscore.values > 0) {
                        score = attemptscore.sum / attemptscore.values;
                    } else {
                        score = 0;
                    }
                break;
                case self.GRADESUM:
                    score = attemptscore.sum;
                break;
                case self.GRADESCOES:
                    score = attemptscore.scos;
                break;
                default:
                    score = attemptscore.max;  
            }
            return score;
        });
    };
        self.getOrganizations = function(scormId, siteId) {
        return self.getScos(scormId, siteId).then(function(scos) {
            var organizations = [];
            angular.forEach(scos, function(sco) {
                if (sco.organization == '' && sco.parent == '/' && sco.scormtype == '') {
                    organizations.push({
                        identifier: sco.identifier,
                        title: sco.title,
                        sortorder: sco.sortorder
                    });
                }
            });
            return organizations;
        });
    };
        self.getOrganizationToc = function(scormId, organization, attempt, offline, siteId) {
        return self.getScosWithData(scormId, organization, attempt, offline, false, siteId).then(function(scos) {
            var map = {},
                rootScos = [];
            angular.forEach(scos, function(sco, index) {
                sco.children = [];
                map[sco.identifier] = index;
                if (sco.parent !== '/') {
                    if (sco.parent == organization) {
                        rootScos.push(sco);
                    } else {
                        scos[map[sco.parent]].children.push(sco);
                    }
                }
            });
            return rootScos;
        });
    };
        self.getPackageUrl = function(scorm) {
        if (scorm.packageurl) {
            return scorm.packageurl;
        }
        if (scorm.reference) {
            return scorm.reference;
        }
        return '';
    };
        self.getScormUserData = function(scormId, attempt, offline, siteId, scos, ignoreCache) {
        siteId = siteId || $mmSite.getId();
        if (offline) {
            var promise = scos ? $q.when(scos) : self.getScos(scormId, siteId);
            return promise.then(function(scos) {
                return $mmaModScormOffline.getScormUserData(siteId, scormId, attempt, undefined, scos);
            });
        } else {
            return $mmaModScormOnline.getScormUserData(siteId, scormId, attempt, ignoreCache);
        }
    };
        function getScosCacheKey(scormId) {
        return 'mmaModScorm:scos:' + scormId;
    }
        self.getScos = function(scormId, siteId, organization, ignoreCache) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            organization = organization || '';
            var params = {
                    scormid: scormId
                },
                preSets = {
                    cacheKey: getScosCacheKey(scormId)
                };
            if (ignoreCache) {
                preSets.getFromCache = 0;
                preSets.emergencyCache = 0;
            }
            return site.read('mod_scorm_get_scorm_scoes', params, preSets).then(function(response) {
                if (response && response.scoes) {
                    var scos = [];
                    if (organization) {
                        angular.forEach(response.scoes, function(sco) {
                            if (sco.organization == organization) {
                                scos.push(sco);
                            }
                        });
                    } else {
                        scos = response.scoes;
                    }
                    return scos;
                }
                return $q.reject();
            });
        });
    };
        self.getScosWithData = function(scormId, organization, attempt, offline, ignoreCache, siteId) {
        return self.getScos(scormId, siteId, organization, ignoreCache).then(function(scos) {
            return self.getScormUserData(scormId, attempt, offline, siteId, scos, ignoreCache).then(function(data) {
                var trackDataBySCO = {};
                angular.forEach(scos, function(sco) {
                    trackDataBySCO[sco.identifier] = data[sco.id].userdata;
                });
                angular.forEach(scos, function(sco) {
                    var scodata = data[sco.id].userdata;
                    if (!scodata) {
                        return;
                    }
                    sco.isvisible = typeof scodata.isvisible != 'undefined' ?
                                            scodata.isvisible && scodata.isvisible !== 'false' : true;
                    sco.prereq = typeof scodata.prerequisites == 'undefined' ||
                                            self.evalPrerequisites(scodata.prerequisites, trackDataBySCO);
                    sco.status = (typeof scodata.status == 'undefined' || scodata.status === '') ?
                                            'notattempted' : scodata.status;
                    sco.exitvar = typeof scodata.exitvar == 'undefined' ? 'cmi.core.exit' : scodata.exitvar;
                    sco.exitvalue = scodata[sco.exitvar];
                });
                return scos;
            });
        });
    };
        self.getScoSrc = function(scorm, sco, siteId) {
        if (sco.launch.match(/http(s)?:\/\//)) {
            return $q.when($sce.trustAsResourceUrl(sco.launch));
        }
        siteId = siteId || $mmSite.getId();
        return $mmFilepool.getPackageDirUrlByUrl(siteId, scorm.moduleurl).then(function(dirPath) {
            return $sce.trustAsResourceUrl($mmFS.concatenatePaths(dirPath, sco.launch));
        });
    };
        self.getScormFolder = function(moduleUrl, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmFilepool.getPackageDirPathByUrl(siteId, moduleUrl);
    };
        self.getScormFileList = function(scorm) {
        var files = [];
        if (self.isScormSupported(scorm) === true && !scorm.warningmessage) {
            files.push({
                fileurl: self.getPackageUrl(scorm),
                filepath: '/',
                filename: scorm.reference,
                filesize: scorm.packagesize,
                type: 'file',
                timemodified: 0
            });
        }
        return files;
    };
        self.getScoStatusIcon = function(sco, incomplete) {
        var imagename = '',
            descname = '',
            status;
        if (sco.scormtype == 'sco') {
            status = sco.status;
            if (statuses.indexOf(status) < 0) {
                status = 'notattempted';
            }
            if (!incomplete) {
                incomplete = self.isStatusIncomplete(status);
            }
            if (incomplete && sco.exitvalue == 'suspend') {
                imagename = 'suspend';
                descname = 'suspended';
            } else {
                imagename = sco.status;
                descname = sco.status;
            }
        } else {
            imagename = 'asset';
            descname = (!sco.status || sco.status == 'notattempted') ? 'asset' : 'assetlaunched';
        }
        return {
            url: 'addons/mod/scorm/img/' + imagename + '.gif',
            description: $translate.instant('mma.mod_scorm.' + descname)
        };
    };
        function getScormDataCacheKey(courseId) {
        return 'mmaModScorm:scorm:' + courseId;
    }
        function getScorm(siteId, courseId, key, value, moduleUrl, forceCache) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    courseids: [courseId]
                },
                preSets = {
                    cacheKey: getScormDataCacheKey(courseId)
                };
            if (forceCache) {
                preSets.omitExpires = true;
            }
            return site.read('mod_scorm_get_scorms_by_courses', params, preSets).then(function(response) {
                if (response && response.scorms) {
                    var currentScorm;
                    angular.forEach(response.scorms, function(scorm) {
                        if (!currentScorm && scorm[key] == value) {
                            currentScorm = scorm;
                        }
                    });
                    if (currentScorm) {
                        if (typeof currentScorm.timeopen == 'undefined') {
                            angular.forEach(response.warnings, function(warning) {
                                if (warning.itemid === currentScorm.id) {
                                    currentScorm.warningmessage = warning.message;
                                }
                            });
                        }
                        currentScorm.moduleurl = moduleUrl;
                        return currentScorm;
                    }
                }
                return $q.reject();
            });
        });
    }
        self.getScorm = function(courseId, cmid, moduleUrl, siteId, forceCache) {
        siteId = siteId || $mmSite.getId();
        return getScorm(siteId, courseId, 'coursemodule', cmid, moduleUrl, forceCache);
    };
        self.getScormById = function(courseId, id, moduleUrl, siteId, forceCache) {
        siteId = siteId || $mmSite.getId();
        return getScorm(siteId, courseId, 'id', id, moduleUrl, forceCache);
    };
        self.getScormGradeMethod = function(scorm) {
        if (scorm.maxattempt == 1) {
            switch (parseInt(scorm.grademethod, 10)) {
                case self.GRADEHIGHEST:
                    return $translate.instant('mma.mod_scorm.gradehighest');
                case self.GRADEAVERAGE:
                    return $translate.instant('mma.mod_scorm.gradeaverage');
                case self.GRADESUM:
                    return $translate.instant('mma.mod_scorm.gradesum');
                case self.GRADESCOES:
                    return $translate.instant('mma.mod_scorm.gradescoes');
            }
        } else {
            switch (parseInt(scorm.whatgrade, 10)) {
                case self.HIGHESTATTEMPT:
                    return $translate.instant('mma.mod_scorm.highestattempt');
                case self.AVERAGEATTEMPT:
                    return $translate.instant('mma.mod_scorm.averageattempt');
                case self.FIRSTATTEMPT:
                    return $translate.instant('mma.mod_scorm.firstattempt');
                case self.LASTATTEMPT:
                    return $translate.instant('mma.mod_scorm.lastattempt');
            }
        }
    };
        self.invalidateAllScormData = function(scormId, siteId, userId) {
        siteId = siteId || $mmSite.getId();
        var promises = [];
        promises.push($mmaModScormOnline.invalidateAttemptCount(siteId, scormId, userId));
        promises.push(self.invalidateScos(scormId, siteId));
        promises.push($mmaModScormOnline.invalidateScormUserData(siteId, scormId));
        return $q.all(promises);
    };
        self.invalidateContent = function(moduleId, courseId, siteId, userId) {
        siteId = siteId || $mmSite.getId();
        return self.getScorm(courseId, moduleId).then(function(scorm) {
            var promises = [];
            promises.push(self.invalidateAllScormData(scorm.id, siteId, userId));
            promises.push($mmFilepool.invalidateFilesByComponent(siteId, mmaModScormComponent, moduleId));
            return $q.all(promises);
        });
    };
        self.invalidateScos = function(scormId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getScosCacheKey(scormId));
        });
    };
        self.invalidateScormData = function(courseId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getScormDataCacheKey(courseId));
        });
    };
        self.isAttemptIncomplete = function(scormId, attempt, offline, ignoreCache, siteId) {
        return self.getScosWithData(scormId, undefined, attempt, offline, ignoreCache, siteId).then(function(scos) {
            var incomplete = false;
            angular.forEach(scos, function(sco) {
                if (sco.isvisible && sco.launch) {
                    if (self.isStatusIncomplete(sco.status)) {
                        incomplete = true;
                    }
                }
            });
            return incomplete;
        });
    };
        self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return  site.wsAvailable('mod_scorm_get_scorm_attempt_count') &&
                    site.wsAvailable('mod_scorm_get_scorm_sco_tracks') &&
                    site.wsAvailable('mod_scorm_get_scorm_scoes') &&
                    site.wsAvailable('mod_scorm_get_scorm_user_data') &&
                    site.wsAvailable('mod_scorm_get_scorms_by_courses') &&
                    site.wsAvailable('mod_scorm_insert_scorm_tracks');
        });
    };
        self.isScormClosed = function(scorm) {
        var timeNow = $mmUtil.timestamp();
        if (scorm.timeclose > 0 && timeNow > scorm.timeclose) {
            return true;
        }
        return false;
    };
        self.isScormDownloadable = function(scorm) {
        return typeof scorm.protectpackagedownloads != 'undefined' && scorm.protectpackagedownloads === false;
    };
        self.isScormOpen = function(scorm) {
        var timeNow = $mmUtil.timestamp();
        if (scorm.timeopen > 0 && scorm.timeopen > timeNow) {
            return false;
        }
        return true;
    };
        self.isScormSupported = function(scorm) {
        if (!self.isScormValidVersion(scorm)) {
            return 'mma.mod_scorm.errorinvalidversion';
        } else if (!self.isScormDownloadable(scorm)) {
            return 'mma.mod_scorm.errornotdownloadable';
        } else if (!self.isValidPackageUrl(self.getPackageUrl(scorm))) {
            return 'mma.mod_scorm.errorpackagefile';
        }
        return true;
    };
        self.isScormValidVersion = function(scorm) {
        return scorm.version == 'SCORM_1.2';
    };
        self.isStatusIncomplete = function(status) {
        return !status || status == 'notattempted' || status == 'incomplete' || status == 'browsed';
    };
        self.isValidPackageUrl = function(packageUrl) {
        if (!packageUrl) {
            return false;
        }
        if (packageUrl.indexOf('imsmanifest.xml') > -1) {
            return false;
        }
        return true;
    };
        self.logView = function(id, siteId) {
        siteId = siteId || $mmSite.getId();
        if (id) {
            return $mmSitesManager.getSite(siteId).then(function(site) {
                var params = {
                    scormid: id
                };
                return site.write('mod_scorm_view_scorm', params);
            });
        }
        return $q.reject();
    };
        self.logLaunchSco = function(scormId, scoId, siteId) {
        siteId = siteId || $mmSite.getId();
        var params = {
            scormid: scormId,
            scoid: scoId
        };
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.write('mod_scorm_launch_sco', params).then(function(response) {
                if (!response || !response.status) {
                    return $q.reject();
                }
            });
        });
    };
        self.saveTracks = function(scoId, attempt, tracks, offline, scorm, userData, siteId) {
        siteId = siteId || $mmSite.getId();
        if (offline) {
            var promise = userData ? $q.when(userData) : self.getScormUserData(scorm.id, attempt, offline, siteId);
            return promise.then(function(userData) {
                return $mmaModScormOffline.saveTracks(siteId, scorm, scoId, attempt, tracks, userData);
            });
        } else {
            return $mmaModScormOnline.saveTracks(siteId, scorm.id, scoId, attempt, tracks).then(function() {
                self._updateUserDataAfterSave(siteId, scorm.id, attempt, tracks);
            });
        }
    };
        self.saveTracksSync = function(scoId, attempt, tracks, offline, scorm, userData) {
        if (offline) {
            return $mmaModScormOffline.saveTracksSync(scorm, scoId, attempt, tracks, userData);
        } else {
            var success = $mmaModScormOnline.saveTracksSync(scoId, attempt, tracks);
            if (success) {
                self._updateUserDataAfterSave($mmSite.getId(), scorm.id, attempt, tracks);
            }
            return success;
        }
    };
        self.shouldDownloadMainFile = function(scorm, isOutdated, siteId) {
        siteId = siteId || $mmSite.getId();
        if (typeof isOutdated == 'undefined') {
            return $mmFilepool.getPackageData(siteId, mmaModScormComponent, scorm.coursemodule).then(function(data) {
                var isOutdated = data.status == mmCoreOutdated ||
                        (data.status == mmCoreDownloading && data.previous == mmCoreOutdated);
                return !isOutdated || data.revision != scorm.sha1hash;
            }).catch(function() {
                return $q.when(true);
            });
        } else if (isOutdated) {
            return $mmFilepool.getPackageRevision(siteId, mmaModScormComponent, scorm.coursemodule).then(function(revision) {
                return scorm.sha1hash != revision;
            }).catch(function() {
                return $q.when(true);
            });
        } else {
            return $q.when(true);
        }
    };
        self._updateUserDataAfterSave = function(siteId, scormId, attempt, tracks) {
        if (!tracks || !tracks.length) {
            return $q.when();
        }
        var needsUpdate = false;
        for (var i = 0, len = tracks.length; i < len && !needsUpdate; i++) {
            var track = tracks[i];
            if (track.element && track.element.indexOf('.') > -1) {
                needsUpdate = true;
            }
        }
        if (needsUpdate) {
            return $mmaModScormOnline.getScormUserData(siteId, scormId, attempt, true);
        }
        return $q.when();
    };
    return self;
}]);

angular.module('mm.addons.mod_scorm')
.constant('mmaModScormOfflineAttemptsStore', 'mod_scorm_offline_attempts')
.constant('mmaModScormOfflineTracksStore', 'mod_scorm_offline_scos_tracks')
.config(["$mmSitesFactoryProvider", "mmaModScormOfflineAttemptsStore", "mmaModScormOfflineTracksStore", function($mmSitesFactoryProvider, mmaModScormOfflineAttemptsStore, mmaModScormOfflineTracksStore) {
    var stores = [
        {
            name: mmaModScormOfflineAttemptsStore,
            keyPath: ['scormid', 'userid', 'attempt'],
            indexes: [
                {
                    name: 'attempt'
                },
                {
                    name: 'userid'
                },
                {
                    name: 'scormid'
                },
                {
                    name: 'courseid'
                },
                {
                    name: 'timemodified'
                },
                {
                    name: 'scormAndUser',
                    keyPath: ['scormid', 'userid']
                }
            ]
        },
        {
            name: mmaModScormOfflineTracksStore,
            keyPath: ['userid', 'scormid', 'scoid', 'attempt', 'element'],
            indexes: [
                {
                    name: 'userid'
                },
                {
                    name: 'scormid'
                },
                {
                    name: 'scoid'
                },
                {
                    name: 'attempt'
                },
                {
                    name: 'element'
                },
                {
                    name: 'synced'
                },
                {
                    name: 'scormUserAttempt',
                    keyPath: ['scormid', 'userid', 'attempt']
                },
                {
                    name: 'scormUserAttemptSynced',
                    keyPath: ['scormid', 'userid', 'attempt', 'synced']
                }
            ]
        }
    ];
    $mmSitesFactoryProvider.registerStores(stores);
}])
.factory('$mmaModScormOffline', ["$mmSite", "$mmUtil", "$q", "$log", "$mmSitesManager", "mmaModScormOfflineAttemptsStore", "mmaModScormOfflineTracksStore", "$mmSyncBlock", "mmaModScormComponent", function($mmSite, $mmUtil, $q, $log, $mmSitesManager, mmaModScormOfflineAttemptsStore,
            mmaModScormOfflineTracksStore, $mmSyncBlock, mmaModScormComponent) {
    $log = $log.getInstance('$mmaModScormOffline');
    var self = {};
        self.changeAttemptNumber = function(siteId, scormId, attempt, newAttempt, userId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            $log.debug('Change attempt number from ' + attempt + ' to ' + newAttempt + ' in SCORM ' + scormId);
            userId = userId || site.getUserId();
            var db = site.getDb(),
                newEntry = {
                    scormid: scormId,
                    userid: userId,
                    attempt: newAttempt,
                    timemodified: $mmUtil.timestamp()
                };
            $mmSyncBlock.blockOperation(mmaModScormComponent, scormId, 'changeAttemptNumber', siteId);
            return db.get(mmaModScormOfflineAttemptsStore, [scormId, userId, attempt]).then(function(entry) {
                newEntry.timecreated = entry.timecreated;
                newEntry.courseid = entry.courseid;
                return db.insert(mmaModScormOfflineAttemptsStore, newEntry).then(function() {
                    return self.getScormStoredData(siteId, scormId, attempt, userId).then(function(entries) {
                        var promises = [];
                        angular.forEach(entries, function(entry) {
                            entry.attempt = newAttempt;
                            entry.synced = 0;
                            promises.push(db.insert(mmaModScormOfflineTracksStore, entry));
                        });
                        return $mmUtil.allPromises(promises).then(function() {
                            return self.deleteAttempt(siteId, scormId, attempt).catch(function() {
                                return self.deleteAttempt(siteId, scormId, attempt).catch(function() {});
                            });
                        });
                    }).catch(function() {
                        return self.deleteAttempt(siteId, scormId, newAttempt).then(function() {
                            return $q.reject();
                        });
                    });
                });
            }).finally(function() {
                $mmSyncBlock.unblockOperation(mmaModScormComponent, scormId, 'changeAttemptNumber', siteId);
            });
        });
    };
        self.createNewAttempt = function(siteId, scorm, userId, attempt, userData, snapshot) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            $log.debug('Creating new offline attempt ' + attempt + ' in SCORM ' + scorm.id);
            userId = userId || site.getUserId();
            $mmSyncBlock.blockOperation(mmaModScormComponent, scorm.id, 'createNewAttempt', siteId);
            var db = site.getDb(),
                entry = {
                    scormid: scorm.id,
                    userid: userId,
                    attempt: attempt,
                    courseid: scorm.course,
                    timecreated: $mmUtil.timestamp(),
                    timemodified: $mmUtil.timestamp()
                };
            if (snapshot) {
                entry.snapshot = removeDefaultData(snapshot);
            }
            return db.insert(mmaModScormOfflineAttemptsStore, entry).then(function() {
                var promises = [];
                angular.forEach(userData, function(sco) {
                    var tracks = [];
                    angular.forEach(sco.userdata, function(value, element) {
                        tracks.push({element: element, value: value});
                    });
                    promises.push(self.saveTracks(siteId, scorm, sco.scoid, attempt, tracks, userData));
                });
                return $q.all(promises);
            }).finally(function() {
                $mmSyncBlock.unblockOperation(mmaModScormComponent, scorm.id, 'createNewAttempt', siteId);
            });
        });
    };
        self.deleteAttempt = function(siteId, scormId, attempt, userId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            $log.debug('Delete offline attempt ' + attempt + ' in SCORM ' + scormId);
            userId = userId || site.getUserId();
            return self.getScormStoredData(siteId, scormId, attempt, userId).then(function(entries) {
                var promises = [],
                    db = site.getDb();
                angular.forEach(entries, function(entry) {
                    var entryId = [entry.userid, entry.scormid, entry.scoid, entry.attempt, entry.element];
                    promises.push(db.remove(mmaModScormOfflineTracksStore, entryId));
                });
                promises.push(db.remove(mmaModScormOfflineAttemptsStore, [scormId, userId, attempt]));
                return $q.all(promises);
            });
        });
    };
        function formatInteractions(scoUserData) {
        var formatted = {};
        formatted.score_raw = '';
        formatted.status = '';
        formatted.total_time = '00:00:00';
        formatted.session_time = '00:00:00';
        angular.forEach(scoUserData, function(value, element) {
            if (element == 'score_raw' || element == 'status' || element == 'total_time' || element == 'session_time') {
                return;
            }
            formatted[element] = value;
            switch (element) {
                case 'cmi.core.lesson_status':
                case 'cmi.completion_status':
                    if (value == 'not attempted') {
                        value = 'notattempted';
                    }
                    formatted.status = value;
                    break;
                case 'cmi.core.score.raw':
                case 'cmi.score.raw':
                    formatted.score_raw = $mmUtil.roundToDecimals(value, 2);
                    break;
                case 'cmi.core.session_time':
                case 'cmi.session_time':
                    formatted.session_time = value;
                    break;
                case 'cmi.core.total_time':
                case 'cmi.total_time':
                    formatted.total_time = value;
                    break;
            }
        });
        return formatted;
    }
        function getLaunchUrlsFromScos(scos) {
        var response = {};
        angular.forEach(scos, function(sco) {
            response[sco.id] = sco.launch;
        });
        return response;
    }
        self.getAllAttempts = function(siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSiteDb(siteId).then(function(db) {
            if (!db) {
                return $q.reject();
            }
            return db.getAll(mmaModScormOfflineAttemptsStore);
        });
    };
        self.getAttempts = function(siteId, scormId, userId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            var db = site.getDb();
            return db.whereEqual(mmaModScormOfflineAttemptsStore, 'scormAndUser', [scormId, userId]).then(function(attempts) {
                return attempts;
            });
        });
    };
        self.getAttemptSnapshot = function(siteId, scormId, attempt, userId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            return site.getDb().get(mmaModScormOfflineAttemptsStore, [scormId, userId, attempt]).catch(function() {
                return {};
            }).then(function(entry) {
                return entry.snapshot;
            });
        });
    };
        self.getAttemptCreationTime = function(siteId, scormId, attempt, userId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            return site.getDb().get(mmaModScormOfflineAttemptsStore, [scormId, userId, attempt]).catch(function() {
                return {};
            }).then(function(entry) {
                return entry.timecreated;
            });
        });
    };
        self.getScormStoredData = function(siteId, scormId, attempt, userId, excludeSynced, excludeNotSynced) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            var fieldName, where;
            if (excludeSynced && excludeNotSynced) {
                return $q.when([]);
            } else if (excludeSynced || excludeNotSynced) {
                fieldName = 'scormUserAttemptSynced';
                where = [scormId, userId, attempt, excludeNotSynced ? 1 : 0];
            } else {
                fieldName = 'scormUserAttempt';
                where = [scormId, userId, attempt];
            }
            return site.getDb().whereEqual(mmaModScormOfflineTracksStore, fieldName, where);
        });
    };
        self.getScormUserData = function(siteId, scormId, attempt, userId, scos) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            return self.getScormStoredData(siteId, scormId, attempt, userId).then(function(entries) {
                var response = {},
                    launchUrls = getLaunchUrlsFromScos(scos),
                    userId = site.getUserId(),
                    username = site.getInfo().username,
                    fullName = site.getInfo().fullname;
                angular.forEach(entries, function(entry) {
                    var scoid = entry.scoid;
                    if (!response[scoid]) {
                        response[scoid] = {
                            scoid: scoid,
                            userdata: {
                                userid: userId,
                                scoid: scoid,
                                timemodified: 0
                            }
                        };
                    }
                    response[scoid].userdata[entry.element] = entry.value;
                    if (entry.timemodified > response[scoid].userdata.timemodified) {
                        response[scoid].userdata.timemodified = entry.timemodified;
                    }
                });
                angular.forEach(response, function(sco) {
                    sco.userdata = formatInteractions(sco.userdata);
                });
                angular.forEach(scos, function(sco) {
                    if (!response[sco.id]) {
                        response[sco.id] = {
                            scoid: sco.id,
                            userdata: {
                                status: '',
                                score_raw: ''
                            }
                        };
                    }
                });
                angular.forEach(response, function(sco) {
                    sco.defaultdata = {};
                    sco.defaultdata['cmi.core.student_id'] = username;
                    sco.defaultdata['cmi.core.student_name'] = fullName;
                    sco.defaultdata['cmi.core.lesson_mode'] = 'normal';
                    sco.defaultdata['cmi.core.credit'] = 'credit';
                    if (sco.userdata.status === '') {
                        sco.defaultdata['cmi.core.entry'] = 'ab-initio';
                    } else if (sco.userdata['cmi.core.exit'] === 'suspend') {
                        sco.defaultdata['cmi.core.entry'] = 'resume';
                    } else {
                        sco.defaultdata['cmi.core.entry'] = '';
                    }
                    sco.defaultdata['cmi.student_data.mastery_score'] = scormIsset(sco.userdata, 'masteryscore');
                    sco.defaultdata['cmi.student_data.max_time_allowed'] = scormIsset(sco.userdata, 'max_time_allowed');
                    sco.defaultdata['cmi.student_data.time_limit_action'] = scormIsset(sco.userdata, 'time_limit_action');
                    sco.defaultdata['cmi.core.total_time'] = scormIsset(sco.userdata, 'cmi.core.total_time', '00:00:00');
                    sco.defaultdata['cmi.launch_data'] = launchUrls[sco.scoid];
                    sco.defaultdata['cmi.core.lesson_location'] = scormIsset(sco.userdata, 'cmi.core.lesson_location');
                    sco.defaultdata['cmi.core.lesson_status'] = scormIsset(sco.userdata, 'cmi.core.lesson_status');
                    sco.defaultdata['cmi.core.score.raw'] = scormIsset(sco.userdata, 'cmi.core.score.raw');
                    sco.defaultdata['cmi.core.score.max'] = scormIsset(sco.userdata, 'cmi.core.score.max');
                    sco.defaultdata['cmi.core.score.min'] = scormIsset(sco.userdata, 'cmi.core.score.min');
                    sco.defaultdata['cmi.core.exit'] = scormIsset(sco.userdata, 'cmi.core.exit');
                    sco.defaultdata['cmi.suspend_data'] = scormIsset(sco.userdata, 'cmi.suspend_data');
                    sco.defaultdata['cmi.comments'] = scormIsset(sco.userdata, 'cmi.comments');
                    sco.defaultdata['cmi.student_preference.language'] = scormIsset(sco.userdata, 'cmi.student_preference.language');
                    sco.defaultdata['cmi.student_preference.audio'] = scormIsset(sco.userdata, 'cmi.student_preference.audio', '0');
                    sco.defaultdata['cmi.student_preference.speed'] = scormIsset(sco.userdata, 'cmi.student_preference.speed', '0');
                    sco.defaultdata['cmi.student_preference.text'] = scormIsset(sco.userdata, 'cmi.student_preference.text', '0');
                    sco.userdata.student_id = username;
                    sco.userdata.student_name = fullName;
                    sco.userdata.mode = sco.defaultdata['cmi.core.lesson_mode'];
                    sco.userdata.credit = sco.defaultdata['cmi.core.credit'];
                    sco.userdata.entry = sco.defaultdata['cmi.core.entry'];
                });
                return response;
            });
        });
    };
        function insertTrackToDB(db, userId, scormId, scoId, attempt, element, value, synchronous) {
        var entry = {
            userid: userId,
            scormid: scormId,
            scoid: scoId,
            attempt: attempt,
            element: element,
            value: value,
            timemodified: $mmUtil.timestamp(),
            synced: 0
        };
        if (synchronous) {
            return db.insertSync(mmaModScormOfflineTracksStore, entry);
        } else {
            return db.insert(mmaModScormOfflineTracksStore, entry);
        }
    }
        function insertTrack(siteId, userId, scormId, scoId, attempt, element, value, forceCompleted, scoData) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            scoData = scoData || {};
            var promises = [],
                lessonStatusInserted = false,
                scoUserData = scoData.userdata || {},
                db = site.getDb();
            if (forceCompleted) {
                if (element == 'cmi.core.lesson_status' && value == 'incomplete') {
                    if (scoUserData['cmi.core.score.raw']) {
                        value = 'completed';
                    }
                }
                if (element == 'cmi.core.score.raw') {
                    if (scoUserData['cmi.core.lesson_status'] == 'incomplete') {
                        lessonStatusInserted = true;
                        promises.push(insertTrackToDB(db, userId, scormId, scoId, attempt, 'cmi.core.lesson_status', 'completed'));
                    }
                }
            }
            return $q.all(promises).then(function() {
                if (!scoUserData[element] || element != 'x.start.time') {
                    return insertTrackToDB(db, userId, scormId, scoId, attempt, element, value).catch(function() {
                        if (lessonStatusInserted) {
                            return insertTrackToDB(db, userId, scormId, scoId, attempt, 'cmi.core.lesson_status', 'incomplete')
                                    .then(function() {
                                return $q.reject();
                            });
                        }
                        return $q.reject();
                    });
                }
            });
        });
    }
        function insertTrackSync(userId, scormId, scoId, attempt, element, value, forceCompleted, scoData) {
        userId = userId || $mmSite.getUserId();
        scoData = scoData || {};
        if (!$mmSite.isLoggedIn()) {
            return false;
        }
        var lessonStatusInserted = false,
            scoUserData = scoData.userdata || {},
            db = $mmSite.getDb();
        if (forceCompleted) {
            if (element == 'cmi.core.lesson_status' && value == 'incomplete') {
                if (scoUserData['cmi.core.score.raw']) {
                    value = 'completed';
                }
            }
            if (element == 'cmi.core.score.raw') {
                if (scoUserData['cmi.core.lesson_status'] == 'incomplete') {
                    lessonStatusInserted = true;
                    if (!insertTrackToDB(db, userId, scormId, scoId, attempt, 'cmi.core.lesson_status', 'completed', true)) {
                        return false;
                    }
                }
            }
        }
        if (!scoUserData[element] || element != 'x.start.time') {
            if (!insertTrackToDB(db, userId, scormId, scoId, attempt, element, value, true)) {
                if (lessonStatusInserted) {
                    insertTrackToDB(db, userId, scormId, scoId, attempt, 'cmi.core.lesson_status', 'incomplete', true);
                }
                return false;
            }
            return true;
        }
    }
        self.markAsSynced = function(siteId, scormId, attempt, userId, scoId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            $log.debug('Mark SCO ' + scoId + ' as synced for attempt ' + attempt + ' in SCORM ' + scormId);
            userId = userId || site.getUserId();
            return self.getScormStoredData(siteId, scormId, attempt, userId, true).then(function(entries) {
                var promises = [],
                    db = site.getDb();
                angular.forEach(entries, function(entry) {
                    if (entry.scoid == scoId) {
                        entry.synced = 1;
                        promises.push(db.insert(mmaModScormOfflineTracksStore, entry));
                    }
                });
                return $q.all(promises);
            });
        });
    };
        function removeDefaultData(userData) {
        var result = angular.copy(userData);
        angular.forEach(result, function(sco) {
            delete sco.defaultdata;
        });
        return result;
    }
        self.saveTracks = function(siteId, scorm, scoId, attempt, tracks, userData) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var userId = site.getUserId();
            $mmSyncBlock.blockOperation(mmaModScormComponent, scorm.id, 'saveTracksOffline', siteId);
            var promises = [];
            angular.forEach(tracks, function(track) {
                promises.push(insertTrack(siteId, userId, scorm.id, scoId, attempt,
                                            track.element, track.value, scorm.forcecompleted, userData[scoId]));
            });
            return $q.all(promises).finally(function() {
                $mmSyncBlock.unblockOperation(mmaModScormComponent, scorm.id, 'saveTracksOffline', siteId);
            });
        });
    };
        self.saveTracksSync = function(scorm, scoId, attempt, tracks, userData) {
        var userId = $mmSite.getUserId(),
            success = true;
        angular.forEach(tracks, function(track) {
            if (!insertTrackSync(userId, scorm.id, scoId, attempt, track.element, track.value,
                                    scorm.forcecompleted, userData[scoId])) {
                success = false;
            }
        });
        return success;
    };
        function scormIsset(userdata, param, ifempty) {
        if (typeof ifempty == 'undefined') {
            ifempty = '';
        }
        if (typeof userdata[param] != 'undefined') {
            return userdata[param];
        }
        return ifempty;
    }
        self.setAttemptSnapshot = function(siteId, scormId, attempt, userData, userId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            $log.debug('Set snapshot for attempt ' + attempt + ' in SCORM ' + scormId);
            userId = userId || site.getUserId();
            return site.getDb().get(mmaModScormOfflineAttemptsStore, [scormId, userId, attempt]).then(function(entry) {
                entry.snapshot = removeDefaultData(userData);
                entry.timemodified = $mmUtil.timestamp();
                return site.getDb().insert(mmaModScormOfflineAttemptsStore, entry);
            });
        });
    };
    return self;
}]);

angular.module('mm.addons.mod_scorm')
.factory('$mmaModScormOnline', ["$mmSitesManager", "$mmSite", "$q", "$mmWS", "$log", "mmCoreWSPrefix", "$mmSyncBlock", "mmaModScormComponent", function($mmSitesManager, $mmSite, $q, $mmWS, $log, mmCoreWSPrefix, $mmSyncBlock,
        mmaModScormComponent) {
    $log = $log.getInstance('$mmaModScormOnline');
    var self = {};
        function getAttemptCountCacheKey(scormId, userId) {
        userId = userId || $mmSite.getUserId();
        return 'mmaModScorm:attemptcount:' + scormId + ':' + userId;
    }
        self.getAttemptCount = function(siteId, scormId, userId, ignoreMissing, ignoreCache) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            var params = {
                    scormid: scormId,
                    userid: userId,
                    ignoremissingcompletion: ignoreMissing ? 1 : 0
                },
                preSets = {
                    cacheKey: getAttemptCountCacheKey(scormId, userId)
                };
            if (ignoreCache) {
                preSets.getFromCache = 0;
                preSets.emergencyCache = 0;
            }
            return site.read('mod_scorm_get_scorm_attempt_count', params, preSets).then(function(response) {
                if (response && typeof response.attemptscount != 'undefined') {
                    return response.attemptscount;
                }
                return $q.reject();
            });
        });
    };
        function getScormUserDataCacheKey(scormId, attempt) {
        return getScormUserDataCommonCacheKey(scormId) + ':' + attempt;
    }
        function getScormUserDataCommonCacheKey(scormId) {
        return 'mmaModScorm:userdata:' + scormId;
    }
        self.getScormUserData = function(siteId, scormId, attempt, ignoreCache) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    scormid: scormId,
                    attempt: attempt
                },
                preSets = {
                    cacheKey: getScormUserDataCacheKey(scormId, attempt)
                };
            if (ignoreCache) {
                preSets.getFromCache = 0;
                preSets.emergencyCache = 0;
            }
            return site.read('mod_scorm_get_scorm_user_data', params, preSets).then(function(response) {
                if (response && response.data) {
                    var data = {};
                    angular.forEach(response.data, function(sco) {
                        var formattedDefaultData = {},
                            formattedUserData = {};
                        angular.forEach(sco.defaultdata, function(entry) {
                            formattedDefaultData[entry.element] = entry.value;
                        });
                        angular.forEach(sco.userdata, function(entry) {
                            formattedUserData[entry.element] = entry.value;
                        });
                        sco.defaultdata = formattedDefaultData;
                        sco.userdata = formattedUserData;
                        data[sco.scoid] = sco;
                    });
                    return data;
                }
                return $q.reject();
            });
        });
    };
        self.invalidateAttemptCount = function(siteId, scormId, userId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            return site.invalidateWsCacheForKey(getAttemptCountCacheKey(scormId, userId));
        });
    };
        self.invalidateScormUserData = function(siteId, scormId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKeyStartingWith(getScormUserDataCommonCacheKey(scormId));
        });
    };
        self.saveTracks = function(siteId, scormId, scoId, attempt, tracks) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                scoid: scoId,
                attempt: attempt,
                tracks: tracks
            };
            if (!tracks || !tracks.length) {
                return $q.when();
            }
            $mmSyncBlock.blockOperation(mmaModScormComponent, scormId, 'saveTracksOnline', siteId);
            return site.write('mod_scorm_insert_scorm_tracks', params).then(function(response) {
                if (response && response.trackids) {
                    return response.trackids;
                }
                return $q.reject();
            }).finally(function() {
                $mmSyncBlock.unblockOperation(mmaModScormComponent, scormId, 'saveTracksOnline', siteId);
            });
        });
    };
        self.saveTracksSync = function(scoId, attempt, tracks) {
        var params = {
                scoid: scoId,
                attempt: attempt,
                tracks: tracks
            },
            preSets = {
                siteurl: $mmSite.getURL(),
                wstoken: $mmSite.getToken()
            },
            wsFunction = $mmSite.getCompatibleFunction('mod_scorm_insert_scorm_tracks'),
            response;
        if (!tracks || !tracks.length) {
            return true;
        }
        if (!$mmSite.wsAvailable(wsFunction, false)) {
            if ($mmSite.wsAvailable(mmCoreWSPrefix + wsFunction, false)) {
                wsFunction = mmCoreWSPrefix + wsFunction;
            } else {
                $log.error("WS function '" + wsFunction + "' is not available, even in compatibility mode.");
                return false;
            }
        }
        response = $mmWS.syncCall(wsFunction, params, preSets);
        if (response && !response.error && response.trackids) {
            return true;
        }
        return false;
    };
    return self;
}]);

angular.module('mm.addons.mod_scorm')
.factory('$mmaModScormSync', ["$mmaModScorm", "$mmSite", "$q", "$translate", "$mmaModScormOnline", "$mmaModScormOffline", "$mmUtil", "$log", "mmaModScormSyncTime", "$mmApp", "$mmEvents", "mmaModScormEventAutomSynced", "$mmSitesManager", "$mmSync", "mmaModScormComponent", "$mmaModScormPrefetchHandler", "$mmCourse", "$mmSyncBlock", "$mmLang", function($mmaModScorm, $mmSite, $q, $translate, $mmaModScormOnline, $mmaModScormOffline, $mmUtil, $log,
            mmaModScormSyncTime, $mmApp, $mmEvents, mmaModScormEventAutomSynced, $mmSitesManager, $mmSync, mmaModScormComponent,
            $mmaModScormPrefetchHandler, $mmCourse, $mmSyncBlock, $mmLang) {
    $log = $log.getInstance('$mmaModScormSync');
    var self = $mmSync.createChild(mmaModScormComponent, mmaModScormSyncTime);
        self.syncAllScorms = function(siteId) {
        if (!$mmApp.isOnline()) {
            $log.debug('Cannot sync all SCORMs because device is offline.');
            return $q.reject();
        }
        var promise;
        if (!siteId) {
            $log.debug('Try to sync SCORMs in all sites.');
            promise = $mmSitesManager.getSitesIds();
        } else {
            $log.debug('Try to sync SCORMs in site ' + siteId);
            promise = $q.when([siteId]);
        }
        return promise.then(function(siteIds) {
            var sitePromises = [];
            angular.forEach(siteIds, function(siteId) {
                sitePromises.push($mmaModScormOffline.getAllAttempts(siteId).then(function(attempts) {
                    var scorms = [],
                        ids = [],
                        promises = [];
                    angular.forEach(attempts, function(attempt) {
                        if (ids.indexOf(attempt.scormid) == -1) {
                            ids.push(attempt.scormid);
                            scorms.push({
                                id: attempt.scormid,
                                courseid: attempt.courseid
                            });
                        }
                    });
                    angular.forEach(scorms, function(scorm) {
                        if (!$mmSyncBlock.isBlocked(mmaModScormComponent, scorm.id, siteId)) {
                            promises.push($mmaModScorm.getScormById(scorm.courseid, scorm.id, '', siteId).then(function(scorm) {
                                return self.syncScormIfNeeded(scorm, siteId).then(function(data) {
                                    if (typeof data != 'undefined') {
                                        $mmEvents.trigger(mmaModScormEventAutomSynced, {
                                            siteid: siteId,
                                            scormid: scorm.id,
                                            attemptFinished: data.attemptFinished,
                                            warnings: data.warnings
                                        });
                                    }
                                });
                            }));
                        }
                    });
                    return $q.all(promises);
                }));
            });
            return $q.all(sitePromises);
        });
    };
        self._syncAttempt = function(scormId, attempt, siteId) {
        siteId = siteId || $mmSite.getId();
        $log.debug('Try to sync attempt ' + attempt + ' in SCORM ' + scormId + ' and site ' + siteId);
        return $mmaModScormOffline.getScormStoredData(siteId, scormId, attempt, undefined, true).then(function(entries) {
            var scos = {},
                promises = [],
                somethingSynced = false;
            angular.forEach(entries, function(entry) {
                if (entry.element.indexOf('.') > -1) {
                    if (!scos[entry.scoid]) {
                        scos[entry.scoid] = [];
                    }
                    scos[entry.scoid].push({
                        element: entry.element,
                        value: entry.value
                    });
                }
            });
            angular.forEach(scos, function(tracks, scoId) {
                promises.push($mmaModScormOnline.saveTracks(siteId, scormId, scoId, attempt, tracks).then(function() {
                    return $mmaModScormOffline.markAsSynced(siteId, scormId, attempt, undefined, scoId).catch(function() {
                    }).then(function() {
                        somethingSynced = true;
                    });
                }));
            });
            return $mmUtil.allPromises(promises).then(function() {
                return $mmaModScormOffline.deleteAttempt(siteId, scormId, attempt).catch(function() {
                    return $mmaModScormOffline.deleteAttempt(siteId, scormId, attempt).catch(function() {
                        $log.error('After sync: error deleting attempt ' + attempt + ' in SCORM ' + scormId);
                    });
                });
            }).catch(function() {
                if (somethingSynced) {
                    $log.error('Error synchronizing some SCOs for attempt ' + attempt + ' in SCORM ' + scormId + '. Saving snapshot.');
                    return saveSyncSnapshot(scormId, attempt, siteId).then(function() {
                        return $q.reject();
                    });
                } else {
                    $log.error('Error synchronizing attempt ' + attempt + ' in SCORM ' + scormId);
                }
                return $q.reject();
            });
        });
    };
        function saveSyncSnapshot(scormId, attempt, siteId) {
        return $mmaModScorm.getScormUserData(scormId, attempt, false, siteId, undefined, true).then(function(data) {
            return $mmaModScormOffline.setAttemptSnapshot(siteId, scormId, attempt, data);
        }, function() {
            return $mmaModScorm.getScormUserData(scormId, attempt, false, siteId).catch(function() {
                return {};
            }).then(function(data) {
                return $mmaModScormOffline.getScormStoredData(siteId, scormId, attempt, undefined, false, true)
                            .then(function(synced) {
                    angular.forEach(synced, function(entry) {
                        if (!data[entry.scoid]) {
                            data[entry.scoid] = {
                                scoid: entry.scoid,
                                userdata: {}
                            };
                        }
                        data[entry.scoid].userdata[entry.element] = entry.value;
                    });
                    return $mmaModScormOffline.setAttemptSnapshot(siteId, scormId, attempt, data);
                });
            });
        });
    }
        self.syncScormIfNeeded = function(scorm, siteId) {
        return self.isSyncNeeded(scorm.id, siteId).then(function(needed) {
            if (needed) {
                return self.syncScorm(scorm, siteId);
            }
        });
    };
        self.syncScorm = function(scorm, siteId) {
        siteId = siteId || $mmSite.getId();
        var warnings = [],
            initialAttemptsData,
            lastOnline = 0,
            lastOnlineWasFinished = false,
            syncPromise;
        if (self.isSyncing(scorm.id, siteId)) {
            return self.getOngoingSync(scorm.id, siteId);
        }
        if ($mmSyncBlock.isBlocked(mmaModScormComponent, scorm.id, siteId)) {
            $log.debug('Cannot sync SCORM ' + scorm.id + ' because it is blocked.');
            var modulename = $mmCourse.translateModuleName('scorm');
            return $mmLang.translateAndReject('mm.core.errorsyncblocked', {$a: modulename});
        }
        $log.debug('Try to sync SCORM ' + scorm.id + ' in site ' + siteId);
        function finishSync(updated) {
            var promise;
            if (updated) {
                promise = $mmaModScorm.invalidateAllScormData(scorm.id, siteId).catch(function() {}).then(function() {
                    return $mmaModScormPrefetchHandler.downloadWSData(scorm, siteId);
                });
            } else {
                promise = $q.when();
            }
            return promise.then(function() {
                return self.setSyncTime(scorm.id, siteId).catch(function() {
                });
            }).then(function() {
                if (initialAttemptsData) {
                    return $mmaModScorm.getAttemptCount(scorm.id, siteId, undefined, false).then(function(attemptsData) {
                        if (attemptsData.online.length > initialAttemptsData.online.length) {
                            return true;
                        } else if (!lastOnlineWasFinished && lastOnline > 0) {
                            return $mmaModScorm.isAttemptIncomplete(scorm.id, lastOnline, false, false, siteId).then(function(inc) {
                                return !inc;
                            });
                        }
                        return false;
                    });
                }
                return false;
            }).then(function(attemptFinished) {
                return {
                    warnings: warnings,
                    attemptFinished: attemptFinished
                };
            });
        }
        syncPromise = $mmaModScorm.getAttemptCount(scorm.id, siteId, undefined, false, true).then(function(attemptsData) {
            if (!attemptsData.offline || !attemptsData.offline.length) {
                return finishSync();
            }
            initialAttemptsData = attemptsData;
            var collisions = [],
                promise;
            angular.forEach(attemptsData.online, function(attempt) {
                lastOnline = Math.max(lastOnline, attempt);
                if (attemptsData.offline.indexOf(attempt) > -1) {
                    collisions.push(attempt);
                }
            });
            promise = lastOnline > 0 ? $mmaModScorm.isAttemptIncomplete(scorm.id, lastOnline, false, true, siteId) : $q.when(false);
            return promise.then(function(incomplete) {
                lastOnlineWasFinished = !incomplete;
                if (!collisions.length && !incomplete) {
                    var promises = [];
                    angular.forEach(attemptsData.offline, function(attempt) {
                        if (scorm.maxattempt == 0 || attempt <= scorm.maxattempt) {
                            promises.push(self._syncAttempt(scorm.id, attempt, siteId));
                        }
                    });
                    return $q.all(promises).then(function() {
                        return finishSync(true);
                    });
                } else if (collisions.length) {
                    return treatCollisions(scorm.id, siteId, collisions, lastOnline, attemptsData.offline).then(function(warns) {
                        warnings = warnings.concat(warns);
                        return $mmaModScormOffline.getAttempts(siteId, scorm.id).then(function(entries) {
                            var promises = [],
                                cannotSyncSome = false;
                            entries = entries.map(function(entry) {
                                return entry.attempt;
                            });
                            if (incomplete && entries.indexOf(lastOnline) > -1) {
                                incomplete = false;
                            }
                            angular.forEach(entries, function(attempt) {
                                if (!incomplete || attempt <= lastOnline) {
                                    if (scorm.maxattempt == 0 || attempt <= scorm.maxattempt) {
                                        promises.push(self._syncAttempt(scorm.id, attempt, siteId));
                                    }
                                } else {
                                    cannotSyncSome = true;
                                }
                            });
                            return $q.all(promises).then(function() {
                                if (cannotSyncSome) {
                                    warnings.push($translate.instant('mma.mod_scorm.warningsynconlineincomplete'));
                                }
                                return finishSync(true);
                            });
                        });
                    });
                } else {
                    warnings.push($translate.instant('mma.mod_scorm.warningsynconlineincomplete'));
                    return finishSync();
                }
            });
        });
        return self.addOngoingSync(scorm.id, syncPromise, siteId);
    };
        function treatCollisions(scormId, siteId, collisions, lastOnline, offlineAttempts) {
        var warnings = [],
            promises = [],
            newAttemptsSameOrder = [],
            newAttemptsAtEnd = {},
            lastCollision = Math.max.apply(Math, collisions),
            lastOffline = Math.max.apply(Math, offlineAttempts),
            lastOfflineIncomplete,
            lastOfflineCreated;
        function getLastOfflineAttemptData() {
            return $mmaModScorm.isAttemptIncomplete(scormId, lastOffline, true, false, siteId).then(function(incomplete) {
                lastOfflineIncomplete = incomplete;
                return $mmaModScormOffline.getAttemptCreationTime(siteId, scormId, lastOffline).then(function(time) {
                    lastOfflineCreated = time;
                });
            });
        }
        function addToNewOrDelete(attempt) {
            if (attempt == lastOffline) {
                newAttemptsSameOrder.push(attempt);
                return $q.when();
            }
            return $mmaModScormOffline.getAttemptCreationTime(siteId, scormId, attempt).then(function(time) {
                if (time > lastOfflineCreated) {
                    if (lastOfflineIncomplete) {
                        $log.debug('Try to delete attempt ' + attempt + ' because it cannot be created as a new attempt.');
                        return $mmaModScormOffline.deleteAttempt(siteId, scormId, attempt).then(function() {
                            warnings.push($translate.instant('mma.mod_scorm.warningofflinedatadeleted', {number: attempt}));
                        }).catch(function() {
                        });
                    } else {
                        newAttemptsAtEnd[time] = attempt;
                    }
                } else {
                    newAttemptsSameOrder.push(attempt);
                }
            });
        }
        return getLastOfflineAttemptData().then(function() {
            collisions.forEach(function(attempt) {
                var getDataFn = $mmaModScormOffline.getScormStoredData,
                    promise = getDataFn(siteId, scormId, attempt, undefined, false, true).then(function(synced) {
                    if (synced && synced.length) {
                        return getDataFn(siteId, scormId, attempt, undefined, true).then(function(entries) {
                            var hasDataToSend = false;
                            angular.forEach(entries, function(entry) {
                                if (entry.element.indexOf('.') > -1) {
                                    hasDataToSend = true;
                                }
                            });
                            if (hasDataToSend) {
                                return canRetrySync(scormId, siteId, attempt, lastOnline).catch(function() {
                                    return addToNewOrDelete(attempt);
                                });
                            } else {
                                return $mmaModScormOffline.deleteAttempt(siteId, scormId, attempt).catch(function() {
                                });
                            }
                        });
                    } else {
                        return $mmaModScormOffline.getAttemptSnapshot(siteId, scormId, attempt).then(function(snapshot) {
                            if (snapshot && Object.keys(snapshot).length) {
                                var refresh = lastOnline != attempt;
                                return $mmaModScorm.getScormUserData(scormId, attempt, false, siteId, undefined, refresh)
                                            .then(function(data) {
                                    if (!snapshotEquals(snapshot, data)) {
                                        return addToNewOrDelete(attempt);
                                    }
                                });
                            } else {
                                newAttemptsSameOrder.push(attempt);
                            }
                        });
                    }
                });
                promises.push(promise);
            });
            return $q.all(promises).then(function() {
                return moveNewAttempts(scormId, siteId, newAttemptsSameOrder, lastOnline, lastCollision, offlineAttempts).then(function() {
                    lastOffline = lastOffline + newAttemptsSameOrder.length;
                    return createNewAttemptsAtEnd(scormId, siteId, newAttemptsAtEnd, lastOffline).then(function() {
                        return warnings;
                    });
                });
            });
        });
    }
        function moveNewAttempts(scormId, siteId, newAttempts, lastOnline, lastCollision, offlineAttempts) {
        if (!newAttempts.length) {
            return $q.when();
        }
        var promise = $q.when(),
            lastSuccessful;
        offlineAttempts = offlineAttempts.sort(function(a, b) {
            return parseInt(a, 10) < parseInt(b, 10);
        });
        angular.forEach(offlineAttempts, function(attempt) {
            if (attempt > lastCollision) {
                promise = promise.then(function() {
                    var newNumber = attempt + newAttempts.length;
                    return $mmaModScormOffline.changeAttemptNumber(siteId, scormId, attempt, newNumber).then(function() {
                        lastSuccessful = attempt;
                    });
                });
            }
        });
        return promise.then(function() {
            var promises = [],
                successful = [];
            newAttempts = newAttempts.sort(function(a, b) {
                return parseInt(a, 10) > parseInt(b, 10);
            });
            angular.forEach(newAttempts, function(attempt, index) {
                var newNumber = lastOnline + index + 1;
                promises.push($mmaModScormOffline.changeAttemptNumber(siteId, scormId, attempt, newNumber).then(function() {
                    successful.push(attempt);
                }));
            });
            return $q.all(promises).catch(function() {
                promises = [];
                angular.forEach(successful, function(attempt) {
                    var newNumber = lastOnline + newAttempts.indexOf(attempt) + 1;
                    promises.push($mmaModScormOffline.changeAttemptNumber(siteId, scormId, newNumber, attempt));
                });
                return $mmUtil.allPromises(promises).then(function() {
                    return $q.reject();
                });
            });
        }).catch(function() {
            if (!lastSuccessful) {
                return $q.reject();
            }
            promise = $q.when();
            var attemptsToUndo = [];
            for (var i = lastSuccessful; offlineAttempts.indexOf(i) != -1; i++) {
                attemptsToUndo.push(i);
            }
            attemptsToUndo.forEach(function(attempt) {
                promise = promise.then(function() {
                    return $mmaModScormOffline.changeAttemptNumber(siteId, scormId, attempt + newAttempts.length, attempt);
                });
            });
            return promise.then(function() {
                return $q.reject();
            });
        });
    }
        function createNewAttemptsAtEnd(scormId, siteId, newAttempts, lastOffline) {
        var times = Object.keys(newAttempts).sort(),
            promises = [];
        if (!times.length) {
            return $q.when();
        }
        angular.forEach(times, function(time, index) {
            var attempt = newAttempts[time];
            promises.push($mmaModScormOffline.changeAttemptNumber(siteId, scormId, attempt, lastOffline + index + 1));
        });
        return $mmUtil.allPromises(promises);
    }
        function canRetrySync(scormId, siteId, attempt, lastOnline) {
        var refresh = lastOnline != attempt;
        return $mmaModScorm.getScormUserData(scormId, attempt, false, siteId, undefined, refresh).then(function(siteData) {
            return $mmaModScormOffline.getAttemptSnapshot(siteId, scormId, attempt).then(function(snapshot) {
                if (!snapshot || !Object.keys(snapshot).length || !snapshotEquals(snapshot, siteData)) {
                    return $q.reject();
                }
            });
        });
    }
        function snapshotEquals(snapshot, userData) {
        var scoId,
            element,
            siteSco,
            snapshotSco;
        for (scoId in userData) {
            siteSco = userData[scoId];
            snapshotSco = snapshot[scoId];
            for (element in siteSco.userdata) {
                if (element.indexOf('.') > -1) {
                    if (!snapshotSco || siteSco.userdata[element] !== snapshotSco.userdata[element]) {
                        return false;
                    }
                }
            }
        }
        for (scoId in snapshot) {
            siteSco = userData[scoId];
            snapshotSco = snapshot[scoId];
            for (element in snapshotSco.userdata) {
                if (element.indexOf('.') > -1) {
                    if (!siteSco || siteSco.userdata[element] !== snapshotSco.userdata[element]) {
                        return false;
                    }
                }
            }
        }
        return true;
    }
    return self;
}]);

angular.module('mm.addons.mod_survey')
.controller('mmaModSurveyIndexCtrl', ["$scope", "$stateParams", "$mmaModSurvey", "$mmUtil", "$q", "$mmCourse", "$translate", "$mmText", "$ionicPlatform", "$ionicScrollDelegate", "$mmaModSurveyOffline", "mmaModSurveyComponent", "$mmaModSurveySync", "$mmSite", "$mmEvents", "mmaModSurveyAutomSyncedEvent", "$mmApp", "$mmCourseHelper", "mmCoreEventOnlineStatusChanged", function($scope, $stateParams, $mmaModSurvey, $mmUtil, $q, $mmCourse, $translate, $mmText,
            $ionicPlatform, $ionicScrollDelegate, $mmaModSurveyOffline, mmaModSurveyComponent, $mmaModSurveySync, $mmSite,
            $mmEvents, mmaModSurveyAutomSyncedEvent, $mmApp, $mmCourseHelper, mmCoreEventOnlineStatusChanged) {
    var module = $stateParams.module || {},
        courseid = $stateParams.courseid,
        survey,
        userId = $mmSite.getUserId(),
        scrollView,
        syncObserver, onlineObserver;
    $scope.title = module.name;
    $scope.description = module.description;
    $scope.moduleUrl = module.url;
    $scope.moduleName = $mmCourse.translateModuleName('survey');
    $scope.componentId = module.id;
    $scope.courseid = courseid;
    $scope.answers = {};
    $scope.isTablet = $ionicPlatform.isTablet();
    $scope.refreshIcon = 'spinner';
    $scope.syncIcon = 'spinner';
    $scope.component = mmaModSurveyComponent;
    function fetchSurveyData(refresh, sync, showErrors) {
        $scope.isOnline = $mmApp.isOnline();
        return $mmaModSurvey.getSurvey(courseid, module.id).then(function(surveydata) {
            survey = surveydata;
            $scope.title = survey.name || $scope.title;
            $scope.description = survey.intro || $scope.description;
            $scope.survey = survey;
            if (sync) {
                return syncSurvey(showErrors).then(function(answersSent) {
                    if (answersSent) {
                        return $mmaModSurvey.getSurvey(courseid, module.id).then(function(surveyData) {
                            survey = surveyData;
                            $scope.survey = survey;
                        });
                    }
                }).catch(function() {
                });
            }
        }).then(function() {
            return $mmaModSurveyOffline.hasAnswers(survey.id);
        }).then(function(hasOffline) {
            if (survey.surveydone) {
                $scope.hasOffline = false;
            } else {
                $scope.hasOffline = hasOffline;
            }
            if (!survey.surveydone && !hasOffline) {
                return fetchQuestions();
            }
        }).then(function() {
            $mmCourseHelper.fillContextMenu($scope, module, courseid, refresh, mmaModSurveyComponent);
        }).catch(function(message) {
            if (!refresh) {
                return refreshAllData(sync);
            }
            if (message) {
                $mmUtil.showErrorModal(message);
            } else {
                $mmUtil.showErrorModal('mma.mod_survey.errorgetsurvey', true);
            }
            return $q.reject();
        });
    }
    function fetchQuestions() {
        return $mmaModSurvey.getQuestions(survey.id).then(function(questions) {
            return $mmaModSurvey.formatQuestions(questions).then(function(formatted) {
                $scope.questions = formatted;
                angular.forEach(formatted, function(q) {
                    if (q.name) {
                        var isTextArea = q.multi && q.multi.length === 0 && q.type === 0;
                        $scope.answers[q.name] = q.required ? -1 : (isTextArea ? '' : '0');
                    }
                });
            });
        });
    }
    function refreshAllData(sync, showErrors) {
        var p1 = $mmaModSurvey.invalidateSurveyData(courseid),
            p2 = survey ? $mmaModSurvey.invalidateQuestions(survey.id) : $q.when();
        return $q.all([p1, p2]).finally(function() {
            return fetchSurveyData(true, sync, showErrors);
        });
    }
    fetchSurveyData(false, true).then(function() {
        $mmaModSurvey.logView(survey.id).then(function() {
            $mmCourse.checkModuleCompletion(courseid, module.completionstatus);
        });
    }).finally(function() {
        $scope.surveyLoaded = true;
        $scope.refreshIcon = 'ion-refresh';
        $scope.syncIcon = 'ion-loop';
    });
    $scope.isValidResponse = function() {
        var valid = true;
        angular.forEach($scope.answers, function(a) {
            if (a === -1) {
                valid = false;
            }
        });
        return valid;
    };
    $scope.submit = function() {
        $mmUtil.showConfirm($translate('mm.core.areyousure')).then(function() {
            var answers = [],
                modal = $mmUtil.showModalLoading('mm.core.sending', true);
            angular.forEach($scope.answers, function(value, key) {
                answers.push({
                    key: key,
                    value: value
                });
            });
            $mmaModSurvey.submitAnswers(survey.id, survey.name, courseid, answers).then(function() {
                scrollTop();
                return refreshAllData(false);
            }).catch(function(message) {
                if (message) {
                    $mmUtil.showErrorModal(message);
                } else {
                    $mmUtil.showErrorModal('mma.mod_survey.cannotsubmitsurvey', true);
                }
            }).finally(function() {
                modal.dismiss();
            });
        });
    };
    $scope.removeFiles = function() {
        $mmCourseHelper.confirmAndRemove(module, courseid);
    };
    $scope.prefetch = function() {
        $mmCourseHelper.contextMenuPrefetch($scope, module, courseid);
    };
    $scope.expandDescription = function() {
        $mmText.expandText($translate.instant('mm.core.description'), $scope.description, false, mmaModSurveyComponent, module.id);
    };
    $scope.refreshSurvey = function(showErrors) {
        if ($scope.surveyLoaded) {
            $scope.refreshIcon = 'spinner';
            $scope.syncIcon = 'spinner';
            return refreshAllData(true, showErrors).finally(function() {
                $scope.refreshIcon = 'ion-refresh';
                $scope.syncIcon = 'ion-loop';
                $scope.$broadcast('scroll.refreshComplete');
            });
        }
    };
    function scrollTop() {
        if (!scrollView) {
            scrollView = $ionicScrollDelegate.$getByHandle('mmaModSurveyScroll');
        }
        scrollView && scrollView.scrollTop && scrollView.scrollTop();
    }
    function syncSurvey(showErrors) {
        return $mmaModSurveySync.syncSurvey(survey.id, userId).then(function(result) {
            if (result.warnings && result.warnings.length) {
                $mmUtil.showErrorModal(result.warnings[0]);
            }
            return result.answersSent;
        }).catch(function(error) {
            if (showErrors) {
                if (error) {
                    $mmUtil.showErrorModal(error);
                } else {
                    $mmUtil.showErrorModal('mm.core.errorsync', true);
                }
            }
            return $q.reject();
        });
    }
    onlineObserver = $mmEvents.on(mmCoreEventOnlineStatusChanged, function(online) {
        $scope.isOnline = online;
    });
    syncObserver = $mmEvents.on(mmaModSurveyAutomSyncedEvent, function(data) {
        if (survey && data && data.siteid == $mmSite.getId() && data.surveyid == survey.id && data.userid == userId) {
            $scope.surveyLoaded = false;
            $scope.refreshIcon = 'spinner';
            $scope.syncIcon = 'spinner';
            scrollTop();
            refreshAllData(false).finally(function() {
                $scope.surveyLoaded = true;
                $scope.refreshIcon = 'ion-refresh';
                $scope.syncIcon = 'ion-loop';
            });
        }
    });
    $scope.$on('$destroy', function() {
        syncObserver && syncObserver.off && syncObserver.off();
        onlineObserver && onlineObserver.off && onlineObserver.off();
    });
}]);

angular.module('mm.addons.mod_survey')
.factory('$mmaModSurveyHandlers', ["$mmCourse", "$mmaModSurvey", "$state", "$mmContentLinksHelper", "$mmUtil", "$mmEvents", "$mmSite", "$mmaModSurveyPrefetchHandler", "$mmCoursePrefetchDelegate", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreOutdated", "mmaModSurveyComponent", "mmCoreEventPackageStatusChanged", "$mmaModSurveySync", function($mmCourse, $mmaModSurvey, $state, $mmContentLinksHelper, $mmUtil, $mmEvents, $mmSite,
            $mmaModSurveyPrefetchHandler, $mmCoursePrefetchDelegate, mmCoreDownloading, mmCoreNotDownloaded, mmCoreOutdated,
            mmaModSurveyComponent, mmCoreEventPackageStatusChanged, $mmaModSurveySync) {
    var self = {};
        self.courseContent = function() {
        var self = {};
                self.isEnabled = function() {
            return $mmaModSurvey.isPluginEnabled();
        };
                self.getController = function(module, courseId) {
            return function($scope) {
                var downloadBtn = {
                        hidden: true,
                        icon: 'ion-ios-cloud-download-outline',
                        label: 'mm.core.download',
                        action: function(e) {
                            if (e) {
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            download();
                        }
                    },
                    refreshBtn = {
                        hidden: true,
                        icon: 'ion-android-refresh',
                        label: 'mm.core.refresh',
                        action: function(e) {
                            if (e) {
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            $mmaModSurvey.invalidateContent(module.id, courseId).finally(function() {
                                download();
                            });
                        }
                    };
                $scope.title = module.name;
                $scope.icon = $mmCourse.getModuleIconSrc('survey');
                $scope.class = 'mma-mod_survey-handler';
                $scope.buttons = [downloadBtn, refreshBtn];
                $scope.spinner = true;
                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_survey', {module: module, courseid: courseId});
                };
                function download() {
                    $scope.spinner = true;
                    $mmaModSurveyPrefetchHandler.getDownloadSize(module, courseId).then(function(size) {
                        $mmUtil.confirmDownloadSize(size).then(function() {
                            $mmaModSurveyPrefetchHandler.prefetch(module, courseId).catch(function() {
                                if (!$scope.$$destroyed) {
                                    $mmUtil.showErrorModal('mm.core.errordownloading', true);
                                }
                            });
                        }).catch(function() {
                            $scope.spinner = false;
                        });
                    }).catch(function(error) {
                        $scope.spinner = false;
                        if (error) {
                            $mmUtil.showErrorModal(error);
                        } else {
                            $mmUtil.showErrorModal('mm.core.errordownloading', true);
                        }
                    });
                }
                function showStatus(status) {
                    if (status) {
                        $scope.spinner = status === mmCoreDownloading;
                        downloadBtn.hidden = status !== mmCoreNotDownloaded;
                        refreshBtn.hidden = status !== mmCoreOutdated;
                    }
                }
                var statusObserver = $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
                    if (data.siteid === $mmSite.getId() && data.componentId === module.id &&
                            data.component === mmaModSurveyComponent) {
                        showStatus(data.status);
                    }
                });
                $mmCoursePrefetchDelegate.getModuleStatus(module, courseId).then(showStatus);
                $scope.$on('$destroy', function() {
                    statusObserver && statusObserver.off && statusObserver.off();
                });
            };
        };
        return self;
    };
        self.linksHandler = $mmContentLinksHelper.createModuleIndexLinkHandler('mmaModSurvey', 'survey', $mmaModSurvey);
        self.syncHandler = function() {
        var self = {};
                self.execute = function(siteId) {
            return $mmaModSurveySync.syncAllSurveys(siteId);
        };
                self.getInterval = function() {
            return 600000;
        };
                self.isSync = function() {
            return true;
        };
                self.usesNetwork = function() {
            return true;
        };
        return self;
    };
    return self;
}]);

angular.module('mm.addons.mod_survey')
.factory('$mmaModSurveyPrefetchHandler', ["$mmaModSurvey", "mmaModSurveyComponent", "$mmFilepool", "$mmSite", "$q", "$mmUtil", "md5", "$mmPrefetchFactory", function($mmaModSurvey, mmaModSurveyComponent, $mmFilepool, $mmSite, $q, $mmUtil, md5,
            $mmPrefetchFactory) {
    var self = $mmPrefetchFactory.createPrefetchHandler(mmaModSurveyComponent);
    self.updatesNames = /^configuration$|^.*files$|^answers$/;
        self.download = function(module, courseId) {
        return self.prefetch(module, courseId);
    };
        self.getFiles = function(module, courseId) {
        return self.getIntroFiles(module, courseId);
    };
        self.getIntroFiles = function(module, courseId) {
        return $mmaModSurvey.getSurvey(courseId, module.id).catch(function() {
        }).then(function(survey) {
            return self.getIntroFilesFromInstance(module, survey);
        });
    };
        self.getRevision = function(module, courseId) {
        return $mmaModSurvey.getSurvey(courseId, module.id).then(function(survey) {
            return getRevisionFromSurvey(module.id, survey);
        });
    };
        function getRevisionFromSurvey(moduleId, survey) {
        var promise,
            siteId = $mmSite.getId();
        if (survey.surveydone) {
            promise = $mmFilepool.getPackageRevision(siteId, mmaModSurveyComponent, moduleId).then(function(revision) {
                revision = '' + revision;
                return revision.split('#')[0];
            }).catch(function() {
                return md5.createHash(survey.questions);
            });
        } else {
            promise = $q.when(md5.createHash(survey.questions));
        }
        return promise.then(function(revision) {
            if (typeof survey.introfiles == 'undefined' && survey.intro) {
                var urls = $mmUtil.extractDownloadableFilesFromHtml(survey.intro);
                urls = urls.sort(function (a, b) {
                    return a > b;
                });
                return revision + '#' + md5.createHash(JSON.stringify(urls));
            }
            return revision;
        });
    }
        self.getTimemodified = function(module, courseId) {
        return self.getFiles(module, courseId).then(function(files) {
            return $mmFilepool.getTimemodifiedFromFileList(files);
        });
    };
        self.invalidateContent = function(moduleId, courseId) {
        return $mmaModSurvey.invalidateContent(moduleId, courseId);
    };
        self.invalidateModule = function(module, courseId) {
        return $mmaModSurvey.invalidateSurveyData(courseId);
    };
        self.isEnabled = function() {
        return $mmaModSurvey.isPluginEnabled();
    };
        self.prefetch = function(module, courseId, single) {
        return self.prefetchPackage(module, courseId, single, prefetchSurvey);
    };
        function prefetchSurvey(module, courseId, single, siteId) {
        var revision,
            timemod;
        return $mmaModSurvey.getSurvey(courseId, module.id).then(function(survey) {
            var promises = [],
                files = self.getIntroFilesFromInstance(module, survey);
            timemod = $mmFilepool.getTimemodifiedFromFileList(files);
            angular.forEach(files, function(file) {
                promises.push($mmFilepool.addToQueueByUrl(siteId, file.fileurl, component, module.id, file.timemodified));
            });
            if (!survey.surveydone) {
                promises.push($mmaModSurvey.getQuestions(survey.id));
            }
            promises.push(getRevisionFromSurvey(module.id, survey).then(function(rev) {
                revision = rev;
            }));
            return $q.all(promises);
        }).then(function() {
            return {
                revision: revision,
                timemod: timemod
            };
        });
    }
        self.removeFiles = function(module, courseId) {
        return $mmFilepool.removeFilesByComponent($mmSite.getId(), self.component, module.id);
    };
    return self;
}]);

angular.module('mm.addons.mod_survey')
.factory('$mmaModSurvey', ["$q", "$mmSite", "$translate", "$mmSitesManager", "$mmFilepool", "$mmApp", "$mmaModSurveyOffline", "$mmUtil", "mmaModSurveyComponent", function($q, $mmSite, $translate, $mmSitesManager, $mmFilepool, $mmApp, $mmaModSurveyOffline, $mmUtil,
            mmaModSurveyComponent) {
    var self = {};
        function commaStringToArray(value) {
        if (typeof value == 'string') {
            if (value !== '') {
                return value.split(',');
            } else {
                return [];
            }
        } else {
            return value;
        }
    }
        self.formatQuestions = function(questions) {
        var stringkeys = [
            'mma.mod_survey.ipreferthat',
            'mma.mod_survey.ifoundthat',
            'mm.core.choose'
        ];
        return $translate(stringkeys).then(function(translates) {
            var stripreferthat = translates[stringkeys[0]],
                strifoundthat = translates[stringkeys[1]],
                strchoose = translates[stringkeys[2]],
                formatted = [],
                parents = self.getParentQuestions(questions),
                num = 1;
            questions = angular.copy(questions);
            angular.forEach(questions, function(question) {
                var parent = parents[question.parent];
                question.multi = commaStringToArray(question.multi);
                question.options = commaStringToArray(question.options);
                if (parent) {
                    question.required = true;
                    if (parent.type === 1 || parent.type === 2) {
                        question.name = 'q' + (parent.type == 2 ? 'P' : '') + question.id;
                        question.num = num++;
                    } else {
                        var q2 = angular.copy(question);
                        question.text = stripreferthat + ' ' + question.text;
                        question.name = 'qP' + question.id;
                        question.num = num++;
                        formatted.push(question);
                        q2.text = strifoundthat + ' ' + q2.text;
                        q2.name = 'q' + question.id;
                        q2.num = num++;
                        formatted.push(q2);
                        return;
                    }
                } else if (question.multi && question.multi.length === 0) {
                    question.name = 'q' + question.id;
                    question.num = num++;
                    if (question.type > 0) {
                        question.options.unshift(strchoose);
                    }
                }
                formatted.push(question);
            });
            return formatted;
        });
    };
        self.getParentQuestions = function(questions) {
        var parents = {};
        angular.forEach(questions, function(question) {
            if (question.parent === 0) {
                parents[question.id] = question;
            }
        });
        return parents;
    };
        self.getQuestions = function(id) {
        var params = {
                surveyid: id
            },
            preSets = {
                cacheKey: getQuestionsCacheKey(id)
            };
        return $mmSite.read('mod_survey_get_questions', params, preSets).then(function(response) {
            if (response.questions) {
                return response.questions;
            }
            return $q.reject();
        });
    };
        function getQuestionsCacheKey(id) {
        return 'mmaModSurvey:questions:' + id;
    }
        function getSurvey(siteId, courseId, key, value) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    courseids: [courseId]
                },
                preSets = {
                    cacheKey: getSurveyDataCacheKey(courseId)
                };
            return site.read('mod_survey_get_surveys_by_courses', params, preSets).then(function(response) {
                if (response && response.surveys) {
                    var currentSurvey;
                    angular.forEach(response.surveys, function(survey) {
                        if (!currentSurvey && survey[key] == value) {
                            currentSurvey = survey;
                        }
                    });
                    if (currentSurvey) {
                        return currentSurvey;
                    }
                }
                return $q.reject();
            });
        });
    }
        self.getSurvey = function(courseId, cmId, siteId) {
        siteId = siteId || $mmSite.getId();
        return getSurvey(siteId, courseId, 'coursemodule', cmId);
    };
        self.getSurveyById = function(courseId, id, siteId) {
        siteId = siteId || $mmSite.getId();
        return getSurvey(siteId, courseId, 'id', id);
    };
        function getSurveyDataCacheKey(courseid) {
        return 'mmaModSurvey:survey:' + courseid;
    }
        self.invalidateContent = function(moduleId, courseId) {
        var promises = [],
            siteId = $mmSite.getId();
        promises.push(self.getSurvey(courseId, moduleId).then(function(survey) {
            var ps = [];
            ps.push(self.invalidateSurveyData(courseId));
            ps.push(self.invalidateQuestions(survey.id));
            return $q.all(ps);
        }));
        promises.push($mmFilepool.invalidateFilesByComponent(siteId, mmaModSurveyComponent, moduleId));
        return $q.all(promises);
    };
        self.invalidateQuestions = function(id) {
        return $mmSite.invalidateWsCacheForKey(getQuestionsCacheKey(id));
    };
        self.invalidateSurveyData = function(courseid) {
        return $mmSite.invalidateWsCacheForKey(getSurveyDataCacheKey(courseid));
    };
        self.isPluginEnabled = function(siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return  site.wsAvailable('mod_survey_get_questions') &&
                    site.wsAvailable('mod_survey_get_surveys_by_courses') &&
                    site.wsAvailable('mod_survey_submit_answers');
        });
    };
        self.logView = function(id) {
        if (id) {
            var params = {
                surveyid: id
            };
            return $mmSite.write('mod_survey_view_survey', params);
        }
        return $q.reject();
    };
        self.submitAnswers = function(surveyId, name, courseId, answers, siteId) {
        siteId = siteId || $mmSite.getId();
        if (!$mmApp.isOnline()) {
            return storeOffline();
        }
        return $mmaModSurveyOffline.deleteSurveyAnswers(surveyId, siteId).then(function() {
            return self.submitAnswersOnline(surveyId, answers, siteId).then(function() {
                return true;
            }).catch(function(error) {
                if (error && error.wserror) {
                    return $q.reject(error.error);
                } else {
                    return storeOffline();
                }
            });
        });
        function storeOffline() {
            return $mmaModSurveyOffline.saveAnswers(surveyId, name, courseId, answers, siteId).then(function() {
                return false;
            });
        }
    };
        self.submitAnswersOnline = function(surveyId, answers, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                surveyid: surveyId,
                answers: answers
            };
            return site.write('mod_survey_submit_answers', params).catch(function(error) {
                return $q.reject({
                    error: error,
                    wserror: $mmUtil.isWebServiceError(error)
                });
            }).then(function(response) {
                if (!response.status) {
                    return $q.reject({
                        wserror: true
                    });
                }
            });
        });
    };
    return self;
}]);

angular.module('mm.addons.mod_survey')
.constant('mmaModSurveyAnswersStore', 'mma_mod_survey_answers')
.config(["$mmSitesFactoryProvider", "mmaModSurveyAnswersStore", function($mmSitesFactoryProvider, mmaModSurveyAnswersStore) {
    var stores = [
        {
            name: mmaModSurveyAnswersStore,
            keyPath: ['surveyid', 'userid'],
            indexes: [
                {
                    name: 'surveyid'
                },
                {
                    name: 'courseid'
                },
                {
                    name: 'userid'
                },
                {
                    name: 'timecreated'
                }
            ]
        }
    ];
    $mmSitesFactoryProvider.registerStores(stores);
}])
.factory('$mmaModSurveyOffline', ["$mmSitesManager", "$log", "$mmSite", "mmaModSurveyAnswersStore", function($mmSitesManager, $log, $mmSite, mmaModSurveyAnswersStore) {
    $log = $log.getInstance('$mmaModSurveyOffline');
    var self = {};
        self.deleteSurveyAnswers = function(surveyId, siteId, userId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            return site.getDb().remove(mmaModSurveyAnswersStore, [surveyId, userId]);
        });
    };
        self.getAllData = function(siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.getDb().getAll(mmaModSurveyAnswersStore);
        });
    };
        self.getSurveyData = function(surveyId, siteId, userId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            return site.getDb().get(mmaModSurveyAnswersStore, [surveyId, userId]);
        });
    };
        self.getSurveyAnswers = function(surveyId, siteId, userId) {
        return self.getSurveyData(surveyId, siteId, userId).then(function(entry) {
            return entry.answers || [];
        }).catch(function() {
            return [];
        });
    };
        self.hasAnswers = function(surveyId, siteId, userId) {
        return self.getSurveyAnswers(surveyId, siteId, userId).then(function(answers) {
            return !!answers.length;
        });
    };
        self.saveAnswers = function(surveyId, name, courseId, answers, siteId, userId) {
        siteId = siteId || $mmSite.getId();
        return $mmSitesManager.getSite(siteId).then(function(site) {
            userId = userId || site.getUserId();
            var entry = {
                    surveyid: surveyId,
                    name: name,
                    courseid: courseId,
                    userid: userId,
                    answers: answers,
                    timecreated: new Date().getTime()
                };
            return site.getDb().insert(mmaModSurveyAnswersStore, entry);
        });
    };
    return self;
}]);

angular.module('mm.addons.mod_survey')
.factory('$mmaModSurveySync', ["$log", "$mmSite", "$q", "$mmApp", "$translate", "$mmaModSurvey", "$mmSitesManager", "$mmCourse", "$mmSync", "$mmaModSurveyOffline", "$mmEvents", "mmaModSurveyAutomSyncedEvent", "mmaModSurveyComponent", "mmaModSurveySyncTime", function($log, $mmSite, $q, $mmApp, $translate, $mmaModSurvey, $mmSitesManager, $mmCourse, $mmSync,
            $mmaModSurveyOffline, $mmEvents, mmaModSurveyAutomSyncedEvent, mmaModSurveyComponent, mmaModSurveySyncTime) {
    $log = $log.getInstance('$mmaModSurveySync');
    var self = $mmSync.createChild(mmaModSurveyComponent, mmaModSurveySyncTime);
        self._getSyncId = function(surveyId, userId) {
        return surveyId + '#' + userId;
    };
        self.isSyncingSurvey = function(surveyId, userId, siteId) {
        var syncId = self._getSyncId(surveyId, userId);
        return self.isSyncing(syncId, siteId);
    };
        self.syncAllSurveys = function(siteId) {
        if (!$mmApp.isOnline()) {
            $log.debug('Cannot sync all surveys because device is offline.');
            return $q.reject();
        }
        var promise;
        if (!siteId) {
            $log.debug('Try to sync surveys in all sites.');
            promise = $mmSitesManager.getSitesIds();
        } else {
            $log.debug('Try to sync surveys in site ' + siteId);
            promise = $q.when([siteId]);
        }
        return promise.then(function(siteIds) {
            var sitePromises = [];
            angular.forEach(siteIds, function(siteId) {
                sitePromises.push($mmaModSurveyOffline.getAllData(siteId).then(function(entries) {
                    var promises = [];
                    angular.forEach(entries, function(entry) {
                        promises.push(self.syncSurvey(entry.surveyid, entry.userid, siteId).then(function(result) {
                            if (result && result.answersSent) {
                                $mmEvents.trigger(mmaModSurveyAutomSyncedEvent, {
                                    siteid: siteId,
                                    surveyid: entry.surveyid,
                                    userid: entry.userid,
                                    warnings: result.warnings
                                });
                            }
                        }));
                    });
                    return $q.all(promises);
                }));
            });
            return $q.all(sitePromises);
        });
    };
        self.syncSurveyIfNeeded = function(surveyId, userId, siteId) {
        siteId = siteId || $mmSite.getId();
        var syncId = self._getSyncId(surveyId, userId);
        return self.isSyncNeeded(syncId, siteId).then(function(needed) {
            if (needed) {
                return self.syncSurvey(surveyId, userId, siteId);
            }
        });
    };
        self.syncSurvey = function(surveyId, userId, siteId) {
        siteId = siteId || $mmSite.getId();
        var syncPromise,
            result = {
                warnings: [],
                answersSent: false
            },
            syncId = self._getSyncId(surveyId, userId),
            courseId;
        if (self.isSyncing(syncId, siteId)) {
            return self.getOngoingSync(syncId, siteId);
        }
        $log.debug('Try to sync survey ' + surveyId + ' for user ' + userId);
        syncPromise = $mmaModSurveyOffline.getSurveyData(surveyId, siteId, userId).catch(function() {
            return {};
        }).then(function(data) {
            if (!data.answers || !data.answers.length) {
                return;
            } else if (!$mmApp.isOnline()) {
                return $q.reject();
            }
            courseId = data.courseid;
            return $mmaModSurvey.submitAnswersOnline(surveyId, data.answers, siteId).then(function() {
                result.answersSent = true;
                return $mmaModSurveyOffline.deleteSurveyAnswers(surveyId, siteId, userId);
            }, function(error) {
                if (error && error.wserror) {
                    result.answersSent = true;
                    return $mmaModSurveyOffline.deleteSurveyAnswers(surveyId, siteId, userId).then(function() {
                        result.warnings.push($translate.instant('mm.core.warningofflinedatadeleted', {
                            component: $mmCourse.translateModuleName('survey'),
                            name: data.name,
                            error: error.error
                        }));
                    });
                } else {
                    return $q.reject(error && error.error);
                }
            });
        }).then(function() {
            if (courseId) {
                return $mmaModSurvey.invalidateSurveyData(courseId).then(function() {
                    return $mmaModSurvey.getSurveyById(courseId, surveyId, siteId);
                }).catch(function() {
                });
            }
        }).then(function() {
            return self.setSyncTime(syncId, siteId).catch(function() {
            });
        }).then(function() {
            return result;
        });
        return self.addOngoingSync(syncId, syncPromise, siteId);
    };
        self.waitForSurveySync = function(surveyId, userId, siteId) {
        var syncId = self._getSyncId(surveyId, userId);
        return self.waitForSync(syncId, siteId);
    };
    return self;
}]);

angular.module('mm.addons.mod_url')
.controller('mmaModUrlIndexCtrl', ["$scope", "$stateParams", "$mmaModUrl", "$mmCourse", "$mmText", "$translate", "$q", "$mmUtil", "mmaModUrlComponent", function($scope, $stateParams, $mmaModUrl, $mmCourse, $mmText, $translate, $q, $mmUtil,
            mmaModUrlComponent) {
    var module = $stateParams.module || {},
        courseId = $stateParams.courseid;
    $scope.title = module.name;
    $scope.moduleUrl = module.url;
    $scope.component = mmaModUrlComponent;
    $scope.componentId = module.id;
    function fetchContent() {
        return $mmCourse.getModule(module.id, courseId).then(function(mod) {
            if (!mod.contents.length) {
                return $q.reject();
            }
            module = mod;
            $scope.title = module.name;
            $scope.description = module.description;
            $scope.url = (module.contents[0] && module.contents[0].fileurl) ? module.contents[0].fileurl : undefined;
        }).catch(function(error) {
            $mmUtil.showErrorModalDefault(error, 'mm.course.errorgetmodule', true);
            return $q.reject();
        }).finally(function() {
            $scope.loaded = true;
            $scope.refreshIcon = 'ion-refresh';
        });
    }
    fetchContent();
    $scope.go = function() {
        $mmaModUrl.logView(module.instance).then(function() {
            $mmCourse.checkModuleCompletion(courseId, module.completionstatus);
        });
        $mmaModUrl.open($scope.url);
    };
    $scope.doRefresh = function() {
        if ($scope.loaded) {
            $scope.refreshIcon = 'spinner';
            return $mmCourse.invalidateModule(module.id).then(function() {
                return fetchContent();
            }).finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        }
    };
    $scope.expandDescription = function() {
        $mmText.expandText($translate.instant('mm.core.description'), $scope.description, false, mmaModUrlComponent, module.id);
    };
}]);

angular.module('mm.addons.mod_url')
.factory('$mmaModUrlHandlers', ["$mmCourse", "$mmaModUrl", "$state", "$mmContentLinksHelper", function($mmCourse, $mmaModUrl, $state, $mmContentLinksHelper) {
    var self = {};
        self.courseContentHandler = function() {
        var self = {};
                self.isEnabled = function() {
            return true;
        };
                self.getController = function(module, courseId) {
            return function($scope) {
                $scope.icon = $mmCourse.getModuleIconSrc('url');
                $scope.title = module.name;
                $scope.class = 'mma-mod_url-handler';
                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_url', {module: module, courseid: courseId});
                };
                $scope.spinner = true;
                $mmCourse.loadModuleContents(module, courseId).then(function() {
                    if (module.contents && module.contents[0] && module.contents[0].fileurl) {
                        $scope.buttons = [{
                            icon: 'ion-link',
                            label: 'mm.core.openinbrowser',
                            action: function(e) {
                                if (e) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                }
                                $mmaModUrl.logView(module.instance).then(function() {
                                    $mmCourse.checkModuleCompletion(courseId, module.completionstatus);
                                });
                                $mmaModUrl.open(module.contents[0].fileurl);
                            }
                        }];
                    }
                }).finally(function() {
                    $scope.spinner = false;
                });
            };
        };
        return self;
    };
        self.linksHandler = $mmContentLinksHelper.createModuleIndexLinkHandler('mmaModUrl', 'url', $mmaModUrl);
    return self;
}]);

angular.module('mm.addons.mod_url')
.factory('$mmaModUrl', ["$mmSite", "$mmUtil", "$q", "$mmContentLinksHelper", function($mmSite, $mmUtil, $q, $mmContentLinksHelper) {
    var self = {};
        self.logView = function(id) {
        if (id) {
            var params = {
                urlid: id
            };
            return $mmSite.write('mod_url_view_url', params);
        }
        return $q.reject();
    };
        self.open = function(url) {
        var modal = $mmUtil.showModalLoading();
        $mmContentLinksHelper.handleLink(url).then(function(treated) {
            if (!treated) {
                return $mmSite.openInBrowserWithAutoLoginIfSameSite(url);
            }
        }).finally(function() {
            modal.dismiss();
        });
    };
    return self;
}]);

angular.module('mm.addons.mod_wiki')
.controller('mmaModWikiEditCtrl', ["$q", "$scope", "$stateParams", "$mmUtil", "$state", "$mmaModWiki", "$translate", "$ionicHistory", "$mmCourse", "mmaModWikiRenewLockTimeout", "$interval", "$mmText", "$mmaModWikiOffline", "$mmEvents", "$mmLang", "$mmSite", "mmaModWikiComponent", "mmaModWikiPageCreatedEvent", "$mmaModWikiSync", "$mmSyncBlock", function($q, $scope, $stateParams, $mmUtil, $state, $mmaModWiki, $translate, $ionicHistory,
        $mmCourse, mmaModWikiRenewLockTimeout, $interval, $mmText, $mmaModWikiOffline, $mmEvents, $mmLang, $mmSite,
        mmaModWikiComponent, mmaModWikiPageCreatedEvent, $mmaModWikiSync, $mmSyncBlock) {
    var module = $stateParams.module || {},
        courseId = $stateParams.courseid,
        subwikiId = $stateParams.subwikiid || null,
        wikiId = $stateParams.wikiid || null,
        pageId = $stateParams.pageid || null,
        section = $stateParams.section || null,
        originalContent = null,
        editing = false,
        version = false,
        groupId = $stateParams.groupid || null,
        userId = $stateParams.userid || null,
        rteEnabled,
        subwikiFiles,
        renewLockInterval,
        editOffline = false,
        blockId = $mmaModWikiSync.subwikiBlockId(subwikiId, wikiId, userId, groupId);
    $mmUtil.blockLeaveView($scope, cancel);
    $scope.saveAndGoParams = false;
    $scope.component = mmaModWikiComponent;
    $scope.componentId = module.id;
    $scope.page = {
        title: $stateParams.pagetitle ? $stateParams.pagetitle.replace(/\+/g, " ") : null,
        text: ""
    };
    $scope.canEditTitle = !$stateParams.pagetitle;
    $scope.title = $scope.page.title ? $translate.instant('mma.mod_wiki.editingpage', {'$a': $scope.page.title}) :
        $translate.instant('mma.mod_wiki.newpagehdr');
    if (blockId) {
        $mmSyncBlock.blockOperation(mmaModWikiComponent, blockId);
    }
    $scope.save = function() {
        var text = $scope.page.text,
            promise,
            modal = $mmUtil.showModalLoading('mm.core.sending', true);
        if (rteEnabled) {
            text = $mmText.restorePluginfileUrls(text, subwikiFiles);
        } else {
            text = $mmText.formatHtmlLines(text);
        }
        if (editing) {
            promise = $mmaModWiki.editPage(pageId, text, section).then(function() {
                return $mmaModWiki.invalidatePage(pageId).then(function() {
                    return gotoPage();
                });
            });
        } else {
            if (!$scope.page.title) {
                return $mmUtil.showModal('mm.core.notice', 'mma.mod_wiki.titleshouldnotbeempty');
            }
            if (!editOffline) {
                promise = $mmaModWikiOffline.getNewPage($scope.page.title, subwikiId, wikiId, userId, groupId).then(function() {
                    return $mmLang.translateAndReject('mma.mod_wiki.pageexists');
                }, function() {
                });
            } else {
                promise = $q.when();
            }
            promise = promise.then(function() {
                var wikiId = wikiId || (module && module.instance);
                return $mmaModWiki.newPage($scope.page.title, text, subwikiId, wikiId, userId, groupId).then(function(createdId) {
                    if (createdId) {
                        pageId = createdId;
                        return $mmaModWiki.getPageContents(pageId).then(function(pageContents) {
                            var promises = [];
                            wikiId = parseInt(pageContents.wikiid, 10);
                            if (!subwikiId) {
                                promises.push($mmaModWiki.invalidateSubwikis(wikiId));
                            }
                            subwikiId = parseInt(pageContents.subwikiid, 10);
                            userId = parseInt(pageContents.userid, 10);
                            groupId = parseInt(pageContents.groupid, 10);
                            promises.push($mmaModWiki.invalidateSubwikiPages(wikiId));
                            return $q.all(promises).then(function() {
                                return gotoPage();
                            });
                        }).finally(function() {
                            $mmEvents.trigger(mmaModWikiPageCreatedEvent, {
                                pageid: pageId,
                                subwikiid: subwikiId,
                                pagetitle: $scope.page.title,
                                siteid: $mmSite.getId()
                            });
                        });
                    } else {
                        return gotoNewOfflinePage();
                    }
                });
            });
        }
        return promise.catch(function(message) {
            $mmUtil.showErrorModalDefault(message, 'Error saving wiki data.');
        }).finally(function() {
            modal.dismiss();
        });
    };
    function cancel() {
        if ((originalContent == $scope.page.text) || (!editing && !$scope.page.text && !$scope.page.title)) {
            return $q.when();
        } else {
            return $mmUtil.showConfirm($translate('mm.core.confirmcanceledit'));
        }
    }
    function gotoPage() {
        return retrieveModuleInfo(wikiId).then(function() {
            var openPage = false;
            if ($stateParams.subwikiid) {
                if (!editing && editOffline && backViewPageIsDifferentOffline()) {
                    openPage = true;
                } else if (!editOffline && backViewIsDifferentPageOnline()) {
                    openPage = true;
                }
            }
            if (openPage) {
                $scope.saveAndGoParams = {
                    module: module,
                    moduleid: module.id,
                    courseid: courseId,
                    pageid: pageId,
                    pagetitle: $scope.page.title,
                    wikiid: wikiId,
                    subwikiid: subwikiId,
                    userid: userId,
                    groupid: groupId
                };
            }
            return $ionicHistory.goBack();
        }).catch(function() {
            return $ionicHistory.goBack();
        });
    }
    function gotoNewOfflinePage() {
        if (courseId && (module.id || wikiId)) {
            if (!editOffline || backViewPageIsDifferentOffline()) {
                $scope.saveAndGoParams = {
                    module: module,
                    moduleid: module.id,
                    courseid: courseId,
                    pageid: null,
                    pagetitle: $scope.page.title,
                    wikiid: wikiId,
                    subwikiid: subwikiId,
                    userid: userId,
                    groupid: groupId
                };
            }
        } else {
            $mmUtil.showModal('mm.core.success', 'mm.core.datastoredoffline');
        }
        return $ionicHistory.goBack();
    }
    function backViewIsDifferentPageOnline() {
        var backView = $ionicHistory.backView();
        return !editing || backView.stateName != 'site.mod_wiki' || backView.stateParams.moduleid != module.id ||
                    backView.stateParams.pageid != pageId;
    }
    function backViewPageIsDifferentOffline() {
        var backView = $ionicHistory.backView(),
            backViewParams = backView.stateParams;
        if (backView.stateName != 'site.mod_wiki' || backViewParams.moduleid != module.id || backViewParams.wikiid != wikiId ||
                backViewParams.pagetitle != $scope.page.title) {
            return true;
        }
        var backSubwikiId = parseInt(backViewParams.subwikiid, 10) || 0;
        if (backSubwikiId > 0 && subwikiId > 0) {
            return backSubwikiId != subwikiId;
        }
        var backUserId = parseInt(backViewParams.userid, 10) || 0,
            backGroupId = parseInt(backViewParams.groupid, 10) || 0;
        return userId != backUserId || groupId != backGroupId;
    }
    function renewLock() {
        $mmaModWiki.getPageForEditing(pageId, section, true).then(function(response) {
            if (response.version && version != response.version) {
                $scope.wrongVersionLock = true;
            }
        });
    }
    function fetchWikiPageData() {
        var promise, canEdit = false;
        if ($mmaModWiki.isPluginEnabledForEditing()) {
            if (pageId) {
                $scope.canEditTitle = false;
                editing = true;
                editOffline = false;
                promise = $mmaModWiki.getPageContents(pageId).then(function(pageContents) {
                    $scope.page.title = pageContents.title;
                    wikiId = pageContents.wikiid;
                    subwikiId = pageContents.subwikiid;
                    $scope.title = $translate.instant('mma.mod_wiki.editingpage', {'$a': $scope.page.title});
                    canEdit = pageContents.caneditpage;
                    groupId = pageContents.groupid;
                    userId = pageContents.userid;
                    return $mmaModWikiSync.waitForSync(blockId);
                }).then(function() {
                    return $mmUtil.isRichTextEditorEnabled();
                }).then(function(enabled) {
                    rteEnabled = enabled;
                    if (enabled) {
                        return $mmaModWiki.getSubwikiFiles(wikiId, groupId, userId);
                    }
                }).then(function(files) {
                    subwikiFiles = files;
                    return $mmaModWiki.getPageForEditing(pageId, section);
                }).then(function(editContents) {
                    if (rteEnabled) {
                        $scope.page.text = $mmText.replacePluginfileUrls(editContents.content, subwikiFiles);
                    } else {
                        $scope.page.text = editContents.content;
                    }
                    originalContent = $scope.page.text;
                    version = editContents.version;
                    if (canEdit) {
                        renewLockInterval = $interval(function() {
                            renewLock();
                        }, mmaModWikiRenewLockTimeout * 1000);
                    }
                }).finally(function() {
                    $scope.wikiLoaded = true;
                });
            } else {
                promise = $mmaModWikiSync.waitForSync(blockId);
                if ($scope.page.title) {
                    promise = promise.then(function() {
                        return $mmaModWikiOffline.getNewPage($scope.page.title, subwikiId, wikiId, userId, groupId);
                    }).then(function(page) {
                        $scope.page.text = page.cachedcontent;
                        originalContent = $scope.page.text;
                        editOffline = true;
                    }).catch(function() {
                        editOffline = false;
                    });
                } else {
                    editOffline = false;
                }
                promise.then(function() {
                    $scope.wikiLoaded = true;
                    editing = false;
                    canEdit = !!blockId;
                });
            }
        } else {
            promise = $q.when();
            canEdit = false;
        }
        return promise.catch(function(message) {
            $mmUtil.showErrorModalDefault(message, 'Error getting wiki data.');
            return $ionicHistory.goBack();
        }).finally(function() {
            if (!canEdit) {
                $mmUtil.showModal('mm.core.notice', 'mma.mod_wiki.cannoteditpage').then(function() {
                    $ionicHistory.goBack();
                });
            }
        });
    }
    function retrieveModuleInfo(wikiId) {
        if (module.id && courseId) {
            return $q.when();
        }
        var promise = module.id ? $q.when(module) : $mmCourse.getModuleBasicInfoByInstance(wikiId, 'wiki');
        return promise.then(function(info) {
            module = info;
            $scope.componentId = module.id;
            if (!courseId && module.course) {
                courseId = module.course;
            } else if (!courseId) {
                return $mmCourseHelper.getModuleCourseIdByInstance(wikiId, 'wiki').then(function(course) {
                    courseId = course;
                });
            }
            return $q.when();
        });
    }
    $scope.firstRender = function() {
        originalContent = $scope.page.text;
    };
    $scope.$on('$ionicView.afterLeave', function(event) {
        if (event.targetScope.saveAndGoParams) {
            return $state.go('site.mod_wiki', event.targetScope.saveAndGoParams);
        }
    });
    fetchWikiPageData().then(function() {
        if (blockId && !$scope.$$destroyed) {
            var newBlockId = $mmaModWikiSync.subwikiBlockId(subwikiId, wikiId, userId, groupId);
            if (newBlockId != blockId) {
                $mmSyncBlock.unblockOperation(mmaModWikiComponent, blockId);
                blockId = newBlockId;
                $mmSyncBlock.blockOperation(mmaModWikiComponent, blockId);
            }
        }
    }).finally(function() {
        $scope.wikiLoaded = true;
    });
    $scope.$on('$destroy', function() {
        $interval.cancel(renewLockInterval);
        if (blockId) {
            $mmSyncBlock.unblockOperation(mmaModWikiComponent, blockId);
        }
    });
}]);

angular.module('mm.addons.mod_wiki')
.controller('mmaModWikiIndexCtrl', ["$q", "$scope", "$stateParams", "$mmCourse", "$mmUser", "$mmGroups", "$ionicPopover", "$mmUtil", "$state", "$mmSite", "$mmaModWiki", "$ionicTabsDelegate", "$ionicHistory", "$translate", "mmaModWikiSubwikiPagesLoaded", "$mmCourseHelper", "$mmText", "mmaModWikiComponent", "$mmEvents", "$ionicScrollDelegate", "$mmaModWikiOffline", "mmaModWikiPageCreatedEvent", "mmaModWikiSubwikiAutomSyncedEvent", "$mmaModWikiSync", "mmaModWikiManualSyncedEvent", "$mmApp", "mmCoreEventOnlineStatusChanged", function($q, $scope, $stateParams, $mmCourse, $mmUser, $mmGroups, $ionicPopover, $mmUtil, $state,
        $mmSite, $mmaModWiki, $ionicTabsDelegate, $ionicHistory, $translate, mmaModWikiSubwikiPagesLoaded, $mmCourseHelper,
        $mmText, mmaModWikiComponent, $mmEvents, $ionicScrollDelegate,
        $mmaModWikiOffline, mmaModWikiPageCreatedEvent, mmaModWikiSubwikiAutomSyncedEvent, $mmaModWikiSync,
        mmaModWikiManualSyncedEvent, $mmApp, mmCoreEventOnlineStatusChanged) {
    var module = $stateParams.module || {},
        courseId = $stateParams.courseid,
        action = $stateParams.action || 'page',
        currentPage = $stateParams.pageid || false,
        pageTitle = $stateParams.pagetitle,
        isCurrentView = true,
        popover, wiki, currentSubwiki, loadedSubwikis, tabsDelegate, onlineObserver,
        currentPageObj, newPageObserver, syncObserver, syncObserverManual, scrollView, ignoreManualSyncEvent;
    $scope.title = pageTitle || module.name;
    $scope.description = module.description;
    $scope.mainpage = !currentPage && !pageTitle;
    $scope.moduleUrl = module.url;
    $scope.courseId = courseId;
    $scope.component = mmaModWikiComponent;
    $scope.canEdit = false;
    $scope.subwikiData = {
        subwikiSelected: 0,
        userSelected: 0,
        groupSelected: 0,
        subwikis: [],
        count: 0
    };
    $scope.refreshIcon = 'spinner';
    $scope.syncIcon = 'spinner';
    $scope.pageStr = $translate.instant('mma.mod_wiki.page');
    $scope.moduleName = $mmCourse.translateModuleName('wiki');
    $scope.tabsDelegateName = 'mmaModWikiTabs_'+(module.id || 0) + '_' + (currentPage || 0) + '_' +  new Date().getTime();
    tabsDelegate = $ionicTabsDelegate.$getByHandle($scope.tabsDelegateName);
    $scope.showSubwikiPicker = function(e) {
        popover.show(e);
    };
    $scope.goHomeWiki = function(e) {
        var backTimes = getHistoryBackCounter();
        $ionicHistory.goBack(backTimes);
    };
    $scope.gotoPage = function(page) {
        if (!page.id) {
            if (currentPage || !pageTitle || page.title != pageTitle) {
                var stateParams = {
                    module: module,
                    moduleid: module.id,
                    courseid: courseId,
                    pagetitle: page.title,
                    pageid: null,
                    wikiid: wiki.id,
                    subwikiid: page.subwikiid,
                    action: 'page'
                };
                return $state.go('site.mod_wiki', stateParams);
            }
        } else if (currentPage != page.id) {
            return fetchPageContents(page.id).then(function(page) {
                var stateParams = {
                    module: module,
                    moduleid: module.id,
                    courseid: courseId,
                    pageid: page.id,
                    pagetitle: page.title,
                    wikiid: page.wikiid,
                    subwikiid: page.subwikiid,
                    action: 'page'
                };
                return $state.go('site.mod_wiki', stateParams);
            });
        }
        tabsDelegate.select(0);
    };
    $scope.gotoEditPage = function() {
        if (!$scope.canEdit) {
            return;
        }
        if (currentPageObj) {
            var stateParams = {
                module: module,
                moduleid: module.id,
                courseid: courseId,
                pageid: currentPageObj.id,
                pagetitle: currentPageObj.title,
                subwikiid: currentPageObj.subwikiid
            };
            if (currentSubwiki) {
                stateParams.wikiid = currentSubwiki.wikiid;
                stateParams.userid = currentSubwiki.userid;
                stateParams.groupid = currentSubwiki.groupid;
            }
            return $state.go('site.mod_wiki-edit', stateParams);
        } else if (currentSubwiki) {
            return gotoCreateFirstPage();
        }
    };
    $scope.gotoNewPage = function() {
        if (!$scope.canEdit) {
            return;
        }
        if (currentPageObj) {
            var stateParams = {
                module: module,
                moduleid: module.id,
                courseid: courseId,
                subwikiid: currentPageObj.subwikiid
            };
            if (currentSubwiki) {
                stateParams.wikiid = currentSubwiki.wikiid;
                stateParams.userid = currentSubwiki.userid;
                stateParams.groupid = currentSubwiki.groupid;
            }
            return $state.go('site.mod_wiki-edit', stateParams);
        } else if (currentSubwiki) {
            return gotoCreateFirstPage();
        }
    };
    function gotoCreateFirstPage() {
        var stateParams = {
            module: module,
            moduleid: module.id,
            courseid: courseId,
            pagetitle: wiki.firstpagetitle,
            wikiid: currentSubwiki.wikiid,
            userid: currentSubwiki.userid,
            groupid: currentSubwiki.groupid
        };
        return $state.go('site.mod_wiki-edit', stateParams);
    }
    $scope.gotoSubwiki = function(subwikiId, userId, groupId, canEdit) {
        if (subwikiId > 0 || canEdit) {
            popover.hide();
            if (subwikiId != currentSubwiki.id || userId != currentSubwiki.userid || groupId != currentSubwiki.groupid) {
                var stateParams = {
                    module: module,
                    moduleid: module.id,
                    courseid: courseId,
                    pageid: null,
                    pagetitle: null,
                    wikiid: wiki.id,
                    subwikiid: subwikiId,
                    userid: userId,
                    groupid: groupId,
                    action: tabsDelegate.selectedIndex() == 0 ? 'page' : 'map'
                };
                return $state.go('site.mod_wiki', stateParams);
            }
        }
    };
    function fetchWikiData(refresh, sync, showErrors) {
        $scope.isOnline = $mmApp.isOnline();
        var id = module.id || $stateParams.wikiid,
            paramName = module.id ? 'coursemodule' : 'id';
        return $mmaModWiki.getWiki(courseId, id, paramName).then(function(wikiData) {
            wiki = wikiData;
            $scope.wiki = wiki;
            if (sync) {
                return syncWiki(showErrors).catch(function() {
                });
            }
        }).then(function() {
            if ($scope.pageWarning) {
                return $q.reject();
            }
            var promise;
            if (isCurrentView) {
                $scope.showHomeButton = getHistoryBackCounter() < 0;
            }
            if (!module.url) {
                promise = $mmCourse.getModule(wiki.coursemodule, wiki.course, null, true);
            } else {
                module.instance = wiki.id;
                promise = $q.when(module);
            }
            return promise.then(function(mod) {
                module = mod;
                $scope.title = $scope.title || wiki.title;
                $scope.description = wiki.intro || module.description;
                $scope.moduleUrl = module.url;
                $scope.componentId = module.id;
                return $mmGroups.getActivityGroupMode(wiki.coursemodule).then(function(groupmode) {
                    if (groupmode === $mmGroups.SEPARATEGROUPS || groupmode === $mmGroups.VISIBLEGROUPS) {
                        promise = $mmGroups.getActivityAllowedGroups(wiki.coursemodule);
                    } else {
                        promise = $q.when([]);
                    }
                    return promise.then(function(userGroups) {
                        return fetchSubwikis(wiki.id).then(function() {
                            var subwikiList = $mmaModWiki.getSubwikiList(wiki.id);
                            if (!subwikiList) {
                                return createSubwikiList(userGroups);
                            }
                            $scope.subwikiData.count = subwikiList.count;
                            setSelectedWiki($stateParams.subwikiid, $stateParams.userid, $stateParams.groupid);
                            if (!isAnySubwikiSelected()) {
                                setSelectedWiki(subwikiList.subwikiSelected, subwikiList.userSelected, subwikiList.groupSelected);
                            }
                            $scope.subwikiData.subwikis = subwikiList.subwikis;
                            return $q.when();
                        });
                    }).then(function() {
                        if ($scope.subwikiData.count > 1) {
                            handleSubwikiPopover();
                        }
                        if (!refresh) {
                            tabsDelegate.select(action == 'map' ? 1 : 0);
                        }
                        if (!isAnySubwikiSelected() || $scope.subwikiData.count <= 0) {
                            return $q.reject($translate.instant('mma.mod_wiki.errornowikiavailable'));
                        }
                    }).then(function() {
                        return fetchWikiPage();
                    }).then(function() {
                        $mmCourseHelper.fillContextMenu($scope, module, courseId, refresh, mmaModWikiComponent);
                    });
                });
            });
        }).catch(function(message) {
            if ($scope.pageWarning) {
                return $q.reject();
            }
            if (!refresh && !wiki) {
                return refreshAllData(sync, showErrors);
            }
            $mmUtil.showErrorModalDefault(message, 'Error getting wiki data.');
            return $q.reject();
        });
    }
    $scope.expandDescription = function() {
        $mmText.expandText($translate.instant('mm.core.description'), $scope.description, false, mmaModWikiComponent, module.id);
    };
    $scope.removeFiles = function() {
        $mmCourseHelper.confirmAndRemove(module, courseId);
    };
    $scope.prefetch = function() {
        $mmCourseHelper.contextMenuPrefetch($scope, module, courseId);
    };
    function handleSubwikiPopover() {
        $ionicPopover.fromTemplateUrl('addons/mod/wiki/templates/subwiki_picker.html', {
            scope: $scope
        }).then(function(po) {
            popover = po;
        });
    }
    function createSubwikiList(userGroups) {
        var subwikiList = [],
            promises = [],
            userGroupsIds = [],
            allParticipants = false,
            showMyGroupsLabel = false,
            multiLevelList = false,
            currentUserId = $mmSite.getUserId() || false,
            allParticipantsTitle = $translate.instant('mm.core.allparticipants'),
            nonInGroupTitle = $translate.instant('mma.mod_wiki.notingroup'),
            myGroupsTitle = $translate.instant('mm.core.mygroups'),
            otherGroupsTitle = $translate.instant('mm.core.othergroups');
        $scope.subwikiData.subwikis = [];
        setSelectedWiki($stateParams.subwikiid, $stateParams.userid, $stateParams.groupid);
        $scope.subwikiData.count = 0;
        if (userGroups.length > 0) {
            userGroupsIds = userGroups.map(function(g) {
                return g.id;
            });
        }
        angular.forEach(loadedSubwikis, function(subwiki) {
            var groupIdx,
                promise,
                groupId = parseInt(subwiki.groupid, 10),
                groupLabel = "",
                userId = parseInt(subwiki.userid, 10);
            if (groupId == 0 && userId == 0) {
                if (!allParticipants) {
                    subwikiList.unshift({
                        name: allParticipantsTitle,
                        id: subwiki.id,
                        user: userId,
                        group: groupId,
                        groupLabel: "",
                        canedit: subwiki.canedit
                    });
                    allParticipants = true;
                }
            } else {
                if (groupId != 0 && userGroupsIds.length > 0) {
                    groupIdx = userGroupsIds.indexOf(groupId);
                    if (groupIdx > -1) {
                        groupLabel = userGroups[groupIdx].name;
                    }
                } else {
                    groupLabel = nonInGroupTitle;
                }
                if (userId != 0) {
                    promise = $mmUser.getProfile(userId, null, true).then(function(user) {
                        subwikiList.push({
                            name: user.fullname,
                            id: subwiki.id,
                            user: userId,
                            group: groupId,
                            groupLabel: groupLabel,
                            canedit: subwiki.canedit
                        });
                    });
                    promises.push(promise);
                    if (!multiLevelList && groupId != 0) {
                        multiLevelList = true;
                    }
                } else {
                    subwikiList.push({
                        name: groupLabel,
                        id: subwiki.id,
                        user: userId,
                        group: groupId,
                        groupLabel: groupLabel,
                        canedit: subwiki.canedit
                    });
                    showMyGroupsLabel = true;
                }
            }
        });
        return $q.all(promises).then(function() {
            var groupValue = -1,
                grouping;
            subwikiList.sort(function(a, b) {
                return a.group - b.group;
            });
            $scope.subwikiData.count = subwikiList.length;
            if ((!$stateParams.subwikiid || (!$stateParams.userid && !$stateParams.groupid)) && !isAnySubwikiSelected() &&
                    subwikiList.length > 0) {
                var firstCanEdit = false;
                    candidateNoFirstPage = false,
                    candidateFirstPage = false;
                for (var x in subwikiList) {
                    var subwiki = subwikiList[x];
                    if (subwiki.canedit) {
                        var candidateSubwikiId = false;
                        if (subwiki.user > 0) {
                            if (currentUserId == subwiki.user) {
                                candidateSubwikiId = subwiki.id;
                            }
                        } else if (subwiki.group > 0) {
                            if (showMyGroupsLabel) {
                                candidateSubwikiId = subwiki.id;
                            }
                        } else if (subwiki.id > 0) {
                            candidateSubwikiId = subwiki.id;
                        }
                        if (candidateSubwikiId !== false) {
                            if (candidateSubwikiId > 0) {
                                candidateFirstPage = x;
                                break;
                            } else if (candidateNoFirstPage === false) {
                                candidateNoFirstPage = x;
                            }
                        } else if (firstCanEdit === false) {
                            firstCanEdit = x;
                        }
                    }
                }
                var subWikiToTake;
                if (candidateFirstPage !== false) {
                    subWikiToTake = candidateFirstPage;
                } else if (candidateNoFirstPage !== false) {
                    subWikiToTake = candidateNoFirstPage;
                } else if (firstCanEdit !== false) {
                    subWikiToTake = firstCanEdit;
                } else {
                    subWikiToTake = 0;
                }
                if (typeof subwikiList[subWikiToTake] != "undefined") {
                    setSelectedWiki(subwikiList[subWikiToTake].id, subwikiList[subWikiToTake].user,
                        subwikiList[subWikiToTake].group);
                }
            }
            if (multiLevelList) {
                for (var i in subwikiList) {
                    var subwiki = subwikiList[i];
                    if (subwiki.group !== groupValue) {
                        grouping = {label: subwiki.groupLabel, subwikis: []};
                        groupValue = subwiki.group;
                        $scope.subwikiData.subwikis.push(grouping);
                    }
                    grouping.subwikis.push(subwiki);
                }
            } else if (showMyGroupsLabel) {
                var noGrouping = {label: "", subwikis: []},
                    myGroupsGrouping = {label: myGroupsTitle, subwikis: []},
                    otherGroupsGrouping = {label: otherGroupsTitle, subwikis: []};
                for (var i in subwikiList) {
                    var subwiki = subwikiList[i];
                    if (typeof subwiki.canedit == 'undefined') {
                        noGrouping.subwikis.push(subwiki);
                    } else if (subwiki.canedit) {
                        myGroupsGrouping.subwikis.push(subwiki);
                    } else {
                        otherGroupsGrouping.subwikis.push(subwiki);
                    }
                }
                if (noGrouping.subwikis.length > 0) {
                    $scope.subwikiData.subwikis.push(noGrouping);
                }
                if (myGroupsGrouping.subwikis.length > 0) {
                    $scope.subwikiData.subwikis.push(myGroupsGrouping);
                }
                if (otherGroupsGrouping.subwikis.length > 0) {
                    $scope.subwikiData.subwikis.push(otherGroupsGrouping);
                }
            } else {
                $scope.subwikiData.subwikis.push({label: "", subwikis: subwikiList});
            }
            $mmaModWiki.setSubwikiList(wiki.id, $scope.subwikiData.subwikis, $scope.subwikiData.count,
                $scope.subwikiData.subwikiSelected, $scope.subwikiData.userSelected, $scope.subwikiData.groupSelected);
        });
    }
    function getHistoryBackCounter() {
        var view, historyInstance, backTimes = 0,
            backViewId = $ionicHistory.currentView().backViewId;
        if (!wiki.id) {
            return 0;
        }
        while (backViewId) {
            view = $ionicHistory.viewHistory().views[backViewId];
            if (view.stateName != 'site.mod_wiki') {
                break;
            }
            historyInstance = view.stateParams.wikiid ? view.stateParams.wikiid : view.stateParams.module.instance;
            if (historyInstance && historyInstance == wiki.id) {
                backTimes--;
            } else {
                break;
            }
            backViewId = view.backViewId;
        }
        return backTimes;
    }
    function fetchSubwikis(wikiId) {
        return $mmaModWiki.getSubwikis(wikiId).then(function(subwikis) {
            loadedSubwikis = subwikis;
            return $mmaModWikiOffline.subwikisHaveOfflineData(subwikis).then(function(hasOffline) {
                $scope.wikiHasOffline = hasOffline;
            });
        });
    }
    function fetchWikiPage() {
        currentSubwiki = false;
        for (var x in loadedSubwikis) {
            if ($scope.isSubwikiSelected(loadedSubwikis[x])) {
                currentSubwiki = loadedSubwikis[x];
                break;
            }
        }
        if (!currentSubwiki) {
            return $q.reject();
        }
        setSelectedWiki(currentSubwiki.id, currentSubwiki.userid, currentSubwiki.groupid);
        return fetchSubwikiPages(currentSubwiki).then(function() {
            $scope.canEdit = currentSubwiki.canedit && $mmaModWiki.isPluginEnabledForEditing();
            return fetchPageContents(currentPage).then(function(pageContents) {
                if (pageContents) {
                    $scope.title = pageContents.title;
                    setSelectedWiki(pageContents.subwikiid, pageContents.userid, pageContents.groupid);
                    $scope.pageContent = replaceEditLinks(pageContents.cachedcontent);
                    $scope.canEdit = pageContents.caneditpage && $mmaModWiki.isPluginEnabledForEditing();
                    currentPageObj = pageContents;
                }
            });
        });
    }
    function replaceEditLinks(content) {
        content = content.trim();
        if (content.length > 0) {
            var url = $mmSite.getURL();
            content = content.replace(/href="edit\.php/g, 'href="'+url+'/mod/wiki/edit.php');
        }
        return content;
    }
    function fetchSubwikiPages(subwiki) {
        return $mmaModWiki.getSubwikiPages(subwiki.wikiid, subwiki.groupid, subwiki.userid).then(function(subwikiPages) {
            if (!currentPage && !pageTitle) {
                angular.forEach(subwikiPages, function(subwikiPage) {
                    if (!currentPage && subwikiPage.firstpage) {
                        currentPage = subwikiPage.id;
                    }
                });
            }
            return $mmaModWikiOffline.getSubwikiNewPages(subwiki.id, subwiki.wikiid, subwiki.userid, subwiki.groupid)
                    .then(function(offlinePages) {
                if (!currentPage) {
                    var searchTitle = pageTitle ? pageTitle : wiki.firstpagetitle;
                    angular.forEach(offlinePages, function(subwikiPage) {
                        if (!currentPage && subwikiPage.title == searchTitle) {
                            pageTitle = subwikiPage.title;
                        }
                    });
                }
                $scope.subwikiPages = $mmaModWiki.sortPagesByTitle(subwikiPages.concat(offlinePages));
                $scope.$broadcast(mmaModWikiSubwikiPagesLoaded, $scope.subwikiPages);
                if (!currentPage && !pageTitle && subwikiPages.length > 0) {
                    return $q.reject();
                }
            });
        });
    }
    function fetchPageContents(pageId) {
        if (!pageId) {
            var title = pageTitle || wiki.firstpagetitle;
            return $mmaModWikiOffline.getNewPage(title, currentSubwiki.id, currentSubwiki.wikiid, currentSubwiki.userid,
                    currentSubwiki.groupid).then(function(offlinePage) {
                $scope.pageIsOffline = true;
                if (!newPageObserver) {
                    newPageObserver = $mmEvents.on(mmaModWikiPageCreatedEvent, function(data) {
                        if (data.siteid == $mmSite.getId() && data.subwikiid == currentSubwiki.id && data.pagetitle == title) {
                            currentPage = data.pageid;
                            showSpinnerAndFetch(false, true).then(function() {
                                $mmaModWiki.logPageView(currentPage);
                            });
                            newPageObserver.off && newPageObserver.off();
                            newPageObserver = false;
                        }
                    });
                }
                return offlinePage;
            }).catch(function() {
            });
        }
        $scope.pageIsOffline = false;
        return $mmaModWiki.getPageContents(pageId);
    }
    function refreshAllData(sync, showErrors) {
        var promises = [$mmaModWiki.invalidateWikiData(courseId)];
        if (wiki) {
            promises.push($mmaModWiki.invalidateSubwikis(wiki.id));
            promises.push($mmGroups.invalidateActivityAllowedGroups(wiki.coursemodule));
            promises.push($mmGroups.invalidateActivityGroupMode(wiki.coursemodule));
        }
        if (currentSubwiki) {
            promises.push($mmaModWiki.invalidateSubwikiPages(currentSubwiki.wikiid));
            promises.push($mmaModWiki.invalidateSubwikiFiles(currentSubwiki.wikiid));
        }
        if (currentPage) {
            promises.push($mmaModWiki.invalidatePage(currentPage));
        }
        return $q.all(promises).finally(function() {
            return fetchWikiData(true, sync, showErrors);
        });
    }
    function showSpinnerAndFetch(refresh, sync, showErrors) {
        var promise;
        $scope.wikiLoaded = false;
        $scope.refreshIcon = 'spinner';
        $scope.syncIcon = 'spinner';
        scrollTop();
        promise = refresh ? refreshAllData(sync, showErrors) : fetchWikiData(true, sync, showErrors);
        return promise.finally(function() {
            $scope.wikiLoaded = true;
            $scope.refreshIcon = 'ion-refresh';
            $scope.syncIcon = 'ion-loop';
        });
    }
    function scrollTop() {
        if (!scrollView) {
            scrollView = $ionicScrollDelegate.$getByHandle('mmaModWikiIndexScroll');
        }
        scrollView && scrollView.scrollTop && scrollView.scrollTop();
    }
    fetchWikiData(false, true, false).then(function() {
        if (!currentPage && !pageTitle) {
            $mmaModWiki.logView(wiki.id).then(function() {
                $mmCourse.checkModuleCompletion(courseId, module.completionstatus);
            });
        } else if (currentPage) {
            $mmaModWiki.logPageView(currentPage);
        }
    }).finally(function() {
        $scope.wikiLoaded = true;
        $scope.refreshIcon = 'ion-refresh';
        $scope.syncIcon = 'ion-loop';
    });
    $scope.refreshWiki = function(showErrors) {
        if ($scope.wikiLoaded) {
            $scope.refreshIcon = 'spinner';
            $scope.syncIcon = 'spinner';
            return refreshAllData(true, showErrors).finally(function() {
                $scope.refreshIcon = 'ion-refresh';
                $scope.syncIcon = 'ion-loop';
                $scope.$broadcast('scroll.refreshComplete');
            });
        }
    };
    function syncWiki(showErrors) {
        return $mmaModWikiSync.syncWiki(wiki.id, courseId, wiki.coursemodule).then(function(result) {
            result.wikiid = wiki.id;
            if (result.updated) {
                ignoreManualSyncEvent = true;
                $mmEvents.trigger(mmaModWikiManualSyncedEvent, result);
            }
            if (result.warnings && result.warnings.length) {
                $mmUtil.showErrorModal($mmText.buildMessage(result.warnings));
            }
            if (currentSubwiki) {
                checkPageCreatedOrDiscarded(result.subwikis[currentSubwiki.id]);
            }
            return result.updated;
        }).catch(function(error) {
            if (showErrors) {
                $mmUtil.showErrorModalDefault(error, 'mm.core.errorsync', true);
            }
            return $q.reject();
        });
    }
    function checkPageCreatedOrDiscarded(data) {
        if (!currentPage && data) {
            var page,
                pageId;
            for (var i = 0, len = data.created.length; i < len; i++) {
                page = data.created[i];
                if (page.title == pageTitle) {
                    pageId = page.pageid;
                    break;
                }
            }
            if (pageId) {
                currentPage = pageId;
            } else {
                for (i = 0, len = data.discarded.length; i < len; i++) {
                    page = data.discarded[i];
                    if (page.title == pageTitle) {
                        $scope.pageWarning = page.warning;
                        $scope.pageContent = '';
                        $scope.pageIsOffline = false;
                        $scope.wikiHasOffline = false;
                    }
                }
            }
        }
    }
    var skip = true;
    $scope.$on('$ionicView.enter', function() {
        isCurrentView = true;
        if (skip) {
            skip = false;
            return;
        }
        var forwardView = $ionicHistory.forwardView();
        if (forwardView && forwardView.stateName === 'site.mod_wiki-edit') {
            showSpinnerAndFetch(false, true);
        }
    });
    $scope.$on('$ionicView.beforeLeave', function() {
        isCurrentView = false;
    });
    onlineObserver = $mmEvents.on(mmCoreEventOnlineStatusChanged, function(online) {
        $scope.isOnline = online;
    });
    syncObserver = $mmEvents.on(mmaModWikiSubwikiAutomSyncedEvent, function(data) {
        if (data && currentSubwiki && data.siteid == $mmSite.getId() && data.subwikiid == currentSubwiki.id &&
                data.wikiid == currentSubwiki.wikiid && data.userid == currentSubwiki.userid  &&
                data.groupid == currentSubwiki.groupid) {
            if (isCurrentView && data.warnings && data.warnings.length) {
                $mmUtil.showErrorModal($mmText.buildMessage(data.warnings));
            }
            checkPageCreatedOrDiscarded(data);
            if (!$scope.pageWarning) {
                showSpinnerAndFetch(true, false);
            }
        }
    });
    syncObserverManual = $mmEvents.on(mmaModWikiManualSyncedEvent, function(data) {
        if (data && wiki && data.siteid == $mmSite.getId() && data.wikiid == wiki.id) {
            if (ignoreManualSyncEvent) {
                ignoreManualSyncEvent = false;
                return;
            }
            if (currentSubwiki) {
                checkPageCreatedOrDiscarded(data.subwikis[currentSubwiki.id]);
            }
            if (!$scope.pageWarning) {
                showSpinnerAndFetch(false, false);
            }
        }
    });
    function setSelectedWiki(subwiki, user, group) {
        $scope.subwikiData.subwikiSelected = (subwiki = parseInt(subwiki, 10)) > 0 ? subwiki : 0;
        $scope.subwikiData.userSelected = parseInt(user, 10) || 0;
        $scope.subwikiData.groupSelected = parseInt(group, 10) || 0;
    }
    $scope.isSubwikiSelected = function(subwiki) {
        var subwikiId = parseInt(subwiki.id, 10) || 0;
        if (subwikiId > 0 && $scope.subwikiData.subwikiSelected > 0) {
            return subwikiId == $scope.subwikiData.subwikiSelected;
        }
        var userId = parseInt(subwiki.user, 10) || parseInt(subwiki.userid, 10) || 0,
            groupId = parseInt(subwiki.group, 10) || parseInt(subwiki.groupid, 10) || 0;
        return userId == $scope.subwikiData.userSelected && groupId == $scope.subwikiData.groupSelected;
    };
    function isAnySubwikiSelected() {
        return $scope.subwikiData.subwikiSelected > 0 || $scope.subwikiData.userSelected > 0 ||
            $scope.subwikiData.groupSelected > 0;
    }
    $scope.$on('$destroy', function() {
        popover && popover.remove();
        newPageObserver && newPageObserver.off && newPageObserver.off();
        syncObserver && syncObserver.off && syncObserver.off();
        syncObserverManual && syncObserverManual.off && syncObserverManual.off();
        onlineObserver && onlineObserver.off && onlineObserver.off();
    });
}]);

angular.module('mm.addons.mod_wiki')
.controller('mmaModWikiMapCtrl', ["$scope", "mmaModWikiSubwikiPagesLoaded", function($scope, mmaModWikiSubwikiPagesLoaded) {
    $scope.map = [];
    $scope.constructMap = function(subwikiPages) {
        var initialLetter = false,
            letter = {};
        $scope.map = [];
        subwikiPages = subwikiPages.sort(function(a, b) {
            var compareA = a.title.toLowerCase().trim(),
                compareB = b.title.toLowerCase().trim();
            return compareA.localeCompare(compareB);
        });
        angular.forEach(subwikiPages, function(page) {
            var letterCandidate = page.title.charAt(0).toLocaleUpperCase();
            if (letterCandidate !== initialLetter) {
                initialLetter = letterCandidate;
                letter = {label: letterCandidate, pages: []};
                $scope.map.push(letter);
            }
            letter.pages.push(page);
        });
    };
    var obsLoaded = $scope.$on(mmaModWikiSubwikiPagesLoaded, function(event, subwikiPages) {
        $scope.constructMap(subwikiPages);
    });
    $scope.constructMap($scope.subwikiPages);
    $scope.$on('$destroy', obsLoaded);
}]);

angular.module('mm.addons.mod_wiki')
.factory('$mmaModWikiHandlers', ["$mmCourse", "$mmaModWiki", "$state", "$mmContentLinksHelper", "$mmCourseHelper", "$mmUtil", "$q", "mmaModWikiComponent", "$mmaModWikiPrefetchHandler", "mmCoreDownloading", "mmCoreNotDownloaded", "mmCoreEventPackageStatusChanged", "mmCoreOutdated", "$mmCoursePrefetchDelegate", "$mmSite", "$mmEvents", "$mmaModWikiSync", "$mmContentLinkHandlerFactory", "$mmText", function($mmCourse, $mmaModWiki, $state, $mmContentLinksHelper, $mmCourseHelper, $mmUtil, $q,
        mmaModWikiComponent, $mmaModWikiPrefetchHandler, mmCoreDownloading, mmCoreNotDownloaded, mmCoreEventPackageStatusChanged,
        mmCoreOutdated, $mmCoursePrefetchDelegate, $mmSite, $mmEvents, $mmaModWikiSync, $mmContentLinkHandlerFactory, $mmText) {
    var self = {};
        self.courseContent = function() {
        var self = {};
                self.isEnabled = function() {
            return $mmaModWiki.isPluginEnabled();
        };
                self.getController = function(module, courseId) {
            return function($scope) {
                var downloadBtn = {
                        hidden: true,
                        icon: 'ion-ios-cloud-download-outline',
                        label: 'mm.core.download',
                        action: function(e) {
                            if (e) {
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            download();
                        }
                    },
                    refreshBtn = {
                        hidden: true,
                        icon: 'ion-android-refresh',
                        label: 'mm.core.refresh',
                        action: function(e) {
                            if (e) {
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            $mmaModWiki.invalidateContent(module.id, courseId).finally(function() {
                                download();
                            });
                        }
                    };
                $scope.title = module.name;
                $scope.icon = $mmCourse.getModuleIconSrc('wiki');
                $scope.class = 'mma-mod_wiki-handler';
                $scope.buttons = [downloadBtn, refreshBtn];
                $scope.spinner = true;
                $scope.action = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $state.go('site.mod_wiki', {module: module, moduleid: module.id, courseid: courseId});
                };
                function download() {
                    $scope.spinner = true;
                    $mmaModWikiPrefetchHandler.getDownloadSize(module, courseId).then(function(size) {
                        $mmUtil.confirmDownloadSize(size).then(function() {
                            $mmaModWikiPrefetchHandler.prefetch(module, courseId).catch(function() {
                                if (!$scope.$$destroyed) {
                                    $mmUtil.showErrorModal('mm.core.errordownloading', true);
                                }
                            });
                        }).catch(function() {
                            $scope.spinner = false;
                        });
                    }).catch(function(error) {
                        $scope.spinner = false;
                        $mmUtil.showErrorModalDefault(error, 'mm.core.errordownloading', true);
                    });
                }
                function showStatus(status) {
                    if (status) {
                        $scope.spinner = status === mmCoreDownloading;
                        downloadBtn.hidden = status !== mmCoreNotDownloaded;
                        refreshBtn.hidden = status !== mmCoreOutdated;
                    }
                }
                var statusObserver = $mmEvents.on(mmCoreEventPackageStatusChanged, function(data) {
                    if (data.siteid === $mmSite.getId() && data.componentId === module.id &&
                            data.component === mmaModWikiComponent) {
                        showStatus(data.status);
                    }
                });
                $mmCoursePrefetchDelegate.getModuleStatus(module, courseId).then(showStatus);
                $scope.$on('$destroy', function() {
                    statusObserver && statusObserver.off && statusObserver.off();
                });
            };
        };
        return self;
    };
        self.indexLinksHandler = $mmContentLinksHelper.createModuleIndexLinkHandler('mmaModWiki', 'wiki', $mmaModWiki);
        self.pageMapLinksHandler = $mmContentLinkHandlerFactory.createChild(
                /\/mod\/wiki\/(view|map)\.php.*([\&\?]pageid=\d+)/, '$mmCourseDelegate_mmaModWiki');
    self.pageMapLinksHandler.isEnabled = function(siteId, url, params, courseId) {
        var isMap = url.indexOf('mod/wiki/map.php') != -1;
        if (params.id && !isMap) {
            return false;
        } else if (isMap && (typeof params.option != 'undefined' && params.option != 5)) {
            return false;
        }
        courseId = courseId || params.courseid || params.cid;
        return $mmContentLinksHelper.isModuleIndexEnabled($mmaModWiki, siteId, courseId);
    };
    self.pageMapLinksHandler.getActions = function(siteIds, url, params, courseId) {
        courseId = courseId || params.courseid || params.cid;
        var pageId = parseInt(params.pageid, 10),
            action = url.indexOf('mod/wiki/map.php') != -1 ? 'map' : 'page';
        return [{
            action: function(siteId) {
                var modal = $mmUtil.showModalLoading();
                return getPageContents(pageId, siteId).then(function(page) {
                    var promise;
                    if (courseId) {
                        promise = $q.when(courseId);
                    } else {
                        promise = $mmCourseHelper.getModuleCourseIdByInstance(page.wikiid, 'wiki', siteId);
                    }
                    return promise.then(function(courseId) {
                        var stateParams = {
                            module: null,
                            moduleid: null,
                            courseid: courseId,
                            pageid: page.id,
                            pagetitle: page.title,
                            wikiid: page.wikiid,
                            subwikiid: page.subwikiid,
                            action: action
                        };
                        return $mmContentLinksHelper.goInSite('site.mod_wiki', stateParams, siteId);
                    });
                }).finally(function() {
                    modal.dismiss();
                });
            }
        }];
    };
        self.createLinksHandler = $mmContentLinkHandlerFactory.createChild(
                /\/mod\/wiki\/create\.php.*([\&\?]swid=\d+)/, '$mmCourseDelegate_mmaModWiki');
    self.createLinksHandler.isEnabled = function(siteId, url, params, courseId) {
        if (!$mmaModWiki.isPluginEnabledForEditing()) {
            return false;
        }
        courseId = courseId || params.courseid || params.cid;
        return $mmContentLinksHelper.isModuleIndexEnabled($mmaModWiki, siteId, courseId);
    };
    self.createLinksHandler.getActions = function(siteIds, url, params, courseId) {
        courseId = courseId || params.courseid || params.cid;
        return [{
            action: function(siteId) {
                params.swid = parseInt(params.swid, 10);
                getCreateLinkStateParams(params, courseId, siteId).then(function(stateParams) {
                    return $mmContentLinksHelper.goInSite('site.mod_wiki-edit', stateParams, siteId);
                });
            }
        }];
    };
        self.editLinksHandler = $mmContentLinkHandlerFactory.createChild(
                /\/mod\/wiki\/edit\.php.*([\&\?]pageid=\d+)/, '$mmCourseDelegate_mmaModWiki');
    self.editLinksHandler.isEnabled = function(siteId, url, params, courseId) {
        if (!$mmaModWiki.isPluginEnabledForEditing()) {
            return false;
        }
        courseId = courseId || params.courseid || params.cid;
        return $mmContentLinksHelper.isModuleIndexEnabled($mmaModWiki, siteId, courseId);
    };
    self.editLinksHandler.getActions = function(siteIds, url, params, courseId) {
        courseId = courseId || params.courseid || params.cid;
        var section = "";
        if (typeof params.section != 'undefined') {
            section = $mmText.decodeURIComponent(params.section.replace(/\+/g, ' '));
        }
        return [{
            action: function(siteId) {
                var stateParams = {
                    module: null,
                    moduleid: null,
                    courseid: courseId,
                    section: section,
                    pageid: parseInt(params.pageid, 10)
                };
                return $mmContentLinksHelper.goInSite('site.mod_wiki-edit', stateParams, siteId);
            }
        }];
    };
        function getPageContents(pageId, siteId) {
        return $mmaModWiki.getPageContents(pageId, siteId).then(function(page) {
            return page;
        }).catch(function(error) {
            $mmUtil.showErrorModalDefault(error, 'mma.mod_wiki.errorloadingpage', true);
            return $q.reject();
        });
    }
    function getCreateLinkStateParams(params, courseId, siteId) {
        var modal = $mmUtil.showModalLoading();
        return currentStateIsSameWiki(params.swid, siteId).then(function(isSameWiki) {
            if (isSameWiki) {
                if ($state.params.module && $state.params.module.id) {
                    return $state.params.module;
                } else if ($state.params.wikiid) {
                    return $mmCourse.getModuleBasicInfoByInstance($state.params.wikiid, 'wiki', siteId).catch(function() {
                    });
                }
            }
        }).then(function(module) {
            return {
                module: module,
                moduleid: module && module.id,
                courseid: courseId || (module && module.course) || $state.params.courseid,
                pagetitle: params.title,
                subwikiid: params.swid
            };
        }).finally(function() {
            modal.dismiss();
        });
    }
    function currentStateIsSameWiki(subwikiId, siteId) {
        if ($state.current.name == 'site.mod_wiki') {
            if ($state.params.subwikiid == subwikiId) {
                return $q.when(true);
            } else if ($state.params.pageid) {
                return $mmaModWiki.getPageContents($state.params.pageid, siteId).then(function(page) {
                    return page.subwikiid == subwikiId;
                }).catch(function() {
                    return false;
                });
            } else if ($state.params.wikiid) {
                return $mmaModWiki.wikiHasSubwiki($state.params.wikiid, subwikiId, siteId);
            } else if ($state.params.courseid && $state.params.module) {
                var moduleId = $state.params.moduleid || ($state.params.module && $state.params.module.id);
                if (moduleId) {
                    return $mmaModWiki.getWiki($state.params.courseid, moduleId, 'coursemodule', siteId).then(function(wiki) {
                        return $mmaModWiki.wikiHasSubwiki(wiki.id, subwikiId, siteId);
                    }).catch(function() {
                        return false;
                    });
                }
            }
        }
        return $q.when(false);
    }
        self.syncHandler = function() {
        var self = {};
                self.execute = function(siteId) {
            return $mmaModWikiSync.syncAllWikis(siteId);
        };
                self.getInterval = function() {
            return 600000;
        };
                self.isSync = function() {
            return true;
        };
                self.usesNetwork = function() {
            return true;
        };
        return self;
    };
    return self;
}]);

angular.module('mm.addons.mod_wiki')
.factory('$mmaModWikiPrefetchHandler', ["$mmaModWiki", "mmaModWikiComponent", "$mmSite", "$mmFilepool", "$q", "$mmGroups", "$mmUtil", "$mmCourseHelper", "$mmCourse", "$mmPrefetchFactory", "$mmCoursePrefetchDelegate", function($mmaModWiki, mmaModWikiComponent, $mmSite, $mmFilepool, $q, $mmGroups, $mmUtil,
        $mmCourseHelper, $mmCourse, $mmPrefetchFactory, $mmCoursePrefetchDelegate) {
    var self = $mmPrefetchFactory.createPrefetchHandler(mmaModWikiComponent);
    self.updatesNames = /^.*files$|^pages$/;
        self.download = function(module, courseId) {
        return self.prefetch(module, courseId);
    };
        self.getDownloadSize = function(module, courseId, siteId) {
        var promises = [];
        siteId = siteId || $mmSite.getId();
        promises.push(self.getFiles(module, courseId, siteId).then(function(files) {
            return $mmUtil.sumFileSizes(files);
        }));
        promises.push(getAllPages(module, courseId, siteId).then(function(pages) {
            var size = 0;
            angular.forEach(pages, function(page) {
                if (page.contentsize) {
                    size = size + page.contentsize;
                }
            });
            return {size: size, total: true};
        }));
        return $q.all(promises).then(function(sizes) {
            return sizes.reduce(function(a, b) {
                return {size: a.size + b.size, total: a.total && b.total};
            }, {size: 0, total: true});
        });
    };
        self.getFiles = function(module, courseId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmaModWiki.getWiki(courseId, module.id, 'coursemodule', siteId).then(function(wiki) {
            var introFiles = self.getIntroFilesFromInstance(module, wiki);
            return $mmaModWiki.getWikiFileList(wiki, siteId).then(function(files) {
                return introFiles.concat(files);
            });
        }).catch(function() {
            return [];
        });
    };
        function getAllPages(module, courseId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmaModWiki.getWiki(courseId, module.id, 'coursemodule', siteId).then(function(wiki) {
            return $mmaModWiki.getWikiPageList(wiki, siteId);
        }).catch(function() {
            return [];
        });
    }
        self.getTimemodified = function(module, courseId, siteId) {
        var promises = [];
        siteId = siteId || $mmSite.getId();
        promises.push(self.getFiles(module, courseId, siteId).then(function(files) {
            return $mmFilepool.getTimemodifiedFromFileList(files);
        }));
        promises.push(getAllPages(module, courseId, siteId).then(function(pages) {
            return getTimemodifiedFromPages(pages);
        }));
        return $q.all(promises).then(function(lastmodifiedTimes) {
            return Math.max.apply(null, lastmodifiedTimes);
        });
    };
        function getTimemodifiedFromPages(pages) {
        var lastmodified = 0;
        angular.forEach(pages, function(page) {
            if (page.timemodified > lastmodified) {
                lastmodified = page.timemodified;
            }
        });
        return lastmodified;
    }
        self.invalidateContent = function(moduleId, courseId) {
        return $mmaModWiki.invalidateContent(moduleId, courseId);
    };
        self.invalidateModule = function(module, courseId) {
        if ($mmCoursePrefetchDelegate.canCheckUpdates()) {
            return $q.when();
        }
        return $mmaModWiki.getWiki(courseId, module.id, 'coursemodule').then(function(wiki) {
            var promises = [];
            promises.push($mmaModWiki.invalidateWikiData(courseId));
            promises.push($mmaModWiki.invalidateSubwikis(wiki.id));
            promises.push($mmaModWiki.invalidateSubwikiFiles(wiki.id));
            promises.push($mmaModWiki.invalidateSubwikiPages(wiki.id));
            return $q.all(promises);
        });
    };
        self.isEnabled = function() {
        if ($mmaModWiki.isPluginEnabled()) {
            return  $mmSite.wsAvailable('mod_wiki_get_subwiki_files');
        }
        return false;
    };
        self.prefetch = function(module, courseId, single) {
        return self.prefetchPackage(module, courseId, single, prefetchWiki);
    };
        function prefetchWiki(module, courseId, single, siteId) {
        var userId = $mmSite.getUserId(),
            revision,
            timemod;
        return $mmFilepool.getPackageTimemodified(siteId, self.component, module.id).then(function(packageModified) {
            return getAllPages(module, courseId, siteId).then(function(pages) {
                var promises = [];
                angular.forEach(pages, function(page) {
                    if (page.timemodified > packageModified) {
                        promises.push($mmaModWiki.invalidatePage(page.id, siteId).finally(function() {
                            return $mmaModWiki.getPageContents(page.id, siteId);
                        }));
                    }
                });
                promises.push($mmGroups.getActivityGroupMode(module.id, siteId).then(function(groupmode) {
                    if (groupmode === $mmGroups.SEPARATEGROUPS || groupmode === $mmGroups.VISIBLEGROUPS) {
                        return $mmGroups.getActivityAllowedGroups(module.id, userId, siteId);
                    }
                    return $q.when();
                }));
                promises.push($mmaModWiki.getWiki(courseId, module.id, 'coursemodule', siteId).then(function(wiki) {
                    return $mmCourseHelper.getModuleCourseIdByInstance(wiki.id, 'wiki', siteId);
                }));
                promises.push($mmCourse.getModuleBasicInfo(module.id, siteId));
                promises.push(self.getFiles(module, courseId, siteId).then(function (files) {
                    var filePromises = [];
                    revision = $mmFilepool.getRevisionFromFileList(files);
                    angular.forEach(files, function(file) {
                        var url = file.fileurl;
                        filePromises.push($mmFilepool.addToQueueByUrl(siteId, url, self.component, module.id, file.timemodified));
                    });
                    return $q.all(filePromises);
                }));
                promises.push(self.getTimemodified(module, courseId, siteId).then(function(timemodified) {
                    timemod = timemodified;
                }));
                return $q.all(promises);
            });
        }).then(function() {
            return {
                revision: revision,
                timemod: timemod
            };
        });
    }
    return self;
}]);

angular.module('mm.addons.mod_wiki')
.factory('$mmaModWiki', ["$q", "$mmSite", "$mmSitesManager", "$mmFilepool", "$mmApp", "$mmaModWikiOffline", "$mmUtil", "$mmLang", "mmaModWikiComponent", function($q, $mmSite, $mmSitesManager, $mmFilepool, $mmApp, $mmaModWikiOffline, $mmUtil, $mmLang,
            mmaModWikiComponent) {
    var self = {},
        subwikiListsCache = {};
        function getWikiDataCacheKey(courseId) {
        return 'mmaModWiki:wiki:' + courseId;
    }
        function getWikiSubwikisCacheKey(wikiId) {
        return 'mmaModWiki:subwikis:' + wikiId;
    }
        function getWikiSubwikiPagesCacheKey(wikiId, groupId, userId) {
        return getWikiSubwikiPagesCacheKeyPrefix(wikiId) + ':' + groupId + ':' + userId;
    }
        function getWikiSubwikiPagesCacheKeyPrefix(wikiId) {
        return 'mmaModWiki:subwikipages:' + wikiId;
    }
        function getWikiSubwikiFilesCacheKey(wikiId, groupId, userId) {
        return getWikiSubwikiFilesCacheKeyPrefix(wikiId) + ':' + groupId + ':' + userId;
    }
        function getWikiSubwikiFilesCacheKeyPrefix(wikiId) {
        return 'mmaModWiki:subwikifiles:' + wikiId;
    }
        function getWikiPageCacheKey(pageId) {
        return 'mmaModWiki:page:' + pageId;
    }
        self.isPluginEnabled = function(siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return  site.wsAvailable('mod_wiki_get_wikis_by_courses') &&
                    site.wsAvailable('mod_wiki_get_subwikis') &&
                    site.wsAvailable('mod_wiki_get_subwiki_pages') &&
                    site.wsAvailable('mod_wiki_get_page_contents');
        });
    };
        self.isPluginEnabledForEditing = function() {
        return  $mmSite.wsAvailable('mod_wiki_get_page_for_editing') &&
                $mmSite.wsAvailable('mod_wiki_new_page') &&
                $mmSite.wsAvailable('mod_wiki_edit_page');
    };
        self.getWiki = function(courseId, id, paramName, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    courseids: [courseId]
                },
                preSets = {
                    cacheKey: getWikiDataCacheKey(courseId)
                };
            return site.read('mod_wiki_get_wikis_by_courses', params, preSets).then(function(response) {
                if (response.wikis) {
                    var currentWiki;
                    angular.forEach(response.wikis, function(wiki) {
                        if (wiki[paramName] == id) {
                            currentWiki = wiki;
                        }
                    });
                    if (currentWiki) {
                        return currentWiki;
                    }
                }
                return $q.reject();
            });
        });
    };
        self.getWikiFileList = function(wiki, siteId) {
        var files = [];
        siteId = siteId || $mmSite.getId();
        return self.getSubwikis(wiki.id, siteId).then(function(subwikis) {
            var promises = [];
            angular.forEach(subwikis, function(subwiki) {
                promises.push(self.getSubwikiFiles(subwiki.wikiid, subwiki.groupid, subwiki.userid, siteId).then(function(subwikiFiles) {
                    files = files.concat(subwikiFiles);
                }));
            });
            return $q.all(promises).then(function() {
                return files;
            });
        });
    };
        self.getWikiPageList = function(wiki, siteId) {
        var pages = [];
        siteId = siteId || $mmSite.getId();
        return self.getSubwikis(wiki.id, siteId).then(function(subwikis) {
            var promises = [];
            angular.forEach(subwikis, function(subwiki) {
                promises.push(self.getSubwikiPages(subwiki.wikiid, subwiki.groupid, subwiki.userid, null, null, null, siteId).then(
                    function(subwikiPages) {
                        pages = pages.concat(subwikiPages);
                    }
                ));
            });
            return $q.all(promises).then(function() {
                return pages;
            });
        });
    };
        self.getSubwikiList = function(wikiId) {
        return subwikiListsCache[wikiId];
    };
        self.setSubwikiList = function(wikiId, subwikis, count, subwikiId, userId, groupId) {
        var subwikiLists =  {
            count: count,
            subwikiSelected: subwikiId,
            userSelected: userId,
            groupSelected: groupId,
            subwikis: subwikis
        };
        subwikiListsCache[wikiId] = subwikiLists;
    };
        self.clearSubwikiList = function(wikiId) {
        if(typeof wikiId == 'undefined') {
            subwikiListsCache = {};
        } else {
            delete subwikiListsCache[wikiId];
        }
    };
        self.getSubwikis = function(wikiId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    wikiid: wikiId
                },
                preSets = {
                    cacheKey: getWikiSubwikisCacheKey(wikiId)
                };
            return site.read('mod_wiki_get_subwikis', params, preSets).then(function(response) {
                if (response.subwikis) {
                    return response.subwikis;
                }
                return $q.reject();
            });
        });
    };
        self.getSubwikiPages = function(wikiId, groupId, userId, sortBy, sortDirection, includeContent, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            groupId = groupId || -1;
            userId = userId || 0;
            sortBy = sortBy || 'title';
            sortDirection = sortDirection || 'ASC';
            includeContent = includeContent || 0;
            var params = {
                    wikiid: wikiId,
                    groupid: groupId,
                    userid: userId,
                    options: {
                        sortby: sortBy,
                        sortdirection: sortDirection,
                        includecontent: includeContent
                    }
                },
                preSets = {
                    cacheKey: getWikiSubwikiPagesCacheKey(wikiId, groupId, userId)
                };
            return site.read('mod_wiki_get_subwiki_pages', params, preSets).then(function(response) {
                if (response.pages) {
                    return response.pages;
                }
                return $q.reject();
            });
        });
    };
        self.getSubwikiFiles = function(wikiId, groupId, userId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            groupId = groupId || -1;
            userId = userId || 0;
            var params = {
                    wikiid: wikiId,
                    groupid: groupId,
                    userid: userId
                },
                preSets = {
                    cacheKey: getWikiSubwikiFilesCacheKey(wikiId, groupId, userId)
                };
            return site.read('mod_wiki_get_subwiki_files', params, preSets).then(function(response) {
                if (response.files) {
                    return response.files;
                }
                return $q.reject();
            });
        });
    };
        self.getPageContents = function(pageId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    pageid: pageId
                },
                preSets = {
                    cacheKey: getWikiPageCacheKey(pageId)
                };
            return site.read('mod_wiki_get_page_contents', params, preSets).then(function(response) {
                if (response.page) {
                    return response.page;
                }
                return $q.reject();
            });
        });
    };
        self.getPageForEditing = function(pageId, section, lockonly) {
        var params = {
                pageid: pageId
            };
        if (section) {
            params.section = section;
        }
        if (lockonly) {
            if ($mmSite.isVersionGreaterEqualThan('3.2')) {
                params.lockonly = 1;
            }
        }
        return $mmSite.write('mod_wiki_get_page_for_editing', params).then(function(response) {
            if (response.pagesection) {
                return response.pagesection;
            }
            return $q.reject();
        });
    };
        self.isTitleUsed = function(wikiId, subwikiId, title, siteId) {
        return self.getSubwikis(wikiId, siteId).then(function(subwikis) {
            for (var i = 0, len = subwikis.length; i < len; i++) {
                var subwiki = subwikis[i];
                if (subwiki.id == subwikiId) {
                    return subwiki;
                }
            }
            return $q.reject();
        }).then(function(subwiki) {
            return self.getSubwikiPages(wikiId, subwiki.groupid, subwiki.userid, null, null, false, siteId);
        }).then(function(pages) {
            for (var i = 0, len = pages.length; i < len; i++) {
                var page = pages[i];
                if (page.title == title) {
                    return true;
                }
            }
            return false;
        }).catch(function() {
            return false;
        });
    };
        self.newPage = function(title, content, subwikiId, wikiId, userId, groupId, siteId) {
        siteId = siteId || $mmSite.getId();
        if (!$mmApp.isOnline()) {
            return storeOffline();
        }
        return $mmaModWikiOffline.deleteNewPage(title, subwikiId, wikiId, userId, groupId, siteId).then(function() {
            return self.newPageOnline(title, content, subwikiId, wikiId, userId, groupId, siteId).then(function(pageId) {
                return pageId;
            }).catch(function(error) {
                if (error && error.wserror) {
                    return $q.reject(error.error);
                } else {
                    return storeOffline();
                }
            });
        });
        function storeOffline() {
            var promise;
            if (wikiId) {
                promise = self.isTitleUsed(wikiId, subwikiId, title, siteId).catch(function() {
                    return false;
                }).then(function(used) {
                    if (used) {
                        return $mmLang.translateAndReject('mma.mod_wiki.pageexists');
                    }
                });
            } else {
                promise = $q.when();
            }
            return promise.then(function() {
                return $mmaModWikiOffline.saveNewPage(title, content, subwikiId, wikiId, userId, groupId, siteId).then(function() {
                    return false;
                });
            });
        }
    };
        self.newPageOnline = function(title, content, subwikiId, wikiId, userId, groupId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var params = {
                    title: title,
                    content: content,
                    contentformat: 'html'
                };
            subwikiId = parseInt(subwikiId, 10) || 0;
            wikiId = parseInt(wikiId, 10) > 0 ? parseInt(wikiId, 10) : 0;
            if (subwikiId && subwikiId > 0) {
                params.subwikiid = subwikiId;
            } else if (wikiId) {
                params.wikiid = wikiId;
                params.userid = parseInt(userId, 10) > 0 ? parseInt(userId, 10) : 0;
                params.groupid = parseInt(groupId, 10) > 0 ? parseInt(groupId, 10) : 0;
            }
            return site.write('mod_wiki_new_page', params).catch(function(error) {
                return $q.reject({
                    error: error,
                    wserror: $mmUtil.isWebServiceError(error)
                });
            }).then(function(response) {
                if (response.pageid) {
                    return response.pageid;
                }
                return $q.reject({
                    wserror: true
                });
            });
        });
    };
        self.editPage = function(pageId, content, section) {
        var params = {
                pageid: pageId,
                content: content
            };
        if (section) {
            params.section = section;
        }
        return $mmSite.write('mod_wiki_edit_page', params).then(function(response) {
            if (response.pageid) {
                return response.pageid;
            }
            return $q.reject();
        });
    };
        self.invalidateWikiData = function(courseId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getWikiDataCacheKey(courseId));
        });
    };
        self.invalidateSubwikis = function(wikiId, siteId) {
        self.clearSubwikiList(wikiId);
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getWikiSubwikisCacheKey(wikiId));
        });
    };
        self.invalidateSubwikiPages = function(wikiId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKeyStartingWith(getWikiSubwikiPagesCacheKeyPrefix(wikiId));
        });
    };
        self.invalidateSubwikiFiles = function(wikiId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKeyStartingWith(getWikiSubwikiFilesCacheKeyPrefix(wikiId));
        });
    };
        self.invalidatePage = function(pageId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getWikiPageCacheKey(pageId));
        });
    };
        self.invalidateContent = function(moduleId, courseId, siteId) {
        siteId = siteId || $mmSite.getId();
        return self.getWiki(courseId, moduleId, 'coursemodule', siteId).then(function(wiki) {
            var ps = [];
            ps.push(self.invalidateWikiData(courseId, siteId));
            ps.push(self.invalidateSubwikis(wiki.id, siteId));
            ps.push(self.invalidateSubwikiPages(wiki.id, siteId));
            ps.push(self.invalidateSubwikiFiles(wiki.id, siteId));
            return $q.all(ps);
        });
    };
        self.invalidateFiles = function(moduleId, siteId) {
        return $mmFilepool.invalidateFilesByComponent(siteId, mmaModWikiComponent, moduleId);
    };
        self.logView = function(id, siteId) {
        if (id) {
            return $mmSitesManager.getSite(siteId).then(function(site) {
                var params = {
                    wikiid: id
                };
                return site.write('mod_wiki_view_wiki', params);
            });
        }
        return $q.reject();
    };
        self.logPageView = function(id, siteId) {
        if (id) {
            return $mmSitesManager.getSite(siteId).then(function(site) {
                var params = {
                    pageid: id
                };
                return site.write('mod_wiki_view_page', params);
            });
        }
        return $q.reject();
    };
        self.sortPagesByTitle = function(pages, desc) {
        return pages.sort(function (a, b) {
            var result = a.title >= b.title ? 1 : -1;
            if (!!desc) {
                result = -result;
            }
            return result;
        });
    };
        self.wikiHasSubwiki = function(wikiId, subwikiId, siteId) {
        return self.getSubwikis(wikiId, siteId).then(function(subwikis) {
            for (var i = 0; i < subwikis.length; i++) {
                if (subwikis[i].id == subwikiId) {
                    return true;
                }
            }
            return false;
        }).catch(function() {
            return false;
        });
    };
    return self;
}]);

angular.module('mm.addons.mod_wiki')
.constant('mmaModWikiNewPagesStore', 'mma_mod_wiki_new_pages_store')
.config(["$mmSitesFactoryProvider", "mmaModWikiNewPagesStore", function($mmSitesFactoryProvider, mmaModWikiNewPagesStore) {
    var stores = [
        {
            name: mmaModWikiNewPagesStore,
            keyPath: ['subwikiid', 'wikiid', 'userid', 'groupid', 'title'],
            indexes: [
                {
                    name: 'subwikiid'
                },
                {
                    name: 'wikiid'
                },
                {
                    name: 'userid'
                },
                {
                    name: 'groupid'
                },
                {
                    name: 'title'
                },
                {
                    name: 'subwikiWikiUserGroup',
                    keyPath: ['subwikiid', 'wikiid', 'userid', 'groupid']
                }
            ]
        }
    ];
    $mmSitesFactoryProvider.registerStores(stores);
}])
.factory('$mmaModWikiOffline', ["$mmSitesManager", "$log", "$mmSite", "$q", "mmaModWikiNewPagesStore", function($mmSitesManager, $log, $mmSite, $q, mmaModWikiNewPagesStore) {
    $log = $log.getInstance('$mmaModWikiOffline');
    var self = {};
        self.deleteNewPage = function(title, subwikiId, wikiId, userId, groupId,  siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            subwikiId = (subwikiId = parseInt(subwikiId, 10)) > 0 ? subwikiId : 0;
            wikiId = (wikiId = parseInt(wikiId, 10)) > 0 ? wikiId : 0;
            userId = (userId = parseInt(userId, 10)) > 0 ? userId : 0;
            groupId = (groupId = parseInt(groupId, 10)) > 0 ? groupId : 0;
            return site.getDb().remove(mmaModWikiNewPagesStore, [subwikiId, wikiId, userId, groupId, title]);
        });
    };
        self.getAllNewPages = function(siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.getDb().getAll(mmaModWikiNewPagesStore);
        });
    };
        self.getNewPage = function(title, subwikiId, wikiId, userId, groupId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            subwikiId = (subwikiId = parseInt(subwikiId, 10)) > 0 ? subwikiId : 0;
            wikiId = (wikiId = parseInt(wikiId, 10)) > 0 ? wikiId : 0;
            userId = (userId = parseInt(userId, 10)) > 0 ? userId : 0;
            groupId = (groupId = parseInt(groupId, 10)) > 0 ? groupId : 0;
            return site.getDb().get(mmaModWikiNewPagesStore, [subwikiId, wikiId, userId, groupId, title]);
        });
    };
        self.getSubwikiNewPages = function(subwikiId, wikiId, userId, groupId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            subwikiId = (subwikiId = parseInt(subwikiId, 10)) > 0 ? subwikiId : 0;
            wikiId = (wikiId = parseInt(wikiId, 10)) > 0 ? wikiId : 0;
            userId = (userId = parseInt(userId, 10)) > 0 ? userId : 0;
            groupId = (groupId = parseInt(groupId, 10)) > 0 ? groupId : 0;
            return site.getDb().whereEqual(mmaModWikiNewPagesStore, 'subwikiWikiUserGroup', [subwikiId, wikiId, userId, groupId]);
        });
    };
        self.getSubwikisNewPages = function(subwikis, siteId) {
        siteId = siteId || $mmSite.getId();
        var promises = [],
            pages = [];
        angular.forEach(subwikis, function(subwiki) {
            promises.push(self.getSubwikiNewPages(subwiki.id, subwiki.wikiid, subwiki.userid, subwiki.groupid, siteId)
                    .then(function(subwikiPages) {
                pages = pages.concat(subwikiPages);
            }));
        });
        return $q.all(promises).then(function() {
            return pages;
        });
    };
        self.saveNewPage = function(title, content, subwikiId, wikiId, userId, groupId, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var now = new Date().getTime(),
                entry = {
                    title: title,
                    cachedcontent: content,
                    subwikiid: (subwikiId = parseInt(subwikiId, 10)) > 0 ? subwikiId : 0,
                    wikiid: (wikiId = parseInt(wikiId, 10)) > 0 ? wikiId : 0,
                    userid: (userId = parseInt(userId, 10)) > 0 ? userId : 0,
                    groupid: (groupId = parseInt(groupId, 10)) > 0 ? groupId : 0,
                    contentformat: 'html',
                    timecreated: now,
                    timemodified: now,
                    caneditpage: true
                };
            return site.getDb().insert(mmaModWikiNewPagesStore, entry);
        });
    };
        self.subwikisHaveOfflineData = function(subwikis, siteId) {
        return self.getSubwikisNewPages(subwikis, siteId).then(function(pages) {
            return !!pages.length;
        }).catch(function() {
            return false;
        });
    };
    return self;
}]);

angular.module('mm.addons.mod_wiki')
.factory('$mmaModWikiSync', ["$q", "$log", "$mmApp", "$mmSitesManager", "$mmaModWikiOffline", "$mmSite", "$mmEvents", "$mmSync", "$mmLang", "mmaModWikiComponent", "$mmaModWiki", "$translate", "mmaModWikiSubwikiAutomSyncedEvent", "mmaModWikiSyncTime", "$mmGroups", "$mmCourse", "$mmSyncBlock", function($q, $log, $mmApp, $mmSitesManager, $mmaModWikiOffline, $mmSite, $mmEvents, $mmSync, $mmLang,
        mmaModWikiComponent, $mmaModWiki, $translate, mmaModWikiSubwikiAutomSyncedEvent, mmaModWikiSyncTime, $mmGroups,
        $mmCourse, $mmSyncBlock) {
    $log = $log.getInstance('$mmaModWikiSync');
    var self = $mmSync.createChild(mmaModWikiComponent, mmaModWikiSyncTime);
        self.syncAllWikis = function(siteId) {
        if (!$mmApp.isOnline()) {
            $log.debug('Cannot sync all wikis because device is offline.');
            return $q.reject();
        }
        var promise;
        if (!siteId) {
            $log.debug('Try to sync wikis in all sites.');
            promise = $mmSitesManager.getSitesIds();
        } else {
            $log.debug('Try to sync wikis in site ' + siteId);
            promise = $q.when([siteId]);
        }
        return promise.then(function(siteIds) {
            var sitePromises = [];
            angular.forEach(siteIds, function(siteId) {
                sitePromises.push($mmaModWikiOffline.getAllNewPages(siteId).then(function(pages) {
                    var promises = [],
                        subwikis = {};
                    angular.forEach(pages, function(page) {
                        var index = self.subwikiBlockId(page.subwikiid, page.wikiid, page.userid, page.groupid);
                        subwikis[index] = page;
                    });
                    angular.forEach(subwikis, function(subwiki) {
                        promises.push(self.syncSubwikiIfNeeded(subwiki.subwikiid, subwiki.wikiid, subwiki.userid, subwiki.groupid,
                                siteId).then(function(result) {
                            if (result && result.updated) {
                                $mmEvents.trigger(mmaModWikiSubwikiAutomSyncedEvent, {
                                    siteid: siteId,
                                    subwikiid: subwiki.subwikiid,
                                    wikiid: subwiki.wikiid,
                                    userid: subwiki.userid,
                                    groupid: subwiki.groupid,
                                    created: result.created,
                                    discarded: result.discarded,
                                    warnings: result.warnings
                                });
                            }
                        }));
                    });
                    return $q.all(promises);
                }));
            });
            return $q.all(sitePromises);
        });
    };
        self.syncSubwikiIfNeeded = function(subwikiId, wikiId, userId, groupId, siteId) {
        var index = self.subwikiBlockId(subwikiId, wikiId, userId, groupId);
        return self.isSyncNeeded(index, siteId).then(function(needed) {
            if (needed) {
                return self.syncSubwiki(subwikiId, wikiId, userId, groupId, siteId);
            }
        });
    };
        self.syncSubwiki = function(subwikiId, wikiId, userId, groupId, siteId) {
        siteId = siteId || $mmSite.getId();
        var syncPromise,
            result = {
                warnings: [],
                updated: false,
                created: [],
                discarded: []
            };
        var index = self.subwikiBlockId(subwikiId, wikiId, userId, groupId);
        if (self.isSyncing(index, siteId)) {
            return self.getOngoingSync(index, siteId);
        }
        if ($mmSyncBlock.isBlocked(mmaModWikiComponent, index, siteId)) {
            $log.debug('Cannot sync subwiki ' + index + ' because it is blocked.');
            var modulename = $mmCourse.translateModuleName('wiki');
            return $mmLang.translateAndReject('mm.core.errorsyncblocked', {$a: modulename});
        }
        $log.debug('Try to sync subwiki ' + index);
        syncPromise = $mmaModWikiOffline.getSubwikiNewPages(subwikiId, wikiId, userId, groupId, siteId).catch(function() {
            return [];
        }).then(function(pages) {
            if (!pages || !pages.length) {
                return;
            } else if (!$mmApp.isOnline()) {
                return $mmLang.translateAndReject('mm.core.networkerrormsg');
            }
            var promises = [];
            angular.forEach(pages, function(page) {
                promises.push($mmaModWiki.newPageOnline(page.title, page.cachedcontent, subwikiId, wikiId, userId, groupId, siteId)
                        .then(function(pageId) {
                    result.updated = true;
                    result.created.push({
                        pageid: pageId,
                        title: page.title
                    });
                    return $mmaModWikiOffline.deleteNewPage(page.title, subwikiId, wikiId, userId, groupId, siteId);
                }).catch(function(error) {
                    if (error && error.wserror) {
                        return $mmaModWikiOffline.deleteNewPage(page.title, subwikiId, wikiId, userId, groupId, siteId)
                                .then(function() {
                            result.updated = true;
                            var warning = $translate.instant('mm.core.warningofflinedatadeleted', {
                                component: $translate.instant('mma.mod_wiki.wikipage'),
                                name: page.title,
                                error: error.error
                            });
                            result.discarded.push({
                                title: page.title,
                                warning: warning
                            });
                            result.warnings.push(warning);
                        });
                    } else {
                        return $q.reject(error && error.error);
                    }
                }));
            });
            return $q.all(promises);
        }).then(function() {
            return self.setSyncTime(index, siteId).catch(function() {
            });
        }).then(function() {
            return result;
        });
        return self.addOngoingSync(index, syncPromise, siteId);
    };
        self.syncWiki = function(wikiId, courseId, cmId, siteId) {
        siteId = siteId || $mmSite.getId();
        return $mmaModWiki.getSubwikis(wikiId).then(function(subwikis) {
            var promises = [],
                result = {
                    warnings: [],
                    updated: false,
                    subwikis: {},
                    siteid: siteId
                };
            angular.forEach(subwikis, function(subwiki) {
                promises.push(self.syncSubwiki(subwiki.id, subwiki.wikiid, subwiki.userid, subwiki.groupid, siteId)
                        .then(function(data) {
                    if (data && data.updated) {
                        result.warnings = result.warnings.concat(data.warnings);
                        result.updated = true;
                        result.subwikis[subwiki.id] = {
                            created: data.created,
                            discarded: data.discarded
                        };
                    }
                }));
            });
            return $q.all(promises).then(function() {
                promises = [];
                if (result.updated) {
                    if (wikiId) {
                        promises.push($mmaModWiki.invalidateSubwikis(wikiId));
                        promises.push($mmaModWiki.invalidateSubwikiPages(wikiId));
                        promises.push($mmaModWiki.invalidateSubwikiFiles(wikiId));
                    }
                    if (courseId) {
                        promises.push($mmaModWiki.invalidateWikiData(courseId));
                    }
                    if (cmId) {
                        promises.push($mmGroups.invalidateActivityAllowedGroups(cmId));
                        promises.push($mmGroups.invalidateActivityGroupMode(cmId));
                    }
                }
                return $q.all(promises).catch(function() {
                }).then(function() {
                    return result;
                });
            });
        });
    };
    self.subwikiBlockId = function(subwikiId, wikiId, userId, groupId) {
        subwikiId = parseInt(subwikiId, 10) || 0;
        if (subwikiId && subwikiId > 0) {
            return subwikiId;
        }
        wikiId = (wikiId = parseInt(wikiId, 10)) > 0 ? wikiId : 0;
        if(wikiId) {
            userId = parseInt(userId, 10) > 0 ? parseInt(userId, 10) : 0;
            groupId = parseInt(groupId, 10) > 0 ? parseInt(groupId, 10) : 0;
            return wikiId + ':' + userId + ':' + groupId;
        }
        return false;
    };
    return self;
}]);

angular.module('mm.addons.messageoutput_airnotifier')
.controller('mmaMessageOutputAirnotifierDevicesCtrl', ["$stateParams", "$scope", "$mmUtil", "$translate", "$timeout", "$injector", "$mmaMessageOutputAirnotifier", function($stateParams, $scope, $mmUtil, $translate, $timeout, $injector,
        $mmaMessageOutputAirnotifier) {
    var $mmaPushNotifications = $injector.get('$mmaPushNotifications'),
        updateTimeout;
    $scope.title = $stateParams.title || $translate.instant('mm.settings.processorsettings');
    function fetchDevices() {
        return $mmaMessageOutputAirnotifier.getUserDevices().then(function(devices) {
            var pushId;
            if ($mmaPushNotifications) {
                pushId = $mmaPushNotifications.getPushId();
            }
            angular.forEach(devices, function(device) {
                device.enable = !!device.enable;
                device.current = pushId && pushId == device.pushid;
            });
            $scope.devices = devices;
        }).catch(function(message) {
            $mmUtil.showErrorModal(message);
        }).finally(function() {
            $scope.devicesLoaded = true;
        });
    }
    function updateDevicesAfterDelay() {
        $timeout.cancel(updateTimeout);
        updateTimeout = $timeout(function() {
            updateTimeout = null;
            updateDevices();
        }, 5000);
    }
    function updateDevices() {
        $mmaMessageOutputAirnotifier.invalidateUserDevices().finally(function() {
            $mmaMessageOutputAirnotifier.getUserDevices();
        });
    }
    fetchDevices();
    $scope.refreshDevices = function() {
        $mmaMessageOutputAirnotifier.invalidateUserDevices().finally(function() {
            fetchDevices().finally(function() {
                $scope.$broadcast('scroll.refreshComplete');
            });
        });
    };
    $scope.enableDevice = function(device, enable) {
        device.updating = true;
        $mmaMessageOutputAirnotifier.enableDevice(device.id, enable).then(function() {
            updateDevicesAfterDelay();
        }).catch(function(message) {
            $mmUtil.showErrorModal(message);
            device.enable = !device.enable;
        }).finally(function() {
            device.updating = false;
        });
    };
    $scope.$on('$destroy', function() {
        if (updateTimeout) {
            $timeout.cancel(updateTimeout);
            updateDevices();
        }
    });
}]);

angular.module('mm.addons.messageoutput_airnotifier')
.factory('$mmaMessageOutputAirnotifier', ["$mmSite", "$log", "$mmSitesManager", "$q", "mmCoreConfigConstants", function($mmSite, $log, $mmSitesManager, $q, mmCoreConfigConstants) {
    $log = $log.getInstance('$mmaMessageOutputAirnotifier');
    var self = {};
        self.enableDevice = function(deviceId, enable, siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var data = {
                    deviceid: deviceId,
                    enable: enable ? 1 : 0
                };
            return site.write('message_airnotifier_enable_device', data).then(function(result) {
                if (!result.success) {
                    if (result.warnings && result.warnings.length) {
                        return $q.reject(result.warnings[0].message);
                    }
                    return $q.reject();
                }
            });
        });
    };
        function getUserDevicesCacheKey() {
        return 'mmaMessageOutputAirnotifier:userDevices';
    }
        self.getUserDevices = function(siteId) {
        $log.debug('Get user devices');
        return $mmSitesManager.getSite(siteId).then(function(site) {
            var data = {
                    appid: mmCoreConfigConstants.app_id
                },
                preSets = {
                    cacheKey: getUserDevicesCacheKey()
                };
            return site.read('message_airnotifier_get_user_devices', data, preSets).then(function(data) {
                return data.devices;
            });
        });
    };
        self.invalidateUserDevices = function(siteId) {
        return $mmSitesManager.getSite(siteId).then(function(site) {
            return site.invalidateWsCacheForKey(getUserDevicesCacheKey());
        });
    };
        self.isEnabled = function() {
        return $mmSite.wsAvailable('message_airnotifier_enable_device') &&
                $mmSite.wsAvailable('message_airnotifier_get_user_devices');
    };
    return self;
}]);

angular.module('mm.addons.messageoutput_airnotifier')
.factory('$mmaMessageOutputAirnotifierHandlers', ["$mmaMessageOutputAirnotifier", "$state", function($mmaMessageOutputAirnotifier, $state) {
    var self = {};
        self.processorPreferences = function() {
        var self = {};
                self.getPreferenceLabel = function() {
            return 'mma.messageoutput_airnotifier.processorsettingsdesc';
        };
                self.isEnabled = function() {
            return $mmaMessageOutputAirnotifier.isEnabled();
        };
                self.openPreferencesView = function(processor) {
            $state.go('site.messageoutput-airnotifier-preferences', {title: processor.displayname});
        };
        return self;
    };
    return self;
}]);

angular.module('mm.core')

.constant('mmCoreConfigConstants', {
    "app_id" : "com.moodle.moodlemobile",
    "appname": "Moodle Mobile",
    "versioncode" : "2017",
    "versionname" : "3.2.1",
    "cache_expiration_time" : 300000,
    "default_lang" : "en",
    "languages": {"ar": "عربي", "bg": "Български", "ca": "Català", "cs": "Čeština", "da": "Dansk", "de": "Deutsch","en": "English", "es": "Español", "es-mx": "Español - México", "eu": "Euskara", "fa": "فارسی", "fr" : "Français", "he" : "עברית", "hu": "magyar", "it": "Italiano", "ja": "日本語","nl": "Nederlands", "pl": "Polski", "pt-br": "Português - Brasil", "pt": "Português - Portugal", "ro": "Română", "ru": "Русский", "sv": "Svenska", "tr" : "Türkçe", "zh-cn" : "简体中文", "zh-tw" : "正體中文"},
    "wsservice" : "moodle_mobile_app",
    "wsextservice" : "local_mobile",
    "demo_sites": {"student": {"url": "http://school.demo.moodle.net", "username": "student", "password": "moodle"}, "teacher": {"url": "http://school.demo.moodle.net", "username": "teacher", "password": "moodle"}, "cva": {"url": "http://mm.cvaconsulting.com/moodle", "username": "student", "password": "student"}},
    "gcmpn": "694767596569",
    "customurlscheme": "moodlemobile",
    "siteurl": "",
    "skipssoconfirmation": "false",
    "forcedefaultlanguage": "false",
    "privacypolicy": "https://moodle.org/mod/page/view.php?id=8148"
}
);